{"id1": "8216539", "id2": "14191679", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentAsStr", "getFileContentasStr", "getFileContentasText", "getFilecontentAsStream", "getFilecontentAsText", "getFileContentFromStream", "getFilecontentInStream", "getFileContentInText", "getFilecontentAsStr", "getFilecontentInString", "getFileContentFromText", "getFileContentFromStr", "getFileContentInStream", "getFileContentInString", "getFileContentAsStream", "getFilecontentInText", "getFileContentInStr", "getFileContentFromString", "getFilecontentInStr", "getFileContentAsText", "getFileContentasStream", "getFileContentasString", "getFilecontentAsString"], "filePath": ["singleLocation", "FileUrl", "baseLocation", " fileStr", "basepath", "FileStr", "singleUrl", "Filepath", "fileStr", "baseName", "resourceName", "singlePath", "resourcepath", "fileUrl", "fileName", "filepath", " fileUrl", "singlepath", "FilePath", "baseStr", "basePath", "FileName", "fileLocation", " filepath", "resourceLocation", "FileLocation", "resourcePath", "baseUrl"], "encoding": ["casing", "equlocking", "Enclocking", "cryption", "Encryption", "decoding", "coded", "Encging", "languageoding", "Encasing", "languageging", "languagepling", "equging", "Encpling", "languagelocking", "encpling", "encryption", "equoding", "decoded", "encging", "enclocking", "Encoded", "encoded", "decryption", "encasing", "equpling", "coding", "Encoding", "decasing"], "testURL": ["appUrl", " testUrl", "shorturl", "testingurl", "shortURL", "shortUrl", "testingRL", " testRL", "testUrl", "fileURL", "testRL", "testingUrl", "testingUR", "shortTL", "fileUrl", "appUR", "fileURI", "testUR", "testingURI", "testurl", " testTL", "testingURL", "testingTL", "fileRL", "testTL", " testURI", "TestUrl", "TestURL", "appURL", "testURI", "TestUR", "Testurl", "appurl", " testurl"], "input": ["ink", "text", "url", "ssl", "flow", "resource", "image", "parent", "null", "connection", "form", "act", "rc", "init", "acl", "data", "this", "socket", "raw", "inc", "output", "in", "entry", "audio", "result", "error", "out", "type", "inf", "conn", "through", "temp", "xml", "i", "source", "instance", "api", "reader", "config", "client", "qa", "pull", "stream", "inside", "ack", "inner", "Input", "element", "ac", "exec", "bin", "file", "upload", "dc", "binary", "ou", "op", "get", "path", "wrapper", "current", "active", "but", "enc", "http", "feed", "img"], "sw": ["writer", "wr", "iw", "we", "rx", "sf", "wt", "aw", "en", "rc", "sv", "io", "sb", "wrap", "fp", "now", " SW", "sn", "ow", "ew", "ws", "rw", "wx", "nw", "rew", "SW", "stream", "work", "wp", "web", "WS", "Sw", "ib", "sc", "cr", "sa", "sm", "ww", "sl", "w", "sk", "wb", "sh", "wrapper", "tw", "hw"]}}
{"id1": "2521141", "id2": "13595251", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["ame", "ize", "rm", "pe", "write", "image", " cp", "cp", "attach", "ge", "link", "sync", "zip", "archive", "paste", "clone", "clip", "type", "download", "ignore", "move", "cat", "Copy", "create", "source", "config", "open", "directory", "delete", "dump", "change", "load", "file", "share", "upload", "diff", "get", "transfer", "update", "opy", "cop"], "from_name": [" from_key", "source_memory", "fromMname", "source_name", " from_Name", "from_path", "fromMfile", "from_key", " from_names", "from_Name", "fromFfilename", "source_filename", "from__memory", "from_names", "from__filename", "fromFpath", "from__path", "fromFmemory", "fromMnames", "from_memory", "to_path", "fromFname", "source_path", "to_filename", "from_filename", "from__name"], "to_name": ["toampath", "toamfile", "to_Name", "to_path", "to_home", "toamname", " to_Name", " to_home", "toamhome", " to_path", "to_filename", "from_path", "from_filename"], "from_file": ["from___filename", "fromapplane", "source_resource", "from_resource", " from_filename", "fromCfilename", " from_folder", "from_files", " from_auto", "source_name", " from__name", "from__file", "from__resource", "from_auto", " from__file", "remote_function", "from___name", " from__filename", "from_lane", "fromCname", "fromappfile", " from_source", "from_folder", " from_files", "remote_file", " from__auto", "source_directory", "source_filename", "from_log", " from_directory", "from___file", "remote_log", "remote_lane", "source_files", "from___auto", "fromappfunction", "from_source", "fromCbrain", "from_function", "from__filename", "from__files", "fromCfile", "from__directory", "source_brain", "from__auto", "source_file", "from_brain", "from_directory", "from_filename", "fromapplog", "from__name"], "to_file": ["into_function", "tojname", "to_dir", "eto_name", "from_files", "into_use", "eto___remote", " to_filename", "tojuse", "to67file", "to64function", " to_queue", "to64file", "intojfunction", "tojfile", "to_class", "to64use", "to__dir", "to_queue", "from_model", "to_server", "to__name", "intojname", "source_filename", "eto_remote", "to_bar", "to___file", "to_use", "from_stream", "toJname", "to___name", "to_load", "source_files", "to_files", "to__file", "toJfile", "eto___file", "to67name", "toJbar", "to_model", " to_model", "eto___name", "intojfile", " to_class", "to__load", " to_files", "into_name", "eto_file", "to64name", "to_remote", "to___remote", "to_binary", "intojuse", "to_stream", "tojfunction", "source_file", "from_dir", "to_function", "from_bar", "toJstream", "to67dir", "from_binary", "into_file", "source_server", "to_filename", "from_load", "to67load"], "parent": ["ppa", "null", "term", "part", "search", "pa", "temp", "directory", "target", "div", "po", "cache", "string", "patch", "file", "ac", "root", "per", "owner", "page", "uri", "unit", "resource", "server", "connection", "Parent", "par", "remote", "port", "inc", "old", "folder", "test", "type", "tree", "point", "handler", "mother", "global", "path", "content", "url", "complete", "loc", "rule", "parents", "out", "api", "memory", "size", "user", "any", "id", "function", "location", "manager", "child", "session", "container", "home", "source", "client", "ip", "address", "name", "am", "full", "host", "pool", "current", "or", "author", "fat", "p"], "dir": ["url", "nav", "module", "build", "dr", "loc", "rel", "manager", "lock", "io", "die", "data", "md", "dec", "part", "folder", "group", "entry", "f", " directory", "dep", "in", "block", "exp", "d", "coll", "dev", "container", "out", "wd", "home", "cur", "ver", "dict", "cat", "class", "iter", "directory", "di", "keep", "db", "user", "tr", "r", "object", "id", "div", "cache", "ir", "file", "name", "dc", "def", "global", "root", "per", "dis", "path", "or", "Dir", "director", "doc"], "from": ["pe", "component", "From", "url", "fr", "one", "e", "server", "se", "without", "view", "connection", "form", "ce", "two", "io", "empty", "this", "link", "part", "range", "entry", "flo", "so", "cor", "ch", "feed", "bean", "conn", "source", "add", "api", "with", "parse", "client", "cm", "stream", "self", "base", "can", "address", "cache", "who", "low", "file", "con", "start", "name", "find", "by", "vol", "when", "left", "per", "ou", "get", "auto", "normal", "or", "ra", "context", "cf", "fe", "http", "cr"], "to": ["proxy", "too", "write", "one", "server", "dest", "connection", "two", "io", "fb", "store", "tto", "session", "sync", "socket", "not", "output", "via", "so", "flo", "about", "o", "storage", "su", "out", "type", "conn", "that", "see", "ver", "api", "top", "TO", "client", "size", "co", "with", "target", "pi", "db", "base", "will", "po", "token", "file", "by", "t", "per", "thro", "op", "until", "auto", "as", "or", "value", "To", "office", "fat", "http", "on"], "buffer": ["border", "wave", "buf", "bb", "page", "padding", "writer", "url", "default", "message", "resource", "server", "length", "b", "null", "data", "duration", "Buffer", "channel", "shape", "document", "batch", "read", "row", "texture", "total", "flush", "iter", "memory", "source", "reader", "header", "comment", "buff", "seed", "number", "queue", "position", "slice", "variable", "address", "character", "window", "binary", "reference", "layer", "uffer", "transfer", "feed", "block"], "bytes_read": ["bytes_load", "bytes_en", "byteslexcurrent", "bytesXcurrent", "bytes_reads", "bytes_current", "gets___allow", "bytes___pass", "gets_pass", "gets_read", "bytes___reads", "byte_read", "bytes___read", "bytesXbefore", "bytesXread", "gets___pass", "gets___reads", "byteslexread", "bytes_before", "byte_load", "bytes_write", "gets_allow", "bytesXload", "byte_before", "bytes___allow", "byteslexbefore", "gets___read", "bytes_allow", "gets_reads", "byte_current", "byteslexload", "bytes_pass", "bytes_found", " bytes_found", " bytes_write", " bytes_en"]}}
{"id1": "8320469", "id2": "17158020", "code1": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5": [" md512", "mp512", "md6", " md2", "mp5", "md2", "mp2", "MD6", "md512", "MD512", "mp6", " md6", "MD2", "MD5"], "text": ["prefix", "txt", "message", "image", "struct", "body", "connection", "letter", "data", "this", "required", "output", "input", "str", "editor", "password", "bytes", "key", "test", "out", "code", "source", "class", "driver", "config", "target", "TEXT", "object", "string", "obj", "name", "pattern", "path", "word", "content", "or", "format", "ext", "buffer", "contract", "secret", "Text"], "encrypted": ["rypted", "shared", " secured", "enabled", "message", "cert", "plain", "body", "emb", "updated", "data", "empty", "assembled", "selected", "phrase", "str", "password", "bytes", "key", "ted", "broken", "temp", "finished", "ryption", "config", " encryption", "modified", "checked", "hed", "packed", "rypt", "string", "confirmed", "ob", "binary", "normal", "unsigned", "content", "ed", "ext", "signed", "initialized", "used", "secure", "enc", "locked", " encrypt", "secret", "ordered"], "md": ["m", "rm", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "dig", "dd", "km", "rpm", "editor", "mc", "mag", "d", "od", "meta", "me", "mb", "wd", "code", "amd", "nm", "dm", "bd", "metadata", "pd", "MD", "di", "db", "ad", "mac", "ind", "mand", "ym", "mm", "ma", "sm", "dc", "rod", "pm", "mt", "cd", "mod", "dh", "ds"]}}
{"id1": "12454178", "id2": "23677147", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 1, "substitutes": {"alterar": [" cryar", " cryAr", " crea", " crya", " celebra", " cultivar", " celebraran", " crearan", " crear", " cultivaran", " cryaran", " cultiva", " creAr", " cultivAr", " celebrAr", " celebrar"], "t": ["at", " mt", "rt", "to", "att", "m", "bolt", "u", "e", "wt", "xt", "n", "st", "tc", "flat", "ot", "this", "ut", "you", "tm", "in", "pt", "f", "it", "tool", "tt", "o", "nt", "d", "tower", "ta", "unt", "template", "type", "s", "tf", "the", "let", "T", "tools", "te", "i", "y", "l", "target", "tree", "tr", "et", "table", "det", "trans", "ti", "tp", "v", "c", "qt", "ts", "ant", "tw", "x", "p", "dt"], "stmt": ["strmn", "swmd", "stmr", "Strm", "putau", " stnt", "formrm", "tmr", "stdb", "istdb", "formmm", "stnt", "istmt", "putmt", "ctgr", "Stv", "tpt", " stmm", "Stmb", "smr", "spt", " stmn", "ctmt", "strm", "stmb", "Stgr", "strmt", " stbm", " stdb", "istmn", " stv", "strau", "stmd", "ustmd", " stct", "stpt", " stau", "ustau", " stpt", "Stct", " stgr", "swbm", "sdb", "tmt", "stau", " stmb", "stct", "Stbm", "istau", "Stau", "swmt", "stmm", "ctmb", "stbm", "formmt", " stmd", "stv", "stgr", "putmd", "ctct", "stmn", "Stmd", "Stmt", "ustnt", "smt", "swau", " strm", "putnt", "ustmt", "Stmm", "strdb", "tdb", "formv", " stmr"], "sql": ["ls", "sol", "statement", "log", "url", "details", " SQL", "cmd", "lock", "shell", "QL", "limit", "result", "zip", "stat", "job", "s", "conn", "sq", "dl", "pr", "plan", "seed", "lambda", "expression", "db", "base", "string", "params", "printf", "sl", "up", "mt", "query", "insert", "setup", "where", "q", "database", "serv", "SQL", "ql"], "id_disciplina": ["id_distrequini", "id_Disciplinea", "id_disciplini", "id_discomplina", "id_distciplinea", "id_disrequINA", "id_disciino", "id_disciplana", "id_Disciplissa", "id_disciplinea", "id_disciplineini", "id_Disciplini", "id_Disciplina", "id_distciina", "id_distciini", "id_disciinea", "id_distciplina", "id_distciino", "id_discomplana", "id_disrequina", "id_disciplineino", "id_disciINA", "id_distciplini", "id_disciplissa", "id_disciina", "id_distrequina", "id_disciplineana", "id_discomplino", "id_disciplineINA", "id_discomplinea", "id_disciana", "id_discomplini", "id_distrequinea", "id_Disciplineini", "id_disciini", "id_disguinea", "id_disguini", "id_disciplino", "id_disguina", "id_disrequinea", "id_distciplINA", "id_disciplineissa", "id_disciplineinea", "id_distciplino", "id_discomplissa", "id_distciana", "id_disguissa", "id_Disciplineina", "id_distciplana", "id_distrequINA", "id_Disciplineissa", "id_disciplINA", "id_Disciplineinea", "id_disciplineina", "id_disrequini"], "item": ["at", "m", "page", "pe", "request", "url", "unit", "e", "server", "parent", "event", "info", "data", "entry", "it", "result", "site", "area", "o", "index", "container", "type", "instance", "i", "source", "action", "hop", "reader", "article", "er", "ip", "edit", "bar", "queue", "r", "object", "id", "seller", "v", "Item", "name", "other", "service", "order", "or", "q", "items", "p"]}}
{"id1": "22844377", "id2": "19667000", "code1": "    public int scrapeForIsbns(URL url) {\n        int matches = 0;\n        Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\");\n        Matcher m;\n        for (int i = 0; i < RETRIES; i++) {\n            try {\n                InputStream in = url.openStream();\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String str;\n                while ((str = br.readLine()) != null) {\n                    m = p.matcher(str);\n                    while (m.find()) {\n                        matches++;\n                        outputIsbns.put(m.group(1));\n                        logger.debug(\"Got ISBN: \" + m.group(1));\n                    }\n                }\n                break;\n            } catch (ConnectException e) {\n                logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES);\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                }\n            } catch (IOException e) {\n                logger.error(\"Error reading URL stream\", e);\n            } catch (InterruptedException e) {\n                logger.error(\"Interrupted while calling put(Object E)\", e);\n            }\n        }\n        return matches;\n    }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"scrapeForIsbns": ["scrapeForISbns", "scrapeForIsbbna", "scrapeForIspn", "scrapeForIsbtcn", "scrapeForIspcn", "scrapeForISbbns", "scrapeForIsbtns", "scrapeForISbna", "scrapeForIspna", "scrapeForISbbna", "scrapeForIsbbn", "scrapeForIsbn", "scrapeForIsbbns", "scrapeForIsbcn", "scrapeForISbcn", "scrapeForIsbna", "scrapeForIsbtn", "scrapeForIspns", "scrapeForIsbtna", "scrapeForISbbn", "scrapeForISbn", "scrapeForIsbbcn", "scrapeForISbbcn"], "url": ["ur", "page", "uri", "ssl", "resource", "image", "ll", "server", "html", "connection", "io", "org", "data", "f", "zip", "URL", "bel", "el", "download", "xml", "source", "config", "stream", "l", "base", "r", "object", "string", "gl", "file", "name", "loader", "service", "sl", "path", "Url", "buffer", "http", "feed"], "matches": ["patched", "matched", "attchers", "retries", "retures", " matcher", "matcher", "attks", "Mathes", " matures", "matries", " matched", "rethes", "matures", "patches", "matchers", "matests", "Matchers", " matchers", "Matcher", " mathes", "patchers", " matries", "retches", "attches", "matks", "latchers", "latches", "mathes", "Matks", " matests", "latched", "Matures", " matks", "attcher", "Matries", "latests", "patests", "Matches"], "p": ["pe", "np", "lp", "e", "b", "n", "cp", "ps", "parser", "py", "f", "P", "pa", "o", "d", "pb", "s", "pr", "api", "l", "pi", "r", "cache", "po", "c", "t", "per", "sp", "proc", "pattern", "op", "pro", "jp", "comp", "pp", "fp", "tp"], "m": ["u", " r", "e", "mut", "b", "mp", "n", "mr", "rem", "form", " pm", "g", "md", "um", "mo", "wm", "tm", "fm", "mc", "man", "lem", "me", "ms", "hm", "h", "nm", "dm", "bm", "cm", "pr", "gm", "mn", "mi", " cm", "pi", "er", "im", "l", "month", "r", "mac", "mand", "match", "ym", "v", "mm", "pc", "c", "ma", "sm", "machine", "mor", "re", "am", "per", "pm", "em", "M", "mu", "om", "line"], "i": ["k", "u", "z", "j", "count", "n", "fi", "init", "ori", "io", "info", "si", "ie", "f", "ni", "it", "o", "index", "ci", "h", "iu", "oi", "end", "timeout", "is", "multi", "li", "di", "mi", "hi", "pi", "inner", "xi", "slice", "ind", "id", "counter", "ti", "v", "gi", "c", "start", "t", "ix", "I", "ai", "phi", "ini", "ii", "ui", "x", "qi", "ri"], "in": ["ex", "fr", "ins", "In", "b", "n", "lock", "init", "io", "data", "inc", "socket", "f", "input", "exp", "IN", "ch", "inn", "coll", "out", "s", "is", "reader", "ar", "a", "l", "stream", "inner", "r", "bin", "err", "file", "ini", "bl", "as", "arin"], "br": ["obl", "buf", "bro", "fr", "arr", "b", "body", "dr", "ori", "io", "yr", "data", "bh", "rb", "ch", "cb", "out", "BR", "reader", "src", "stream", "er", "ber", "bar", "tr", "r", "inv", "err", "obj", "ob", "gr", "sp", "hr", "bl", "Br", "abs", "line", "cr", "img", "browser"], "str": ["kr", "Str", "text", "stri", "fr", "STR", "arr", "b", "st", "dr", "data", "dec", "raw", "f", "result", "strike", "input", "strip", "cl", "read", "s", "pass", "pr", "reader", "tr", "r", "id", "string", "err", "obj", "c", "name", "sr", "sl", "t", "sp", "gr", "hr", "bl", "enc", "line", "cr", "char"]}}
{"id1": "3375724", "id2": "411595", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulasF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitulof", " importarEmissoresDosTitularF", " importarEmissoresDosTitulosFe", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitULoPF", " importarEmissoresDosTituloF", " importarEmissoresDosTitulasf", " importarEmissoresDosTitulosPF", " importarEmissoresDosTitularf", " importarEmissoresDosTituloFe", " importarEmissoresDosTitulosF", " importarEmissoresDosTitulosf", " importarEmissoresDosTitULosFe", " importarEmissoresDosTituloPF", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitulasPF"], "pArquivoTXT": ["pArquivDLS", "pArquivoBBT", "pArquivoQxt", "pArquivoBxt", "pArquivoOTEMP", "pArquivoDEXT", "pArquivoOTXT", "pArquivoDLS", "pArquivaTEXT", "pArquivoTTP", "pArquivoOTTP", "pArquivTXT", "pArquivoLxt", "pArquivoLBT", "pArquivoOTxt", "pArquivaFBT", "pArquivoBEMP", "pArquivoBXT", "pArquivoDBT", "pArquivaTxt", "pArquivDxt", "pArquivoDXT", "pArquivaFTP", "pArquivoFxt", "pArquivaFEMP", "pArquivoDxt", "pArquivoLLS", "pArquivaTBT", "pArquivaTXT", "pArquivaFxt", "pArquivoTxt", "pArquivoBLS", "pArquivoFXT", "pArquivoQXT", "pArquivTLS", "pArquivoFBT", "pArquivTxt", "pArquivTBT", "pArquivoTEMP", "pArquivoQBT", "pArquivoTEXT", "pArquivoQEXT", "pArquivaTTP", "pArquivoTBT", "pArquivoTLS", "pArquivaFXT", "pArquivoFEXT", "pArquivoBTP", "pArquivoFTP", "pArquivaFEXT", "pArquivoLXT", "pArquivoFEMP", "pArquivDXT", "pArquivaTEMP", "pArquivDBT"], "pAndamento": [" pOramentO", " pOramentoo", " pAndementos", " pOrementO", " pOrementos", " pAndamentoo", " pAndentionO", " pAndmentO", " pAndentiono", " pAndamentO", " pAndemento", " pOramentos", " pAndmentoo", " pOramento", " pAndamentos", " pAndentionoo", " pAndentionos", " pAndmentos", " pAndmento", " pAndementoo", " pOremento", " pOrementoo", " pAndementO"], "numeroDoRegistro": ["numeroDoregestros", "numeroDoRegpectrano", "numeroDoRegestorno", "numeroDoregistros", "numeroDoRegpectro", "numeroDoRegpectros", "numeroDoRegistros", "numeroDoregestorno", "numeroDoregestro", "numeroDoRegestros", "numeroDoRegistorno", "numeroDoregistrano", "numeroDoRegpectorno", "numeroDoRegiftorno", "numeroDoregistorno", "numeroDoRegiftros", "numeroDoregistro", "numeroDoRegiftrano", "numeroDoRegiftro", "numeroDoRegestrano", "numeroDoRegestro", "numeroDoRegistrano", "numeroDoregestrano"], "in": ["span", "m", "ex", "ln", "ins", "url", "In", "b", "g", "n", "connection", "scan", "conf", "data", "session", "ner", "inc", "part", "f", "IN", "inn", "cl", "out", "s", "cin", "i", "rin", "kin", "is", "reader", " IN", "with", "config", "nin", " out", "l", "login", "slice", "r", "con", "c", "err", "bin", "t", "ini", "query", "again"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestino", "stmtLimpezaIniciaDestania", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialCombania", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestao", "stmtLimpezaInicialdestania", "stmtLimpezaInicioDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDesino", "stmtLimpezaInicialDestario", "stmtLimpezaInicialDestination", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialdestario", "stmtLimpezaInicialDesario", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombao", "stmtLimpezaInicioDestario", "stmtLimpezaInicioCombario", "stmtLimpezaInicioCombao", "stmtLimpezaInicioDestao", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialDestaco", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestao", "stmtLimpezaInicioCombino", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestania", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialDesao"], "sql": ["ls", "expr", "description", "statement", "sol", "log", "fn", "url", "ssl", "lua", "install", "sf", "html", "details", " SQL", "body", "cmd", "software", "term", "sv", "acl", "data", "msg", "sys", "shell", "socket", "csv", "QL", "sb", "search", "spec", "result", "zip", "liquid", "sn", "stat", "nl", "s", "el", "sq", "dl", "comment", "rl", "filename", "l", "seed", "sg", "db", "eps", "util", "id", "kl", "layout", "string", "err", "params", "select", "sl", "json", "query", "setup", "where", "http", "SQL", "ql"], "stmtDestino": ["stmtdestin", "stmdDestin", "stmtdestino", "stmtdestinos", "stmtDistaco", "stmdDestinos", "stmDestaco", "stmdDestino", "stmDestania", "stmCampaco", "stmtDestin", "stmtDistania", "stmtDestorno", "stmtdestaco", "stmtDestinos", "stmDestino", "stmtCampino", "stmtCamporno", "stmtdestorno", "stmtdestania", "stmtDestaco", "stmCampania", "stmtDistorno", "stmtCampania", "stmCampino", "stmtDistinos", "stmtDestania", "stmtDistino", "stmtCampaco", "stmCamporno", "stmDestorno", "stmtDistin", "stmdDestorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECALSHI", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABECALSCO"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPJTO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAP_PO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADANDOSAD", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADANDOJ"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RegIES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_EGIS"], "tamanhoDosArquivos": ["tamanhoDosArQUivlos", "tamanhoDosArqivos", "tamanhoDosArqivoes", "tamanhoDosArquIVo", "tamanhoDosArquivalo", "tamanhoDosArqIVos", "tamanhoDosArQUervos", "tamanhoDosArquievOs", "tamanhoDosArquivOs", "tamanhoDosArQUervlos", "tamanhoDosArquievos", "tamanhoDosArQUervOs", "tamanhoDosArQUivo", "tamanhoDosArquivaloes", "tamanhoDosArquievlos", "tamanhoDosArquIVoes", "tamanhoDosArquivo", "tamanhoDosArqIVo", "tamanhoDosArqivlos", "tamanhoDosArqIVlos", "tamanhoDosArquervos", "tamanhoDosArquervo", "tamanhoDosArquivalos", "tamanhoDosArquivoes", "tamanhoDosArqIVoes", "tamanhoDosArquIVlos", "tamanhoDosArquivallos", "tamanhoDosArQUivOs", "tamanhoDosArQUervo", "tamanhoDosArQUivos", "tamanhoDosArqivo", "tamanhoDosArquievo", "tamanhoDosArquivlos", "tamanhoDosArquervoes", "tamanhoDosArquervOs", "tamanhoDosArquIVOs", "tamanhoDosArquervlos", "tamanhoDosArquIVos"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimmado"], "registro": ["regastration", "regustros", " regestros", " regestration", "registration", "regustulo", " registulo", "regestration", "regastulo", "regestros", "regestulo", " regestulo", "registulo", " registration", "regastro", "regestro", "registros", "regustro", " registros", " regestro", "regastros", "regustration"], "campos": ["Campo", "Campas", " campOS", " casOS", "campas", "campOS", " campo", "Campos", " campas", "CampOS", " caso", " casos", " casas", "campo"]}}
{"id1": "5760649", "id2": "18451704", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "label": 0, "substitutes": {"createFile": ["CreateResource", "saveFolder", "createContent", "CreateFolder", " createContent", "createResource", "saveFile", "CreateFile", "saveResource", " createFolder", "saveContent", "createFolder", " createResource", "CreateContent"], "src": ["SourceFile", "buf", "fn", "rss", "url", "txt", "uri", "resource", "rob", "ssl", "dest", "loc", "rc", "data", "username", "sb", "Source", "input", "rb", "href", "cb", "s", "source", "ruby", "stream", "files", "resources", "slice", "r", "sc", "sit", "string", "load", "file", "obj", "upload", "gb", "name", "sl", "sel", "proc", "path", "content", "secure", "fp", "img"], "filename": ["ame", "SourceFile", "prefix", "fn", "url", "uri", "txt", "FILE", "resource", "sf", "length", "acl", "username", "title", "output", "f", "route", "nil", "s", "dll", "source", "metadata", "directory", "rl", "l", "fil", "files", "which", "Filename", "string", "file", "ames", "name", "loader", "wb", "location", "path", "utf", "fp", "ename", "feat"], "fis": ["fais", " fiss", "cfais", "sfiss", "sfris", " fIS", "cfIS", "Fos", "cfbs", "Fris", "fbs", "fris", "sfos", "cfis", "Fiss", " fris", "Fais", "FIS", "fiss", "cfris", " fais", "fIS", "sfis", "cfos", "Fbs", " fbs", "Fis"], "fos": ["foros", "Fas", "foris", "fOS", "affos", "Fops", "Fos", "affbos", "affios", "sfos", "foras", "bis", "bbos", "fas", "Fbos", "bos", " fas", " fops", " fOS", "fios", "Fios", "affis", "fops", "sfis", "fbos", "forOS", "sfops", "FOS", " fios", "sfios", "bios", "Fis"]}}
{"id1": "19810820", "id2": "8182932", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyDirectorychannel", "transferFilechannel", "copyStreamStream", "copyDirectoryChannel", "transferFileChannel", "copyfileChan", "transferfilechannel", "transferfileChan", "copyDirectoryStream", "copyFileChan", "copyStreamChannel", "copyStreamChan", "transferfileStream", "copyDirectoryChan", "copyfileChannel", "transferfileChannel", "copyfilechannel", "copyFilechannel", "copyfileStream", "transferFileChan", "copyFileStream", "copyStreamchannel", "transferFileStream"], "src": ["ls", "sth", "url", "ssl", "server", "dest", "b", "st", "loc", "rc", "rs", "sys", "sync", "func", "sb", "inst", "Source", "input", "rb", "cur", "s", "conn", "sq", "download", "rest", "sin", "source", "config", "client", "filename", "ruby", "sub", "stream", "tmp", "slice", "ses", "sc", "sit", "lower", "dist", "sup", "upload", "RC", "start", "sl", "sel", "ctx", "SOURCE", "path", "scene", "img"], "dst": ["lddest", "fdput", "ddest", "Ddest", "adput", "fdrc", "bST", "ldST", "drc", "tST", "ldost", "tart", "Dost", "dST", "stST", "tlt", "dart", "dost", "stst", "DST", "blt", "adST", "bput", " dost", "fdst", "Dst", "tst", "fdST", "adst", "adrc", "bart", "stlt", "dput", "ldst", " dST", "dlt", "start", "brc", "bst", " ddest"], "preserveModificationTime": ["preserveMinificationTime", "preserveModificationFile", "preserveModifiedtime", "preserveModifyTime", "preserveModationtime", "preserveModifyingFile", "preserveModifytime", "preserveModifiedTime", "preserveModationTime", "preserveMinifiedtime", "preserveMinificationFile", "preserveModifiedFile", "preserveModifyingtime", "preserveMinifiedFile", "preserveMinifiedTime", "preserveModifyingTime", "preserveMinificationtime", "preserveModationFile", "preserveModificationtime"], "inputChannel": ["binarychannel", "inputChan", "outputStream", " inputCode", "requestCode", "binaryGate", "inputGate", "imageGate", "inputCache", "outputCache", "inputQueue", "imagechannel", "requestChan", " inputchannel", "errorCache", "errorChan", "outputConsole", "inputchannel", "Inputchannel", "outputCode", " inputConsole", "InputSocket", " inputChan", "outputSocket", "errorStream", "binaryChannel", "imageChannel", "inputConnection", "InputQueue", "inputStream", "fileConsole", "requestChannel", "inputConsole", "outputConnection", "outputQueue", "fileChan", "binaryChan", " inputStream", "errorChannel", "inputCode", "outputChan", "fileChannel", " inputCache", " inputConnection", " inputSocket", " inputBuffer", "outputBuffer", "InputChan", " inputQueue", "InputBuffer", "inputBuffer", "fileConnection", "requestStream", "outputGate", "InputChannel", "inputSocket", "imageChan", "outputchannel"], "outputChannel": ["outchannel", "outputStream", "inputChan", "writeChannel", " outputChan", "writeStream", "Outputchannel", " outputManager", " outputQueue", "OutputQueue", "outStream", "outputManager", "inputStream", "outputQueue", "writeQueue", "outputChan", "outButton", "OutputChannel", "OutputStream", "outChan", " outputchannel", "OutputChan", "outChannel", "writeManager", "inputButton", " outputStream", "inputManager", "outputButton", " outputButton", "writeChan", "outputchannel"], "length": ["available", "partial", "text", "delay", "count", "style", "build", "volume", "offset", "form", "lock", "complete", "child", "session", "duration", "last", "part", "sequence", "limit", "result", "block", "sum", "end", "type", "pull", "max", "section", "size", "with", "width", "l", "len", "Length", "slave", "base", "number", "position", "id", "load", "start", "full", "next", "php", "current", "value", "buffer", "head", "join"], "total": ["available", "partial", "count", "complete", "offset", "failed", "info", "scale", "duration", "last", "part", "no", "limit", "all", "result", "set", "sum", "valid", "translation", "done", "error", "key", "type", "cur", "i", "Total", "multi", "max", "size", "len", "toc", "base", "found", "id", "less", "start", "otal", "full", "used", "current", "always"]}}
{"id1": "6379126", "id2": "838844", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTinyDir", "riarTravispage", "riartourPage", "riartutorialElement", "riarTutorialElement", "riarTravisPage", "riarTinyPage", "riarTourElement", "riarTutorialPage", "riartutorialPage", "riarTutorialDir", "riarTourpage", "riartutorialpage", "riarTinyElement", "riarTourDir", "riartutorialDir", "riartourElement", "riarTourPage", "riartourDir", "riarTinypage", "riarTravisElement", "riartourpage", "riarTravisDir", "riarTutorialpage"], "indexDir": ["zipDIR", "indexJar", "zipDir", "includeTier", "IndexDIR", "IndexDir", "indexDIR", "zipTier", "includeJar", "zipJar", "indexTier", "includeDIR", "IndexJar", "IndexTier", "includeDir"], "cssDir": ["javascriptDir", "cssUrl", "CSSDirectory", "catsDoc", "ssD", "fontD", "fontDir", "piecesDIR", "cssDIR", "ssDb", "gzDir", "gzUrl", "gzDirectory", "cssLen", "cssDb", "CSSUrl", "ssUrl", "javascriptDar", "ssDirectory", "cssDoc", "cssDie", "codesDoc", "catsLen", "cssDar", "CSSDar", "javascriptDb", "catsDir", "ssDIR", "piecesDie", "codesLen", "cssDirectory", "CSSDb", "CSSDir", "gzDIR", "cssD", "javascriptDIR", "ssDar", "CSSDoc", "CSSDIR", "CSSLen", "piecesDir", "piecesD", "fontDIR", "fontDie", "ssDie", "ssDir", "codesDir"], "capDir": ["CapDir", "casDir", "apsDirectory", "CapDirectory", "casDirectory", "apsDir", "Capdir", "casdir", "apsVol", "capVol", "apsdir", "casVol", "CapVol", "capDirectory", "capdir"], "licDir": ["licDoc", "volDoc", "volDir", "libManager", "volManager", "lifDir", "libDir", "libdir", "libDoc", "lifManager", "licdir", "licManager", "voldir", "lifdir", "lifDoc"], "midDir": ["limDIR", "middir", "casDir", "limDir", "casdir", "limdir", "midDIR", "casTier", "mindDir", "mindDIR", "casDIR", "midTier", "mindTier", "minddir", "limTier"], "filesDir": ["pagesDir", "FilesFolder", "FilesFile", "videosDirectory", " filesPos", "stylesDir", "opensDIR", "videosFolder", "opensDur", "locksDur", "videosFile", "opensDir", "FilesDirectory", "filesDirectory", "imagesFolder", "stylesDur", "ballsDir", "imagesFile", "pagesPos", "locksDir", "filesFolder", "filesFile", "imagesDir", "filesDIR", "stylesDirectory", "imagesDirectory", "locksDIR", "ballsPos", "filesDur", "FilesDir", "stylesDIR", "pagesVol", "opensDirectory", "filesPos", "filesVol", "ballsVol", "locksDirectory", " filesVol"], "videosDir": ["videoDir", "videosDirectory", "viewsFile", "viewsDirectory", "videoUrl", "videoDirectory", "videosUrl", " videosUrl", " videosDirectory", "videosFile", " videosDb", "viewsDir", "imagesDir", " videosFile", "imagesDb", "viewsUrl", "videoFile", "videosDb", "videoDb"], "imagensDir": ["imagersDirectory", "imagenJar", "imagenFile", "imagenciesDirectory", " imagersDir", " imagensDirectory", "imagentsJar", "imgentsDirectory", "imagensDIR", " imagersFile", "imgentsFile", "imagersDir", " imagensJar", " imagersDirectory", "imagentsFile", "imagersFile", "imagenciesDir", "imgentsDIR", "imgensDirectory", "imagenDirectory", "imgentsDir", "imagentsDIR", "imagersJar", "imagenciesDIR", "imgensFile", "imagensDirectory", "imagensFile", " imagersJar", "imagentsDirectory", "imgensDIR", "imagersDIR", "imagensJar", "imagentsDir", " imagensFile", "imagenciesFile", "imagenDir", "imgensDir"], "local": ["available", "prefix", "partial", "request", "log", "shared", "http", "localhost", "standard", "conf", "loc", "lock", "remote", "relative", "data", "username", "pal", "back", "part", "managed", "input", "Location", "valid", "d", "small", "home", "pass", "temp", "total", "basic", "dir", "directory", "LOC", "tmp", "l", "self", "same", "base", "user", "inner", "internal", "present", "file", "upload", "safe", "name", "personal", "initial", "global", "defined", "Local", "location", "path", "json", "current", " Local", "state", "specified", "where", "serial", "active", "util", "p"], "srcCss1": ["srcPss81", "srcPss1", "srcRcss81", "srcRcss11", "srcCcss3", "srcCass81", "srcCrss11", "srcCfg1", "srcPcssPre", "srcCass11", "srcCss11", "srcCpePre", "srcCss81", "srcRss81", "srcCfgPre", "srcCcss0", "srcCcss2", "srcRss2", "srcCcss11", "srcCse2", "srcPss3", "srcPcss81", "srcRss1", "srcCpe4", "srcCcss4", "srcCcss1", "srcCrss2", "srcCrss3", "srcCss0", "srcRcss1", "srcRcss2", "srcCass0", "srcCse0", "srcCssPre", "srcCse11", "srcCass3", "srcCrss81", "srcCpe2", "srcRss11", "srcCfg2", "srcCfg4", "srcCcssPre", "srcCrss1", "srcPcss3", "srcRss0", "srcCcss81", "srcRcss0", "srcPss4", "srcCse1", "srcPcss1", "srcPcss2", "srcPss2", "srcCass2", "srcCass1", "srcPssPre", "srcCpe1", "srcPcss4"], "destCss1": ["destPcss3", "destPss2", "destCcss3", "destCcss1", "destPss3", "destPssCard", "destCfg1", "destCrss2", "destPcss81", "destCass81", "destPss0", "destCrss3", "destCcss0", "destPss81", "destCfg0", "destPcssCard", "destPcss2", "destPss1", "destCss0", "destCcss81", "destCcss2", "destCrss81", "destCss81", "destCxx2", "destCxx1", "destCass2", "destCxx3", "destCrss0", "destCfg3", "destCass1", "destCassCard", "destCfg2", "destPcss0", "destCxxCard", "destCass3", "destPcss1", "destCssCard", "destCcssCard", "destCrss1"], "srcCss2": ["srcCfgL", "srcCssB", "srcChess1", "srcPss1", "srcUcss1", "srcCcss52", "srcUssTwo", "srcChess2", "srcAccss2", "srcCcss3", "srcCass52", "srcUss1", "srcCss27", "srcAccss52", "srcPcss27", "srcCfg1", "srcAccss1", "srcCross1", "srcCcssL", "srcCcss2", "srcCross52", "srcPss3", "srcChessTwo", "srcAcss2", "srcUcssB", "srcCcss4", "srcCcss1", "srcCcssB", "srcCass4", "srcCrss3", "srcCross4", "srcPssL", "srcCfgTwo", "srcCssTwo", "srcCcssTwo", "srcAcss4", "srcUssB", "srcPcssL", "srcCng27", "srcUcss2", "srcCss52", "srcCross2", "srcCfg3", "srcChessB", "srcCfg2", "srcCng2", "srcCrss1", "srcPcss3", "srcCng1", "srcUcssTwo", "srcAccss4", "srcCcss27", "srcCrss27", "srcPcss1", "srcCass2", "srcPcss2", "srcPss2", "srcPss27", "srcAcss1", "srcCass1", "srcAcss52", "srcCssL", "srcCrssL", "srcCrss2", "srcCfgB", "srcUss2"], "destCss2": ["destNss72", "destCest1", "destNss3", "destCssB", "destCess32", "destNss32", "destCcss3", "destCfg32", "destCcss1", "destCfg4", "destCfg1", "destNssB", "destCcss72", "destCess1", "destCess4", "destCss32", "destNcss3", "destNss2", "destNcss32", "destCcss4", "destCess2", "destCcss2", "destCcss32", "destNcss1", "destNcss72", "destNcssB", "destCfg3", "destNss1", "destCest3", "destNss4", "destCest2", "destCfg2", "destCestB", "destCss72", "destCfg72", "destCfgB", "destNcss2", "destCcssB", "destNcss4", "destCess72"], "srcCss3": ["srcScss15", "srcScstyle2", "srcCstyle15", "srcClass93", "srcPss6", "srcRssThird", "srcClass2", "srcScstyle93", "srcCsl2", "srcCstyle2", "srcCfg3", "srcCstyle93", "srcCsh2", "srcCss15", "srcRcss183", "srcCass2", "srcPss2", "srcScss93", "srcScss3", "srcClass3", "srcCssAND", "srcRss2", "srcCcss6", "srcPss3", "srcRss1", "srcCsl183", "srcCcss1", "srcCass4", "srcCrss3", "srcCsl3", "srcCcss15", "srcCfg2", "srcPcss3", "srcClass15", "srcRcss4", "srcPssAND", "srcCsh3", "srcCass1", "srcCrss2", "srcCstyle3", "srcRss183", "srcCcssAND", "srcScss2", "srcCcss3", "srcCfg1", "srcCcss93", "srcRcss3", "srcCrssAND", "srcCstyle6", "srcCslThird", "srcCssThird", "srcRss4", "srcPcssAND", "srcCshThird", "srcCss93", "srcCsh183", "srcPcss2", "srcCss183", "srcPcss6", "srcCcss2", "srcCcss4", "srcCcss183", "srcScstyle15", "srcRcss2", "srcRcss1", "srcCrss6", "srcCass3", "srcRss3", "srcCstyleAND", "srcScstyle3", "srcCfg4", "srcRcssThird", "srcCcssThird"], "destCss3": ["destScss3", "destPcss3", "destCcss3", "destNss3", "destPss2", "destCcss6", "destScss183", "destPss3", "destCja6", "destScrss2", "destCrss2", "destScrss6", "destPss53", "destCcss03", "destNcss3", "destNss2", "destCrss3", "destCross53", "destCcss53", "destPcss2", "destCross3", "destCstyle53", "destNss43", "destScrss183", "destCja3", "destCrss6", "destScss2", "destCcss2", "destCss53", "destCja2", "destPcss53", "destPcss03", "destCrss183", "destCass2", "destPss03", "destCstyle03", "destCstyle43", "destCstyle3", "destCss03", "destCass43", "destCss183", "destCstyle2", "destCcss183", "destCja183", "destCcss43", "destCass3", "destScrss3", "destCross03", "destScss6", "destNcss2", "destCross2", "destNcss43", "destCss43"], "srcCss4": ["srcPss1", "srcPssFour", "srcCcss2", "srcCrssFour", "srcCcss4", "srcCcss1", "srcCassFour", "srcCass4", "srcCssFour", "srcPcssFour", "srcCrss4", "srcCrss1", "srcPcss4", "srcPss4", "srcCcssFour", "srcPcss1", "srcCass2", "srcPcss2", "srcPss2", "srcCass1", "srcCrss2"]}}
{"id1": "1357662", "id2": "19251426", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyfileFrom", " copyfileFrom", "copyChannelFile", " copyFileFrom", "copyfileFile", " copyfileFile", " copyfileTO", "copyfileTo", "copyFilesTO", " copyfileTo", " copyFileFile", "copyChannelTo", "copyfileTO", "copyFileFrom", " copyFileTO", "copyFileFile", "copyChannelFrom", "copyFilesTo", "copyChannelTO", "copyFilesFrom", "copyFilesFile", "copyFileTO"], "destination": ["distination", "Destribution", "distinations", " Destribution", " Destinator", " destinations", "configinator", "distruction", "configination", "destinate", "destruction", "destinations", "distinator", "Destined", "targetinate", "separinator", "Destinator", "sourceination", " Destination", "destined", "configinations", "targetinations", " destribution", "destribution", "sourceinated", "distined", " destinator", "configinated", "Destination", "destinated", " destined", "sourceinations", "separinations", "targetruction", "sourceinator", "separination", " destruction", "destinator", " destinate", "separinated", "distinate", "Destinations", "targetination"], "srcChannel": ["srcContext", "sourceContext", " srcContext", "rcChan", "sourceChannel", "srcChan", "rcConnection", "destchannel", "rcContext", " srcchannel", "sourcechannel", "rcchannel", "destConnection", "rcChannel", "srcConnection", "srcchannel", "sourceChan", "sourceConnection", " srcConnection", " srcChan", "destChan"], "destChannel": ["descChannel", "sourceChannel", "srcChan", " destConnection", "restchannel", "descButton", "srcButton", "destchannel", "DestChan", "sourcechannel", " destchannel", "destConnection", "srcConnection", "srcchannel", "sourceChan", "restChan", "DestChannel", "sourceConnection", "Destchannel", "destButton", "DestConnection", " destButton", "destChan", " destChan", "descchannel", "restChannel"]}}
{"id1": "22046596", "id2": "4168534", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["to", "write", " transfer", " cp", "cp", "io", "Transfer", "sync", "all", " copying", " copied", "zip", "paste", "clip", "download", "Copy", " Copy", "exec", "file", "upload", " dup", "get", "transfer", "put", "p", " copies"], "s": ["ls", "m", "u", "ins", "south", "ssl", "e", "sf", "se", "b", "g", "ss", "os", "sv", "ps", "ns", "si", "sb", "f", "es", "input", "o", "storage", "fs", "sin", "source", "i", "is", "src", "a", "l", "files", "outs", "ses", "S", "less", "v", "c", "xs", "ts", "sl", "w", "sh", "as", "gs", "x", "services", "p", "ds"], "t": ["at", "to", "m", "z", "e", "b", "g", "n", "tc", "ot", "pt", "f", "it", "o", "ta", "template", "tf", "T", "temp", "i", "tty", "y", "l", "target", "tr", "r", "object", "v", "file", "c", "tor", "ts", "down", "x", "ty", "p", "tp", " T"], "in": ["m", "ins", "ssl", "url", "e", "In", "g", "b", "n", "init", "io", "sync", "inc", "socket", "f", "input", "din", "IN", "d", "inn", "h", "conn", "i", "source", "rin", "is", "reader", "win", "pull", "sin", "nin", "l", "login", "inner", "min", "r", "id", "bin", "c", "file", "up", "pin", "as", "again", "p"], "out": ["at", "ex", "writer", "image", "call", "parent", "g", "b", "n", "connection", "plain", "null", "io", "off", "sync", "inc", "not", "channel", "output", "f", "o", "d", "Out", "conn", "temp", "client", "l", "outs", "user", "v", "bin", "err", "file", "c", "obj", "net", "w", "OUT", "x", "again", "p", "ext"]}}
{"id1": "21425787", "id2": "23531898", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFile", " copyStream", "CopyFiles", " copyFiles", "copyfile", " copyfile", "CopyStream", "transferfile", "copyFiles", "Copyfile", "transferStream", "copyStream", "transferFiles", "transferFile"], "in": ["at", "m", "ex", "ins", "url", "image", "In", "b", "connection", "io", "data", "inc", "input", "IN", "index", "inn", "i", "source", "reader", "a", "work", "login", "inner", "base", "min", "id", "ac", "exec", "bin", "file", "c", "name", "up", "ini", "or", "again"], "out": ["at", "to", "prefix", "ex", "writer", "server", "call", "dest", "b", "n", "connection", "io", "off", "data", "inc", "part", "output", "result", "o", "Out", "conn", "temp", "source", "client", "target", "point", "outs", "base", "user", "object", "cache", "exec", "v", "c", "file", "name", "up", "w", "OUT", "x", "again", "p"], "sourceChannel": ["ourceChannel", "resourceConnection", "ourcechannel", " sourceSocket", " sourcechannel", "ourceSocket", "srcChan", "sourceSocket", "targetChannel", "targetStream", "srcSocket", "sourcechannel", " sourceStream", " sourceConnection", "srcConnection", "SourceConnection", "Sourcechannel", "targetChan", "targetchannel", "SourceStream", "srcChannel", "resourcechannel", "ourceChan", "SourceChan", "SourceChannel", "sourceConnection", "resourceChannel", "resourceChan", "sourceChan", "sourceStream", " sourceChan", "ourceConnection"], "destinationChannel": ["destinationChan", "DestinationConnection", "destinatorchannel", "DestinatingChannel", "destinatingManager", "destinationManager", "destinatorStream", "destinatingChannel", "DestinatorChannel", "destinatedConnection", "destructionChannel", "destationConnection", "DestinatingStream", "destinatedFile", "destinateConnection", "DestinatorChan", "DestinationChannel", "destinatingChan", "destationChannel", "destinationConnection", "DestinatingManager", "DestinationFile", "destinateChan", "destinatedStream", "DestinationChan", "destinatedchannel", "destinatorChannel", "DestinatorConnection", "destinatedChan", "destructionConnection", "destationchannel", "destructionChan", "destinationchannel", "destinatorFile", "destinatingStream", "DestinationStream", "destinatedManager", "DestinatorFile", "destinatorManager", "destinationStream", "destinatedChannel", "DestinationManager", "destinateChannel", "destinationFile", "destinatorChan", "destationFile", "DestinatingChan", "Destinatorchannel", "Destinationchannel", "destinatorConnection"]}}
{"id1": "20886320", "id2": "14619453", "code1": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"search": ["replace", "filter", "report", "build", "scan", "form", "all", "result", "index", "run", "sort", "results", "create", "parse", "suggest", "send", "show", "submit", "start", "find", "list", "select", "Search", "get", "request"], "query": ["filter", "text", "description", "uri", "resource", "image", "general", "view", "term", "data", "depth", "Query", "sql", "range", "qu", "series", "result", "answer", "str", "quer", "password", "sort", "error", "timeout", "xml", "results", "comment", "source", "media", "expression", "qs", "command", "feature", "queue", "cache", "string", "question", "params", "name", "words", "json", "clean", "value", "q", "request", "database"], "order": ["asc", "ort", "page", "direction", "der", "e", "server", "ordering", "ard", "method", "random", "ORD", "part", "group", "result", "rule", "editor", "effect", "sort", "key", "type", "row", "class", "record", "dir", "orter", "hop", "er", "user", "r", "orders", "position", "address", "string", "desc", "err", "name", "by", "Order", "state", "request", "ordered"], "maxResults": ["Maxresults", "minPages", "MaxResult", "maxPages", " maxResult", "minresults", "maxresults", "MaxResults", "minResults", " maxresults", "minResult", "MaxPages", " maxPages", "maxResult"], "encodedQuery": ["encoredExp", "encodedRequest", "deccodedRequest", "incodedQuery", "Encryptedquery", "encoredRequest", "encodingQuery", "deccodedBody", "decodedBody", "EncodedQ", "encodedExp", "encachedExp", "incodedExp", "decodedQuery", "encoredUrl", "encryptedQuery", "encodingBody", "encodedQ", "incodedUrl", "EncryptedQuery", "encapedquery", "EncryptedPage", "encodingRequest", "enccodedQ", "encachedPage", "encryptedQ", "encapedQ", "encodingQ", "incoredUrl", "incoredExp", "encryptedBody", "encryptedRequest", "enccodedUrl", "encachedQ", "incodedRequest", "decodedRequest", "encachedRequest", "encryptedquery", "encoredQuery", "EncodedQuery", "enccodedQuery", "EncryptedQ", "encodedUrl", "EncodedPage", "encryptedPage", "encapedPage", "encodedquery", "incoredRequest", "encachedUrl", "encodedBody", "encachedQuery", "deccodedQ", "enccodedBody", "encachedquery", "decodedQ", "enccodedExp", "encapedQuery", "Encodedquery", "encodedPage", "enccodedRequest", "incoredQuery", "deccodedQuery"], "startAt": ["startAfter", "startOr", "endOr", "endAfter", " startNum", "StartNum", "Startat", "stopAt", " startAfter", "endFrom", "startFrom", "stopat", "endAt", "stopFrom", "StartFrom", "StartOr", "endNum", "startat", "StartAt", "StartAfter", "stopOr", " startFrom", "startNum", "endat"], "pageNr": [" pageNn", "pageNumrs", "pageSn", "pageSrc", "pageNumn", "pageLenr", " pageNrc", "pageNrc", "pageNnr", " pageNrs", "pageLenn", "pageNumnr", "pageLenrc", "pageNn", "pageSr", "pageNrs", "pageSrs", "pageNumr", " pageNnr", "pageLenrs"], "url": ["page", "uri", "ssl", "resource", "image", "server", "connection", "data", "version", "link", "channel", "output", "entry", "route", "str", "URL", "www", "href", "download", "xml", "source", "base", "r", "id", "address", "string", "name", "sl", "host", "path", "Url", " URL", "json", "format", "location", "q", "http", "feed", "request"], "httpparams": ["httmpareas", "httppparums", "httpparaums", "httpparsums", "httPPARms", "httPPARAMS", "httpparaases", "httmparas", "httpparamams", "httupparums", "httPParms", "httPPARas", "httupparAMS", "httppARays", "httpparsams", "httpparatams", "httppparays", "httpparatAMS", "httppareums", "httPParams", "httpparas", "httpparsases", "httppparams", "httupparams", "httppParparams", "httupparatAMS", "httppARAMS", "httpparsms", "httupparatays", "httmparams", "httpparamparams", "httpparparams", "httpparamam", "httpsarsparams", "httppARams", "httppParam", "httpsaram", "httppARums", "httmpareases", "httpsarparams", "httpparamms", "httpparaams", "httppareas", "httpparases", "httpsarsams", "httPPARams", "httmpareums", "httpparums", "httpparays", "httppParams", "httpparsam", "httpparaas", "httPParAMS", "httPParas", "httpsarases", "httpparam", "httpparamAMS", "httmparases", "httpparatums", "httppARms", "httupparays", "httupparatums", "httppareases", "httpsarams", "httpsarsam", "httpparamases", "httpparsas", "httpparms", "httpparsparams", "httppparAMS", "httpparatays", "httupparatams", "httppareams", "httpparAMS", "httpsarsases", "httppARas", "httmparums", "httpparsAMS", "httpparamas", "httmpareams", "httppParases"], "httpclient": ["httpsconn", "httpmethod", "webserver", "httpsclient", "htmlclient", " httpmethod", "webClient", "httpClient", " httprequest", "httpcall", "webclient", "httpconnection", "phprequest", "webconnection", "httpscall", "httprequest", " httpserver", " httpcall", "phpserver", "htmlserver", "httpsClient", "phpclient", "webconn", "htmlconn", "httpsserver", " httpClient", "phpcall", "phpconnection", "httpserver", "htmlClient", "webmethod", "httpconn", "phpClient", " httpconnection", "phpmethod", "httpsrequest"], "httpget": ["httpsput", " httpGet", "phpGet", "phpput", " httpsend", "persend", "httpGet", "httpsend", "phpget", "httpset", "Httpsend", "phppost", " httpset", "httpspost", "httpsget", "perget", "Httpget", "Httpset", "httppost", "httpput", "perset", " httppost", "httpsGet", " httpput"], "response": ["resp", "page", "res", "respond", "resource", "message", "server", "Response", "body", "connection", "method", "data", "successful", "version", "session", "output", "application", "status", "entry", "result", "document", "reply", "seeking", "api", "client", "stream", "user", "object", "success", "full", "get", "json", "collection", "http", "feed", "request", "onse", "received"], "instream": ["outchannel", "innerchannel", "inview", " inStream", "rinStream", "infile", " inchannel", "inStream", "innerfile", "inputview", "inchannel", "inputchannel", "rinchannel", "inputform", " inversion", "outview", "intfile", "rinview", "outStream", "inputStream", "inform", "outform", "inputresource", " inform", "intversion", "inresource", "outstream", "intchannel", "inversion", "rinstream", " inresource", "outresource", "innerstream", "inputstream", "intstream", "innerversion", " infile"], "html": ["css", "page", "text", "js", "message", "plain", "view", "body", "info", "data", "version", "raw", "title", "output", "result", "hash", "str", "template", "h", "live", "xml", "source", "article", "header", "web", "db", "base", "object", "HTML", "string", "hot", "ml", "tml", "json", "content", "format", "http", "doc", "img", "browser"]}}
{"id1": "19739421", "id2": "3187685", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": [" UnknownOptionsError", "UnknownOperationError", "UnknownParameterException", " UnknownOptionsception", " UnknownOptionsException", "UnknownOptionsError", "UnknownOperationException", "UnknownOptionsException", " UnknownOptionError", "UnknownOptionception", "UnknownParameterError", "UnknownOperationception", "UnknownOptionError", "UnknownOptionsception", " UnknownOptionception", "UnknownParameterception"], "cmdLineParser": ["cmdSiteparser", "cmdLinearser", "cmdSiteParser", " cmdLineMaster", "cmdLineJar", " cmdLinearser", "cmdLinMaster", "mdLineParser", "cmdStringMaster", "mdLineHelper", "cmdBlockParser", "cmdStringBuilder", "cmdServiceJar", "mdlinearser", "mdLParser", "cmdStringJar", "cmdlineReader", "cmdStringWriter", "cmdLineWriter", "commandlineMaster", "cmdLMaster", "cmdLineReader", "cmdEntryarser", "cmdLBuilder", "cmdLJar", "mdLineReader", "cmdBlockBuilder", "cmdSiteWriter", "cmdLHelper", "commandlineReader", "cmdlinearser", "cmdFileJar", "cmdEntryMaster", "cmdlineWriter", "mdLineWriter", "cmdBlockarser", "cmdlineJar", "cmdStringHelper", "cmdLineRunner", "cmdStringarser", "commandLineMaster", "cmdServicearser", "cmdlineparser", "cmdBlockparser", "mdLineBuilder", "cmdServiceMaster", "cmdFileReader", "mdLinearser", "cmdBlockMaster", "cmdLinReader", "mdLHelper", "cmdLineMaster", "cmdStringParser", "commandLineParser", "commandLineJar", "cmdByteMaster", "mdlineParser", " cmdLMaster", "cmdlineMaster", " cmdLineJar", "cmdStringRunner", "cmdByteJar", "mdLineJar", "cmdFileRunner", "mdlineparser", " cmdLJar", "mdLarser", "mdlineBuilder", "commandlineParser", "cmdStringReader", "cmdFileMaster", "cmdByteParser", "mdlineMaster", "mdLReader", "cmdLineparser", "cmdEntryParser", "cmdLinParser", "cmdLineBuilder", "cmdBlockWriter", " cmdLParser", "cmdFileParser", "mdLJar", "cmdlineParser", "mdlineJar", "cmdLparser", "cmdStringparser", "commandLineReader", " cmdLarser", "mdLineMaster", "cmdEntryJar", "cmdLinJar", "mdLineparser", "cmdlineBuilder", "cmdFilearser", "cmdBlockJar", "mdlineWriter", "cmdLineHelper", "mdLRunner", "cmdLarser", "cmdLReader", "cmdlineHelper", "mdLineRunner", "commandlineJar", "cmdSiteJar", "cmdLParser", "cmdByteWriter", "cmdLRunner", "cmdServiceParser"], "formatOption": [" formatElement", "lengthVariable", "lengthOption", "FormatOption", "FormatOpt", "printfElement", "printfOperation", "formatOpt", "formatParameter", "FormatOperation", "FormatElement", "formatOperation", "printfOption", " formatParameter", "lengthOpt", "typeOpt", "formatElement", " formatOpt", "lengthParameter", "typeParameter", "printfOpt", " formatOperation", "formatVariable", " formatVariable", "typeOption", "typeVariable"], "outputEncodingOption": ["outputEncasingOpt", "outputEncasingParameter", "outputEncodingOperation", "outputEncordingOption", "outputCasingParameter", "outputEncitingOperation", "outputEncordingOptions", "outputCasingOpt", "outputCodingOptions", "outputEncoderParameter", "outputEncordingOpt", "outputEncodingParameter", "outputEncitingOpt", "outputCodingOpt", "outputEncodingOpt", "outputCodingOperation", "outputCasingOperation", "outputEncordingOperation", "outputEncasingOperation", "outputEncoderOperation", "outputEncoderOption", "outputEncordingParameter", "outputEncodingOptions", "outputCodingParameter", "outputCodingOption", "outputEncitingOptions", "outputEncasingOptions", "outputEncoderOpt", "outputEncasingOption", "outputCasingOptions", "outputEncitingOption", "outputCasingOption"], "inputEncodingOption": ["inputChodingOpt", "inputChachingOption", "inputEncodedOption", "inputEncoderOperation", "inputChachingOperation", "inputEncasingOpt", "inputEncoderOption", "inputChodingOperation", "inputEncodingFunction", "inputEncasingOption", "inputEncodingOperation", "inputEncoderOpt", "inputEncasingFunction", "inputEncodedFunction", "inputChodingFunction", "inputEncodingOpt", "inputChachingOpt", "inputChasingOperation", "inputEncachingOperation", "inputEncoderFunction", "inputChasingFunction", "inputChodingOption", "inputChasingOption", "inputEncachingOpt", "inputEncodedOperation", "inputEncachingOption", "inputEncasingOperation"], "format": ["filter", "at", "prefix", "attribute", "writer", "unit", "html", "style", "term", "form", "letter", "atter", "version", "scale", "title", "output", "f", "template", "sort", "type", "plugin", "cat", "api", "config", "quality", "size", "filename", "license", "target", "command", "transform", "place", "feature", "language", "string", "layout", "file", "alpha", "Format", "option", "name", "service", "printf", "pattern", "host", "ant", "value", "pretty", "export"], "outputEncoding": ["outputOctoding", "inputEncryption", "outputCompasing", "inputChasing", "outputEntryption", "outputChaping", "outputChoder", "outputChaching", "outputOctoring", "outputencoder", "outputencoding", " outputEntining", "outputOctasing", "outputDecoding", "inputChryption", "outputCompoding", "outputEngording", "outputEncaping", "inputChoding", "inputChoring", "outputDecording", "inputEncoring", "inputEncoder", "outputencaching", " outputEncoder", "outputChining", "outputChryption", "outputSequoding", "outputCompoder", "outputEngoder", " outputEncining", "outputEntoding", "outputEncording", "outputEncoder", "outputEntoder", " outputEncaping", "outputEntasing", "outputEncoring", "outputEntining", " outputEntoding", " outputEncaching", "outputencording", "outputEnaping", "outputEngaching", "outputSequoder", "outputEncryption", "outputSequryption", " outputEngaching", "outputCompording", "outputChoding", " outputEngoding", " outputEncasing", "outputEnasing", "outputEncaching", "inputChoder", "outputEnining", "inputEncasing", "outputEncasing", " outputEntasing", "outputDecoder", " outputEngoder", " outputEncording", " outputEngording", "outputEngoding", "outputChoring", "outputChording", "outputChasing", " outputEntaping", "inputChording", "outputSequasing", "outputDecasing", "inputEncording", "outputOctoder", "outputEncining", "outputEntaping", "outputEnoding"], "inputEncoding": ["inputEnoder", "inputExplasing", " inputDecoder", "inputEnacing", "variableExplasting", "inputChoding", "variableExplode", "variableEncode", "inputExploding", "inputEnording", "inputEngoding", "inputChacing", "inputEncasting", "inputChasting", "inputEngoder", "inputDecacing", " inputDecording", "inputChasing", "variableExplasing", "inputChode", "inputEnasting", "inputEngasing", "inputEncoder", "inputEncacing", "outputEncasing", "inputDecoding", "inputEncode", "outputChoder", "outputChasing", "inputExplode", "inputExplasting", " inputDecacing", "inputChording", "outputChoding", "inputEngapping", " inputDecoding", "inputEncording", "outputChapping", "inputDecording", "inputEnasing", "inputEnode", "outputEncoder", "inputEncapping", "inputChoder", "variableExploding", "inputDecoder", "variableEncasting", "variableEncasing", "inputEnoding", " inputEncording", "inputEncasing", "outputEncapping", "inputChapping", " inputEncacing", "inputEnapping", " inputEncoder", "variableEncoding"], "remainingArgs": ["remainArgs", "remendingArg", "RemingLong", "RemingParts", "regainingGS", "remangingGS", "remainedGS", "remangingLong", "remainArg", "remangingParts", "resainargs", "remainParameters", "resainedLong", "resainedArg", "remingParts", "remainedArray", "remangingArgs", "RemangingParts", "remainsArg", "remainLong", "RemingArgs", "remainedParameters", "RemangingAr", "remainedParts", "remainingArg", "remainingLong", "RemainingLong", "remainargs", "remainedargs", "remainsAr", "remainingArray", "RemainingArg", "regainedGS", "resainArray", "remainAr", "regainingArg", "RemainingParts", "remainedArg", "resainingLong", "remainedLong", "resainingArray", "remainingAr", "regainingParameters", "remainingParts", "resainArgs", "remainingargs", "removingParts", "remangingArg", "remingArgs", "remainingParameters", "remainsArgs", "remainedArgs", "RemangingArg", "remangingAr", "regainedArg", "remingLong", "remendingArray", "remainGS", "remangingParameters", "remendingargs", "regainingArgs", "remainsParts", "removingArgs", "resainArg", "RemainingGS", "removingGS", "resainingArgs", "resainingParts", "RemainingArgs", "resainingArg", "remainingGS", "regainedArgs", "removingLong", "regainedParameters", "RemangingArgs", "remingGS", "resainedArgs", "remendingArgs", "resainedParts", "remainParts", "resainingargs", "RemingGS", "remainArray", "RemainingAr"], "inputFile": [" inputfile", "InputFile", "localDirectory", "localFile", "InputDir", " inputDir", "sourceDirectory", "InputLine", "sourceLine", "inputSourceFile", "InputSourceFile", "sourceFile", "inputStream", "sourcefile", "inputPath", " inputPath", " inputDirectory", " inputStream", "localDir", "inputDirectory", "inputDir", "localSourceFile", "InputDirectory", "inputfile", "sourcePath", "inputLine", " inputLine", "sourceDir", "sourceStream", "InputPath", " inputSourceFile", "InputStream", "Inputfile"], "outputFile": ["OutputPath", "outputStream", "examplefile", "exampleFile", " outputFolder", "operationfile", "operationHeader", "outputMessage", " outputPath", "operationFolder", "OutputFolder", " outputMessage", " outputfile", "OutputHeader", "exampleFolder", "productionfile", "outputPath", "OutputStream", "productionMessage", "outputFolder", "productionFile", " outputStream", "operationFile", " outputHeader", "OutputFile", "exampleStream", "OutputMessage", "productionPath", "Outputfile", "outputfile", "outputHeader"], "out": ["prefix", "page", "gen", "log", "writer", "ln", "flow", "write", "server", "parent", "copy", "debug", "lock", "io", "outer", "info", "session", "raw", "group", "output", "in", "sum", "Out", "error", "temp", "builder", "client", "co", "dump", "ger", "outs", "over", "cache", "screen", "history", "err", "obj", "println", "list", "up", "pre", "OUT", "auto", "line", "word", "again", "manager", "post"]}}
{"id1": "11475527", "id2": "6371607", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addDatafromurl", "addDatafromFile", "addDataFromurl", "addDataWithFile", "addDataWithUrl", "addDataWithURL", "addTextFromUrl", "addDataWithurl", "addDataFromUrl", "addTextFromURL", "addTextfromFile", "addDatafromUrl", "addDataFromFile", "addDataForFile", "addDatafromURL", "addTextFromFile", "addTextfromURL", "addDataForURL", "addDataForUrl", "addTextfromUrl", "addDataForurl", "addTextfromurl", "addTextFromurl"], "theurl": ["thereurl", " theuri", "pythonurl", "thepublic", "thereURL", "testURL", "myURL", " thelog", "theURL", "theuri", "testUrl", "thereuri", "pythonuri", "youURL", "pythonURL", " Theurl", " TheURL", " thepublic", "youlog", "myurl", "mypublic", "testurl", "myUrl", "youurl", "youUrl", " theURL", " TheUrl", "theUrl", " Thepublic", "thelog", "testlog", " theUrl"], "line": ["LINE", "text", "pe", "log", "url", "unit", "write", "le", "style", "connection", "letter", "cell", "link", "sync", "part", "no", "entry", "f", "model", "str", "lin", "feed", "lines", "nl", "key", "out", "row", "el", "code", "pass", "cl", "i", "comment", "source", "reader", "li", "l", "len", "number", "base", "object", "id", "string", "character", "file", "Line", "name", "buffer", "ine", "block", "char"], "in": ["m", "rin", "ins", "url", "fin", "image", "In", "b", "init", "io", "info", "inc", "socket", "it", "oin", "input", "fa", "din", "IN", "inn", "lin", "read", "out", "s", "conn", "pass", "cin", "i", "is", "source", "win", "reader", "record", "client", "inside", "nin", "l", "a", "login", "stream", "inner", "r", "bin", "file", "err", "pin", "ini", "or", "arin", "again", "serv", "isin"], "data": ["DATA", "writer", "url", "default", "one", "body", "connection", "like", "info", "this", "output", "entry", "f", "result", "input", "o", "d", "dat", "lines", "end", "out", "conn", "i", "source", "iter", "reader", "di", "stream", "er", "l", "inner", "da", "ata", "r", "handler", "file", "start", "la", "up", "next", "plus", "buffer", "open"], "e": ["ade", "ale", "pe", "ee", "ev", "one", "se", "en", "ce", "event", "ue", "ge", "je", "ie", "ec", "ele", "f", "oe", "edge", "es", "ise", "o", "ep", "ace", "ae", "error", "me", "element", "ze", "ne", "er", "E", "de", "eu", "et", "eme", "err", "ke", "ede", "be", "ea", "or", "ef", "fe", "exc", "ception"]}}
{"id1": "18544890", "id2": "5138455", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"get": ["gets", "resource", "call", "debug", "remote", "info", "data", "GET", "Get", "end", "download", "pull", "create", "send", "cache", "show", "load", "match", "start", "select", "find", "list", "next", "json", "query", "update"], "url": ["ur", "ls", "page", "uri", "ssl", "ll", "resource", "server", "image", "connection", "loc", "f", "rule", "route", "str", "URL", "www", "href", "date", "key", "download", "source", "l", "base", "queue", "id", "email", "address", "string", "file", "name", "service", "sl", "host", "layer", "location", "Url", "path", "http", "feed"], "lat": ["at", "distance", "play", "late", "length", "west", "offset", "loc", "height", "data", "las", "port", "pos", "range", "route", "league", "out", "live", "home", "tile", "Lat", "width", "l", "base", "alt", "point", "local", "gal", "address", "id", "la", "grid", "street", "bot", "location", "game"], "lon": ["log", "ln", "length", "offset", "loc", "off", "lan", "depth", "lb", "on", "online", "pos", "range", "land", "lin", "nl", "val", "live", "ng", "width", "l", "len", "number", "base", "position", "lag", "la", "left", "layer", "location", "level", "ino", "fat", "lang", "vel"], "count": ["Count", "log", "length", "offset", "n", "amount", "num", "depth", "more", "part", "follow", "limit", "f", "all", "sum", "index", "batch", "error", "val", "type", "timeout", "code", "time", "total", "size", "len", "number", "base", "scroll", "id", "found", "cache", "load", "file", "c", "age", "list", "name", "pool", "level", "force"], "req": ["fr", "requ", "org", "dq", "socket", "reg", "exp", "rb", "conn", "ver", "temp", "r", "cache", "cook", "exec", "wa", "err", "proc", "plug", "query", "orb", "respond", "fin", "server", "call", "ru", "cp", "form", "fail", "cb", "test", "download", "pkg", "worker", "https", "c", "gr", "ctx", "cf", "pub", "jp", "q", "rf", "post", "resp", "rx", "build", "ok", "cmd", "loc", "io", "fb", "sem", "check", "cur", "sq", "pr", "pull", "ctr", "tr", "next", "hr", "http", "serv", "ur", "rt", "res", "p", "rob", "conf", "f", "ref", "Request", "wx", "require", "bur", "client", "work", "rr", "qt", "def", "grad", "fit", "fe", "request", "ext"], "gl": ["ogl", "console", "fl", "fr", "ll", "Gl", "g", "gn", "view", "loc", "pl", "gall", "gre", "il", "las", "ul", "ang", "groups", "ga", "coll", "cl", "nl", "bel", "rg", "go", "el", "gg", "berg", "lol", "cm", "rl", "gold", "gm", "hl", "l", "bg", "ger", "fx", "gal", "GL", "lim", "gi", "gb", "list", "ml", "global", "gel", "sl", "sel", "bl", "lc", "cal", "fe", "bs", "img", "browser"], "br": ["buf", "res", "bro", "fr", "arr", "b", "body", "dr", "mr", "io", "yr", "bh", "bc", "result", "str", "ch", "rb", "brush", "BR", "pr", "reader", "ar", "stream", "lr", "ber", "bar", "tr", "r", "ctr", "div", "err", "sr", "gr", "sp", "hr", "bl", "ler", "Br", "bridge", "cr", "img", "browser"], "line": ["page", "text", "pe", "LINE", "log", "fr", "lf", "e", "unit", "le", "style", "letter", "cell", "data", "ge", "link", "sync", "pos", "entry", "rule", "str", "lin", "cl", "lines", "nl", "inline", "key", "row", "el", "live", "end", "jo", "code", "comment", "source", "cle", "ne", "l", "co", "base", "look", "string", "file", "Line", "name", "sl", "sel", "bl", "lo", "word", "lc", "ino", "ine", "block", "char"]}}
{"id1": "9347451", "id2": "14231545", "code1": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"writeData": ["writeDATA", " writeText", "appendDATA", "WriteDATA", "writedata", "WriteData", "Writedata", " writeDATA", "appendData", "WriteText", "writeText", "appendText", " writedata", "appenddata"], "name": ["ame", "NAME", "prefix", "url", "report", "image", "parent", "n", "info", "data", "old", "title", "part", "model", "f", "str", "named", "index", "date", "key", "type", "out", "pass", "code", "temp", "time", "class", "Name", "size", "filename", "l", "base", "table", "id", "names", "string", "start", "path", "word", "active", "line"], "items": ["keys", "chains", "item", "jobs", "cases", "Items", "sections", "groups", "plugins", "features", "planes", "classes", "projects", "lines", "ips", "flows", "objects", "xml", "images", "days", "pieces", "files", "pages", "ids", "units", "steps", "names", "models", "tests", "locks", "amples", "blocks", "types", "events", "months", "ints"], "mzmin": ["mwmax", "mvmin", "mxstart", "mZstart", "dizstart", "MZstart", "mizmax", "mxmins", "mczstart", "dizmax", "mczmax", "mzstart", "mozMin", "mvmins", "dzmin", "Mzstart", "dzMin", "mizmin", "Mxmin", "mczMin", "mczmin", "mizMin", "mozstart", "mozmin", "mwmin", "Mzmax", "MzMin", "mozmins", "mizstart", "mozmax", "Mxmins", "mzmins", "mvMin", "mzMin", "mZmax", "mwstart", "mxMin", "Mzmin", "dizMin", "dzstart", "mZmin", "dizmin", "MZmin", "Mxstart", "dzmax", "mxmin", "mvstart", "Mzmins", "mxmax", "MZmax", "MxMin"], "mzmax": ["MzMAX", "MZax", "mxMAX", "mizmax", " mzhMax", "mZMax", " mzhend", "Mzlast", " mizmin", "mjMax", "Mzax", "MzMax", "mzend", " mzhmin", "mizmin", "mzax", "mZend", "mizlast", "mgzlast", "MZlast", "mzhmax", "mzMax", "mgzmin", " mzMax", "mZax", "mZlast", "Mzmax", "mxax", "mazmin", "mjlast", " mizMax", "mxlast", "mjmax", " mzhmax", "mazMAX", "mZmax", "mzMAX", "mizMax", "mazmax", "mgzMax", "Mzmin", "mzhmin", " mzend", " mizlast", "mZmin", "MZMax", "mxend", "MZmin", "mazax", "mzhMax", "mzlast", "mzhend", " mzlast", "mxmin", " mizmax", "mjmin", "mxMax", "MZMAX", "mZMAX", "mgzmax", "mxmax", "MZmax"], "tstart": ["pstart", "tnstart", "pmin", "fmin", " tstop", "fstart", "fadd", " tmin", "tend", "tadd", "fstop", "ttstop", "tnmin", "ttstart", "ttmin", " tadd", "pstop", "fend", "tnadd", " tend", "ttend", "tmin", "pend", "tstop"], "tdelta": ["tdatum", "tdiff", "ulediffs", "ndata", "ruedatum", "dtiffs", "ruediff", "ruediffs", "tdiffs", "ndiff", "dtiff", "TDiffs", "dtata", "ddiffs", "ruedelta", "TDelta", "ddiff", "TDiff", "uledelta", "TDatum", "ddata", "ndelta", "uledatum", "ddelta", "tdata", "ulediff", "ndiffs", "dtelta"], "peaks": ["meakers", "meakes", "keakes", "peak", "feaks", "speaked", "meaks", "peakers", "peasons", "feasons", "leakes", "teakes", "leaks", "keaks", "leak", "speak", "keaked", "teaks", "meak", "speasons", "feakes", "feakers", "leaked", "keak", "speakes", "teak", "feak", "speakers", "peakes", "teasons", "speaks"], "file": ["writer", "FILE", "report", "image", "core", "parent", "view", "letter", "single", "socket", "temp", "class", "l", "files", "place", "queue", "cache", "per", "wave", "page", "pe", "unit", "e", "resource", "server", "message", "form", "info", "this", "port", "group", "folder", "model", "result", "h", "el", "let", "handle", "parse", "ger", "object", "show", "loader", "global", "w", "path", "where", "feed", "save", "book", "log", "il", "io", "check", "tool", "site", "run", "out", "comment", "print", "db", "user", "File", "function", "buffer", "http", "use", "fp", "force", "sample", "module", "write", "ile", "le", "b", "lock", "output", "f", "it", "source", "reader", "work", "base", "bar", "table", "pipe", "load", "full", "get", "auto", "pool", "fit", "fe", "line", "lib"], "i": ["m", "p", "u", "z", "uri", "e", "n", "fi", "init", "io", "info", "adi", "si", "step", "ie", "part", "it", "ni", "f", "jj", "index", "d", "ci", "iu", "oi", "h", "is", "mini", "multi", "api", "y", "li", "di", "im", "mi", "ip", "eni", "xi", "hi", "pi", "slice", "l", "yi", "id", "uli", "ti", "gi", "v", "c", "start", "sup", "ri", "I", "ai", "ix", "phi", "ini", "ii", "ui", "bi", "x", "mu", "chi", "qi", "ik"], "nothing": ["sorry", " rest", " difference", "Nothing", "hack", "miss", "good", "thing", " no", "init", "yeah", " worst", "none", "info", "empty", "terror", "hello", "different", "tips", " tid", "no", "how", "it", "stuff", " stop", "tt", "done", "ta", "missing", "them", "broken", "T", "total", " tot", "life", "notice", "what", "shit", " trials", " it", "wrong", "anything", "show", " skip", "tests", "everything", "little", "xxx", "wait", "worst", "diff", " trial", "unknown", "whatever", "something", "things", "false", "zero", "huge", " tries", "dt", " total"], "fileLoc": [" fileLOC", "baseLocation", "fLoc", "Fileloc", "fileLOC", "FileLoc", "FileLOC", "floc", " fileloc", " fileLocation", "fileloc", "fLOC", "baseLOC", "fLocation", "fileLocation", "baseloc", "FileLocation", "baseLoc"], "tempDate": [" tempLine", "tmpDat", "tempdate", "tmpdate", "tmpDay", "TempDate", "fakeDat", "temdate", " tempDat", "temDat", "tmpLine", "fakedate", "fakeDate", "tmpDate", "TempLine", "TempDat", " tempdate", " tempDay", " tempSign", "TempSign", "TempDay", "tempDat", "Tempdate", "tempDay", "tempSign", "tmpSign", "tempLine", "temDate"], "t": ["at", "m", " difference", "e", "g", "tz", "n", "b", "flat", "ot", "duration", " tid", "it", "f", " ng", "tt", "d", "ta", "the", " tail", "out", "utt", " n", "that", "tf", "T", "total", "y", " tot", " p", "l", "target", "tim", " it", "ti", "c", " tf", " ta", "ts", " pt", " title", "p", "dt", " ti", " e"], "k": ["ks", "ky", "kr", "K", "dk", "uk", "u", "kat", "z", "kid", "e", "b", "g", "n", "ok", "ki", "ku", "ek", "kick", "f", "jj", "o", "d", "ck", "ka", "ko", "kn", "key", "ijk", "ak", "kh", "y", "work", "l", "kk", "kw", "kl", "v", "unk", "c", "kind", "ke", "w", "mk", "sk", "x", "tk", "q", "p", "ik"], "j": ["ij", "jen", "m", "js", "u", "fr", "z", "e", "b", "g", "n", "off", "kj", "jc", "ie", "f", "it", "jj", "jet", "ja", "o", "d", "ch", "dj", "job", "uj", "key", "aj", "ji", "J", "el", "pass", "jo", "pr", "y", "oj", "li", "l", "bj", "r", "ind", "br", "v", "err", "obj", "dy", "adj", "jl", "ii", "x", "jp", "q", "p", "ik"], "peaked": ["speaky", "cleaked", "meaker", "peaky", "peaker", "speaken", "feaking", "peak", "keaking", "ceaky", "meaken", "keake", "apeaking", "speaked", "cleaken", "paaked", "pak", "apeaked", "peake", "feaken", "cleaking", "ceaking", "ceaked", "paken", "paked", "feaked", "speak", "keaky", "keaked", "meaked", "cleake", "keaker", "peaking", "meaking", "apeaken", "ceaken", "ceak", "paaken", "paake", "keak", "paaking", "paky", "peaken", "ceaker", "feaker", "keaken", "apeaker"], "test": ["filter", "txt", "pack", "report", "server", "call", "build", "master", "scan", "here", "data", "this", "Test", "search", "loop", "f", "all", "py", "check", "result", "trial", "fail", "valid", "end", "out", "val", "pass", "ver", "temp", "iter", "driver", "reader", "print", "inner", "user", "tr", "table", "match", "show", "v", "err", " tests", "tests", "start", "diff", "cher", "runner", "testing", "train", "feed"]}}
{"id1": "3375722", "id2": "8024375", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importTarsetor", " importTarSetorn", " importTarSetor", " importarStructor", " importarsetor", " importarSetorn", " importarStructutor", " importTarsetori", " importTarsetutor", " importarStructorn", " importarsetori", " importarProcessorn", " importarStructori", " importarsetorn", " importarProcessutor", " importTarsetorn", " importTarSetori", " importarSetutor", " importarProcessor", " importarProcessori", " importarSetori", " importarsetutor", " importTarSetutor"], "pArquivoXLS": ["pArquivaEXls", "pArquivoTXSL", "pArquivoXls", "pArquivaEXLS", "pArquivoTXLS", "pArquivoZXls", "pArquivaXML", "pArquivoYCL", "pArquivoTXCL", "pArquivoEXML", "pArquivoZXSL", "pArquivoYls", "pArquivoYML", "pArquivaXSL", "pArquivaXCL", "pArquivoXSL", "pArquivoEXSL", "pArquivaXls", "pArquivoEXCL", "pArquivoXML", "pArquivoZXLS", "pArquivaEXML", "pArquivoEXls", "pArquivoEXLS", "pArquivaXLS", "pArquivoZXML", "pArquivaEXCL", "pArquivoXCL", "pArquivoTXls", "pArquivaEXSL", "pArquivoYLS", "pArquivoTXML"], "pCabecalhoSetor": ["pCabecalhaSetor", "pCabecalhoSelector", "pCabecalhaSelecte", "pCabecalhaSete", "pCabecalhoSetors", "pCabecalhoSelectors", "pCabecalhoEditors", "pCabecalhaSelector", "pCabecalhoEditeur", "pCabecalhoSelecteur", "pCabecalhoEditor", "pCabecalhoSeteur", "pCabecalhoSelecte", "pCabecalhaSeteur", "pCabecalhaSelecteur", "pCabecalhoSete", "pCabecalhaSelectors", "pCabecalhoEdite", "pCabecalhaSetors"], "pAndamento": ["pAndamentO", "pAndementono", "pOramentos", "pAndmentono", "pOramentono", "pOrementos", "pAndamentos", "pAndietono", "pAndementO", "pAndietos", "pOremento", "pOrementono", "pOramento", "pAndmento", "pAndietO", "pAndemento", "pAndamentono", "pAndmentos", "pAndieto", "pOramentO", "pOrementO", "pAndementos", "pAndmentO"], "iLinha": ["iPlanha", "iFranha", "NumLinha", "iPlanHa", "NumPlanya", "iMalHa", "iMalya", "NumLinya", "iLineno", "iFranHa", "NumLineno", "iLinya", "iLinHa", "iMalha", "iFranya", "iPlanya", "NumPlanha", "NumLinHa", "NumPlaneno", "NumPlanHa", "iFraneno", "iMaleno", "iPlaneno"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialESTination", "stmtLimpezaIniciodestino", "stmtLimpezaInicialDesania", "stmtLimpezaInicialdestino", "stmtLimpezaIniciadestaco", "stmtLimpezaInicialESTaco", "stmtLimpezaInicialCombina", "stmtLimpezaInicioDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialdestin", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestina", "stmtLimpezaInicialDesination", "stmtLimpezaInicialDestination", "stmtLimpezaIniciadestination", "stmtLimpezaInicialdestaco", "stmtLimpezaIniciodestaco", "stmtLimpezaInicialCombino", "stmtLimpezaInicialDesINO", "stmtLimpezaInicioDestINO", "stmtLimpezaIniciodestination", "stmtLimpezaIniciodestania", "stmtLimpezaInicialDestina", "stmtLimpezaInicialESTino", "stmtLimpezaInicioDestania", "stmtLimpezaIniciadestin", "stmtLimpezaInicialDestINO", "stmtLimpezaIniciaDestin", "stmtLimpezaIniciadestino", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialCombINO", "stmtLimpezaInicialESTin", "stmtLimpezaInicialDestaco", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialdestina", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialdestINO", "stmtLimpezaInicioDestination", "stmtLimpezaIniciaDestino", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialDestania", "stmtLimpezaIniciodestina", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialdestania", "stmtLimpezaInicialDestin"], "stmtDestino": ["stmtdestin", "stmtRestINO", "stmrdestinning", "stmpDestino", "stmdestino", "stmtCombINO", "stmtRestinning", "stmtRestin", "stmtCombino", "stmDestin", "stmtdestino", "stmdestinos", "stmpdestINO", "stmpdestorno", "stmtdestinos", "stmpdestaco", "stmpDestorno", "stmtDistINO", "stmpDestaco", "stmrDestinning", "stmtDestINO", "stmrdestINO", "stmtDistaco", "stmtLocationINO", "stmtLocationaco", "stmpDestINO", "stmtDestin", "stmtRestinos", "stmtRestino", "stmtCombin", "stmtdestaco", "stmtDestorno", "stmpdestino", "stmDestino", "stmtDestinos", "stmrdestaco", "stmtDestinning", "stmtdestorno", "stmtDestaco", "stmrDestINO", "stmDestINO", "stmtDistorno", "stmDestinos", "stmtRestaco", "stmtdestINO", "stmtCombinos", "stmrDestaco", "stmtDistino", "stmdestINO", "stmrdestino", "stmtdestinning", "stmdestin", "stmtLocationinning", "stmrDestino", "stmtLocationino"], "arquivo": ["arQUico", " ar\u00e7ivo", " arqiva", "Arqoso", " ar\u00e7icio", "arQUiva", "arqico", " arquiva", " ar\u00e7arius", "arquarius", "arQuivo", "Arquiva", "Arqiva", " ar\u00e7iva", "Arqivo", "arquico", "arqicio", " arqivo", "arQuiva", " arqicio", "arqiva", " arQuiva", "arquoso", " arQuarius", "arqarius", "arQuico", "arquiva", " arquicio", " arQuivo", "arQUoso", " arqarius", "arQuoso", "arqivo", " arquarius", " arQuicio", "arquicio", "Arquoso", "arQUivo", "Arqico", "arqoso", "Arquico", "Arquivo"], "plan1": ["Plan0", "Plan2", "plan2", " Plan0", " plan0", " planName", " plan2", "planOne", " planOne", "PlanName", "plan0", "planName", " Plan1", "product2", "productName", "product0", " Plan2", " PlanOne", "Plan1", "PlanOne", "product1"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTROAD", "QUANTIDADE_DE_REGISTROSAD", "QUANTIDADE_DE_REGISTEROAD", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRASAD", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTERO__", "QUANTIDADE_DE_REGISTRO__", "QUANTIDADE_DE_REGISTEROSAD", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosAD", "QUANTIDADE_DE_REGISTRONS_", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRATES__", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRONS__", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTROsEC", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRYAS_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTROsJ", "QUANTIDADE_DE_REGISTRYOS_", "QUANTIDADE_DE_REGISTRYOSJ", "QUANTIDADE_DE_REGISTRYASJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRosEC", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTROID", "QUANTIDADE_DE_REGISTRES_", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTRON_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRATESJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRATESEC", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRESEC", "QUANTIDADE_DE_REGISTEROID", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTEROSID", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRONID", "QUANTIDADE_DE_REGISTRosID", "QUANTIDADE_DE_REGISTRESJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTROSID"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivator", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstimmator", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstifator", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstifado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimator", "quantidadeDeRegistrosEstimmado"], "vSetor": ["vSetoring", "vSelector", " vSete", "vShipe", "vSelecte", " vSetoring", "vSelectoring", "vSete", "vShipor", "vSetors", "vShiporing", "vSelectors", " vSetors", "vShipors"], "vSubsetor": ["vSubjectors", "vSubscor", "vSubseto", "vSubscriptor", "vSubscr", "vSubsco", "vsubsetor", "vSubjector", "vsubsetr", "vSubscors", "vsubscors", "vSubscripto", "vsubscor", "vsubsco", "vSubjecto", "vSubscriptors", "vSubjectr", "vsubscr", "vSubsetors", "vSubscriptr", "vSubsetr", "vsubsetors", "vsubseto"], "vSegmento": ["vSegMENTo", "vGamentos", "vSegmenta", "vSegMENTos", "vSegamentos", "vSegamento", "vSegmentationor", "vGamentor", "vSegmentationa", "vSegMENTor", "vGmentor", "vGmenta", "vSegamenta", "vGamenta", "vSegmentationo", "vGmento", "vGamento", "vGmentos", "vSegMENTa", "vSegmentationos", "vSegmentos", "vSegmentor", "vSegamentor"], "registroAtual": ["RegistroAtual", "Registroatual", "RegistroGenual", "Registrosatial", "RegistroGenional", "RegistroGenUAL", "RegistroExional", "RegistroGenial", "RegistroatUAL", "RegistrosAtUAL", "Registroatial", "RegistrosAtial", "RegistroAtUAL", "RegistrosatUAL", "RegistroExual", "RegistrosAtual", "Registroational", "RegistrosAtional", "RegistroAtional", "Registrosational", "RegistroExUAL", "Registrosatual", "RegistroExial", "RegistroAtial"], "vPapeisPorSegmento": ["vPapeisPorSegmente", "vPapeisPorSegmentsor", "vPapeisPorSegmentor", "vPapeisPorSegmentos", "vPapeisPorSegmentationos", "vPapeisPorSegamentor", "vPapeisPorFragmento", "vPapeisPorSegamento", "vPapeisPorSegmentationo", "vPapeisPorSegmentatione", "vPapeisPorFragmente", "vPapeisPorFragmentsos", "vPapeisPorSegmentationor", "vPapeisPorFragmentsor", "vPapeisPorFragmentso", "vPapeisPorFragmentos", "vPapeisPorFragmentse", "vPapeisPorSegamente", "vPapeisPorSegmentsos", "vPapeisPorFragmentor", "vPapeisPorSegmentse", "vPapeisPorSegmentso", "vPapeisPorSegamentos"], "sql": ["ls", "sol", "description", "statement", "log", "http", "ln", "url", "ssl", "install", "sf", "html", " SQL", "script", "body", "term", "os", "sv", "acl", "data", "msg", "shell", "csv", "QL", "sb", "spec", "zip", "str", "sn", "nl", "s", "sq", "dl", "pr", "comment", "section", "seed", "sg", "db", "base", "eps", "slice", "id", "layout", "string", "params", "select", "sl", "spr", "json", "query", "setup", "where", "util", "serv", "SQL", "ql"]}}
{"id1": "3584508", "id2": "5138455", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadresource", " copyresource", " downloadUrl", "copyFile", " copyUrl", "copyresource", "copyUrl", "transferUrl", " downloadResource", " copyFile", "transferResource", "transferresource", " downloadFile", "transferFile"], "url": ["ls", "page", "uri", "ssl", "resource", "image", "server", "connection", "loc", "remote", "data", "f", "www", "URL", "ref", "bel", "download", "xml", "source", "src", "stream", "l", "lr", "web", "base", "r", "object", "id", "address", "string", "ource", "file", "loader", "re", "name", "sl", "host", "path", "Url", "http", "feed"], "input": ["request", "ssl", "resource", "image", "connection", "form", "act", "data", "this", "session", "inc", "socket", "in", "f", "audio", "index", "error", "reader", "accept", "out", "inf", "temp", "instance", "i", "source", "xml", "api", "config", "pull", "element", "qa", "progress", "stream", "l", "ack", "parse", "inner", "base", "client", "Input", "cache", "address", "exec", "bin", "file", "load", "upload", "binary", "get", "context", "current", "plus", "buffer", "but", "active", "http", "feed", "bb", "open"], "output": ["log", "writer", "console", "default", "unit", "resource", "write", "image", "flow", "copy", "connection", "outer", "data", "socket", "external", "application", "document", "result", "out", "source", "Output", "config", "network", "stream", "target", "web", "queue", "control", "object", "cache", "address", "file", "other", "binary", "ou", "layer", "environment", "response", "operation", "current", "put", "buffer", "production"], "b": ["buf", "k", "m", "p", "e", "n", "fb", "bit", "lb", "bc", "sb", "f", "bs", "pb", "d", "rb", "batch", "cb", "mb", "h", "bf", "B", "i", "a", "l", "db", "base", "bar", "r", "br", "v", "bin", "c", "file", "be", "ob", "binary", "bi", "x", "buffer", "ab", "abs", "nb", "line", "bb"]}}
{"id1": "16804988", "id2": "5399593", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"init": [" startup", "ize", "image", "build", " initialized", "Init", "info", "it", "draw", "launch", " Init", "create", "parse", "config", "activate", "layout", "show", "load", "initial", "start", " initialization", "setup", "update", "format", "Initialized", "close", "construct"], "filename": ["fd", "SourceFile", "prefix", "fn", "ppa", "jpg", "uri", "txt", "ssl", "sf", "length", "n", "loc", "il", "username", "online", "journal", "title", "phrase", "doi", "folder", "f", "fax", "password", "nil", "kn", "download", "dll", "metadata", "config", "size", "directory", "l", "fil", "license", "files", "which", "Filename", "kl", "string", "file", "params", "name", "upload", "loader", "binary", "path", "location", "word", "content", "utf", "fp", "ename", "database"], "dim": ["param", "m", "span", "sam", "wid", "image", "marg", "g", " reim", "dr", "fi", "num", "thin", "info", "project", "scale", "si", "wm", "iframe", "part", "shape", "du", "py", "dimension", "spec", "imm", "fm", "d", "dat", "index", "val", "dm", "ims", "cm", "multi", "config", "size", "width", "im", "gm", "di", "mi", "Dim", "min", "slice", "div", "lim", "dist", "grid", "fac", "grad", "diff", "ext", "mod", "format", "dem", "dom", "p", "img", " Dim"], "w": ["k", "m", "u", "z", "e", "wt", "b", "n", "en", "height", "weight", "f", "o", "d", "ow", "ew", "wh", "wd", "s", "rw", "i", "W", "win", "y", "max", "width", "a", "l", "fw", "r", "v", "wa", "c", "t", "x", "q", "sw", "p", "hw"], "h": ["k", "u", "hd", "z", "e", "j", "b", "n", "uh", "en", "ah", "height", "rh", "bh", "ph", "ht", "f", "hs", "o", "d", "s", "hm", "th", "kh", "y", "oh", "l", "gh", "v", "c", "t", "ih", "ha", "hr", "sh", "x", "H", "q", "p"], "in": ["ins", "ssl", "resource", "In", "b", "ax", "n", "connection", "io", "fb", "data", "serv", "inc", "socket", "f", "impl", "gin", "input", "din", "IN", "inn", "read", "cl", "out", "el", "conn", "amin", "i", "is", "source", "kin", "reader", "src", "win", "nin", "stream", "l", "login", "min", "r", "id", "ac", "bin", "file", "err", "fc", "fac", "pin", "cf", "ini", "as", "again", "fe", "fp", "lib", "cgi"], "ff": ["fd", "buf", "uf", "fl", "lf", "sf", "ffe", "cmp", "fed", "fb", "back", "fff", "xff", "f", "fp", "cb", "eff", "bf", "ulp", "library", "buff", "iff", "fx", "file", "FF", "ouf", "af", "fc", "aff", "ctx", "cf", "ef", "fe", "pp", "feed", "bb", "df"], "url": ["ls", "fl", "uri", "ssl", "e", "image", "resource", "ll", "sf", "fr", "b", "server", "connection", "io", "fb", "f", "zip", "www", "URL", "feed", "download", "source", "src", "stream", "l", "web", "base", "string", "file", "ob", "sl", "path", "Url", "http", "fp", "open"]}}
{"id1": "6008635", "id2": "16142024", "code1": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"referredFilesChanged": ["referredFilesChange", "referredfilesChange", "referredFileschanged", "revertedFileschanged", "referredFilechanged", "referredFileChange", "revertedFilesChanged", "referredfileschanged", "revertedFilesChange", "referredFileChanged", "referredfilesChanged"], "IOException": ["IOError", " IOError", "IPException", "DownloadError", "IPception", "Downloadception", "DownloadException", "IOception", " IOception", "IPError"], "file": ["page", "pe", "log", "uri", "FILE", "e", "message", "sf", "ile", "image", "b", "resource", "style", "le", "server", "info", "data", "single", "link", "part", "folder", "entry", "it", "document", "model", "feed", "type", "live", "class", "source", "dir", "directory", "filename", "l", "work", "use", "db", "files", "base", "object", "id", "string", "handler", "name", "full", "File", "path", "line", "mail", "fe", "http", "fp"], "url": ["page", "log", "fl", "ssl", "z", "e", "ll", "cert", "resource", "uri", "server", "b", "g", "n", "connection", "loc", "html", "build", "channel", "impl", "www", "URL", "coll", "ch", "h", "api", "rl", "l", "web", "object", "id", "v", "service", "image", "sl", "path", "Url", "http", "feed", "bb", "open"], "f": ["fd", "fo", "m", "p", "fl", "fr", "lf", "e", "sf", "b", "conf", "n", "form", "info", "fb", "func", "folder", "fa", "coll", "feed", "fs", "s", "inf", "rf", "i", "filename", "l", "files", "fx", "r", "v", "c", "name", "fc", "af", "t", "cf", "path", "F", "fe", "fp", "lib"]}}
{"id1": "21995302", "id2": "416857", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "label": 0, "substitutes": {"open": ["ize", " start", " OPEN", "to", "un", "res", "resource", " transfer", "write", "build", "en", "init", " close", "it", "o", "set", " opening", "end", "handle", "process", " opener", "xml", "create", "parse", "add", "opening", "stream", "Open", "oc", "change", " Open", "load", "start", "initial", "re", " reopen", "fix", "get", "update", "close", "use", " opened"], "input": ["ink", "text", "ssl", "resource", "image", "connection", "form", "event", "io", "data", "this", "socket", "inc", "output", "in", "document", "audio", "error", "accept", "out", "type", "inf", "container", "element", "instance", "i", "source", "class", "temp", "reader", "pull", "client", "config", "keep", "stream", "PUT", "command", "base", "inner", "Input", "object", "exec", "file", "upload", "context", "current", "state", "buffer", "argument", "http", "feed", "request"], "uri": ["prefix", "direction", "resource", "image", "connection", "manager", "database", "ki", "io", "info", "data", "adi", "username", "si", "verb", " URI", "doi", "definition", "document", "via", "result", "route", "str", "ci", "element", "instance", "i", "source", "uni", "api", "abi", "uid", "directory", "li", "di", "cli", "mi", "pi", "eni", "base", "object", "id", "address", "string", "gi", "file", "URI", "origin", "service", "iri", "absolute", "next", "path", "ui", "response", "qi", "state", "picture", "bridge", "http", "ri"], "url": ["ls", "text", "ssl", "resource", "server", "b", "connection", "io", "data", "link", "socket", "channel", "f", "impl", "URL", "coll", "ref", "bel", "i", "source", "api", "config", "li", "stream", "l", "base", "id", "address", "string", "file", "ob", "sl", "plug", "path", "Url", "layer", "state", "buffer", "http", "feed", "ball", "char", "browser"]}}
{"id1": "21181542", "id2": "21998571", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "label": 0, "substitutes": {"deleteRoleType": [" deleteRoletype", "deleteroleType", "deleteRoletype", "deleteResourcetype", " deleteRoleTyp", "deleteFunctionType", "deleteRoleTyp", " deleteroleTypes", "deleteroleTyp", "deleteResourceType", " deleteroleType", "deleteroletype", "deleteroleTypes", "deleteResourceTypes", "deleteFunctiontype", "deleteResourceTyp", " deleteRoleTypes", "deleteRoleTypes", " deleteroletype", "deleteFunctionTypes", "deleteFunctionTyp", " deleteroleTyp"], "id": ["ID", "url", "uri", "kid", "parent", "length", "vid", "view", "connection", "lock", "like", "data", "info", "version", "mid", "sid", "part", "in", "model", "it", "f", "aid", "Id", "index", "pid", "error", "key", "type", "end", "rid", "code", "uid", "source", "i", "is", "section", "edit", "ip", "ids", "object", "address", "string", "start", "name", "path", "ident", "oid", "request"], "namespaceId": ["namespacesInfo", "namespaceContext", "namespacedInfo", "memberspaceId", "asentityName", "namesspaceId", "membersetId", "nspaceid", "namespacedType", "namesaceID", "namesentityName", "asentityInfo", "namesaceInfo", "nspaceId", "namespacesid", "namesenceType", "workspaceType", "memberspaceType", "NamespaceId", "aspaceID", "workspacesid", "workspaceKey", "memberspaceName", "namespaceKey", "namespacesContext", "namespacesID", "namesetid", "namesentityID", "Namespaceid", "workspaceInfo", "namesentityId", "namesaceId", "nspaceID", "aspaceName", "namesplaceid", "namesetId", "namesenceId", "namesspaceKey", "membersetid", "workspacesId", "workspacePath", "worksspacePath", "workspaceId", "namespacesKey", "workspacesType", "namespaceid", "worksspaceId", "namespacedId", "workspaceid", "workspaceContext", "namespacesName", "nsaceid", "namesaceid", "worksspaceInfo", "namespacedName", "NamespacedType", "namesplaceInfo", "NamespaceName", "namesspaceInfo", "namespacedKey", "namesentityInfo", "namesenceid", "NamespaceType", "namesaneName", "namesetID", "namespacePath", "namespaceType", "Namespacedid", "namesaceType", "namespacedid", "nsaceID", "aspaceInfo", "namesplaceId", "membersetName", "NamespacedName", "namespaceInfo", "nspaceInfo", "nsaceInfo", "namespaceID", "namesetInfo", "namesaneId", "namespaceName", "namesetType", "worksspaceKey", "NamespacedId", "namesspacePath", "nsaceId", "workspacesContext", "namesenceContext", "asentityId", "namespacedPath", "namesaneType", "namesaneid", "memberspaceid", "membersetType", "asentityID", "aspaceId", "namesplaceID", "namespacesType", "namespacesId", "namesaceContext", "namespacesPath", "namesetName"], "removeReferencesInRoleTypes": ["removeReferencesFromRoleNames", "removeReferencesInroleRelations", "removeReferencesInRoleType", "removeReferencesInServiceRelations", "removeReferencesedInroleType", "removeReferencesedInroletypes", "removeReferencesInServiceType", "removeReferencesInRoletypes", "removeReferencesInRuleType", "removeReferencesedInRoleTypes", "removeReferencesFromRoleRelations", "removeReferencesedInRoleNames", "removeReferencesInRuleRelations", "removeReferencesFromroleNames", "removeReferencesedInroleTypes", "removeReferencesInServiceNames", "removeReferencesedInroleNames", "removeReferencesInRoleNames", "removeReferencesFromroleTypes", "removeReferencesInRoleRelations", "removeReferencesInroleType", "removeReferencesInServiceTypes", "removeReferencesFromroleRelations", "removeReferencesInRuleTypes", "removeReferencesFromroleType", "removeReferencesInRuleNames", "removeReferencesInroletypes", "removeReferencesInroleTypes", "removeReferencesedInRoletypes", "removeReferencesedInRoleType", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInRuletypes", "removeReferencesFromRoleType"], "permit": ["permits", "permmissions", "Permissions", "perMIT", "PERMIT", "PerMIT", "permission", "recmits", "permMIT", " perit", "Perit", "Permit", "permmit", "recmit", "recmission", "Permits", " permission", "Permission", "permissions", " permits", "perit", "PERmission", "permmission", "PERmissions", "recit", "PERmit"], "exist": ["purpose", "icate", "include", "write", "apply", "cmp", "except", "form", "destroy", "know", "stick", "inc", "draw", "check", "fail", "index", "support", "fill", "existence", "create", "add", "ist", "register", "keep", "edit", "delete", "same", "present", "match", "start", "list", "continue", "destruct", "existing", "diff", "existent", "cont", "ident", "front", "update"], "msgBuf": [" msgBuff", "msgEBuff", " msgFuf", "msgPlaf", "messageFbox", "msgPluf", "msgEBuf", " msgFbuf", "messageBbuf", "msgDuff", "msgAUF", "msgBbox", "msgFBUF", "messageFbuf", "msgDBuff", "msgBbuf", "msgFuf", "messageAuf", "msgFundle", "msgFbox", "msgDbuf", "msgDaf", "msgBob", "msgBraf", "msgLuff", "msgBUF", "msgDBuf", "messageAbuf", "msgPluff", " msgLaf", "msgLuf", "msgFBob", "msgEBbuf", "msgFBuff", "msgCuf", " msgLuff", "messageBuf", "msgLUF", "msgCuff", " msgFuff", "msgLaf", "msgLundle", "msgFUF", "msgFBuf", "msgBaf", "msgAraf", "messageBuff", "messageFob", "msgAuf", " msgFraf", "messageFUF", "messageBob", "msgAuff", "msgFbuf", " msgBundle", "messageBbox", "msgAbox", "msgDuf", "msgFob", "msgCob", "msgBundle", "msgLob", "msgAbuf", "msgAob", "msgAbuff", " msgBbuf", " msgFbuff", "msgFaf", " msgLundle", "msgBbuff", "msgFuff", " msgBaf", " msgFaf", "messageFuf", "messageFuff", " msgBbuff", "messageBUF", "msgFbuff", "msgAaf", "messageAuff", "msgBuff", " msgLuf", "messageAUF", "msgDBbuf", "msgFraf", " msgBraf", "msgEBbox", "msgCbuf", "msgDBUF", "msgPlundle"], "objects": ["notes", "values", "keys", "ins", "people", "pins", "kids", "archives", "products", "owners", "points", "os", "obs", "links", "users", "jobs", "parts", "cats", "relations", "archs", "oids", "agents", "apps", "plugins", "groups", "organisms", "parents", "features", "classes", "projects", "lines", "children", "results", "images", "properties", "pps", "files", "resources", "ids", "object", "frames", "names", "articles", "models", "obj", "bugs", "cells", "locks", "actions", "ops", "blocks", "types", "boxes", "members", "phones", "items", "ks", "roots"], "sqlRightId": ["sqlrightId", "sqlRightRef", "sqlRightPoint", "sqlRightType", "SQLRightID", "sqlRestId", "sqlRRef", "sqlRID", "sqlrightPoint", " sqlrightid", "sqlRestID", "SQLRightRef", "SQLRestID", "SQLRestId", "SQLRestid", "sqlLeftid", " sqlRightPoint", "sqlRId", " sqlrightId", "SQLRightid", "SQLRightId", "sqlRightID", "sqlRightid", " sqlrightPoint", "sqlrightid", "SQLRestRef", "sqlRestRef", " sqlrightType", "sqlLeftType", "sqlrightType", "sqlLeftId", "sqlLeftPoint", " sqlRightid", "sqlRestid", "sqlRid", " sqlRightType"], "sqlParent": [" sqlparent", "qlRoot", "suparent", "qlparent", "sqlParents", "suParents", " sqlRoot", "suParent", "qlParent", "suRoot", " sqlParents", "sqlparent", "qlParents", "sqlRoot"], "sql": ["replace", " db", "description", "log", "url", " SQL", "acl", "msg", "link", "session", " params", "error", " session", "conn", "s", "dl", " url", "delete", "db", "select", "repl", "sl", "operation", " msg", "where", "update", "SQL", "ql"], "pstmt": ["pctbl", " pSttr", "pftr", "pStm", " pndmt", "pndmb", "Pcttr", " pstmb", "pstatnt", " pStmt", "pctmb", "pmtbl", "postnt", " pstnt", "New", "pStct", "Security", "pmtmb", " pStm", "Pctct", "pstbl", "_", "pstrtr", "this", "pstm", "All", "pfct", "pStmt", " pStct", "add", "pstrm", "Pctmd", "pstmd", "pctmr", "Pstct", " pstmr", "pctm", "psttr", " pndmb", "pctct", "Pstmd", "postct", "Pctmt", "s", " pndct", " pstbl", "pndct", "pmtct", "pfmt", "pstatmt", "postmr", " postnt", "pmtmd", "pfmd", "pstatct", "Pstmt", "pstmb", "pstatmr", " pstm", "pctmd", "pmtmt", "pstmr", "pndbl", "The", "postmt", " pstct", "Error", "pstct", "pstnt", "pstrmt", "pctnt", "pSttr", "pndmt", " pndbl", "delete", " postmt", " postmr", "pstrct", " psttr", "pmttr", "pctmt", " postct", "Delete", "Psttr", "pcttr"], "typeGid": ["typegID", "linkGid", "linkGID", "TypeCmin", "TypeCID", "linkGoid", "typeGUid", "typeGVID", "typeGUname", "typegname", "TypeGmin", "typeGmin", "typeAccid", "typeWID", "TypeGid", "linkGname", "typeCname", "typeGname", "TypeCname", "TypeGname", "typegid", "typeGoid", "linkGVID", "TypeGID", "typeGVoid", "typeGID", "typeGUoid", "linkGVid", "typeWid", "linkGVoid", "TypeCid", "linkGVname", "typegoid", "typeGUID", "typeCmin", "typeGVid", "typeCID", "typeAccID", "typeAccname", "typeAccmin", "typeWname", "typeWmin", "typeCid", "typeGVname"], "defaultLevel": ["configDepth", "configCl", " defaultCl", "DefaultLevel", "defaultCl", "defaultMode", "configMode", " defaultDepth", "configLevel", "DefaultCl", "defaultDepth", " defaultMode", "DefaultDepth", "DefaultMode"], "success": ["warning", "replace", "resp", "message", "successfully", "complete", "failed", "successful", "data", "reg", "status", "result", "fail", "launch", "batch", "error", "accept", "test", "results", "Success", "progress", "roll", "match", "submit", "continue", "response", "serial"]}}
{"id1": "3024970", "id2": "7425022", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamAndOutputFile", "testCopy_inputStreamAndInputArray", "testCopy_inputStreamAndInputFile", "testCopy_inputStreamToOutputArray", "testCopy_inputStreamToOutStream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamToOutFile", "testCopy_inputStreamToInputArray", "testCopy_inputStreamToOutArray", "testCopy_inputStreamAndInputStream", "testCopy_inputStreamAndOutputstream", "testCopy_inputStreamAndOutputArray", "testCopy_inputStreamToInputstream", "testCopy_inputStreamToOutstream", "testCopy_inputStreamAndInputstream", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamToInputStream", "testCopy_inputStreamAndOutputStream"], "in": ["proxy", "include", "ex", "ins", "url", "ssl", "image", "In", "n", "connection", "init", "data", "this", "inc", "gin", "it", "input", "din", "IN", "inn", "index", "read", "s", "conn", "pass", "cin", "i", "is", "win", "rin", "reader", "source", "inside", "nin", "a", "login", "inner", "min", "r", "id", "token", "bin", "con", "err", "c", "file", "up", "pin", "ini", "as", "query", "arin", "again", "update", "isin"], "baout": ["aaout", "caagain", "BAagain", "BAout", "aaoff", "BaOUT", "BAOut", "Baout", "baoff", "paOUT", "Bain", "aaOut", "paart", " baOUT", "bain", "caoff", "baOut", "paOut", "BAoff", " baart", " bain", "paout", "BAOUT", "cain", "baOUT", "caout", "caOUT", "caOut", "pain", "baart", "paagain", "BaOut", "baagain", "BAart", "BAin", "aain"], "out": ["at", "to", "ex", "log", "array", "default", "image", "copy", "parent", "b", "In", "n", "lock", "io", "data", "inc", "part", "output", "exp", "o", "inas", "IN", "Out", "conn", "with", "client", "base", "outs", "object", "cache", "exec", "file", "obj", "up", "ou", "OUT", "pool", "buffer", "again", "line", "ext"], "count": ["Count", "call", "parent", "info", "weight", "limit", "cond", "check", "ref", "error", "type", "code", "process", "max", "work", "base", "found", "cache", "counter", "load", "file", "start", "name", "pool", "head", "from"]}}
{"id1": "1769771", "id2": "14231545", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "CopyFiles", " copyFiles", "copyfile", "CopyChannel", " copyfile", "copyChannel", "transferfile", "transferChannel", " copyChannel", "copyFiles", "Copyfile", "transferFiles", "transferFile"], "in": ["m", "ex", "ins", "url", "image", "In", "lock", "io", "data", "inc", "f", "input", "IN", "inn", "lin", "index", "i", "source", "win", "reader", "config", "l", "work", "login", "inner", "base", "min", "id", "bin", "file", "c", "name", "diff", "pin", "query", "again"], "out": ["prefix", "ex", "writer", "default", "write", "image", "server", "plain", "call", "resource", "b", "n", "io", "off", "dot", "external", "output", "o", "Out", "conn", "target", "base", "outs", "point", "user", "cache", "string", "v", "exec", "file", "c", "name", "extra", "up", "w", "OUT", "x", "again", "p", "ext"], "inChannel": ["outClient", "outchannel", "inputChan", "inputChannel", "InStream", " inStream", "InChan", "INChannel", "insChannel", " inchannel", "inClient", "InChannel", "insChan", "inStream", "inChan", "binStream", "INStream", "inchannel", "binClient", "binchannel", "binChannel", "insStream", "winStream", "INchannel", "inputchannel", " inChan", "binChan", "outStream", "inputStream", "insClient", "winChannel", " inClient", "InClient", "outChan", "winChan", "Inchannel", "INChan", "winchannel"], "outChannel": ["outchannel", "inputChan", "inputChannel", "nChan", "nManager", "outputStream", "inConnection", "OutChan", " outManager", "outCh", "inStream", "inController", "inChan", " outChan", "outManager", "nStream", "OutConnection", "OutChannel", "inchannel", "inputchannel", "Outchannel", " outchannel", "inCh", "outputCh", "inputController", "outStream", "nChannel", "inManager", " outStream", "outputChan", "outChan", " outCh", "outController", "outputController", "outConnection", " outConnection", "outputChannel", "outputchannel"]}}
{"id1": "13886238", "id2": "20619879", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"init": ["art", "build", "Init", "info", "reset", "it", " discover", "check", "launch", "error", "test", "rest", " Init", "strap", "parse", "config", "activate", " reload", "load", "start", "destruct", "initialized", "setup", "update", "construct", "open"], "backupFile": ["backoutFile", "BackdownFile", "backupFiles", "lookoutFILE", "backupfile", "backupFILE", "BackdownStream", "lookoutFile", "BackureFiles", "BackureSourceFile", "BackupF", "backbookF", "backUPFiles", "backupStream", "backbookFiles", "backupsDir", "backdownF", "backdownFile", "backureFile", "backupsFiles", "backacyFolder", "backacyfile", "backbackFILE", "backdownFiles", "BackureFile", "backUPFile", "backbackFolder", "BackdownFiles", "backoutfile", "lookoutFolder", "backbackFile", "BackupSourceFile", "backrapSourceFile", "lookupfile", "backupDir", "backureFiles", "backrapFiles", "BackupStream", "backUPF", "BackupDir", "backacyFILE", "backdownStream", "backureDir", "backrapFile", "backUPStream", "backupSourceFile", "backupF", "backacyFile", "BackureDir", "backupsSourceFile", "backbookFile", "BackupFiles", "backupsFile", "backureSourceFile", "backupFolder", "lookupFolder", "backoutFILE", "backbackfile", "lookupFILE", "lookoutfile", "backbookStream", "BackupFile", "backoutFolder", "BackdownF", "lookupFile", "backrapDir"], "buff": ["buf", "font", "uf", "pad", "bind", "txt", "length", "build", "b", "cp", "cod", "cmd", "fb", "back", "ph", "sb", "shape", "cond", "now", "zip", "pb", "ch", "rb", "utf", "comb", "cb", "Buff", "mb", "gg", "bf", "uff", "bound", "boot", "flush", "ffff", "grab", "comment", "bg", "ff", "oct", "slice", "load", "gz", "gb", "app", "fab", "cast", "ob", "buffer", "comp", "fe", "pp", "feed", "bb", "char"], "in": ["ins", "ssl", "url", "e", "image", "In", "b", "n", "connection", "data", "inc", "socket", "part", "old", "gin", "f", "input", "din", "IN", "inn", "lin", "s", "pass", "el", "cin", "i", "win", "reader", "inside", "nin", "l", "stream", "login", "inner", "min", "slice", "r", "id", "ac", "exec", "bin", "con", "c", "up", "diff", "pin", "get", "ini", "or", "again", "serv", "isin"], "out": ["prefix", "ex", "gen", "writer", "ins", "one", "copy", "b", "conf", "n", "ax", "io", "sync", "inc", "socket", "part", "output", "exp", "o", "IN", "Out", "conn", "pass", "win", "reader", "client", "co", "inner", "outs", "user", "exec", "bin", "file", "err", "up", "net", "lib", "OUT", "again", "line", "serv", "doc", "ext"], "read": ["k", "bind", "count", "view", "data", "reading", "search", "fill", "row", "pass", "roll", "ad", "send", "r", "exec", "start", "find", "readable", "ink", "text", " Read", "en", "input", "index", "Read", "i", "add", "parse", "max", "iter", "skip", "x", "close", "feed", "log", "play", "length", "build", "ok", "sync", "last", "check", "reads", "d", "seek", "run", "end", "size", "ind", "id", "wait", "next", "buffer", "use", "block", "open", "write", "ask", "copy", "se", "b", "n", "lock", "lex", "child", "raw", "reach", "ride", "connect", "READ", "reader", "work", "ip", "load", "select", "get", "current", "level", "sleep"], "reportWriter": [" reportJournal", "summaryPublisher", "exportJournal", "reviewEditor", "reportedEditor", "reportWalker", "resultPage", "reportApplication", " reportWalker", "reportedHelper", " reportHelper", " reportPublisher", "exportApplication", "reportEditor", "reportedDriver", " reportReader", "exportReader", "resultWrite", "summaryWrite", "ReportWrite", "reportedTime", "exportWalker", "reportedWs", "exportWrite", "commentWrite", "reviewEngine", "ReportReader", "reportPage", "ReportApplication", "exportHelper", "reviewWrite", " reportEditor", " reportWs", "reportWriting", "reportJournal", "reportedEngine", "reportHelper", " reportWrite", "exportWriter", "reviewTime", "commentWriter", "summaryPage", "commentStream", "reportedWalker", "resultStream", "reportTime", "reportedWriter", " reportApplication", "reportEngine", "reportWrite", "reviewWriter", "reportStream", "reportedReader", "resultWriter", "summaryWriter", "ReportWriter", "reportedWriting", "reportPublisher", "exportPublisher", " reportTime", "summaryStream", " reportWriting", "commentPage", "reviewDriver", " reportEngine", " reportDriver", "ReportWs", "reportDriver", "reportWs", "reportedWrite", "summaryJournal", "ReportWriting", "reportReader"], "restarting": ["restrupted", "RestartING", "restrupting", "restrited", "restarmING", "restartING", "restruptable", "restartsting", "Restritting", "Restritating", "restartating", "restritING", "restarsING", "restartting", "restartable", "restritable", "Restrited", "restarsating", "restarted", "RestritING", "Restritable", "Restartting", "restritating", "restruptING", "restarsting", "Restriting", "Restarting", "Restarted", "restarming", "restartsating", "restarsing", "restarmable", "restartsing", "restriting", "restarmed", "restritting", "restartsING", "Restartating", "Restartable"]}}
{"id1": "19307120", "id2": "7499186", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"sendPost": ["doSub", "dopost", "executePost", "sendPOST", "postSub", "postPOST", "sendSub", "executeSub", "doPost", "postPost", "executepost", "executePOST", "postpost", "sendpost", "doPOST"], "url": ["ur", "ls", "page", "uri", "ssl", "ll", "resource", "server", "html", "connection", "loc", "remote", "link", "route", "www", "URL", "source", "api", "l", "base", "address", "string", "file", "name", "service", "sl", "host", "full", "bug", "path", "Url", "location", "hub", "http", "feed"], "param": ["page", "resource", "connection", "par", "Param", "info", "data", "part", "channel", "phrase", "output", "meter", "input", "ram", "password", "error", "Parameter", "temp", "source", "comment", "config", "base", "prom", "object", "address", "string", "patch", "question", "params", "name", "extra", "arg", "proc", "arm", "path", "query", "p"], "result": ["description", "res", "array", "default", "message", "report", "resource", "reason", "data", "msg", "output", "status", "answer", "valid", "error", "date", "test", "our", "home", "results", "comment", "true", "work", "Result", "user", "feature", "found", "match", "string", "load", "err", "success", "params", "extra", "grade", "ret", "json", "response", "runner", "function", "value", "buffer", "current", "expected", "request"], "httpurl": ["httpconfig", "workurl", "baseconfig", "phpurl", "httpUrl", "workcf", "phpUrl", "httpURL", "phpcf", "phpURL", "phpconfig", "baseurl", "workconn", "phpconn", " httpconfig", "httpconn", "workURL", " httpconn", " httpUrl", " httpURL", " httpcf", "baseURL", "baseUrl", "httpcf"], "httpConn": ["HttpExec", "webConnect", "httpsconn", "perExec", "perConn", "urlConnect", "phpConn", "webCon", "httpExec", "httpConnect", "httpsConnection", "httpsCon", " httpExec", "HttpConnect", " httpConnect", "perConnect", "webConnection", "urlCon", "phpconn", " httpCon", "HttpConnection", "webconn", "phpConnection", "HttpCon", "httpsConn", " httpConnection", "httpconn", " httpconn", "HttpConn", "urlConn", "Httpconn", "perconn", "webConn", "httpCon", "urlConnection", "httpConnection", "phpConnect", "urlconn"], "out": ["prefix", "ex", "log", "writer", "flow", "write", "plain", "copy", "null", "b", "In", "n", "connection", "parent", "init", "io", "outer", "inc", "socket", "output", "f", "exp", "o", "password", "Out", "h", "key", "conn", "pass", "temp", "flush", "cli", "dump", "inner", "outs", "user", "r", "file", "err", "extra", "w", "net", "OUT", "word", "plus", "again", "p"], "in": ["into", "rec", "ins", "In", "b", "init", "inc", "gin", "f", "input", "din", "IN", "lin", "inn", "read", "conn", "s", "cin", "i", "is", "win", "rin", "reader", "kin", "nin", "stream", "login", "inner", "min", "r", "id", "ac", "bin", "con", "err", "ic", "re", "pin", "ini", "as", "again", "serv", "isin"], "line": ["page", "text", "pe", "LINE", "log", "unit", "message", "e", "lf", "le", "letter", "cell", "data", "ge", "link", "entry", "model", "str", "lin", "cl", "lines", "job", "key", "inline", "row", "code", "end", "me", "i", "source", "comment", "reader", "record", "l", "ip", "user", "r", "id", "string", "character", "file", "Line", "name", "continue", "sl", "sel", "pin", "response", "word", "lc", "cr", "block", "char"]}}
{"id1": "21754659", "id2": "6840241", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSenico", "getbuttonSenido", "getButtonJonendo", "getButtonSonico", "getbuttonSenendo", "getButtonJonira", "getButtonSenira", "getButtonSenendo", "getbuttonSonira", "getButtonJonico", "getButtonSonendo", "getButtonJonido", "getButtonSonira", "getbuttonSenira", "getButtonSenido", "getButtonSenico", "getbuttonSonendo", "getbuttonSonico", "getbuttonSonido"], "buttonSonido": ["buttonDonardo", "btnSonido", "btnSonado", "buttonSenado", "buttonSonigo", "buttonTanardo", "buttonTanado", "buttonHomardo", "buttonHonido", "buttonsonido", " buttonSenida", "btnDonigo", "buttonsonigo", " buttonSonida", "btnDonado", " buttonSonado", "ButtonSonado", "btnDonardo", "buttonSenigo", "buttonDonini", "buttonTanido", "buttonHonino", "btnDonido", "buttonHomado", "buttonHonardo", "buttonsonado", "ButtonDonido", "buttonSonado", "buttonDonino", "ButtonSonido", " buttonSenado", "buttonSonardo", "btnSonigo", "buttonDonida", "buttonHomida", "buttonSonino", "buttonDonado", "buttonHomido", "ButtonDonida", "buttonSenido", "buttonSenardo", "buttonSenida", "btnSonini", " buttonSonino", "ButtonDonado", "ButtonSonardo", "buttonsonardo", "buttonSenino", "buttonDonigo", "buttonSonini", " buttonSenido", "buttonDonido", " buttonSenardo", "ButtonDonini", " buttonSenino", "buttonHonado", "buttonTanida", "ButtonSonida", "buttonsonini", "buttonSonida", "buttonSenini", "ButtonDonardo", "btnSonardo", " buttonSonardo", "ButtonSonini"], "e": [" inst", " cause", "ee", " te", "event", " exc", " ace", " exception", " events", " je", " ate", " pe", " ie", " ignored", " fe", " Event", " ev", " en", "E", " invoked", " caught", "t", "Event", " exp", "ed", " other", " E"], "fc": ["fd", "FS", "fn", "fl", "fr", "ct", "lf", "CF", " FC", "FE", "wt", "roc", "fi", "fed", "xf", "tc", "il", "fb", "bc", "ec", "LC", "f", "GF", "WF", "wic", "fm", "flo", "PF", "mc", "fa", "Factory", "isc", "nc", "fs", "bf", "irc", "FC", "fx", "fw", "xc", "DC", "WC", "pc", "con", "c", "dc", "af", "cf", "wk", "F", "lc", "fe", "enc", "fp"], "returnVal": ["returnval", "continueValue", "backval", "ReturnNum", " returnNum", "continueval", " returnVAL", "continueVal", "backValue", "returnValue", "continueNum", "backVAL", "returnVAL", "ReturnValue", "Returnval", "ReturnVal", " returnval", "returnNum", "backVal", "ReturnVAL", " returnValue"], "file": ["to", "page", "log", "FILE", "url", "resource", "ile", "image", "sf", "uri", "b", "message", "connection", "up", "lock", "io", "info", "data", "single", "socket", "part", "folder", "f", "document", "zip", "input", "feed", "out", "type", "class", "source", "dir", "directory", "filename", "l", "use", "db", "files", "base", "user", "object", "local", "handler", "name", "binary", "global", "full", "File", "per", "php", "cf", "path", "get", "function", "fe", "http", "fp", "lib"], "rutaGlobal": ["rundaGeneral", "rutaGeneral", " rutoInternational", " rutaGeneral", "rutiLocal", " rutoGlobal", "rutaCore", "srettaLocal", "rundaInternational", "rettaLocal", "srettaGlobal", "srutaReal", "rutoLocal", "rutiInternational", "rutaLocal", "rettaInternational", " rutoGeneral", "rettaReal", "rutiGeneral", "rucaGlobal", "srutaInternational", "srettaInternational", "rottaLocal", "rutoCore", "srutaGeneral", "srutaLocal", "rucaInternational", "srutaGlobal", "rutoInternational", "rottaGlobal", "rettaGlobal", "rutiGlobal", "rottaCore", "srottaGlobal", "srottaCore", "rutoGeneral", "rottaGeneral", "srettaReal", " rutaInternational", "rugaLocal", "srottaGeneral", "rundaGlobal", "rugaGlobal", "srottaLocal", "rutaReal", "rutoGlobal", "rutaInternational", "rugaReal", "rucaGeneral", "rutiReal", "srutaCore", "rugaInternational", "rutiCore"], "rutaRelativa": ["rutaRelativ", "rutaRelarativism", "rutaRelarivism", "rutaRelarivas", "rutaMalarivo", "rutaRelattivo", "rutaRelattivism", "rutaRelativas", "rutaRelattiv", "rutaRelariva", "rutaRelATiv", "rutaRelarivo", "rutaMalativas", "rutaRelarativa", "rutaRelATivas", "rutaMalativa", "rutaRelativism", "rutaMalariva", "rutaRelarativas", "rutaRelATivo", "rutaRelattivas", "rutaRelateiva", "rutaMalativo", "rutaRelariv", "rutaRelateivo", "rutaRelATiva", "rutaRelateivism", "rutaRelarativ", "rutaRelarativo", "rutaMalativism", "rutaRelateiv", "rutaRelattiva", "rutaMalarivism", "rutaRelativo", "rutaMalarivas"], "fis": [" fir", "Fis", "xris", "FIs", "fir", " fiss", "friss", "xis", " fys", "Fos", "Fris", "fris", "Fir", "Fiss", " fris", "fys", "fIs", "fiss", "xys", "vis", "Fys", "xiss", "vos", "viss", "frir", "vIs", "fros", " fIs"], "fos": ["fo", "fileocks", "tfops", "fOS", "Fops", "Fos", "infos", "Fo", "fileo", "fileos", " fops", " fOS", "infOS", " fo", "fios", "focks", "tfos", "fileops", " focks", "Fios", "infios", "fops", "infis", "tfOS", "FOS", " fios", "Focks", "Fis", "tfo"], "canalFuente": ["canalFiencer", "canalKuente", "canalFuent", "canalKuenza", "canalFiente", "canalBuente", "canalFuante", "canalBuenza", "canalfuenza", "canulFuencer", "canallFuenza", "canallBuence", "canalFience", "canalsFuent", "canalfuente", "canulFient", "canalFuento", "canalBugent", "canalfugent", "canallBuenza", "canalsFuento", "canallBugent", "canalJuento", "canalKugent", "canalsFuante", "canalsFuente", "canalBuent", "canalsBuent", "canallFuente", "canalFUento", "canulFience", "canallBuente", "canalFient", "canalFUante", "canalBuence", "canulFiente", "canalsBuante", "canalKuence", "canalsBuento", "canalJuante", "canalFUent", "canallFuence", "canalBuento", "canalJuente", "canalJuencer", "canalsBuente", "canalFuence", "canalFuenza", "canalJuence", "canalBuante", "canalMuencer", "canalMuent", "canulFuent", "canulFuente", "canalFuencer", "canalFugent", "canalMuente", "canalMuence", "canulFiencer", "canalfuence", "canalFUente", "canallFugent", "canulFuence", "canalJuent"], "canalDestino": ["canaldestination", "canelCampino", "canalDestinos", "canalCampination", "canalldestino", "canalDestination", "canallDestino", "canaldestino", "canallDestinos", "canelDestination", "canalCampania", "canelDestina", "canelDestania", "canelDestino", "canalldestina", "canalNegania", "canalNegino", "canalCampino", "canalNegina", "canalldestania", "canallDestania", "canelCampination", "canaldestinos", "canalCampina", "canelCampina", "canalldestinos", "canalDestina", "canelCampania", "canaldestina", "canalNegination", "canalDestania", "canaldestania", "canallDestina", "canalCampinos"]}}
{"id1": "16572931", "id2": "21824901", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"unJar": ["copyTar", "putTar", "addServer", "updateTar", "updateServer", "updatejar", "putjar", "addJava", "putJava", "addTar", "updateJava", "putServer", "copyServer", "copyjar", "copyJava", "addjar"], "jarPath": ["javaDir", "erbEntry", " jarUrl", "relDir", "javaUrl", " jarFile", "garPath", "JarPath", "JarName", "jarDir", "jarLog", "javaLog", "garLog", "JarFile", "javaEntry", "jarpath", " jarLog", "javaName", "garpath", " jarDir", "browserpath", "relFile", "jarUrl", "erbPo", "javaFile", " jarpath", "javapath", "Jarpath", "browserName", "relEntry", "erbName", "JarEntry", "jarFile", "javaPath", "browserEntry", "JarUrl", "JarDir", "javaPo", " jarName", "browserPath", "erbPath", " jarPo", "jarPo", "garEntry", "jarName"], "jarEntry": ["javaDir", " jarUrl", "irName", " jarJar", "cookEntry", "javaUrl", "cookEnt", "xmlPath", "JarPath", "jarLog", "jarDir", "javaLog", "Jarentry", "aliasName", "javaEntry", " jarLog", "zipDir", "javaName", "irJar", "dropPath", " jarInfo", "xmlEntry", "javaentry", "dropInfo", "xmlInfo", "javaInfo", " jarDir", "irEntry", "cookDir", "jarUrl", "irentry", "zipEntry", "zipUrl", "aliasEntry", "aliasInfo", "JarEntry", "jarentry", "javaEnt", "dropEntry", "jarJar", " jarentry", "javaPath", "javaJar", "JarInfo", "jarEnt", "cookPath", " jarName", "zipName", "aliasEnt", "xmlLog", " jarEnt", "jarInfo", "dropentry", "jarName"], "path": ["prop", "default", "image", "core", "parent", "data", "step", "part", "not", "zone", "entry", "conn", "pass", "temp", "directory", "po", "string", "patch", "file", "root", "context", "right", "text", "uri", "resource", "this", "ph", "folder", "model", "zip", "ion", "key", "type", "test", "code", "cel", "config", "dir", "skip", "content", "prefix", "log", "url", "dest", "loc", "sync", "mode", "route", "str", "archive", "end", "out", "th", "src", "Path", "id", "binary", "pattern", "next", "location", "clean", "p", "lock", "ath", "project", "mount", "PATH", "it", "wd", "home", "cat", "source", "work", "inner", "base", "address", "name", "left", "host", "request"], "relPath": ["RelPath", " relType", "relType", "RelEntry", "RelType", "revType", "relativePath", "Relpath", "revPath", " relUrl", "relpath", "revEntry", " relpath", "relativeUrl", " relName", "revpath", " relEntry", "relName", "relativeName", "RelUrl", "relEntry", "relativepath", "RelName", "relUrl"], "jar": ["java", "gar", " Jar", "url", "z", "pack", "module", "j", "le", "b", "dr", "Jar", "rar", "zone", "folder", "entry", "py", "tar", "zip", "her", "fire", "drop", "archive", "ja", "bag", "job", "cur", "tab", "jo", "pkg", "xml", "plugin", "war", "dir", "ar", "car", "er", "base", "bar", "cook", "gi", "file", "binary", "sl", "keeper", "ler", "gap", "lib", "open", "ball", "browser"], "ze": ["pe", "z", "e", "se", "le", "ce", "ge", "je", "sle", "ZE", "ie", "ele", "entry", "pse", "oe", "zip", "ja", "zin", "zes", " je", "zzy", "te", "kee", "zen", "de", "za", "aze", "zer", "ke", "zie", "be", "ipe", "zy", "zed", "sl", "zee", "zi", "ine"], "bin": ["bb", "bon", "proxy", "gen", "log", "pack", "resource", "ban", "b", "lock", "init", "abin", "data", "bit", "in", "cookie", "brain", "zip", "bis", "abi", "sin", "plugin", "win", "boot", "cin", "kin", "web", "len", "login", "inner", "base", "jin", "gi", "file", "bed", "bas", "bian", "binary", "bot", "pin", "bi", "spin", "lib", "isin"]}}
{"id1": "4686922", "id2": "11962480", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesAsfile", "extractResourceToFiles", "extractResourceInResource", "extractResourcesToFile", "extractResourcesAsFile", "extractResourceAsFile", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceAndfile", "extractResourceInFiles", "extractResourceAndResource", "extractResourceToResource", "extractResourceAsfile", "extractResourceAndFile", "extractResourceTofile", "extractResourceAndFiles", "extractResourceAsFiles", "extractResourceInfile", "extractResourceInFile", "extractResourcesAsResource", "extractResourcesAsFiles", "extractResourceAsResource", "extractResourcesToResource"], "resourcePath": ["sourcepath", " resourceId", "Resourcepath", " resourceFolder", " resourcepath", "stringFolder", "stringpath", "resourceId", "resourcepath", " resourceUrl", "ResourcePath", "ResourceUrl", "stringPath", "resourceFolder", "servicepath", "servicePath", "resourceUrl", "sourceUrl", "sourceId", "sourcePath", "ResourceId", "serviceFolder"], "dest": ["prop", " Dest", "txt", "default", "resource", "const", "Dest", "destroy", "flat", "die", "data", "store", "project", "later", "output", "folder", "result", "route", "comb", "done", " destination", "home", "temp", "source", "class", "src", "config", "tmp", "filename", "target", "resources", "de", "trans", "desc", "file", "dist", "sup", "sac", "wb", "path", "transfer", "content", "contract", "img"], "in": ["rec", "ins", "url", "resource", "image", "In", "b", "n", "connection", "init", "thin", "like", "this", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "lin", "conn", "pass", "cin", "i", "is", "win", "source", "reader", "rin", "kin", "inside", "nin", "sin", "login", "inner", "r", "id", "bin", "c", "con", "file", "re", "up", "ini", "as", "plus", "arin", "again", "isin"], "out": ["at", "norm", "ex", "writer", "ins", "one", "image", "server", "copy", "null", "b", "n", "In", "ax", "parent", "io", "outer", "off", "this", "sync", "outside", "inc", "socket", "cos", "output", "cookie", "f", "all", "o", "Out", "s", "conn", "temp", "i", "source", "client", "a", "co", "outs", "user", "cache", "exec", "bin", "file", "err", "obj", "app", "up", "w", "net", "OUT", "lib", "auto", "again", "boot", "ext"]}}
{"id1": "5436973", "id2": "10451698", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStringStrict", "httpToStringUrict", "httpToStringCupid", "httpToPageCored", "httpToStringCrict", "httpToStringComp", "httpToStringStored", "httpToStringstomp", "httpToPageStupid", "httpToPageComp", "httpToStringstored", "httpToPageStrict", "httpToPageCupid", "httpToStringstupid", "httpToPageStored", "httpToStringUored", "httpToPageCrict", "httpToPageStomp", "httpToStringStomp", "httpToStringUomp", "httpToStringCored", "httpToStringstrict", "httpToStringUupid"], "url": ["ls", "secret", "page", "uri", "ssl", "resource", "image", "server", "html", "connection", "version", "channel", "f", "route", "str", "URL", "www", "href", "i", "source", "api", "config", "l", "base", "id", "address", "string", "https", "file", "name", "service", "sl", "host", "domain", "path", "Url", "location", "http", "feed", "request"], "IOException": ["IOError", " IOError", "Configurationception", "ConfigurationException", "Downloadception", "DownloadException", "IOception", " IOception", "ConfigurationError", "DownloadError"], "HttpException": ["httpception", "httpException", "HTTPException", "Httpception", "HTTPception", "Downloadception", "DownloadException"], "InterruptedException": ["InterruptExcept", " InterruptExcept", " InterruptedExcept", "InterruptedError", "InterIOExit", "InterruptException", "InterruptedExcept", "InterruptExit", " InterruptedExit", "InterSleepError", " InterruptExit", "InterSleepException", "InterIOExcept", " InterruptError", " InterruptedError", "InterIOException", "InterSleepExcept", "InterSleepExit", "InterruptedExit", " InterruptException", "InterruptError", "InterIOError"], "URISyntaxException": ["URISyntntaxception", "URISyntaceEx", "URISyntaceception", "URISlntaxception", "URISyntaxError", "URISlaxException", "URISlntaxError", "URISyntntaxException", "URISlaxEx", "URISyntaceException", "URISyntntaxEx", "URISlntaxEx", "URISlaxError", "URISyntaceError", "URISyntaxception", "URISyntaxEx", "URISyntixError", "URISyntixEx", "URISyntntaxError", "URISlaxception", "URISlntaxException", "URISyntixception", "URISyntixException"], "pageDump": ["pageDumm", "pageDsumps", "pagedumps", " pageDumper", "pageFumps", "pageDoumping", "pageLumper", "pageDumper", "pageDumping", " pageBumps", "pageBumps", " pageBash", "pageDoump", "pageFash", "pageLumps", "pageDsumper", "pageDsump", "pageDoumper", "pagedump", "pagedash", "pageBumper", " pageDash", " pageBump", "pageLump", "pageBash", "pageFump", "pageDash", " pageDumping", "pageDoumm", "pageDoumps", "pageLumping", "pagedumper", " pageBumm", "pageDumps", "pageFumper", "pageDsumm", " pageBumper", " pageDumm", "pageBumm", "pageBump", "pageBumping", " pageBumping", " pageDumps"], "httpget": [" httpGet", "hrgot", "phpfind", "httpstart", "httpGet", " httpstart", "phpget", "phpstart", "urlGet", "phget", "httpset", " httprequest", " httpfind", "phpGET", "httget", "phstart", "httprequest", "hrGet", "httpGET", " httpGET", " httpset", "urlrequest", "Httprequest", "httpgot", "httfind", "HttpGet", "httstart", "Httpget", "Httpset", "phgot", "urlset", "httpfind", "httGET", "hrstart", "hrget", "urlget", "phGet", " httpgot"], "response": ["resp", "page", "res", "respond", "uri", "resource", "message", "server", "e", "body", "Response", "connection", "method", "data", "output", "application", "status", "document", "result", "reply", "error", "api", "object", "success", "relation", "full", "environment", "get", "json", "collection", "http", "request", "ception", "onse", "received"], "entity": ["resp", "page", "component", "ity", " entities", "unit", "resource", "e", "message", "image", "server", "Response", "body", "Entity", "connection", "event", "data", "output", "model", "document", "entry", "result", "translation", "ent", "error", "xml", "element", "instance", "article", "agent", "object", "security", " Entity", "service", "environment", "json", "query", "content", "collection", "person"]}}
{"id1": "20751378", "id2": "18114701", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"hashPassword": ["signPassword", " hashWord", " hashpassword", "signWord", "cryptPass", "signpassword", " hashPass", "cryptPassword", "cryptWord", "cryptpassword", "signPass", "hashPass", "hashpassword", "hashWord"], "password": ["crypt", "prefix", "text", "p", "padding", "description", "auth", "pad", "message", "plain", "sha", " passwords", "data", "username", "sword", "phrase", "input", "encrypted", "key", "wd", "python", "pass", "code", "seed", "number", "command", "user", "mac", "address", "token", "string", "cache", "security", "name", "w", "pattern", "words", "path", "word", "content", "Password", "secret", " Password", "database", "PASS"], "hash": ["html", "tag", "search", "phrase", "her", "sum", "addr", "ruby", "cache", "string", "security", "root", "put", "update", "secret", "text", "ash", "bolt", "message", "call", "style", "height", "rh", "version", "dig", "result", "hex", "index", "error", "key", "h", "code", "handle", "pkg", "oh", "dump", "alt", "match", "ssh", "json", "format", "replace", "log", "url", "uild", "length", "build", "math", "msg", "check", "proof", "memory", "gh", "user", "mac", "id", "square", "value", "array", "auth", "copy", "sha", "kh", "ashes", "work", "number", "base", "hed", "address", "history", "host", "ha", "Hash", "sh", "pool", "mod"], "md": ["mad", "m", "hd", "sd", " MD", "der", "Cmd", "xd", "nd", "sha", "cmd", "ME", "dig", "dd", "km", "gd", "f", "mc", "mag", "d", "vd", "od", "meta", "mb", "ms", "hm", "nm", "amd", "mg", "dm", "bd", "wd", "metadata", "pd", "MD", "mac", "mand", "mm", "sm", "ma", "gb", "am", "pm", "kg", "grad", "mt", "mod", "dh", "df"]}}
{"id1": "3809087", "id2": "22442270", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 0, "substitutes": {"getWave": ["readSound", "newWire", "newSound", " getwave", "newwave", "getwave", "getSound", "readWire", "getWire", " getWire", "newWave", " getSound", "readwave", "readWave"], "url": ["wave", "fn", "page", "fl", "fr", "uri", "resource", "image", "sf", "b", "loc", "field", "f", "fax", "Feed", "URL", "ref", "feed", "inf", "Ur", "source", "filename", "l", "lr", "ff", "base", "web", "r", "address", "string", "file", "name", "host", "File", "path", "Url", "word", "F", "fe", "http", "fp"], "Word": ["Field", "Folder", "Str", "Feature", "Weight", "Stream", "Key", " word", "Code", "Writer", "Content", "wd", "Term", "Tag", "W", "Function", "Name", "World", "Class", "Work", "Path", "Length", "Eng", "Part", "Msg", "Hack", "string", "Gender", "Line", "Wire", "Language", "File", "Time", "words", "Url", "Frame", "word", "F", "Words", "Dir", "Wave", "Token", "Message", "Rule", "Win", "Letter", "Text"], "FF": ["fd", "Field", "Folder", "FS", "FP", "FILE", "FE", "DF", "ELF", "Fi", "IP", "AF", "Feed", "URL", "P", "FD", "feed", "FB", "IF", "LL", "Fax", "TF", "ff", "Client", "FC", "IFF", "FA", "DC", "CC", " ff", "BB", "FL", "RC", "FH", "FM", "F", "SF", "fp", "FW"], "url2": [" url3", "f1", "url1", "URL1", " url4", "l4", "url3", "path1", "pathTwo", "f3", " urlDB", "URLTwo", "pathDB", "url4", "urlDB", "l3", "URL2", "URLDB", " url1", "l2", " urlTwo", "l1", "f2", "urlTwo", "path2", "f4"], "stream": ["fd", "wave", "forward", "ack", "fr", "ssl", "writer", "flow", "server", "view", "Stream", "form", "io", "steam", "socket", "raw", "channel", "output", "in", "loop", "f", "impl", "field", "input", "stack", "coll", "draft", "row", "live", "temp", "source", "reader", "src", "client", "roll", "driver", "sw", "thread", "flash", "ff", "transform", "slice", "pipe", "video", "string", "v", "handler", "file", "loader", "w", "sl", "host", "context", "path", "response", "http", "feed"], "Fdel": ["FiDel", "Fdestroy", "fdelete", "Fdelete", " FDel", " Ffin", "fdestroy", "Fifin", " Fdelete", " Fdestroy", "ffin", "fDel", "Ffin", "Fidestroy", "Fidelete", "Fidel", "FDel", "fdel"], "outstream": ["outputform", "outputStream", "outchannel", "outwriter", " outfile", "inwriter", " outreader", "Outform", "outmodel", "outputstream", "inStream", "instream", " outmodel", "outputwriter", "inreader", "inchannel", "outreader", "inputchannel", "inmodel", " outwriter", "outStream", "outfile", "inputStream", "outputmodel", "outputreader", " outStream", "outform", "inlog", "outputlog", "inputlog", "Outstream", "Outfile", "OutStream", "outlog", " outform", "inputstream", "outputfile", "outputchannel"], "bwriter": ["fbwriters", "outwriter", "bwr", "Bwrite", "Bbuilder", "bwriters", "fbwrite", "outwr", " bwrite", " breader", "fwriter", "bbuilder", " bWriter", "bbwriters", "Breader", "outreader", "breader", " bwr", "freader", "bbwr", "bbreader", "fwrite", " bwriters", " bwriting", " bbuilder", "bwrite", "outwriting", "fbuilder", "bWriter", "bbwriting", "bwriting", "Bwriter", "fbWriter", "fbwriter", "bbWriter", "bbwriter", "bbwrite"], "binput": ["byteset", "bisplit", "libput", "libcut", " binpos", "binlog", "bytesplit", "bitset", "sinset", "binwrite", "binstop", "biset", "bistop", "binsplit", "liblog", "winput", "binarylog", "binpos", "output", "bitwrite", "bytestop", "biput", " binstop", "sinput", "binstart", " binstart", "bincut", " binsell", "biwrite", "bitpos", "libset", "outstart", "sincut", "sinlog", "binaryset", "bipos", "winstart", "outsell", "bitput", "binarycut", " binset", "outwrite", "winwrite", "winsell", "byteput", " binwrite", "binset", "binaryput", " binsplit", "binsell"], "len": ["ls", "lon", "cap", "ln", "fl", "seq", " lang", "lf", "fin", "label", "le", "length", "count", "lt", "n", "en", "num", "lan", "data", "rev", "ie", "part", "pos", "limit", "elt", "coll", "lin", "split", "Len", "end", "val", "el", "dl", "iter", "size", "li", "hl", "l", "fun", "base", "ann", "id", "lim", "bin", "low", "la", "sl", "pre", "lc", "enc", "line"]}}
{"id1": "5441579", "id2": "23335922", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"createPseudoUUID": [" createPseudoUuid", " createPseudoUUuid", " createPseudoPuid", " createPseoUMD", " createPseudoUUUID", " createPseudoPUID", " createPseudoUUMD", " createPseudoUUD", " createPseudoPUD", " createPseoUuid", " createPseoUUD", " createPseudoPMD", " createPseoUUID", " createPseudoUMD", " createPseudoUUUD"], "messageDigest": ["messageSignested", "messageDiger", "messageBuildester", "messageDesignEST", "messageBuilder", "maildigest", "messageDest", "messagedigester", "mailDiger", " messageDest", "MessageDigusher", "messagedigested", " messageDer", "messageSignest", "messagedigener", "messageSignener", "messagedigse", "messageSigner", "messagediger", "messageDigester", " messageDester", "maildigester", "messageBuildesting", " messageDigesting", "messageSignEST", "messagedigusher", "messageDer", "messageDesignester", "messageSignusher", " messageDiger", "mailDigEST", "messageSignester", "MessageDigested", "MessageDigener", "messageDester", "messagedigEST", "MessageDigest", "messagedigest", "messageDigesting", "messageDesignest", "MessageSignest", "MessageDigse", " messageDesting", "maildiger", "messageDesting", "MessageSignusher", "messageDigusher", "messageBuildest", "MessageDigEST", "maildigEST", "mailDigest", "messageDigested", "messageSignse", "messageSignesting", " messageDigester", "MessageSignester", "mailDigester", "messageDigse", "MessageDigester", "messageDigEST", "messageDigener", "MessageSignEST", "messageDesignusher", "messageDesigner"], "localHost": ["foreignDomain", "localAddress", "localhost", "foreignAddress", "foreignHost", "localPort", " localAddress", "remoteAddress", "localDomain", "foreignPort", "remotePort", "LocalHost", "remotehost", " localhost", "Localhost", "LocalAddress", "LocalPort", " localDomain", "LocalDomain", "remoteHost", " localPort"], "digestBytes": [" digastbytes", " digengeBytes", " digestBlocks", "digESTByte", "digestampbytes", "digesterBitcoin", "digenseParts", "digestedBlocks", "DigestByte", "digestFiles", "digesterFiles", "digendBitcoin", "Digesterbytes", " digastBytes", "digestedParts", " digesterBlocks", "digestWords", "digastBytes", " digesterbytes", "digestampBitcoin", "DigesterPoints", "digesterbytes", "digestGb", "digseBitcoin", "digastByte", "digesterParts", "digseByte", "digESTbytes", "digengeBytes", "digastTokens", "digestsPoints", "digestedBitcoin", " digesterBytes", "DigesterBytes", "digestsBytes", "DigesterFiles", " digengeByte", "digESTBytes", "digestBlocks", " digestParts", " digestBitcoin", " digestbytes", "DigestBitcoin", "digesterWords", "DigesterBitcoin", "Digestbytes", "digestedPages", "digESTBitcoin", "digestedBytes", "digestedByte", "DigestBytes", "digestedbytes", "digesterByte", " digestByte", "digesterPoints", "digestbytes", "digsePages", " digastByte", "digestPoints", "digengeByte", "digendbytes", "digESTPoints", "digestsByte", "digseBytes", " digesterParts", "digengeBitcoin", "digendBytes", "digesterBytes", " digengePages", "DigesterGb", "digestTokens", "digeterFiles", "digestPages", "DigestGb", " digengeBitcoin", " digastTokens", "digeterBytes", "digsebytes", "digenseBitcoin", "digastbytes", " digestTokens", "digensebytes", "DigestFiles", "digestByte", "DigesterByte", "DigestWords", "digestParts", "digengePages", "DigesterWords", "digestampBytes", "digesterGb", "digenseBytes", "digestampWords", "digenseWords", "digenseBlocks", "digeterByte", "digeterGb", "digseTokens", "digesterTokens", " digestPages", "digestBitcoin", "digesterBlocks", "DigestPoints"], "sb": ["buf", "ls", "kb", "sth", "url", "lp", "ssl", "txt", "sf", "b", "ss", "sv", "fb", "bt", "bh", "bp", "si", "usb", "xb", "lb", "shell", "bc", "pb", "SB", "su", "rb", "nl", "cb", "s", "conn", "bf", "ws", "abi", "bm", "src", "sym", "bg", "sg", "db", "lr", "bj", "abb", " SB", "ib", "ba", "BB", "sa", "obj", "gb", "ob", "binary", "sr", "sl", "sp", "ai", "wb", "bl", "vm", "lc", "buffer", "bi", "nb", "fe", "eb", "bs", "Bs", "bb", "nn"]}}
{"id1": "11305840", "id2": "873012", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"setUpdateCliente": ["setUpdateContactes", "setupdateClienteur", "setupdateclienten", "setUpdateclientes", "setupdatecliente", "setUpdateclienten", "setUpdateCompanyes", "setUpdateContacten", "setUpdatecliente", "setUpdateContacte", "setUpdateClientes", "setUpdateCompanye", "setUpdateCompanyeur", "setUpdateclienteur", "setupdateClienten", "setupdateclienteur", "setupdateClientes", "setUpdateCompanyen", "setUpdateClienteur", "setupdateclientes", "setupdateCliente", "setUpdateClienten", "setUpdateContacteur"], "IDcliente": ["IDquanto", " IDservere", "IDprojectee", "IDclientpe", "IDquante", "IDprojecte", "IDprojectpe", "IDCliente", "IDprojectes", "IDClientpe", " IDclientes", " IDclientee", " IDclientE", "ENDclientee", "IDClientee", "IDClientE", "IDquantisi", " IDserverpe", "ENDCliento", "IDclientee", "IDClientes", "ENDCliente", "IDClientisi", "IDcliento", "ID1000isi", " IDserveres", "ENDClientisi", "ENDclientisi", "IDCliento", "ENDcliento", "IDservere", "ID1000e", "IDclientisi", "ID1000ee", "IDserverpe", "ENDcliente", " IDclientpe", "IDserveree", " IDserveree", "IDclientE", "IDclientes", "IDserveres", "ID1000o", "ENDClientee", "IDserverE", "IDquantee"], "nombre": ["Nuclere", " nomeber", "Nombber", "Nombrero", "nombber", "nugere", "nucleber", "nucleres", "nomerero", "numbred", "Nuclerero", "nomeber", " nombrero", "nugerero", "Nombres", " nomered", "nomeres", " nomere", "nugeber", "nombres", "nugered", " nomerero", " nombber", "numbres", "nomere", "Nombre", "Nucleber", "nomered", "nombred", "numbrero", " nombred", "nuclerero", "numbber", "numbre", "nombrero", "nuclere", "Nucleres"], "paterno": ["pterno", "patterno", "matterno", "paserno", "natern", "patersNo", "matterna", "patterNo", "natterno", "patersn", "pterna", "nattern", "paserNo", "natterna", "mattername", "patername", "patern", "pasern", "materna", "naterna", "patersno", "naterno", "patterna", "patersna", "pattername", "natterNo", "paterNo", "paterna", "paserna", "ptername", "naterNo", "pattern", "ptern", "matername", "mattern", "matern", "patersname"], "materno": ["matterno", "morterno", "MATERno", "mortern", "maternot", "natern", "MaterNo", "matersn", "natternot", "maserno", "natterno", "mATERna", "mATERno", "matersnot", "nattern", "maserna", "mATERn", "morternot", "MATERna", "naternot", "morterNo", "matternot", "masern", "mATERNo", "matersNo", "matersna", "matersno", "materna", "materNo", "naterno", "MATERNo", "natterNo", "Matern", "Materna", "matterNo", "maserNo", "naterNo", "MATERn", "Materno", "mattern", "matern"], "ocupacion": ["OCuppaci", "ocupsatio", "ocupaton", "ocuppacion", "oculpaton", "ocovacion", "ocovaci", "OCupaton", "ocuppaton", "acupacion", "OCupaci", "acuppruction", "ocopacia", "ocupruction", "ocupsacion", "OCuppatio", "ocovruction", "acupruction", "ocupatio", "OCuppaton", "ocopaci", "oculpaci", "ocupacia", "ocuppruction", "acupacia", "OCupacion", "ocuppaci", "ocopruction", "ocovacia", "oculpatio", "acuppacion", "acupaci", "ocuppacia", "ocopacion", "ocupaci", "acuppacia", "OCuppacion", "ocupsaton", "ocupsaci", "acuppaci", "OCupatio", "oculpacion", "ocuppatio"], "rfc": ["sriff", "srpc", "rbf", "srfc", "Rfc", "rspc", "Rpc", "rrfc", "rrpc", "srfe", " rbf", "riff", "Rf", "rrf", "rsfe", " rfe", "rrbf", " rf", " riff", "rsfc", " rpc", "rfe", "Rbf", "rsiff", "rf", "rpc"], "stm": ["Stm", "STm", "stf", "ctf", "ntm", "stmt", "ntbm", "ctmt", "crbm", " stbm", "STmt", "Stf", "ctm", "ntM", "crM", "StM", "crm", " stdm", "ntdm", "stM", "stbm", "crdm", "STM", "STf", "stdm", "Stmt", "ctM", " stM"], "update": ["replace", "save", "include", "component", "UPDATE", "unit", "write", "module", "apply", "build", "complete", "lock", "equal", "event", "updated", "enable", "it", "draw", "result", "check", "set", "valid", "run", "remove", "error", "accept", "fill", "out", "end", "create", "add", "Update", "edit", "send", "id", "change", "load", "initial", "other", "continue", "up", "diff", "ite", "json", "response", "current", "ify", "author", "where", "use", "open", "database"]}}
{"id1": "6625074", "id2": "414258", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"SHA1": ["SHA384", "HA256", "sha1", "sha256", " SHA384", "SHAOne", "HA384", "HA1", "SHA256", " SHA256", "shaOne", "sha384", "HAOne", " SHAOne"], "text": ["font", "txt", "message", "image", " Text", "plain", "struct", "letter", "data", "in", "output", "input", "str", "editor", "hex", "translation", "password", "template", "bytes", "test", "out", "code", "class", "source", "config", "TEXT", "object", "token", "string", "obj", "name", "pattern", "context", "path", "transfer", "word", "content", "value", "format", "buffer", "ext", "contract", "Text"], "sha1hash": ["sha6hash", "sha6Hash", "sha2hex", "SHA1hash", "sha1log", "SHA2Hash", "sha_hex", "SHA1cap", "sha81cap", "sha1hex", "sha6log", "SHA2hash", "sha_Hash", "shaOnetext", "sha1Hash", "SHA2log", "shaOnepassword", "sha2hash", "ha1hash", "sha2Hash", "shaOneHash", "sha81hash", "sha256password", "sha2sum", "ha2Hash", "sha1sum", "sha2cap", "SHA1Hash", "SHA2cap", "SHA1password", "sha2log", "shaOnehash", "ha2hex", "sha1text", "sha_sum", "SHA1text", "sha1password", "sha81log", "SHA1log", "sha_hash", "ha1Hash", "ha1hex", "sha256text", "ha2hash", "sha256hash", "ha2sum", "sha1cap", "ha1sum", "sha256Hash", "sha81Hash", "sha6cap"], "md": ["m", "rm", "hd", " MD", "nd", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "f", "rpm", "hash", "editor", "mc", "mag", "d", "vd", "od", "ms", "meta", "hm", "wd", "mb", "amd", "nm", "dm", "bd", "pkg", "metadata", "pd", "MD", "ad", "de", "mac", "mm", "ma", "gb", "sm", "ld", "pm", "cf", "cd", "mt", "df"]}}
{"id1": "3514286", "id2": "2936678", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getHashedPassword": ["getHhedHash", "getMampedHash", "getHashingPass", "getMashedpassword", "getHampedPassword", "getHashingPassword", "getMampedpassword", "getHhedPassword", "getMashedPass", "getHhedPass", "getHampedHash", "getMashedPassword", "getHashedHash", "getHashingpassword", "getHampedPass", "getHashingHash", "getHashedPass", "getHampedpassword", "getHashedpassword", "getMashedHash", "getMampedPass", "getHhedpassword", "getMampedPassword"], "password": ["crypt", "prefix", "text", "p", "padding", "attribute", "auth", "message", " passwords", "data", "username", "sword", "phrase", "hash", "input", "encrypted", "wd", "out", "wallet", "pass", "code", "seed", "number", "user", "address", "token", "string", "account", "email", "cache", "name", "confirmed", "pattern", "words", "word", "content", "buffer", "Password", "secret", " Password", "PASS"], "digest": ["Diger", "dEST", "mdester", "Digoder", " digher", " digEST", "DigEST", "hashester", " diggest", "Diggest", "dest", "Digester", "mdEST", "dests", "digEST", "Digest", " digested", "mdested", "digher", " digoder", "digoder", "mder", " diger", "hashher", " digests", "hashoder", " digester", "digend", "Digested", " digend", "digester", "Digher", "Digests", "digests", "diger", "dgest", "digested", "mdest", "mdend", "hashest", "diggest", "Digend"], "hashedInt": ["HhedLong", "HashedInt", "hashInteger", "rhashedObj", "Hhedint", "rhashedInteger", "HashedINT", "hhedLong", "hashedObj", "rhashInteger", "haledLong", "hhedINT", "hashedINT", "hashInt", "hryptedObj", "hhedObj", "hryptedInt", "rhashedint", "rhashint", "HashedLong", "hashedLong", "Hashedint", "hashint", "hashedInteger", "hryptedint", "hhedint", "hryptedInteger", "HhedInt", "haledINT", "haledint", "hachedint", "HhedINT", "rhashObj", "hashedint", "hhedInteger", "hashObj", "hhedInt", "hachedInt", "haledInt", "rhashInt", "rhashedInt", "hachedINT", "hachedLong"]}}
{"id1": "8468859", "id2": "6908537", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["bind", "log", "establish", "write", "Connect", "build", "connection", "en", "init", "socket", "port", "stat", "read", "run", "conn", "connected", "download", "stop", "add", "create", "config", "boot", "client", " connection", "login", "sign", "exec", "con", "patch", "start", " disconnect", " reconnect", "select", "find", "nect", "host", "close", "on", "construct", "open"], "status": ["log", "unit", "standard", "server", "parent", "count", "style", "speed", "complete", "summary", "Status", "version", "si", "step", "sync", "session", "output", "result", "site", "str", "fail", "index", "stat", "type", "code", "temp", "progress", "source", "use", "edit", "login", "user", "min", "id", "skip", "success", "continue", "wait", "full", "response", "ui", "current", "content", "state", "update", "active", "stage"], "reply": ["resp", "prefix", "respond", "message", "server", "call", "count", "connection", "reason", "info", "data", "link", "sync", "random", "py", "result", "answer", "second", "error", "vote", "code", "comment", "action", "base", "send", "address", "fee", "dy", "ping", "repl", "next", "bot", "ret", "response", " response", "query", "state", "update", "Reply", "request", "post"], "isConnected": ["isConnectalled", "IsConnectioned", "IsConnects", "isFined", "isConnectioning", "isAdapteded", "isAcceptable", " isAcceptaged", "isconnecteding", "isConnectionp", "isNECTished", "isConnectted", "isConnecting", "isFinted", "isConnectified", " isConnectionalled", "isConnectaged", "IsConnected", "isConnectp", "isConnectionished", "isAdaptified", "isaAdaptified", "IsConnectioning", "isConnectable", "isNECTalled", " isConnectished", " isConnecting", "isNECTed", "isFinable", "isconnectedp", "isAdapted", " isConnectable", " isAcceptable", "isaConnected", " isConnectioning", "IsConnections", "isNECTing", "isConnectished", "IsConnectp", " isConnectalled", "isaAdapting", "isAcceptaged", " isConnectioned", "isaConnecting", "isaConnectified", " isAcceptted", " isConnectionished", "isconnecteds", " isConnectted", "isConnectionalled", "IsConnecting", "IsConnectionp", "isConnectioned", "isConnecteded", "isFinished", "isaConnecteded", "isAcceptted", " isConnectaged", "isConnects", "isaAdapted", "isFinaged", "isFinalled", "isFining", "isConnectioneded", "isaAdapteded", "isConnections", " isAccepted", "isconnecteded", "isAdapting", "isAccepted", "isConnectionified"]}}
{"id1": "14773782", "id2": "20091126", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPPGrasters", " testJPPGRatter", " testJPEGRast", " testJPEGRasters", " testJPEGRotaster", " testJPEGWatter", " testJPEGrast", " testJPPGRasters", " testJPEGRotatter", " testJPPGrast", " testJPEGWast", " testJPEGraster", " testJPEGratter", " testJPPGRast", " testJPEGRotasters", " testJPEGrasters", " testJPPGratter", " testJPEGRatter", " testJPEGWasters", " testJPPGRaster", " testJPEGWaster", " testJPEGRotast", " testJPPGraster"], "IOException": ["IOError", " IOError", "OSception", "IPException", "IPception", "OSError", "IOception", "OSException", " IOception", "IPError"], "start": ["art", "delay", "Start", "length", "style", "offset", "speed", "init", "started", "info", "data", "scale", "step", "pos", "in", "f", "set", "sum", "end", "date", "time", "source", "starting", "size", "base", "ish", "min", "id", "load", "stage", "left", "order", "pre", "diff", "get", "first", "shift", "use", "from"], "i": ["m", "p", "u", "e", "image", "j", "b", "fi", "io", "info", "si", "ie", "f", "ni", "index", "ci", "iu", "key", "oi", "uni", "abi", "multi", "li", "di", "l", "mi", "ip", "pi", "xi", "hi", "inner", "slice", "eni", "yi", "id", "ti", "v", "gi", "c", "ix", "I", "zi", "ai", "phi", "ini", "ii", "ui", "qi", "bi", "x", "ri"], "url": ["ur", "ls", "page", "uri", "resource", "image", "connection", "org", "data", "fb", "channel", "in", "f", "route", "www", "URL", "ref", "href", "download", "source", "src", "config", "filename", "l", "album", "web", "base", "id", "address", "string", "file", "name", "sl", "path", "Url", "location", "hub", "http", "feed", "img"], "istream": ["istsound", "instagram", "ishound", "isterib", "irstREAM", "ishREAM", "stead", "istsstream", "istestream", "ISTream", "istsream", "isep", "irstound", "istREAM", "step", "ISTstream", "instream", "isteream", "istore", "ISTrib", "istsREAM", "istep", "instead", "irstream", "ishream", "istsep", "irstore", "istsrib", "iststream", "stream", "istsore", "ISTep", "isagram", "istrib", "instep", "ishore", "isteep", "istagram", "isream", "stagram", "istead", "istound", "isead"], "dec": [" DEC", "rec", "des", "der", "fr", "cam", "data", "rev", "inc", "dig", "func", "ec", " Dec", "draw", "ode", "DEC", "exp", "valid", "sec", "out", "s", "decl", "code", "dir", "deg", "de", "da", "r", "div", "neg", "desc", "Dec", "c", "dc", "next", "vec", "ra", "oder", "enc", "director", "doc", " decode", "img"], "raster": [" rasters", "arasters", "araster", "hap", "Rap", "rasters", "aroder", "Ratter", "hatter", "Raster", "Roder", "haster", " ratter", "eraster", "rap", "erasters", "rascal", "arascal", " rascal", "ratter", "eratter", "Rascal", " roder", "hasters", " rap", "Rasters", "roder", "eroder"], "width": ["ize", "lon", "page", "widget", "z", "flow", "frame", "image", "write", "length", "west", "gender", "style", "n", "wn", "en", "weight", "scale", "wm", "duration", "shape", "f", "area", "d", "density", "h", "wd", "Width", "size", "work", "fw", "min", "layout", "wa", "window", "dim", "age", "w", "left", "full", "wb", "x", "value", "p", "img"], "height": ["k", "padding", "pad", "hd", "rows", "ady", "length", "build", "volume", "thin", "Height", "rh", "depth", "inches", "shape", "han", "d", "density", "h", "th", "y", "size", "max", "work", "stroke", "v", "window", "dy", "dim", "deep", "w", "angle", "crop", "x", "head", "img", "right"], "stop": ["save", "page", "exit", "delay", "b", "speed", "summary", "hide", "step", "cut", "output", "shape", "Stop", "drop", "limit", "check", "set", "sort", "remove", "end", "clip", "fill", "spot", "rest", "comment", "hop", "roll", "keep", "number", "sign", "change", "skip", "address", "snap", "wait", "ops", "pop", "pause", "trip", "zero", "sleep", "block"]}}
{"id1": "1421557", "id2": "11962480", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "23215235", "id2": "8921716", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"readFile": ["readFiles", "readContent", " readContent", " readFiles", "loadContent", "importZip", "loadZip", "importFiles", "importContent", "importFile", "readZip", "loadFile", " readZip", "loadFiles"], "url": ["page", "uri", "ssl", "resource", "image", "server", "connection", "io", "data", "link", "f", "zip", "input", "str", "URL", "job", "download", "xml", "source", "class", "reader", "config", "client", "filename", "l", "stream", "base", "user", "object", "address", "file", "name", "loader", "service", "sl", "host", "bug", "path", "Url", "location", " URL", "buffer", "http", "feed", "browser"], "IOException": ["IPException", "IOInterface", "TimeoutException", "IPInterface", " IOInterface", "TimeoutInterface"], "ParserConfigurationException": ["InvalidConfigAPE", "ParserDefinitionException", "ParserDefinitionAPE", "ParserConstructionEX", "ParserConstructionException", "ParserConfigEX", "ParserConfigAPE", "InvalidConfigurationEX", "InvalidConfigurationAPE", "ParserConfigurationEX", "ParserConstructionAPE", "ParserConfigException", "InvalidConfigEX", "ParserConfigurationAPE", "InvalidConfigException", "InvalidConfigurationException", "ParserDefinitionEX"], "SAXException": [" SAXception", "SAFEException", "SAXception", " SAXPception", "SAXPception", "SAFEception", "SAXPException", "SAXMception", "SAXMException", " SAXPException"], "zipFileName": ["zipFileDirectory", "zipFolderPath", "zipFolderType", "zipFolderName", "archiveFileDirectory", "zipDirDirectory", "zipFileType", "archiveFileName", "archiveFilePath", "archiveFileType", "archiveFilesType", "zipFilesDirectory", "archiveFilesDirectory", "zipFilesType", "zipFolderDirectory", "zipFilesName", "zipDirName", "zipDirPath", "zipFilePath", "zipFilesPath", "archiveFilesPath", "zipDirType", "archiveFilesName"], "urlConnection": ["URLChannel", "URLconnection", "webChannel", "fileManager", "inputConn", "webconnection", "urlResponse", "inputPool", "urlManager", "httpPool", "webConnection", "URLConnection", "inputConnection", "fileConn", "webResponse", "urlConn", "urlChannel", "urlPool", "URLResponse", "urlconnection", "httpManager", " urlChannel", "filePool", "httpConnection", "inputManager", "fileConnection", " urlconnection", " urlResponse", "httpConn"], "inputStream": ["InputSession", "outputStream", "inputChannel", "urlFeed", "outputContext", "InputFile", "InputChannel", "urlFile", "outputstream", "inputFile", " inputContext", "inputFeed", "urlSession", "InputContext", "inputContext", "Inputstream", " inputFeed", "inputSession", " inputSession", " inputFile", "InputFeed", "urlStream", "inputstream", "outputChannel", " inputstream", "InputStream", " inputChannel"]}}
{"id1": "11484416", "id2": "23677147", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"moveFile": [" moveFiles", "moveDirectory", "MoveDirectory", "MoveFiles", " movedFiles", "MovePath", " movedFile", "moveFiles", " movePath", " moveDirectory", "MoveFile", " movedPath", "movePath", " movedDirectory"], "orig": ["buf", "proxy", "original", "array", "raid", "frame", "image", "copy", "dest", "build", "prev", "loc", "init", "remote", "ori", "info", "org", "old", "folder", "f", "impl", "archive", "coll", "rb", "comb", "home", "temp", "source", "iter", "src", "tmp", "raf", "base", "coord", "ctr", "internal", "transform", "id", "bin", "file", "obj", "bas", "origin", "exe", "Orig", "ext", "real", "imag", "img"], "target": ["replace", "prot", "to", "original", "resource", "copy", "dest", "build", "master", "parent", "remote", "manager", "project", "this", "external", "f", "it", "result", "archive", "nt", "template", "eth", "temp", "source", "tmp", "Target", "base", "object", "match", "arget", "platform", "origin", "t", "reference", " Target", "next", "ret", "path", "auto", "current", "format", "force", "compatible", "join"], "buffer": ["wave", "buf", "bb", "request", "padding", "url", "frame", "message", "resource", "write", "length", "copy", "b", "null", "data", "Buffer", "raw", "sequence", "result", "input", "stack", "batch", "read", "bytes", "code", "source", "iter", "header", "buff", "base", "queue", "position", "slice", "cache", "address", "bin", "file", "repeat", "reference", "binary", "layer", "transfer", "uffer", "content", "feed", "block"], "bread": ["circ", "rows", "bat", "meal", "good", "length", "wake", "ffe", "raft", "num", "fall", "fed", "die", "piece", "rub", "cake", "hello", "bc", "food", "loop", "zip", "robe", "str", "inn", "batch", "key", "broken", "fe", "abi", "width", "rib", "web", "beat", "design", "fred", "bn", "brew", "div", "fee", "cook", "fif", "knife", "buck", "fle", "fine", "fen", "wen", "ble", "zero", "sleep", "eb", "grain", "feed", "bb", "bare", "four", "choice", "bee"], "fis": [" fils", "ufils", "lfis", "ufis", "ufiss", " fiss", "lfIs", "hos", "fisa", "qiss", "fxos", "fxisa", "qis", "ufos", " fisa", "fxIs", "fils", "fxis", "his", "qils", "fIs", "fiss", "lfiss", "qos", "afiss", "afIs", "hIs", "afis", "lfos", "afos", " fIs", "hisa"], "fos": ["fois", "Fors", "infors", "infois", " fros", "fose", "fens", " fens", "gros", "flos", "Fos", "flois", "fors", "foses", "faos", "infos", "infaos", "Foss", "gis", "flaos", "Fois", " foses", " fose", "Fens", "flose", "flens", " foss", "Faos", "Foses", "floses", "Fros", "gos", "Fose", "foss", "goss", "flors", "fros", "Fis"]}}
{"id1": "18433984", "id2": "16142024", "code1": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"doUpload": ["runupload", "runSave", " doSave", "DoUpload", " doDownload", "doDownload", "Doupload", "doSave", "doupload", "runUpload", "DoSave", "runDownload", "DoDownload", " doupload"], "request": ["art", "report", "image", "parent", "view", "requ", "data", "temp", "QUEST", "queue", "r", "string", "file", "context", "query", "condition", "page", "resource", "message", "server", "connection", "event", "info", "version", "hello", "model", "result", "input", "accept", "type", "xml", "config", "er", "worker", "command", "object", "match", "upload", "initial", "path", "json", "operation", "content", "q", "url", "frame", "complete", " Request", "application", "instance", "create", "stream", "user", "submit", "re", "ware", "transfer", "buffer", "http", "use", "param", "req", "subject", "method", "child", "session", "raw", "document", "Request", "require", "client", "header", "get", "current", "state", "head", "quest", "join"], "response": ["resp", " Response", "page", "report", "message", "resource", "server", "image", "view", "Response", "connection", "output", "application", "status", "model", "result", "document", "reply", "xml", "Resp", "client", "stream", "re", "json", "content", "onse"], "reqSession": ["reqCh", "tempSocket", "requClient", "refSecret", "reqSocket", " reqSocket", " reqession", "rbession", "requSession", " reqCh", "rbLog", "reqsession", "rbClient", " reqLog", "reqClient", "reqession", "reqConn", "refession", "refLog", "rbsession", "rbSession", "clientSession", "qsession", "qClient", "tempsession", "tempCh", "qSession", " reqsession", "requsession", "reqSecret", "rbConn", "clientSocket", "qConn", "requConn", "rbSecret", "reqLog", "clientCh", " reqSecret", "clientsession", "refSession", "tempSession"], "uploadFiles": [" uploadfiles", "transferfiles", " uploadFile", "Uploadfiles", "UploadResources", "uploadfiles", "UploadFile", "transferResources", "uploadFile", "uploadResources", " uploadResources", "UploadFiles", "transferFiles", "transferFile"], "tempDirName": ["cacheDirHome", " tempDirInfo", " tempFolderName", "cacheDirName", "tempFolderCode", "tempDIRPart", "tempDirectoryPath", "tempFolderHome", " tempFolderDesc", "tempVername", "tempDirectoryInfo", " tempFilename", "tempDirectoryname", "tempDirectoryKey", "tempFileInfo", "tempDIRname", "tempDirDesc", "tempDirPath", " tempFileSize", "tempAreaSize", "tempDirKey", "tempFolderDesc", "tempDirname", "tempDirectoryHome", "tempVerName", "tempDirectoryName", "tempFoldername", "tempDirInfo", " tempDirCode", "TempDirectoryCode", "tempFileName", "tempFileSize", "TempDirPath", "cacheDIRPart", "tempDirectoryDesc", "tempFilename", " tempFoldername", "tempAreaname", "cacheDIRname", "tempDirectoryPart", "TempDirectoryPath", "TempDirKey", "TempDirName", "tempFolderPath", "tempDirHome", "TempDirectoryKey", "tempFileKey", "tempDirectorySize", "tempFilePath", "tempDirSize", "tempAreaName", "tempFolderKey", "tempDirectoryCode", "cacheDIRName", "tempDIRHome", "tempFileCode", "tempDIRName", "TempDirectoryName", "tempAreaInfo", " tempFileName", "TempDirCode", "tempVerDesc", " tempFolderCode", "tempVerCode", " tempDirDesc", "tempDirCode", "cacheDirPart", "cacheDirname", "cacheDIRHome", "tempFolderPart", " tempDirSize", "tempFolderName", " tempDirname", " tempFileInfo", "tempDirPart"], "tempUploadDir": ["tempDownloadPath", " tempUploadJar", "tempInputInfo", " tempDownloadFile", "tempAttachDir", "tempUploadD", "testUploadDir", "testBuildD", "TempDownloadFolder", " tempUploadFile", "temuploadPath", "tempRootDb", "tempDownloadDir", "tempDownloadFolder", "tempInputPath", " tempUploaddir", "testUploaddir", " tempUploadArea", "tempBuilddir", "tempDownloadD", "tempUploadArea", "tempImageDirectory", "tempStreamFolder", "temuploadFolder", "TempDownloadDirectory", " tempUploadFolder", "tempDownloadDb", "tempStreamArea", " tempDownloaddir", "tempDownDir", "tempInputFolder", "tempImageArea", "tempTempFolder", " tempStreamFolder", "temuploadDir", "tempBuildD", "tempCaptureDir", "testAttachFolder", " tempUploadDirectory", "testBuildDir", "tempUploadFolder", "tempDownJar", "tempUploadPath", "testUploadFolder", "tempRootFolder", "tempUploadFile", "tempTempDirectory", "tempCaptureJar", "temuploadInfo", "tempWorkDirectory", "tempuploadDir", "tempBuildJar", "tempUploadDb", "tempStreamJar", "tempImageManager", " tempDownloadDirectory", "tempAttachUrl", "tempStreamDir", " tempUploadManager", "tempAttachdir", "temUploadFolder", "testUploadJar", "tempuploadInfo", "tempFileFolder", "tempUploadUrl", "tempFileDir", "tempuploadFolder", "temUploadInfo", "tempAttachFolder", " tempStreamDir", "TempDownloadDir", "tempTempDb", "tempInputDir", "temUploadPath", "tempTempdir", " tempDownloadManager", "tempFileFile", "tempImageDir", "tempStreamDb", "testUploadD", "tempUploaddir", "tempFileDirectory", "tempDownloadUrl", "tempUploadDirectory", "tempDownloadInfo", "tempDownloadArea", "testAttachUrl", "tempImagedir", " tempDownloadFolder", "TempUploadDir", "tempCaptureD", "tempDownloadManager", " tempDownloadDb", " tempStreamDirectory", "testBuilddir", "tempWorkFile", "tempBuildDir", " tempDownloadDir", " tempStreamJar", "tempDownFolder", "tempWorkDir", "testUploadUrl", "tempUploadManager", "tempStreamDirectory", "tempUploadJar", "testAttachdir", " tempUploadDb", "tempDownloadFile", "temUploadDir", "tempImageFolder", "tempDownloadJar", "TempUploadFolder", " tempDownloadArea", "testBuildJar", "tempCapturedir", "TempUploadDirectory", "tempuploadPath", "testAttachDir", "TempUploadDb", "tempDownloaddir", "tempUploadInfo", "tempWorkFolder", "tempDownDirectory", "tempTempDir", "TempDownloadDb", "tempDownloadDirectory", "tempRootDirectory", "tempRootDir", "tempTempManager"], "attachmentDir": ["attachmentMin", "AttmentFolder", "AttmentDirectory", "attachmentObj", "AttachedDir", "attachFile", "attachDb", "assachedDirectory", "assachedDb", "AttachmentDirectory", "attachmentFile", "attachedObj", "assachmentDb", "attachedFile", "attributionDet", "attachedDb", "attachmentDb", "attporaryFile", "attributionDir", "attentionDirectory", "attmentDirectory", "attachDirectory", "attmentMin", "attporaryDet", "attentionMin", "attporaryDb", "assachedDet", "attentionFolder", "AttmentMin", "attachmentDirectory", "attachmentDet", "AttachmentObj", "AttmentDir", "attachDir", "attributionFile", "attmentObj", "AttachmentDir", "assachmentDir", "attributionDb", "AttachedDirectory", "assachedFile", "AttachmentFile", "AttachmentMin", "attmentFolder", "attachmentFolder", "AttachedObj", "attmentFile", "attentionFile", "attmentDir", "assachmentDet", "assachedDir", "attentionObj", "assachmentDirectory", "attentionDir", "attporaryDir", "AttachedFile", "AttachmentFolder", "attentionDb", "attachedDir", "attachedDirectory", "assachmentFile", "attachedDet"], "paramMap": ["ParameterList", "ParameterCache", "paramArray", "parammap", "argList", "paramBlock", "paramClear", "Parammap", "argClear", "paramZone", "ParamMap", "argArray", "ParameterMap", " parameterMap", " parameterCache", "ParamArray", " paramBlock", "ParamList", " paramCache", "paramCache", "argMap", "mediaMap", " paramClear", " paramZone", " parameterZone", "mediamap", "paramList", " parammap", " paramList", "mediaArray", "ParameterZone", "argBlock", "mediaList", "ParamClear", "ParamBlock", " parameterList", " paramArray"]}}
{"id1": "2022160", "id2": "4593012", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"write": ["writer", "play", "flow", "cycle", "append", "call", "copy", "wrote", "lex", "data", "store", "writing", "sync", "written", "writ", "output", "connect", "set", "run", "read", "end", "Write", "out", "code", "process", "flush", "create", "add", "size", "dump", "send", "pipe", "exec", "kill", "service", "w", "next", "put", "update", "close", "feed", "export", "open"], "byteBuffers": ["byteChers", "bytesAkers", " byteOrdeners", "byteAkors", "ByteBufflers", "bytesDefatters", "byteChered", " byteBuffinals", "bytesAkelines", "bytesPackERS", " byteBuffiners", "byteOrdeners", "bytebuffings", "byteIntegeners", "byteDefatters", " byteOrdinals", "byteBuilderers", "doubleHeadings", "byteBuffatters", " byteBufferers", "byteBuffinals", "byteInteginals", "byteCornlers", "connectionBuffers", "byteChERS", "doubleBuffered", "bytebuffeners", "connectionBuffERS", "bytebuffered", "byteOffers", "byteHeadERS", "doubleHeadered", "ByteBufferers", "byteBuffERS", "byteAkers", "bytesCornered", "byteIntegERS", "byteWriters", " byteOrderers", " byteOrdlers", "doubleBuffERS", "bytebuffinals", "byteOffors", "wordBuffatters", "bytesDefelines", "wordBuffers", "bytesCornests", "byteCornares", "byteIntegers", "byteDefers", "byteWriterers", "doubleHeaders", "bytebuffelines", "byteBufferatters", "byteWritelines", "byteIntegatters", "bytebufferers", "bytebuffers", "byteWritiners", "doubleBuffings", "byteBuffters", "byteHeadered", "byteBuffererers", "bytesDefers", "connectionbuffERS", "bytesBufferers", " byteOffters", "bytesCornatters", "bytePackapers", "ByteOrderers", " byteBuffors", "byteHeaders", "byteBufferERS", " byteOffors", "bytesBuffizers", "byteWritizers", "byteBuffors", "ByteBuffresses", "ByteOrdERS", "byteBuffresses", " byteBufflers", "byteChings", "byteBuffeners", "bytebuffERS", "connectionbuffers", "wordBuffERS", " byteCompERS", "bytePackerers", " byteBuffares", "byteOrdapers", "byteCompares", "bytesBuffatters", "bytesBuffests", "byteOrders", "ByteOrders", " byteCompers", " byteOrdERS", "byteComplers", "bytesBuffERS", "byteBufferers", "doubleHeadERS", "bytesAkizers", "byteOffters", "byteInfers", "byteCornatters", "bytebuffatters", "byteOrderers", "byteDefelines", "byteCompers", "wordBufferers", "byteBuffings", "bytePackERS", "byteCornERS", "byteBuffapers", "byteCornests", "byteDefERS", "byteInferers", "bytesBuffapers", "byteOrdERS", " byteBuffERS", "bytebufflers", "byteBufferapers", "bytebuffors", " byteBuffters", "byteAkizers", "bytesCorners", "byteBuildERS", "byteHeadings", "bytesPackapers", "ByteBuffERS", "byteBuffered", "byteCorners", "doubleBuffers", " byteCompares", "bytesBuffors", "byteBufflers", "bytebuffizers", " byteComplers", "byteBufferelines", "byteBuffares", "byteBuffiners", " byteOffERS", "bytebuffests", "byteOffERS", "byteOrdlers", "byteCompERS", "byteWritors", "bytesDefERS", "byteAkelines", "byteCornered", "ByteOrdresses", "bytesBuffered", "byteWritlers", " byteOrders", " byteOrdiners", "byteOrdiners", "byteInfatters", " byteOffers", "byteBuffizers", "byteBuildatters", "connectionbufferers", "connectionBufferers", "byteBuffests", " byteBuffeners", "ByteBuffers", "bytebuffters", "bytebuffresses", "byteBuilders", "bytesPackerers", "byteOrdresses", "byteOrdinals", "bytePackers", "byteInfERS", "byteBuffereners", "bytesBuffers", "connectionBuffeners", "bytesAkors", "bytesBuffelines", "byteBuffelines", "byteBufferlers", "bytebuffiners", "byteIntegelines", "connectionbuffeners", "bytesPackers"], "m_initialOutBuffer": ["m_initialInFile", "m_initialInLine", "m_finalOutLine", "m_initialAuthBuffer", "m_InitialOutFile", "m_initialoutCache", "m_initialoutChannel", "m_initialOutChannel", "m_initialClientBuffer", "m_finalOutMessage", "m_initialOutputHeader", "m_initialInBuffer", "m_finalOutCache", "m_InitialOutputBuffer", "m_finalOutFile", "m_initialoutAddress", "m_initialShortFile", "m_originaloutBuffer", "m_initialOutHeader", "m_initialoutBuff", "m_initialOutputLayer", "m_initialOutBuff", "m_initialNewFile", "m_InitialOutLayer", "m_finaloutBuffer", "m_finalOutBuff", "m_initialSocketLayer", "m_initialOutputFile", "m_finalInLine", "m_initialNewMessage", "m_finaloutFile", "m_initialOutMessage", "m_initialOutputBuffer", "m_originalOutBuffer", "m_finalOutBuffer", "m_initialOutLayer", "m_initialoutFile", "m_initialAuthFile", "m_initialShortCache", "m_initialInLayer", "m_initialSocketFile", "m_finaloutBuff", "m_initialNewBuffer", "m_originaloutLine", "m_initialSocketBuffer", "m_originaloutFile", "m_originalOutAddress", "m_InitialOutputFile", "m_initialInCache", "m_finalInFile", "m_originaloutAddress", "m_finalOutChannel", "m_initialClientBuff", "m_initialInChannel", "m_initialOutCache", "m_initialOutLine", "m_initialAuthLine", "m_InitialOutputHeader", "m_initialOutAddress", "m_InitialOutHeader", "m_finalInMessage", "m_initialOutputBuff", "m_initialoutBuffer", "m_initialInMessage", "m_initialNewBuff", "m_originalOutLine", "m_finalInChannel", "m_initialClientFile", "m_initialClientLine", "m_initialOutFile", "m_finalInBuff", "m_initialShortChannel", "m_initialOutputChannel", "m_initialoutLine", "m_initialInAddress", "m_InitialOutBuffer", "m_initialAuthAddress", "m_finalInBuffer", "m_initialOutputMessage", "m_initialInBuff", "m_InitialOutputLayer", "m_initialSocketHeader", "m_initialShortBuffer", "m_originalOutFile", "m_initialInHeader", "m_finalInCache", "m_finaloutChannel"], "buffer": ["console", "writer", "null", "view", "data", "bc", "phrase", "row", "temp", "queue", "cache", "string", "file", "uffer", "wave", "page", "resource", "message", "server", "event", "cell", "back", "shell", "port", "limit", "input", "template", "read", "timeout", "builder", "iter", "config", "er", "worker", "object", "loader", "layer", "feed", "url", "fb", "channel", "batch", "cur", "flush", "comment", "holder", "re", "binary", "transfer", "FFER", "block", "buf", "array", "copy", "engine", "Buffer", "ker", "output", "document", "f", "stack", "source", "reader", "header", "client", "buff", "base", "table", "slice", "address", "window", "pool", "response", "bridge", "callback"], "buffers": ["bufered", "buffERS", "ufors", "affaches", "buffered", "bufering", "buffler", "transformers", "bufresses", " buffators", "phages", "Bufferers", "buferers", "transformERS", "buffators", "Buffars", "transformler", "bufler", "buffages", " buffler", "buffaches", "affering", "phators", " buffering", "buffering", "Buffers", " buffERS", "phers", "Buffered", "bufages", " buffered", "phresses", "transformering", "affers", " buffresses", "ufering", "ufaches", "bufERS", "buffresses", " buffages", "ufers", "bufaches", " bufferers", " buffars", "bufers", "bufars", "bufors", "bufators", "bufferers", "buffars", "buffors", "affors"], "result": ["res", "url", "default", "resource", "report", "message", "complete", "view", "rc", "rate", "event", "info", "data", "successful", "session", "winner", "search", "output", "status", "f", "acc", "valid", "error", "date", "val", "out", "test", "row", "ver", "results", "comment", "future", "driver", "consumer", "true", "flash", "er", "Result", "inner", "user", "r", "cache", "match", "err", "card", "success", "re", "sr", "up", "grade", "diff", "ret", "json", "response", "runner", "function", "or", "cup", "manager", "use", "request"], "encrypted": ["available", "text", "pad", "padding", "image", "body", "channel", "selected", "entry", " data", "temp", "flush", "source", "config", "reader", "flash", "stream", "inner", "internal", "packed", "cache", "loader", "extra", "interrupted", "binary", "layer", "transfer", "secret"]}}
{"id1": "14303294", "id2": "15645004", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"getServerHash": [" getServerSalt", "getServerAddress", "getServerSHA", "getSecureSHA", "getSecureAddress", " getSecureHash", " getServerSHA", "getserverAddress", " getServerAddress", " getSecureSHA", " getSecureAddress", "getserverSHA", "getSessionHash", "getServerSalt", "getSessionSHA", "getSessionSalt", "getSessionAddress", " getSecureSalt", "getserverSalt", "getSecureHash", "getserverHash", "getSecureSalt"], "passwordHash": ["privatePassword", "PasswordHash", " passwordCode", " PasswordCode", "passwordPassword", " PasswordHash", "passwordPass", "Passwordhash", " passwordPass", "privateHash", "passwordCode", "passwordhash", " passwordhash", "privatehash", "passwordSalt", "PasswordPass", " passwordSalt", "privateSalt", " PasswordPass", "PasswordPassword", " passwordPassword", "PasswordCode"], "PasswordSalt": ["PasswordHash", "PasswordSecret", "password256", "PASSSalt", "passwordPassword", " PasswordHash", "PASS256", "passwordSecret", " passwordSecret", "passwordSalt", " PasswordSecret", " PasswordPassword", "PASSPassword", "Password256", " Password256", " passwordSalt", "PASSHash", "PasswordPassword", " passwordPassword"], "hash": ["crypt", "ash", "array", "log", "url", "auth", "message", "image", "copy", "html", "build", "sha", "data", "dig", "search", "her", "result", "check", "hex", "sum", "password", "error", "h", "key", "row", "code", "kh", "size", "work", "number", "base", "user", "mac", "change", "address", "string", "cache", "ha", "Hash", "sh", "response", "pool", "value", "buffer", "update", "content", "block"], "digest": ["Diger", "Digusher", "mdester", " digher", "integested", "Digger", "hashester", "integall", " digall", " digener", "signger", "Digester", "digall", "Digest", " digested", "mdested", "digener", "generall", "generester", "signest", "digger", "generest", "digher", " diger", "signer", "signher", " digusher", "generested", "mdusher", "integester", " digester", " digger", "Digested", "digester", "Digher", "integest", "signester", "hasher", "diger", "Digener", "digested", "mdest", "digusher", "hashest", "hashener"]}}
{"id1": "21642215", "id2": "9956095", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public void exportNotesToServer() {\n        boolean uploaded = true;\n        try {\n            File f = new File(UserSettings.getInstance().getNotesFile());\n            FileInputStream fis = new FileInputStream(f);\n            String urlString = protocol + \"://\" + UserSettings.getInstance().getServerAddress() + UserSettings.getInstance().getServerDir() + f.getName();\n            setDefaultAuthenticator();\n            URL url = new URL(urlString);\n            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n            urlc.setDoOutput(true);\n            urlc.setRequestMethod(\"PUT\");\n            OutputStream os = urlc.getOutputStream();\n            int nextByte = fis.read();\n            while (nextByte != -1) {\n                os.write(nextByte);\n                nextByte = fis.read();\n            }\n            fis.close();\n            os.close();\n            if (urlc.getResponseCode() != HttpURLConnection.HTTP_CREATED && urlc.getResponseCode() != HttpURLConnection.HTTP_NO_CONTENT) {\n                uploaded = false;\n            }\n        } catch (SSLHandshakeException e) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.sslcertificateerror\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n            uploaded = false;\n        } catch (Exception e) {\n            uploaded = false;\n        }\n        if (uploaded) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"info.notesfileuploaded\"), I18N.getInstance().getString(\"info.title\"), JOptionPane.INFORMATION_MESSAGE);\n        } else {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.notesfilenotuploaded\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["addLinks", " addIDS", "addIDS", "loadIDs", "loadLinks", " addLinks", "addID", "loadIDS", " addID", "findID", "findIDs", "findLinks", "findIDS", "loadID"], "row": ["array", "rows", "report", "col", "server", "ro", "copy", "view", "scan", "item", "cell", "info", "raw", "group", "entry", "result", "index", "ow", "batch", "job", "key", "tab", "column", "builder", "reader", "record", "table", "r", "tr", "user", "Row", "list", "up", "per", "bug", "query", "head", "feed", "post", "ry"], "name": ["NAME", "ame", "filter", "prefix", "description", "resource", "image", "n", "connection", "info", "username", "title", "search", "alias", "str", "named", "key", "type", "time", "source", "Name", "size", "filename", "number", "string", "file", "start", "path", "query", "word"], "in": ["at", "rec", "m", "ex", "gen", "ins", "ssl", "resource", "image", "In", "b", "n", "lock", "init", "session", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "inn", "container", "out", "s", "conn", "xml", "cin", "i", "source", "is", "win", "reader", "record", "with", "iter", "a", "stream", "l", "nin", "login", "inner", "min", "user", "r", "cache", "token", "string", "bin", "err", "c", "con", "file", "ic", "re", "diff", "pin", "ini", "query", "as", "path", "buffer", "again", "update", "http", "serv", "doc"], "urlName": ["urlStr", "urlname", " urlname", "filePath", " urlPath", "lPath", "toolPath", "lStr", "URLPath", "UrlType", "UrlStr", "lType", "URLname", "fileName", " urlType", "lName", "urlPart", "UrlPath", "filename", "urlPath", "URLName", "Urlname", "UrlName", "lname", "toolName", "toolname", "UrlPart", "filePart", " urlPart", " urlStr", "urlType"], "url": ["fl", "uri", "ssl", "resource", "image", "server", "b", "connection", "io", "org", "link", "socket", "channel", "f", "input", "URL", "bel", "out", "source", "reader", "client", "stream", "l", "web", "base", "user", "r", "gl", "file", "loader", "service", "sl", "path", "Url", " URL", "hub", "buffer", "http", "feed", "open"], "inputLine": ["searchFile", "baseLINE", "updateline", "responseLINE", "againLine", "rawL", "accessLINE", "output\n", "indexLine", "baseLine", "inputStream", " inputEntry", "InputRoute", " inputFile", "htmlString", "dataLine", "issueLine", "htmlLINE", "typeLine", "requestUrl", " inputEmail", " inputWrite", "Input\n", "rawFile", "inputString", "formline", "inputWrite", " input\n", " inputL", "dataWrite", "inputEmail", "typeline", "Inputline", "dataLink", " inputRoute", "InputFile", "againLINE", "formLINE", "InputBlock", "inputLin", "updateLine", "execUrl", "responseLink", "dataSync", "requestLINE", "indexEntry", "dataBlock", "baseline", "InputLo", "readLook", "updateLin", "readL", " inputLINE", "requestEmail", "uploadSel", "readSync", "dataLin", "searchL", "dataLINE", "inputline", "uploadline", "input\n", "readLin", "InputLINE", "dataFile", "updateLINE", " inputLo", "execEmail", "inputBlock", "dataRoute", " inputUrl", "requestString", "uploadLin", "inputL", "accessSync", " inputSource", "responseLine", "InputLine", "inputUrl", "formLine", "issueLin", "uploadLine", "execLine", "dataUrl", "searchLine", "issueline", "inputSync", "issueSel", " inputLook", "requestline", "accessEntry", " inputStream", "searchStream", "htmlline", "inputLook", "inputRoute", "inputSource", " inputBlock", "InputSync", "inputLo", "formLin", " inputSel", "requestLine", "inputLink", "InputStream", "dataline", " inputSync", "typeLink", "readLine", "againUrl", "execline", "inputEntry", "inputFile", " inputString", "readFile", "responseFile", "dataSource", "readline", "typeLINE", " inputLink", "inputSel", " inputline", "againWrite", "InputSource", "indexLINE", "InputLink", "indexSync", "dataLo", "htmlLine", "dataLook", "InputL", "rawline", "baseFile", "rawLine", " inputLin", "accessLine", "inputLINE"], "score": ["confidence", "message", "core", "length", "count", "speed", "gain", "ranking", "loss", " Score", "weight", "ner", "winner", "status", "result", "price", "index", "error", "key", "test", "live", "code", "player", "time", "size", "width", "seed", "feature", "sc", "match", "fee", "scoring", "cost", "grade", "rank", "Score", "value", "fit", "level", "game", "rice", "rate"], "metaboliteID": ["metaboliciteInfo", "metabolizeID", "metabolitationName", "metmbolitableIndex", "metovaliteId", "metaboliqueIDs", "metabololeID", "metabolitionIndex", "metabolizeInfo", "metovaliteAddress", "metaboliqueID", "metmboliqueIDs", "metaboliteIN", "metabolicizeInfo", "metabololeSize", "metaboliteSize", "metovalriteIN", "metabolverseIN", "metabolicizeScore", "metabolitableId", "metaboliqueType", "metabolicizeID", "metmbolitableSize", "metabolheticID", "metabolriteIDs", "metovalriteId", "metabolriteAddress", "metmboliteType", "metabolriteIN", "metaboliciteName", "metaboliciteScore", "metabolizeScore", "metaboliteInfo", "metmboliqueType", "metaboliqueId", "metmboliteID", "metabolitationId", "metmboliqueId", "metovaliteIN", "metabolriteInfo", "metabolitionId", "metabolitableIndex", "metabolriteName", "metabolitionAddress", "metabolitionID", "metaboliteIndex", "metmboliteId", "metaboliciteID", "metabolverseId", "metmboliteSize", "metaboliteIDs", "metabolriteScore", "metabolitableIDs", "metabololeIndex", "metabolicizeName", "metabolidateID", "metovalriteID", "metmbolitableID", "metabolitableName", "metabolriteIndex", "metabolriteType", "metabolitationID", "metovaliteName", "metabolitationIN", "metmboliteIndex", "metabolitableSize", "metovaliteID", "metabolidateName", "metmboliteName", "metaboliteAddress", "metmbolitableName", "metovalriteAddress", "metabololeName", "metaboliteScore", "metaboliteId", "metovalriteIndex", "metabolidateScore", "metabolriteId", "metabolheticId", "metabolriteID", "metovaliteIndex", "metmboliqueID", "metabolheticIndex", "metabolriteSize", "metaboliteName", "metabolidateInfo", "metovalriteName", "metabolizeName", "metabolitableType", "metabolheticAddress", "metaboliteType", "metmboliteIDs", "metabolverseName", "metabolitableID", "metabolverseID"], "dataScore": [" dataWeight", "videoWeight", "indexID", "videoScore", "doubleType", "dataID", "dataRank", "numberGrade", "dataType", "inputMatch", "numberRank", "dataGrade", "DataSum", "DataSize", "numberWeight", "doubleWeight", "styleWeight", "doubleScore", "dataSize", " dataMatch", "doubleRank", "dataSource", "indexSource", "inputID", "laSum", "inputSize", "numberLevel", " dataSum", "numberType", "laPath", "DataMatch", "styleScore", " dataGrade", "DataPath", "styleType", "styleSize", "videoSize", "inputScore", "dataSum", "dataLevel", " dataPath", "indexScore", "videoType", "indexPath", " dataSource", "laLevel", "DataGrade", "inputSource", "DataRank", "dataWeight", "DataScore", "dataPath", "DataLevel", " dataRank", " dataType", " dataID", " dataLevel", " dataSize", "numberScore", "laScore", "inputPath", "dataMatch"], "data": ["DATA", "sample", "text", "pad", "array", "resource", "image", "message", "style", "body", "empty", "info", "weight", "area", "zip", "input", "result", "map", "split", "dat", "batch", "missing", "error", "done", "key", "code", "results", "source", "size", "media", "number", "ata", "div", "change", "string", "alpha", "extra", "json", "response", "picture", "ui", "content", "value", "buffer"], "molecularWeight": ["molesularSize", "molescularSize", "moleciumFlow", "mosellularWidth", "mosellularWeight", "molecularSize", "moleculeFlow", "moleularSize", "moleculeWidth", "moleuralWidth", "molesularWidth", "moleculeWeight", "molescularWeight", "molescularWidth", "molesularWeight", "molecularWidth", "mosecularWidth", "mosecularWeight", "molellularWeight", "moleciumWeight", "moleularWeight", "moleularWidth", "molecularFlow", "molellularWidth", "molellularFlow", "moleciumWidth", "moleculeSize", "moleuralSize", "moleuralWeight", "mosecularFlow", "mosellularFlow"]}}
{"id1": "21224967", "id2": "12146394", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "label": 0, "substitutes": {"crear": ["generas", " crea", " creare", "Crear", " creas", " Crea", "Crea", " Creas", " Creare", " Crear", "generare", "generar", "genera", "Creare", "Creas"], "result": ["page", "res", "default", "message", "mark", "length", "count", "rate", "event", "die", "limit", "entry", "status", "valid", "error", "score", "date", "out", "type", "ver", "results", "comment", "record", "db", "Result", "number", "sign", "user", "cash", "found", "feature", "match", "counter", "ure", "err", "success", "up", "grade", "order", "diff", "ret", "function", "response", "currency", "value", "force", "df"], "sql": ["fn", "statement", "log", "url", "ssl", "install", " SQL", "script", "cmd", "pg", "session", "sync", "fp", "zip", "job", "conn", "sq", "dl", "comment", "action", "plan", "seed", "db", "base", "string", "exec", "params", "select", "repl", "printf", "up", "sl", "query", "setup", "update", "where", "q", "database", "serv", "SQL", "ql", "join"], "connection": ["proxy", "statement", "log", "writer", "server", "communication", "system", "loc", "lock", "pg", "tc", "event", "engine", "session", "socket", "bc", "Connection", "application", "cond", "document", "connect", "ion", "index", "graph", "error", "union", "container", "conn", "connected", "driver", "config", "section", "client", "Exception", "BC", "db", "table", "position", "which", "cache", "con", "c", "relation", "ctx", "environment", "context", "function", "condition", "query", "collection", "manager", "p", "database"], "ps": ["ppa", "proxy", "pe", "ins", "cp", "ss", "pg", "os", "PS", "ns", "cop", "pos", "pse", "pt", "hs", "vs", "pa", "ips", "settings", "conn", "posts", "Ps", "pr", "pd", "properties", "qs", "pps", "ports", "eps", "po", "pc", "params", "ops", "pre", "sp", "proc", "query", "gs", "gres", "jp", "cs", "ups", "pers", "pp", "bs", "p", "ks", "ds", "changes"]}}
{"id1": "3958807", "id2": "23152865", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"loadBinaryStream": ["loadBatchFile", "loadBatchInput", "loadFbinaryFile", "loadFbinaryStream", "loadBInputFile", "loadBinaryFile", "loadFinaryContent", "loadBInputInput", "loadFinaryInput", "loadFbinaryContent", "loadFinaryStream", "loadBatchContent", "loadBInputStream", "loadBatchStream", "loadBbinaryContent", "loadBbinaryFile", "loadFinaryFile", "loadBInputContent", "loadBbinaryInput", "loadBinaryContent", "loadBbinaryStream", "loadFbinaryInput", "loadBinaryInput"], "streamName": ["channelKey", "filePath", "channelPath", " streamType", "resourcename", "StreamName", "StreamPath", "fileKey", "Streamname", "channelName", "streamKey", "streamType", "resourceName", " streamKey", "fileType", "streamPath", "fileName", " streamPath", "resourceType", "filename", "streamname", " streamname", "resourcePath"], "streamToLoad": ["streamToAdd", "objectToUpload", "streamtoAdd", " streamtoLoad", "streamToUse", "streamTOload", "objectToRead", "streamtoRead", "streamTOUpload", "objectTOUse", "streamTOUse", "streamWithUse", " streamToUse", "channelToAdd", "streamTOAdd", "streamtoLoad", "streamtoUse", " streamtoUse", "objectToUse", "streamToload", "streamWithAdd", " streamToAdd", "streamWithLoad", "streamtoUpload", "objectTOLoad", "streamWillUse", " streamtoRead", "streamWillUpload", "streamToUpload", "channeltoLoad", "streamToRead", "streamWillRead", "channeltoload", "channelToload", " streamtoAdd", "channelToLoad", "streamWithRead", "streamWillAdd", " streamToRead", "objectToLoad", "objectTOUpload", "streamTORead", "streamWillLoad", "channeltoAdd", "streamtoload", "streamTOLoad", "objectTORead"], "sz": ["szes", "ssze", " sze", "ssz", "szi", "szip", "wsz", "wsze", "imsiz", "wszi", "psz", "siz", "imszes", " szes", "sze", "pszi", " szip", "wszip", "pszip", "imsz", " szi", "imsze", "psze", "ssiz", " siz", "sszes"], "req": ["rec", "res", "rss", "respond", "fr", "report", "rx", "ok", "requ", "rh", "sem", "f", "input", "ref", "Request", "cb", "conn", "download", "wx", "rw", "require", "Resp", "progress", "pkg", "src", "client", "rr", "inv", "r", "exec", "qt", "err", "obj", "def", "ctx", "proc", "response", "q", "http", "serv", "request"], "resp": ["rec", "bb", "page", "res", "request", "rss", "respond", "circ", "report", "e", "server", "html", "Response", "rem", "par", "rel", "prev", "cmp", "remote", "rh", "body", "esp", "rev", "output", "rup", "fp", "zip", "reply", "ref", "conn", "download", "wx", "Resp", "api", "client", "wp", "cook", "exec", "err", "obj", "re", "comm", "ctx", "sp", "proc", "wb", "ret", "response", "jp", "http", "serv", "rep", "df"], "out": ["buf", "fn", "res", "log", "default", "copy", "null", "b", "os", "io", "data", "aos", "output", "in", "zip", "o", "Out", "s", "conn", "ws", "i", "boot", "tmp", "co", "base", "outs", "object", "cache", "exec", "bin", "gz", "binary", "ops", "OUT", "op", "auto", "response", "pool", "buffer", "again", "serv", "p", "img"], "bos": ["bb", "ros", "bro", "biz", "pins", "fits", "rob", "bare", "os", "obs", "las", "bh", "mis", "osi", "osa", "obo", "aos", "bc", "zos", "flo", "bis", "cro", "bott", "ko", "bo", "abi", "ios", "lol", "bes", "zo", "obos", "oos", "zb", "los", "bin", "bas", "ob", "obb", "bot", "lo", "bi", "oops", "bs", "boot", "bps", "ubis"]}}
{"id1": "8087001", "id2": "14785308", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generatestackHashString", "generateStackHeaderString", "generateStackhashKey", "generatestackHashkey", "generateStackhashkey", "generateStackhashString", "generatestackHashKey", "generateStackHashKeys", "generateStackHeaderKeys", "generateStackHashkey", "generatestackhashKey", "generateStackHeaderkey", "generatestackhashKeys", "generatestackHashKeys", "generateStackHeaderKey", "generatestackhashString", "generateStackhashKeys", "generateStackHashString", "generatestackhashkey"], "e": ["enter", "m", "pe", "ee", "ex", "est", "he", "ev", "esi", "se", "b", "n", "body", "en", "event", "this", "ie", "ec", "ele", "f", "oe", "es", "o", "d", "ace", "ae", "error", "h", "me", "el", "element", "ze", "Exception", "a", "er", "E", "r", "et", "exec", "err", "c", "t", "ea", "x", "ed", "ef", "fe", "exc", "p", "ception"], "digest": ["Diger", " Digest", "Digusher", "mdester", "mdature", "Signate", "decature", " Digested", " digher", "digature", "logester", " Digator", "Digester", "Digest", " digested", " digator", "mdested", "Digator", "logest", " digenge", "digher", "mder", " digusher", " diger", "Signature", "digate", "digge", "mdusher", " Digester", "decate", " digester", "Digenge", "Digested", "logher", "digester", "mdate", "digator", "Digher", "decester", "decest", " digge", "digenge", "diger", "Signest", "digested", "mdest", "digusher", "Digge", "mdenge", "Signester", "logge"], "hash": ["text", "ash", "array", "message", "image", "build", "b", "sha", "body", "rh", "dot", "data", "bh", "ph", "dig", "f", "her", "result", "hex", "sum", "h", "key", "code", "total", "kh", "ashes", "header", "base", "mac", "hed", "string", "v", "history", "ha", "Hash", "sh", "value"], "rtn": ["gtn", "rdb", "vrnn", "retns", "RTne", "retb", "RTns", "gtb", "vrne", "retN", "rtc", "RTc", "rtb", "RTnin", "ntpn", "rtN", "ntN", "RTN", "rtns", "rdN", "ntn", "ntc", "latne", "vrns", "txn", "ortnn", "vrN", "gtN", "RTn", "ntb", "ortn", "latns", "RTb", "rtnn", "ortN", "retn", "RTpn", "latn", "rtpn", "latN", "rdn", "ntnin", "rtne", "gtpn", "txN", "rdns", "rtnin", "txnin", "RTnn", "txc", "ortne", "vrn"]}}
{"id1": "19113613", "id2": "18613870", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "write", " cp", "cp", "sync", "zip", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "Copy", "create", "delete", "change", "load", "share", "upload", "get", "ssh", "transfer", "Cop", "put", "update", "p", "opy", "cop"], "in": ["ins", "url", "image", "In", "n", "connection", "init", "thin", "data", "this", "project", "inc", "old", "part", "f", "input", "din", "IN", "inn", "lin", "index", "plugin", "cin", "i", "kin", "win", "reader", "sin", "config", "inside", "client", "work", "a", "login", "inner", "base", "min", "id", "token", "bin", "c", "ic", "name", "diff", "pin", "get", "ini", "as", "again", "update", "on"], "out": ["at", "page", "ex", "vert", "one", "image", "resource", "call", "parent", "b", "null", "n", "connection", "remote", "init", "io", "off", "outer", "dot", "project", "this", "version", "outside", "inc", "external", "part", "output", "no", "group", "input", "block", "o", "Out", "conn", "with", "client", "self", "work", "base", "outs", "point", "user", "object", "app", "cache", "exec", "bin", "c", "v", "err", "obj", "option", "name", "net", "goal", "OUT", "up", "root", "other", "path", "x", "again", "line", "p", "ext"], "source": ["prefix", "proxy", "pe", "component", "attribute", "direction", "subject", "secret", "url", "uri", "unit", "resource", "parent", "dest", "scope", "view", "ce", "username", "project", "status", "Source", "site", "route", "family", "missing", "type", "sin", "iter", "class", "src", "size", "base", "feature", "alt", "internal", "position", "id", "ource", "name", "origin", "service", "reference", "SOURCE", "format", "secure", "force", "use", "from"], "target": ["prefix", "component", "direction", "url", "resource", "parent", "master", "dest", "null", "project", "output", "alias", "site", "route", "about", "template", "home", "cat", "top", "config", "src", "Target", "alt", "base", "point", "wrong", "address", "token", "arget", "detail", "name", "origin", "service", "reference", "root", "pattern", "host", "next", "goal", "path", "current", "value", "tail", "format", "force"], "files": ["ls", "keys", "ions", "ins", "links", "users", "obs", "jobs", "data", "assets", "f", "sections", "apps", "groups", "plugins", "features", "classes", "lines", "fs", "s", "children", "flows", "objects", "results", "docs", "tools", "images", "filename", "ports", "pages", "resources", "names", "models", "cells", "iles", "blocks", "Files", "items"], "file": ["page", "FILE", "url", "e", "resource", "ile", "uri", "parent", "le", "b", "unit", "letter", "item", "data", "single", "child", "part", "folder", "entry", "f", "it", "feed", "live", "el", "fe", "future", "dir", "directory", "filename", "l", "base", "object", "id", "local", "string", "load", "name", "entity", "binary", "per", "File", "layer", "path", "function", "current", " File", "line", "fp", "lib"], "inCh": ["InChan", "INChannel", "inCH", "InChannel", "INCH", "inch", "inChan", "outCH", " inch", "InCH", " inChan", " inCH", "outch", "Inch", "InCh", "outChan", "outChannel", " inChannel", "INChan", "inChannel", "INCh"], "outCh": ["Outch", "OutChan", "OutCH", "inCH", " outChannel", "inch", " outch", "inChan", "outCH", "OutChannel", "outputCh", "outch", "outputChan", "outChan", " outCH", "outChannel", "outputCH", "inChannel", "OutCh", "outputch"]}}
{"id1": "12454178", "id2": "8942491", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "label": 0, "substitutes": {"alterar": [" cryar", " cryAr", " crea", " crya", " celebra", " cultivar", " celebraran", " crearan", " crear", " cultivaran", " cryaran", " cultiva", " creAr", " cultivAr", " celebrAr", " celebrar"], "t": ["at", " mt", "rt", "to", "att", "m", "bolt", "u", "e", "wt", "xt", "n", "st", "tc", "flat", "ot", "this", "ut", "you", "tm", "in", "pt", "f", "it", "tool", "tt", "o", "nt", "d", "tower", "ta", "unt", "template", "type", "s", "tf", "the", "let", "T", "tools", "te", "i", "y", "l", "target", "tree", "tr", "et", "table", "det", "trans", "ti", "tp", "v", "c", "qt", "ts", "ant", "tw", "x", "p", "dt"], "stmt": ["strmn", "swmd", "stmr", "Strm", "putau", " stnt", "formrm", "tmr", "stdb", "istdb", "formmm", "stnt", "istmt", "putmt", "ctgr", "Stv", "tpt", " stmm", "Stmb", "smr", "spt", " stmn", "ctmt", "strm", "stmb", "Stgr", "strmt", " stbm", " stdb", "istmn", " stv", "strau", "stmd", "ustmd", " stct", "stpt", " stau", "ustau", " stpt", "Stct", " stgr", "swbm", "sdb", "tmt", "stau", " stmb", "stct", "Stbm", "istau", "Stau", "swmt", "stmm", "ctmb", "stbm", "formmt", " stmd", "stv", "stgr", "putmd", "ctct", "stmn", "Stmd", "Stmt", "ustnt", "smt", "swau", " strm", "putnt", "ustmt", "Stmm", "strdb", "tdb", "formv", " stmr"], "sql": ["ls", "sol", "statement", "log", "url", "details", " SQL", "cmd", "lock", "shell", "QL", "limit", "result", "zip", "stat", "job", "s", "conn", "sq", "dl", "pr", "plan", "seed", "lambda", "expression", "db", "base", "string", "params", "printf", "sl", "up", "mt", "query", "insert", "setup", "where", "q", "database", "serv", "SQL", "ql"], "id_disciplina": ["id_distrequini", "id_Disciplinea", "id_disciplini", "id_discomplina", "id_distciplinea", "id_disrequINA", "id_disciino", "id_disciplana", "id_Disciplissa", "id_disciplinea", "id_disciplineini", "id_Disciplini", "id_Disciplina", "id_distciina", "id_distciini", "id_disciinea", "id_distciplina", "id_distciino", "id_discomplana", "id_disrequina", "id_disciplineino", "id_disciINA", "id_distciplini", "id_disciplissa", "id_disciina", "id_distrequina", "id_disciplineana", "id_discomplino", "id_disciplineINA", "id_discomplinea", "id_disciana", "id_discomplini", "id_distrequinea", "id_Disciplineini", "id_disciini", "id_disguinea", "id_disguini", "id_disciplino", "id_disguina", "id_disrequinea", "id_distciplINA", "id_disciplineissa", "id_disciplineinea", "id_distciplino", "id_discomplissa", "id_distciana", "id_disguissa", "id_Disciplineina", "id_distciplana", "id_distrequINA", "id_Disciplineissa", "id_disciplINA", "id_Disciplineinea", "id_disciplineina", "id_disrequini"], "item": ["at", "m", "page", "pe", "request", "url", "unit", "e", "server", "parent", "event", "info", "data", "entry", "it", "result", "site", "area", "o", "index", "container", "type", "instance", "i", "source", "action", "hop", "reader", "article", "er", "ip", "edit", "bar", "queue", "r", "object", "id", "seller", "v", "Item", "name", "other", "service", "order", "or", "q", "items", "p"]}}
{"id1": "10385815", "id2": "1188100", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "write", "cmp", "Transfer", "sync", "zip", "paste", "split", "clone", "download", "process", "move", "Copy", "create", "delete", " Copy", "send", "change", "exec", "file", "upload", "get", "transfer", "Cop", "put", "update", "open"], "fileFrom": [" fileIn", "ioSource", "mailFrom", "FileIn", " fileAs", "mailAs", "FileTo", "FileFrom", "FileSource", "ioTo", "fileStart", "FileStart", "fileSource", "FileAs", " fileSource", " fileStart", "fileAs", "ioStart", "mailTo", "fileIn", "ioFrom", "mailIn"], "fileTo": ["FileTarget", "fpto", "fpFrom", "FileTo", "FileFrom", "fileto", "resourceTo", "FileTO", " fileFile", "fileTarget", " fileto", "resourceFrom", "FileFile", "fileFile", "resourceTarget", " fileTarget", " fileTO", "fpTO", "fpTo", "fileTO", "Fileto", "resourceFile"], "inputStream": ["outputSync", " inputSync", "inputSteam", "InputFile", "outputContext", "outputstream", "inputFile", " inputContext", "InputContext", "inputContext", "outputFile", "Inputstream", "inputSync", " inputFile", "outputSteam", "InputSteam", "InputSync", "InputChannel", "inputstream", " inputstream", "InputStream", " inputSteam"], "outputStream": ["OutputPath", "inputChan", "writeChannel", "inputSteam", "writeSocket", "fourStream", "outputStreamer", " outputSteam", "fourChannel", " outputChan", "writeStream", " outputPath", "fourStreamer", "writeSteam", "referenceSocket", "outputSocket", "outputPath", " outputStreamer", "outputChan", "OutputChannel", "OutputStream", "OutputChan", "OutputSteam", "fourSteam", "outputSteam", "referenceChannel", "OutputStreamer", "referenceSteam", "referenceStream", "inputSocket", "inputPath"], "inputChannel": ["butContext", "parentStream", "inputChan", "parentChannel", "butCommand", " inputCam", "outputContext", "audioChannel", "inputCommand", "butChan", "outputClient", " inputContext", " inputPassword", "audioStream", "audioCam", "butChannel", "InputContext", "inputContext", "inputCam", "InputSocket", " inputChan", "outputSocket", " inputClient", "audioClient", "parentPassword", " inputCommand", "outputPassword", "outputChan", "outputCam", " inputSocket", "outputCommand", "parentChan", "InputChan", "inputClient", "inputPassword", "InputChannel", "inputSocket", "InputStream"], "outputChannel": ["inputChan", "outContext", "outputContext", " outputChan", "Outputchannel", "inputQueue", "OutputContext", "inputchannel", "inputContext", " outputQueue", "OutputQueue", "outStream", "outputQueue", "outputChan", "OutputChannel", "OutputStream", "outChan", " outputchannel", "OutputChan", "outChannel", " outputContext", "outputchannel"]}}
{"id1": "16550855", "id2": "10131427", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"readPage": ["readFile", "getPages", "openFile", "readpage", "readPages", "getpage", "getFile", "findPage", "findPages", "openPages", "findpage", "openPage", "findFile", "getPage", "openpage"], "ignoreComments": ["orecomments", " ignoreQuotes", "includeComments", " ignoreTags", "includeComment", " ignoreComment", "includeTags", "useQuotes", "useComments", "oreQuotes", "useTags", "oreTags", "ignoreQuotes", "usecomments", "includecomments", "ignoreComment", " ignorecomments", "oreComments", "ignoreTags", "oreComment", "ignorecomments"], "in": ["into", "rec", "m", "ins", "url", "ssl", "e", "image", "In", "b", "connection", "init", "data", "version", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "inn", "lin", "index", "h", "out", "s", "i", "kin", "win", "source", "reader", "is", "client", "inside", "nin", "stream", "login", "inner", "user", "min", "r", "id", "token", "bin", "c", "err", "con", "file", "loader", "re", "t", "ini", "as", "buffer", "again", "http", "on", "isin"], "inputLine": ["rawText", "installLook", "ifLook", "requestCo", "inputPage", "Inputline", "inputText", "InputCell", "requestLink", "pullRow", " inputRow", "ifline", "pullLink", "inputCo", "requestLook", "incLook", " inputCell", "requestRow", "inputL", "pullline", "imageLine", "InputLine", "InputName", "InputPage", "rawL", "inputRow", "ifCo", "rawName", "incLine", "commentLine", " inputLink", "commentline", "installL", " inputline", "installLine", "requestline", " inputLook", "imageline", "installline", "imageLook", "pullLine", "ifLine", "inputCell", "commentCell", "imageL", "InputLink", "inputLook", "inputName", " inputText", "InputText", "inputLink", "InputLook", "InputL", "rawline", " inputName", "rawLink", "commentPage", " inputCo", "incline", "rawLine", "inputline", " inputPage", "requestLine", " inputL", "incL"], "html": ["css", "high", "page", "text", "bsp", "rss", "js", "url", "message", "plain", "details", "view", "body", "summary", "links", "flat", "data", "htm", "msg", "link", "strong", "blog", "title", "part", "output", "ht", "wrap", "f", "result", "www", "tt", "str", "template", "attr", "h", "tf", "live", "home", "inline", "bf", "xml", "temp", "source", "api", "article", "war", "atom", "header", "flash", "web", "gh", "dump", "base", "HTML", "show", "hard", "amp", "hot", "detail", "tml", "embed", "json", "ui", "content", "format", "http", "doc", "img"]}}
{"id1": "18793482", "id2": "8150996", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifiedapplicationMessage", "modifyAppmessage", "modifyapplicationContent", "modifyAppMessage", "modifyAppContent", "modifiedApplicationmessage", "modifyApplicationmessage", "modifyapplicationmessage", "modifiedapplicationmessage", "modifyApplicationMsg", "modifyExternalMsg", "modifiedApplicationMsg", "modifyapplicationMsg", "modifyapplicationMessage", "modifiedApplicationMessage", "modifyAppMsg", "modifyExternalMessage", "modifyApplicationContent", "modifiedapplicationMsg", "modifyExternalmessage", "modifiedApplicationContent", "modifyExternalContent", "modifiedapplicationContent"], "locale": ["locales", "localale", "Locator", "locationales", "locator", "placeALE", "locationALE", "Locale", "localue", "locame", "Locue", "LocALE", " locame", "localame", "locationue", "localator", " locator", "Locame", "Locales", "placeame", "placeale", " locales", "locationale", "placeales", "locALE", "localALE", "localales", "locue"], "messageName": [" messagename", "msgKey", "reasonType", "reasonName", "reasonname", "messageKey", "phraseValue", "msgType", " messageType", "messagename", "MessageValue", "phraseType", "messageType", "MessageType", "MessageKey", "MessageName", " messageKey", "Messagename", "phraseKey", "reasonValue", "msgName", "msgValue", "phraseName"], "messageValue": ["responseVal", "msgVal", "MessageVal", "msgType", " messageType", "MessageValue", "responseType", " messageVal", "messageType", "MessageType", "MessageName", "messageVal", "msgName", "responseName", "msgValue", "responseValue"], "properties": ["prop", "Property", "txt", "Pro", "conf", " props", "ps", "stats", "options", "data", "py", "pb", "ips", "settings", "xml", "metadata", " Properties", "config", "api", "tmp", "perties", "resources", "obj", "params", "property", "ops", "json", "pro"], "i18nPath": ["i18onLocation", "i18fCorp", "i16nsPath", "i18nsPath", "i11npath", "i18ninFile", "i11fCorp", "i18nStr", "i11nUrl", "i18napath", "i18ninLocation", "i18nspath", "i32nPath", "i18onUrl", "i16nsStr", "i18neUrl", "i18nsUrl", "i11fUrl", "i11nPath", "i16nPart", "i18nePath", "i16nStr", "i18nUrl", "i18nsStr", "i18nCorp", "i18fUrl", "i16npath", "i18nsCorp", "i16nsPart", "i18naStr", "i18bStr", "i18nsLocation", "i18bpath", "i11fPath", "i18nsFile", "i32nLocation", "i18ninUrl", "i18onFile", "i18onPath", "i16nspath", "i32nUrl", "i32nFile", "i18fpath", "i32ninFile", "i18nPart", "i18nsPart", "i18naPart", "i11fpath", "i18nepath", "i18bPart", "i18bPath", "i32ninPath", "i32ninUrl", "i11nCorp", "i18nLocation", "i18ninPath", "i16nPath", "i18neCorp", "i32ninLocation", "i18fPath", "i18npath", "i18naPath", "i18nFile"], "englishFile": ["englishJar", "englishfile", "examplefile", "EnglishFolder", "exampleFile", "languageFile", "EnglishPath", "ianaJar", "ianaFile", " englishJar", " englishPath", "languageDir", "languageFiles", "ianaPath", "EnglishFiles", "Englishfile", " englishFiles", "languagePath", "languageJar", "exampleFolder", "englishFolder", "propertiesPath", "englishPath", "examplePath", "propertiesFolder", "ianaDir", "languagefile", "englishFiles", "propertiesfile", " englishfile", "englishDir", " englishDir", "propertiesFile", "EnglishFile"], "propertiesFilePath": ["pertiesfileName", "propertiesfileUrl", "pertiesFileName", "propertiesfilePath", "propertiesSourceFileName", "propertiesSourceFileURL", "propertiesfileURL", "propertiesfilepath", "pertiesDirName", "propertiesFileName", "pertiesDirPath", "propertiesDirName", "propertiesFileUrl", "propertiesDirpath", "pertiesDirpath", "pertiesfilepath", "propertiesFilesPath", "propertiesfileName", "pertiesDirUrl", "pertiesFilepath", "propertiesSourceFilePath", "propertiesDirUrl", "propertiesFilesURL", "propertiesFilesUrl", "propertiesSourceFilepath", "pertiesFileUrl", "propertiesDirPath", "propertiesFilepath", "pertiesfileURL", "pertiesFilePath", "pertiesFileURL", "propertiesFileURL", "propertiesFilesName", "propertiesFilespath", "pertiesfilePath"], "file": ["FILE", "one", "parent", "letter", "die", "data", "single", "socket", "part", "field", "class", "directory", "l", "files", "string", "php", "page", "text", "pe", "unit", "resource", "message", "connection", "folder", "model", "zip", "h", "object", "show", "handler", "entity", "path", "word", "content", "format", "book", "log", "url", "play", "application", "future", "stream", "binary", "up", "File", "function", "buffer", "http", "force", "use", "fp", "module", "ile", "le", "b", "lock", "child", "f", "it", "source", "reader", "filename", "media", "base", "language", "name", "property", "full", "or", "fe", "p"], "in": ["into", "ins", "image", "In", "b", "n", "init", "io", "inc", "f", "it", "gin", "input", "din", "d", "inn", "lin", "IN", "s", "cin", "sin", "i", "rin", "reader", "kin", "win", "inside", "nin", "l", "er", "login", "inner", "r", "bin", "con", "err", "ic", "ri", "pin", "ini", "or", "plus", "again", "p", "isin"], "out": ["to", "ex", "one", "image", "write", "plain", "b", "n", "io", "outer", "sync", "inc", "socket", "part", "output", "f", "exp", "o", "Out", "and", "end", "error", "s", "home", "i", "builder", "co", "work", "cli", "inner", "outs", "r", "string", "v", "bin", "err", "exec", "by", "up", "net", "w", "OUT", "ou", "full", "lib", "word", "again", "p", "ext"], "c": ["k", "ct", "esc", "col", "uc", "C", "b", "n", "rc", "ce", "arc", "dec", "bc", "ec", "f", "o", "d", "ch", "cl", "ci", "h", "cur", "code", "cc", "i", "cu", "size", "ice", "a", "l", "r", "xc", "sc", "ac", "v", "pc", "con", "character", "abc", "dc", "w", "t", "cf", "cont", "x", "cy", "pointer", "lc", "enc", "cr", "p", "char"], "is": ["res", "ins", "does", "os", "ps", "info", "si", "iso", "it", "es", "str", "bis", "IS", "us", "s", "ios", "i", "iter", "api", "stream", "ib", "id", "iss", "ir", "ais", "ris", "has", "Is", "re", "get", "as", "ui", "isa", "are", "serv", "ri", "isu", "its"], "breader": [" BreadER", " cakeers", " cakeER", " cakeler", "feediter", " cakeer", "brewamer", "webamer", "breadler", "breadr", "weber", "brewiter", "webiter", "breadamer", "brewer", " breaders", "feedamer", " Breadler", "breaditer", " breadler", "webr", "feeder", " breadER", "breaders", " Breaders", "breadER", " Breader", "brewr", "feedr"], "line": ["page", "text", "LINE", "log", "url", "frame", "lf", "message", "one", "write", "le", "style", "body", "letter", "item", "cell", "data", "link", "sync", "part", "no", "definition", "status", "phrase", "entry", "rule", "model", "str", "split", "lin", "strip", "lines", "error", "key", "row", "end", "code", "pass", "inline", "nl", "lined", "comment", "el", "parse", "band", "section", "header", "li", "side", "l", "ip", "base", "look", "day", "string", "character", "Line", "liner", "name", "plugin", "sl", "next", "response", "lo", "word", "value", "lc", "feed", "block"], "strBuilder": ["StrBuild", "strbuilder", "StrBuilder", "strBlock", "stringBuild", "strBuild", "brBlock", "stringBuffer", "brBuilder", "stringbuilder", "Strbuilder", " strBlock", " strbuilder", "strBuilding", "brBuilding", "StrBlock", " strBuild", "StrBuilding", " strBuffer", "stringBuilding", "strBuffer", "brBuild", "stringBuilder", " strBuilding", "brBuffer", "brbuilder", "StrBuffer"], "pieces": ["places", "forms", "values", "keys", "tops", "cuts", "marks", "pins", "circle", "letters", "piece", "lists", "parts", "tips", "rings", "apps", "planes", "sections", "groups", "features", "split", "bytes", "lines", "ips", "flows", "objects", "seconds", "cards", "vals", "nets", "pages", "files", "bits", "steps", "names", "bones", "packs", "cells", "ops", "blocks", "pots", "words", "boxes", "phones", "services", "strings", "items", "styles"], "found": ["loaded", "matched", "fl", "sent", "printed", "still", "successfully", "count", "null", "got", "letter", "fall", "failed", "built", "updated", "successful", "created", "old", "not", "filled", "search", "required", "all", "f", "result", " Found", "valid", "missing", "val", "broken", "temp", "made", "true", "lost", "l", "finding", "identified", "given", "err", "find", "Found", "confirmed", "left", "full", "defined", "first", "normal", "used", "expected", "based", "fixed", "changed"]}}
{"id1": "23398710", "id2": "12454178", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"getUser": ["getPerson", "createProfile", "newProfile", "newAccount", "createAccount", "newUser", "newPerson", "createPerson", "getProfile", " getProfile", "getAccount", " getAccount", " getPerson", "createUser"], "get": ["p", "url", "resource", "call", "build", "g", "view", "body", "got", "remote", "google", "init", "like", "method", "ge", "this", "single", "GET", "model", "it", "status", "check", "Get", "set", "read", "handle", "i", "consumer", "create", "api", "parse", "pull", "cli", "sign", "send", "object", "token", "show", "give", "cache", "c", "v", "start", "service", "find", "entity", "json", "query", "invoke", "put", "update", "http", "request", "open", "post"], "client": ["p", "console", "url", "ssl", "resource", "server", "call", "copy", "connection", "manager", "io", "method", "this", "session", "channel", "output", "result", "connect", "conn", "i", "consumer", "api", "bird", "cli", "web", "contact", "Client", "send", "control", "https", "con", "handler", "app", "service", "per", "php", "secure", "http", "request", "open"], "response": ["wave", "resp", "page", "writer", "subject", "respond", "uri", "resource", "message", "server", "image", "report", "view", "Response", "connection", "body", "successful", "data", "version", "serv", "output", "application", "status", "document", "result", "site", "reply", "index", "error", "results", "api", "tree", "send", "queue", "object", "handler", "success", "service", "relation", "full", "json", "generation", "collection", "http", "feed", "request", "offer", "received"], "statusCode": ["StatusC", "statusC", "successCode", " statusType", "statuscode", "responseCode", "statusType", "StatusType", "responseType", " statusC", " statuscode", "Statuscode", "StatusCode", "successcode", "successC", "successType"], "sBuf": ["sBbuff", " sBuff", "sPluf", " sFbuf", " sBlu", "sQbuf", "sBBumb", " sFlu", "sBerumb", "sAbuf", "sBeruf", "sFumb", " sFumb", "sFlu", " sAbuf", "sQumb", "sBerlu", "sBbuf", "sBlu", " sFuf", "sBBuff", "sPlbuf", "sBuff", "sFuff", " sAbuff", " sBbuff", " sBBuf", " sBBbuf", "sBerbuf", "sAuf", "sAbuff", "sFbuf", "sAuff", " sBumb", " sAuff", "sQuf", "sPllu", "sFuf", "sFbuff", "sBBbuf", "sBumb", "sBBbuff", "sBBuf", "sPlumb", " sBBumb", " sBbuf", " sAuf"], "linea": ["Lineha", " lineA", "idea", "ideA", " lineha", "lineA", "linva", "linas", " lineas", "Lineas", "lineha", "Linea", " lineva", "ideva", "linha", "linA", "lineas", "lineva", "Lineva", "ideas", "LineA", "lina"], "reader": ["writer", "e", "server", "rx", "rer", "ser", "io", "data", "ner", "reading", "rar", "parser", "f", "result", "Reader", "input", "editor", "upper", "read", "row", "player", "i", "builder", "iter", "driver", "bird", "stream", "er", "l", "rr", "worker", "inner", "r", "handler", "loader", "per", "cher", "layer", "keeper", "ler", "pointer", "buffer", "wrapper", "oder", "line", "feed", "ri", "right"], "salida": [" salicka", "bilicka", "salara", "salido", " salidas", "saticka", "milida", "slida", "bilara", "salicka", "bilido", "milidas", "Salara", "Salida", "slidas", " salanda", "satara", "satida", "Salido", "satido", "Salidas", "salidas", "slara", "milanda", " salido", "milido", "slanda", "salanda", "Salanda", " salara", "bilida"], "user_firstname": ["user_thirdname", "user_fullname", "user_realnames", "user_lastName", "user_headame", "user_firstName", "user_realname", "user_lastame", "user_fullName", "user_firstame", "user_thirdphone", "user_realame", "user_fullame", "user_firstphone", "user_lastnames", "user_realName", "user_fullnames", "user_firstnames", "user_headname", "user_headphone", "user_lastphone", "user_thirdame"], "user_lastname": ["user_fullname", "user_pastName", "user_lastName", "user_lastword", "user_firstword", "user_lastame", "user_pastaddress", "user_fullName", "user_firstame", "user_fullame", "user_longname", "user_longaddress", "user_longame", "user_fulladdress", "user_pastame", "user_lastnames", "user_fullnames", "user_firstnames", "user_pastname", "user_fullword", "user_longName", "user_lastaddress"]}}
{"id1": "6963063", "id2": "14038176", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"mas": ["mes", "mag", "forms", "mad", "ls", "asa", "ins", "marks", "ages", "sha", "astics", "os", "data", "las", "mis", "ias", "asia", "parts", "cats", "MA", "faces", "ums", "pos", "lam", "spec", "features", "fa", "pa", "ga", "mc", "amps", "ta", "inas", "missing", "ms", "meta", "cas", "Las", "images", " ma", "a", "asm", "lambda", "ras", "mast", "mat", "ima", "mos", "names", "sa", "mm", "ma", "bas", "ams", "amas", "alpha", "la", "params", "xs", "rules", "phi", "ama", "central", "nas", "as", "ra", "afi", "cs", "months", "ia", "phas", "space"], "sort": ["filter", "replace", "ort", "vert", "default", "label", "parent", "master", "g", "axis", "cmp", "offset", "par", "loc", "init", "num", "ul", "style", "Sort", "hide", "scale", "part", "pos", "search", "alias", "o", "split", "index", "type", "ji", "orient", "s", "parse", "ist", "size", "l", "edit", "adjust", "sign", "min", "alt", "place", "position", "slice", "ind", "lower", "id", "err", "alpha", "start", "list", "order", "pre", "diff", "ii", "update", "seq", "use", "lib"], "j": ["ij", "k", "m", "js", "u", "z", "b", "n", "num", "si", "jc", "ie", "f", "it", "o", "d", "ci", "h", "oi", "ji", "J", "is", "y", "li", "a", "l", "pi", "xi", "ind", "v", "I", "ii", "ui", "bi", "jp", "x", "q", "p"], "i": ["ij", "k", "m", "u", "z", "uri", "e", "b", "fi", "init", "ori", "io", "info", "data", "si", "ie", "in", "f", "ni", "it", "o", "index", "ci", "iu", "oi", "ji", "h", "abi", "temp", "api", "multi", "li", "di", "a", "mi", "ip", "pi", "xi", "hi", "cli", "inner", "slice", "yi", "id", "uli", "ti", "gi", "v", "c", "ix", "I", "ai", "phi", "ri", "ini", "ii", "ui", "bi", "x", "jp", "mu", "lc", "qi", "ik"]}}
{"id1": "11716816", "id2": "12171364", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"updateFile": ["updateBody", "copyBody", "upFolder", "upDirectory", "importBody", "copyFolder", "copyFile", "upFile", "importFolder", "upBody", "updateFolder", "updateDirectory", "copyDirectory", "importFile", "importDirectory"], "file": ["pe", "log", "FILE", "url", "resource", "e", "image", "parent", "b", "connection", "lock", "io", "info", "data", "single", "this", "socket", "part", "model", "f", "zip", "input", "type", "class", "source", "future", "dir", "filename", "l", "db", "files", "base", "queue", "object", "local", "cache", "load", "handler", "name", "up", "full", "File", "get", "path", "line", "current", "content", "http", "fp"], "IOException": ["Timeoutception", "DownloadProblem", "Downloadception", "TimeoutException", "DownloadException", "TimeoutProblem", "IOception", " IOception", " IOProblem", "IOProblem"], "destFile": ["flatFile", "destFull", "origTable", "destroyDir", "srcPath", " destFolder", "destFiles", "flatDir", "destFolder", "sourceFolder", "destTable", "origFile", " destinationFiles", "srcFiles", "destroyTable", " destinationFile", "destPath", " destFull", "origfile", "DestFile", "destDir", "flatFiles", "sourceFile", "Destfile", "DestPath", " destfile", "origDir", "DestDir", "DestFull", "destroyfile", " destTable", " destFiles", "sourceFiles", "srcFolder", "destfile", "srcFile", " destDir", "DestFiles", " destinationFull", "DestFolder", " destPath", "flatfile", "destroyFile", " destinationDir", "sourceDir"], "in": ["ins", "image", "In", "b", "ax", "connection", "lock", "init", "io", "this", "sync", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "cl", "s", "pass", "conn", "cin", "el", "i", "source", "win", "pull", "reader", "with", "client", "inside", "a", "l", "nin", "login", "work", "inner", "min", "r", "id", "ac", "bin", "con", "c", "err", "re", "up", "pin", "cf", "ini", "as", "again", "on", "p", "isin"], "out": ["at", "to", "ex", "writer", "url", "resource", "call", "In", "b", "n", "connection", "io", "off", "outer", "this", "sync", "outside", "inc", "socket", "channel", "output", "no", "cookie", "exp", "o", "password", "Out", "timeout", "conn", "pass", "i", "client", "nin", "co", "of", "login", "point", "outs", "user", "exec", "bin", "err", "obj", "c", "name", "option", "extra", "up", "net", "w", "OUT", "ou", "again", "lib", "ext"]}}
{"id1": "15799935", "id2": "13563706", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAppensionPart", "saveAttachedBody", "saveAttPartBody", "saveAppachmentBody", "saveAppensionBody", "saveAttensionBody", "saveAttachedPart", "saveAppachmentPart", "saveAttachedbody", "saveAttachmentbody", "saveAttachmentFile", "saveAppensionFile", "saveAttensionFile", "saveAttensionbody", "saveAppachmentbody", "saveAttachmentPart", "saveAttPartFile", "saveAppachmentFile", "saveAttPartPart", "saveAttensionPart", "saveAppensionbody", "saveAttPartbody"], "context": ["text", "component", "subject", "message", "resource", "parent", "view", "connection", "system", "ce", "event", "version", "project", "channel", "definition", "document", "input", "mc", "coll", "translation", "template", "support", "community", "container", "Context", "cca", "driver", "config", "cms", "client", "media", "contact", "reader", "center", "network", "queue", "cache", "present", "c", "service", "kernel", "ctx", "host", "environment", "cf", "current", "state", "concept", "front", "ca", "content", "collection", "manager", "request", "processor"], "part": ["art", "to", "partial", " Part", "component", "message", "image", "parent", "html", "body", "connection", "event", "parts", " parts", "channel", "area", "block", "Parts", "translation", "phase", "type", "comment", "source", "mission", "section", "plan", "media", "PART", "pod", "base", "place", "point", "position", "Part", "object", "po", "patch", "file", "chapter", "upload", "start", "app", "name", "service", "per", "pre", "or", "state", "from", "p"], "localAttachment": ["localArtment", "LocalAttail", "LocalAssachment", "localAssention", "localAssment", "localAssachment", "localAddachment", "localAttention", "localAddrollment", " localAttention", "localAttachrollment", "LocalAssail", "LocalAttention", "localAttachacher", " localExtention", " localAttribution", "localattention", " localPartention", "localattachment", "localPartachment", " localAttrollment", "localExtachment", " localExtacher", "localAddail", "localAttachachment", " localExtachment", "localAvacement", "localAddment", " localAttacement", "localAvacher", "localAttail", "localInstachment", " localAttachachment", "localPartension", "localPartribution", "LocalAttachment", " localAttachrollment", "LocalAssment", "LocalAttment", " localAttacher", " localExtacement", "localInstension", " localPartension", "localattment", "localAttrollment", "localAttension", "localExtacement", " localAttachention", " localAttension", "localAttachention", "localAttachension", " localPartachment", "LocalAssention", "localArtail", "localAvachment", "localInstention", "localExtention", "localAttachacement", "localAttacement", "localAttachribution", "localExtacher", "localattrollment", " localPartribution", " localAttment", "localAttribution", "localAttment", "localInstribution", "localAssail", "localArtention", "localPartention", "localAddention", "localArtachment", "localAttacher", "localAvention"], "accountId": ["feedName", "AccountName", "accInfo", "jobName", "appID", "contractId", "appid", "jobid", "contactId", "contractName", "accid", "accID", "AccountID", " accountID", "accountName", "feedId", " accountid", "jobId", "accountInfo", "jobID", "AccountId", " accountName", "accountid", "contractid", "appId", " accountInfo", "Accountid", "contactid", "feedid", "appInfo", "accountID", "contactName", "accId", "feedID"], "attachmentId": ["attociationType", "addachmentType", "extensionSource", "atachmentID", "addachmentId", "attachedID", "attentionID", "attensionSource", "attentionIndex", "attagramInfo", "attlementName", "attagramId", "attlementId", "adachmentIndex", "addentionId", "attensionId", "attmissionSource", "attachmentid", "atociationID", "attentionUrl", "attachmentSource", "attociationReference", "attensionID", "addentionID", "attmissionID", "extachmentSource", "adentionId", "atociationId", "attmissionId", "attmentName", "attociationName", "attachmentType", "adachmentId", "attptionIndex", "attachmentID", "attptionInfo", "addentionType", "attachedType", "extensionId", "attachedId", "attociationID", "atachmentReference", "attachmentReference", "attachmentInfo", "attentionInfo", "addentionUrl", "attachmentName", "addachmentID", "attagramID", "extachmentId", "attmentId", "atachmentName", "attensionid", "adentionIndex", "atociationReference", "extachmentID", "extensionID", "attmentReference", "attlementReference", "attachedUrl", "attptionID", "adachmentInfo", "attentionId", "attachmentIndex", "extensionid", "adentionID", "attagramIndex", "attociationId", "atachmentId", "attentionSource", "attentionid", "attmissionid", "attlementID", "adachmentID", "adentionInfo", "attmentID", "addachmentUrl", "attentionType", "attachmentUrl", "attociationUrl", "extachmentid", "atociationName", "attptionId"], "in": ["ins", "url", "image", "In", "copy", "init", "info", "data", "inc", "socket", "gin", "f", "it", "input", "din", "IN", "inn", "conn", "pass", "cin", "i", "is", "source", "pull", "reader", "inside", "nin", "a", "login", "inner", "slice", "id", "ac", "load", "bin", "file", "con", "err", "up", "pin", "ini", "as", "or", "plus", "again", "p"], "saveIn": [" saveOut", " saveIN", " savein", "savein", "SaveOut", "savOut", "stageOut", "saveOut", "aveAs", "savin", "aveIN", "writein", "writeOut", "stageAs", "writeIN", "avein", "stageIn", "stageIns", "aveIn", "saveIns", "SaveIns", "savIn", "savAs", " saveIns", "saveIN", "SaveAs", "aveOut", "SaveIn", "writeIn"], "saveAs": [" saveOut", " saveFile", "SaveOut", "copyAs", " saveAS", "writeAS", "copyAS", "openFile", "saveOut", "copyas", "saveAS", "saveas", "createAS", "copyIn", " saveas", "createFile", "writeOut", "openAt", "createAt", "writeAs", "saveFile", "Saveas", " saveAt", "openAs", "saveAt", "createAs", "SaveAs", "SaveAS", "SaveIn", "writeIn", "openAS"], "out": ["at", "to", "page", "ex", "writer", "default", "flow", "image", "copy", "null", "init", "io", "off", "data", "outer", "this", "sync", "inc", "output", "o", "Out", "s", "conn", "temp", "source", "client", "a", "inner", "outs", "cache", "string", "v", "bin", "file", "c", "err", "exec", "name", "other", "up", "OUT", "path", "as", "plus", "again", "line", "ext"], "copySize": ["opensize", "leSIZE", " copysize", "saveLength", "copysize", "openLength", " copyLength", "leLength", "CopyLength", " copySIZE", " copyAddress", "openSize", "byteAddress", "copyLength", "savesize", "saveAddress", "CopySize", "copyAddress", " copyTime", "lesize", "saveSize", "CopyTime", "leSize", "copyTime", "bytesize", "byteLength", "openSIZE", "byteTime", "copySIZE", "byteSize", "Copysize"], "contentUriString": ["contentIiStr", "contentUriStr", "contentUiniByte", "contentIriStr", "contentUristring", "contentUiniStr", "contentIriUnit", "contentIrisUnit", "contentUiniNumber", "contentUiNumber", "contentUioString", "contentUriUnit", "contentUuriStr", "contentUridString", "contentIriNumber", "contentUpiString", "contentUiostring", "contentUriByte", "contentUridStr", "contentIrisstring", "contentIriString", "contentUiString", "contentUrisStr", "contentUiStr", "contentUioStr", "contentUrisstring", "contentIriInt", "contentUiniString", "contentUpiInt", "contentUrisInt", "contentUuriNumber", "contentUiByte", "contentIrisStr", "contentIrisInt", "contentUpistring", "contentIriByte", "contentUrisString", "contentUuriString", "contentUridUnit", "contentIiString", "contentIiNumber", "contentUrisUnit", "contentUriInt", "contentUioInt", "contentUiUnit", "contentUriNumber", "contentIrisString", "contentIiByte", "contentUuriByte", "contentIristring", "contentUpiStr"], "mSize": ["pSize", "pCount", "iSize", "mCount", "pLength", "pName", "cCount", "mName", "mLength", "iName", "cLength", "cName", "cSize", "iLength", "iCount"], "mContentUri": ["mContentIci", "mResourceUri", "mContentOUric", "mResourceIci", "mResourceIris", "mContentOUci", "mContentIric", "mResourceIri", "mContentUrris", "mResourceUci", "mResourceUric", "mContentUrri", "mContentUris", "mContentUric", "mContentOUris", "mResourceUris", "mResourceIric", "mContentIri", "mContentUrci", "mContentOUri", "mContentIris", "mContentUci", "mContentUrric"], "cv": ["conv", "buf", "cap", "que", "core", "vp", "uc", "cp", "loc", "rc", "sv", "um", "av", "uv", "csv", "bc", "vv", "vr", "vs", "mc", "pb", "iv", "coll", "nc", "cb", "auc", "iq", "cc", "nv", "ctrl", "cu", "cm", "keep", "co", "ov", "xc", "sc", "CV", "lv", "cr", "v", "c", "VC", "fc", "GV", "vc", "ctx", "cf", "cd", "cover", "vm", "lc", "content", "cs", "ca", "enc", "fp"], "uri": ["prefix", "proxy", "attribute", "url", "resource", "data", "username", "universal", " URI", "range", "route", "iv", "storage", "href", "ci", " Uri", "uni", "i", "uid", "metadata", "api", "cli", " url", "mi", "pi", "base", "point", " ur", "id", "address", "string", " scheme", "URI", "gb", "iri", "environment", "path", "ui", "query", "qi", "location", "format", "http", "oid", "ri"]}}
{"id1": "9805906", "id2": "2668634", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["save", "ln", "copy", "info", "data", "store", " dumping", "f", " dumps", "zip", "all", "out", "download", "flush", " dumped", "dir", "db", "files", "load", "println", "diff", "transfer", "ump", "update", "Dir", "export", "df"], "source": ["uri", "unit", "resource", "server", "se", "core", "parent", "view", "connection", "remote", "this", "series", "Source", "site", "input", "ources", "s", "sin", "iter", "src", "stream", "slave", "base", "slice", "address", "string", "ource", "file", "start", "service", "SOURCE", "current", "scene", "http", "use", "from"], "target": ["replace", "to", "resource", "large", "parent", "dest", "null", "master", "connection", "project", "port", "follow", "output", "alias", "it", "result", "effect", "template", "out", "settings", "top", "src", "Target", "base", "table", "object", "address", "arget", "file", "platform", "root", "goal", "next", "host", "path", "pointer", "office", "enemy", "force", "database"], "is": ["ls", "ins", "gets", "isi", "isl", "ps", "ori", "lis", "info", "mis", "obs", "io", "nis", "ics", "iso", "oss", "in", "es", "bis", "bos", "IS", "us", "ists", "oses", "ens", "s", "iris", "ws", "ios", "i", "im", "ip", "ses", "iss", "ais", "ris", "has", "Is", "ops", "ai", "ui", "as", "or", "isa", "cs", "abs", "opens", "ois", "bs", "was", "its"], "os": ["ros", "oa", "dos", "nos", "ss", "acs", "ps", "io", "ori", "obs", "ies", "osi", "oss", "cos", "aos", "pos", "ose", "es", "ows", "o", "bos", "vs", "us", "oses", "ips", "fs", "s", "ols", "ens", "ues", "ios", "i", "Os", "oos", "oes", "outs", "los", "ais", "ops", "as", "or", "cs", "bs", "its", "boot", "ks", "OS", "ds"], "done": ["loaded", "after", "enabled", "running", "odo", "one", "complete", "ready", "got", "nice", "none", "started", "die", "empty", "data", "later", "last", "part", "gone", "once", "progress", "finished", "future", "made", " finished", " Done", "foo", "checked", "Done", "de", "doing", "due", "disabled", "confirmed", "defined", "next", "expected", "current", "always", "did", "yes", "dirty", "dad"]}}
{"id1": "10690321", "id2": "17947246", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"readData": ["initDATA", "parseDATA", "readText", "readdata", "processdata", "initdata", "processDATA", "initData", "parsedata", "initText", "readDATA", "processData", "parseText", "processText", "parseData"], "sTok": ["suSk", "awsDoc", " sMsg", "syncVo", " sBuff", "hsIter", "sPos", "awsLoc", "siteTag", "nChat", "dTok", "tIter", "sisIter", "sslTu", "fsDec", "testsTu", "sDec", "sportsPos", " sDec", "sToken", " sSel", "sportsPop", "testsKo", "yourMsg", "siteTok", "yourLoc", " sPop", "hsSk", "servicesIter", " sAk", "sesUk", "awsEnc", "nBu", "sslTok", "hsVo", "suVo", "nLex", "dsIter", "awsIter", "singleMsg", " sToken", "gsTok", "sTu", " sSk", "sslVo", "sEnc", "newUt", "seTok", "singleTok", "SBuff", "sDoc", " sOtt", "submitLex", "sBot", "sChan", "gsSk", "dsAk", "synIter", "submitBu", "tDoc", "nOp", " sUk", "pLoc", "SIter", "sOp", "pIter", "sesIter", "sBuff", "sesAk", "sChat", "dIter", "sKe", "hsTok", "sMsg", "sisVal", "dToken", "sEh", "sportsKe", "pTok", "sportsEh", " sTag", "tTok", "sportsTok", "servicesLex", " sKe", "synOtt", "SOrg", "lsKe", "sSel", "dsTu", "newTok", "nIter", "yourChat", "sBuild", " sChat", "syncIter", "sLex", " sVo", "nUt", "sUt", "sOk", "pToken", "lsBuild", " sPos", "newBot", "sPop", "sLoc", "sIter", "fsLex", "sOrg", "testsIter", " sLoc", "awsRec", "siteLoc", "seSel", "seBuff", "dsUk", "sisChan", "opensTok", "opensPop", "yourTok", "nMsg", "nTok", "dsTok", "STok", "tLoc", " sTu", "synTok", "dsVal", " sEnc", "sIv", "newKe", "lsTok", "opensPos", "servicesTok", "syncTu", "submitMsg", "sVo", "fsSk", "obsKe", " sIter", "sisOtt", "syncTok", " sOp", "SOk", " sKo", "servicesKo", "dsLoc", "sBu", "sisTok", " sChan", "sSk", "sportsBuild", "seToken", "dLoc", "sCorp", "dsOtt", "dsVo", "sOtt", "SSel", "sUk", "sisBuff", "submitTok", "sesTok", "servicesTu", " sVal", " sOrg", " sLex", "suIter", "sRec", "servicesIv", "siteOtt", "synVal", "obsTok", "SToken", "testsTok", "sVal", "fsTok", "gsLex", "suTok", " sIv", "singleSk", "opensEh", "sAk", " sBot", " sUt", " sDoc", "sisTu", " sBu", "singleCorp", " sCorp", " sOk", "awsTok", "gsDec", "sKo", "sTag", "obsBuild", " sEh", "siteIter", "sslIter", " sRec", "nLoc"], "topSet": ["TopChan", "TopHat", "topHat", " topAdd", "pperSet", "TOPAdd", " topUnit", "TopMap", "pperChan", "TopAdd", "TOPSet", "topChan", "pperHat", " topMap", "topUnit", "pperMap", "TopUnit", "topMap", " topHat", "TOPChan", " topChan", "TOPUnit", "TopSet", "topAdd"], "leftSet": [" leftUnit", "controlBlock", " leftBlock", "lawHat", " leftHat", "smallSet", " leftKit", "controlCollect", "leftUnit", "leftHat", "rightUnit", "lawSet", "leftKit", "smallKit", "lawCollect", "lawBlock", " leftCollect", "leftBlock", "controlHat", "smallUnit", "rightKit", "leftCollect", "controlSet"], "rightSet": ["RightUnit", " rightUnit", "rightsGet", " rightSource", " rightMap", "rightsList", "rightList", "rightsUnit", "RightList", " rightGet", "rightChain", "rightUnit", "rightSource", "RightSource", "rightGet", "rightMap", "RightMap", "RightChain", " rightList", "rightsSet", "rightsChain", "rightsSource", "RightSet", " rightChain", "rightsMap", "RightGet"], "farRightSet": [" farRightset", " farLeftSet", " farRightList", "farCorrectList", "farRightChan", "farrightSet", " farLeftUnit", " farRightChan", "farrightList", "farCorrectSet", "farRightset", "farLeftList", " farLeftList", "farRightUnit", "farCorrectChan", "farLeftSet", "farLeftChan", "farRightList", " farRightUnit", "farLeftset", "farLeftUnit", "farrightUnit", "farCorrectset"], "vowelSet": ["vowelList", "vowelMap", "voxelsList", "vowellList", "voulList", "vowellSet", "vowlSize", "vowlSet", "voxelSet", "vowelsMap", "vowlList", "vouelSet", "voxelsSet", "voxelsMap", "vowelsList", "voweleMap", "vowelSize", "voxelMap", "vowellSize", "voulSize", "voweleSet", "vouelSize", "vowelsSize", "voxelList", "vowellMap", "voulSet", "vowelsSet", "voweleList", "vouelList"], "ntk": ["ptK", "rtwork", "ontke", "ptp", "NTwork", "NTc", "ptsk", "ntke", "settk", "octk", "etk", "otku", "etK", "antp", "LTk", "ontp", "octg", "ontku", "ottwork", "ontok", "ontK", "rtk", "ntK", "notk", "antk", "untok", "ctK", "notks", "NTch", "antr", "notK", "antwork", "montsk", "gtke", "ottok", "netK", "gtok", "ntku", "ntak", "ontg", "antkg", "ctke", "NTk", "antok", "ptks", "octsk", "NTuk", "ntsk", "ntr", "ontr", "NTok", "ntkg", "notsk", "antc", "LTuk", "ontak", "settsk", "settg", "antK", "ontch", "NTek", "antik", "untwork", "ctsk", "NTK", "ctk", "otk", "gtsk", "etok", "gtK", "ottak", "etwork", "montke", "ntik", "ontks", "netok", "ontkg", "ontk", "antku", "ntuk", "octke", "ntwork", "ntek", "otp", "ntg", "ptik", "rtok", "untk", "montK", "ntch", "ntc", "LTek", "LTok", "ptr", "ptk", "settke", "ottk", "rtK", "netc", "montk", "ontik", "ntp", "ntks", "ontc", "ontwork", "ntok", "netk", "untch", "ontsk", "NTak", "gtk", "otkg", "gtc"], "maxEwtsVowelLength": ["maxEwtsVowelsLen", "maxEwtsVowelingNumber", "maxEwtsVowelingLength", "maxEwtsVoyellId", "maxEwtsVowetLen", "maxEwtsVowselText", "maxEwtsVowselLength", "maxEwtsVowetText", "maxEwtsVoyelType", "maxEwtsVowellLength", "maxEwtsVowsetNumber", "maxEwtsVowilLength", "maxEwtsVowetNumber", "maxEwtsVoyellType", "maxEwtsVowelNumber", "maxEwtsVowetLength", "maxEwtsVowilType", "maxEwtsVowellType", "maxEwtsVowellLen", "maxEwtsVowellNumber", "maxEwtsVowselLen", "maxEwtsVowelType", "maxEwtsVoyellLength", "maxEwtsVowelsLength", "maxEwtsVowelId", "maxEwtsVowsetText", "maxEwtsVowelsId", "maxEwtsVowellId", "maxEwtsVowelText", "maxEwtsVoyelLength", "maxEwtsVowelsType", "maxEwtsVoyelLen", "maxEwtsVoyelId", "maxEwtsVowelLen", "maxEwtsVowsetLen", "maxEwtsVowselNumber", "maxEwtsVoyellLen", "maxEwtsVowilLen", "maxEwtsVowilId", "maxEwtsVowelingText", "maxEwtsVowelingLen", "maxEwtsVowellText", "maxEwtsVowsetLength"], "puncSet": ["pocList", "PuncSet", "pucGet", "puncset", "pascalNum", "pummset", "puncList", "puccGet", " puncset", "puncGet", " puncGet", "pocSet", "puncNum", "pocNum", "pucset", "pucSet", "PucList", "PucSet", "puccset", "pucList", "pummSet", "pascalSet", "pummGet", " puccSet", "PuncList", "pascalList", " puccGet", "PucNum", "puccSet", "pucNum", " puccset", "PuncNum"], "charSet": ["inchMap", "characterLet", "characterMap", "characterList", "CharSet", "charBlock", "inchLet", " charList", "characterSet", "inchSet", "CharBlock", "charList", "characterBlock", "charLet", " charBlock", "CharList", " charLet", " charMap", "charMap"], "tibSet": ["tivet", "tibet", "tilibEn", "Tibiset", "TibArray", "tibiset", "tikSet", "Tibet", "tilibSet", "Tobet", "tbiet", "tikArray", "tibiSet", "TibiSet", "Tibiet", "tibset", "TibSet", "Tibset", "tibEn", "tobEn", "TobEn", "tilibet", "TibEn", "tobSet", "tobet", "TibiArray", "tivSet", "tikset", "tbiSet", "tbiset", "tibiet", "tibiArray", "tbiArray", "tiket", "tivEn", "tibArray", "TobSet"], "sanskritStackSet": ["sanskritRootSet", "sanskriticalRootset", "sanskriticalRootSet", "sanskritHashSet", "sanskritContextMap", "sanskritContextSet", "sanskritHashMap", "sanskritStackMap", "sanskritRootset", "sanskriticalRootMap", "sanskritRootMap", "sanskriticalStackSet", "sanskritHashset", "sanskritContextset", "sanskritStackset", "sanskriticalStackMap", "sanskriticalStackset"]}}
{"id1": "23273706", "id2": "536614", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectPageMeta", "getProjectPageDATA", "getProjecttreeMeta", "getProjectTreeInfo", "getProjecttreeInfo", "getprojecttreeMeta", "getProjectPageData", "getProjectDocumentDATA", "getprojectTreeDATA", "getProjectDocumentMeta", "getProjectDocumentInfo", "getProjectTreeMeta", "getProjecttreeData", "getProjectDocumentData", "getProjecttreeDATA", "getprojecttreeDATA", "getprojectTreeInfo", "getProjectTreeDATA", "getprojecttreeInfo", "getprojectTreeData", "getProjectPageInfo", "getprojectTreeMeta", "getprojecttreeData"], "treeData": [" treeDec", " treeDat", "bodyData", "reeArray", "bodyDat", " treeInfo", "treeText", "reeInfo", "treeInfo", "TreeList", "bodyString", "monkeyDat", "bodyList", "contentDat", "treeString", "TreeData", " treeString", "reeData", "contentInfo", "reeText", "storyDec", "storyDat", "reeList", "reeString", " treeList", "treeList", "reeDat", "storyArray", "monkeyDec", "TreeString", "TreeArray", "monkeyArray", "monkeyData", "storyData", " treeText", "contentData", "treeDec", " treeArray", "treeArray", "TreeInfo", "contentText", "treeDat"], "filename": ["fd", "SourceFile", "prefix", "fn", "ppa", "jpg", "url", "uri", "FILE", "txt", "sheet", "data", "username", "kj", "journal", "title", "folder", "figure", "password", "nil", "kn", "framework", "xml", "dll", "metadata", "directory", "tmp", "fil", "files", "wav", "Filename", "kl", "string", "file", "upload", "name", "dylib", "location", "path", "ername", "whatever", "fp", "database"], "urlString": ["urlStr", "URLURL", " urlstring", "urlUrl", "locationUrl", " urlUrl", "addressURL", "URLStr", "URLString", "locationStr", "urlstring", "locationString", "addressStr", "addressString", " urlURL", "locationstring", "addressstring", "URLstring", "URLUrl", " urlStr", "urlURL"], "urldata": ["urlfata", "urLDdata", "urlfat", "urLDta", " urlddata", "urlddata", "URldata", "urlleddata", "urledATA", "urlledta", "urLDat", "urldat", "urleddata", "URlfata", "URldat", "urledta", " urLDdata", "urlfATA", "urlledata", " urLDta", "urldta", "URlddata", "URlfdata", "urlldata", "urlledATA", "urllATA", "urlfdata", " urldta", " urLDATA", "urLData", "urllat", " urldATA", "urldATA", "urledata", " urLData", "URldATA", "urllata", "urLDATA", "URlfATA", "URlfat"], "factory": ["fFactory", "cflier", "lactory", "conflier", "confiller", "filler", "luild", "lictionary", "confFactory", " filler", " flier", "cFactory", "pFactory", "cactory", "pault", "cfFactory", " fuild", "pactory", "cault", "confactory", "piller", "fuild", "liller", " fault", " fFactory", "ciller", "fault", "cfactory", "flier", "ufictionary", " fictionary", "ufuild", "ufactory", "cfiller", "fictionary", "ufiller"], "parser": ["writer", "lp", "uri", "se", "parent", "b", "manager", "ph", "monkey", "jack", "s", "xml", "instance", "builder", "plugin", "parse", "reader", "library", "driver", "raf", "api", "l", "er", "pdf", "ger", "util", "r", "string", "handler", "loader", "Parser", "up", "t", "fruit", "root", "auto", "json", "utils", "http", "p", "arser"], "u": ["ur", "nu", "uf", "url", "uri", "lu", "b", "ru", "uu", "ul", "io", "universal", "uv", "o", "su", "us", "d", "iu", "s", "uni", "cu", "l", "eu", " ur", "util", "c", "tu", "yu", "U", "ou", "hu", "plug", "ui", "http", "p"], "is": ["p", "gets", "uri", "isl", "lis", "obs", "io", "info", "mis", "ori", "init", "iso", "ie", "in", "it", "es", "bis", "IS", "us", "fs", "s", "iris", "ios", "api", "ar", "ip", "pi", "are", "ib", "iss", "ir", "ais", "ris", "has", "Is", "ob", "ops", "ai", "as", "ui", "or", "isa", "abs", "http", "serv", "ri", "isu", "its"], "os": ["ros", "oa", "dos", "gets", "fits", "obs", "io", "ps", "sys", "osi", "iso", "oss", "aos", "cos", "ose", "pos", "es", "bs", "so", "bis", "o", "bos", "us", "oses", "ms", "fs", "s", "ens", "ios", "Os", "oos", "oes", "ils", "los", "ob", "ops", "ol", "as", "or", "opens", "http", "OS"], "iBufSize": ["iBuffLength", "iBytebufLen", "iBlfLength", "iBlfSize", "iByteufSize", "iBytebufLength", "iByteufsize", "iBufSt", "iLufLength", "iLufSt", "iBufferLength", "iByteufLen", "iByteufLength", "iBytebufSize", "iBuffsize", "iBbufsize", "iBytebufsize", "iLlfSize", "iBuffersize", "iLlfsize", "iBufferSt", "iLlfSt", "iBbufLength", "iBuffSize", "iBbufLen", "iBlfsize", "iBlfSt", "iBbufSize", "iBlfLen", "iBufLen", "iBuffLen", "iBuffSt", "iLufSize", "iLlfLength", "iBufLength", "iLufsize", "iBufferSize", "iBufsize"], "inBuf": ["inBunk", "inBlunk", "inDuff", "inDbuf", "inBaf", "inDaf", "outBbuf", "inBuff", "outBuffbuf", "inBlub", "outBuffub", "inFuff", "inBuffump", "inBump", " inBump", " inBuff", " inFbuf", "outBub", "inFbuf", "inbuf", "inCuff", "outBuf", "outBuffump", "inbub", "inBuffuf", "inPluf", " inCump", " inFaf", " inCunk", " inCbuf", " inFuff", " inCuf", "inbump", "inFuf", " inBbuf", "inBlbuf", "inCaf", "inBuffbuf", "inBbuf", "inBluf", " inFuf", "inBuffub", "inFaf", "inPlump", "inCuf", "outBump", " inBunk", "outBuffuf", "inBub", "inCump", "inDuf", "inBlump", "inPlunk", "inPlbuf", "inCbuf", "inbbuf", "inCunk", " inBaf"], "iNumRead": ["iNumberWritten", "qiNumBuild", "qiValread", "iChanRead", "iValBuild", "iNumread", "pNumWritten", "pNumWrite", "qiValBuild", "inumWritten", "iChanread", "iNumberREAD", "iChanBuild", "iValREAD", " iNumWrite", "iNumberread", " iFatWrite", "iChanREAD", "iValRead", "qiNumread", "qiValREAD", " iFatWritten", "iNumWrite", "inumread", "iNumberWrite", "iLenRead", "inumWrite", "pNumberread", "iNumREAD", "iFatRead", "iNumberRead", "iValread", " iNumWritten", "iNumBuild", "pNumRead", "inumRead", "qiValRead", "iFatWritten", "qiNumREAD", "pNumberWrite", "iNumWritten", "pNumberRead", "iFatWrite", "pNumread", "iLenWritten", " iFatRead", "iLenWrite", "qiNumRead", "iNumberBuild", "pNumberWritten"], "f": ["fd", "m", "fn", "uf", "fr", "e", "j", "sf", "b", "g", "n", "fi", "io", "fa", "o", "d", "feed", "h", "fs", "s", "rf", "l", "ff", "r", "v", "handler", "c", "file", "fc", "t", "full", "F", "fe", "fp", "p", "df"], "inputstream": ["Inputsw", "outputStream", "contentStream", "outputstream", "inputsw", " inputchannel", "contentsystem", "contentstream", "inputchannel", "Inputchannel", "Inputstream", "inputStream", "contentsw", " inputStream", "inputsystem", " inputsw", " inputsystem", "Inputsystem", "InputStream", "outputchannel"], "document": ["m", "page", "doc", "e", "html", "null", "parent", "n", "DOM", "info", "data", "project", "output", "d", "container", "docs", " documents", "xml", "source", "Document", "record", "directory", "media", "l", "tree", "Documents", "node", "object", " documentation", "language", "file", "window", "list", "t", "ocument", "context", "response", "content", "office", "dom", "collection", "director", "p"], "nodelist": ["nozesh", "Nodesh", "anodedelist", "nodsette", "nozename", "nondestate", "nodedette", "nodata", "nonedels", "nodedeme", "nodedemark", "nODlist", "nodedeline", "anodedata", " nodesette", "nonedelist", "nodette", "nodselist", "nonedename", "nondata", "nODestyle", "nodedata", "nozette", "Nodestyle", "nodeestate", "nodeelist", "nodesette", "snodseline", "nODette", "nodedelist", "Nodelist", "snodelist", "nodename", " nodesels", " nodename", "nodeme", "nodestyle", "nondeme", "snodlist", "nodeline", "nodeselist", "NODemark", "nozemark", "snodette", "anodedestate", "nodeeme", "anodedeme", "nonedette", "nODeline", "nodedestyle", "nODesh", "nodedestate", "NODestyle", "NODelist", "nODemark", "snodsette", "nondelist", "nozels", "anodeme", "nodemark", "anodestate", "nodeata", "nodedlist", "Nodemark", "anodelist", "nodlist", " nodels", "nozestyle", "nozelist", "nODelist", "NODesh", " nodeselist", "snodeline", "nodedesh", "nodels", "nodseline", " nodesename", "nodesh", "nodestate", "anodata", "snodselist", "nodesename", " nodette", "nodslist", "snodslist", "nodesels"], "num": ["mon", "norm", "span", "m", "nu", "np", "uri", "unit", "col", "nom", "count", "n", "loc", "init", "nr", "ul", "en", "um", "inc", "part", "pos", "index", "NUM", "sum", "comb", "Num", "uni", "temp", "total", "multi", "max", "len", "tri", "number", "node", "div", "mult", "con", "lim", "dim", "net", "umi", "nam", "mu", "zero", "nb", "dom", "om"], "i": ["m", "uri", "col", "j", "isi", "g", "b", "fi", "ori", "io", "info", "si", "ie", "part", "in", "it", "iv", "o", "index", "d", "ci", "iu", "oi", "ji", "multi", "y", "li", "di", "cli", "mi", "ip", "pi", "hi", "xi", "eni", "l", "slice", "yi", "id", "a", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "phi", "ix", "chi", "ii", "ui", "qi", "mu", "ini", "bi", "x", "p", "ik"]}}
{"id1": "237493", "id2": "19134229", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["ur", "uri", "ssl", "resource", "ll", "server", "image", "fr", "null", "html", "connection", "loc", "io", "link", "f", "www", "URL", "ref", "href", "bel", "el", "xml", "source", "config", "rl", "filename", "l", "lr", "base", "id", "address", "string", "file", "name", "loader", "service", "ob", "sl", "host", "location", "Url", "path", "buffer", "http", "feed"], "in": ["m", "ex", "ins", "ssl", "resource", "image", "In", "n", "init", "io", "data", "this", "socket", "inc", "part", "f", "gin", "impl", "input", "din", "IN", "inn", "val", "out", "conn", "xml", "i", "is", "source", "rin", "reader", "config", "cms", "inside", "a", "nin", "login", "inner", "min", "r", "id", "token", "con", "file", "err", "c", "bin", "pin", "ini", "as", "or", "again", "serv", "isin"]}}
{"id1": "13596891", "id2": "21152728", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 0, "substitutes": {"doTransfer": ["handleSend", "handleImport", " doSend", "doSend", "handleTransfer", "handleRequest", "makeImport", "doRequest", " doImport", " doRequest", "makeRequest", "makeTransfer", "doImport", "makeSend"], "request": ["enter", "req", "subject", "resource", "message", "server", "report", "complete", "connection", "requ", "form", "remote", "event", "data", "version", "this", "session", "in", "application", "model", "result", "input", "Request", "type", "rf", "xml", "instance", "time", "QUEST", "create", "reader", "config", "client", "record", "stream", "command", "user", "queue", "object", "position", "re", "context", "query", "condition", "current", "q", "http", "post", "received", "com"], "response": ["warning", "resp", " Response", "page", "res", "writer", "respond", "default", "report", "resource", "server", "message", "image", "call", "view", "Response", "connection", "body", "en", "remote", "event", "version", "session", "output", "application", "status", "document", "result", "site", "model", "reply", "index", "error", "out", "results", "client", "header", "object", "cache", "success", "re", "service", "full", "next", "cover", "json", "content", "http", "serv", "onse"], "method": ["prefix", "METHOD", "text", "description", "direction", "subject", "resource", "message", "call", "cmd", "term", "reason", "version", "session", "verb", "status", "mode", "route", "sort", "Method", "date", "type", "process", "time", "class", "pull", "command", "sign", "send", "position", "string", "property", "path", "json", "content", "format", "head", "use", "callback", "hod"], "servletContext": ["ServletsController", "ServletContext", "servletscontext", "servletsContext", "servleContext", " servletConfig", " servantContext", "servLETProvider", "servletProvider", "servletCurrent", "ServletConfig", "servletConfig", " servantCurrent", "servleProvider", " servantProvider", "servletcontext", "servLETCurrent", "servantContext", "servletsController", "servleCurrent", " servantConfig", "servApplicationcontext", "Servletcontext", "servletsConfig", "servleConfig", "servletController", "servApplicationConfig", "servlexController", "ServletController", "ServletsContext", " servletProvider", "servApplicationController", "Servletscontext", "servantProvider", "servlexConfig", "servlexContext", "ServletsConfig", " servletCurrent", "servLETConfig", "servApplicationContext", "servlexcontext", "servLETContext", "servantConfig", "servantCurrent"], "wac": ["wae", "wsAC", " Wae", "wAC", "wacs", " Wac", " wae", " WAC", " wAC", " Wacs", " wacs", "wsae", "wsacs", "wsac"], "szUrl": ["szeurl", "szenURL", "szeUrl", "asizFrame", " sizFolder", "aszURL", "szurl", "sziUrl", "sznURL", "aszUrl", "aszPath", "sziURL", "szenFolder", "asizPath", "szerFrame", "szeURL", "szerUr", "szPath", "szaUrl", "aszUr", " sizURL", "szenUrl", " szurl", "szerUrl", "asizurl", "sznUrl", "szFolder", "szerURL", "sizPath", "sizurl", "sziurl", " sizurl", "sizURL", "sznurl", "szeFrame", "sznPath", "szUr", "szURL", "sziUr", "sizUrl", "szeUr", "asizUr", "szFrame", "szenurl", "sizFolder", "sizUr", " szFolder", "sznUr", "szaUr", "asizUrl", " szURL", "sizFrame", "aszFrame", " sizUrl", "aszurl", "szaURL", "asizURL", "szaPath", "szeFolder"], "url": ["ur", "page", "log", "fl", "uri", "ssl", "resource", "ll", "server", "connection", "loc", "rel", "il", "ul", "org", "event", "lb", "socket", "cloud", "impl", "f", "www", "URL", "key", "el", "conn", "xml", "source", "config", "rl", "li", "client", "web", "l", "stream", "base", "user", "string", "gl", "file", "obj", "name", "re", "service", "sl", "host", "context", "location", "Url", " URL", "get", "buffer", "http"], "is": [" are", "uri", "rx", "isl", "isi", "rc", "os", "lis", "il", "io", "info", "iso", "oss", " bis", "it", " isn", "bis", "IS", "isc", "us", "ci", "ios", "i", "src", "cms", "im", "web", "ip", "ib", "ils", "iss", "isf", "ir", "ais", "ris", "has", "Is", "ai", "ii", "as", "x", "isa", "was", "bs", "serv", "ri", "isu"], "sout": ["Sout", "sOut", " souts", "SOut", " sOut", "sin", "souts", " sin", "Sdata", "Souts", "sdata", "Sin", "SOUT", " sOUT", " sdata", "sOUT"], "con": ["conv", "java", "un", "cn", "core", "const", "wan", "view", "CON", "single", "bc", "fa", "cl", "nc", "conn", "ver", "win", "l", "min", "internal", "xc", "cache", "pc", "exec", "wa", "net", "pre", "query", "non", "on", "ocon", "pen", "com", "m", "crit", "Internal", "server", "uc", "cp", "connection", "en", "rc", "remote", "event", "version", "inc", "func", "syn", "status", "coll", "type", "cc", "ctrl", "can", "c", "ctx", "cf", "lc", "ca", "close", "util", "gen", "ct", "general", "Common", "ran", "run", "cur", "don", "co", "web", "login", "user", "re", "pin", "common", "http", "san", "open", "cons", "subject", "ssl", "C", "conf", "Con", "cos", "ec", "Connection", "connect", "client", "fun", "fc", "get", "ren", "author", "fe"], "hNames": ["hrKeys", " hFiles", "HBlocks", "hostNs", "HFiles", "HNames", "hName", "HVs", "ihVs", " hBlocks", "hostNames", "HTypes", " hName", "hrFiles", "hostTypes", "ihNames", "hBlocks", "hKeys", "hNs", "hrName", "hVs", "hrNames", "hrNs", "ihBlocks", "ihName", "HName", "hostKeys", " hKeys", "hTypes", "hrTypes", " hNs", " hTypes", " hVs", "hFiles"], "txt": ["prot", "text", "ct", "rx", "wt", "xt", "struct", " text", "sv", "tin", "bt", "htm", "inet", "csv", "tx", "in", "phrase", "kt", "py", "ht", "zip", "str", "elt", "nt", "XT", "gt", "key", "nm", "cb", "utt", "vt", "wx", "section", "header", "rr", "fx", "TEXT", "et", "lv", "v", "gi", "qt", "obj", "gz", "name", "xxx", "t", "binary", "ctx", "value", "git", "jp", "q", "lt", "fp", "dt", "Text"], "inBody": ["inbody", "insBody", "InFile", " inReader", "InStream", " inStream", "INbody", "Inbody", "insFile", "inReader", "inStream", "INStream", "InBody", "INReader", "insStream", "inFile", " inFile", "InReader", "outStream", "insReader", "INBody", "INFile", " inbody", "outFile", "outBody", "outbody"], "bufCh": [" bufChar", "bufChar", "buffch", "queueCh", "queueCH", "ufCol", " bufCH", "bufCH", " bufC", "bufC", "buffCh", "bufCol", "bufferch", "buffCH", "ufChar", "bufch", "ufC", "buffC", " bufch", "bufferCH", "queuech", " bufCol", "bufferChar", "queueCol", "ufCH", "ufCh", "bufferCh", "ufch"], "r": ["k", "m", "rt", "p", "res", "u", "fr", "R", "e", " rg", "ru", "b", "g", "n", "nr", "rc", "rs", "rh", "ner", "reg", "range", "f", "result", "str", "d", "rb", "rg", "rf", "rw", "i", "pr", "reader", "rl", "ar", "er", "rr", "lr", "br", "v", "c", "err", "re", "rd", "sr", "w", "hr", "ror", "x", "q", "cr", "ri"], "outReq": ["outREq", "outSeque", "outRequest", " outRece", "outRreq", " outReh", "outRck", " outRq", "outDeque", " outRsque", "outREque", "outEreq", "outRece", "outSeck", " outRereq", "outREce", " outReque", " outRsce", " outEreq", " outReck", " outRque", " outRsh", "outRecq", " outRce", "outRecce", " outRsq", "outEck", " outEq", "outSequest", "outSece", "outRecreq", " outRquest", "outREh", "outReh", "outSeq", " outRequest", " outSeque", " outSeck", "outConque", "outRsce", "outEque", "outDece", "outRce", "outReck", "outRsq", "outREck", " outSeq", "outRsque", "outRquest", "outReque", "outDequest", "outRecque", "outConq", "outRq", "outEq", " outEque", "outConh", " outSece", "outConce", "outRque", "outRsh", "outRereq", "outDeq", " outEck", "outRecck"], "buff": ["buf", "uf", "p", "array", "b", "Info", "num", "info", "data", "Buffer", "f", "map", "ch", "lines", " chunk", "Buff", "Pad", " buffers", "Msg", "file", " Buff", " Buffer", "buffer", "bb", "Ptr"]}}
{"id1": "160739", "id2": "20426057", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"createOutputStream": ["createOutputSteam", " createOutputSteam", " createInputSteam", " createIOSteam", " createByteFile", " createInputFile", "createOutputFile", "createInputReader", " createByteSteam", " createInputReader", " createByteStream", " createInputStream", "createInputFile", "createInputStream", " createIOFile", " createIOReader", " createByteReader", " createOutputFile", " createIOStream", "createOutputReader", " createOutputReader", "createInputSteam"], "inFile": ["incFiles", "infile", "insFile", "insfile", "inputFile", "inStream", "outFiles", "insFiles", "insStream", "incfile", "sourceFile", "outStream", "outfile", "sourcefile", "inputStream", "inputfile", "incStream", "incFile", "sourceFiles", "inputFiles", "inFiles", "sourceStream"], "outFile": [" outfile", "infile", "outTime", "workTime", "inputFile", "inTime", "workingStream", "workFile", "outDir", "targetStream", "workfile", "workingDirectory", "workingfile", "outStream", "outfile", "inDir", " outStream", "targetfile", "outDirectory", "targetFile", "workDir", "inputDir", "workingFile", "targetDirectory", "inputTime", "inputfile", " outDirectory"], "k_blockSize": ["k_byteCode", "k_byteLength", "k_lockCode", "k_lockLen", "k_bitCount", "k_BlockLength", "k_lockLength", "k_blockCode", "k_blockLen", "k_BlockSize", "k_BlockCount", "k_lineCount", "k_lockCount", "k_lineInfo", "k_lockSize", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_blockInfo", "k_lineSize", "k_blocksLength", "k_BlockCode", "k_byteLen", "k_byteSize", "k_blockCount", "k_blockLength", "k_byteInfo", "k_bitInfo", "k_byteCount", "k_bitSize"], "byteCount": ["ByteSum", " bytecount", "characterLength", " byteSize", "blockSize", " byteLen", "Bytecount", "characterLen", "ByteSize", "ByteLen", "flushcount", "flushCount", "byteSum", " byteSum", "ByteCount", "blockSum", "flushSize", "byteLen", "blockCount", "characterCount", "ByteLength", "flushLength", "byteLength", " byteLength", "blockLength", "bytecount", "characterSize", "byteSize"], "buf": ["fd", "border", "font", "cap", "cv", "uf", "append", "background", "b", "cmd", "loc", "rc", "fb", "data", "bh", "Buffer", "result", "bag", "rb", "batch", "feed", "bytes", "Buff", "cb", "cas", "alloc", "bf", "flush", "src", "config", "tmp", "buff", "len", "base", "queue", "la", "ucc", "vec", "brace", "ctx", "buffer", "exc", "seq", "feat", "img"], "ofp": ["Ofc", "afp", "OFl", "ofc", "fortp", "ofl", "forc", "afc", "fort", "ofnp", "afnp", "OFnp", "Oftp", "OFt", "Ofnp", "afl", "OFtp", "OFp", "OFc", "oft", "Ofl", "forp", "Ofp", "oftp", "Oft"], "zos": ["rons", "ogl", "kos", "core", "zh", "tz", "osi", "iframe", "owicz", "zag", "zers", "rez", "outs", "los", "gz", "zer", "bitcoin", "dylib", "webkit", "zon", "utils", "bs", "ros", "js", "z", "fits", "iffs", "obs", "ossus", "enos", "ozo", "zona", "zip", "bos", "zes", "oses", "zik", "lol", "bes", "zar", "zb", "ZI", "zx", "oda", "zy", "ops", "zi", "budget", "inos", "css", "ls", "zyk", "modules", "zo", "zen", "ses", "nox", "zig", "cfg", "ZA", "os", "jas", "uz", "zn", "nz", "cos", "robe", "liquid", "lins", "zin", "ws", "oS", "abi", "zl", "hz", "za", "forge", "packs", "obb", "soon"], "osw": ["ossnow", "isy", "osy", "esfw", "issw", "lsx", "eshell", "osws", "osow", "osswd", "oswd", "ishell", "lswo", " osfw", "iswd", "isw", "osshell", "osx", "lsws", "osnow", "osfw", "ossw", "isnow", "esw", " osww", "esd", "bx", "ossfw", "bws", "osww", "bwo", "ossd", "ossy", "oswo", "esow", " osow", "oshell", "isd", "bsws", "ossow", "osssw", "essw", "esww", "eswd", "esy", "osd", "bsx", "bsw", "bswo", "ossww", "esnow", "lsw"], "bw": ["bbz", "lbw", " bwa", "lx", "ebW", "fr", "fbW", "bz", "fsw", "lbz", "bwe", "ebwd", " bws", "bW", "ebw", "fbwe", "Bws", "bbwa", "Bw", "lbwa", "bew", "abw", "bbew", " baw", "abW", "Bwa", "bbwu", "lbsw", "ow", "fwa", "bwh", "fbw", "owa", " bwh", "abwe", "ebwe", "bx", "lbx", "bws", "fbwd", "Bew", "fx", " bew", "fw", "lbwh", "bwu", "owu", "fwh", "baw", "lwa", "bbws", "abwd", "bwa", "bbwh", "lbws", " bwu", "lw", "bwd", "bsw", "oaw", "lbr", "bbw", "bbaw", " bz", "lsw"], "zot": ["Zor", "zor", "jot", "Ziot", "zori", " zor", "azita", "azott", "zeros", "aziot", "ziot", "Zit", "jos", "jit", "zerott", "jori", "azor", "zerita", " zori", "zita", "zerori", "zott", "zerit", "Zita", "zerot", "azit", "Zot", "Zott", " ziot", "azot"], "ifp": ["Iff", "ifb", " ifi", "ipb", "IFb", "Ifi", " ifl", "ipp", "Ifc", " ifb", "ifl", "ipc", "ipl", "ifc", "ifi", "iff", "IFc", "IFl", " ifc", " iff", "IFi", "Ifp", "IFp", "IFf"], "zis": ["jits", "zisi", "jisi", "zIS", "zib", "xits", "zipis", "xais", "xit", " zits", "ziss", "xis", "zipits", "zenis", "zenib", "zeip", "zipip", "zipiss", "xisi", "zip", "Ziss", "zeits", "Zis", "jit", "xIS", "zeis", " zisi", "zits", "zenIS", "Zip", " zais", " zIS", "zais", "Zits", "zenais", " zib", "jis", "zeiss", "xib"], "isr": ["IScr", "irrb", "irrc", "irr", "ISr", "rispr", " issr", "ISsr", "risr", "ISrs", "risrc", "issrs", " isrs", "iscr", "ISrb", "risrb", "isrs", "irpr", " iscr", "ISrc", "isrb", "ISpr", "isssr", "isscr", "ispr", "issr", "isrc"], "br": ["kr", "obl", "bsp", "bro", "fr", "arr", "shr", "b", "body", "mr", "rs", "yr", "bh", "bp", "bc", "obi", "str", "HR", "cro", "rb", "ch", " BR", " Br", "BR", "rib", "lr", "ber", "bar", "tr", "r", "ctr", "div", "err", "ocr", " fr", " dr", "sr", "ibl", "gr", "ob", "sp", "hr", "bl", "Br", "ibr", "img", "browser"], "zit": ["jits", "zipita", "zIT", "zeith", "zenith", " zip", "xit", "zenitter", " zits", "zipits", "zitter", "jith", "jite", "xith", "jIT", "zipip", "zic", "zip", "xic", "zeits", " zi", "zipit", " zith", "jit", "zite", "jic", "zipith", "zenit", "zith", "ji", "zits", " zic", "zipite", "zeit", "zita", "zenits", "xi", "jita", " zite", "zipitter", "jip", "zi", "zeIT", "zipIT", "zeitter", "zeita"]}}
{"id1": "7846688", "id2": "22611968", "code1": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"postData": ["PostData", "PostBody", " PostText", " postText", "postText", " postBody", "postPart", "postBody", " PostPart", " postPart", " PostData", "PostPart", " PostBody", "PostText"], "protocol": ["scheo", "pathport", "interol", "theose", "hosturl", "Proto", "portec", "protec", "proec", "promport", "promocol", "proport", "hostort", "portotype", "pathol", "theocol", "proticle", "theport", "intericle", "scheocol", "cryptport", "Protol", "prototype", "protose", "scheotype", "prootype", "protport", "proto", "proturl", "iolort", "Protort", "porto", "cryptol", "Proturl", "iolport", "pathicle", "Protport", "interport", "interocol", "scheec", "hostocol", "protort", "protol", "Protocol", "cryptocol", "proocol", "theotype", "iolurl", "Proticle", "promo", "hostport", "Protose", "portocol", "pathocol", "Prototype", "promol", "proose", "proo", "iolocol", "crypto"], "host": ["proxy", "bind", "component", "arch", "auth", "subject", "uri", "localhost", "server", "parent", "view", "loc", "method", "project", "port", "part", "channel", "site", "controller", "h", "type", "container", "home", "key", "source", "add", "hop", "header", "work", "target", "ip", "base", "node", "mac", "object", "address", "string", "hard", "ac", "account", "name", "service", "Host", "root", "domain", "pattern", "path", "front", "hub", "format", "topic", "http", "feed", "database"], "form": ["filter", "forms", "text", "Form", "one", "parent", "view", "body", "term", "act", "off", "method", "session", "port", "raw", "channel", "field", "model", "f", "range", "zip", "input", "str", "template", "and", "test", "type", "key", "pass", "source", "action", "config", "with", "stream", "transform", "place", "object", "address", "string", "ac", "file", "FORM", "name", "pattern", "domain", "function", "path", "clean", "query", "format", "feed", "post"], "data": ["DATA", "text", "array", "uri", "message", "one", "append", "resource", "style", "view", "body", "info", "parts", "version", "raw", "part", "zip", "result", "input", "str", "valid", "dat", "batch", "missing", "key", "type", "xml", "source", "action", "multi", "config", "media", "what", "da", "cache", "change", "string", "patch", "file", "alpha", "name", "params", "json", "response", "picture", "query", "content", "value", "format", "update", "buffer", "database", "request", "post"], "url": ["ls", "ur", "proxy", "log", "fl", "uri", "ssl", "resource", "server", "b", "connection", "this", "session", "channel", "f", "impl", "connect", "www", "URL", "conn", "api", "client", "web", "l", "base", "cache", "file", "c", "fc", "sl", "Url", "http", "open", "com"], "con": ["conv", "cons", "un", "log", "cn", "core", "uc", "conf", "cp", "connection", "en", "rc", "Con", "CON", "sync", "on", "socket", "inc", "bc", "channel", "Connection", "part", "f", "cos", "connect", "fa", "ran", "coll", "cl", "run", "cur", "conn", "Conn", "ver", "cm", "open", "win", "client", "co", "sub", "login", "can", "r", "xc", "cache", "pc", "c", "exec", "re", "fc", "per", "pre", "ca", "close", "enc", "http", "cr", "ocon", "pen", "com"], "out": ["ex", "log", "writer", "plain", "b", "conf", "n", "io", "outer", "child", "sync", "inc", "socket", "raw", "output", "f", "gin", "o", "sum", "ch", "Out", "key", "conn", "pass", "temp", "co", "web", "sub", "outs", "user", "r", "cache", "ac", "err", "bin", "file", "obj", "up", "w", "net", "OUT", "plus", "again", "line", "p"], "in": ["rec", "ex", "ins", "fin", "rx", "In", "b", "init", "inc", "socket", "f", "impl", "input", "vin", "din", "IN", "lin", "inn", "read", "s", "conn", "cin", "i", "is", "win", "kin", "reader", "rin", "inside", "nin", "stream", "l", "sub", "login", "inner", "min", "r", "id", "bin", "c", "err", "inter", "pin", "ini", "again", "line", "isin"]}}
{"id1": "9413074", "id2": "13362846", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getLocation": ["getFile", "newURL", "setLocation", "GetFile", "GetAddress", " getAddress", "findLoc", "newLoc", "getURL", "findURL", "getLoc", "findFile", "GetPath", "setURL", "GetLoc", "newFile", "getPath", "setPath", " getURL", "newLocation", "GetLocation", "setAddress", "GetURL", "findLocation", "getAddress", " getPath"], "clazz": ["Clazz", "cluster", "Cllass", " cluster", "CLuster", "CLazz", "cllass", "Clclass", " clclass", "Cluster", "CLclass", " cllass", "clclass", "CLlass"], "url": ["ll", "image", "html", "null", "org", "entry", "cl", "class", "l", "string", "gl", "context", "browser", "page", "text", "uri", "resource", "server", "connection", "rel", "link", "zip", "URL", "Location", "coll", "code", "i", "config", "lr", "object", "local", "email", "loader", "layer", "path", "feed", "log", "loc", "channel", "impl", "site", "route", "pull", "api", "web", "user", "ob", "sl", "Url", "buffer", "http", "bb", "ssl", "b", "mount", "f", "ref", "href", "jar", "source", "client", "base", "position", "address", "language", "name", "service", "host", "bug", "or"], "location": ["warning", "description", "uri", "resource", "message", "image", "length", "style", "connection", "loc", "data", "via", "result", "site", "area", "route", "Location", "URL", "storage", "translation", "error", "home", "instance", "source", "library", "directory", "filename", "l", "feature", "position", "local", "address", "language", "string", "layout", "property", "region", "layer", "response", "path", "function", "lc", "content", "operation", "where"], "file": ["page", "pe", "log", "FILE", "uri", "resource", "ile", "image", "able", "remote", "il", "io", "child", "folder", "entry", "f", "it", "key", "el", "source", "class", "dir", "filename", "l", "files", "base", "object", "cache", "name", "entity", "per", "File", "full", "get", "path", "fe", "line", "fp", "lib"]}}
{"id1": "14783950", "id2": "5035872", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressUsingJar", "compressUsingZip", "compressInZip", "compresswithZip", "compresswithSax", "compressedWithJar", "compressInSax", "compressedWithZip", "compressWithJar", "compressUsingSax", "compresswithJar", "compressInJar", "compressedWithSax", "compressedUsingJar", "compressedUsingZip", "compressedUsingSax", "compressWithSax"], "fileList": [" fileChain", "wordString", "FileStream", "zipSet", "FileString", "fileStream", "modelCollection", "wordName", "inputEx", "modelEx", "fileCollection", "FileSet", "fileString", "modelList", "wordStream", "modelStream", "FileList", "inputCollection", "fileEx", "FileChain", "filelist", " fileSet", "zipList", "inputList", "inputStream", "wordList", "ziplist", "fileChain", "stringName", " fileEx", "stringlist", " fileStream", "Filelist", " fileCollection", " fileString", "FileName", "stringList", "stringChain", "zipName", "fileSet", " filelist"], "zipFileName": ["folderGlobalPath", "archiveDirDir", "zipFullname", "zipDirname", "zipFileDir", "archiveDirPath", "zipGlobalNames", "zipFullPath", "folderGlobalname", "zipFilename", "archiveFileName", "archiveFilePath", "zipDirDir", "zipPackagePath", "zipFullName", "zipFileNames", "archiveDirName", "folderFileNames", "zipGlobalPath", "folderFileName", "zipFullDir", "zipPackageName", "zipPackageDir", "folderGlobalName", "zipDirNames", "zipDirName", "archiveFileDir", "zipFullNames", "zipGlobalName", "zipDirPath", "zipFilePath", "folderFilename", "folderFilePath", "zipGlobalname", "folderGlobalNames"], "fos": ["Fosh", "infoS", "Fos", "flos", "faos", "infos", "fosh", "infaos", "afoS", "foS", "flis", "Faos", "FoS", " fosh", "afaos", "infis", "flosh", "afis", "afos", "Fis"], "zos": ["css", "zz", "ros", "dos", "closure", "z", "fits", "kos", "tz", "fi", "ZA", "os", "jas", "jobs", "ozo", "osi", "uz", "iframe", "nz", "cos", "loop", "zip", "es", "bis", "bos", "lins", "bag", "chini", "zes", "oses", "zzy", "seconds", "abi", "zik", "lol", "bes", "zar", "zag", "zo", "zers", "zen", "LOS", "outs", "zl", "rez", "ses", "onz", "zb", "ZI", "packs", "gz", "zx", "zer", "zy", "webkit", "obb", "zi", "phi", "zon", "zan", "spin", "budget", "inos"], "iter": ["enter", "inse", "fr", "e", "itter", "ser", "loc", "outer", "oper", "ner", "inc", "ie", "it", "f", "set", "index", "upper", "finder", "sort", "coll", "end", "test", "ener", "el", "gener", "i", "is", "parse", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "slice", "ir", "file", "err", "fer", "list", "Iter", "inter", "ator", "izer", "next", "ite", "order", "cher", "liter", "iner", "chain", "iterator", "iz", "http"], "fileName": ["filenamename", "pageString", "FileString", " filePart", "FileUrl", "fName", "filePath", " filePath", "localname", "fileOpen", "filenameName", "currentname", "fileData", " fileLine", " fileType", " fileData", "FileFull", "fullOpen", "fileString", " fileFull", "fileType", "FilePart", "simplePath", "filenameInfo", "fileUrl", "currentData", "pageType", "currentName", " fileUrl", "FileLine", "pagename", "localPart", "fileInfo", "filename", "localName", "currentUrl", "simpleOpen", " fileInfo", "Filename", "FileInfo", "FilePath", " filename", "fPart", "fileFull", " fileString", "FileName", "fullPath", "localPath", "filePart", "FileData", "fullName", "fLine", "pageName", "FileType", " fileOpen", "fileLine", "simpleName", "filenameFull", "fname"], "ind": ["bind", "fr", "z", "vert", "nd", "j", "length", "count", "loc", "mid", "ded", "inc", "pos", "in", "cond", "pt", "index", "inn", "d", "ci", "val", "end", "eff", "i", "pull", "dir", "rib", "len", "ad", "id", "div", "ord", "IND", "start", "ld", "ix", "mind", "ii", "x", "Ind", "wind", "pend"], "shortName": ["Shortname", "ShortPath", " shortString", "longName", "smallname", "shortPart", "ShortString", "shortname", "ShortPart", "smallPart", "shortPath", "shortString", "ShortName", "longPart", "shortLine", "smallPath", "fullname", " shortPath", "longLine", "fullString", " shortname", "smallName", "longPath", "longname", "fullPath", "fullName", "fullLine", " shortLine"], "fis": [" fiss", "pisa", "fisa", "Fos", "fris", "cfis", "Fiss", "gisa", " fris", "cfs", " fisa", "gis", "fs", "pis", "fios", "Fs", "gios", "pris", "fiss", "pios", "cfiss", "gris", "afiss", "cfris", "cfos", " fs", "afris", "afis", " fios", "afos", "Fis"], "buf": ["fd", "cv", "uf", "bu", "uc", "b", "loc", "rc", "fb", "data", "bh", "bp", "lb", "feat", "bc", "pb", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cur", "bf", "bd", "grab", "tmp", "buff", "ff", "queue", "ba", "br", "v", "lim", "bin", "la", "vec", "wb", "bl", "buffer", "seq", "box", "bb"], "bytesRead": [" bytesLength", "flowsWrite", "tesRead", "flowsRead", "bitsSkip", " bytesWrite", "bitsLength", "bitsRead", " bytesNeed", " bytesLoad", "bytesNeed", "bitsWrite", "tesWrite", "tesSkip", "bitsUse", "secondsRead", "wordsWrite", "bytesUse", "wordsUse", "bitsLoad", "secondsWrite", "bytesSkip", "tesLoad", "wordsRead", "bytesLoad", "bytesLength", "secondsLength", "bytesWrite", "flowsNeed", "secondsNeed", "flowsLength", " bytesUse", "wordsLength", " bytesSkip"]}}
{"id1": "10218878", "id2": "12242903", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 0, "substitutes": {"DecodeMapFile": ["DecoderMapFile", "DecodeDataFile", "DecodeMapFiles", "DecodemapFiles", "DecoderFileFiles", "DecoderMapfile", "DecodeDataFiles", "DecoderMapFiles", "DecodemapFile", "DecodeFileFile", "DecodeDatafile", "DecodeFileFiles", "Decodemapfile", "DecoderFileFile", "DecodeMapfile", "DecodeFilefile", "DecoderFilefile"], "mapFile": ["mapLog", "apperUrl", "fileTable", "addressfile", "MapFile", "mapFull", "apperFile", "loadFull", "mapUrl", "mapfile", "batchUrl", "mapTable", "addressTable", "MapUrl", "addressFull", "loadfile", "loadFile", "fileFile", "apperLog", "MapLog", "batchLog", "fileFull", "filefile", "batchFile", "loadTable", "addressFile"], "outputFile": ["outputFiles", "outputStream", "inputFolder", " outputFolder", "inputFile", "responseFile", "OutputFolder", "responseStream", " outputfile", "inputDir", "OutputStream", " outputFiles", "OutputFiles", "OutputDir", "outputDir", "outputFolder", " outputStream", "responseFiles", "responsefile", "OutputFile", "inputFiles", " outputDir", "Outputfile", "outputfile"], "magicKey": ["prefixKey", "specialKey", "techLink", " magickey", "magicK", " magicChar", "prefixKEY", "techKey", "techKEY", "magicSecret", "techkey", "cacheSecret", " specialLetter", "cachekey", " magicKEY", " specialKey", " specialkey", "MagicKey", " magicK", "magickey", "prefixLink", "prefixkey", "magicLetter", "MagicK", "MagicLetter", "cacheKey", "specialChar", "magicKEY", "magicLink", " magicLink", "magicChar", "cacheChar", "specialkey", " magicLetter", "Magickey", " magicSecret", " specialK", "specialSecret"], "buffer": ["wave", "buf", "pad", "array", "writer", "url", "message", "length", "count", "b", "offset", "null", "data", "Buffer", "shape", "document", "result", "input", "stack", "batch", "read", "row", "code", "source", "iter", "memory", "reader", "comment", "header", "buff", "seed", "base", "bar", "queue", "position", "variable", "slice", "cache", "address", "token", "binary", "reference", "pause", "layer", "uffer", "FFER", "transfer", "feed", "bb"], "nread": ["Nread", "enfind", "newrite", "pload", "neread", "nload", "enreads", "Nreader", "nRead", "nreader", "Nwrite", "Nfind", " nRead", "enwrite", "nereader", " nload", "NRead", "nfind", "Nload", "pwrite", "nwrite", "enRead", " nwrite", " nfind", "pRead", "enread", "Nreads", "neRead", " nreads", " nreader", "pread", "nreads"], "map": ["wave", "m", "maps", "pad", "pack", "flow", "module", "image", "one", "resource", "copy", "master", "write", "message", "core", "lock", "data", "group", "input", "index", "key", "out", "code", "apper", "source", "cm", "create", "parse", "config", "media", "client", "work", "stream", "pair", "header", "make", "over", "cache", "address", "ap", "MAP", "file", "app", "list", "per", "pre", "cover", "pool", "layer", "transfer", "bridge", "use", "block", "open"], "output": ["page", "exit", "console", "log", "unit", "write", "module", "resource", "image", "core", "flow", "connection", "outer", "data", "oper", "cut", "external", "application", "model", "document", "input", "o", "run", "sort", "error", "out", "pot", "Output", "config", "web", "target", "number", "queue", "control", "object", "cache", "address", "file", "ilo", "other", "reference", "ou", "global", "function", "layer", "response", "operation", "put", "office", "update", "utils", "export"], "i": ["m", "p", "u", "z", "uri", "e", "j", "length", "b", "io", "info", "si", "in", "f", "it", "o", "ci", "oi", "ji", "multi", "li", "di", "l", "a", "ip", "pi", "xi", "slice", "id", "uli", "ti", "v", "gi", "c", "t", "I", "ai", "phi", "zi", "ini", "ii", "ui", "x", "qi", "bi", "mu", "ri"]}}
{"id1": "21491791", "id2": "23452437", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"run": ["spawn", "running", "log", "unit", "call", "apply", "build", "Run", "func", "loop", "all", "job", "test", "code", "process", "create", "work", "worker", "command", "fork", "exec", "start", "app", "runner", "invoke", "execute"], "input": ["text", "flow", "resource", "image", "view", "connection", "form", "io", "data", "parser", "reading", "raw", "in", "entry", "audio", "storage", "index", "read", "out", "conn", "instance", "source", "driver", "config", "client", "stream", "work", "worker", "inner", "user", "Input", "internal", "control", "address", "file", "initial", "loader", "up", "context", "state", "iterator", "active", "feed", "request", "readable"], "output": ["page", "text", "exit", "log", "console", "unit", "write", "resource", "image", "parent", "connection", "letter", "outer", "data", "later", "writing", "written", "application", "document", "generated", "index", "Writer", "job", "end", "out", "temp", "source", "Output", "config", "network", "filename", "web", "target", "user", "queue", "control", "object", "cache", "file", "writers", "path", "response", "environment", "operation", "put", "office"], "reader": ["book", "request", "peer", "resource", "image", "server", "rer", "view", "system", "io", "parser", "ner", "reading", "in", "entry", "audio", "Reader", "read", "row", "rator", "builder", "source", "driver", "client", "riter", "stream", "er", "worker", "slave", "inner", "r", "handler", "loader", "context", "wrapper", "author", "oder", "manager", "ri", "owner"], "writer": ["wr", "write", "wan", "connection", "outer", "data", "writing", "engine", "ner", "written", "writ", "entry", "creator", "her", "editor", "Writer", "ew", "out", "wer", "player", "maker", "ws", "rw", "builder", "nw", "driver", "war", "riter", "work", "er", "worker", "ter", "inner", "r", "wa", "wire", "w", "wb", "writers", "wrapper", "or", "word", "office", "author", "manager", "request"], "pump": ["camp", "ppumping", "pumping", "pamp", "prump", "Pmp", "mprint", "dumps", "pdump", " pmp", "Pam", "ppumper", "cump", "ppumps", "Pdump", "humper", "cumper", "mumper", "pumps", "Pumper", " pdump", "Pump", " pumper", "pam", "pumper", "pmp", "Pumping", "prumper", "pprint", "Pprint", "humps", " pumping", "dmp", "mump", "hump", "dump", "Pamp", "pram", "Pumps", " pumps", "dumper", " pam", "hprint", " pamp", "prdump", "ppump", "mumps", "cumping"], "counter": ["enter", "page", "Counter", "url", "server", "clock", "const", "master", "count", "parent", "offset", "num", "race", "outer", "version", "step", "ner", "hello", "sequence", "cookie", "loop", "entry", "now", "result", "meter", "timer", "second", "index", "ener", "row", "code", "ver", "instance", "progress", "consumer", "comment", "trace", "center", "rew", "builder", "keep", "ter", "er", "worker", "seed", "number", "ger", "walker", "lr", "r", "inner", "starter", "repeat", "loader", "continue", "inter", "order", "layer", "runner", "current", "currency", "pointer", "author", "zero", "collection", "keeper", "ception", "processor"], "buffer": ["buf", "page", "uf", "text", "url", "message", "resource", "server", "length", "data", "port", "Buffer", "channel", "limit", "entry", "document", "batch", "source", "iter", "header", "buff", "base", "queue", "position", "address", "file", "loader", "reference", "binary", "layer", "uffer"], "off": ["own", "art", "oa", "Off", "flow", "offset", "OFF", "info", "pos", "offs", "now", "area", "fail", "o", "set", "ref", "end", "out", "Offset", "open", "addr", "ff", "of", "opt", "inner", "eno", "less", "low", "ord", "start", "left", "down", "unknown", "ui", "auto", "head", "on", "offer"], "len": ["fd", "lon", "gen", "log", "ln", "fl", "url", "lf", "fin", "ll", "length", "count", "n", "body", "loc", "en", "lock", "lan", "limit", "in", "pos", "all", "elt", "lin", "ref", "Len", "end", "val", "el", "size", "width", "li", "l", "lit", "lim", "den", "bin", "name", "ld", "layer", "ler", "lc", "lt", "line", "on", "lib"], "rd": ["fd", "rt", "red", "rand", "rm", "rss", "raid", "fr", " r", "xd", "nd", "rx", "rob", "ru", "dr", "RR", "nr", "rc", "rs", "rh", "dd", "d", "rb", "rn", "val", "rid", "RD", "rw", "rl", "rr", "db", "lr", "r", "ind", "adr", "ud", "ord", "dra", "rod", "ld", " prod", "hr", "ra", "cr", "rf", "ds"]}}
{"id1": "9954926", "id2": "9347451", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"simulate": ["animure", "imulate", "Simulator", "Simure", "animulation", "imulation", "animulate", "imure", "simulation", "Simulate", "simure", "imulator", "animulator", "simulator", "Simulation"], "out": ["ex", "writer", "flow", "report", "parent", "null", "view", "data", "part", "in", "exp", "o", "conn", "temp", "cli", "outs", "cache", "string", "err", "list", "net", "pre", "page", "resource", "server", "info", "group", "result", "error", "key", "dump", "point", "object", "con", "w", "down", "word", "post", "prefix", "gen", "log", "exit", "plain", "io", "outer", "sys", "store", "Out", "flush", "comment", "co", "db", "user", "bin", "obj", "up", "buffer", "again", "write", "copy", "lock", "session", "external", "raw", "output", "now", "client", "tmp", "base", "table", "window", "name", "full", "OUT", "pool", "state", "line", "lib"], "file": ["book", "page", "pe", "log", "FILE", "url", "report", "resource", "message", "le", "ile", "unit", "b", "connection", "data", "socket", "port", "output", "in", "f", "rule", "feed", "source", "filename", "stream", "l", "files", "base", "queue", "cache", "address", "handler", "name", "loader", "full", "File", "path", "buffer", "fe", "collection", "line", "fp"], "obtainUserReputationRequest": ["obtainUserAnnutationRequest", "obtainUserReputedGrant", "obtainUserRepositoryResponse", "obtainUserRepurationResponse", "obtainUserComputationInfo", "obtainUserAnnigrationQuery", "obtainUserReputableResponse", "obtainUserRelutationGrant", "obtainUserRepurationRequest", "obtainUserComputationEntry", "obtainUserRepulationInput", "obtainUserReputedResponse", "obtainUserReputionGrant", "obtainUserRelutationrequest", "obtainUserRepigrationInfo", "obtainUserRelentionrequest", "obtainUserRelutationResponse", "obtainUserReputedrequest", "obtainUserReputionrequest", "obtainUserReputationGrant", "obtainUserComputationInput", "obtainUserAnnutationGrant", "obtainUserRepigrationQuery", "obtainUserReputeResponse", "obtainUserReputableRequest", "obtainUserRelentionRequest", "obtainUserRepigrationRequest", "obtainUserRepulationResponse", "obtainUserRepentionGrant", "obtainUserReputationEntry", "obtainUserReputeEntry", "obtainUserReputedRequest", "obtainUserRepigrationGrant", "obtainUserComputationrequest", "obtainUserAnnigrationResponse", "obtainUserAnnigrationRequest", "obtainUserComputeResponse", "obtainUserRepentionRequest", "obtainUserComputeEntry", "obtainUserComputerequest", "obtainUserRepigrationResponse", "obtainUserRepositoryrequest", "obtainUserRepurityInput", "obtainUserComputeInfo", "obtainUserReputeGrant", "obtainUserComputationResponse", "obtainUserReputationQuery", "obtainUserAnnutationResponse", "obtainUserRepulationEntry", "obtainUserRelentionGrant", "obtainUserReputionResponse", "obtainUserRepositoryRequest", "obtainUserRepentionrequest", "obtainUserRelentionResponse", "obtainUserReputationInfo", "obtainUserReputerequest", "obtainUserReputationrequest", "obtainUserReputationInput", "obtainUserComputeRequest", "obtainUserComputeInput", "obtainUserAnnutationQuery", "obtainUserReputablerequest", "obtainUserRepigrationrequest", "obtainUserRepurationQuery", "obtainUserReputeQuery", "obtainUserReputeInfo", "obtainUserRepurationGrant", "obtainUserRepentionResponse", "obtainUserRepulationRequest", "obtainUserReputeInput", "obtainUserAnnigrationGrant", "obtainUserReputionRequest", "obtainUserReputeRequest", "obtainUserRepositoryInfo", "obtainUserRepurityResponse", "obtainUserRelutationRequest", "obtainUserComputationRequest", "obtainUserRepurityRequest", "obtainUserRepurityEntry"], "obtainUserReputationResponse": ["obtainUserRepositoryRequest", "obtainUserReputationResp", "obtainUserExpositoryResp", "obtainUserExputationResponse", "obtainUserRepositoryResponse", "obtainUserRepurationResponse", "obtainUserReputeResponse", "obtainUserExputationResp", "obtainUserExpositoryResponse", "obtainUserRepurationResp", "obtainUserExputationRequest", "obtainUserExpositoryRequest", "obtainUserReputeResp", "obtainUserRepurationRequest", "obtainUserReputeRequest", "obtainUserRepositoryResp"], "rateUserRequest": ["rateUsageReturn", "rateuserrequest", " rateuserrequest", "rateFileCommand", "RateFileResponse", "rateMachinerequest", "rateMachineRequest", "rateUQUEST", "rateUserFunction", "gradeLineError", "rateFileQUEST", " rateUserQUEST", "issueCustomerForce", "rateUError", "ratedFileCommand", "rateLineGrant", "ratedUserrequest", "RateFileQUEST", "rateFileVersion", "rateWordCustomer", "gradeUserRequest", "rateCustomerForce", "RateUserQUEST", "rateMachineResult", "RateFilerequest", "rateHumanVersion", "rateUQuery", "rateLineResponse", " rateClientRequest", "rateHumanResult", " rateClientGrant", "rateServiceQuery", "rateUserResult", "rateWordError", "rateUserReturn", " rateuserRequest", "gradeUserCustomer", "rateClientGrant", "rateMachineVersion", "rateUResponse", "ratedUsageForce", "rateWordQuery", "rateApplicationRequest", "rateUsageQUEST", "rateUserGrant", "RateUserRequest", "issueUserRequest", "rateHumanrequest", "rateServiceFunction", "rateUCommand", "gradeUserError", "ratedUserFunction", "issueCustomerReturn", "rateUsageUser", "rateLineError", "rateUserQUEST", "rateuserQUEST", "ratedUsageRequest", "issueCustomerRequest", "rateFilerequest", "ratePostrequest", " rateUserGrant", "rateUserError", "ratePostRequest", "rateFileRequest", " rateuserResponse", " rateClientrequest", "featureMachinerequest", "ratedFileRequest", "rateUsageQuery", "ratedUserQUEST", "issueCustomerQUEST", " rateuserQUEST", "featureMachineVersion", "ratedUserCommand", "rateUForce", "rateUsageRequest", "rateFileResponse", "rateUserForce", "rateUserrequest", "issueUserReturn", " rateUserQuery", " rateApplicationRequest", "featureMachineResult", "rateServiceCommand", "ratedUsagerequest", "rateCustomerReturn", "rateApplicationResponse", "rateUSERQUEST", "rateUserUser", "rateUserQuery", " rateApplicationQuery", "rateUsageGrant", "featureUserRequest", "rateFileQuery", "rateuserResponse", "featureMachineRequest", "rateUsageForce", "rateuserRequest", "rateLinerequest", "rateUsagerequest", "rateFileResult", "rateCustomerQUEST", " rateApplicationResponse", "rateClientRequest", "gradeLinerequest", "rateLineCustomer", "rateUsRequest", "rateUsReturn", "ratedUserRequest", "featureUserResult", "rateWordrequest", " rateApplicationUser", " rateUserUser", "rateUsForce", "ratedUsageQUEST", "ratedUsageQuery", "rateApplicationQuery", "rateUSERRequest", "rateLineRequest", "issueUserQUEST", " rateUserrequest", "ratedFileFunction", "rateUserCommand", "ratedFileQuery", "gradeLineRequest", "ratePostQUEST", "rateLineQUEST", "issueUserForce", "RateFileRequest", "rateUSERrequest", "rateLineQuery", "rateUSERForce", "gradeUserrequest", "rateClientrequest", "rateFileFunction", "ratedUserForce", "featureUserVersion", "rateUserCustomer", "rateWordRequest", "rateURequest", "RateUserrequest", "RateUserResponse", "ratedUserQuery", "rateUsQUEST", "rateUrequest", "rateUsageResponse", "rateHumanRequest", "rateApplicationUser", "rateFileUser", "rateServiceRequest", "ratePostResponse", "gradeLineCustomer", "rateUFunction", "rateUCustomer", "featureUserrequest", "rateUserVersion", "rateCustomerRequest"], "rateUserResponse": ["rateuserData", "rateFileStatus", "rateCustomerReference", "rateUsersResource", " rateUserReference", "rateUsersResp", "rateUserResource", "RateTimeStatus", "RateUserResource", " rateApplicationData", "rateCustomerResource", " rateFileResult", "rateUserResult", "RateUserStatus", "RateTimeResp", "RateTimeResponse", "rateUserReply", " rateUresponse", "rateApplicationReference", "rateUResponse", "RateUserRequest", "rateApplicationResp", "rateTimeResp", "rateClientResponse", "rateuserresponse", "rateFileresponse", " rateUResponse", "rateCustomerResp", "rateUresponse", "rateUserData", "rateuserReference", " rateApplicationReference", "rateCustomCustomer", " rateApplicationResp", " rateFileResp", "rateUsersResult", "rateApplicationData", "rateTimeCustomer", "rateFileResponse", " rateUserResult", "rateCustomResponse", " rateFileResponse", "rateuserReply", "rateUserReference", "rateUsersStatus", "rateClientStatus", "rateApplicationResponse", "rateTimeResponse", "rateuserResult", "rateuserResp", "rateuserResponse", "rateFileResult", "rateUsersRequest", "RateTimeCustomer", " rateApplicationResponse", "rateCustomResp", "rateUserResp", "rateCustomStatus", " rateUResp", "rateuserStatus", " rateUserReply", "rateTimeStatus", "RateUserResp", "RateUserCustomer", "rateUserStatus", "rateCustomerResponse", " rateUserresponse", "rateFileReply", " rateUserStatus", "rateClientCustomer", "rateUserCustomer", "RateUserResponse", "rateUResp", " rateFileStatus", "rateCustomerData", "rateUsersResponse", "rateFileResp", "rateClientResp", " rateUserData", " rateUserResp", "rateUReply", "rateUserresponse", " rateUReply", "rateCustomerRequest"], "fis": ["Fis", "FIs", " fiss", "sfiss", "sfris", "Fris", "fris", "sfIs", "Fiss", "bis", " fris", "bIs", "biss", "fIs", "bris", "fiss", "sfis", " fIs"], "br": ["buf", "res", "bro", "wr", "fr", "arr", "fin", "b", "body", "dr", " tr", "io", "bp", "bc", "result", "Reader", "str", "rb", "ch", "ref", " bio", "brush", "BR", "pr", "reader", "lr", "ber", "tr", "r", "cr", "err", "bed", " fr", "ob", "gr", "sp", "hr", "bl", "ler", "buffer", "Br", "bridge", "bs", "sw", "browser"], "call": ["text", "doc", "calling", "url", "play", "flow", "message", "e", "ell", "body", "cod", "loc", "cell", "info", "data", "msg", "phone", "output", "f", "result", "charge", "input", "str", "fax", "check", "ck", "cl", "claim", "called", "type", "code", "xml", "cat", "comment", "cu", "ack", "roll", "push", "create", "contact", "co", "work", "user", "sc", "address", "string", "load", "c", "Line", "name", "response", "query", "voice", "invoke", "buffer", "Call", "throw", "line", "use", "request", "callback"]}}
{"id1": "20685385", "id2": "4830847", "code1": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 1, "substitutes": {"getNextPkValueForEntityIncreaseBy": ["getNextPkValueForentityIncreaseBy", "getNextPkValueForEntityIncreaseById", "getNextPkValueForEntityIncreById", "getNextPkValueForentityIncreaseOf", "getNextPkValueForEntityIncreasedOf", "getNextPkValueForEntityIncreOf", "getNextPkValueForentityIncreOf", "getNextPkValueForEntityIncreasedById", "getNextPkValueForEntityRepeatOf", "getNextPkValueForentityIncreBy", "getNextPkValueForEntityIncreBy", "getNextPkValueForEntityRepeatBy", "getNextPkValueForEntityIncreasedBy", "getNextPkValueForentityIncreaseById", "getNextPkValueForEntityRepeatById", "getNextPkValueForentityIncreById", "getNextPkValueForEntityIncreaseOf"], "entityName": ["resourceNames", "elementPath", " entityType", " entityNames", "resourcename", "elementType", "entityNames", "tableNames", "EntityPath", "entityname", "resourceName", "entityTitle", "EntityPart", "tablePart", "peerName", "elementName", "entityPart", " entityname", "EntityNames", " entityPart", "EntityType", "EntityTitle", " entityPath", "tableName", "EntityName", "tablePath", "entityPath", "peername", " entityTitle", "elementname", "peerNames", "peerTitle", "Entityname", "tableType", "tablename", "entityType"], "count": ["Count", "page", "call", "length", "amount", "num", "depth", "session", "more", "part", "limit", "loop", "all", "sum", "ch", "batch", "coll", "key", "type", "timeout", "code", "process", "cc", "handle", "multi", "max", "size", "many", "number", "base", "found", "id", "cache", "counter", "match", "repeat", "c", "start", "list", "path", "pool", "current", "force"], "increasePkBy": ["increasePkeAt", "increasePckBy", "increasePkAt", "increasePknBY", "increasePactBY", "increasePksBy", "increasePkeyFrom", "increasepkAt", "increasePactFor", "increasePkeyBy", "increasePkPer", "increasePkBY", "increaseCksOf", "increasePkOn", "increasePokBy", "increasePokFrom", "increasePkby", "increaseFkBy", "increasePknOn", "increasePkeBY", "increasepnAt", "increaseCkby", "increasePkFor", "increasePkeBy", "increaseEkBy", "increaseCksBy", "increaseEksBy", "increaseCksby", "increasePckFor", "increasePksBY", "increasePactFrom", "increasePknBy", "increaseEkBY", "increasePknAt", "increasePksOf", "increasePksby", "increaseFckBy", "increasePnOn", "increaseEksFrom", "increasePokby", "increasePokOf", "increasePkeFrom", "increaseFokPer", "increasePkFrom", "increasePokPer", "increaseEkFor", "increaseFkPer", "increaseFokFrom", "increasePkeOn", "increasePckBY", "increasePnAt", "increaseEksBY", "increaseFckBY", "increasePksFor", "increaseFkFrom", "increasepnBy", "increasePckOf", "increasePkeyPer", "increasePnBy", "increasePksFrom", "increasePckby", "increaseCkOf", "increaseFkBY", "increasePckFrom", "increasePactBy", "increaseEkFrom", "increasepkOn", "increaseFokBy", "increasePkePer", "increaseEksFor", "increasepkBy", "increaseCkBy", "increasePkOf", "increasepnOn"], "where": ["log", "default", "message", "html", "build", "scope", "style", "body", "loc", "pl", "here", "each", "options", "data", "sql", "search", "field", "how", "exp", "template", "and", "union", "test", "type", "xml", "Where", "dir", "sub", "what", "which", "match", "lim", "WHERE", "file", "select", "when", "other", "printf", "global", "post", "path", "location", "based", "update", "nor", "whe", "database", "ql", "join"], "ec": ["ee", "ex", "log", "eg", "ev", "esc", "e", "core", "roc", "uc", "loc", "rc", "tc", "ce", "org", "dec", "bc", "EC", "anc", "ect", "exc", "eca", "mc", "sec", "cl", "ae", "nc", "conn", "cc", "el", "cca", "equ", "env", "eu", "oc", "sc", "ac", "pc", "c", "bec", "eco", "exec", "dc", "Ec", "fc", "ctx", "environment", "context", "cf", "ea", "lc", "cs", "enc", "ep"], "dbc": [" dbcs", "odcu", "odcy", "bbs", "dbC", "odc", "bbf", "fdC", "dbf", "dbct", "dbn", "bbk", "debf", "debb", "fdcs", "fdct", "odC", "dbcs", "ebn", "debn", "dbk", "dbs", "bbc", "ebc", "odcs", " dbct", "debk", "ppcy", " dbf", "ebb", "dbb", "fdc", " dbcy", "ppcs", " dbC", "odct", " dbk", "obn", "obc", "obb", "debs", "obf", "dbcu", "ppcu", " dbcu", "ebf", " dbs", "dbcy", "ppc", "debc"], "entity": [" component", "pe", "ee", " ep", "component", "e", "resource", "parent", "connection", "Entity", "item", "ce", "event", "entry", "model", "oe", "ode", "document", "ent", "el", " endpoint", "element", "instance", " environment", "node", "et", "object", "table", "email", " enc", "id", " locale", "name", "em", " event", "content", "enc", "ep", " envelope"], "channel": ["ee", "component", "annels", "console", "flow", "e", "resource", "server", "connection", "en", "event", "cer", "bc", "group", "entry", "coll", "ch", "nc", "bean", "container", "conn", "builder", "source", "chan", "config", "client", "self", "can", "ann", "queue", "sc", "cache", "character", "handler", "c", "ou", "ctx", "context", "or", "manager", "feed", "Channel"], "result": ["page", "res", "array", "url", "rows", "arr", "resource", "message", "rate", "event", "profile", "data", "search", "group", "entry", "document", "range", "map", "acc", "val", "row", "results", "source", "consumer", "record", "db", "Result", "number", "feature", "table", "r", "object", "account", "card", "product", "list", "up", "order", "response", "value", "buffer", "collection", "df"], "broker": ["broger", "roker", " broader", "roader", "Broader", "brken", "blockken", "broader", "Broken", "broken", "rok", " broger", " brok", "blockker", "brker", "brcer", "broke", "blockcer", "Broke", "Brocer", "brocer", "brok", "Brok", "roger", "Broger", "brke", "blockke", "Broker"], "con": ["conv", "cons", "ex", "log", "un", "crit", "ct", "cn", "col", "core", "uc", "b", "conf", "connection", "en", "lock", "act", "rc", "Con", "CON", "bc", "Connection", "cond", "f", "connect", "mc", "ran", "coll", "ch", "cl", "h", "out", "cur", "conn", "Conn", "cc", "ver", "pr", "cm", "win", "config", "client", "co", "db", "can", "min", "cache", "pc", "c", "fc", "ctx", "cf", "pub", "pool", "ca", "close", "enc", "common", "cr", "pen", "com"], "tries": ["retries", "fests", "tickets", " trys", "trying", "dests", "retrys", "Try", " tickets", "drys", "attries", "fickets", "fries", "fry", "Trys", "retrying", "frying", "retry", "attasks", " tests", "tests", "Trying", " tasks", "attrying", "trys", "dickets", "tasks", "fasks", " trying", "dries", "Tries", "attests", "frys"], "resultSet": ["resultsSet", "retSet", "reportSum", "resultLine", " resultLine", " resultUse", "reportUse", "ResultHit", "resultsLine", "resultsUse", " resultHit", "retHit", "ResultSet", "pageLine", " resultSum", "resultGen", "resultUse", "resultsRow", "resultHit", "pageSet", "resultSum", "retGen", "resultRow", "resultSource", "resultsSum", "reportSource", "pageRow", "reportSet", "resultsGet", " resultSource", " resultGet", "pageGet", "resultsSource", " resultRow", "ResultGen", " resultGen", "resultGet"], "hasNext": [" HasNext", "HasFirst", "hadNext", " hasMe", "hasMe", "hasPrevious", " HasFirst", "hadPrevious", "HasNext", " HasPrevious", "hadFirst", "HasMe", "hasFirst", " hasFirst", " HasMe", " hasPrevious", "HasPrevious"], "pk": ["lpk", " pkey", "prkg", "lpsk", " pid", "ipk", " pok", "lpok", " pkg", "ipkey", " pks", " pke", "pkey", "jpke", "pid", "jpk", "lpke", " ipk", "Pks", "pkg", "psk", "Pk", "prks", "pok", "lpkey", "pke", "jpok", "prid", "lpid", " psk", "prk", "ipid", "ipsk", " ipke", "Pid", "pks", " ipid", "jpid", " ipsk", "Pkg"]}}
{"id1": "16549995", "id2": "19868933", "code1": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"mysqlPasswordHash": ["mysqlPasswordhash", "mysSQLpasswordhash", "mysSQLpasswordHash", "mysSQLPasswordPassword", "mysqlSecretPassword", "mysqlPasswordPass", "mysqlHashHash", "mysSQLPasswordHash", "mysqlSecrethash", "mysqlHashPassword", "mysqlSecretPass", "mysqlPasswordPassword", "mysSQLpasswordPassword", "mysqlSecretHash", "mysqlpasswordPass", "mysqlpasswordhash", "mysSQLPasswordhash", "mysqlHashPass", "mysqlHashhash", "mysqlpasswordPassword", "mysqlpasswordHash", "mysSQLPasswordPass", "mysSQLpasswordPass"], "string": ["prefix", "text", "array", "uri", "message", "ring", "null", "script", "letter", "data", "username", "version", "duration", "sword", "in", "result", "str", "input", "password", "bytes", "pass", "source", "driver", "section", "number", "slice", "object", "address", "file", "name", "service", "word", "value", "buffer", "strings"], "digest": ["Diger", " Digest", "Digusher", "Digler", "encested", " digEST", "DigEST", "digoded", "validest", "encEST", "Digester", "hedest", "validate", "digEST", "Digest", "heder", "dayest", " digested", "mdEST", "mdested", "signusher", "Digtest", " digler", "Digate", "digtest", "Digoded", "signest", "mdoded", "digitester", " diger", "signer", "digler", " digusher", "Digize", "digitest", "digate", " Digester", " digester", "digitate", " Diger", "hedtest", "dayester", "Digested", "digester", "dayer", " digtest", "signester", "dayested", "signEST", "encoded", "encest", "diger", "validize", "digested", "mdest", "digize", "digusher", "digitize", " Digler", "hedEST", "validester"], "encodedPassword": ["enchedPassword", "enodedpassword", "enchedpassword", "enccodedPass", "Encryptedpassword", "encodedText", "encodedCode", "encodingString", "EncodedPass", "encodedString", "EncodedCode", "encryptedCode", "Encodedpassword", "enccodedString", "EncryptedPass", "enodedPassword", "enccodedText", "encodingPass", "enccodedpassword", "encachedString", "EncodedPassword", "encodingCode", "EncryptedCode", "encryptedString", "EncryptedString", "enchedCode", "encryptedText", "encodingPassword", "encryptedPassword", "EncryptedPassword", "encodingText", "encryptedPass", "encachedPassword", "enchedString", "encachedpassword", "encodedPass", "EncryptedText", "EncodedText", "encryptedpassword", "encodedpassword", "enodedString", "enccodedPassword", "EncodedString", "encodingpassword"], "hash": ["pad", "ash", "array", "log", "url", "length", "build", "html", "null", "sha", "style", "height", "rh", "tag", "version", "carry", "dig", "search", "result", "check", "hex", "valid", "sum", "password", "error", "h", "key", "row", "code", "ver", "pass", "total", "kh", "memory", "parse", "ashes", "number", "sign", "base", "mac", "user", "hed", "id", "cache", "match", "history", "alpha", "ha", "Hash", "square", "sh", "always", "value", "shift", "block", "ashed", "char"]}}
{"id1": "22114133", "id2": "22035737", "code1": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "code2": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["eventPerformed", "eventPerured", "actionConformed", "actionPerceived", "actionConured", "actionOccformed", "eventPerceived", "actionOccceived", "eventOccformed", "actionOccuted", "actionReured", "actionConuted", "actionOccured", "eventOccuted", "actionConceived", "eventPeruted", "eventOccured", "actionReceived", "actionPerured", "actionReformed", "actionReuted", "eventOccceived", "actionPeruted"], "e": ["m", "enter", "ee", "ev", "esi", "se", "g", "ce", "event", "ie", "ec", "entry", "es", "o", "ent", "type", "element", " Event", "a", "er", "E", "r", "v", "handler", "c", "t", "Event", "eve", "ente", " event", "ea", "or", "ed", "x", "events", "q", "ante", "owner", "p"], "cmd": ["text", "req", "Cmd", "txt", "module", "nd", "cfg", "cod", "cp", "rc", "cmp", "event", "method", "data", "md", "msg", "folder", "mode", "cpp", "gt", "cl", "cb", "wd", "type", "conn", "code", "cc", "plugin", "ctrl", "pkg", "ack", "config", "src", "MD", "cli", "client", "target", "fun", "command", "ctr", "Command", "id", "handler", "c", "name", "help", "dc", "comm", "ctx", "vc", "host", "grad", "cf", "cd", "path", "qq", "q", "kind"], "chooser": ["promoder", "choiner", "choser", "chosen", "Choaser", "choosen", "boosen", "wooker", "joosen", "chose", "Chooker", "chooker", "pooder", "catoner", "cloder", "joose", "poicer", "Chooser", "pooker", "boose", "wooder", "claser", "promoker", " choaser", "booser", " choose", "closer", " choosing", "clicer", "woicer", "choker", "promoner", "boaser", "choosing", "chooder", " chooner", "catoser", "joosing", "Choose", " chooker", "Choiner", " choicer", "booker", "wooner", "catose", "jooser", "joiner", "chooner", "boiner", "jooder", "pooner", "chaser", "boosing", "poaser", " choosen", "boicer", "pooser", " chooder", "Choosing", "booner", "wooser", "choaser", "promoser", "closing", "choose", "choicer", "joicer", "poose", "cloker", "catosen", "poosen", "close"], "f": ["fd", "fo", "fn", "uf", "m", "u", "fl", "fr", "j", "sf", "g", "b", "n", "fi", "form", "xf", "fb", "info", "part", "elf", "func", "field", "fm", "fa", "o", "d", "ref", "feed", "h", "tf", "fs", "inf", "rf", "bf", "framework", "l", "ff", "fun", "fx", "fw", "v", "handler", "file", "c", "fc", "fen", "af", "t", "full", "function", "F", "ef", "fe", "fp", "p", "df"], "filename": ["prefix", "fn", "text", "subject", "uri", "ssl", "message", "txt", "sf", "length", "b", "maximum", "n", "loc", "summary", "sheet", "il", "fb", "profile", "username", "shell", "appy", "title", "phrase", "document", "fax", "family", "password", "attr", "nl", "nil", "href", "kn", "brush", "bytes", "download", "bf", "nv", "metadata", "directory", "size", "expression", "fil", "l", "files", "which", "Filename", "kl", "token", "string", "suff", "file", "knife", "name", "loader", "binary", "sl", "wb", "layer", "location", "path", "jl", "json", "word", "utf", "label", "fp", "ename"], "askRestart": ["CanRestart", "Canrestort", "AllowRestart", "CanRestarter", "CanAbarter", "CanStart", "CanRestarts", "Canrestarts", "CanAbort", "CanAbart", "CanRestort", "AllowRestarter", "Allowrestarter", "CanStarter", "CanStarts", "CanStort", "Allowrestarts", "Allowrestart", "Canrestarter", "AllowRestarts", "Allowrestort", "CanAbarts", "Canrestart", "AllowRestort"]}}
{"id1": "14877116", "id2": "411595", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"cpFile": ["cpfile", " cpfile", "CopyFile", " copyFiles", "CopyFiles", " cpFiles", "cpCode", " copyfile", " cpCode", "cpFiles", "Copyfile", " copyFile", " copyCode", "CopyCode"], "source": ["component", "subject", "url", "unit", "resource", "image", "server", "se", "parent", "dest", "null", "view", "scope", "connection", "remote", "database", "ce", "this", "project", "channel", "document", "Source", "site", "route", "zip", "archive", "ources", "template", "type", "element", "iter", "config", "directory", "client", "stream", "self", "seed", "base", "Target", "slice", "node", "object", "table", "token", "string", "ource", "file", "start", "name", "service", "reference", "SOURCE", "grade", "host", "context", "path", "current", "secure", "scene", "force", "use", "from"], "target": ["to", "proxy", "component", "url", "resource", "server", "parent", "master", "dest", "copy", "null", "connection", "remote", "project", "sync", "port", "external", "director", "alias", "range", "output", "it", "folder", "result", "site", "route", "archive", "nt", "template", "type", "home", "download", "iter", "config", "top", "client", "self", "Target", "base", "table", "transform", "object", "token", "arget", "file", "ource", "name", "other", "origin", "tor", "reference", "root", "host", "next", "global", "service", "path", "current", "content", "tail", "format", "force", "boot", "database", "owner"], "replace": ["rm", "include", "array", "write", "append", "apply", "copy", "protect", "complete", "stall", "rel", "reset", "store", "hide", "allow", "sync", "follow", "range", "route", "split", "reply", "remove", "multiple", "inline", "fill", "only", "move", "placed", "add", "flash", "delete", "same", "place", "change", "match", "repeat", "share", "repl", "re", "other", "root", "cover", "align", "insert", "update", "force", "use", "compatible"], "bufferSize": [" bufferSIZE", "queueLen", " buffersize", "byteCount", " bufferLen", "serversize", "queueSize", "serverLen", "flushSIZE", "serverSIZE", " bufferCount", "bufferSIZE", "flushSize", "bufferCount", "byteLen", "queueCount", "flushsize", "bufferLen", "serverSize", "buffersize", "bytesize", "queuesize", "flushLen", "byteSize"], "src": ["rt", "fn", "proxy", "req", "rec", "url", "ssl", "resource", "server", "copy", "dest", "ser", "loc", "rc", "sys", "sync", "socket", "bc", "in", "sb", "inst", "Source", "result", "zip", "input", "archive", "rb", "ources", "cb", "cur", "sq", "tmp", "ruby", "stream", "flash", "sub", "reflect", "sc", "ource", "gz", "obj", "RC", "gb", "start", "sr", "sl", "ctx", "sel", "proc", "sh", "secure"], "tarn": ["treen", " tann", "taur", "tharo", " treen", " taro", "yarm", "Tann", "Treen", "wtarm", "ttern", " trn", "ttarm", "Tron", "yaran", "yern", "thaur", "wtaran", "thern", "ttarp", "tarp", "ttron", " tarm", "Taran", "etarn", " tron", "trn", "tron", "etreen", "ntarn", "tern", "yarn", " taran", "taron", "wtarn", "ttrn", "taran", "tharn", "taro", " taron", "tarm", "Tarn", "ttarn", "Trn", " tarp", "ntarp", "ttann", "ntaron", " taur", "ttaro", "tann", "ttaur", "Tarm", "etann", "etaran", " tern", "wtern", "ttaron", "ntann"], "tardir": ["sardire", "tartart", "sardir", "tartir", "sardsir", "tardart", "Tartiri", "tildiri", "tariri", "tarpirt", "tardpath", "tardedpath", "tardsdir", "tarpar", "tardspath", "tarir", "Tardar", "tartirt", "tardsir", "sardirt", "Tartar", "tardeddir", "tardedirs", "tardirt", "tardirs", "Tardart", "tartpath", "tartire", "tarar", "tarddir", "tardar", "Tardiri", "tildar", "sardar", "tartiri", "Tarddir", "tardsirt", "sardsirt", "tardire", "Tartdir", "tardsirs", "tildir", "tardsire", "Tartart", "Tardpath", "sardsire", "tarpir", "tardiri", "tardedir", "tartar", "Tartirs", "tildart", "Tardirs", "tardsar", "tartdir", "Tardir", "Tartpath", "tartirs", "tarpire", "Tartir", "tarart", "sardsar"], "n": ["norm", "k", "m", "nu", "fn", "un", "u", "ln", "z", "e", "cn", "j", "g", "en", "num", "none", "ns", "in", "ni", "sn", "o", "nt", "d", "rn", "coll", "nl", "nc", "pn", "ng", "conn", "i", "nw", "ne", "mn", "l", "number", "min", "na", "v", "c", "dn", " i", "x", "nor", "nb", "N", "p", "nn"], "tar": ["pack", "shr", "large", "copy", "dest", "dr", "par", "tc", "sv", "rar", "cloud", "csv", "cos", "shape", "zip", "archive", "Tar", "sum", "cro", "test", "tf", "tan", "jar", "cat", "temp", "war", "ar", "tg", "tmp", "tif", "car", "raf", "flash", "di", "tr", "skip", "trans", "file", "gz", "safe", "sr", "sh", "transfer", "ra", "buffer", "box", "ca", "ray", "cr"], "bytes": ["ls", "values", "keys", "rows", "Bytes", "b", "os", "ps", "io", "data", "ones", "es", "bs", "reads", "vs", "classes", "lines", "out", "bles", "seconds", "objects", "tes", "les", "vals", "nets", "pieces", "files", "pages", "resources", "outs", "eps", "bits", "frames", "steps", "cells", "ops", "blocks", "words", "items", "boot", "bps", "runs", "ipes"], "readn": ["passns", "findlen", "writelen", "writene", "passN", "runns", "writeno", " readN", "readno", "writens", "runN", "readne", "readN", "findN", "writen", "readns", "runn", "Readn", "findne", "ReadN", "writeN", "readlen", "readl", "runlen", " readl", "Readlen", "Readl", "findn", "runl", "passn", " readlen", "runno", "passno", " readne"]}}
{"id1": "620855", "id2": "10218878", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doChangeUpdate", " doversionUpdate", "doversioncheck", "doVersioncheck", "doversionUpdate", " doversionCheck", " doversioncheck", "doVersionUpdate", "doversionScan", "doVersionScan", "doFeatureUpdate", " doVersionScan", "doChangeCheck", "doFeatureScan", "doFeatureCheck", " doVersioncheck", "doversionCheck", "doFeaturecheck", "doChangeScan", "doChangecheck", " doversionScan", " doVersionUpdate"], "view": ["widget", "image", "html", "row", "review", "self", "edit", "cache", "div", "gu", "list", "ui", "query", "update", "page", "e", "server", "style", "form", "event", "cell", "this", "link", "port", "display", "group", "model", "input", "fail", "index", "el", "see", "config", "can", "object", "change", "layout", "show", "vis", "video", "vol", "views", "ve", "check", "out", "comment", "im", "user", "screen", "by", "up", "ou", "sel", "value", "manager", "use", "http", "block", "body", "lock", "session", "container", "client", "base", "VIEW", "v", "window", "full", "pool", "head", "box", "View"], "url": ["ls", "log", "uri", "ssl", "resource", "ll", "server", "image", "fr", "b", "null", "length", "rel", "loc", "ul", "link", "socket", "blog", "f", "impl", "zip", "www", "URL", "download", "source", "builder", "stream", "l", "web", "base", "id", "address", "email", "string", "gl", "file", "loader", "name", "ob", "sl", "host", "bug", "path", "Url", "location", "buffer", "hub", "http", "bb", "open", "browser"], "in": ["m", "ins", "resource", "In", "b", "init", "data", "socket", "inc", "input", "bis", "din", "IN", "lin", "inn", "out", "s", "cin", "is", "source", "win", "sin", "reader", "rin", "nin", "stream", "login", "inner", "ac", "file", "con", "err", "binary", "pin", "ini", "as", "buffer", "again", "doc", "isin"], "bin": ["border", "fin", "ban", "b", "body", "lock", "init", "socket", "gin", "oin", "input", "vin", "din", "IN", "lin", "run", "inn", "out", "abi", "cin", "sin", "is", "win", "reader", "record", "ruby", "login", "inner", "bn", "file", "con", "loader", "binary", "lib", "pin", "bot", "ini", "bi", "buffer", "arin", "spin", "nb", "bb", "browser"], "line": ["page", "LINE", "text", "pe", "log", "lf", "e", "unit", "write", "le", "one", "b", "letter", "cell", "data", "ge", "link", "out", "nl", "part", "range", "entry", "definition", "zip", "str", "lin", "cl", "lines", "end", "val", "type", "row", "code", "el", "jo", "key", "inline", "comment", "job", "parse", "l", "ip", "base", "user", "object", "look", "id", "string", "file", "Line", "name", "up", "sl", "pin", "word", "lc", "ine", "block"], "version": ["Version", "install", "vert", "unit", "image", "server", "null", "VERSION", "project", "model", "beta", "support", "date", "dev", "type", "python", "download", "ver", "plugin", "code", "pull", "driver", "section", "vision", "license", "feature", "user", "position", "versions", "id", "video", "string", "v", "patch", "name", "option", "device", "latest", "host", "bug", "cover", "release", "value", "author", "update", "format", "secret"], "build": ["log", "install", "unit", "image", "lease", "uild", "style", "rel", "lock", "built", "tag", "info", "hold", "mount", "link", "follow", "building", "how", "block", "valid", "run", "job", "feed", "row", "home", "ver", "builder", "Build", "add", "pull", "print", "work", "make", "show", "load", "patch", "help", "post", "bug", "get", "clean", "release", "update", "http", "use", "boot"]}}
{"id1": "5148212", "id2": "3806532", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["createFile", "transferDir", " copyFiles", "copyDir", "copyfile", " copyfile", "createfile", "createFiles", "transferfile", "copyFiles", " copyDir", "createDir", "transferFiles", "transferFile"], "src": ["proxy", "req", "url", "uri", "resource", "image", "view", "loc", "rc", "cdn", "remote", "project", "ie", "sb", "impl", "input", "archive", "rb", "ref", "href", "s", "download", "source", "config", "filename", "stream", "l", "slice", "r", "sc", "ource", "file", "obj", "upload", "RC", "name", "gb", "dist", "gz", "loader", "sl", "path", "http", "fp", "img"], "dest": [" Dest", "p", "url", "txt", "parent", "b", "style", "master", "null", "Dest", "destroy", "cdn", "loc", "flat", "data", "later", "this", "project", "output", "folder", "du", "dep", "zip", "route", "archive", "exp", "d", "dat", "done", "comb", " destination", "wd", "home", "temp", "rest", "source", "dir", "config", "tmp", "di", "filename", "target", "delete", "opt", "de", "slice", "id", "trans", "desc", "v", "file", "obj", "dist", "dc", "name", "origin", "wb", "path", "front", "orig", "doc", "img"], "bufSize": ["bufLen", " bufLen", "ufSize", "buffsize", "buffLen", " bufCount", "bufsize", "bufName", "buffName", "ufsize", "buffSize", " bufsize", "bufCount", "bufferCount", "ufCount", "bufferLen", "bufferName", "buffCount", "buffersize", "ufName", "bufferSize", "ufLen"], "force": ["replace", "delay", "play", "write", "parent", "count", "apply", "style", "Force", "remote", "act", "reason", "like", "die", "store", "child", "forces", "sync", "allow", "enable", "ride", "orce", "route", "effect", "forced", "only", "ignore", "require", "flush", "pull", "push", "keep", "send", "forcing", "cache", "hard", "load", "file", "err", "kill", "want", "service", "deep", "fix", "auto", "front", "false", "close", "secure", "use", "dirty", "cop"], "f": ["fd", "m", "fn", "uf", "u", "e", "j", "b", "g", "n", "fb", "folder", "fm", "o", "d", "feed", "h", "fs", "s", "rf", "bf", "i", "dir", "l", "self", "ff", "base", "fx", "r", "cache", "v", "c", "file", "fc", "t", "w", "path", "F", "fe", "fp", "p", "df"], "buffer": ["border", "wave", "buf", "page", "pad", "url", "write", "resource", "message", "length", "null", "b", "offset", "data", "Buffer", "raw", "sequence", "limit", "result", "input", "batch", "bytes", "flush", "iter", "source", "reader", "size", "buff", "seed", "number", "base", "queue", "slice", "position", "cache", "bin", "binary", "reference", "uffer", "transfer", "value", "feed", "bb"], "read": ["ink", "k", "text", "play", "write", "se", "length", "count", "copy", "build", "ok", "n", "view", " Read", "lex", "io", "data", "sync", "reading", "inc", "raw", "connect", "check", "input", "reads", "READ", "set", "index", "Read", "run", "feed", " write", "end", "key", "fill", "seek", "pass", "i", "add", "iter", "max", "reader", "size", "parse", "ip", "len", "ad", "send", "r", "ind", "id", "skip", "show", "load", "exec", "c", "start", "select", "find", "wait", "get", "x", "sleep", "use", "block", "open", "rate"], "in": ["m", "request", "ex", "ins", "url", "In", "b", "ax", "n", "connection", "thin", "init", "child", "inc", "socket", "gin", "impl", "input", "din", "IN", "inn", "lin", "s", "conn", "pass", "cin", "download", "i", "source", "win", "rin", "reader", "kin", "pull", "client", "nin", "l", "a", "login", "inner", "r", "id", "token", "ac", "bin", "con", "c", "err", "re", "up", "pin", "ini", "as", "or", "again", "on", "p"], "out": ["to", "ex", "log", "writer", "one", "write", "server", "image", "parent", "null", "b", "plain", "n", "connection", "init", "off", "io", "data", "outer", "sync", "inc", "socket", "output", "gin", "cookie", "exp", "o", "sum", "Out", "error", "conn", "pass", "client", "ne", "nin", "co", "inner", "outs", "user", "object", "id", "cache", "exec", "bin", "v", "obj", "err", "c", "name", "other", "up", "net", "OUT", "w", "plus", "again", "line", "lib", "ext"]}}
{"id1": "9398454", "id2": "16092702", "code1": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"getRemoteFile": ["getLocalfile", "createRemoteURL", "createRemoteFiles", "getVirtualFiles", "getRemoteFiles", "createLocalFiles", "getVirtualURL", "getVirtualFile", "createLocalfile", "getRemotefile", "getLocalFile", "getRemoteURL", "getremotefile", "getremoteFiles", "createRemotefile", "createRemoteFile", "createLocalURL", "createLocalFile", "getLocalURL", "getLocalFiles", "getremoteFile", "getremoteURL", "getVirtualfile"], "url": ["ur", "page", "uri", "ssl", "resource", "server", "connection", "loc", "remote", "data", "f", "route", "str", "URL", "www", "ref", "href", "source", "src", "addr", "config", "filename", "l", "base", "address", "email", "string", "gl", "file", "name", "sl", "host", "location", "Url", "path", "buffer", "http", "feed"], "size": ["ize", "oa", "esc", "unit", "e", "large", "length", "count", "speed", "offset", "loc", "empty", "weight", "scale", "si", "sync", "SIZE", "sum", "storage", "password", "small", "bytes", "timeout", "accept", "code", "type", "time", "eng", "width", "sized", "capacity", "len", "address", "string", "Size", "fee", "security", "name", "full", "path", "content", "iz", "enc", "use"], "realUrl": ["realLength", "fullLength", "fakeURL", "fakeurl", "realUr", "fullurl", "baseurl", "realURL", "baseUr", "fakeUr", "fullURL", " realUr", "realName", " realLength", "fakeUrl", "realurl", " realurl", "fakeLength", " realURL", "fakeName", " realName", "fullName", "baseURL", "baseUrl", "fullUrl"], "conn": ["conv", "resp", "rt", "oa", "ct", "ssl", "cn", "col", "g", "conf", "n", "connection", "cp", "rc", "loc", "act", "cmp", "en", "sync", "Connection", "connect", "nt", "coll", "ch", "nc", "ci", "h", "cb", "error", "Conn", "co", "db", "ann", "exec", "con", "c", "err", "obj", "dc", "dn", "comm", "ctx", "ai", "close", "enc", "dh", "p", "open"], "rf": ["rt", "fn", "fr", " RF", "lf", "rx", "sf", "fi", "rc", "nr", "fb", "f", "vr", "result", "PF", "rn", "ref", "rb", "arf", "cb", "fs", "far", "bf", "rl", "lr", " framework", "fw", "r", "fee", " fr", "fc", "af", "cf", "response", "RF", "fe", "fp"]}}
{"id1": "6890417", "id2": "21488518", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"a1": ["alpha2", "an1", "A2", "an2", "A3", "a0", " a0", "an01", "alpha01", "an3", "ga1", "alpha0", "ga2", "a01", "ga01", "A01", "ga0", "A1", "alpha1", " a01"], "a2": ["n8", "n2", "A2", "A5", "n5", "n4", "A4", "p5", "p1", "p2", "A8", "p4", "A1"], "a3": ["a23", "an33", " a33", "alpha2", "a33", "an23", "alpha5", "ga3", "ga5", " a23", "alpha3", "an3", "ga2", "alpha9", "la3", "la33", "ga9", "la23"], "a4": ["A2", "as9", "ga8", "A5", "pa8", "pa4", "pa10", "A4", "ma10", "ma8", "as2", "ga4", "ma4", "ga10", "as5", "A9", "as4"], "a5": ["n2", " a6", "a6", "p7", "alpha8", "alpha6", "A5", "a7", "alpha5", "n5", "alpha4", "n6", "A4", "p5", "p2", "A8", "n7", "p6", "A6", " a7"], "a8": ["alpha11", " a6", "an7", "a6", "an6", "alpha8", "alpha6", "b4", "a7", "an8", "alpha4", "b7", "A11", "A4", "an10", "b11", "b6", "b10", "A8", "A6", " a7", "b8"], "a9": ["alpha10", "alpha11", "p10", "p7", "alpha8", "a7", "alpha7", "a09", "p09", "A11", " a09", "A7", "alpha9", "A8", "A9", " a7", "p9", "alpha09"], "a10": ["alpha10", "as8", "as9", "as09", "alpha8", "a12", "an8", "A10", "a09", "an12", "b09", "as10", "A09", "an10", "alpha9", "an9", "b10", "A8", "alpha12", "A9", " a12", "b9", "b8"], "a11": ["alpha11", "am7", "alpha8", "a12", "a7", "A10", "alpha18", "A18", "am10", "a18", "a13", "A11", "am13", " a18", " a13", "A7", "A8", "alpha12", "am11", " a7", "A12", " a12", "A13"], "ps": ["ls", "ppa", "proxy", "pe", "pes", "js", "res", "ins", "gets", "details", "als", "ss", "points", "ipes", "rs", "os", "ases", "PS", "ns", "parts", "aps", "cases", "pos", "pse", "py", "es", "vs", "pa", "pres", "lines", "ips", "settings", "s", "ms", "pass", "alls", "posts", "Ps", "pr", "ws", "is", "hes", "properties", "qs", "pps", "pi", "ports", "ras", "eps", "files", "ils", "params", "ams", "tests", "ops", "ts", "rules", "per", "ons", "as", "gs", "jp", "ples", "cs", "ups", "pers", "pp", "p", "ks", "ds", "changes"], "url": ["ls", "proxy", "page", "log", "fl", "uri", "ssl", "ll", "image", "server", "build", "connection", "cloud", "f", "document", "www", "URL", "download", "config", "client", "contact", "l", "web", "base", "user", "control", "object", "address", "string", "gl", "file", "service", "sl", "bug", "Url", "response", "buffer", "twitter", "http", "browser"], "request": ["pe", "req", "p", "respond", "resource", "report", "server", "call", "complete", "connection", "remote", "method", "info", "this", "child", "session", "hello", "external", "result", "connect", "reply", "Request", "rest", "temp", "pull", "create", "builder", "access", "push", "client", "web", "worker", "user", "r", "upload", "re", "per", "next", "response", "transfer", "buffer", "http", "use", "open", "post", "rate"]}}
{"id1": "5061606", "id2": "2022160", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequessnecessary", "createSettingsIfNequccesseless", "createSettingsIfNecesseless", "createSettingsIfNecccessarily", "createSettingsIfNecessnecessary", "createSettingsIfNequessary", "createSettingsIfNececeless", "createSettingsIfNecccessnecessary", "createSettingsIfNeceseless", "createSettingsIfNecccessary", "createSettingsIfNequccessnecessary", "createSettingsIfNececary", "createSettingsIfNequccessary", "createSettingsIfNecccesseless", "createSettingsIfNequessarily", "createSettingsIfNequesseless", "createSettingsIfNequccessarily", "createSettingsIfNecesnecessary", "createSettingsIfNecesary", "createSettingsIfNecessarily", "createSettingsIfNececnecessary", "createSettingsIfNececarily", "createSettingsIfNecesarily"], "out": ["at", "prefix", "page", "exit", "log", "writer", "ex", "array", "url", "write", "image", "server", "plain", "copy", "null", "parent", "connection", "lock", "init", "io", "off", "data", "this", "sync", "socket", "channel", "output", "model", "group", "result", "cookie", "editor", "o", "index", "password", "Out", "error", "timeout", "conn", "plugin", "i", "flush", "source", "config", "client", "a", "outs", "user", "object", "cache", "exec", "bin", "file", "err", "obj", "window", "app", "name", "by", "up", "net", "OUT", "path", "pool", "again"], "fSettings": ["Fsettings", "filesettings", "fJs", "fsSettings", "fsSetting", "fSetup", " fsettings", "fsFs", "fsSetup", "fmSetting", "fSetting", "sfSettings", "rfConfig", " fFs", "rfSettings", " fConfig", "FSettings", "rfFs", "FSetting", "FSetup", " fSetting", "fsConfig", "sfSetting", "fileSettings", "fileSetting", "sfJs", "fileettings", "rfSetting", "fmSetup", "fConfig", " fJs", " fettings", "fsettings", "FJs", "fmSettings", "FConfig", "sfsettings", "fFs", "sfettings", "fettings", "fmConfig"], "src": ["prot", "text", "req", "ins", "url", "uri", "ssl", "uc", "dest", "b", "st", "loc", "rc", "sb", "route", "str", "storage", "ref", "rb", "attr", "cb", "settings", "cur", "source", "config", "filename", "tmp", "stream", "sub", "base", "ctr", "sc", "lower", "string", "ource", "file", "dist", "gb", "sr", "sl", "sel", "path", "fp", "img"], "in": ["ins", "url", "image", "In", "copy", "b", "n", "connection", "init", "thin", "data", "inc", "f", "gin", "input", "din", "IN", "inn", "index", "s", "i", "sin", "win", "source", "rin", "reader", "kin", "stream", "l", "login", "inner", "r", "id", "bin", "file", "con", "c", "err", "ini", "path", "again"]}}
{"id1": "17856064", "id2": "3053403", "code1": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "label": 0, "substitutes": {"parse": [" structure", " start", " load", " analyze", " parsing", " resolve", " process", " extract", " pars", " inspect", " constructor", " parsed", " validate", " discover", " scan", " assemble", " check", " params", " read", " compile", " parser", " execute", " install", " ls", " test", " analyse"], "unitName": ["uiValue", "unitsNames", "Unitname", "uiType", "Unit1", "unitsName", "machineValue", " unitType", "units1", "unit1", "machineName", "unitValue", "unitPath", "unitsname", " unitname", "machineType", " unitPath", "machinePath", "UnitName", "UnitNames", "uiName", "unitNames", " unit1", "unitname", "unitType", " unitValue", " unitNames", "uiPath"], "persistenceUnits": ["persistanceUnitit", "persistenceClites", "persistenceOperits", "persistanceUnunits", "persistenceUnunits", "persistanceUnITS", "persistanceUnites", "persistanceClITS", "persistenceUnitITS", "persistanceUnitits", "persistenceunits", "persistenceClITS", "persistenceLogists", "persistenceununits", "persistanceUnitodes", "persistenceUNITS", "persistenceUnitodes", "persistenceUites", "persistenceUnititions", "persistenceUNitions", "persistanceClits", "persistenceUnitits", "persistenceUnitions", "persistanceUnitists", "persistenceUnitunits", "persistenceUNites", "persistenceUnites", "persistanceUnitions", "persistanceUnitites", "persistenceUnists", "persistenceUNodes", "persistenceClitions", "persistenceUnodes", "persistenceLogunits", "persistanceUnit", "persistenceClits", "persistenceOperites", "persistenceOperodes", "persistenceunists", "persistenceLogits", "persistenceunites", "persistenceUNit", "persistenceUnitit", "persistenceUNits", "persistanceUnodes", "persistenceUnITS", "persistanceUnitunits", "persistenceLogites", "persistenceUnit", "persistenceUits", "persistanceClitions", "persistanceClites", "persistenceUnitites", "persistenceOperit", "persistanceUnits", "persistanceUnitITS", "persistanceUnists", "persistenceUit", "persistenceUITS", "persistenceUnitists"], "classes": [" configurations", " constants", " interfaces", "ps", " suites", " protocols", " groups", "es", "groups", "result", " class", "set", " models", " packages", " instances", "results", "class", "properties", " sources", "Class", "resources", " assignments", " formulas", "names", " tests", "params", " Classes", "services"], "i": ["p", "u", "z", "uri", "n", "fi", "ori", "info", "si", "ie", "in", "f", "ni", "index", "ci", "iu", "oi", "ji", "multi", "y", "li", "di", "l", "mi", "ip", "pi", "xi", "hi", "eni", "yi", "id", "ti", "v", "gi", "ix", "I", "ai", "phi", "ini", "ii", "ui", "x", "bi", "qi", "ri"], "url": ["ls", "ur", "uri", "ssl", "resource", "image", "server", "connection", "io", "data", "username", "link", "in", "entry", "f", "route", "URL", "href", "xml", "element", "plugin", "source", "api", "config", "filename", "l", "web", "base", "user", "address", "string", "file", "name", "service", "up", "sl", "path", "Url", "location", "http"], "b": ["m", "p", "e", "build", "n", "fb", "bt", "bh", "Builder", "bc", "verb", "sb", "f", "bis", "pb", "o", "rb", "cb", "B", "builder", "bd", "library", "a", "l", "db", "base", "r", "br", "v", "c", "obj", "gb", "be", "ob", "lib", "wb", "hub", "ab", "eb", "bs", "bb"], "d": ["fd", "ds", "m", "u", "dos", "e", "g", "n", "dot", "data", "md", "dd", "f", "dat", " D", "s", "xml", "dl", "dm", "dir", "pd", "di", "l", "db", "r", "D", "id", "c", "dc", "t", "did", "dom", "director", "p", "dt", "df"], "unitNodes": [" unitNideos", "unitnoded", "unitSnodes", "unitNoms", "unitSnode", " unitNoded", "unitNeodes", "unitnobs", " unitNoms", "unitDodes", " unitNurs", " unitNubes", " unitnodes", "unitNubes", "unitNurs", "unitnideos", "unitSnoded", "unitNeode", "unitnurs", " unitNobs", "unitNeoms", " unitnurs", "unitNideos", "unitnodes", "unitnubes", "unitRenoms", "unitDurs", "unitRenobs", " unitnoms", "unitNobs", "unitNeoded", "unitSnoms", "unitNoded", "unitRenubes", " unitnoded", "unitnoms", "unitDideos", "unitnode", "unitRenodes", " unitnode", " unitnideos"], "j": ["ij", "jen", "js", "u", "fr", "z", "g", "n", "kj", "je", "jc", "ie", "syn", "f", "ni", "it", "jj", "jet", "ja", "jit", "ch", "dj", "job", "uj", "key", "aj", "ji", "J", "h", "jo", "y", "section", "l", "bj", "br", "v", "obj", "jl", "ii", "qi", "json", "jp", "note", "q", "p"], "unitNode": ["connectionElement", "tunElement", "connectionPath", "UnitNode", "tunNode", " unitN", "unitsName", " unitElement", "unitPath", "UnitPath", "connectionNode", " unitPath", "tunnode", "unitsnode", "unitN", "tunName", "UnitN", "connectionN", "unitElement", "unitsElement", "unitsNode", "unitnode", " unitnode", "UnitElement"], "unitElt": ["unitOlt", " unitELT", "unitEsld", "unitNlt", "unitUxt", "elementElt", " unitExt", "unitEld", "unitEselt", "unitUler", "unitExt", "elementEslet", "elementEld", "elementEselt", " unitUlt", " unitEler", "unitOelt", "unitNelt", " unitOlt", " unitOLT", "unitGeld", "unitext", " unitUler", "unitIlem", "uniteelt", " unitOld", "unitELT", "unitNld", "unitElem", "elementEslt", "unitelt", "unitIxt", "unitGeLT", "unitEslet", "unitOlet", "unitIlt", "unitOld", "unitUlem", "uniteler", "unitEslt", "elementEelt", " unitOelt", "unitGelt", "unitEler", "unitelet", " unitUlem", "unitUlt", "elementElet", " unitUxt", "unitEelt", "unitNLT", "unitIler", "uniteld", "unitElet", " unitEelt", " unitEld", "unitOLT", " unitElem", "unitelem", "unitGeelt", "elementEsld"], "uName": ["uNode", " uNode", "duNode", "uPath", "suValue", "suName", "unitValue", " uname", "unitPath", "uValue", " uValue", " uPath", "duValue", "duNames", "uNames", "uname", "unitNames", "suname", "suPath", "unitname", " uNames", "duName"], "parameters": ["paramParameters", "paramels", "aramels", "arameters", "pams", "pareters", "prometer", "pumers", "paramsels", "parumers", "paramumers", "prometers", "perseters", "peters", "paramseters", "paramseter", "promels", "arameter", "paramsParameters", "aramParameters", "promParameters", "pels", "params", "parameter", "paramams", "persams", "persumers", "persels", "parels"], "classNodes": ["classCode", "Classnode", "ClassNode", "classEodes", "classEanks", "classCoded", "classClements", "classCodes", "classnoded", "fieldNodes", "Classnodes", "classEoded", "classSode", "fieldNinodes", "classNeoded", "fieldNinode", "classVobs", "ClassNanks", "classNinodes", " classClements", "classVode", "classSnlements", "classnanks", "fieldNODE", " classNlements", "classNeodes", "classnode", "ClassNoded", "ClassNodes", "Classnoded", "classSnode", "classnodes", "fieldNobs", "classVodes", "Classnanks", "classNinode", "classVODE", "classSobs", "classNoded", "classNanks", "classSnodes", "classNelements", "classSODE", " classCode", "classNobs", "classNinobs", "classNinODE", "classEode", "fieldNinODE", "classNlements", "classNODE", "fieldNinobs", " classNoded", " classCodes", "fieldNode", "classSodes", "classSnoded", "classNeode", " classCoded"], "k": ["ks", "ky", "kr", "K", "dk", "kat", "z", "kid", "ku", "g", "ok", "n", "ki", "ek", "km", "kick", "f", "ck", "ch", "ko", "kn", "key", "h", "y", "work", "kk", "kw", "ad", "r", "id", "v", "unk", "c", "ke", "w", "sk", "q", "p", "ik"], "classNode": [" classFile", " className", "Classnode", " classSource", "ClassNode", "configSource", "busFile", "ClassFile", "fileNode", " classnode", "classFile", "fileTree", "configName", "baseTree", "className", "baseRoot", "busNs", "ClassNs", "classnode", "elementElement", "classRoot", " classNs", "elementTree", "classElement", "elementNode", "classNs", "configNode", "fileElement", "elementRoot", "fileRoot", "baseNode", " classElement", "busnode", "classTree", "busNode", "baseElement", "classSource", "configElement", "elementSource"], "classElt": ["classOlt", "classeld", "elementeelt", "elementElt", "ClassElem", "classYelt", "ClassExt", "elementEld", "elementext", "classUlem", "classOxt", "classelt", "classYlem", "classXler", "classEld", "ClassEld", "classext", "classEelt", "classXelt", "classeelt", "ClassOxt", "ClassXelt", "classelem", "classElem", "Classelem", "ClassXld", "classYler", "classYlt", "classXxt", "Classeelt", "classXLT", "ClassElt", "ClassELT", "classUlt", "ClassEler", "elementEelt", "elementeld", "ClassXlt", "ClassOld", "classUld", "Classeld", "Classelt", "classeLT", "ClassEelt", "elementExt", "classOld", "classOler", "classUelt", "ClassOlt", "ClassOler", "classYld", "classEler", "classUxt", "elementelt", "ClassXLT", "classYxt", "classELT", "classXlt", "classXld", "classExt"], "elementName": ["typeFamily", "elementPath", "typeAnn", "typeApp", "layerFamily", "moduleValue", "typeName", "elementAnn", "sectionFace", "className", "elementFace", "layerAnn", "layerApp", "sectionName", " elementFamily", "articleFamily", "sectionFamily", "elementFamily", " elementname", "elementApp", "articleAnn", "stringName", "classValue", "moduleName", "stringFamily", "articleName", " elementFace", "modulePath", "layerName", "classPath", "elementname", "stringFace", "articleApp", " elementPath", "modulename", "classname"], "elementValue": ["stylevalue", "optionValue", "styleText", "elementString", "elementVal", "objectString", "objectValue", "entryText", " elementVal", "Elementvalue", "optionVal", "objectvalue", "optionString", "objectVal", "entryVal", "entryvalue", "ElementVal", "memberText", "styleValue", "memberVALUE", "styleVALUE", "ElementVALUE", "optionvalue", "elementvalue", "memberVal", " elementVALUE", "ElementValue", "ElementString", "entryVALUE", "memberValue", "elementVALUE", " elementText", "elementText", "ElementText", "entryValue"]}}
{"id1": "13499897", "id2": "21824901", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"CopyFile": [" CopyFolder", "Createfile", " copyfile", " CopyDir", " Copyfile", "CreateFolder", " copyDir", "Copyfile", "CreateFile", " copyFolder", "CreateDir", " copyFile", "CopyFolder", "CopyDir"], "sourcefile": ["SourceFile", "Sourcef", "destFile", "sourcefilename", "sinfile", " sourceFile", " sourcefilename", "configstream", "Sourcefile", "sourcelog", "destf", "configlog", "Sourcefilename", "configfile", "sourceFile", "sinlog", "deststream", "sinstream", "destlog", "sinFile", "configFile", " sourcef", "sourcef", "sourcestream", "destfilename"], "destfile": ["destFile", "sourcefilename", "targetfilename", "srcfilename", "deststring", "destroystream", "sourcepath", "buildfile", " destFile", "Desturl", "destfp", "tempFile", "destroyfilename", " destfp", "tempfilename", "Destfilename", "tempstream", "newfile", "Destfp", "buildstring", "targetpath", "srcfile", " destfilename", "DestFile", "sourceFile", "newfilename", "Destfile", "srcpath", "buildFile", "newfp", "deststream", "Destpath", "tempfile", "sourcestring", "targetfile", "targeturl", "targetFile", "destroyfile", "newFile", " destpath", " deststring", " desturl", "srcFile", "destroypath", "buildfilename", "destfilename", "temppath", "srcstream", "desturl", "destpath"], "last": ["after", "ending", "recent", "nd", "core", "se", "count", "length", "offset", "style", "prev", "event", "empty", "depth", "later", "child", "old", "part", "range", "route", "end", "key", "cur", "code", "cat", "total", " Last", "max", "size", "Last", "base", "start", "ast", "left", "full", "next", "latest", "first", "path", "current", "value", "or", "real", "use", "from", "right"], "parent": ["ppa", "text", "partial", "shared", "url", "unit", "dest", "null", "loc", "Parent", "remote", "data", "child", "port", "part", "search", "anc", "parents", "exp", "pa", "valid", "and", "key", "test", "home", "temp", "source", "api", "section", "filename", "target", "ip", "base", "point", "mac", "id", "cache", "po", "string", "ac", "patch", "file", "name", "root", "next", "function", "path", "location", "ant", "current", "content", "pointer", "fat", "line", "p", "post"], "f": ["fd", "m", "lf", "e", "j", "sf", "b", "g", "flat", "fb", "folder", "fa", "o", "d", "ref", "feed", "h", "fs", "s", "inf", "i", "dir", "l", "self", "of", "base", "r", "found", "v", "file", "c", "fc", "t", "af", "full", "cf", "F", "fe", "fp", "p", "df"], "srcChannel": ["destChannel", "rcChan", "srcClient", "sourceChannel", "srcChan", "rcConnection", "destchannel", "rcClient", " srcchannel", "sourcechannel", "rcchannel", "destConnection", "srcConnection", "rcChannel", "srcchannel", "sourceChan", "sourceConnection", " srcClient", " srcConnection", " srcChan", "destChan", "destClient"], "dstChannel": ["destChannel", "idstChan", "idrcChan", "dstchannel", "idstChannel", "ddestBuffer", "dntContext", "dsrcChan", "ddestChannel", "DstBuffer", "ddestContext", "DestContext", "dstChan", "dstButton", "DstChan", "drcchannel", "idrcButton", "dstsChannel", "idrcchannel", "dstBuffer", "destchannel", "dstContext", "DestChan", "dstschannel", "drcButton", "idstButton", "DstChannel", "dntBuffer", "dsrcButton", "ddestChan", "dsrcChannel", "dntChannel", "idrcChannel", "drcChan", "dntChan", "dsrcchannel", "destBuffer", "drcChannel", "DestChannel", "Destchannel", "destButton", "DstContext", "DestBuffer", "destChan", "dstsChan", "Dstchannel", "idstchannel", "destContext"]}}
{"id1": "10176678", "id2": "3187685", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpGgzained", "testLoadHttpGozipped", "testLoadHttpGgzips", "testLoadHttpGzipipped", "testLoadHttpGzipipping", "testLoadHttpgzipained", "testLoadHttpGozained", "testLoadHttpGozips", "testLoadHttpGzained", "testLoadHttpGzipping", "testLoadHttpgzained", "testLoadHttpGozipping", "testLoadHttpgzipipped", "testLoadHttpGzipained", "testLoadHttpGzips", "testLoadHttpgzipips", "testLoadHttpgzipped", "testLoadHttpgzips", "testLoadHttpgzipipping", "testLoadHttpGgzipped", "testLoadHttpgzipping", "testLoadHttpGgzipping", "testLoadHttpGzipips"], "url": ["ls", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "html", "connection", "loc", "info", "data", "method", "f", "zip", "route", "URL", "ref", "error", "key", "type", "xml", "class", "source", "src", "config", "filename", "l", "base", "id", "address", "string", "gl", "file", "name", "sl", "host", "pattern", "location", "Url", "path", "response", "buffer", "http"], "loadingInfo": [" loadinginfo", " loadingObj", "loadingObj", "loadingInf", "loadinginfo", "LoadingInf", "loaderinfo", " loadingManager", "LoadingConfig", "loaderConfig", "lockingManager", "loadingConfig", "LoadingManager", "lockingInfo", "LoadingObj", " loadingInf", "Loadinginfo", "LoadingInfo", "lockingInf", "loaderInfo", "loadingManager", " loadingConfig", "lockingObj", "loaderInf"], "contentInputStream": ["contentReadSteam", "contentBytestream", "contentOutputStream", "contentReadStream", "ContentOutputString", "ContentInputSteam", "ContentInputString", "contentInputSteam", "contentImportSteam", "contentByteStream", "ContentOutputObject", "contentImportObject", "contentOutputObject", "contentImportStream", "ContentOutputstream", "contentContentObject", "contentInputObject", "ContentInputstream", "contentOutputString", "contentInputString", "contentOutputSteam", "contentOutputstream", "contentReadString", "ContentInputObject", "contentContentSteam", "contentReadstream", "contentInputstream", "ContentOutputSteam", "contentImportstream", "ContentOutputStream", "contentContentstream", "ContentInputStream", "contentContentStream", "contentByteString", "contentByteSteam"], "actual": ["original", "array", "older", "affected", "acceptable", "example", "als", "length", "act", "failed", "event", "successful", "pect", "evaluate", "valid", "truth", "covered", "future", "actually", "average", " Actual", "former", "found", "wrong", "pects", "ual", "handled", "initial", "anticipated", "reported", "existing", "fake", "response", "content", "current", "events", "real", "ception", "received", "including"], "expected": ["allowed", "original", "usual", "acceptable", "length", "example", "failed", "updated", "pect", "info", "data", "required", " expecting", "error", "future", " unexpected", "driver", "size", "found", "wrong", " expect", "reported", "seen", "handled", "anticipated", "defined", "fake", "cover", "nexpected", "always", "needed", "real", "pected", "ception", "received"]}}
{"id1": "13421722", "id2": "17029388", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"getFileSize": [" getFileBytes", "getfileLength", "getFilesInfo", "getByteLength", "getfileInfo", " getfileLength", " getfileSize", "getByteBytes", "getFilesSize", "getByteSize", "getFileInfo", " getFileInfo", "getFilesBytes", " getfileInfo", "getfileBytes", " getfileBytes", "getFileBytes", "getFilesLength", " getFileLength", "getFileLength", "getByteInfo", "getfileSize"], "address": ["prefix", "attribute", "array", "uri", "localhost", "report", "resource", "server", "message", "offset", "data", "port", "output", "route", "str", "type", "Address", "code", "source", "addr", "config", "size", "network", "target", "ip", "number", "base", "point", "position", "object", "email", "string", "name", "reference", "host", "location", "path", "content", "format", "request"], "url": ["ur", "page", "proxy", "log", "uri", "ssl", "resource", "image", "server", "e", "ll", "html", "build", "loc", "io", "org", "session", "socket", "channel", "f", "impl", "result", "www", "URL", "str", "job", "conn", "xml", "api", "config", "client", "l", "web", "lr", "base", "user", "object", "found", "string", "orb", "file", "service", "ob", "sl", "host", "bug", "path", "Url", "location", "http", "feed", "lib"], "connection": ["to", "proxy", "uri", "resource", "server", "communication", "event", "io", "info", "version", "session", "socket", "bc", "channel", "Connection", "application", "entry", "connect", "out", "conn", "connected", "config", "section", "client", "control", "object", "position", "character", "handler", "c", "con", "service", "relation", "reference", "environment", "context", "function", "response", "wrapper", "or", "current", "condition", "collection", "http", "use", "request", "open", "database"]}}
{"id1": "7911686", "id2": "7149578", "code1": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFile", " copyFiles", "copyfile", " copyfile", "moveFiles", " copyResource", "transferfile", "copyResource", "moveResource", "copyFiles", "movefile", "transferResource", "transferFiles", "transferFile"], "source": ["proxy", "ins", "resource", "image", "server", "parent", "connection", "remote", "sync", "ie", "Source", "site", "input", "ources", "sin", "src", "reader", "size", "inside", "stream", "target", "inner", "base", "slice", "internal", "object", "ource", "file", "start", "origin", "service", "reference", "SOURCE", "use", "from"], "destination": ["testout", "dominate", "domination", "resturation", "destinate", "Destinator", "restinated", "Destinate", "destout", "deinate", "deinated", "deinator", "testination", "destinated", "Destination", "testinated", "testuration", "Desturation", "deination", "desturation", "destinator", "restination", "Destinated", "Destout", "dominator", "dominated", "restout"], "in": ["m", "ins", "url", "image", "In", "null", "b", "n", "connection", "lock", "init", "like", "io", "info", "data", "socket", "inc", "ie", "channel", "f", "gin", "input", "din", "IN", "inn", "conn", "cin", "i", "win", "rin", "reader", "record", "sin", "inside", "nin", "a", "config", "login", "client", "inner", "base", "min", "issue", "r", "id", "pull", "pc", "bin", "err", "c", "con", "file", "name", "up", "pin", "ini", "as", "again", "isin"], "out": ["at", "plain", "exit", "ex", "writer", "url", "vert", "write", "call", "copy", "null", "b", "In", "n", "parent", "connection", "init", "cmd", "off", "io", "data", "outer", "this", "sync", "outside", "inc", "channel", "output", "no", "gin", "exp", "o", "IN", "Out", "conn", "temp", "i", "with", "client", "nin", "of", "outs", "user", "id", "cache", "bin", "err", "obj", "c", "file", "app", "name", "extra", "up", "net", "OUT", "ou", "w", "again", "lib", "ext"]}}
{"id1": "21979717", "id2": "11334468", "code1": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"upload": ["save", " transfer", "init", "archive", "paste", "run", " download", "accept", "download", "process", "Submit", "create", "add", " Upload", "load", "submit", "start", "select", "up", " submit", "transfer", "execute", "Upload", "request", "open", "post"], "fileResult": ["filesresult", "FileRes", "fileRank", "downloadResult", "filesRes", "downloadResults", "Fileresult", "fpRes", "filesResults", "fpResults", " fileresult", "fileResults", " fileResults", "fileRes", "FileResult", "downloadRes", "filesResult", "downloadRank", "FileResults", "fpResult", "fileresult", "fpRank", " fileRes", "FileRank"], "in": ["into", "ins", "image", "In", "conf", "init", "tin", "info", "data", "inc", "socket", "f", "gin", "input", "vin", "IN", "inn", "lin", "conn", "cin", "i", "source", "win", "kin", "rin", "inside", "login", "inner", "min", "cache", "bin", "c", "file", "up", "pin", "ini", "arin", "again", "on", "p", "isin"], "url": ["ur", "ls", "log", "fl", "uri", "ssl", "image", "server", "b", "connection", "pl", "ul", "org", "socket", "channel", "f", "impl", "www", "URL", "coll", "cl", "bel", "conn", "pull", "api", "client", "l", "web", "address", "gl", "c", "file", "ob", "sl", "host", "path", "Url", "http"], "con": ["conv", "cons", "un", "log", "gen", "ssl", "cn", "plain", "uc", "conf", "cp", "connection", "en", "rc", "remote", "Con", "CON", "sync", "socket", "bc", "part", "ec", "syn", "func", "connect", "fa", "ran", "ch", "cl", "run", "rou", "cur", "conn", "Conn", "ver", "ctrl", "cm", "open", "client", "co", "sub", "login", "fun", "can", "min", "pc", "c", "exec", "re", " conn", "fc", "per", "pin", "cf", "non", "ca", "close", "http", "on", "request", "ocon", "pen"], "out": ["at", "ex", "ssl", "resource", "image", "server", "parent", "copy", "b", "conf", "connection", "io", "outer", "this", "socket", "external", "inc", "output", "input", "o", "ch", "Out", "conn", "win", "client", "login", "base", "can", "outs", "object", "cache", "v", "c", "bin", "file", "obj", "err", "OUT", "pool", "as", "again", "line", "on"], "in2": ["input2", " in02", "intwo", "out2", " intwo", "INTwo", "IN02", "In2", "inTwo", "inputTwo", "input4", "out4", " inTwo", "In1", " in1", "in4", "err1", "err2", "input02", "outtwo", "errtwo", " in4", "IN4", "IN2", "out1", "outTwo", "InTwo", "in02", "errTwo", "In4", "in1"], "buf": ["fd", "font", "cap", "cv", "uf", "text", "uc", "b", "rc", "fb", "data", "bh", "dec", "av", "lb", "feat", "Buffer", "bc", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cas", "home", "bf", "cat", "bd", "buff", "ff", "db", "base", "ba", "br", "bin", "fab", "la", "vec", "ha", "cf", "pool", "buffer", "utf", "seq", "box", "block"], "bytesRead": [" bytesLength", "rowsread", "tesRead", "byteWrite", "blocksread", "rowsRead", "linesWrite", " bytesWrite", "blocksUse", "BytesLength", " bytesLoad", "rowsUse", "blocksWrite", " bytesread", "linesRead", "tesWrite", "byteLoad", "blocksRead", "bytesUse", " bytesRun", "rowsWrite", "tesRun", "BytesRead", "byteRead", "bytesLoad", "bytesLength", "bytesWrite", " bytesWritten", " bytesUse", "linesRun", "bytesread", "linesWritten", "BytesLoad", "byteLength", "bytesWritten", "bytesRun", "tesWritten", "BytesWrite"]}}
{"id1": "15510198", "id2": "21489105", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"buildParser": ["makeReader", "constructReader", "makeParser", "newReader", "constructParser", "buildHandler", "buildReader", "makeWriter", "constructHandler", "newParser", "makeHandler", "newWriter", "buildWriter", "newHandler", "constructWriter"], "url": ["page", "proxy", "uri", "ssl", "resource", "image", "server", "null", "loc", "io", "data", "this", "link", "channel", "str", "URL", "www", "source", "class", "config", "l", "base", "object", "address", "file", "obj", "c", "name", "loader", "service", "sl", "host", "bug", "path", "Url", "location", " URL", "http", "open"], "ParserException": ["ParserExc", "IOError", " IOError", "SSLError", "SSLException", " IOExc", " IOException", "IOExc", "SSLExc", "IOException", "ParserError"], "parser": ["angler", "pe", "writer", "server", "se", "parent", "null", "style", "master", "manager", "data", "this", "result", "jack", "test", "type", "xml", "instance", "plugin", "class", "builder", "parse", "reader", "pard", "pd", "library", "api", "seed", "er", "worker", "slave", "object", "cache", "pc", "handler", "au", "loader", "Parser", "root", "fruit", "php", "pool", "ler", "jp", "x", "config", "http", "fp", "p", "processor", "arser"], "connection": ["proxy", "uri", "resource", "image", "server", "message", "communication", "j", "loc", "event", "io", "this", "link", "session", "socket", "bc", "channel", "Connection", "application", "document", "connect", "ion", "conn", "connected", "instance", "class", "reader", "config", "client", "section", "directory", "db", "position", "object", "character", "handler", "c", "con", "service", "relation", "reference", "context", "function", "response", "condition", " Connection", "lc", "pointer", "collection", "http", "open", "database"]}}
{"id1": "12380475", "id2": "17557289", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"transport": ["protpoint", "ransports", " transmission", "protports", " transporter", "protmission", "transprocess", "ransmission", "transmission", "protport", "ransport", "transpoint", "ranspoint", " transpoint", "ransporter", " transports", "protporter", "protprocess", "transporter", "ransprocess", " transprocess", "transports"], "file": ["page", "log", "FILE", "url", "resource", "e", "image", "server", "parent", "ile", "connection", "io", "data", "single", "project", "info", "socket", "channel", "folder", "model", "f", "entry", "document", "route", "out", "type", "handle", "source", "class", "comment", "reader", "dir", "directory", "filename", "stream", "use", "db", "base", "user", "queue", "object", "local", "cache", "change", "string", "handler", "name", "service", "full", "File", "path", "line", "auto", "content", "http", "fp"], "files": ["ls", "pes", "keys", "ions", "ins", "books", "users", "sites", "headers", "ums", "f", "bs", "features", "classes", "lines", "balls", "fs", "s", "thumbnails", "objects", "results", "facts", "flows", "images", "dir", "pages", "names", "models", "cells", "iles", "views", "blocks", "Files", "boxes", "ups", "events", "phones", "items", "issues"], "i": ["k", "m", "p", "u", "uri", "e", "col", "j", "b", "n", "io", "info", "si", "f", "it", "ni", "o", "index", "d", "ci", "h", "end", "oi", "key", "abi", "multi", "li", "di", "mi", "ip", "pi", "vi", "xi", "hi", "slice", "id", "ti", "v", "c", "I", "ai", "chi", "ii", "ui", "x", "ini", "ri"], "inChannel": ["InFile", "outchannel", "inputChan", "inputChannel", "InStream", " inStream", "InChan", " inchannel", "InChannel", "inStream", "outMessage", "inChan", "inputCh", "InMessage", "inchannel", " inMessage", "inFile", " inFile", "inCh", " inChan", "inputStream", "outStream", " inCh", "InCh", "Inchannel", "outFile", "inMessage"], "outChannel": ["ioChannel", "outchannel", "inConnection", "outHandler", "OutChan", " outHandler", "inHandler", "inStream", "inChan", " outChan", "ioChan", "ioConnection", "OutChannel", "inchannel", "Outchannel", " outchannel", "ioHandler", "outStream", " outStream", "outChan", "outConnection", "OutStream", " outConnection"]}}
{"id1": "18544890", "id2": "13595251", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"get": ["gets", "resource", "call", "debug", "remote", "info", "data", "GET", "Get", "end", "download", "pull", "create", "send", "cache", "show", "load", "match", "start", "select", "find", "list", "next", "json", "query", "update"], "url": ["ur", "ls", "page", "uri", "ssl", "ll", "resource", "server", "image", "connection", "loc", "f", "rule", "route", "str", "URL", "www", "href", "date", "key", "download", "source", "l", "base", "queue", "id", "email", "address", "string", "file", "name", "service", "sl", "host", "layer", "location", "Url", "path", "http", "feed"], "lat": ["at", "distance", "play", "late", "length", "west", "offset", "loc", "height", "data", "las", "port", "pos", "range", "route", "league", "out", "live", "home", "tile", "Lat", "width", "l", "base", "alt", "point", "local", "gal", "address", "id", "la", "grid", "street", "bot", "location", "game"], "lon": ["log", "ln", "length", "offset", "loc", "off", "lan", "depth", "lb", "on", "online", "pos", "range", "land", "lin", "nl", "val", "live", "ng", "width", "l", "len", "number", "base", "position", "lag", "la", "left", "layer", "location", "level", "ino", "fat", "lang", "vel"], "count": ["Count", "log", "length", "offset", "n", "amount", "num", "depth", "more", "part", "follow", "limit", "f", "all", "sum", "index", "batch", "error", "val", "type", "timeout", "code", "time", "total", "size", "len", "number", "base", "scroll", "id", "found", "cache", "load", "file", "c", "age", "list", "name", "pool", "level", "force"], "req": ["fr", "requ", "org", "dq", "socket", "reg", "exp", "rb", "conn", "ver", "temp", "r", "cache", "cook", "exec", "wa", "err", "proc", "plug", "query", "orb", "respond", "fin", "server", "call", "ru", "cp", "form", "fail", "cb", "test", "download", "pkg", "worker", "https", "c", "gr", "ctx", "cf", "pub", "jp", "q", "rf", "post", "resp", "rx", "build", "ok", "cmd", "loc", "io", "fb", "sem", "check", "cur", "sq", "pr", "pull", "ctr", "tr", "next", "hr", "http", "serv", "ur", "rt", "res", "p", "rob", "conf", "f", "ref", "Request", "wx", "require", "bur", "client", "work", "rr", "qt", "def", "grad", "fit", "fe", "request", "ext"], "gl": ["ogl", "console", "fl", "fr", "ll", "Gl", "g", "gn", "view", "loc", "pl", "gall", "gre", "il", "las", "ul", "ang", "groups", "ga", "coll", "cl", "nl", "bel", "rg", "go", "el", "gg", "berg", "lol", "cm", "rl", "gold", "gm", "hl", "l", "bg", "ger", "fx", "gal", "GL", "lim", "gi", "gb", "list", "ml", "global", "gel", "sl", "sel", "bl", "lc", "cal", "fe", "bs", "img", "browser"], "br": ["buf", "res", "bro", "fr", "arr", "b", "body", "dr", "mr", "io", "yr", "bh", "bc", "result", "str", "ch", "rb", "brush", "BR", "pr", "reader", "ar", "stream", "lr", "ber", "bar", "tr", "r", "ctr", "div", "err", "sr", "gr", "sp", "hr", "bl", "ler", "Br", "bridge", "cr", "img", "browser"], "line": ["page", "text", "pe", "LINE", "log", "fr", "lf", "e", "unit", "le", "style", "letter", "cell", "data", "ge", "link", "sync", "pos", "entry", "rule", "str", "lin", "cl", "lines", "nl", "inline", "key", "row", "el", "live", "end", "jo", "code", "comment", "source", "cle", "ne", "l", "co", "base", "look", "string", "file", "Line", "name", "sl", "sel", "bl", "lo", "word", "lc", "ino", "ine", "block", "char"]}}
{"id1": "21125261", "id2": "21425787", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"test": [" verify", " testing", " train", " eval", " process", "Test", " sample", "Main", " validate", "evaluate", " check", " example", " evaluate", "run", " simulate", " tests", "tests", " run", " analyse", "train", "execute", "Train", " solve", " deploy"], "is": ["ls", "res", "gets", "ins", "does", "isi", "os", "lis", "ps", "info", "mis", "ics", "si", "iso", "in", "es", "bis", "IS", "ists", "fs", "s", "out", "iris", "ws", "ios", "i", "src", "stream", "ses", "id", "iss", "ais", "ir", "ris", "has", "Is", "ai", "as", "isa", "opens", "serv", "its"], "byteArrayOutputStream": ["byteArrayOutputPath", "byteStringOutputPath", "byteArrayoutputSteam", "byteStringInputStream", "byteArrayFileFile", "byteArrayOutputFile", "byteArrayInputFile", "byteArrayIOFile", "byteStringInputString", "byteArrayoutputContext", "byteArrayOutputString", "byteArrayByteString", "byteArrayByteSteam", "byteStringOutputString", "byteStringInputContext", "byteArrayFilePath", "byteArrayOutputContext", "byteArrayIOString", "byteStringOutputFile", "byteArrayInputPath", "byteStringInputSteam", "byteArrayByteFile", "byteStringInputPath", "byteArrayoutputStream", "byteArrayFileSteam", "byteArrayByteStream", "byteStringOutputSteam", "byteStringOutputContext", "byteStringInputFile", "byteArrayIOStream", "byteArrayOutputSteam", "byteArrayFileStream", "byteArrayInputString", "byteArrayInputContext", "byteArrayInputStream", "byteArrayInputSteam", "byteArrayFileContext", "byteArrayoutputPath", "byteStringOutputStream", "byteArrayIOSteam", "byteArrayFileString"], "def": ["der", "des", "frame", "default", "e", "report", "conf", "init", "info", "data", "md", "this", "definition", "f", "spec", "entry", "d", "ref", "dev", "decl", "DEF", "class", "parse", "config", "dir", "bus", "di", "base", "de", "da", "id", "desc", "file", "obj", "dist", "Def", "re", "DE", "defined", "pro", "define", "dem", "df"], "se": ["ade", "ve", "pe", "est", "inse", "spe", "e", "le", "ss", "ser", "ste", "ce", "SE", "lex", "sle", "ge", "si", "sem", "ie", "pse", "entry", "zip", "site", "es", "so", "su", "sec", "me", "s", "sche", "see", "sea", "te", "ze", "parse", "cle", "ne", "de", "ses", "sc", "sed", "ase", "ane", "ke", "be", "service", "sl", "sel", "sp", "per", "sk", "sh", "ine", "fe"], "linkId": ["Linkid", "lockInfo", "linkid", "lockId", "feedLength", "linkById", " linkLength", "feedInfo", "lineId", "linkLength", "lineInfo", "feedId", " linkById", "lineById", "linkInfo", "lockById", "LinkId", " linkid", " linkInfo", "feedid", "LinkLength", "LinkInfo"], "segmentId": ["negementNumber", " segmentsType", " segmentID", "segementCount", "segmentsType", "sementId", "segementInfo", "negementInfo", "segmentCount", "segmentID", "segmentsID", "selementCount", "negmentCount", "selementType", "selementId", " segmentType", "segmentType", "segmentInfo", "negementId", "negmentNumber", "selementID", "negementCount", "segementId", "segmentsId", " segmentsCount", " segmentCount", "segementNumber", "segmentsInfo", "negmentInfo", " segmentsID", "sementInfo", "sementCount", "sementType", "segmentsCount", " segmentsId", "sementID", "segmentsNumber", "segmentNumber", "sementNumber", "negmentId"], "linkSegments": ["lineFraggments", "linkConnectments", "linkFragines", "linkFragments", "linkFragles", "lineSegines", "linkConnectgments", "linkSegures", " linkEnggments", "lineFragments", "linkEngles", "lineSegment", "linkFragment", "linkIncrements", "lineFragles", "linkEngment", "linkIncreines", "linkEngines", "lineFragines", "linkEngures", "linkSegles", " linkSegment", "linkEnggments", "lineSegles", "linkSeggments", "linkFraggments", " linkSeggments", "lineSegments", "linkSegment", "linkConnectures", "linkIncreles", "lineSeggments", " linkSegures", "linkEngments", "linkFragures", "linkConnectment", " linkEngments", " linkEngures", "linkIncrement", "linkSegines", " linkEngment", "lineFragment", "linkIncregments"], "segments": ["pegments", "gegment", "pegment", "begs", "pegs", "begment", "sements", "schegment", "begments", "pements", "bements", "segs", "Seggments", "pegements", "peplings", "gegments", "gegements", "seplings", "Seggment", "Seggements", "Segments", "geplings", "segements", "segment", "schegments", "gements", "gegs", "scheplings", "schements"], "frameProperties": [" frameProblems", "frameProeters", "frameProps", "framePromproperties", "frameprops", " frameProeters", "framePropblems", "framePrometers", "frameproperties", "frameproeters", "framePropeters", "framePromperties", " frameproblems", "frameProproperties", " frameProproperties", " frameproproperties", "frameproproperties", "framePropperties", "framePropps", "frameProblems", " frameproperties", "framePromps", "frameproblems", " frameProps", "framePropproperties", " frameprops", " frameproeters"], "time": ["activity", "TIME", "delay", "play", "e", "image", "money", "clock", "length", "count", "speed", "etime", "event", "data", "weight", "depth", "step", "duration", "times", "port", "once", "loop", "f", "now", "timer", "date", "h", "type", "live", "timeout", "end", "size", "ice", "ime", "work", "tim", "id", "change", "video", "v", "cost", "c", "file", "start", "age", "name", "t", "Time", "x", "value", "vel", "sleep", "rate"], "vehicle": ["vertology", "venical", "venometry", "vehical", "vehocity", "bridicle", "bridical", " mobicles", " vehicular", "vehometry", " mobicle", "Vehology", "vehish", " mobish", "verticular", "bridometry", "Vehicles", " mobline", "driical", "Vehicle", "driicle", "vehline", "driocity", "verticle", " vehicles", "Vehish", "vehology", "vehicular", "venicle", "venocity", "vehicles", " vehline", " vehology", "bridocity", "driometry", "Vehicular", "verticles", " vehish", "Vehline"]}}
{"id1": "7846688", "id2": "13152325", "code1": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"postData": ["PostData", "PostBody", " PostText", " postText", "postText", " postBody", "postPart", "postBody", " PostPart", " postPart", " PostData", "PostPart", " PostBody", "PostText"], "protocol": ["scheo", "pathport", "interol", "theose", "hosturl", "Proto", "portec", "protec", "proec", "promport", "promocol", "proport", "hostort", "portotype", "pathol", "theocol", "proticle", "theport", "intericle", "scheocol", "cryptport", "Protol", "prototype", "protose", "scheotype", "prootype", "protport", "proto", "proturl", "iolort", "Protort", "porto", "cryptol", "Proturl", "iolport", "pathicle", "Protport", "interport", "interocol", "scheec", "hostocol", "protort", "protol", "Protocol", "cryptocol", "proocol", "theotype", "iolurl", "Proticle", "promo", "hostport", "Protose", "portocol", "pathocol", "Prototype", "promol", "proose", "proo", "iolocol", "crypto"], "host": ["proxy", "bind", "component", "arch", "auth", "subject", "uri", "localhost", "server", "parent", "view", "loc", "method", "project", "port", "part", "channel", "site", "controller", "h", "type", "container", "home", "key", "source", "add", "hop", "header", "work", "target", "ip", "base", "node", "mac", "object", "address", "string", "hard", "ac", "account", "name", "service", "Host", "root", "domain", "pattern", "path", "front", "hub", "format", "topic", "http", "feed", "database"], "form": ["filter", "forms", "text", "Form", "one", "parent", "view", "body", "term", "act", "off", "method", "session", "port", "raw", "channel", "field", "model", "f", "range", "zip", "input", "str", "template", "and", "test", "type", "key", "pass", "source", "action", "config", "with", "stream", "transform", "place", "object", "address", "string", "ac", "file", "FORM", "name", "pattern", "domain", "function", "path", "clean", "query", "format", "feed", "post"], "data": ["DATA", "text", "array", "uri", "message", "one", "append", "resource", "style", "view", "body", "info", "parts", "version", "raw", "part", "zip", "result", "input", "str", "valid", "dat", "batch", "missing", "key", "type", "xml", "source", "action", "multi", "config", "media", "what", "da", "cache", "change", "string", "patch", "file", "alpha", "name", "params", "json", "response", "picture", "query", "content", "value", "format", "update", "buffer", "database", "request", "post"], "url": ["ls", "ur", "proxy", "log", "fl", "uri", "ssl", "resource", "server", "b", "connection", "this", "session", "channel", "f", "impl", "connect", "www", "URL", "conn", "api", "client", "web", "l", "base", "cache", "file", "c", "fc", "sl", "Url", "http", "open", "com"], "con": ["conv", "cons", "un", "log", "cn", "core", "uc", "conf", "cp", "connection", "en", "rc", "Con", "CON", "sync", "on", "socket", "inc", "bc", "channel", "Connection", "part", "f", "cos", "connect", "fa", "ran", "coll", "cl", "run", "cur", "conn", "Conn", "ver", "cm", "open", "win", "client", "co", "sub", "login", "can", "r", "xc", "cache", "pc", "c", "exec", "re", "fc", "per", "pre", "ca", "close", "enc", "http", "cr", "ocon", "pen", "com"], "out": ["ex", "log", "writer", "plain", "b", "conf", "n", "io", "outer", "child", "sync", "inc", "socket", "raw", "output", "f", "gin", "o", "sum", "ch", "Out", "key", "conn", "pass", "temp", "co", "web", "sub", "outs", "user", "r", "cache", "ac", "err", "bin", "file", "obj", "up", "w", "net", "OUT", "plus", "again", "line", "p"], "in": ["rec", "ex", "ins", "fin", "rx", "In", "b", "init", "inc", "socket", "f", "impl", "input", "vin", "din", "IN", "lin", "inn", "read", "s", "conn", "cin", "i", "is", "win", "kin", "reader", "rin", "inside", "nin", "stream", "l", "sub", "login", "inner", "min", "r", "id", "bin", "c", "err", "inter", "pin", "ini", "again", "line", "isin"]}}
{"id1": "3801655", "id2": "15580610", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"helper": ["workp", "scheper", "workmer", "helpler", "schepherd", "Helper", "harper", "sher", "helppherd", "harpherd", "scheHelper", "heller", "helpherd", "heler", "Heler", "helHelper", "shper", "harler", "worker", "Help", "workper", "shp", "helpper", "shmer", "help", "helmer", "scheler", "helpHelper", "harHelper", "Helmer"], "dataset": ["Dataset", "datrasets", "metasheet", " DatASet", "datasset", "datassets", "Datasets", "datASheet", "DatasET", "metasET", "datAset", " DatasET", "datAsets", "datapsET", "datAsheet", "datastets", "DatASeter", "datapsheet", "datacheet", "datasert", "datastet", " Datasheet", "datASet", "datasets", "DatASet", "datasteter", "datraseter", "datacert", "datrasET", "datacet", "metasert", "datASets", "datapset", " DatASheet", "metaset", " DatASets", " Datasets", " DatASET", "Dataseter", "datapsert", " Dataset", "datassert", "dataseter", "DatASET", "datASeter", "metassert", "DatASets", "datastET", "datasET", "datassET", "datAsET", "metassheet", "datASET", "datasheet", "metassET", "datassheet", "datraset", "metasset", "datacET"], "zip": ["java", "z", "pack", "ssl", "se", "copy", "system", "lock", "flat", "io", "data", "zone", "folder", "py", "f", "wrap", "tar", "loop", "archive", "bag", "split", "out", "code", "jar", "xml", "sea", "plugin", "parse", "dir", "directory", "pkg", "source", "ip", "Zip", "pdf", "slice", "pipe", "handler", "file", "gz", "window", "service", "binary", "sl", "bug", "git", "secure", "p"], "entries": [" entlines", "entents", "entlections", "ntries", "intries", " entities", "ntents", "iterents", "entities", "contry", "itries", "entryents", "itry", "entrees", "entrys", "contries", "entrylements", "contrys", "itents", "infries", "ENTrees", "iterries", "ntry", "ENTries", "contents", "entsries", "deents", "itrys", "inflines", "intlines", "intlements", "intities", "entryries", "entslections", "ENTrants", "ntrys", "delements", "infities", "inflections", "entlements", "deries", "entsrees", "ENTlections", " entlements", "inflements", "infrants", "entrants", "entlines", "entsrants", "infrees", "iterlements"], "performance": ["book", " u", "unit", " writers", "Unit", "stats", "ul", " ratio", "each", "it", " suite", "union", " split", " Units", "its", " unit", " units", "work", "slave", "units", "exec", " group", "U", " output", "runner", "ui", "rank", "util", " Unit", " result"], "index": ["page", "unit", "write", "length", "count", "offset", "Index", "num", "depth", "limit", "pos", "key", "type", "i", "iter", "number", "position", "id", "name", "order", "path", "x", "value", "level", "head"], "entry": ["pe", "install", "uri", "e", "write", "server", "se", "style", "connection", "cell", "info", "data", "child", "si", "ie", "part", "in", "folder", "it", "her", "result", "input", "route", "archive", "nt", "key", "row", "Entry", "element", "xml", "cel", "add", "record", "section", "parse", "stream", "inner", "r", "file", "obj", "service", "pattern", "or", "lc", "office", "feed", "export", "post", "ry"], "temp": ["partial", "original", "txt", "copy", "parent", "dest", "lock", "tc", "flat", "empty", "porary", "data", "single", "store", "io", "session", "part", "Temp", "output", "folder", "wrap", "f", "input", "archive", "valid", "storage", "template", "test", "out", "cel", "config", "iter", "directory", "tmp", "thread", "base", "table", "stable", "local", "cache", "pipe", "layout", "file", "binary", "w", "full", "ctx", "fake", "context", "path", "clean", "office", " temporary", "emp", "tem", "http", "p"], "writer": ["wave", "log", "wr", "write", "server", "io", "outer", "engine", "writing", "written", "output", "editor", "Writer", "feed", "key", "out", "player", "wer", "ws", "rw", "builder", "iter", "driver", "war", "element", "riter", "sw", "er", "worker", "stream", "inner", "r", "holder", "handler", "file", "wire", "loader", "w", "per", "writers", "layer", "wrapper", "ler", "or", "author", "manager"], "reader": ["write", "server", "rer", "ser", "io", "ner", "rar", "reading", "f", "Reader", "input", "editor", "upper", "element", "i", "builder", "iter", "driver", "stream", "er", "ter", "worker", "inner", "rr", "r", "handler", "file", "loader", "per", "wrapper", "ler", "or", "iterator", "oder", "http", "feed", "ri", "ry"], "buffer": ["wave", "buf", "write", "message", "resource", "server", "length", "null", "offset", "data", "Buffer", "sequence", "limit", "channel", "document", "result", "input", "batch", "bytes", "row", "source", "iter", "memory", "flush", "header", "size", "buff", "seed", "capacity", "queue", "position", "slice", "table", "address", "character", "initial", "binary", "device", "reference", "layer", "uffer", "transfer", "feed"], "read": ["save", "available", "book", "text", "k", "play", "default", "write", "report", "se", "length", "build", "count", "view", "g", "copy", "data", "child", "allow", "reading", "sync", "old", "raw", "ride", "connect", "check", "reads", "input", "READ", "Read", "run", "seek", "type", "end", "fill", "download", "process", "pass", "add", "parse", "print", "config", "size", "max", "work", "use", "iter", "ad", "send", "ind", "id", "skip", "load", "exec", "start", "find", "select", "wait", "next", "get", "x", "current", "close", "sleep", "eval", "feed", "open", "readable", "create"], "outfile": [" outfilename", " outf", "infile", " outdata", "instream", "outfilename", "indata", " outFile", "againdir", "logfilename", "outdir", "inFile", "outline", "inline", "inf", "Outline", "againline", "indir", "Outdir", "logdata", "againfile", "logfile", "infilename", "outdata", "outf", " outline", "logFile", "Outf", "outstream", "outFile", "Outstream", "Outfile", "againstream", " outstream"], "line": ["filter", "page", "text", "LINE", "log", "url", "frame", "lf", "le", "style", "letter", "item", "cell", "data", "link", "sync", "on", "range", "status", "str", "end", "split", "lin", "strip", "lines", "error", "inline", "type", "val", "job", "code", "pass", "el", "column", "band", "comment", "row", "parse", "cle", "section", "header", "side", "l", "ip", "object", "look", "string", "file", "Line", "name", "sel", "word", "ine", "block"], "parser": ["book", "angler", "lp", "server", "system", "par", "umper", "data", "test", "type", "plugin", "xml", "class", "builder", "parse", "driver", "plan", "er", "worker", "r", "string", "handler", "params", "loader", "Parser", "pattern", "per", "cher", "function", "pool", "wrapper", "ler", "oder", "manager", "p", "processor", "arser"], "list": ["filter", "array", "lp", "parent", "best", "info", "lists", "data", "part", "group", "member", "all", "right", "result", "map", "set", "LIST", "and", "val", "out", "test", "type", "plan", "li", "l", "er", "listed", "can", "base", "table", "r", "match", "v", "other", "left", "get", "pool", "chain", "collection", "p", "join"], "rule": ["pe", "ee", "style", "rol", "item", "ul", "event", "data", "group", "range", "model", "field", "str", "val", "row", "dict", "plugin", "class", "parse", "record", "rl", "li", "header", "er", "lr", "tree", "base", "table", "r", "match", "ule", "service", "rules", "per", "function", "layer", "Rule", "ri", "rate"], "measure": ["Measures", "speasured", "feasuring", "measured", "measuring", "feasures", "Measured", "Measuring", "speasuring", "feasure", "measures", "Measure", "feasured", "speasures", "speasure"]}}
{"id1": "11341711", "id2": "149935", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makeBackups", "makeCleanups", "createBackUp", "createBackdown", "makePickup", "makebackup", "makeCleanup", "createBackups", "makePickups", "createbackup", "createbackdown", "makebackdown", "createBackup", "makebackUp", "makeCleanUp", "makePickUp", "createbackups", "createbackUp", "makeCleandown", "makeBackdown", "makeBackUp", "makePickdown", "makebackups"], "dir": ["log", "direction", "url", "module", "build", "dest", "rc", "init", "DIR", "io", "data", "store", "md", "director", "folder", "group", "dep", "zip", "Directory", "d", "run", "done", "wd", "dict", "download", "pkg", "source", "config", "directory", "work", "db", "base", "cache", "desc", "ir", "file", "dist", "name", "up", "root", "lib", "diff", "path", "Dir", "manager", "doc"], "sourcedir": ["asourcedir", "sortedore", "seedir", "sodedirs", "ssodedIR", "seeddir", "asourcedore", "sourcedIR", "asortedirs", "ssodedir", "sourcedore", "sodedore", "ssourceddir", "sourcesiri", "sodeddir", "sodedir", "sodediri", "ssodeddir", "asortedore", "sourceddir", "sourcesore", "sourcesdir", "sourcesirs", "sourcesir", "ssourcediri", "sortedir", "asourcedirs", "sortedirs", "ssourcedIR", "sortedIR", "sourcedirs", "seedIR", "seediri", "ssourcedir", "ssodediri", "asortedir", "sourcesIR", "asourcedIR", "sodedIR", "sourcediri", "asortedIR"], "destinationdir": ["Destinationfolder", "Destificationdirection", "DestificationDir", "destinatorfile", "dominationDir", "destinationsfile", "destinatorDIR", "dominatorDir", "destinatefolder", "destinationsDir", "destinatordir", "destinatefile", "destificationdirection", "desturationDir", "destinationDIR", "dominatordir", "destificationfolder", "Destinationdirection", "destinationfolder", "destificationdir", "desturationdirection", "dominationfile", "destinatorDir", "destinationsdir", "dominationDIR", "destinatedirection", "destinateDIR", "destinationDir", "destinationdirection", "desturationdir", "dominatorDIR", "destinationfile", "Destificationdir", "destinationsDIR", "dominationdir", "destificationDir", "desturationfolder", "destinateDir", "destinatedir", "DestinationDir", "Destinationdir", "dominatorfile", "Destificationfolder"], "destinationDirEnding": ["destinationDirEndning", "destinationDirEndining", "destinationDirENDning", "destinationDirENDging", "destinationDirectoryEndING", "destinationPathEndning", "destinationDirSigning", "destinationDirPassging", "destinationPathBegining", "destinationDirSignING", "destinationPathEndING", "destinationDirLeadening", "destinationDirectorySignING", "destinationDirEndging", "destinationDirLeadining", "destinationDirPassing", "destinationDirENDing", "destinationDirectoryEndening", "destinationPathEnding", "destinationDirectorySignening", "destinationDirBeginging", "destinationDirPassING", "destinationDirLeading", "destinationDirEndening", "destinationDirSignening", "destinationPathEndging", "destinationDirectoryEndining", "destinationPathBeginging", "destinationDirSignining", "destinationDirLeadING", "destinationDirEndING", "destinationDirectoryEnding", "destinationDirENDING", "destinationDirPassning", "destinationDirBeginening", "destinationPathBeginning", "destinationDirectorySigning", "destinationDirBeginining", "destinationDirBeginING", "destinationDirBegining", "destinationDirBeginning", "destinationDirectorySignining", "destinationPathBeginING"], "files": ["ls", "fields", "keys", "log", "ins", "rows", "books", "modules", "ps", "users", "links", "data", "reports", "output", "sections", "planes", "groups", " Files", "parents", "features", "split", "classes", "projects", "index", "lines", "balls", "fs", "children", "ips", "docs", "objects", "xml", "results", "flows", "images", "thumbnails", "l", "resources", "pages", "ids", "names", "models", "file", "errors", "tests", "bugs", "locks", "actions", "iles", "rules", "blocks", "Files", "words", "types", "boxes", "events", "uploads", "services", "strings", "items", "its", "runs"], "checkdir": [" checklog", "ckfolder", "searchdirectory", "checkdirectory", "calldir", "calldirectory", "blockdirectory", "searchdir", "workFolder", "lockDir", "workdir", "blockdir", "Checkdir", "blockdraft", "workfolder", "workDIR", "ckd", "checkfolder", " checkDIR", "checkDir", "workfile", "callfolder", "worklog", "CheckDir", "checkd", "blockDir", " checkdirectory", "workdraft", "checkFolder", "locklog", "checkDIR", " checkfolder", "workDir", "ckDir", "ckdirectory", "calld", "workdirectory", "searchDir", " checkDir", "checkdraft", " checkd", "searchdraft", " checkfile", "checklog", "ckfile", " checkFolder", "Checkfile", "lockFolder", "lockdir", "CheckDIR", "checkfile", "ckdir"], "date": ["at", "m", "log", "e", "image", "late", " Date", "event", "tag", "data", "ge", "md", "mate", "zone", "now", "set", "d", "dat", "time", "open", "config", "ime", "contact", "month", "sign", "de", "user", "change", "day", "ate", "file", "Date", "start", "name", "age", "mu", "state", "update", "doc", "dt", "rate"], "msec": ["css", "rsecond", "rss", " minsec", "dsecond", "dsec", " minsc", " minSec", "Msecond", "msecond", "lsecond", "lsec", "misec", " msc", "mss", "dseconds", "mnsc", "rseconds", "Msec", "fmsec", "mnsec", "mnSec", "msc", "fmseconds", "mSec", "lseconds", "csec", "fmisec", "mnif", "cseconds", " mif", "disec", "mif", " minif", "mseconds", "Mseconds", "fmsecond", "Misec", "lss", "rsec", "csecond", " mSec"], "checkFile": ["CheckFile", " checkLine", "controlFile", "ckFiles", "changefile", "changeFile", "ckDirectory", "checkLine", " checkFiles", "controlfile", "workFile", " checkFilename", "checkDir", "workfile", "controlFilename", "checkFilename", "CheckDirectory", "changeLine", "CheckDir", "checkDirectory", "workFiles", " checkDirectory", "workDir", "ckFile", " checkDir", "checkFiles", "CheckFiles", " checkfile", "ckfile", "Checkfile", "changeFilename", "controlLine", "checkfile"], "i": ["m", "p", "u", "uri", "e", "j", "b", "n", "fi", "io", "info", "si", "ie", "part", "field", "index", "ci", "iu", "oi", "key", "ji", "is", "multi", "y", "li", "di", "im", "ip", "pi", "xi", "hi", "eni", "slice", "vi", "id", "ti", "gi", "v", "ix", "I", "ai", "phi", "ini", "ii", "ui", "bi", "x", "mu", "qi", "ri"], "f": ["fd", "m", "fn", "u", "fl", "fr", "e", "j", "sf", "b", "n", "fi", "fb", "info", "folder", "o", "d", "feed", "h", "fs", "l", "fun", "fx", "r", "v", "file", "fc", "t", "w", "cf", "F", "q", "fe", "fp", "p", "df"], "g": ["gar", "m", "og", "eg", "u", "e", "G", "gn", "b", "n", "pg", "erg", "ge", "msg", "reg", "ig", "group", "gd", "gin", "ga", "d", "gc", "rg", "vg", "ng", "gg", "go", "mg", "s", "h", "tg", "gm", "bg", "gh", "sg", "l", "ger", "r", "gi", "file", "gb", "gu", "global", "t", "w", "gp", "gs", "q", "p"], "destinationFile": ["destacementfile", "destationfile", "DestationFilename", "DestificationDir", "DestificationFile", "destiningDir", "Destationfile", "DestinationLocation", "destificationFile", "DestationDir", "destationFilename", "destinationsDir", "destinationsDirectory", "destiningfile", "destinationsFile", "DestinationFile", "DestificationLocation", "destinationDirectory", "destinatorDir", "destacementDir", "destacementFile", "destinationDir", "DestificationDirectory", "destinatorLocation", "destificationDirectory", "destacementFilename", "destinatorFile", "destinationsLocation", "destinationfile", "destificationDir", "destationDir", "DestinationDirectory", "DestationFile", "Destinationfile", "destinationFilename", "destificationLocation", "destinationLocation", "destationFile", "destiningFilename", "DestinationFilename", "destiningFile", "DestinationDir", "destinatorDirectory"], "sourceFile": ["SourceFile", "ourceDir", " sourceDir", "ourceFile", "ourceDirectory", "srcModule", "sourceDirectory", "inputFile", "srcDir", "Sourcefile", " sourceFiles", " sourceDirectory", "srcfile", "sourceModule", "sourcefile", "ourceFiles", "inputDirectory", "inputDir", " sourceModule", "SourceModule", "sourceFiles", " sourcefile", "inputFiles", "srcFile", "SourceDir", "sourceDir"], "infile": ["difffile", "InFile", "inputf", "winstream", "windir", "inputFile", "diffdir", "instream", "indata", "outdir", "inFile", "diffFile", " inFile", "inf", "indir", " indata", "Infile", "Inf", "Instream", "outdata", "winFile", "outf", "inputfile", "outstream", "outFile", "winfile", "inputdata", "inputstream", " instream", "diffstream"], "outfile": ["intstream", "againFile", "outfunction", "againpage", "inputFile", " outpage", " outFile", "intlive", "exFile", "intFile", "outline", "intfile", "Outline", "expage", "againfile", "inputfunction", "exstream", " outline", "inputfile", "outstream", "outFile", "Outstream", " outfunction", "Outfile", "Outlive", " outlive", "againstream", "outlive", "Outfunction", "OutFile", "inputline", " outstream", "outpage", "exfile"], "c": ["k", "m", "u", "ct", "z", "esc", "e", "col", "uc", "C", "b", "n", "rc", "dec", "channel", "in", "ec", "o", "d", "ch", "index", "cl", "ci", "h", "end", "code", "comment", "cu", "cm", "ice", "a", "l", "r", "xc", "id", "ac", "v", "pc", "string", "character", "abc", "t", "w", "cont", "x", "lc", "cy", "pointer", "enc", "cr", "p", "char"]}}
{"id1": "7809093", "id2": "12883117", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 1, "substitutes": {"getContent": ["setData", " getData", "GetBody", "requestEntity", "setBody", "requestBody", "requestContent", "responseOutput", "GetEntity", " getEntity", " getBody", "responseBody", "GetContent", "getBody", "setEntity", "getEntity", "getData", "requestOutput", "GetOutput", "GetData", "responseEntity", "responseContent", "getOutput", "setContent"], "request": ["req", "url", "uri", "message", "resource", "e", "server", "report", "connection", "method", "data", "application", "result", "input", "route", "Request", "type", "xml", "instance", "QUEST", "user", "queue", "r", "object", "position", "address", "string", "handler", "name", "reference", "path", "query", "current", "operation", "q", "http"], "sb": ["ls", "bsp", "lp", "sf", "b", "fb", "bt", "bp", "bh", "usb", "xb", "lb", "bc", "pb", "SB", "su", "rb", "lab", "cb", "bf", "abi", "amb", "bm", "bd", "src", "bg", "sg", "db", "ib", "abb", "bj", "zb", "BB", "sa", "gb", "sup", "binary", "obb", "wb", "sk", "vm", "buffer", "ab", "nb", "eb", "bs", "fp", "bb"], "client": ["proxy", "p", "console", "url", "default", "ssl", "uri", "resource", "server", "call", "connection", "force", "remote", "tc", "ce", "apache", "project", "session", "channel", "output", "application", "connect", "cl", "container", "conn", "plugin", "builder", "api", "config", "bird", "cli", "contact", "web", "Client", "util", "queue", "cache", "https", "con", "c", "handler", "app", "service", "net", "per", "host", "context", "current", "http"], "httpParams": ["httpParamas", "httpPoparams", "httpPams", "httpPoams", "HttpParams", "HTTPPareters", "HTTPParam", "httpPeramas", "httpPerparams", "httpPrams", "httpPARcs", "HTTPPoparams", "HTTPPoamer", "httpPareters", "HTTPPoams", "HTTPParums", "HTTPParamer", "httpPreters", "HttpParamas", "httpPeters", "HTTPParcs", "httpPamer", "httpParparams", "HTTPPoeters", "HTTPPARams", "HTTPParams", "HTTPPARam", "httpPoeters", "httpArcs", "HTTPParparams", "httpPeram", "httpParam", "HTTPPARums", "httpPramer", "HttpParam", "httpPoamer", "httpPparams", "httpAram", "httpPrparams", "httpParums", "httpPARamas", "httpArams", "httpParcs", "httpPerams", "httpPARams", "httpPARparams", "HttpParparams", "httpArums", "httpPARam", "HTTPPARcs", "httpPARums", "httpParamer"], "response": ["resp", "page", "respond", "resource", "report", "message", "server", "view", "Response", "connection", "body", "successful", "data", "output", "application", "status", "model", "result", "document", "reply", "error", "results", "api", "object", "success", "relation", "json", "collection", "http", "feed", "onse", "received"], "entity": ["pe", "component", "writer", "resource", "e", "server", "body", "connection", "Entity", "ce", "event", "data", "channel", "output", "model", "document", "entry", "result", "creator", "application", "coll", "translation", "ent", "type", "conn", "element", "instance", "xml", "source", "api", "article", "media", "agent", "node", "company", "object", "address", "file", "em", "environment", "json", "content", "collection", "http", "person"], "reader": ["writer", "server", "rx", "rer", "ser", "io", "ner", "parser", "reading", "rar", "in", "Reader", "input", "editor", "read", "row", "i", "source", "iter", "driver", "bird", "stream", "er", "rr", "worker", "inner", "r", "handler", "loader", "per", "ler", "buffer", "iterator", "oder", "feed", "ri", "ry"], "line": ["page", "LINE", "url", "unit", "message", "lf", "le", "cell", "data", "ge", "link", "sync", "no", "entry", "model", "definition", "str", "lin", "cl", "lines", "end", "key", "inline", "row", "el", "code", "val", "job", "pass", "source", "iter", "comment", "header", "li", "l", "ip", "len", "base", "user", "r", "id", "string", "character", "Line", "name", "sl", "sel", "layer", "word", "content", "lc", "non", "feed", "block", "char"]}}
{"id1": "1986417", "id2": "8182932", "code1": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 0, "substitutes": {"export": ["fn", " upload", "module", "write", " writer", "io", "output", "f", " fn", " reporter", "process", "print", " exports", "work", " transform", "exec", "handler", "file", " report", " output", "function", "fp"], "lib": ["fn", "log", "url", "module", "server", "script", "os", "io", "data", " libraries", "loop", "editor", " fn", " Library", "val", " library", " Lib", "dll", "plugin", "dl", "config", "library", "src", "reader", "ruby", "l", "db", "local", "LIB", "language", "Library", "bin", "file", "loader", " script", "ld", "ctx", " module", "ler", "lc", "ino", "lang", "Lib", "browser"]}}
{"id1": "13421722", "id2": "18374598", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "label": 0, "substitutes": {"getFileSize": [" getFileBytes", "getfileLength", "getFilesInfo", "getByteLength", "getfileInfo", " getfileLength", " getfileSize", "getByteBytes", "getFilesSize", "getByteSize", "getFileInfo", " getFileInfo", "getFilesBytes", " getfileInfo", "getfileBytes", " getfileBytes", "getFileBytes", "getFilesLength", " getFileLength", "getFileLength", "getByteInfo", "getfileSize"], "address": ["prefix", "attribute", "array", "uri", "localhost", "report", "resource", "server", "message", "offset", "data", "port", "output", "route", "str", "type", "Address", "code", "source", "addr", "config", "size", "network", "target", "ip", "number", "base", "point", "position", "object", "email", "string", "name", "reference", "host", "location", "path", "content", "format", "request"], "url": ["ur", "page", "proxy", "log", "uri", "ssl", "resource", "image", "server", "e", "ll", "html", "build", "loc", "io", "org", "session", "socket", "channel", "f", "impl", "result", "www", "URL", "str", "job", "conn", "xml", "api", "config", "client", "l", "web", "lr", "base", "user", "object", "found", "string", "orb", "file", "service", "ob", "sl", "host", "bug", "path", "Url", "location", "http", "feed", "lib"], "connection": ["to", "proxy", "uri", "resource", "server", "communication", "event", "io", "info", "version", "session", "socket", "bc", "channel", "Connection", "application", "entry", "connect", "out", "conn", "connected", "config", "section", "client", "control", "object", "position", "character", "handler", "c", "con", "service", "relation", "reference", "environment", "context", "function", "response", "wrapper", "or", "current", "condition", "collection", "http", "use", "request", "open", "database"]}}
{"id1": "10218878", "id2": "2168610", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"DecodeMapFile": ["DecoderMapFile", "DecodeDataFile", "DecodeMapFiles", "DecodemapFiles", "DecoderFileFiles", "DecoderMapfile", "DecodeDataFiles", "DecoderMapFiles", "DecodemapFile", "DecodeFileFile", "DecodeDatafile", "DecodeFileFiles", "Decodemapfile", "DecoderFileFile", "DecodeMapfile", "DecodeFilefile", "DecoderFilefile"], "mapFile": ["mapLog", "apperUrl", "fileTable", "addressfile", "MapFile", "mapFull", "apperFile", "loadFull", "mapUrl", "mapfile", "batchUrl", "mapTable", "addressTable", "MapUrl", "addressFull", "loadfile", "loadFile", "fileFile", "apperLog", "MapLog", "batchLog", "fileFull", "filefile", "batchFile", "loadTable", "addressFile"], "outputFile": ["outputFiles", "outputStream", "inputFolder", " outputFolder", "inputFile", "responseFile", "OutputFolder", "responseStream", " outputfile", "inputDir", "OutputStream", " outputFiles", "OutputFiles", "OutputDir", "outputDir", "outputFolder", " outputStream", "responseFiles", "responsefile", "OutputFile", "inputFiles", " outputDir", "Outputfile", "outputfile"], "magicKey": ["prefixKey", "specialKey", "techLink", " magickey", "magicK", " magicChar", "prefixKEY", "techKey", "techKEY", "magicSecret", "techkey", "cacheSecret", " specialLetter", "cachekey", " magicKEY", " specialKey", " specialkey", "MagicKey", " magicK", "magickey", "prefixLink", "prefixkey", "magicLetter", "MagicK", "MagicLetter", "cacheKey", "specialChar", "magicKEY", "magicLink", " magicLink", "magicChar", "cacheChar", "specialkey", " magicLetter", "Magickey", " magicSecret", " specialK", "specialSecret"], "buffer": ["wave", "buf", "pad", "array", "writer", "url", "message", "length", "count", "b", "offset", "null", "data", "Buffer", "shape", "document", "result", "input", "stack", "batch", "read", "row", "code", "source", "iter", "memory", "reader", "comment", "header", "buff", "seed", "base", "bar", "queue", "position", "variable", "slice", "cache", "address", "token", "binary", "reference", "pause", "layer", "uffer", "FFER", "transfer", "feed", "bb"], "nread": ["Nread", "enfind", "newrite", "pload", "neread", "nload", "enreads", "Nreader", "nRead", "nreader", "Nwrite", "Nfind", " nRead", "enwrite", "nereader", " nload", "NRead", "nfind", "Nload", "pwrite", "nwrite", "enRead", " nwrite", " nfind", "pRead", "enread", "Nreads", "neRead", " nreads", " nreader", "pread", "nreads"], "map": ["wave", "m", "maps", "pad", "pack", "flow", "module", "image", "one", "resource", "copy", "master", "write", "message", "core", "lock", "data", "group", "input", "index", "key", "out", "code", "apper", "source", "cm", "create", "parse", "config", "media", "client", "work", "stream", "pair", "header", "make", "over", "cache", "address", "ap", "MAP", "file", "app", "list", "per", "pre", "cover", "pool", "layer", "transfer", "bridge", "use", "block", "open"], "output": ["page", "exit", "console", "log", "unit", "write", "module", "resource", "image", "core", "flow", "connection", "outer", "data", "oper", "cut", "external", "application", "model", "document", "input", "o", "run", "sort", "error", "out", "pot", "Output", "config", "web", "target", "number", "queue", "control", "object", "cache", "address", "file", "ilo", "other", "reference", "ou", "global", "function", "layer", "response", "operation", "put", "office", "update", "utils", "export"], "i": ["m", "p", "u", "z", "uri", "e", "j", "length", "b", "io", "info", "si", "in", "f", "it", "o", "ci", "oi", "ji", "multi", "li", "di", "l", "a", "ip", "pi", "xi", "slice", "id", "uli", "ti", "v", "gi", "c", "t", "I", "ai", "phi", "zi", "ini", "ii", "ui", "x", "qi", "bi", "mu", "ri"]}}
{"id1": "14783950", "id2": "18696387", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressUsingJar", "compressUsingZip", "compressInZip", "compresswithZip", "compresswithSax", "compressedWithJar", "compressInSax", "compressedWithZip", "compressWithJar", "compressUsingSax", "compresswithJar", "compressInJar", "compressedWithSax", "compressedUsingJar", "compressedUsingZip", "compressedUsingSax", "compressWithSax"], "fileList": [" fileChain", "wordString", "FileStream", "zipSet", "FileString", "fileStream", "modelCollection", "wordName", "inputEx", "modelEx", "fileCollection", "FileSet", "fileString", "modelList", "wordStream", "modelStream", "FileList", "inputCollection", "fileEx", "FileChain", "filelist", " fileSet", "zipList", "inputList", "inputStream", "wordList", "ziplist", "fileChain", "stringName", " fileEx", "stringlist", " fileStream", "Filelist", " fileCollection", " fileString", "FileName", "stringList", "stringChain", "zipName", "fileSet", " filelist"], "zipFileName": ["folderGlobalPath", "archiveDirDir", "zipFullname", "zipDirname", "zipFileDir", "archiveDirPath", "zipGlobalNames", "zipFullPath", "folderGlobalname", "zipFilename", "archiveFileName", "archiveFilePath", "zipDirDir", "zipPackagePath", "zipFullName", "zipFileNames", "archiveDirName", "folderFileNames", "zipGlobalPath", "folderFileName", "zipFullDir", "zipPackageName", "zipPackageDir", "folderGlobalName", "zipDirNames", "zipDirName", "archiveFileDir", "zipFullNames", "zipGlobalName", "zipDirPath", "zipFilePath", "folderFilename", "folderFilePath", "zipGlobalname", "folderGlobalNames"], "fos": ["Fosh", "infoS", "Fos", "flos", "faos", "infos", "fosh", "infaos", "afoS", "foS", "flis", "Faos", "FoS", " fosh", "afaos", "infis", "flosh", "afis", "afos", "Fis"], "zos": ["css", "zz", "ros", "dos", "closure", "z", "fits", "kos", "tz", "fi", "ZA", "os", "jas", "jobs", "ozo", "osi", "uz", "iframe", "nz", "cos", "loop", "zip", "es", "bis", "bos", "lins", "bag", "chini", "zes", "oses", "zzy", "seconds", "abi", "zik", "lol", "bes", "zar", "zag", "zo", "zers", "zen", "LOS", "outs", "zl", "rez", "ses", "onz", "zb", "ZI", "packs", "gz", "zx", "zer", "zy", "webkit", "obb", "zi", "phi", "zon", "zan", "spin", "budget", "inos"], "iter": ["enter", "inse", "fr", "e", "itter", "ser", "loc", "outer", "oper", "ner", "inc", "ie", "it", "f", "set", "index", "upper", "finder", "sort", "coll", "end", "test", "ener", "el", "gener", "i", "is", "parse", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "slice", "ir", "file", "err", "fer", "list", "Iter", "inter", "ator", "izer", "next", "ite", "order", "cher", "liter", "iner", "chain", "iterator", "iz", "http"], "fileName": ["filenamename", "pageString", "FileString", " filePart", "FileUrl", "fName", "filePath", " filePath", "localname", "fileOpen", "filenameName", "currentname", "fileData", " fileLine", " fileType", " fileData", "FileFull", "fullOpen", "fileString", " fileFull", "fileType", "FilePart", "simplePath", "filenameInfo", "fileUrl", "currentData", "pageType", "currentName", " fileUrl", "FileLine", "pagename", "localPart", "fileInfo", "filename", "localName", "currentUrl", "simpleOpen", " fileInfo", "Filename", "FileInfo", "FilePath", " filename", "fPart", "fileFull", " fileString", "FileName", "fullPath", "localPath", "filePart", "FileData", "fullName", "fLine", "pageName", "FileType", " fileOpen", "fileLine", "simpleName", "filenameFull", "fname"], "ind": ["bind", "fr", "z", "vert", "nd", "j", "length", "count", "loc", "mid", "ded", "inc", "pos", "in", "cond", "pt", "index", "inn", "d", "ci", "val", "end", "eff", "i", "pull", "dir", "rib", "len", "ad", "id", "div", "ord", "IND", "start", "ld", "ix", "mind", "ii", "x", "Ind", "wind", "pend"], "shortName": ["Shortname", "ShortPath", " shortString", "longName", "smallname", "shortPart", "ShortString", "shortname", "ShortPart", "smallPart", "shortPath", "shortString", "ShortName", "longPart", "shortLine", "smallPath", "fullname", " shortPath", "longLine", "fullString", " shortname", "smallName", "longPath", "longname", "fullPath", "fullName", "fullLine", " shortLine"], "fis": [" fiss", "pisa", "fisa", "Fos", "fris", "cfis", "Fiss", "gisa", " fris", "cfs", " fisa", "gis", "fs", "pis", "fios", "Fs", "gios", "pris", "fiss", "pios", "cfiss", "gris", "afiss", "cfris", "cfos", " fs", "afris", "afis", " fios", "afos", "Fis"], "buf": ["fd", "cv", "uf", "bu", "uc", "b", "loc", "rc", "fb", "data", "bh", "bp", "lb", "feat", "bc", "pb", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cur", "bf", "bd", "grab", "tmp", "buff", "ff", "queue", "ba", "br", "v", "lim", "bin", "la", "vec", "wb", "bl", "buffer", "seq", "box", "bb"], "bytesRead": [" bytesLength", "flowsWrite", "tesRead", "flowsRead", "bitsSkip", " bytesWrite", "bitsLength", "bitsRead", " bytesNeed", " bytesLoad", "bytesNeed", "bitsWrite", "tesWrite", "tesSkip", "bitsUse", "secondsRead", "wordsWrite", "bytesUse", "wordsUse", "bitsLoad", "secondsWrite", "bytesSkip", "tesLoad", "wordsRead", "bytesLoad", "bytesLength", "secondsLength", "bytesWrite", "flowsNeed", "secondsNeed", "flowsLength", " bytesUse", "wordsLength", " bytesSkip"]}}
{"id1": "13657527", "id2": "16931472", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatAsetsSearch", "getDatAsetSearch", "getDatAsetsList", "getDatasetsSearch", "getDatasencieslist", "getDatasenciesList", "getDatasetslist", "getDatasureslist", "getDatasetList", "getDatasetSearch", "getDatasetlist", "getDatAsetList", "getDatAsetlist", "getDatasuresList", "getDatasenciesSearch", "getDatasuresSearch", "getDatAsetslist"], "surl": [" shttp", "srule", "slog", "nsuri", "wsurl", "dlayer", "sUrl", "Surl", "ssl", "dsfile", "nsjob", "sesjob", "sesurl", "Shttp", "Srule", "osfile", "ossl", "osuri", "sinrule", "wslayer", " sURL", "wssl", "ssjob", "slurl", "sinurl", "sesuri", "jssl", "sjob", " sUrl", "durl", "Sfeed", "SURL", "dsl", "jslayer", "shttp", "sinfeed", "jsuri", "wsuri", "tsl", "lsUrl", "slrule", "slfeed", "sinlog", "turl", "slayer", "nsfile", "duri", "sfile", "ssurl", "jsurl", "turi", "osurl", "sesfile", "lshttp", "SUrl", "sllog", "tfile", "dsurl", "dsuri", "ssfile", "nsurl", "dssl", "sURL", "lsurl", "Slog", "ssuri", "suri", "sfeed", "lsURL"], "datasetsList": ["datrasuresMap", "datasetsPool", "datastersMap", "datasuresCollection", "datrasetsMap", "datassETSList", "datrasETSMap", "datasetsCollection", "datasetMap", "datrasetsList", "datrasETSList", "datrasureslist", "dataschesMap", "datastersCollection", "datasetL", "datasencesMap", "datassetsCollection", "datasETSCollection", "datrasetsL", "datassETSPool", "datasetList", "datasuresL", "datascetsCollection", "datasetsL", "datasencesCollection", "datasagesMap", "datascheslist", "datasETSTable", "datasETSlist", "datascencesString", "datetetsList", "dataschesList", "datrasetslist", "datassetsPool", "datascencesList", "datasureslist", "datasETSPool", "datasetslist", "datascetsMap", "datetsetsL", "datetetsMap", "datasuresMap", "datasencesList", "dataselinesTable", "datasetsMap", "datasetsString", "datassETSMap", "dataselineslist", "datassetsList", "datassETSCollection", "datrasETSlist", "datasagesCollection", "datasagesList", "dataschesTable", "datasetlist", "datascetsString", "datasitesL", "datrasuresL", "dataselinesMap", "datastersString", "datascencesCollection", "datastersList", "datasitesMap", "datetetslist", "dataselinesList", "datascencesMap", "datasagesPool", "datascetsList", "datasuresString", "datetsetslist", "datasETSL", "datrasETSTable", "datasiteslist", "datassetsL", "datasitesList", "datetsetsMap", "datetsetsList", "datrasuresList", "datasencesString", "datasuresList", "datasetsTable", "datetetsL", "datassetslist", "datasETSMap", "datasETSList", "datassetsMap", "datrasetsTable"], "result": ["page", "res", "fr", "default", "report", "message", "resource", "rc", "event", "info", "ge", "ner", "rar", "part", "entry", "status", "rule", "valid", "end", "test", "row", "results", "instance", "comment", "record", "Result", "inner", "user", "r", "found", "match", "load", "card", "success", "repl", "re", "ret", "response", "runner", "request"], "reader": ["roller", "writer", "older", "ssl", "resource", "server", "rx", "rer", "ser", "dr", "io", "parser", "reading", "ner", "rar", "entry", "her", "Reader", "input", "editor", "upper", "read", "row", "i", "builder", "iter", "driver", "stream", "er", "l", "lr", "inner", "rr", "ger", "worker", "r", "slice", "over", "handler", "err", "file", "loader", "per", "cher", "layer", "runner", "keeper", "ler", "buffer", "oder", "http", "feed"], "url": ["ur", "page", "log", "ssl", "uri", "ll", "resource", "server", "image", "b", "connection", "io", "socket", "entry", "f", "rule", "str", "URL", "bel", "element", "source", "iter", "driver", "client", "l", "stream", "lr", "base", "user", "address", "string", "file", "loader", "service", "sl", "Url", "buffer", "hub", "http", "feed", "browser"], "s": ["ls", "u", "js", "ins", "ssl", "e", "server", " lines", "b", "details", "ss", "n", "os", "ps", "rs", "ns", "si", "sync", "search", "sb", "f", "spec", "es", "site", "ings", "str", "o", "comments", "su", "sets", "lines", "ws", "i", "source", "is", "l", "r", "ses", "S", "string", "less", "t", "sl", "ops", "words", "abs", "services", "strings", "line", "p", "ds"], "list": ["ls", "array", "default", "ll", "server", "null", "view", "letter", "pl", "ul", "data", "lists", "entry", "all", "str", "LIST", "coll", "set", "batch", "cl", "and", "key", "type", "test", "el", "val", "record", "li", "listed", "l", "base", "table", "queue", "string", "load", "ml", "la", "left", "bl", "lc", "chain", "collection", "join"]}}
{"id1": "15051083", "id2": "19687456", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessageDesignest", "getmessageDigest", "getMessageDigester", "getMessageHashest", "getMessageHashests", "getMessageHashester", "getmessagedigester", "getmessageDigester", "getMessagedigester", "getmessagedigests", "getMessageHashature", "getMessageDigature", "getMessageDesignature", "getMessagedigature", "getmessageDigature", "getMessageDesignests", "getMessageDigests", "getMessagedigest", "getMessagedigests", "getmessagedigest", "getmessagedigature", "getMessageDesignester", "getmessageDigests"], "digest": ["Diger", " Digest", "digiter", "hexest", "greatest", "hexEST", "sandest", "DigEST", "Digger", " digEST", " digeter", "greatiter", "Digeter", "feedester", "Digex", "Digester", "digEST", "Digest", " digested", " Digeter", "sandesting", " digex", "digesting", "greatester", "hexex", " Digger", "sandester", "signest", "digger", "sandested", "hexests", " diger", " Dighed", "greatested", " digests", " Digester", " digester", " digger", "signested", " Diger", "digeter", "Digested", "Digesting", "digester", "digex", "signester", "Digests", "digests", "dighed", "Dighed", "Digiter", "diger", " dighed", "digested", "signesting", "feedest", "feedested", "signiter"], "node": ["component", "Node", "uri", "one", "resource", "server", "module", "parent", "n", "connection", "remote", "event", "child", " nodes", "document", "ode", "route", "index", " source", "element", "instance", "source", "config", " parent", "network", "self", " annotation", "point", "internal", "object", "local", "address", "name", "entity", " namespace", "root", "global", " Node", "location", "path", " child", "odes"], "external": ["intern", "ex", "ternal", "resource", "e", "n", "remote", " remote", "outer", "international", "outside", "foreign", "External", "tern", "multiple", "out", "element", "instance", "source", "network", "client", "target", "Intern", "internal", "object", "local", "https", "account", "name", "secondary", "global", "binary", "reference", " foreign", "environment", " global", " External", "export"], "messageDigest": ["messageMarkester", "messageModester", "messageSignested", "MessageDigest", "messagedigger", "messageMarkested", "messageModesting", "messageDigested", "messageDesignesting", "messagedigest", " messageHashest", "messageDigesting", " messageHashesting", "messageHashesting", "messageDesignest", " messageDesignger", "MessageSignest", "messageDesignger", " messageDigesting", "messageMarkenge", "messageDest", "messagedigester", " messageDigger", " messageDesignest", "messageSignenge", "messageDenge", "messageDesignested", "messageDigger", "messagedigested", " messageDigester", "messageModest", " messageDesignester", "messageHashest", "MessageSignester", "messageModested", "MessageDigenge", "MessageSignested", "messageDigenge", "messageDesignester", "messageSignest", " messageHashested", "messageDested", "messageMarkest", "messageSignester", " messageDigested", "MessageDigester", "MessageDigested", "messageHashested", "messageDester", "MessageSignenge", "messageHashester", " messageHashester", " messageDesignested", "messageDigester"]}}
{"id1": "20028790", "id2": "19520541", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBindingIdDefault", "setBundleIdName", "setBindingInfoPart", "setBundleDirName", "setBundleIdDefault", "setBindingInfoName", "setBundleInformationList", "setBindingIdList", "setBundleInfoList", "setBindingInfoList", "setBundleInformationName", "setBundleDirPart", "setBundleInfoDefault", "setBundleDirDefault", "setBindingInfoDefault", "setBundleIdPart", "setBundleInfoPart", "setBundleDirList", "setBundleInformationPart", "setBindingIdPart", "setBundleInformationDefault", "setBindingIdName", "setBundleIdList"], "location": ["description", "uri", "localhost", "resource", "message", "server", "loc", "remote", "database", "data", "link", "station", "folder", "area", "site", "Location", "URL", "href", "type", "xml", "selection", "library", "directory", "filename", "LOC", "l", "point", "base", "node", "position", "address", "language", "string", "layout", "file", "loader", "region", "path", "content"], "list": ["array", "we", "parent", "data", "lists", "later", "part", "sequence", "group", "range", "entry", "all", "result", "LIST", "set", "stack", "batch", "cl", "coll", "the", "see", "i", "record", "li", "keep", "l", "listed", "cli", "tree", "pair", "table", "queue", "object", "string", "load", "mentioned", "detail", "name", "chain", "there", "collection"], "url": ["uri", "fr", "resource", "ssl", "server", "b", "connection", "loc", "io", "org", "data", "socket", "f", "URL", "bel", "jar", "source", "reader", "l", "stream", "lr", "base", "user", "r", "address", "string", "orb", "file", "err", "service", "sl", "plug", "Url", "buffer", "http", "bb", "open", "browser"], "br": ["buf", "res", "bro", "fr", "arr", "b", "body", "dr", "mr", "io", "yr", "data", "bh", "bc", "result", "str", "rb", "ch", "brush", "handle", "BR", "jar", "i", "reader", "ar", "stream", "er", "ber", "bar", "tr", "r", "err", "obj", "ob", "gr", "sr", "sp", "hr", "bl", "ler", "Br", "bridge", "cr", "bb", "img", "browser"], "line": ["page", "LINE", "text", "log", "lf", "e", "le", "b", "style", "connection", "letter", "lock", "cell", "data", "link", "sync", "shell", "part", "entry", "status", "result", "zip", "rule", "str", "split", "lin", "strip", "cl", "lines", "nl", "job", "inline", "row", "band", "code", "pass", "phase", "error", "source", "parse", "section", "header", "l", "license", "lr", "look", "string", "character", "file", "Line", "name", "up", "response", "lo", "word", "lc", "non", "block"], "pos1": ["pos2", "Pos0", "indexOne", "pos3", "POSN", "posOne", "POSOne", " posOne", "POS3", "Pos1", "Pos2", "POS1", "PosOne", "position2", "position0", " posN", "position3", "posN", "index0", "positionOne", " pos2", "index1", "part3", "part2", "pos0", "PosN", " pos3", "part1", "position1", "index2", "Pos3"], "bundleSymbolicName": ["bundleSymbolicKey", "bundleSyMBicalName", "bundleSymbriticalName", "bundleSymbicInfo", "bundleSymbillyName", "bundleSymbicallyname", "bundleSyMBolicName", "bundleSymbicModule", "bundleSymbicallyWord", "bundleSysembolicname", "bundleSymbillyInfo", "bundleSymbicalModule", "bundleSymbolicModule", "bundleSymbriticalWord", "bundleSymbuousWord", "bundleSyMBicalPart", "bundleSymbicalPath", "bundleSysembuousUrl", "bundleSymbicallyUrl", "bundleSymbicName", "bundleSyembolicInfo", "bundleSyembicKey", "bundleSymbuousUrl", "bundleSymbularPart", "bundleSymbicalKey", "bundleSysembolicUrl", "bundleSymbicalInfo", "bundleSymbuousName", "bundleSymbularPath", "bundleSymbuousname", "bundleSymbillyModule", "bundleSymbularString", "bundleSymbigiousName", "bundleSymbolicString", "bundleSymbicKey", "bundleSymbolicInfo", "bundleSyMBolicString", "bundleSymbolicUrl", "bundleSymbicallyName", "bundleSymbillyKey", "bundleSyembicModule", "bundleSymbularName", "bundleSymbriticalUrl", "bundleSymbicalString", "bundleSyembicName", "bundleSysembuousWord", "bundleSyMBicalPath", "bundleSyembolicName", "bundleSymbigiousPath", "bundleSymbigiousPart", "bundleSyembolicKey", "bundleSymbolicname", "bundleSymbigiousString", "bundleSymbolicPath", "bundleSyembicInfo", "bundleSysembolicWord", "bundleSyMBolicPart", "bundleSyembolicModule", "bundleSymbolicWord", "bundleSymbolicPart", "bundleSysembuousname", "bundleSyMBicalString", "bundleSymbicalName", "bundleSysembolicName", "bundleSymbicalPart", "bundleSymbriticalname", "bundleSyMBolicPath", "bundleSysembuousName"], "bundleName": ["rbundleType", "baffleInfo", "BundleName", "BendorInfo", "BpackageName", "bridgeDesc", "BundleDesc", "babiname", "bpluginName", "rbpluginname", "bendorID", "boodleID", "rbundleName", "bendorname", "BundleInfo", "bpluginInfo", "bblName", "BundleID", "bafflename", "bridgeInfo", "bpackageInfo", "bendorName", "bundleID", "bpackageName", "rbpluginName", "bblID", "BpackageDesc", "babiInfo", "BendorID", "bblname", "bendorInfo", "bundleType", "baffleType", "Bendorname", "bendorType", "rbundleInfo", "bpackageDesc", "BpackageInfo", "babiName", "Bpackagename", "Bundlename", "boodleInfo", "bundlename", "bpluginname", "bundleInfo", "boodlename", "bridgeName", "rbpluginType", "rbpluginInfo", "rbundlename", "BendorName", "bpluginType", "baffleName", "bundleDesc", "boodleName", "bridgename", "babiDesc", "bpackagename", "bblInfo"], "info": ["filter", "available", "fo", "image", "b", "Info", "off", "data", "link", "child", "part", "alias", "entry", "f", "py", "result", "check", "zip", "archive", "index", "error", "INFO", "end", "type", "key", "inf", "ignore", "tf", "i", "comment", "api", "parse", "li", "of", "base", "fw", "object", "id", "string", "gi", "handler", "file", "obj", "start", "name", "def", "extra", "by", "next", "diff", "bug", "op"]}}
{"id1": "8328527", "id2": "3495460", "code1": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"insertJobLog": ["createJoblog", "insertJoblog", "insertjoblog", "createJobHistory", "insertWorklog", "insertjobHistory", "createjoblog", "insertjobLog", "insertJobHistory", "insertJLog", "createjobLog", "insertWorkHistory", "createjobHistory", "createJobLog", "insertJlog", "createjobEntry", "insertjobEntry", "insertWorkLog", "insertWorkEntry", "createJobEntry", "insertJEntry", "insertJHistory", "insertJobEntry"], "userId": ["USERID", " userType", "useID", " userID", "useId", "UserDb", "useName", "UserData", "customId", "customID", "useType", "UserType", "customDb", "userName", "UserID", "UserName", "USERName", "userData", "customData", " userDb", "userID", "userType", " userData", "userDb", "USERId", "UserId"], "checkId": ["updateId", "pullType", "CheckInt", "CheckPath", "pullPoint", "checkInt", "pullID", " checkInt", "CheckId", "userInt", "checkPoint", "checkPath", "userPoint", "workID", "CheckType", "workId", "jobPath", "updateInt", "jobId", "updateID", "jobID", "pullInt", "checkID", "CheckPoint", " checkID", " checkPath", "workerID", "workerInt", "updatePoint", "workPoint", " checkPoint", "workType", "workerId", "userID", "jobPoint", "pullId", "CheckID"], "checkType": ["checkRole", "taskID", "taskId", " checkLength", "CHECKID", "taskType", "checkLength", "blockType", "CheckTyp", "CHECKRole", "CheckId", " checkRole", " checkTyp", " checkTypes", "taskInfo", " checkInfo", "workInfo", "CHECKTyp", "CheckLength", "workID", "CheckTypes", "CheckType", "workId", "CHECKType", "checkTypes", "blockId", "checkID", " checkID", "checkTyp", "CheckRole", "blockTypes", "checkInfo", "workType", "blockLength", "CheckID"], "objType": ["checkName", "opName", "ObjTy", "ObjId", "objectTy", "objName", "objectType", "objectTyp", " objName", "ObjTypes", " objTy", "objTypes", "objId", "objectName", "ObjTyp", "objectId", "checkTyp", "ObjType", "opId", "opType", "objTyp", "objectTypes", "objTy", "ObjName", "opTypes", " objId"], "dbo": ["Dbo", "DBO", "jbo", "jbf", "adBO", " dBo", "dko", "adBo", "adbo", "Dbf", "mBo", "drBO", "Dko", "dBo", "mbu", "dBO", " dbl", "Dbu", "dbf", "adbm", "dbu", "drko", "dbm", "drBo", "DBo", " dko", "Dbl", "drbl", "drbm", "drbo", " dBO", "Dbm", " dbm", "dbl", "jBo", "mbf", "jbu", "mbo"], "connection": ["statement", "management", "log", "subject", "unit", "resource", "message", "server", "communication", "b", "loc", "lock", "io", "session", "engine", "socket", "bc", "channel", "Connection", "application", "document", "connect", "ion", "mc", "index", "graph", "ci", "union", "conn", "connected", "driver", "config", "section", "client", "directory", "BC", "db", "position", "cache", "con", "c", "relation", "service", "ctx", "context", "pool", "response", "condition", "function", " Connection", "current", "query", "collection", "manager", "database"], "preStm": ["preColv", "preStmt", "prStmr", " preShms", "preClv", "preShpm", "preRestd", "preRM", "PREStfm", "preScf", " preShM", " preStmt", "preStv", "PREStmt", " preStmd", "preStM", "preInstm", "prestfm", "preScms", "preClM", "preStrm", "preStreamms", "preRm", "preEdmd", "preEdm", "PREStms", " preShf", "preScfm", "preStms", "synEstm", " preShv", "preStreamm", "preShv", "cleanClm", "preRms", "preRv", "preEstmt", "cleanClmn", "preSlam", "preEdmt", " preTrmn", "preClmn", "preShM", "preEstms", "synStd", "PREStmn", "preConstmn", "preStmd", "preRestM", "preSTrm", "PRERestfm", "prStm", "preSTms", "preInstvm", "preShms", " preStma", "preStrms", "preSlm", "synStms", "preStd", "preDisf", "PREEstmt", " preShm", "cleanStm", "preStrd", "PRERestm", "preScvm", "preEstvm", "preConstmt", "synStm", "preEstm", "cleanStM", " preStam", "preStma", "preStreamvm", "preStrM", "PREEstM", "prestvm", "PRERestmt", "preConstam", "preStmr", "preSTmd", " preTrmt", " preRmd", "prDispm", " preRrm", " preStmn", " preStfm", "prestf", "preRmd", "preColm", "preEdfm", "preColM", "preStvm", " preScm", "prestm", "preShmt", " preScfm", "PREStM", "cleanStmn", "preRestms", "preEdms", "preRestmn", "preConstm", " preRm", "preScm", "preShma", "preRestfm", "preShmr", " preStf", " preStrm", "PREStm", "prestmr", "prDisf", "preRestm", "preShf", "preSlfm", "preRrm", "preRestmt", "cleanClM", "preShvm", "preSlf", "preSlmt", "cleanStv", "prDism", "PREEstms", "preSlma", "preStam", "preStpm", "prStpm", "preStreamM", "preInstms", "preInstfm", "preTram", "preClm", " preStms", "prDismr", "synEstM", "preDism", "preStmn", "PRERestmn", "preColmn", "synEstms", "preTrm", "preRmn", "preStf", " preRms", " preShma", "preTrmn", "preSlv", "preEstd", " preShvm", "preSlmn", " preStv", "prStf", "preScma", "preEdrm", "preSTm", " preStM", " preTram", "cleanClv", " preStvm", " preScms", "preDispm", "preEdmn", " preScvm", "prestpm", "preEstM", "PREEstm", "synEstd", "preStfm", "prestms", " preTrm", "preTrmt", "synStM", "preScv", "preDismr", "preShm"], "sql": ["ls", "fn", "expr", "statement", "sol", "log", "url", "ssl", "html", "body", "pg", "msg", "shell", "sync", "limit", "zip", "str", "sn", "job", "nl", "conn", "sq", "dl", "plan", "l", "seed", "db", "eps", "string", "params", "select", "printf", "sl", "function", "query", "where", "q", "database", "SQL", "ql", "join"], "cleanSql": [" cleanSprintf", " cleanCQL", "cleanAsql", "cleanPsq", " cleanAsprintf", "cleanEsprintf", "cleanCql", "cleanAsQL", "cleanEssql", "cleanAswl", " cleanCsql", "cleanSwl", " cleanCql", " cleanAsql", "cleanPssql", " cleanSwl", "cleanPsql", "cleanSq", "cleanSsql", " cleanCwl", " cleanSsql", "cleanStql", "cleanAsprintf", "cleanStwl", "cleanSprintf", "cleanAssql", " cleanAssql", "cleanCsql", " cleanSq", " cleanSQL", "cleanCQL", "cleanStsql", "cleanCwl", "cleanSQL", "cleanEsq", " cleanAsq", "cleanEsql", "cleanAsq", "cleanStQL", "cleanPsprintf"], "dCount": ["DCount", "dNumber", "dhNumber", "dhCounter", "dcount", "dhCount", "DNumber", "DCounter", "dhcount", " dNumber", "dCounter", "Dcount", " dCounter", " dcount"], "sHaveIns": ["shaveINS", "sHaveContents", "shaveins", " sHaveins", "sHavingIns", "sHaveWs", "sHaveINS", "sHavingINS", "pHaveins", " sWithNoINS", "sHasINS", "sHavingWs", "pHaveWs", "sWithNoINS", "sHadIn", "sAreWs", " sWithNoContents", "sHaveins", "phaveINS", " sHaveINS", "sHavingins", "sAreins", "sWithNoContents", "phaveWs", "shaveWs", "sHasIns", "sWithNoIn", " shaveIns", "pHaveIns", "sAreIns", "phaveins", "sHadIns", " sHaveIn", " shaveins", "sWithNoIns", "sWithNoins", "sHasContents", "sHaveIn", "phaveIns", " sHaveContents", "shaveIn", "pHaveINS", " sWithNoIns", "sAreContents", "shaveIns", "sAreINS", "sHadins", " shaveIn"], "j": ["ij", "k", "js", "u", "fr", "z", "b", "g", "n", "num", "lock", "off", "kj", "journal", "jc", "ie", "part", "syn", "f", "jj", "jet", "ja", "jit", "ch", "dj", "job", "uj", "key", "h", "ji", "J", "el", "aj", "jo", "i", "pr", "y", "section", "oj", "li", "l", "bj", "ind", "br", "v", "obj", "vol", "adj", "jl", "x", "jp", "p"]}}
{"id1": "4599372", "id2": "7908169", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"readFixString": ["readFixedContent", "readAdjustString", "readFixArray", "readFixedArray", "readFixContent", "createFixedContent", "readfixstring", "createFixContent", "readFixedString", "readFixedstring", "readAdjustArray", "createFixArray", "readAdjuststring", "readFixstring", "createFixstring", "createFixedstring", "readAdjustContent", "readfixArray", "createFixedArray", "createFixedString", "readfixContent", "createFixString", "readfixString"], "len": ["fn", "ln", "lp", "lf", "e", "ll", "le", "length", "count", "n", "body", "en", "loc", "enc", "data", "part", "limit", "pos", "f", "str", "split", "lin", "Len", "val", "code", "el", "i", "size", "li", "l", "lit", "base", "string", "file", "list", "sl", "lc", "lt", "line"], "sw": ["bb", "writer", "wr", "iw", "fl", "sf", "wt", "null", "ss", "aw", "sv", "io", "serv", "wra", "sb", "es", "zip", "so", " SW", "sn", "ow", "ew", "ws", "rw", "wx", "nw", "SW", "stream", "wp", "WS", "Sw", "fw", "sc", "lv", "wa", "sa", "ww", "w", "sl", "sp", "sr", "wb", "sh", "tw", "wh", "hw"]}}
{"id1": "647224", "id2": "20724937", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "label": 0, "substitutes": {"uploadFile": ["Uploadfile", "uploadFiles", " uploadfile", " uploadDir", "uploadfile", "processDir", "UploadFile", "UploadDir", "processfile", "processFile", "uploadDir", " uploadFiles", "processFiles", "UploadFiles"], "inputFile": [" inputfile", "targetFolder", "inputPage", "InputFiles", "sourceLog", "inputFolder", "sourceType", "InputFile", " inputFiles", "InputDir", "targetDir", " inputDir", " inputFilename", " inputType", "sourceFolder", "initialFilename", "targetPage", "initialFolder", " inputFolder", " inputLog", "sourcePage", "targetStream", "targetFiles", "inputType", "sourceFile", "inputStream", "sourcefile", "initialFile", " inputStream", "inputFilename", "targetfile", "InputType", "targetFilename", "InputFolder", "inputDir", "initialStream", "inputfile", "targetLog", "inputFiles", " inputPage", "sourceStream", "inputLog", "InputStream", "Inputfile"], "targetFile": ["outputFiles", " targetName", "Targetfile", "outputLine", "outputName", " targetDir", "TargetName", "inputPlace", "targetPath", "targetDir", "TargetLine", "externalPath", " targetFiles", "externalFile", " targetfile", "TargetFile", "targetLine", "targetFiles", "sourcePlace", "sourceFile", "externalfile", "TargetDir", "targetPlace", "TargetPath", "outputPath", " targetLine", "targetfile", "inputDir", "TargetFiles", " targetPlace", " targetPath", "outputDir", "externalName", "sourcePath", "targetName", "sourceDir", "inputPath"], "outputFile": ["outputFiles", "outputStream", "inputPage", " targetDirectory", "currentFile", "currentFolder", "inputFolder", " outputFolder", "writeFile", "targetPath", "writeStream", "outputPlace", " targetFiles", "inputQueue", " outputPath", " outputDirectory", " outputPlace", "OutputFolder", "outPlace", "inputUrl", "outFolder", "targetFiles", " targetQueue", "targetQueue", " outputfile", "outputDirectory", "outfile", "currentPlace", "outputUrl", "inputStream", "outputQueue", "outputPath", "writeUrl", "targetfile", "outDirectory", "inputDirectory", "inputDir", " outputFiles", "OutputDir", "outputDir", "targetDirectory", "outputFolder", "inputfile", "outPath", "currentfile", "outputPage", " outputPage", "outFile", " outputUrl", " outputStream", "OutputFile", "inputFiles", " outputDir", "writePage", "Outputfile", "outputfile", "inputPath"], "in": ["rec", "ins", "url", "In", "init", "io", "data", "inc", "input", "din", "IN", "lin", "inn", "read", "s", "pass", "cin", "i", "is", "win", "pull", "reader", "kin", "issue", "inside", "nin", "stream", "rin", "login", "sub", "inner", "r", "id", "ac", "bin", "err", "con", "up", "diff", "pin", "ini", "source", "again", "serv", "isin"], "out": ["to", "page", "ex", "log", "writer", "console", "write", "report", "one", "image", "copy", "plain", "n", "cmd", "lock", "io", "off", "data", "outer", "sys", "this", "sync", "inc", "output", "o", "Out", "error", "s", "conn", "source", "print", "client", "co", "dump", "ger", "point", "user", "table", "r", "outs", "base", "cache", "inner", "exec", "bin", "file", "err", "println", "by", "inter", "net", "up", "OUT", "state", "again", "ext"], "line": ["page", "pe", "LINE", "log", "url", "frame", "unit", "e", "lf", "write", "le", "lock", "cell", "data", "link", "sync", "part", "limit", "range", "entry", "rule", "split", "lin", "lines", "job", "inline", "type", "row", "error", "code", "pass", "comment", "header", "base", "string", "file", "Line", "name", "word", "lc", "buffer", "ine", "block", "char"], "bytes": ["ls", "values", "rows", "Bytes", "items", "length", " lines", "count", "os", "ones", "pos", "es", "zip", "reads", "bs", "groups", "comments", "classes", "lines", "ines", "s", "ips", "code", "seconds", "i", "tes", "size", "les", "len", "pages", "units", "number", "files", "outs", "bits", " cycles", "steps", "eps", "codes", "binary", "blocks", "words", "cycles", "bps", "odes"]}}
{"id1": "5632808", "id2": "2398448", "code1": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"respondGet": ["respondPut", "requestGetting", "doPut", "doget", "responsePut", "responseget", "requestPut", "requestGet", "responseGetting", "doGet", "responseGet", "respondget", "doGetting", "respondGetting", "requestget"], "resp": ["rec", "page", "req", "res", "request", "p", "rss", "respond", "url", "news", "report", "esi", "server", "html", "b", "body", "Response", "data", "esp", "rev", "enc", "respons", "pos", "status", "result", "zip", "www", "exp", "reply", "ref", "error", "out", "conn", "download", "wx", "temp", "pkg", "Resp", "api", "client", "r", "cache", "cook", "exec", "err", "obj", "success", "re", "comm", "w", "ctx", "sp", "ret", "response", "content", "exc", "http", "serv", "rep", "onse"], "os": ["ls", "ros", "oa", "res", "js", "nos", "ss", "ps", "io", "obs", "options", "ot", "ns", "osi", "oss", "aos", "pos", "cos", "zip", "es", "ows", "o", "bos", "us", "ys", "uns", "oses", "ms", "out", "fs", "conn", "ips", "oi", "oS", "ios", "ws", "is", "ens", "s", "Os", "oes", "outs", "mos", "los", "ents", "obj", "ob", "ops", "ol", "cs", "bs", "OS", "ds", "ors"]}}
{"id1": "21995302", "id2": "18613870", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"open": ["ize", " start", " OPEN", "to", "un", "res", "resource", " transfer", "write", "build", "en", "init", " close", "it", "o", "set", " opening", "end", "handle", "process", " opener", "xml", "create", "parse", "add", "opening", "stream", "Open", "oc", "change", " Open", "load", "start", "initial", "re", " reopen", "fix", "get", "update", "close", "use", " opened"], "input": ["ink", "text", "ssl", "resource", "image", "connection", "form", "event", "io", "data", "this", "socket", "inc", "output", "in", "document", "audio", "error", "accept", "out", "type", "inf", "container", "element", "instance", "i", "source", "class", "temp", "reader", "pull", "client", "config", "keep", "stream", "PUT", "command", "base", "inner", "Input", "object", "exec", "file", "upload", "context", "current", "state", "buffer", "argument", "http", "feed", "request"], "uri": ["prefix", "direction", "resource", "image", "connection", "manager", "database", "ki", "io", "info", "data", "adi", "username", "si", "verb", " URI", "doi", "definition", "document", "via", "result", "route", "str", "ci", "element", "instance", "i", "source", "uni", "api", "abi", "uid", "directory", "li", "di", "cli", "mi", "pi", "eni", "base", "object", "id", "address", "string", "gi", "file", "URI", "origin", "service", "iri", "absolute", "next", "path", "ui", "response", "qi", "state", "picture", "bridge", "http", "ri"], "url": ["ls", "text", "ssl", "resource", "server", "b", "connection", "io", "data", "link", "socket", "channel", "f", "impl", "URL", "coll", "ref", "bel", "i", "source", "api", "config", "li", "stream", "l", "base", "id", "address", "string", "file", "ob", "sl", "plug", "path", "Url", "layer", "state", "buffer", "http", "feed", "ball", "char", "browser"]}}
{"id1": "10176678", "id2": "6403868", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpGgzained", "testLoadHttpGozipped", "testLoadHttpGgzips", "testLoadHttpGzipipped", "testLoadHttpGzipipping", "testLoadHttpgzipained", "testLoadHttpGozained", "testLoadHttpGozips", "testLoadHttpGzained", "testLoadHttpGzipping", "testLoadHttpgzained", "testLoadHttpGozipping", "testLoadHttpgzipipped", "testLoadHttpGzipained", "testLoadHttpGzips", "testLoadHttpgzipips", "testLoadHttpgzipped", "testLoadHttpgzips", "testLoadHttpgzipipping", "testLoadHttpGgzipped", "testLoadHttpgzipping", "testLoadHttpGgzipping", "testLoadHttpGzipips"], "url": ["ls", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "html", "connection", "loc", "info", "data", "method", "f", "zip", "route", "URL", "ref", "error", "key", "type", "xml", "class", "source", "src", "config", "filename", "l", "base", "id", "address", "string", "gl", "file", "name", "sl", "host", "pattern", "location", "Url", "path", "response", "buffer", "http"], "loadingInfo": [" loadinginfo", " loadingObj", "loadingObj", "loadingInf", "loadinginfo", "LoadingInf", "loaderinfo", " loadingManager", "LoadingConfig", "loaderConfig", "lockingManager", "loadingConfig", "LoadingManager", "lockingInfo", "LoadingObj", " loadingInf", "Loadinginfo", "LoadingInfo", "lockingInf", "loaderInfo", "loadingManager", " loadingConfig", "lockingObj", "loaderInf"], "contentInputStream": ["contentReadSteam", "contentBytestream", "contentOutputStream", "contentReadStream", "ContentOutputString", "ContentInputSteam", "ContentInputString", "contentInputSteam", "contentImportSteam", "contentByteStream", "ContentOutputObject", "contentImportObject", "contentOutputObject", "contentImportStream", "ContentOutputstream", "contentContentObject", "contentInputObject", "ContentInputstream", "contentOutputString", "contentInputString", "contentOutputSteam", "contentOutputstream", "contentReadString", "ContentInputObject", "contentContentSteam", "contentReadstream", "contentInputstream", "ContentOutputSteam", "contentImportstream", "ContentOutputStream", "contentContentstream", "ContentInputStream", "contentContentStream", "contentByteString", "contentByteSteam"], "actual": ["original", "array", "older", "affected", "acceptable", "example", "als", "length", "act", "failed", "event", "successful", "pect", "evaluate", "valid", "truth", "covered", "future", "actually", "average", " Actual", "former", "found", "wrong", "pects", "ual", "handled", "initial", "anticipated", "reported", "existing", "fake", "response", "content", "current", "events", "real", "ception", "received", "including"], "expected": ["allowed", "original", "usual", "acceptable", "length", "example", "failed", "updated", "pect", "info", "data", "required", " expecting", "error", "future", " unexpected", "driver", "size", "found", "wrong", " expect", "reported", "seen", "handled", "anticipated", "defined", "fake", "cover", "nexpected", "always", "needed", "real", "pected", "ception", "received"]}}
{"id1": "3375724", "id2": "22875895", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulasF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitulof", " importarEmissoresDosTitularF", " importarEmissoresDosTitulosFe", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitULoPF", " importarEmissoresDosTituloF", " importarEmissoresDosTitulasf", " importarEmissoresDosTitulosPF", " importarEmissoresDosTitularf", " importarEmissoresDosTituloFe", " importarEmissoresDosTitulosF", " importarEmissoresDosTitulosf", " importarEmissoresDosTitULosFe", " importarEmissoresDosTituloPF", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitulasPF"], "pArquivoTXT": ["pArquivDLS", "pArquivoBBT", "pArquivoQxt", "pArquivoBxt", "pArquivoOTEMP", "pArquivoDEXT", "pArquivoOTXT", "pArquivoDLS", "pArquivaTEXT", "pArquivoTTP", "pArquivoOTTP", "pArquivTXT", "pArquivoLxt", "pArquivoLBT", "pArquivoOTxt", "pArquivaFBT", "pArquivoBEMP", "pArquivoBXT", "pArquivoDBT", "pArquivaTxt", "pArquivDxt", "pArquivoDXT", "pArquivaFTP", "pArquivoFxt", "pArquivaFEMP", "pArquivoDxt", "pArquivoLLS", "pArquivaTBT", "pArquivaTXT", "pArquivaFxt", "pArquivoTxt", "pArquivoBLS", "pArquivoFXT", "pArquivoQXT", "pArquivTLS", "pArquivoFBT", "pArquivTxt", "pArquivTBT", "pArquivoTEMP", "pArquivoQBT", "pArquivoTEXT", "pArquivoQEXT", "pArquivaTTP", "pArquivoTBT", "pArquivoTLS", "pArquivaFXT", "pArquivoFEXT", "pArquivoBTP", "pArquivoFTP", "pArquivaFEXT", "pArquivoLXT", "pArquivoFEMP", "pArquivDXT", "pArquivaTEMP", "pArquivDBT"], "pAndamento": [" pOramentO", " pOramentoo", " pAndementos", " pOrementO", " pOrementos", " pAndamentoo", " pAndentionO", " pAndmentO", " pAndentiono", " pAndamentO", " pAndemento", " pOramentos", " pAndmentoo", " pOramento", " pAndamentos", " pAndentionoo", " pAndentionos", " pAndmentos", " pAndmento", " pAndementoo", " pOremento", " pOrementoo", " pAndementO"], "numeroDoRegistro": ["numeroDoregestros", "numeroDoRegpectrano", "numeroDoRegestorno", "numeroDoregistros", "numeroDoRegpectro", "numeroDoRegpectros", "numeroDoRegistros", "numeroDoregestorno", "numeroDoregestro", "numeroDoRegestros", "numeroDoRegistorno", "numeroDoregistrano", "numeroDoRegpectorno", "numeroDoRegiftorno", "numeroDoregistorno", "numeroDoRegiftros", "numeroDoregistro", "numeroDoRegiftrano", "numeroDoRegiftro", "numeroDoRegestrano", "numeroDoRegestro", "numeroDoRegistrano", "numeroDoregestrano"], "in": ["span", "m", "ex", "ln", "ins", "url", "In", "b", "g", "n", "connection", "scan", "conf", "data", "session", "ner", "inc", "part", "f", "IN", "inn", "cl", "out", "s", "cin", "i", "rin", "kin", "is", "reader", " IN", "with", "config", "nin", " out", "l", "login", "slice", "r", "con", "c", "err", "bin", "t", "ini", "query", "again"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestino", "stmtLimpezaIniciaDestania", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialCombania", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestao", "stmtLimpezaInicialdestania", "stmtLimpezaInicioDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDesino", "stmtLimpezaInicialDestario", "stmtLimpezaInicialDestination", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialdestario", "stmtLimpezaInicialDesario", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombao", "stmtLimpezaInicioDestario", "stmtLimpezaInicioCombario", "stmtLimpezaInicioCombao", "stmtLimpezaInicioDestao", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialDestaco", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestao", "stmtLimpezaInicioCombino", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestania", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialDesao"], "sql": ["ls", "expr", "description", "statement", "sol", "log", "fn", "url", "ssl", "lua", "install", "sf", "html", "details", " SQL", "body", "cmd", "software", "term", "sv", "acl", "data", "msg", "sys", "shell", "socket", "csv", "QL", "sb", "search", "spec", "result", "zip", "liquid", "sn", "stat", "nl", "s", "el", "sq", "dl", "comment", "rl", "filename", "l", "seed", "sg", "db", "eps", "util", "id", "kl", "layout", "string", "err", "params", "select", "sl", "json", "query", "setup", "where", "http", "SQL", "ql"], "stmtDestino": ["stmtdestin", "stmdDestin", "stmtdestino", "stmtdestinos", "stmtDistaco", "stmdDestinos", "stmDestaco", "stmdDestino", "stmDestania", "stmCampaco", "stmtDestin", "stmtDistania", "stmtDestorno", "stmtdestaco", "stmtDestinos", "stmDestino", "stmtCampino", "stmtCamporno", "stmtdestorno", "stmtdestania", "stmtDestaco", "stmCampania", "stmtDistorno", "stmtCampania", "stmCampino", "stmtDistinos", "stmtDestania", "stmtDistino", "stmtCampaco", "stmCamporno", "stmDestorno", "stmtDistin", "stmdDestorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECALSHI", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABECALSCO"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPJTO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAP_PO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADANDOSAD", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADANDOJ"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RegIES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_EGIS"], "tamanhoDosArquivos": ["tamanhoDosArQUivlos", "tamanhoDosArqivos", "tamanhoDosArqivoes", "tamanhoDosArquIVo", "tamanhoDosArquivalo", "tamanhoDosArqIVos", "tamanhoDosArQUervos", "tamanhoDosArquievOs", "tamanhoDosArquivOs", "tamanhoDosArQUervlos", "tamanhoDosArquievos", "tamanhoDosArQUervOs", "tamanhoDosArQUivo", "tamanhoDosArquivaloes", "tamanhoDosArquievlos", "tamanhoDosArquIVoes", "tamanhoDosArquivo", "tamanhoDosArqIVo", "tamanhoDosArqivlos", "tamanhoDosArqIVlos", "tamanhoDosArquervos", "tamanhoDosArquervo", "tamanhoDosArquivalos", "tamanhoDosArquivoes", "tamanhoDosArqIVoes", "tamanhoDosArquIVlos", "tamanhoDosArquivallos", "tamanhoDosArQUivOs", "tamanhoDosArQUervo", "tamanhoDosArQUivos", "tamanhoDosArqivo", "tamanhoDosArquievo", "tamanhoDosArquivlos", "tamanhoDosArquervoes", "tamanhoDosArquervOs", "tamanhoDosArquIVOs", "tamanhoDosArquervlos", "tamanhoDosArquIVos"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimmado"], "registro": ["regastration", "regustros", " regestros", " regestration", "registration", "regustulo", " registulo", "regestration", "regastulo", "regestros", "regestulo", " regestulo", "registulo", " registration", "regastro", "regestro", "registros", "regustro", " registros", " regestro", "regastros", "regustration"], "campos": ["Campo", "Campas", " campOS", " casOS", "campas", "campOS", " campo", "Campos", " campas", "CampOS", " caso", " casos", " casas", "campo"]}}
{"id1": "841724", "id2": "8815137", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readandrewrite", "readAndRebrites", "readandRewrite", "readAndRebrite", "readAndrewrite", "readandRewwrite", "readAndRewrap", "readAndSwrites", "readAndSwwrite", "readAndrewwrite", "readandrewwrite", "readAndRebwrite", "readAndRewrites", "readAndSwrite", "readAndrewrap", "readandRewrap", "readAndrewrites", "readAndRebrap", "readandrewrap", "readAndSwrap", "readandRewrites", "readAndRewwrite"], "inFile": ["InFile", "infile", "oldFile", " inFiles", "inFilename", "oldFiles", "inputFile", " inFilename", " inSourceFile", "outFiles", "loginFiles", "loginfile", "loginFilename", "outfile", "Infile", "inputFilename", "outFilename", "oldfile", "outSourceFile", "InFiles", "oldFilename", "InSourceFile", "inputfile", "loginFile", "inputFiles", "inFiles", "inSourceFile", " infile"], "outFile": ["outFILE", " outfile", "processPlace", " outDir", "thisFilename", "exFILE", "outputPlace", "offFilename", "newfile", "processFilename", "outDir", "thisFILE", "exFilename", "exFile", "newStream", "thisFile", "outputFile", "offFILE", "outStream", "outfile", "outputFILE", " outStream", "outFilename", "offPlace", "thisfile", "newFile", "OutDir", "offFile", "Outfile", "newDir", "processFile", "OutStream", "outputFilename", "OutFile", "processFILE", "outPlace", "outputfile", "exfile"], "iis": ["ciiss", "IIS", "Iis", "iniris", " iais", " iiss", "iniiss", "iais", "ciais", "ciris", "ciIS", "Iiss", " iIS", "iiIs", " iIs", "iiiss", "iiis", "iris", "iiris", "iiIS", " iris", "iIS", "iniIS", "iniIs", "ciIs", "ciis", "iiss", "iniis", "iIs", "Iais"], "dcmParser": ["DcmInstallation", " dcmReader", "dpmPlugin", "dcmPolicy", "dkmHelper", "dbmParser", "dmcarser", "dmissionParser", " dcmparser", "dmoduleParser", "dhemParser", "dcmPlugin", " dcmLoader", "fpmParser", " dcmPolicy", " dcmHelper", "dpmInstallation", " dpmJar", "dcrPlugin", " dcmLanguage", "dCMparser", "dcmLoader", "dcmReader", "dcrParser", "dmissionReader", "dmcParser", "dkmParser", " dcrParser", "dcmparser", "dhemInstallation", "dkmPlugin", " dpmLanguage", "dmmparser", "dmParser", "dpmHandler", "dmissionPlugin", "dcmPar", "dCMReader", "dmoduleJar", "dcrLoader", "dcrJar", "dmmParser", "dbmPolicy", "dmodulePlugin", "dmReader", "dhemJar", " dcrReader", " dpmPar", " dpmPlugin", "fcmHandler", " dcrLoader", "fpmHandler", "dpmarser", "dmLoader", "dpmPolicy", "dbmHelper", "dcrarser", "dpmparser", "dbmPlugin", "dpmLanguage", "fcmReader", "fpmReader", "dcmarser", " dpmparser", " dcmPar", "dmPlugin", " dpmHelper", "dcmHelper", " dpmPolicy", "dmissionLanguage", "dcrPar", "dpmReader", "dCMHandler", "fpmparser", " dpmReader", " dpmarser", "DcmParser", "dpmParser", "dpmPar", "dkmPolicy", "dcmInstallation", "fcmParser", "DcmJar", " dcmJar", "dCMLoader", "fcmparser", "dmmPlugin", "dpmLoader", "dhemReader", "dmoduleReader", "dpmJar", "dCMParser", "dCMPlugin", "DcmReader", "dmcPar", "dmmLoader", "dpmHelper", "dmcJar", " dcmarser", "dcmHandler", " dpmLoader", " dcrPlugin", " dcmPlugin", "dmoduleparser", "dcrReader", "dcmLanguage", "dcmJar", " dpmParser"], "ds": ["ks", "ls", "Db", "ros", "js", "des", "ads", "DS", "ins", "details", "ss", "dr", "cdn", "df", "ps", "rs", "points", "os", "data", "ns", "parts", "sys", "session", "uds", "sync", "dd", "tx", "gd", "vs", "Ds", "amps", "d", "dat", "asi", "ys", "s", "conn", "ws", "is", "drivers", "tes", "src", "pd", "vals", "di", "qs", "db", "Os", "ras", "da", "eps", "ils", "iss", "dds", "icks", "dc", "xs", "ld", "ts", "ays", "nas", "gs", "cs", "utils", "services", "bs", "ants", "dt"], "pdReader": ["ddLoader", "pdLoader", "dsLoader", "pcLoader", "hdStream", "hdLoader", "pcReader", "hdRead", "ddReader", "hdReader", "dsWriter", "hdWriter", "dsreader", "pbRunner", "xdReader", "hdreader", "pdreader", "dsReader", "dsRead", "pdRunner", "pcRead", "ddRunner", "hdRunner", "pbReader", "pdStream", "pcWriter", "pbLoader", "xdRead", "pdRead", "xdWriter", "ddStream", "pbStream", "xdreader"], "out": ["ex", "writer", "default", "flow", "image", "parent", "null", "term", "data", "part", "in", "her", "exp", "o", "password", "conn", "pass", "temp", "cli", "outs", "over", "cache", "exec", "file", "err", "list", "net", "lib", "img", "page", "connection", "dot", "inc", "group", "model", "result", "key", "code", "builder", "point", "object", "w", "down", "layer", "word", "oder", "to", "gen", "url", "io", "outer", "store", "later", "sys", "sync", "Out", "dev", "s", "co", "login", "db", "user", "obj", "up", "device", "order", "diff", "again", "manager", "director", "at", "array", "ssl", "write", "copy", "lock", "child", "session", "external", "output", " in", "with", "client", "inner", "base", "name", "full", "OUT", "auto", "as", "line", "doc", "ext"], "dcmEncParam": ["dcmDecParam", "dcmEstPar", "dcmDecPart", "dcmEnType", "dcmElParameter", "dcmSecParam", "dcmEstParam", "dcmDecPar", "dcmElPar", "dcmDecParameter", "dcmArchParam", "dcmSecPart", "dcmEnParameter", "dcmEncArg", "dcmArchParameter", "dcmEncType", "dcmEnArg", "dcmEstType", "dcmSecType", "dcmEnPar", "dcmEncParameter", "dcmSecPar", "dcmArchArg", "dcmElParam", "dcmEstParameter", "dcmEncPart", "dcmElType", "dcmDecType", "dcmDecArg", "dcmEncPar", "dcmEnPart", "dcmEnParam"], "pdWriter": ["htWriter", "ddReader", "dsOutput", "hdWrite", "hdReader", "hdOutput", "htWriting", "pdWrite", "dsWriter", "ddWrite", "hdWriter", "dsReader", "dsWrite", "PDWriter", "dpWriter", "dpWriting", "PDReader", "PDWrite", "dpReader", "pdWriting", "ddWriter", "pdOutput", "ddOutput", "dpWrite", "htWrite", "htReader", "PDWriting"]}}
{"id1": "13720140", "id2": "17111859", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modifyproperty", "ModifyAttribute", "ModifyProperty", "ModifiedAttribute", "modureproperty", "modateProperty", "ModifiedProperty", "modifiedProperty", "modifyString", "modateAttribute", "modateproperty", "modateString", "modureProperty", "Modifyproperty", "Modifiedproperty", "modifyAttribute", "modifiedAttribute", "modureAttribute", "modifiedproperty", "ModifyString", "modifiedString", "ModifiedString", "modureString"], "valueID": ["ValueId", "valueIP", "Valueid", "VALUEIndex", "contentIndex", "jobid", "valueIndex", "valueid", "ValueIP", "propertyid", "VALUEID", "contentid", "propertyIP", "jobId", "jobIP", "contentID", "jobID", "VALUEid", "valueId", "propertyId", "propertyID", "ValueIndex", "ValueID"], "value": ["secret", "values", "text", "description", "attribute", "padding", "array", "default", "message", "resource", "image", "server", "example", "Value", "data", "username", "output", "phrase", "entry", "document", "result", "password", "val", "key", "code", "element", "source", "expression", "target", "number", "command", "object", "address", "language", "string", "v", "token", "name", "reference", "pattern", "function", "VALUE", "response", "content", "format", "update"], "userID": ["userId", " userId", "authorid", "userName", " userName", "UserMAC", "UserID", "authorID", "UserName", "userid", " userid", "authorMAC", "Userid", " userMAC", "authorName", "userMAC", "authorId", "UserId"], "property": ["prop", "prefix", "attribute", "Property", "message", "resource", "module", "parent", "style", "term", "connection", "info", "data", "method", "project", "this", "profile", "operator", "part", "field", "entry", "definition", "primary", "result", "prototype", "password", "key", "type", "temp", "element", "jo", "metadata", "config", "properties", "section", "tmp", "pair", "expression", "foo", "base", "feature", "variable", "position", "object", "address", "string", "character", "name", "option", "entity", "layer", "function", "operation", "update", "p"], "newValue": ["replaceValue", "defaultVal", " newString", "NewValue", "currentValue", "newString", "nextVALUE", "rawVal", "currentVal", "newvalue", "currentVALUE", "newVALUE", " newVal", "rawVALUE", " newvalue", "NewString", "rawValue", "defaultvalue", " newVALUE", "replaceVALUE", "oldvalue", "replacevalue", "defaultValue", "currentvalue", "nextValue", "NewVal", "NewVALUE", "oldValue", "defaultVALUE", "oldVALUE", "newVal", "nextvalue", "replaceVal", "rawString", "oldVal", "nextVal"], "crypt": ["coin", "conv", "prot", "auth", "ssl", "core", "copy", "cmp", "cmd", "cp", "Crypt", "dec", "poly", "ec", "pt", "hash", "hex", "coll", "ch", "password", "comb", "key", " cryptography", "python", "code", "cc", "temp", "conn", "cm", "ryption", "client", "mac", "ctr", "cash", "cache", "rypt", "cook", "chip", "c", "security", "bec", "con", "mix", "binary", "pool", "chain", "ca", "utils", "contract", "enc", "cr", "lib", "com"], "digest": ["Diger", "digress", "Digusher", "ddest", "DigEST", "digoded", "Digit", "encester", "Digester", "designit", "digEST", "Digest", "crend", "crest", "Digoded", "digit", "signest", "designester", "designusher", "digist", "crist", "designest", "signer", "gener", "genEST", "ddusher", "cododed", " digester", "codest", "signested", "crester", "digend", "Digested", " digend", "digester", "ddester", "signEST", "codress", "encoded", "encest", "ddit", " digist", "diger", "digested", "genested", "encress", "digusher", "Digress", "Digist", "Digend", "genest", "codester"], "hexString": ["tempBuffer", " hexstring", "hashStr", "hexBuffer", "byteStr", "rexString", "cryptSection", "byteBuffer", "hexstring", "tempArray", " hexStr", "exArray", "tempString", "hexStr", "hexArray", "hashString", " hexArray", "rexArray", "rexstring", "hashBuffer", " hexSection", "exBuffer", "byteString", "hexSection", "rexBuffer", "hashArray", " hexBuffer", "cryptArray", "cryptBuffer", "cryptString", "byteArray", "exString", "exstring", "tempSection"], "i": ["k", "m", "u", "uri", "e", "j", "b", "init", "io", "info", "data", "si", "in", "field", "pos", "f", "it", "o", "index", "d", "ci", "h", "key", "s", "oi", "abi", "multi", "li", "di", "l", "ip", "pi", "hi", "xi", "slice", "r", "id", "ti", "v", "gi", "c", "ri", "I", "phi", "ix", "ii", "ui", "x", "mu", "bi", "p"]}}
{"id1": "22536033", "id2": "18433984", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"setPayload": [" setPayContent", "parsePayContent", "setMessageloads", "setPayLoad", "parseShipload", "setMessageLoad", " setPayLoad", "parsePayloads", " setPayloads", "parseShiploads", "setPayContent", "setRawload", "setMessageload", "setRawloads", "setRawLoad", "parseShipContent", "parsePayLoad", "setShiploads", "setWorkload", "setShipLoad", "setShipload", "parseShipLoad", "parsePayload", "setWorkLoad", "setPayloads", "setWorkloads", "setRawContent", "setMessageContent", "setShipContent", "setWorkContent"], "fos": ["cfoc", "Foc", "bics", "Fos", "cfis", " fics", "bis", "bos", "cfics", "fics", "cfos", "Fics", "boc", "Fis"], "fis": ["fib", "Fis", "eic", "forib", "foris", "eis", " fIS", "Foc", "eIS", " fics", "FIS", " fib", "fics", "forics", "foric", "Fib", "Fics", "eoc", "fIS", "Fic"], "fic": ["ufic", "cfoc", "ufik", "infics", "Foc", "Fac", "Fos", "Firc", "fci", " fics", "elfci", "infci", "cfirc", "cfics", "ufos", "cfic", "Fci", "elfik", "fics", "firc", "elfic", "infic", "infik", "cfac", " firc", "Fics", "fac", "ufoc", "Fik", "elfics", " fac", " fik", "fik", "Fic"], "foc": ["troc", "Focol", "infac", "Foca", "Foc", "infisc", "Fac", "Fos", "Froc", "tic", "Fisc", "infos", " focol", "fisc", "foca", " fac", " froc", "infoc", " foca", "toc", "Focon", "focon", "infic", "infocol", " fisc", "infocon", " focon", "fac", "focol", "toca", "froc", "Fic"], "Index": ["ID", "Count", "Insert", "Pull", "Version", "Counter", "Page", "X", "Weight", "Start", "Link", "Pos", "Rank", "Key", "Element", "Value", "Connection", "Code", "Loop", "Location", "index", "Len", "Mass", "Content", "Num", "Address", "Offset", "Entry", "Width", "Stage", "Section", "Label", " index", "Path", "Header", "Length", "Depth", "Dim", "Inf", "Flag", "Input", "Client", "Array", "Size", "Row", "Loc", "Found", "Interest", "Order", "Position", "I", "Level", "Instance", "Url", "x", "First", "Number", "Body", "Exp"]}}
{"id1": "5061606", "id2": "494226", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNequessnecessary", "createSettingsIfNequccesseless", "createSettingsIfNecesseless", "createSettingsIfNecccessarily", "createSettingsIfNecessnecessary", "createSettingsIfNequessary", "createSettingsIfNececeless", "createSettingsIfNecccessnecessary", "createSettingsIfNeceseless", "createSettingsIfNecccessary", "createSettingsIfNequccessnecessary", "createSettingsIfNececary", "createSettingsIfNequccessary", "createSettingsIfNecccesseless", "createSettingsIfNequessarily", "createSettingsIfNequesseless", "createSettingsIfNequccessarily", "createSettingsIfNecesnecessary", "createSettingsIfNecesary", "createSettingsIfNecessarily", "createSettingsIfNececnecessary", "createSettingsIfNececarily", "createSettingsIfNecesarily"], "out": ["at", "prefix", "page", "exit", "log", "writer", "ex", "array", "url", "write", "image", "server", "plain", "copy", "null", "parent", "connection", "lock", "init", "io", "off", "data", "this", "sync", "socket", "channel", "output", "model", "group", "result", "cookie", "editor", "o", "index", "password", "Out", "error", "timeout", "conn", "plugin", "i", "flush", "source", "config", "client", "a", "outs", "user", "object", "cache", "exec", "bin", "file", "err", "obj", "window", "app", "name", "by", "up", "net", "OUT", "path", "pool", "again"], "fSettings": ["Fsettings", "filesettings", "fJs", "fsSettings", "fsSetting", "fSetup", " fsettings", "fsFs", "fsSetup", "fmSetting", "fSetting", "sfSettings", "rfConfig", " fFs", "rfSettings", " fConfig", "FSettings", "rfFs", "FSetting", "FSetup", " fSetting", "fsConfig", "sfSetting", "fileSettings", "fileSetting", "sfJs", "fileettings", "rfSetting", "fmSetup", "fConfig", " fJs", " fettings", "fsettings", "FJs", "fmSettings", "FConfig", "sfsettings", "fFs", "sfettings", "fettings", "fmConfig"], "src": ["prot", "text", "req", "ins", "url", "uri", "ssl", "uc", "dest", "b", "st", "loc", "rc", "sb", "route", "str", "storage", "ref", "rb", "attr", "cb", "settings", "cur", "source", "config", "filename", "tmp", "stream", "sub", "base", "ctr", "sc", "lower", "string", "ource", "file", "dist", "gb", "sr", "sl", "sel", "path", "fp", "img"], "in": ["ins", "url", "image", "In", "copy", "b", "n", "connection", "init", "thin", "data", "inc", "f", "gin", "input", "din", "IN", "inn", "index", "s", "i", "sin", "win", "source", "rin", "reader", "kin", "stream", "l", "login", "inner", "r", "id", "bin", "file", "con", "c", "err", "ini", "path", "again"]}}
{"id1": "3584508", "id2": "8747840", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadresource", " copyresource", " downloadUrl", "copyFile", " copyUrl", "copyresource", "copyUrl", "transferUrl", " downloadResource", " copyFile", "transferResource", "transferresource", " downloadFile", "transferFile"], "url": ["ls", "page", "uri", "ssl", "resource", "image", "server", "connection", "loc", "remote", "data", "f", "www", "URL", "ref", "bel", "download", "xml", "source", "src", "stream", "l", "lr", "web", "base", "r", "object", "id", "address", "string", "ource", "file", "loader", "re", "name", "sl", "host", "path", "Url", "http", "feed"], "input": ["request", "ssl", "resource", "image", "connection", "form", "act", "data", "this", "session", "inc", "socket", "in", "f", "audio", "index", "error", "reader", "accept", "out", "inf", "temp", "instance", "i", "source", "xml", "api", "config", "pull", "element", "qa", "progress", "stream", "l", "ack", "parse", "inner", "base", "client", "Input", "cache", "address", "exec", "bin", "file", "load", "upload", "binary", "get", "context", "current", "plus", "buffer", "but", "active", "http", "feed", "bb", "open"], "output": ["log", "writer", "console", "default", "unit", "resource", "write", "image", "flow", "copy", "connection", "outer", "data", "socket", "external", "application", "document", "result", "out", "source", "Output", "config", "network", "stream", "target", "web", "queue", "control", "object", "cache", "address", "file", "other", "binary", "ou", "layer", "environment", "response", "operation", "current", "put", "buffer", "production"], "b": ["buf", "k", "m", "p", "e", "n", "fb", "bit", "lb", "bc", "sb", "f", "bs", "pb", "d", "rb", "batch", "cb", "mb", "h", "bf", "B", "i", "a", "l", "db", "base", "bar", "r", "br", "v", "bin", "c", "file", "be", "ob", "binary", "bi", "x", "buffer", "ab", "abs", "nb", "line", "bb"]}}
{"id1": "7468827", "id2": "8801182", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"run": ["running", "url", "resource", "server", "call", "build", "Run", "loop", "check", "test", "download", "process", "stop", "create", "web", "work", "login", "exec", "submit", "start", "get", "runner", "update", "execute", "close", "open"], "con": ["conv", "cons", "ex", "un", "url", "cn", "plain", "uc", "conf", "cp", "connection", "en", "rc", "init", "CON", "Con", "ocon", "socket", "bc", "connect", "fa", "ran", "cl", "out", "cur", "conn", "Conn", "ver", "ctrl", "client", "don", "co", "web", "sub", "login", "fun", "can", "pc", "c", "exec", "file", "re", "fc", "ob", "cf", "clean", "ca", "close", "fe", "http", "on", "open", "com"], "encodedPassword": ["enoderPassword", "enodedpassword", "encodedData", "encoderPass", "enccodedPass", "encapedData", "Encryptedpassword", "encryptedData", "encoderPassword", "encapedPass", "encoderData", "EncodedPass", "Encodedpassword", "enodedPassword", "EncryptedPass", "encapedpassword", "enccodedpassword", "encapedPassword", "EncodedSecret", "EncodedPassword", "enodedData", "encoderSecret", "enodedPass", "encryptedPassword", "EncryptedPassword", "enoderPass", "encryptedPass", "encodedPass", "EncryptedSecret", "enoderpassword", "enoderData", "encryptedpassword", "encryptedSecret", "encodedpassword", "enccodedSecret", "enccodedPassword", "encodedSecret", "encoderpassword"], "encoder": ["decode", "enoder", "decoding", "enoded", "encode", " encoded", "Encode", "decoder", " encoding", "decoded", "enoding", "enode", "Encoded", "encoded", "Encoder", "encoding", " encode", "Encoding"], "in": ["ins", "url", "In", "b", "init", "io", "socket", "inc", "gin", "f", "input", "vin", "din", "IN", "lin", "inn", "out", "conn", "pass", "cin", "i", "rin", "win", "kin", "reader", "source", "is", "nin", "login", "inner", "bin", "c", "file", "pin", "ini", "as", "again", "isin", "cgi"], "fos": ["infose", "fis", "lfis", "dos", "fose", "Foos", "fOS", " faos", "boes", "Fos", " foos", "foos", "foses", "faos", "infos", "Foss", "bis", "daos", "bos", "infoos", "infoses", "infoss", " foses", " fOS", "infOS", " fose", " foss", "Faos", "Foses", "doss", "doses", "bOS", " fis", "Fose", "foss", "lfoes", "foes", "FOS", "lfos", "lfOS", " foes"], "bout": ["bbouter", "bouts", "bio", "fio", "fin", "fout", "Bio", "bbio", "fouts", "b4", "bbin", "Bout", "bcache", "bbout", " bin", "fouter", "bOut", " bio", "bbouts", " bOut", " b4", "Bcache", "bbcache", " bouter", "bbOut", "bin", "bouter", "Bin", " bouts", "bb4", "BOut", " bcache", "f4"], "data": ["DATA", "sample", "partial", "pad", "message", "image", "one", "length", "body", "info", "raw", "part", "result", "zip", "input", "d", "dat", "batch", "read", "bytes", "key", "i", "memory", "reader", "size", "media", "number", "div", "address", "string", "cache", "video", "alpha", "start", "xxx", "next", "response", "xxxx", "content", "buffer", "value", "zero", "feed", "block"], "x": ["m", "pe", "ex", "u", "z", "X", "rx", "b", "n", "en", "num", "lex", "xy", "tx", "pos", "no", "f", "index", "d", "val", "code", "wx", "i", "y", "max", "size", "xp", "width", "xx", "dx", "xi", "number", "fx", "xc", "id", "my", "v", "wa", "c", "xs", "t", "w", "ix", "xxx", "ww", "p"], "lastIteraction": ["lastExecate", "lastIterAction", "lastExecation", "prevGenerATION", "lastGeneration", "prevIterAction", "lastGenerAction", "prevIterate", "prevGenerate", "lastGenerate", "lastIterate", "prevIterATION", "lastExecATION", "prevGeneration", "lastExecAction", "lastIteration", "lastGenerATION", "lastIterATION", "prevIteration", "prevGenerAction"], "e": ["pe", "ee", "u", "esi", "one", "se", "b", "g", "n", "event", "ge", "this", "ie", "no", "f", "it", "es", "edge", "oe", "ise", "o", "d", "ae", "error", "me", "type", "s", "element", "i", "ze", "a", "ne", "er", "E", "r", "ure", "c", "ke", "be", "re", "t", "ite", "or", "fe", "exc", "p", "ception"]}}
{"id1": "7809093", "id2": "17580775", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 1, "substitutes": {"getContent": ["setData", " getData", "GetBody", "requestEntity", "setBody", "requestBody", "requestContent", "responseOutput", "GetEntity", " getEntity", " getBody", "responseBody", "GetContent", "getBody", "setEntity", "getEntity", "getData", "requestOutput", "GetOutput", "GetData", "responseEntity", "responseContent", "getOutput", "setContent"], "request": ["req", "url", "uri", "message", "resource", "e", "server", "report", "connection", "method", "data", "application", "result", "input", "route", "Request", "type", "xml", "instance", "QUEST", "user", "queue", "r", "object", "position", "address", "string", "handler", "name", "reference", "path", "query", "current", "operation", "q", "http"], "sb": ["ls", "bsp", "lp", "sf", "b", "fb", "bt", "bp", "bh", "usb", "xb", "lb", "bc", "pb", "SB", "su", "rb", "lab", "cb", "bf", "abi", "amb", "bm", "bd", "src", "bg", "sg", "db", "ib", "abb", "bj", "zb", "BB", "sa", "gb", "sup", "binary", "obb", "wb", "sk", "vm", "buffer", "ab", "nb", "eb", "bs", "fp", "bb"], "client": ["proxy", "p", "console", "url", "default", "ssl", "uri", "resource", "server", "call", "connection", "force", "remote", "tc", "ce", "apache", "project", "session", "channel", "output", "application", "connect", "cl", "container", "conn", "plugin", "builder", "api", "config", "bird", "cli", "contact", "web", "Client", "util", "queue", "cache", "https", "con", "c", "handler", "app", "service", "net", "per", "host", "context", "current", "http"], "httpParams": ["httpParamas", "httpPoparams", "httpPams", "httpPoams", "HttpParams", "HTTPPareters", "HTTPParam", "httpPeramas", "httpPerparams", "httpPrams", "httpPARcs", "HTTPPoparams", "HTTPPoamer", "httpPareters", "HTTPPoams", "HTTPParums", "HTTPParamer", "httpPreters", "HttpParamas", "httpPeters", "HTTPParcs", "httpPamer", "httpParparams", "HTTPPoeters", "HTTPPARams", "HTTPParams", "HTTPPARam", "httpPoeters", "httpArcs", "HTTPParparams", "httpPeram", "httpParam", "HTTPPARums", "httpPramer", "HttpParam", "httpPoamer", "httpPparams", "httpAram", "httpPrparams", "httpParums", "httpPARamas", "httpArams", "httpParcs", "httpPerams", "httpPARams", "httpPARparams", "HttpParparams", "httpArums", "httpPARam", "HTTPPARcs", "httpPARums", "httpParamer"], "response": ["resp", "page", "respond", "resource", "report", "message", "server", "view", "Response", "connection", "body", "successful", "data", "output", "application", "status", "model", "result", "document", "reply", "error", "results", "api", "object", "success", "relation", "json", "collection", "http", "feed", "onse", "received"], "entity": ["pe", "component", "writer", "resource", "e", "server", "body", "connection", "Entity", "ce", "event", "data", "channel", "output", "model", "document", "entry", "result", "creator", "application", "coll", "translation", "ent", "type", "conn", "element", "instance", "xml", "source", "api", "article", "media", "agent", "node", "company", "object", "address", "file", "em", "environment", "json", "content", "collection", "http", "person"], "reader": ["writer", "server", "rx", "rer", "ser", "io", "ner", "parser", "reading", "rar", "in", "Reader", "input", "editor", "read", "row", "i", "source", "iter", "driver", "bird", "stream", "er", "rr", "worker", "inner", "r", "handler", "loader", "per", "ler", "buffer", "iterator", "oder", "feed", "ri", "ry"], "line": ["page", "LINE", "url", "unit", "message", "lf", "le", "cell", "data", "ge", "link", "sync", "no", "entry", "model", "definition", "str", "lin", "cl", "lines", "end", "key", "inline", "row", "el", "code", "val", "job", "pass", "source", "iter", "comment", "header", "li", "l", "ip", "len", "base", "user", "r", "id", "string", "character", "Line", "name", "sl", "sel", "layer", "word", "content", "lc", "non", "feed", "block", "char"]}}
{"id1": "23246123", "id2": "4798332", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createButtonGroup", "createMessageArea", " createButtonGroup", " createDialogPanel", " createHelpArea", "createButtonArea", " createDialogarea", "createEditorarea", "createControlarea", "createControlArea", "createButtonarea", "createHelpGroup", "createMessagePanel", "createHelpArea", " createButtonarea", "createEditorGroup", " createDialogGroup", "createEditorArea", "createDialogPanel", "createHelpPanel", "createDialogGroup", "createHelparea", " createButtonArea", " createHelparea", "createControlPanel", "createMessagearea", " createHelpPanel", "createDialogarea"], "parent": ["page", "component", "menu", "message", "image", "resource", "null", "g", "connection", "panel", "Parent", "this", "child", "parser", "port", " scene", "document", "parents", "cl", "clip", "container", "instance", "builder", "class", "client", "section", " sup", "self", "object", "c", "sup", "root", "ctx", "host", "context", "wrapper", "current", "comp", " child", "p"], "composite": ["Complexiting", "comvalitive", "compositionites", "complexiting", "comppositionited", "comPOSitable", "Complexite", "compositionitive", "comppositor", "compositor", "comPOSite", "comppositionitor", "Composites", "comppositionite", "compposite", "complexitable", "composites", "comPOSited", "complexites", "compposites", "composited", "Compositable", "compositionitable", "comosited", "complexitor", "compositing", "compositionite", "comppositable", "Compositing", "comositable", "comvalitor", "comvalites", "comPOSites", "comosites", "compositionited", "compposited", "compositable", "Composite", "compositionitor", "comPOSiting", "compositive", "comppositive", "comppositionites", "complexitive", "Complexites", "comosite", "comvalite", "complexite", "comppositionitable", "comppositionitive", "compositioniting", "Complexitable"], "content": ["activity", "page", "component", "ez", "message", "report", "image", "server", "html", "resource", "copy", "complete", "connection", "cell", "version", "child", "title", "output", "folder", "application", "document", "model", "container", "Content", "conn", "code", "plugin", "xml", "comment", "cm", "create", "config", "section", "header", "client", "media", "cms", "source", "control", "object", "scroll", "address", "load", "exec", "file", "app", "loader", "host", "context", "layer", "json", "cont", "format", "feed"], "ncol": ["nblock", "numcolumn", " ncolumn", "pCol", "Ncol", "numCol", "nbcolumn", "pcol", " nblock", "Nblock", "numrow", " nCol", "nCol", "nbcol", "numcol", "nbCol", "pblock", "ncolumn", "nbrow", "Ncolumn", "nrow", "NCol", "pcolumn", " nrow"], "layout": ["font", "widget", "padding", "closure", "nav", "flow", "board", "image", "build", "offset", "view", "lock", "flat", "data", " layouts", "scale", "mount", "follow", "group", "shape", "model", "figure", "draw", "entry", "zip", "shadow", "translation", "split", "nl", " Layout", "container", "inline", "xml", "config", "section", "l", "edit", "Layout", "base", "design", "control", "position", "scroll", "address", "holder", "alpha", "list", "grid", "lay", "layer", "location", "ui", "lc", "where", "feed", "block", "join"], "numColumns": ["numcolumnes", "nbcolumnes", "numColumnows", "nbColumnes", "numControln", "numcolumnn", "nbColumns", "nbcolumnn", "numControls", "numColn", "nbColumnows", "nbcolumnows", "numColumnn", "numColows", "nbcolumns", "numColes", "numControles", "numControlows", "numcolumnows", "numCols", "numcolumns", "nbColumnn", "numColumnes"], "browser": ["css", "river", "page", "roller", "Browser", "book", "js", "vert", "report", "image", "server", "mobile", "ssl", "uri", "html", "nav", "remote", "google", "fox", "io", "session", "cart", "iframe", "cookie", "fire", "editor", "proxy", "finder", "shadow", "coll", "facebook", "graph", "test", "ver", "plugin", "jar", "comment", "theme", "driver", "chrome", "config", "agent", "client", "flash", "web", "ger", "design", "sim", "feature", "bar", "br", "http", "window", "platform", "loader", "binary", "root", "host", "webkit", "bot", "runner", "front", "box", "manager", "feed", "lib", "open", "img"], "text": ["font", "writer", "txt", "vert", "message", "image", "report", " Text", "struct", "unit", "connection", "letter", "term", "atter", "form", "off", "info", "data", "port", "title", "output", "entry", "it", "editor", "str", "input", "test", "plugin", "element", "comment", "source", "driver", "config", "client", "pdf", "inner", "user", "TEXT", "object", "string", "desc", "name", "select", "service", "binary", "context", "path", "ext", "format", "abs", "label", "feed", "ut", "Text"], "url": ["ur", "page", "ssl", "uri", "resource", "server", "image", "connection", "rel", "io", "f", "zip", "www", "URL", "ref", "bel", "download", "source", "pull", "api", "config", "l", "web", "lr", "base", "user", "id", "address", "string", "gl", "file", "re", "service", "sl", "host", "path", "Url", "http", "feed", "open"], "in": ["rec", "p", "ins", "fr", "resource", "image", "In", "b", "dr", "rc", "init", "data", "on", "inc", "f", "gin", "it", "input", "str", "o", "din", "IN", "d", "inn", "lin", "rb", "out", "s", "conn", "el", "pass", "xml", "i", "rin", "is", "reader", "ar", "nin", "l", "er", "login", "stream", "inner", "a", "min", "br", "bin", "err", "c", "ic", "re", "w", "pin", "ini", "x", "or", "arin", "again", "serv", "ri"], "r": ["kr", "ur", "rt", "m", "p", "res", "rss", "fr", "R", "rx", "ro", "rob", "b", "ru", "dr", "nr", "rc", "mr", "rs", "rel", "rh", "ner", "rar", "f", "vr", "o", "d", "rb", "h", "out", "rg", "rf", "rw", "i", "pr", "reader", "rl", "ar", "l", "er", "rr", "lr", "br", "ir", "err", "c", "re", "sr", "gr", "hr", "or", "cr", "ri", "right"], "sb": ["buf", "kb", "sth", "ls", "bsp", "lp", "ssl", "rob", "sf", "b", "sv", "fb", "bp", "bh", "si", "usb", "xb", "lb", "bc", "sn", "pb", "SB", "storage", "rb", "nl", "lab", "cb", "mb", "s", "bf", "bm", "src", "library", "erb", "ruby", "sg", "db", "lr", "ib", "bj", " SB", "abb", "sa", "sm", "gb", "ob", "sr", "binary", "obb", "sp", "wb", "buffer", "abs", "ab", "eb", "bs", "bb"], "line": ["page", "LINE", "pe", "lf", "col", "message", "le", "se", "b", "n", "letter", "cell", "data", "ge", "part", "entry", "f", "str", "split", "lin", "cl", "lines", "nl", "key", "end", "row", "el", "code", "inline", "pass", "i", "comment", "source", "cle", "record", "header", "li", "ne", "l", "base", "object", "id", "string", "character", "stroke", "obj", "Line", "name", "sl", "lc", "block", "char"], "e": ["ve", "ale", "pe", "ee", "ev", "esi", "one", "se", "le", "en", "ce", "ue", "ge", "je", "ie", "ec", "ele", "f", "oe", "es", "ise", "o", "d", "ae", "error", "me", "i", "te", "ze", "ime", "ne", "er", "E", "de", "err", "ke", "be", "ite", "ea", "or", "ef", "fe", "exc", "p", "ception"]}}
{"id1": "13657527", "id2": "6558022", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatAsetsSearch", "getDatAsetSearch", "getDatAsetsList", "getDatasetsSearch", "getDatasencieslist", "getDatasenciesList", "getDatasetslist", "getDatasureslist", "getDatasetList", "getDatasetSearch", "getDatasetlist", "getDatAsetList", "getDatAsetlist", "getDatasuresList", "getDatasenciesSearch", "getDatasuresSearch", "getDatAsetslist"], "surl": [" shttp", "srule", "slog", "nsuri", "wsurl", "dlayer", "sUrl", "Surl", "ssl", "dsfile", "nsjob", "sesjob", "sesurl", "Shttp", "Srule", "osfile", "ossl", "osuri", "sinrule", "wslayer", " sURL", "wssl", "ssjob", "slurl", "sinurl", "sesuri", "jssl", "sjob", " sUrl", "durl", "Sfeed", "SURL", "dsl", "jslayer", "shttp", "sinfeed", "jsuri", "wsuri", "tsl", "lsUrl", "slrule", "slfeed", "sinlog", "turl", "slayer", "nsfile", "duri", "sfile", "ssurl", "jsurl", "turi", "osurl", "sesfile", "lshttp", "SUrl", "sllog", "tfile", "dsurl", "dsuri", "ssfile", "nsurl", "dssl", "sURL", "lsurl", "Slog", "ssuri", "suri", "sfeed", "lsURL"], "datasetsList": ["datrasuresMap", "datasetsPool", "datastersMap", "datasuresCollection", "datrasetsMap", "datassETSList", "datrasETSMap", "datasetsCollection", "datasetMap", "datrasetsList", "datrasETSList", "datrasureslist", "dataschesMap", "datastersCollection", "datasetL", "datasencesMap", "datassetsCollection", "datasETSCollection", "datrasetsL", "datassETSPool", "datasetList", "datasuresL", "datascetsCollection", "datasetsL", "datasencesCollection", "datasagesMap", "datascheslist", "datasETSTable", "datasETSlist", "datascencesString", "datetetsList", "dataschesList", "datrasetslist", "datassetsPool", "datascencesList", "datasureslist", "datasETSPool", "datasetslist", "datascetsMap", "datetsetsL", "datetetsMap", "datasuresMap", "datasencesList", "dataselinesTable", "datasetsMap", "datasetsString", "datassETSMap", "dataselineslist", "datassetsList", "datassETSCollection", "datrasETSlist", "datasagesCollection", "datasagesList", "dataschesTable", "datasetlist", "datascetsString", "datasitesL", "datrasuresL", "dataselinesMap", "datastersString", "datascencesCollection", "datastersList", "datasitesMap", "datetetslist", "dataselinesList", "datascencesMap", "datasagesPool", "datascetsList", "datasuresString", "datetsetslist", "datasETSL", "datrasETSTable", "datasiteslist", "datassetsL", "datasitesList", "datetsetsMap", "datetsetsList", "datrasuresList", "datasencesString", "datasuresList", "datasetsTable", "datetetsL", "datassetslist", "datasETSMap", "datasETSList", "datassetsMap", "datrasetsTable"], "result": ["page", "res", "fr", "default", "report", "message", "resource", "rc", "event", "info", "ge", "ner", "rar", "part", "entry", "status", "rule", "valid", "end", "test", "row", "results", "instance", "comment", "record", "Result", "inner", "user", "r", "found", "match", "load", "card", "success", "repl", "re", "ret", "response", "runner", "request"], "reader": ["roller", "writer", "older", "ssl", "resource", "server", "rx", "rer", "ser", "dr", "io", "parser", "reading", "ner", "rar", "entry", "her", "Reader", "input", "editor", "upper", "read", "row", "i", "builder", "iter", "driver", "stream", "er", "l", "lr", "inner", "rr", "ger", "worker", "r", "slice", "over", "handler", "err", "file", "loader", "per", "cher", "layer", "runner", "keeper", "ler", "buffer", "oder", "http", "feed"], "url": ["ur", "page", "log", "ssl", "uri", "ll", "resource", "server", "image", "b", "connection", "io", "socket", "entry", "f", "rule", "str", "URL", "bel", "element", "source", "iter", "driver", "client", "l", "stream", "lr", "base", "user", "address", "string", "file", "loader", "service", "sl", "Url", "buffer", "hub", "http", "feed", "browser"], "s": ["ls", "u", "js", "ins", "ssl", "e", "server", " lines", "b", "details", "ss", "n", "os", "ps", "rs", "ns", "si", "sync", "search", "sb", "f", "spec", "es", "site", "ings", "str", "o", "comments", "su", "sets", "lines", "ws", "i", "source", "is", "l", "r", "ses", "S", "string", "less", "t", "sl", "ops", "words", "abs", "services", "strings", "line", "p", "ds"], "list": ["ls", "array", "default", "ll", "server", "null", "view", "letter", "pl", "ul", "data", "lists", "entry", "all", "str", "LIST", "coll", "set", "batch", "cl", "and", "key", "type", "test", "el", "val", "record", "li", "listed", "l", "base", "table", "queue", "string", "load", "ml", "la", "left", "bl", "lc", "chain", "collection", "join"]}}
{"id1": "1371265", "id2": "19810820", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["replace", "save", "UPDATE", "write", "report", "append", "resource", "apply", "updated", "info", "data", "set", "index", "run", "create", "add", "Update", "edit", "delete", "table", "select", "json", "query", "insert", "request", "post"], "channelPath": ["downloadpath", "downloadObject", "fileObject", "downloadMap", " channelpath", "resourceObject", "filePath", "resourceMap", "downloadPath", "resourcePath", "resourcepath", "fileMap", "filepath", " channelObject", " channelMap"], "dataField": ["responseFIELD", "alphaField", "DataArea", "resourceField", "dataTerm", " dataFIELD", "responseTerm", "responseField", "DataField", "dataArea", "responsefield", "DataTerm", " dataTerm", "resourcefield", "alphaTable", "resourceFIELD", "alphaArea", "resourceTerm", "alphaTerm", " datafield", "DataTable", "datafield", "dataTable", " dataTable", "dataFIELD", " dataArea"], "fatherDocId": ["fatherDocName", "fatherPoID", "fatherFilePath", "motherDocInfo", "motherDocID", "fatherPoid", "fatherDocInfo", "motherDocumentInfo", "fatherDocumentName", "fatherDocumentPath", "fatherdocName", "motherDocName", "fatherdocId", "motherDocumentid", "fatherDocID", "motherDocumentName", "fatherdocInfo", "fatherWriterName", "motherDocId", "fatherWriterID", "motherDocumentID", "fatherFileid", "fatherFileName", "motherDocumentId", "motherDocid", "fatherFileID", "motherDocumentPath", "fatherPoName", "fatherdocPath", "fatherWriterInfo", "fatherWriterId", "motherDocPath", "fatherWriterid", "fatherDocumentId", "fatherDocumentID", "fatherFileInfo", "fatherFileId", "fatherDocid", "fatherDocumentInfo", "fatherDocPath", "fatherPoId", "fatherDocumentid"], "sqlInitial": ["qlinitial", "qlFinal", "qlInitialized", " sqlInitialized", "sqlInitialized", "qlInitial", "SQLInitialized", "SQLInitial", "sqlinitial", "queryInit", "SQLInit", " sqlInit", "SQLinitial", " sqlinitial", "queryInitial", "queryinitial", "queryFinal", "SQLFinal", "qlInit", "sqlInit", "sqlFinal"], "sqlsortURL": ["sqlssortURI", "sqlsORTURI", "sqlsourceURL", "sqlsorturl", "sqlsendURL", "sqlsORTurl", "sqlsaltSSL", "sqlsORTURL", "sqlsortUrl", "sqLSORTURI", "sqLSorturl", "sqlsaltURI", "sqlsortSSL", "sqllortUrl", "sqlsaltURL", "sqllortURI", "sqllaltURL", "sqLSortURI", "sqlssorturl", "sqlsendUrl", "sqlsourceUrl", "sqLSortURL", "sqLSORTURL", "sqLSortUrl", "sqlsendURI", "sqlssortUrl", "sqllaltURI", "sqlsaltUrl", "sqlsendSSL", "sqlsourceURI", "sqllortURL", "sqlsORTUrl", "sqlsourceurl", "sqlsortURI", "sqllaltUrl", "sqLSORTurl", "sqLSORTUrl", "sqllaltSSL", "sqlssortURL", "sqlsourceSSL", "sqllortSSL"], "conn": ["rt", "res", "ct", "cn", "col", "core", "Connect", "conf", "cp", "connection", "n", "rc", "pg", "en", "act", "lock", "session", "sql", "sync", "reg", "oss", "Connection", "ht", "pt", "syn", "connect", "mc", "nt", "coll", "ch", "nc", "ci", "ens", "Conn", "cc", " con", "cat", "pr", "oci", "client", "co", "db", "apt", "ann", "orp", "pc", "con", "c", "dc", "dn", "net", "ctx", "pub", "cs", "ca", "enc", "cr", "p", "ds"], "rs": ["rt", "ros", "maps", "asts", "res", "rss", "rors", "arch", "ins", "rows", "DS", "rx", "mr", "rc", "obs", "PS", "ns", "acks", "ges", "hs", "ows", "vs", "rys", "rb", "ys", "lines", "ms", "rg", "s", "Rs", "RS", "results", "ues", "pr", "its", "src", "rl", "rr", "qs", "ras", "r", "sc", "ars", "ris", "ocr", "icks", "sels", "xs", "repl", "rd", "sr", "ts", "ans", "hr", "ats", "ra", "cs", "pers", "bs", "cr", "rep", "ks", "runs", "ds", "vers"], "ps": ["ros", "pe", "res", "ins", "DS", "ss", "pg", "pl", "os", "PS", "ns", "aps", "pos", "pse", "pt", "syn", "fs", "vs", "pa", "pres", "amps", "ys", "ips", "ens", "s", "Rs", "RS", "ws", "Ps", "pr", "pass", "LS", "posts", "pex", "co", "ports", "ras", "pps", "eps", "po", "ms", "pc", "con", "ars", "ts", "pre", "sp", "pm", "ans", "ons", "gs", "jp", "ples", "cs", "ups", "pers", "pp", "bs", "p", "ks", "ds"], "dbo": ["Dbo", "ldbo", "bpo", "dba", " dBo", "bbo", "dBo", "dbc", " dbc", "Dpo", "mdBo", "Dbi", " dba", " dbi", "mdbo", "dbi", "bbi", "dpo", "mdba", "DBo", "mdbc", "bBo", "ldba", " dpo", "ldbc", "ldBo"], "url": ["ur", "page", "text", "fl", "uri", "ssl", "resource", "ll", "image", "server", "html", "fr", "view", "loc", "rel", "force", "data", "username", "blog", "f", "rule", "route", "www", "URL", "str", "href", "nl", "date", "download", "source", "src", "rl", "filename", "l", "hl", "r", "id", "address", "language", "string", "email", "file", "name", "sl", "host", "layer", "path", "Url", "location", "response", "q", "http", "feed", "request"], "st": ["ost", "sth", "std", "rt", "pe", "Str", "est", "fr", "stri", "nd", "const", "ss", "ste", "ut", "sts", "stress", "ST", "pt", "sb", "inst", "str", "sn", "stack", "cl", "s", "rest", "stop", "pr", "St", "th", "src", "ist", "l", "sw", "ft", "r", "sc", "string", "start", "rd", "t", "sl", "sp", "ast", "ld", "la", "bl", "sh", "sta", "x", "ust", "cr", "p"], "sortDocId": ["updateDocumentInfo", "updateDocumentid", " sortFileId", "sortdocName", "sortDOCid", "sortDocumentId", "sortDepID", "updateDocID", " sortDocumentid", "sortDepInfo", "sortDocumentid", " sortFileID", " sortDocumentID", "sortWriterID", " sortDocumentId", "sortdocid", "updateDocumentId", "sortDepId", "sortdocId", "sortPageid", "sortDocumentInfo", "sortdocPath", "sortDOCName", "sortdocInfo", "sortDocid", "sortWriterid", "sortFilePath", " sortDocID", "sortPageName", "sortFileid", "sortDepid", "sortDocumentID", "updateDocumentID", "updateDocid", "sortPageID", "sortDocumentPath", " sortDocPath", "updateDocId", " sortDocumentName", "sortDocPath", "sortDOCID", "sortDocumentName", "sortFileInfo", "updateDocInfo", "sortDocInfo", " sortFilePath", "sortWriterName", "sortdocID", "sortFileID", "sortDocName", " sortDocName", "sortDOCId", "sortWriterId", " sortFileInfo", "sortDocID", "sortPageId", " sortDocid", "sortDepName", "sortFileId", " sortDocInfo"], "flag": ["prop", "fl", "standard", "debug", "count", "offset", "star", "FLAG", "tag", " Flag", "data", "leaf", "store", "child", "sync", "bit", "blog", "part", "func", "bool", "field", "status", "agg", "str", "key", "inline", "only", "cat", "fun", "Flag", "id", "ind", "match", "string", "lag", "file", "start", "wait", "binary", "arg", "bug", "ret", "format", "flags", "ag", "force", "use", "kind", "ext", "char"], "sqlsort": ["sqLSorted", " sqlesort", "sqlessort", "sqllorter", "sqLSsort", " sqLSort", "sqLSORT", " sqlesorter", "sqlesORT", "sqLSorts", "sqlesort", " sqLSorts", "sqLSort", " sqLSORT", " sqlsorted", " sqlssort", "sqLSorter", "sqllORT", "sqlsORT", "sqssort", "sqsORT", " sqlsorter", "sqllorted", " sqlesORT", "sqlsorter", "sqllort", "sqlssort", " sqlesorted", "sqlesorted", " sqLSsort", "sqlsorts", "sqlsorted", "sqlesorts", "sqsorts", " sqlsORT", "sqlesorter", " sqlsorts", "sqsort"], "sortURL": ["editurl", "altSSL", "altUrl", " sortSSL", "sortID", "ortID", "editUrl", "SortUrl", " sortURI", "SortURL", "searchUrl", "sortURI", "searchID", "updateSSL", "updateUR", " sorturl", "sortSSL", " sortUrl", "updateURL", "editUR", "sorturl", "searchURI", "editURL", "ortURL", "updateURI", "SortUR", "ortSSL", " sortUR", "altURL", "sortUR", "altUR", "searchURL", "ortURI", "searchUR", "sortUrl", " sortID", "ortUR", "Sorturl", "ortUrl"], "sortflag": ["addressflag", "considerflag", " sortFlag", "ortFlag", "sortfeed", "considerfeed", " sorttype", "orttype", "sortFlag", "ortflags", "filtertype", "SortFlag", "Sortflag", "considerflags", "addressfeed", "ortlike", "sorttype", "ortFLAG", "sortlike", "SortFLAG", "addressflags", "filterFLAG", "sortflags", "sortFLAG", " sortFLAG", "addresslike", "filterflag", "ortflag", "considerlike", "ortfeed"]}}
{"id1": "13499897", "id2": "15768167", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"CopyFile": [" CopyFolder", "Createfile", " copyfile", " CopyDir", " Copyfile", "CreateFolder", " copyDir", "Copyfile", "CreateFile", " copyFolder", "CreateDir", " copyFile", "CopyFolder", "CopyDir"], "sourcefile": ["SourceFile", "Sourcef", "destFile", "sourcefilename", "sinfile", " sourceFile", " sourcefilename", "configstream", "Sourcefile", "sourcelog", "destf", "configlog", "Sourcefilename", "configfile", "sourceFile", "sinlog", "deststream", "sinstream", "destlog", "sinFile", "configFile", " sourcef", "sourcef", "sourcestream", "destfilename"], "destfile": ["destFile", "sourcefilename", "targetfilename", "srcfilename", "deststring", "destroystream", "sourcepath", "buildfile", " destFile", "Desturl", "destfp", "tempFile", "destroyfilename", " destfp", "tempfilename", "Destfilename", "tempstream", "newfile", "Destfp", "buildstring", "targetpath", "srcfile", " destfilename", "DestFile", "sourceFile", "newfilename", "Destfile", "srcpath", "buildFile", "newfp", "deststream", "Destpath", "tempfile", "sourcestring", "targetfile", "targeturl", "targetFile", "destroyfile", "newFile", " destpath", " deststring", " desturl", "srcFile", "destroypath", "buildfilename", "destfilename", "temppath", "srcstream", "desturl", "destpath"], "last": ["after", "ending", "recent", "nd", "core", "se", "count", "length", "offset", "style", "prev", "event", "empty", "depth", "later", "child", "old", "part", "range", "route", "end", "key", "cur", "code", "cat", "total", " Last", "max", "size", "Last", "base", "start", "ast", "left", "full", "next", "latest", "first", "path", "current", "value", "or", "real", "use", "from", "right"], "parent": ["ppa", "text", "partial", "shared", "url", "unit", "dest", "null", "loc", "Parent", "remote", "data", "child", "port", "part", "search", "anc", "parents", "exp", "pa", "valid", "and", "key", "test", "home", "temp", "source", "api", "section", "filename", "target", "ip", "base", "point", "mac", "id", "cache", "po", "string", "ac", "patch", "file", "name", "root", "next", "function", "path", "location", "ant", "current", "content", "pointer", "fat", "line", "p", "post"], "f": ["fd", "m", "lf", "e", "j", "sf", "b", "g", "flat", "fb", "folder", "fa", "o", "d", "ref", "feed", "h", "fs", "s", "inf", "i", "dir", "l", "self", "of", "base", "r", "found", "v", "file", "c", "fc", "t", "af", "full", "cf", "F", "fe", "fp", "p", "df"], "srcChannel": ["destChannel", "rcChan", "srcClient", "sourceChannel", "srcChan", "rcConnection", "destchannel", "rcClient", " srcchannel", "sourcechannel", "rcchannel", "destConnection", "srcConnection", "rcChannel", "srcchannel", "sourceChan", "sourceConnection", " srcClient", " srcConnection", " srcChan", "destChan", "destClient"], "dstChannel": ["destChannel", "idstChan", "idrcChan", "dstchannel", "idstChannel", "ddestBuffer", "dntContext", "dsrcChan", "ddestChannel", "DstBuffer", "ddestContext", "DestContext", "dstChan", "dstButton", "DstChan", "drcchannel", "idrcButton", "dstsChannel", "idrcchannel", "dstBuffer", "destchannel", "dstContext", "DestChan", "dstschannel", "drcButton", "idstButton", "DstChannel", "dntBuffer", "dsrcButton", "ddestChan", "dsrcChannel", "dntChannel", "idrcChannel", "drcChan", "dntChan", "dsrcchannel", "destBuffer", "drcChannel", "DestChannel", "Destchannel", "destButton", "DstContext", "DestBuffer", "destChan", "dstsChan", "Dstchannel", "idstchannel", "destContext"]}}
{"id1": "2521141", "id2": "3187685", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["ame", "ize", "rm", "pe", "write", "image", " cp", "cp", "attach", "ge", "link", "sync", "zip", "archive", "paste", "clone", "clip", "type", "download", "ignore", "move", "cat", "Copy", "create", "source", "config", "open", "directory", "delete", "dump", "change", "load", "file", "share", "upload", "diff", "get", "transfer", "update", "opy", "cop"], "from_name": [" from_key", "source_memory", "fromMname", "source_name", " from_Name", "from_path", "fromMfile", "from_key", " from_names", "from_Name", "fromFfilename", "source_filename", "from__memory", "from_names", "from__filename", "fromFpath", "from__path", "fromFmemory", "fromMnames", "from_memory", "to_path", "fromFname", "source_path", "to_filename", "from_filename", "from__name"], "to_name": ["toampath", "toamfile", "to_Name", "to_path", "to_home", "toamname", " to_Name", " to_home", "toamhome", " to_path", "to_filename", "from_path", "from_filename"], "from_file": ["from___filename", "fromapplane", "source_resource", "from_resource", " from_filename", "fromCfilename", " from_folder", "from_files", " from_auto", "source_name", " from__name", "from__file", "from__resource", "from_auto", " from__file", "remote_function", "from___name", " from__filename", "from_lane", "fromCname", "fromappfile", " from_source", "from_folder", " from_files", "remote_file", " from__auto", "source_directory", "source_filename", "from_log", " from_directory", "from___file", "remote_log", "remote_lane", "source_files", "from___auto", "fromappfunction", "from_source", "fromCbrain", "from_function", "from__filename", "from__files", "fromCfile", "from__directory", "source_brain", "from__auto", "source_file", "from_brain", "from_directory", "from_filename", "fromapplog", "from__name"], "to_file": ["into_function", "tojname", "to_dir", "eto_name", "from_files", "into_use", "eto___remote", " to_filename", "tojuse", "to67file", "to64function", " to_queue", "to64file", "intojfunction", "tojfile", "to_class", "to64use", "to__dir", "to_queue", "from_model", "to_server", "to__name", "intojname", "source_filename", "eto_remote", "to_bar", "to___file", "to_use", "from_stream", "toJname", "to___name", "to_load", "source_files", "to_files", "to__file", "toJfile", "eto___file", "to67name", "toJbar", "to_model", " to_model", "eto___name", "intojfile", " to_class", "to__load", " to_files", "into_name", "eto_file", "to64name", "to_remote", "to___remote", "to_binary", "intojuse", "to_stream", "tojfunction", "source_file", "from_dir", "to_function", "from_bar", "toJstream", "to67dir", "from_binary", "into_file", "source_server", "to_filename", "from_load", "to67load"], "parent": ["ppa", "null", "term", "part", "search", "pa", "temp", "directory", "target", "div", "po", "cache", "string", "patch", "file", "ac", "root", "per", "owner", "page", "uri", "unit", "resource", "server", "connection", "Parent", "par", "remote", "port", "inc", "old", "folder", "test", "type", "tree", "point", "handler", "mother", "global", "path", "content", "url", "complete", "loc", "rule", "parents", "out", "api", "memory", "size", "user", "any", "id", "function", "location", "manager", "child", "session", "container", "home", "source", "client", "ip", "address", "name", "am", "full", "host", "pool", "current", "or", "author", "fat", "p"], "dir": ["url", "nav", "module", "build", "dr", "loc", "rel", "manager", "lock", "io", "die", "data", "md", "dec", "part", "folder", "group", "entry", "f", " directory", "dep", "in", "block", "exp", "d", "coll", "dev", "container", "out", "wd", "home", "cur", "ver", "dict", "cat", "class", "iter", "directory", "di", "keep", "db", "user", "tr", "r", "object", "id", "div", "cache", "ir", "file", "name", "dc", "def", "global", "root", "per", "dis", "path", "or", "Dir", "director", "doc"], "from": ["pe", "component", "From", "url", "fr", "one", "e", "server", "se", "without", "view", "connection", "form", "ce", "two", "io", "empty", "this", "link", "part", "range", "entry", "flo", "so", "cor", "ch", "feed", "bean", "conn", "source", "add", "api", "with", "parse", "client", "cm", "stream", "self", "base", "can", "address", "cache", "who", "low", "file", "con", "start", "name", "find", "by", "vol", "when", "left", "per", "ou", "get", "auto", "normal", "or", "ra", "context", "cf", "fe", "http", "cr"], "to": ["proxy", "too", "write", "one", "server", "dest", "connection", "two", "io", "fb", "store", "tto", "session", "sync", "socket", "not", "output", "via", "so", "flo", "about", "o", "storage", "su", "out", "type", "conn", "that", "see", "ver", "api", "top", "TO", "client", "size", "co", "with", "target", "pi", "db", "base", "will", "po", "token", "file", "by", "t", "per", "thro", "op", "until", "auto", "as", "or", "value", "To", "office", "fat", "http", "on"], "buffer": ["border", "wave", "buf", "bb", "page", "padding", "writer", "url", "default", "message", "resource", "server", "length", "b", "null", "data", "duration", "Buffer", "channel", "shape", "document", "batch", "read", "row", "texture", "total", "flush", "iter", "memory", "source", "reader", "header", "comment", "buff", "seed", "number", "queue", "position", "slice", "variable", "address", "character", "window", "binary", "reference", "layer", "uffer", "transfer", "feed", "block"], "bytes_read": ["bytes_load", "bytes_en", "byteslexcurrent", "bytesXcurrent", "bytes_reads", "bytes_current", "gets___allow", "bytes___pass", "gets_pass", "gets_read", "bytes___reads", "byte_read", "bytes___read", "bytesXbefore", "bytesXread", "gets___pass", "gets___reads", "byteslexread", "bytes_before", "byte_load", "bytes_write", "gets_allow", "bytesXload", "byte_before", "bytes___allow", "byteslexbefore", "gets___read", "bytes_allow", "gets_reads", "byte_current", "byteslexload", "bytes_pass", "bytes_found", " bytes_found", " bytes_write", " bytes_en"]}}
{"id1": "1986417", "id2": "411595", "code1": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"export": ["fn", " upload", "module", "write", " writer", "io", "output", "f", " fn", " reporter", "process", "print", " exports", "work", " transform", "exec", "handler", "file", " report", " output", "function", "fp"], "lib": ["fn", "log", "url", "module", "server", "script", "os", "io", "data", " libraries", "loop", "editor", " fn", " Library", "val", " library", " Lib", "dll", "plugin", "dl", "config", "library", "src", "reader", "ruby", "l", "db", "local", "LIB", "language", "Library", "bin", "file", "loader", " script", "ld", "ctx", " module", "ler", "lc", "ino", "lang", "Lib", "browser"]}}
{"id1": "6371607", "id2": "300397", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"removeRealm": ["removeScheM", "deleterealM", "removeSchems", "removerealms", "deleterealam", "delRealM", "removeRealam", "removeRelm", "deleteRealam", "removeRealms", "delBroadms", "delRealme", "removeScheme", "removeRelam", "removeBroadms", "removeRelms", "removeBroadM", "delRealm", "delBroadM", "removeSchem", "removeLocalam", "removeLocalms", "removeRealM", "deleterealms", "deleterealm", "removeRealme", "delRealms", "removerealM", "removeLocalM", "removeBroadme", "removerealm", "removeLocalm", "removerealme", "removeBroadm", "removeRelM", "delBroadm", "delBroadme", "deleteRealm", "deleteRealM", "removerealam", "deleteRealms"], "realmIds": ["realmIDes", "realmIDls", "realmRefs", "realmByIdls", "realMIdList", "realmIdids", "realMIdids", "realmRefes", "realmIntos", "realmIdes", "realMByIdls", "realmByIdes", "realMPaths", "realmIdList", "realMPathids", "realMPathos", "realmPaths", "realMByIdes", "realmPathos", "realMIdes", "realmRefls", "realMIdos", "realmInts", "realmRefos", "realmPathids", "realmIDList", "realmIdls", "realmByIdList", "realMIdls", "realMByIdList", "realmIdos", "realmByIds", "realMIds", "realmIntes", "realmIDs", "realmPathes", "realmRefList", "realMByIds", "realmRefids", "realmIntids", "realMPathes"], "psImpl": ["epsImpl", " psExpl", "qsHelper", "epsHelper", "cssImpl", "cssimpl", "csImpl", "dsHelper", " psIter", "psIter", "epsimpl", "dsImpl", " psHelper", "epsExpl", "epsIter", "psHelper", "cssIter", "csimpl", "psimpl", "dsimpl", "qsImpl", "cssExpl", "psExpl", " psimpl", "csHelper", "qsimpl"], "iter": ["enter", "page", "e", "itter", "loc", "init", "outer", "ner", "inc", "ie", "cer", "limit", "in", "loop", "it", "entry", "finder", "index", "coll", "upper", "sort", "end", "el", "gener", "apper", "i", "parse", "reader", "ter", "er", "inner", "former", "walker", "ir", "err", "list", "Iter", "inter", "ator", "izer", "next", "ite", "cher", "ler", "iterator", "line"], "realmId": ["realmcId", "realmRef", "realmaId", " realmnId", " realmOffset", "ironmaInt", "ironmId", "realmID", "ironmaId", "workfid", "realamNum", "workmID", "realmsId", "realamid", "realrmRef", "workfId", "realmcID", "realmeName", "RealmName", "realarmId", " realmnOffset", "realmid", "realfNum", "ironmRef", "realfID", "workmNum", "RealmPath", "realarmName", "realmnId", " realmConfig", "ironmInt", "realmnHash", "RealmID", "realmOffset", "ironmaID", "realmrid", "realdmId", " realmHash", "realmaID", "realmrId", "realmConfig", "realmaInt", "realfId", "realdmHash", "realrmInt", "workfNum", "ironmID", "realmsName", "realmPath", "RealmsPath", "workmid", "realmnOffset", "realmnConfig", "realmHash", "realdmOffset", "workmId", "realmrID", "realmName", "RealmId", "realfid", " realmnConfig", "realmrConfig", "realmInt", "realmePath", "realmrNum", "realmNum", "realmaRef", "realmrHash", "realmcRef", "realamId", "realmcInt", "realdmConfig", "realmeID", "realmrOffset", " realmnHash", "realarmPath", "realrmID", "realrmId", "realmeId", "realamID", "workfID", "RealmsId", "realarmID", "RealmsName", "ironmaRef", "realmsID", "realmsPath", "RealmsID"]}}
{"id1": "9805906", "id2": "2642914", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"dump": ["save", "ln", "copy", "info", "data", "store", " dumping", "f", " dumps", "zip", "all", "out", "download", "flush", " dumped", "dir", "db", "files", "load", "println", "diff", "transfer", "ump", "update", "Dir", "export", "df"], "source": ["uri", "unit", "resource", "server", "se", "core", "parent", "view", "connection", "remote", "this", "series", "Source", "site", "input", "ources", "s", "sin", "iter", "src", "stream", "slave", "base", "slice", "address", "string", "ource", "file", "start", "service", "SOURCE", "current", "scene", "http", "use", "from"], "target": ["replace", "to", "resource", "large", "parent", "dest", "null", "master", "connection", "project", "port", "follow", "output", "alias", "it", "result", "effect", "template", "out", "settings", "top", "src", "Target", "base", "table", "object", "address", "arget", "file", "platform", "root", "goal", "next", "host", "path", "pointer", "office", "enemy", "force", "database"], "is": ["ls", "ins", "gets", "isi", "isl", "ps", "ori", "lis", "info", "mis", "obs", "io", "nis", "ics", "iso", "oss", "in", "es", "bis", "bos", "IS", "us", "ists", "oses", "ens", "s", "iris", "ws", "ios", "i", "im", "ip", "ses", "iss", "ais", "ris", "has", "Is", "ops", "ai", "ui", "as", "or", "isa", "cs", "abs", "opens", "ois", "bs", "was", "its"], "os": ["ros", "oa", "dos", "nos", "ss", "acs", "ps", "io", "ori", "obs", "ies", "osi", "oss", "cos", "aos", "pos", "ose", "es", "ows", "o", "bos", "vs", "us", "oses", "ips", "fs", "s", "ols", "ens", "ues", "ios", "i", "Os", "oos", "oes", "outs", "los", "ais", "ops", "as", "or", "cs", "bs", "its", "boot", "ks", "OS", "ds"], "done": ["loaded", "after", "enabled", "running", "odo", "one", "complete", "ready", "got", "nice", "none", "started", "die", "empty", "data", "later", "last", "part", "gone", "once", "progress", "finished", "future", "made", " finished", " Done", "foo", "checked", "Done", "de", "doing", "due", "disabled", "confirmed", "defined", "next", "expected", "current", "always", "did", "yes", "dirty", "dad"]}}
{"id1": "3558512", "id2": "14598566", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialize", "normalized", "normalze", "Serialze", "finalized", "erialization", "Serialify", " serialization", "finalify", "Serialized", "finalize", "serialze", "Serializable", "erialize", "Serialization", "finalze", "normalize", "erialze", " serialze", "serialify", " serializable", "serializable", "serialization", "serialized", "normalify", "erializable"], "out": ["page", "ex", "gen", "writer", "report", "image", "server", "copy", "parent", "io", "data", "raw", "output", "archive", "o", "Out", "conn", "temp", "i", "source", "client", "filename", "a", "png", "dump", "outs", "cache", "string", "exec", "bin", "err", "file", "obj", "name", "loader", "up", "w", "OUT", "pool", "content", "buffer"], "parser": ["pe", "pillar", "writer", "lp", "txt", "server", "copy", "master", "parent", "ss", "cp", "system", "rar", "tt", "test", "plugin", "pkg", "instance", "class", "xml", "parse", "reader", "builder", "seed", "er", "worker", "base", "cache", "handler", "file", "upload", "loader", "Parser", "up", "per", "php", "as", "wrapper", "pp", "manager", "p", "processor", "arser"], "on_disk": ["off_demand", "on_delete", "off_drive", "onbootstorage", "onJdisk", "onbookdisk", "off_delete", "off_disk", "on_drive", "on_lock", "onJlock", "onnetfile", "off_storage", "onbootdrive", "onnetdemand", "onjdrive", "on_demand", "onjdisk", "off_lock", "onnetdrive", "off_file", "onjspace", "onnetspace", "onnetdisk", "onJdemand", "on_file", "onjfile", "onbootlock", "on_space", "onbootdisk", "onbookdelete", "onbookdrive", "on_storage", "off_space", "onJdrive"], "in": ["ins", "In", "copy", "ax", "connection", "thin", "info", "data", "inc", "socket", "f", "input", "o", "din", "IN", "inn", "lin", "inas", "conn", "pass", "i", "rin", "win", "kin", "reader", "source", "stream", "login", "inner", "min", "r", "ac", "bin", "file", "con", "c", "pin", "ini", "as", "again"]}}
{"id1": "2221297", "id2": "8166767", "code1": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 1, "substitutes": {"getURLContent": ["parseurlcontent", "parseURLBody", "getPageBody", "getStringBody", "geturlContents", "parseurlContent", "parseurlContents", "getURLContents", "getURLcontent", "getURLBody", "parseURLContents", "geturlBody", "parseURLcontent", "parseurlBody", "getPageContents", "getPagecontent", "getStringcontent", "geturlcontent", "getStringContents", "geturlContent", "getStringContent", "getPageContent", "parseURLContent"], "urlToSearchString": ["urlTOSearchString", "urlToFindArray", "urlToCreateStr", "urlTOSearchStr", "urlToSearchStr", "urltoSearchSection", "urltoSearchString", "urlTosearchStr", "urlToSearchArray", "urlTOFindStr", "urltosearchStr", "urltosearchSection", "urltoSearchStr", "urlToFindString", "urlToSearchSection", "urlTOFindSection", "urltoSearchArray", "urlTosearchSection", "urlTosearchString", "urlTOSearchArray", "urlTosearchArray", "urlToFindStr", "urlTOFindArray", "urlTOSearchSection", "urlToCreateString", "urlToCreateSection", "urlToCreateArray", "urlTOFindString", "urltosearchString", "urlToFindSection", "urltosearchArray"], "url": ["ur", "ls", "page", "log", "ssl", "uri", "ll", "resource", "server", "b", "connection", "org", "blog", "f", "zip", "www", "URL", "str", "ch", "job", "cb", "cur", "download", "jar", "rl", "client", "l", "web", "db", "base", "file", "c", "sl", "host", "Url", "lc", "http", "bb", "open"], "conn": ["conv", "rt", "auth", "ssl", "ct", "cn", "g", "conf", "n", "connection", "cp", "act", "loc", "rc", "io", "sync", "socket", "Connection", "connect", "nt", "ch", "nc", "cb", "cur", "Conn", "connected", "api", "config", "client", "cli", "db", "exec", "con", "c", "Config", "err", "dc", "ctx", "host", "enc", "http", "open"], "encoding": ["loccode", "encoder", "engoding", "enale", "enoder", "noded", " encoring", "decoding", "enoded", "nale", "locoded", "encale", "acoding", "noding", "engoder", "Encatin", "acoder", "encode", "engoded", "engcode", "locoding", " encoded", "enccode", "decoder", " encatin", "Encale", "decoded", "enoding", "locoder", "Encoded", "encoded", " encoder", "Encoder", "encoring", "noder", "engoring", "Encoding", "decoring", "acoded", "acatin", "encatin"], "br": ["buf", "bro", "fr", "arr", "b", "dr", "mr", "fb", "bh", "bc", "result", "str", "cro", "ch", "rb", "ref", "cb", "BR", "jar", "src", "reader", "grab", "stream", "db", "lr", "ber", "bar", "tr", "r", "orb", "err", "ob", "sr", "sp", "hr", "bl", "Br", "ab", "bridge", "http", "cr", "bb", "img", "browser"], "sb": ["ls", "kb", "bsp", "ssl", "lp", "sf", "b", "fb", "bt", "bp", "bh", "si", "xb", "lb", "bc", "sn", "pb", "SB", "rb", "lab", "cb", "mb", "bf", "bd", "builder", "bm", "amb", "src", "erb", "ruby", "buff", "sg", "db", "ib", "abb", " SB", "bj", "BB", "sa", "gb", "ob", "binary", "obb", "wb", "bot", "ab", "nb", "eb", "bs", "bb", "bps"], "line": ["page", "text", "LINE", "lf", "e", "b", "n", "body", "letter", "cell", "data", "link", "part", "pos", "f", "str", "lin", "cl", "lines", "end", "key", "out", "row", "code", "inline", "i", "comment", "source", "reader", "l", "len", "number", "base", "r", "string", "character", "c", "err", "Line", "name", "sl", "next", "response", "word", "content", "buffer", "lc", "feed", "char"]}}
{"id1": "7633336", "id2": "5836744", "code1": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 1, "substitutes": {"executeHttpGet": ["executehttpget", "executeHTTPPut", "execHttpGET", "execHttpPut", "execHTTPGET", "executeHTTPget", "executeUrlPut", "executehttpGET", "executehttpGet", "executeHttpGET", "execHttpGet", "executeHTTPGET", "execHTTPPut", "execHTTPGet", "executeUrlget", "executehttpPut", "executeUrlGet", "executeUrlGET", "executeHttpPut", "execHTTPget", "executeHTTPGet", "execHttpget", "executeHttpget"], "uri": ["proxy", "url", "resource", "message", "server", "connection", "io", "data", "port", " URI", "doi", "route", "URL", "href", "timeout", "uni", "i", "api", "cli", "pi", " ur", "object", "id", "address", "string", "URI", "ris", "name", "iri", "absolute", "ri", "path", "Url", "query", "response", "location", "ui", "qi", "http", "request"], "req": ["resp", "rec", "res", "Requ", "crit", "resource", "rx", "call", "requ", "this", "rect", "f", "ref", "Request", "job", "cur", "conn", "require", "pr", "pull", "api", "config", "rr", "exec", "err", "obj", "def", "gr", "ri", "proc", "get", "query", "response", "q", "http", "quest", "request"], "client": ["m", "proxy", "p", "u", "url", "resource", "server", "call", "g", "b", "connection", "force", "tc", "io", "connect", "cl", "h", "conn", "api", "config", "cli", "Client", "base", "cache", "https", "con", "c", "handler", "app", "service", "net", "per", "get", "response", "q", "http", "request", "open"], "resLogin": ["rsLogin", "resAccount", " resLog", "rssLog", "ResAccount", "reslogin", "resLog", "rsslogin", "rssLogin", "ResLogin", "resIn", " reslogin", "retLogin", "rslogin", "retIn", "ResIn", "rssAccount", "Reslogin", "retlogin", "rsIn", " resAccount", "ResLog"], "r": ["kr", "ur", "rt", "m", "res", "p", "writer", "u", "fr", "R", "e", "rx", "b", "dr", "nr", "rc", "rs", "rh", "rar", "f", "Reader", "rb", "rg", "pr", "i", "reader", "ar", "rl", "l", "er", "rr", "ir", "err", "c", "re", "rd", "sr", "w", "hr", "cr", "ri"], "sb": ["buf", "ls", "sth", "bsp", "rob", "sf", "b", "sv", "fb", "bt", "bh", "bp", "usb", "xb", "lb", "bc", "pb", "SB", "su", "rb", "cb", "mb", "bf", "amb", "bd", "bm", "src", "buff", "bg", "sg", "db", "bj", "abb", " SB", "zb", "string", "BB", "sa", "orb", "gb", "ob", "obb", "wb", "ab", "eb", "bs", "bb", "bps"], "s": ["ls", "u", "js", "ssl", "sf", "se", "b", "conf", "ss", "n", "os", "sv", "ps", "rs", "ns", "si", "sync", "f", "spec", "es", "str", "o", "comments", "su", "d", "lines", "h", "ws", "is", "comment", "sym", "side", "l", "a", "sg", "sub", "ses", "S", "address", "suff", "string", "c", "t", "sl", "abs", "strings", "feed", "p"]}}
{"id1": "20735941", "id2": "18433984", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"getFile": ["createFile", "openFiles", "newfile", "openFile", "newFiles", "getResource", "newResource", "createfile", "newFile", "getFiles", "createFiles", "createResource", "openfile", "openResource", "getfile"], "home": ["Home", "HOME", "include", "log", "default", "resource", "server", "parent", "build", "back", "store", "project", "this", "folder", "search", "f", "www", "family", "h", "class", "dir", "library", "directory", "base", "user", "bar", " HOME", "name", "up", "root", "host", "domain", "path", "first", "house", "location", "hub", "plus", "owner", "join"], "fileName": ["remotePath", " fileNum", "urlname", " filePart", "urlNum", "filePath", "FileNum", " filePath", "remoteName", "urlName", " fileType", "resourceName", "fileType", "FilePart", "singlePath", "fileNum", "fullPart", "fileUrl", " fileUrl", "fullname", "filename", "urlPath", "Filename", "FilePath", "resourceUrl", " filename", "remoteUrl", "singleName", "singlename", "FileName", "fullPath", "filePart", "singleType", "fullName", "FileType", "resourcePath"], "file": ["log", "FILE", "resource", "e", "ile", "image", "parent", "play", "money", "plain", "le", "connection", "letter", "lock", "data", "store", "child", "part", "folder", "output", "model", "f", "it", "zip", "rule", "uri", "feed", "job", "run", "type", "live", "el", "class", "source", "dir", "filename", "l", "work", "use", "db", "base", "place", "user", "table", "object", "local", "handler", "name", "be", "up", "full", "File", "function", "path", "line", "get", "current", "or", "buffer", "fe", "http", "fp", "lib"], "url": ["ur", "ls", "page", "log", "uri", "fr", "resource", "image", "server", "ssl", "b", "connection", "loc", "il", "org", "data", "io", "socket", "f", "impl", "zip", "rule", "www", "URL", "coll", "job", "conn", "el", "download", "i", "source", "pull", "api", "rl", "l", "web", "lr", "base", "r", "object", "address", "string", "ource", "name", "service", "ob", "sl", "lib", "host", "path", "Url", "location", "http", "feed", "bb"], "in": ["into", "ins", "resource", "e", "image", "In", "b", "n", "init", "io", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "lin", "s", "i", "source", "pull", "is", "reader", "inside", "a", "stream", "l", "login", "inner", "r", "ac", "bin", "c", "up", "ini", "as", "plus", "again", "line", "isin"], "out": ["to", "ex", "writer", "flow", "resource", "write", "plain", "copy", "null", "b", "In", "init", "io", "data", "this", "sync", "inc", "socket", "output", "exp", "o", "IN", "Out", "conn", "i", "source", "is", "client", "co", "inner", "base", "outs", "object", "exec", "bin", "err", "up", "net", "OUT", "again", "line", "serv", "ext"]}}
{"id1": "16623181", "id2": "4468255", "code1": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"srcDir": ["destFile", " srcDirectory", "sourceDirectory", "destFolder", "srcDirectory", " srcFolder", "rcDir", "sourceFolder", "destDir", "sourceFile", "destDirectory", "srcFolder", "rcFolder", "srcFile", "rcFile", " srcFile", "rcDirectory", "sourceDir"], "dstDir": ["DrcDirectory", "dndDir", "drcPath", "DrcDir", "dndFile", "DrcDIR", "DstPath", "DrcPath", "dptFile", "DstDir", "drcDirectory", "drcDIR", "dndDirectory", "dstDirectory", "DstFile", "dndDIR", "dotDir", "DstDirectory", "dptDir", "ddestFile", "DstDIR", "dptDirectory", "dstFile", "drcDir", "dptDIR", "DrcFile", "drcFile", "dotFile", "dotDirectory", "dstPath", "dotPath", "dstDIR", "ddestDir", "ddestPath", "ddestDirectory"], "srcFiles": [" srcfiles", "scPoints", "scFiles", "scFs", "rcDir", "sourcefiles", "rcfiles", "sourceFile", "srcPoints", "sourceFs", "srcfiles", "sourceFiles", " srcPoints", "rcFiles", "scFile", "srcFile", "srcFs", "rcFile", "sourcePoints", " srcFile", "sourceDir", " srcFs"], "f": ["fd", " F", "m", "fn", "u", "fr", "url", "lf", "e", "j", "sf", "b", "n", "fi", "fed", "form", "flat", " df", "io", "info", "fb", "folder", "fa", "o", "d", "ref", "feed", "h", "fs", "s", "rf", "tf", "bf", "i", "dir", "directory", "filename", "l", "self", "of", "files", "fx", "r", "v", "c", "file", "name", "fc", "t", "w", "path", "F", "x", "fe", "fp", "p"], "srcChannel": ["destChannel", "srcContext", "sourceContext", "rcBuffer", " srcBuffer", " srcContext", "rcChan", "srcClient", "sourceChannel", "srcChan", "sourceClient", "distChan", "rcConnection", "srcGate", "sourceBuffer", "rcClient", "rcContext", "distChannel", " srcchannel", "sourcechannel", "destConnection", "srcBuffer", "srcConnection", "rcchannel", "srcchannel", "rcChannel", "distchannel", "sourceChan", "rcGate", "distGate", " srcGate", "sourceConnection", " srcClient", " srcConnection", " srcChan", "destChan", "destContext"], "dstChannel": ["drcBuffer", "destChannel", "ddstChannel", " destChannel", " dstchannel", "dscChan", "dstchannel", "ddstChan", "dscBuffer", "dblBuffer", "ddrcchannel", "dblChannel", "DstBuffer", "Drcchannel", " destConnection", "drcHandler", "dstChan", "dstButton", "dstConnection", "drcchannel", "dstsChannel", "dscchannel", "destchannel", "ddrcChan", "ddstButton", "dstBuffer", "drcButton", "dstschannel", "dstHandler", "ddrcChannel", "DstChannel", "ddstchannel", "dblchannel", " destchannel", "destConnection", " destHandler", "dscButton", " dstHandler", " dstConnection", "drcChan", "drcChannel", "destHandler", "drcConnection", "DrcBuffer", "destButton", "dstsConnection", "dscChannel", "ddrcButton", "DrcChannel", "destChan", "Dstchannel", "dstsHandler"], "buffer": ["border", "wave", "buf", "bb", "pad", "request", "writer", "url", "resource", "image", "server", "message", "length", "copy", "b", "null", "offset", "fb", "data", "Buffer", "bc", "limit", "document", "result", "stack", "batch", "read", "job", "cb", "out", "cur", "row", "abi", "flush", "comment", "reader", "iter", "size", "header", "buff", "seed", "base", "bar", "queue", "r", "position", "cache", "bin", "loader", "binary", "reference", "layer", "uffer", "FFER", "transfer", "zero", "feed", "block"], "nr": ["cur", "orr", "nu", "wr", "fr", "rx", "ru", "n", "num", "mr", " sr", "ner", "pos", "vr", "ni", "result", "radius", "sn", "rn", "rb", "nl", " ni", "nc", "cb", "rf", "row", "ng", "nm", "rw", " NR", "uni", "nw", "iter", "i", "rl", "rr", "lr", "number", "eno", "r", "usr", "adr", "counter", "br", "err", "obj", "sr", "gr", "NR", "pointer", "nor", "nb", "ri", "nn"]}}
{"id1": "22235113", "id2": "7764011", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshalExML", "unmarshallxil", "unmarshallxml", "unmarshallYil", "unmarshallYson", "unmarshallExML", "unmarshallYML", "unmarshalExml", "unmarshallXil", "unmarshallXson", "unmarshalXil", "unmarshallExml", "unmarshallxML", "unmarshallExil", "unmarshalXml", "unmarshallXML", "unmarshalXML", "unmarshalExil", "unmarshalExson", "unmarshallxson", "unmarshallYml", "unmarshallExson", "unmarshalXson"], "unmarshaller": ["unmashaller", "unmarshallable", "unmockallinging", "unmarshalable", "unmarshiller", "unmarshalleders", "unmashallable", "unmashalledor", "unmarshalledor", "unmockalling", "unmarshalingers", "unmockallingers", "unmarshallinging", "unmashalleders", "unmarshaler", "unmarshalor", "unmashallor", "unmarshalleder", "unmarshallor", "unmarshalling", "unmarshaling", "unmarshallers", "unmarshalers", "unmockallinger", "unmashalledable", "unmarshillers", "unmarshillor", "unmarshalledable", "unmarshalinging", "unmarshallinger", "unmarshallingers", "unmockallers", "unmarshalinger", "unmashalleder", "unmashallers", "unmockaller", "unmarshillable"], "accessUrl": [" accessURL", "requestLink", "serviceUrl", "AccessUrl", " accessLog", "execUrl", " accessPath", " accessStream", "serviceLink", "inputURL", "accessFile", "accessLog", "inputUrl", "accessLink", "execFile", "requestLog", " accessLine", "serviceUr", "execURL", "accessURL", "requestPath", "AccessStream", "AccessLine", " accessUr", "AccessPath", "accessStream", "requestUr", "inputUr", "requestUrl", "requestFile", "accessUr", "inputLink", " accessFile", "requestURL", "requestStream", "execUr", "accessPath", "serviceURL", "AccessURL", "requestLine", "accessLine", "AccessLog"], "nameSpace": ["nameSp", " nameFrame", " namePath", "NameFrame", "NameSp", "namesspace", "resourceSpace", "resourceSp", "namePath", "resourcespace", "nameString", "NameName", "resourceString", "nameName", " nameName", "resourceFrame", "NameSpace", "nameFrame", "NameString", "Namespace", " nameString", "namesName", "namespace", " namespace", "namesSpace", "NamePath", " nameSp", "resourcePath", "namesSp"], "replace": ["places", "save", "prefix", "write", "append", "apply", "protect", "complete", "quote", "like", "tag", "store", "escape", "search", "alias", "group", "strip", "reply", "remove", "fill", "settings", "see", "placed", "comment", "add", "parse", "section", "pair", "sub", "flash", "same", "place", "r", "over", "change", "match", "string", "br", "patch", "repeat", "address", "name", "repl", "be", "find", "re", "fix", "cover", "get", "align", "operation", "insert", "format", "update", "where", "force", "use", "space", "join"], "with": ["at", "prefix", "partial", "include", "without", "resource", "message", "some", "apply", "style", " With", "With", "none", "tag", "before", "search", "document", "spec", "and", "claim", "settings", "around", "then", "plugin", "xml", "add", "properties", "flash", "work", "place", "id", "layout", "params", "name", "other", "by", "host", "context", " without", "get", "x", "format", "from", "join"], "url": ["page", "log", "fl", "uri", "ssl", "ll", "image", "server", "resource", "connection", "socket", "blog", "channel", "zip", "URL", "conn", "xml", "api", "rl", "client", "l", "stream", "base", "user", "address", "string", "file", "window", "service", "sl", "host", "path", "Url", "buffer", "http", "feed", "browser"], "inputStream": ["outputStream", "inputSteam", " inputSteam", "xmlSteam", "xmlStream", "inputContent", "outputstream", " inputContent", "InputContent", "inputReader", " inputReader", "Inputstream", "outputReader", "InputReader", "xmlReader", "InputBuffer", "InputSteam", "inputBuffer", "inputstream", "outputBuffer", " inputstream", "InputStream", " inputBuffer"], "xmlContent": ["fileDocument", "eventContent", " xmlString", "txtContents", "jsonHeader", "eventContents", "xmlString", "xmlHeader", "eventAddress", "fileMessage", " xmlMessage", " xmlDocument", "phpFile", "mlString", "xmlFile", "phpString", "mlHeader", "jsonContent", " xmlData", "xmlDocument", "xmlAddress", "broadText", "mlReader", "fileString", "txtAddress", "eventFile", "mlFile", " xmlAddress", "txtContent", "jsonReader", " xmlFile", " xmlContents", "mlContent", "broadContent", "broadDocument", "mlText", "xmlText", "broadMessage", "fileContent", "mlMessage", "txtFile", "jsonMessage", "xmlReader", "phpContent", " xmlHeader", "mlDocument", " xmlReader", "mlData", "phpData", "xmlContents", "xmlMessage", "xmlData", " xmlText"], "out": ["prefix", "page", "ex", "log", "writer", "array", "gen", "write", "report", "plain", "copy", "b", "io", "outer", "data", "project", "sync", "output", "in", "group", "f", "result", "exp", "password", "Out", "key", "temp", "flush", "builder", "stream", "outs", "user", "object", "cache", "file", "window", "err", "name", "extra", "up", "w", "full", "OUT", "path", "response", "word", "again", "doc", "ext"], "xmlRequestNumber": ["httpResponsenumber", "httpResponseNum", "xmlResponseCounter", "xmlFileCounter", "httpRequestNumber", "httpResponseCounter", "xmlRequestnumber", "xmlVersionNum", "xmlResponseNum", "httpRequestCounter", "httpRequestnumber", "xmlVersionCounter", "httpRequestNum", "httpResponseNumber", "xmlRequestNum", "xmlVersionnumber", "xmlResponseNumber", "xmlFileNum", "xmlVersionNumber", "xmlFileNumber", "xmlFilenumber", "xmlRequestCounter", "xmlResponsenumber"], "byteArrayInputStream": ["byteArrayByteStyle", "byteArrayReadSteam", "byteStringInputStream", "byteArrayInputStyle", "byteStreamOutputSteam", "byteArrayOutputFile", "byteStreamOutputArray", "byteArrayBytestream", "byteArrayInputstream", "byteStringOutputstream", "byteArrayReadFile", "byteArrayInputFile", "byteStreamInputStream", "byteStreamOutputStream", "byteArrayOutputstream", "byteStreamInputstream", "byteArrayTextStream", "byteArrayTextArray", "byteArrayInputArray", "byteArrayTextstream", "byteArrayByteSteam", "byteArrayReadstream", "byteStreamInputSteam", "byteStringInputstream", "byteStreamOutputStyle", "byteArrayOutputArray", "byteStringInputSteam", "byteArrayTextFile", "byteArrayReadArray", "byteStreamInputArray", "byteStreamInputStyle", "byteArrayReadStream", "byteArrayOutputStyle", "byteArrayByteStream", "byteStreamOutputFile", "byteStreamOutputstream", "byteStringOutputSteam", "byteStreamInputFile", "byteArrayOutputStream", "byteArrayOutputSteam", "byteArrayInputSteam", "byteStringOutputStream"], "source": ["proxy", "text", "component", "uri", "unit", "resource", "core", "copy", "null", "g", "scope", "view", "connection", "speed", "style", "ce", "event", "info", "data", "ge", "session", "model", "spec", "Source", "result", "input", "str", "rule", "zip", "type", "kin", "class", "iter", "src", "config", "size", "reader", "stream", "target", "slave", "inner", "slice", "position", "node", "id", "object", "string", "ource", "service", "sl", "SOURCE", "sp", "get", "wrapper", "content", "plus", "secure", "scene", "use", "rate"]}}
{"id1": "4921631", "id2": "18974466", "code1": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"create": ["save", "enter", "Insert", "write", "copy", "info", "store", "entry", "it", "draw", "result", "index", "end", "process", "add", "Create", "edit", "object", "start", "ite", "update", "execute", "database", "post"], "o": ["fo", "oa", "e", " mo", "os", " os", " object", "mo", "online", "oe", " O", "so", "od", "oi", "ao", "bo", "i", "vo", "co", "oro", " bo", "object", "oc", "po", "obj", "ilo", "oo", "ob", "t", "O", "op", "or", "office", "oid", "p", "OO", " e"], "insert": ["replace", "save", "Insert", "enter", "exit", "ert", "write", "append", "apply", "copy", "length", "sync", "inc", "search", " insertion", "entry", "ride", "ode", "result", "draw", " inserting", "check", "index", "read", "error", "row", "pull", "add", "push", "join", "seed", "edit", "delete", "ip", "use", "place", "position", "exist", "load", "patch", "repeat", "start", "success", "select", "xxx", "plus", "put", "update", "throw", "feed", "post"], "id": ["ID", "gen", "url", "length", "count", "parent", "event", "info", "data", "search", "in", "it", "check", "aid", "Id", "index", "pid", "error", "val", "end", "row", "code", "type", "time", "uid", "i", "action", "with", "add", "instance", "edit", "ip", "number", "ids", "show", "start", "name", "root", "ret", "x", "value", "update", "oid", "post"], "item": ["m", "attribute", "log", "unit", "e", "one", "parent", "ordered", "event", "like", "info", "data", "store", "this", "si", "entry", "it", "all", "result", "site", "model", "coll", "type", "temp", "xml", "element", "plugin", "source", "api", "article", "hop", "client", "atom", "reader", "er", "ip", "object", "seller", "Item", "obj", "product", "name", "app", "service", "entity", "other", "extra", "order", "full", "option", "op", "layer", "x", "or", "value", "update", "items", "p", "owner", "instance"], "pst": ["spst", "prsp", "pbSt", "npsp", "pstr", "Pct", "Ptd", "PSt", "Psts", "plSt", "psp", "Psc", "nST", "copcr", " prc", "vpst", "ppsp", "vpsts", " pSt", "Pstr", " psts", "psrc", "pth", " pstd", "prc", " pmt", "nsts", "npmt", "Pcr", "PST", "copSt", "pST", "psts", " pct", " psc", "psstr", "nptd", "pstd", "pste", "coppt", "nct", "Pste", "nst", " ptd", "plst", "psst", "pmt", " psp", "ppct", "plstd", "Pst", " pST", "prtd", "ppt", "plste", "Pth", "pSt", "psc", "ppsc", "spct", " pcr", "ppst", " pth", "copst", "vptd", "pbst", "pbcr", "prmt", "spSt", "lpste", "ptd", "prst", "Psp", "Prc", "pcr", "vpth", " pste", "lpstd", "pct", " pstr", "pscr", "spste", "npst", "pbpt", "lpst", "lpSt", " ppt"], "st": ["std", "est", "statement", "TS", "se", "struct", "ss", "ste", "ps", "sts", "tx", "ST", "pt", "sb", "inst", "str", "tt", "nt", "SS", "s", " sc", "rest", "pr", "St", "src", "r", "sc", "sa", "rd", "sl", "t", "sp", "ast", "ld", "mt", "sh", "bl", "ust", "cr", "sta"], "rs": ["kr", "ls", "ros", "res", "rss", "ins", "rows", "rx", "ss", "dr", "mr", "rc", "ps", " sr", "yr", "ums", "ges", "ows", "rys", "ys", "rg", "RS", "Rs", "ws", "ues", "pr", " res", "rl", "rr", "ras", "r", "ars", "ris", "eers", "icks", "ers", "xs", "rd", "sr", "hr", "ra", "cs", " rows", "runs", "ds", "vers"]}}
{"id1": "11475527", "id2": "9319440", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addDatafromurl", "addDatafromFile", "addDataFromurl", "addDataWithFile", "addDataWithUrl", "addDataWithURL", "addTextFromUrl", "addDataWithurl", "addDataFromUrl", "addTextFromURL", "addTextfromFile", "addDatafromUrl", "addDataFromFile", "addDataForFile", "addDatafromURL", "addTextFromFile", "addTextfromURL", "addDataForURL", "addDataForUrl", "addTextfromUrl", "addDataForurl", "addTextfromurl", "addTextFromurl"], "theurl": ["thereurl", " theuri", "pythonurl", "thepublic", "thereURL", "testURL", "myURL", " thelog", "theURL", "theuri", "testUrl", "thereuri", "pythonuri", "youURL", "pythonURL", " Theurl", " TheURL", " thepublic", "youlog", "myurl", "mypublic", "testurl", "myUrl", "youurl", "youUrl", " theURL", " TheUrl", "theUrl", " Thepublic", "thelog", "testlog", " theUrl"], "line": ["LINE", "text", "pe", "log", "url", "unit", "write", "le", "style", "connection", "letter", "cell", "link", "sync", "part", "no", "entry", "f", "model", "str", "lin", "feed", "lines", "nl", "key", "out", "row", "el", "code", "pass", "cl", "i", "comment", "source", "reader", "li", "l", "len", "number", "base", "object", "id", "string", "character", "file", "Line", "name", "buffer", "ine", "block", "char"], "in": ["m", "rin", "ins", "url", "fin", "image", "In", "b", "init", "io", "info", "inc", "socket", "it", "oin", "input", "fa", "din", "IN", "inn", "lin", "read", "out", "s", "conn", "pass", "cin", "i", "is", "source", "win", "reader", "record", "client", "inside", "nin", "l", "a", "login", "stream", "inner", "r", "bin", "file", "err", "pin", "ini", "or", "arin", "again", "serv", "isin"], "data": ["DATA", "writer", "url", "default", "one", "body", "connection", "like", "info", "this", "output", "entry", "f", "result", "input", "o", "d", "dat", "lines", "end", "out", "conn", "i", "source", "iter", "reader", "di", "stream", "er", "l", "inner", "da", "ata", "r", "handler", "file", "start", "la", "up", "next", "plus", "buffer", "open"], "e": ["ade", "ale", "pe", "ee", "ev", "one", "se", "en", "ce", "event", "ue", "ge", "je", "ie", "ec", "ele", "f", "oe", "edge", "es", "ise", "o", "ep", "ace", "ae", "error", "me", "element", "ze", "ne", "er", "E", "de", "eu", "et", "eme", "err", "ke", "ede", "be", "ea", "or", "ef", "fe", "exc", "ception"]}}
{"id1": "4686922", "id2": "822452", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourcesAsfile", "extractResourceToFiles", "extractResourceInResource", "extractResourcesToFile", "extractResourcesAsFile", "extractResourceAsFile", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceAndfile", "extractResourceInFiles", "extractResourceAndResource", "extractResourceToResource", "extractResourceAsfile", "extractResourceAndFile", "extractResourceTofile", "extractResourceAndFiles", "extractResourceAsFiles", "extractResourceInfile", "extractResourceInFile", "extractResourcesAsResource", "extractResourcesAsFiles", "extractResourceAsResource", "extractResourcesToResource"], "resourcePath": ["sourcepath", " resourceId", "Resourcepath", " resourceFolder", " resourcepath", "stringFolder", "stringpath", "resourceId", "resourcepath", " resourceUrl", "ResourcePath", "ResourceUrl", "stringPath", "resourceFolder", "servicepath", "servicePath", "resourceUrl", "sourceUrl", "sourceId", "sourcePath", "ResourceId", "serviceFolder"], "dest": ["prop", " Dest", "txt", "default", "resource", "const", "Dest", "destroy", "flat", "die", "data", "store", "project", "later", "output", "folder", "result", "route", "comb", "done", " destination", "home", "temp", "source", "class", "src", "config", "tmp", "filename", "target", "resources", "de", "trans", "desc", "file", "dist", "sup", "sac", "wb", "path", "transfer", "content", "contract", "img"], "in": ["rec", "ins", "url", "resource", "image", "In", "b", "n", "connection", "init", "thin", "like", "this", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "lin", "conn", "pass", "cin", "i", "is", "win", "source", "reader", "rin", "kin", "inside", "nin", "sin", "login", "inner", "r", "id", "bin", "c", "con", "file", "re", "up", "ini", "as", "plus", "arin", "again", "isin"], "out": ["at", "norm", "ex", "writer", "ins", "one", "image", "server", "copy", "null", "b", "n", "In", "ax", "parent", "io", "outer", "off", "this", "sync", "outside", "inc", "socket", "cos", "output", "cookie", "f", "all", "o", "Out", "s", "conn", "temp", "i", "source", "client", "a", "co", "outs", "user", "cache", "exec", "bin", "file", "err", "obj", "app", "up", "w", "net", "OUT", "lib", "auto", "again", "boot", "ext"]}}
{"id1": "1485383", "id2": "1169642", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplistInfo", "runGetApplicationListings", "runGetApplicationListing", "runGetApplicationlistInfo", "runGetAppSupportInfo", "runGetAppListInfo", "runGetApplistings", "runGetApplicationlisting", "runGetAppSearchInfo", "runGetApplistling", "runGetApplisting", "runGetAppListings", "runGetApplicationlistings", "runGetAppListling", "runGetAppSearching", "runGetAppSearchings", "runGetApplicationlistling", "runGetAppSupportings", "runGetAppSearchling", "runGetApplicationListInfo", "runGetAppSupporting", "runGetAppSupportling", "runGetApplicationListling"], "url": ["page", "proxy", "uri", "ssl", "resource", "e", "server", "image", "build", "b", "connection", "data", "channel", "f", "result", "route", "URL", "href", "download", "i", "builder", "source", "api", "config", "client", "l", "base", "address", "string", "file", "re", "service", "host", "path", "Url", "json", "location", "buffer", "http", "feed"], "appListingList": ["appLeningEx", "appListillingType", "appListningResult", "appHoldingingType", "appHoldingType", "appListillingLibrary", "appListingMap", "appListINGLayer", "appListingsInfo", "appListingsMap", "applistningResult", "appPoolingGroup", "appListINGEx", "appListitingList", "appPooliningGroup", "appHoldingList", "appListingsLayer", "appListingingLibrary", "appStingLayer", "appListingingGroup", "appListeningEx", "appListingsData", "appPoolingList", "appListitingData", "appListeningInfo", "appHoldingLibrary", "appLingEx", "appStINGLayer", "appListitingType", "appStingEx", "appPooliningList", "appListdingEx", "appListingingType", "appListgingMap", "appListingingList", "appHoldingingList", "appListitingResult", "appListINGList", "applistningEx", "appListingL", "applistingResult", "appListingsEx", "appListingGroup", "appListningEx", "appListninglist", "appListingLibrary", "appListningData", "appHoldinginglist", "appListingData", "appListningGroup", "appListillingList", "appListingEx", "appListinginglist", "appLingList", "appListinglist", "appListingsL", "appStingList", "appListingsList", "appLeningMap", "applistingData", "appListeningMap", "appStingL", "appStINGList", "appListdingList", "appStINGL", "appListdingL", "appLeningInfo", "applistningData", "appListiningList", "appListingType", "appPoolininglist", "appListINGL", "appListeningList", "appListininglist", "appStINGEx", "appListingInfo", "appLeningList", "appListningList", "appPoolinglist", "appListillinglist", "applistingList", "applistingEx", "appListdingLayer", "appListgingEx", "appLingInfo", "appListiningGroup", "appListitingLibrary", "appHoldingingLibrary", "appLingMap", "appListingLayer", "appListitingEx", "appListgingInfo", "appListingResult", "appListgingList", "appHoldinglist", "appListitinglist", "applistningList", "appListingsResult"], "request": ["page", "proxy", "req", "writer", "uri", "resource", "e", "server", "call", "report", "build", "complete", "message", "remote", "method", "project", "child", "hello", "have", "application", "result", "input", "job", "Request", "xml", "builder", "create", "parse", "push", "client", "command", "user", "queue", "r", "object", "address", "re", "service", "next", "get", "json", "query", "transfer", "condition", "buffer", "trip", "q", "http", "use", "callback", "post", "rate"], "readTimeout": ["writeTimeout", "readingTime", "readerTimeout", "readerAttempt", "readingAttempt", "writeSocket", "readTime", " readTime", "readtimeout", " readtimeout", "readingTimeout", " readSocket", "readingSocket", "writeTime", "readAttempt", "writetimeout", "readerTime", "readingtimeout", "writeAttempt", "readertimeout", "readSocket"], "response": ["wave", "resp", "page", "res", "array", "writer", "respond", "resource", "e", "server", "report", "message", "image", "Response", "body", "connection", "data", "version", "output", "application", "status", "document", "result", "site", "reply", "error", "api", "client", "stream", "object", "success", "re", "full", "next", "json", "generation", "http", "feed", "onse", "received"]}}
{"id1": "13783898", "id2": "19739421", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "2518655", "id2": "8801436", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fpOutput", "fnEx", "lsOutput", "fnIn", "FNOut", "lsOut", "FNIn", "FNOutput", "lsOUT", " fnOUT", "fpEx", "fpOUT", "FNEx", " fnFile", "fnOutput", " fnIn", "fnOUT", "fnFile", "fpFile", " fnOutput", " fnEx", "fpOut", "fpIn", "lsFile"], "writer": ["fd", "widget", "wr", "write", "server", "outer", "writing", "parser", "socket", "writ", "output", "entry", "winner", "editor", "Writer", "key", "out", "ws", "temp", "nw", "builder", "driver", "reader", "war", "riter", "a", "work", "er", "worker", "inner", "usher", "walker", "r", "wa", "handler", "file", "wire", "loader", "w", "per", "writers", "layer", "ler", "word", "buffer", "director"], "i": ["k", "m", "u", "z", "uri", "e", "j", "b", "n", "fi", "ori", "io", "si", "ie", "part", "f", "o", "index", "ci", "h", "type", "s", "iu", "oi", "key", "abi", "ji", "multi", "li", "di", "mi", "ip", "pi", "hi", "xi", "eni", "id", "ti", "v", "gi", "c", "ri", "I", "ai", "ix", "phi", "chi", "ii", "ui", "x", "bi", "ini", "qi", "strength", "p"], "fInput": ["fFormat", " fFormat", "sfinput", "finput", "sfFormat", " fOutput", "fSource", " finput", "fileinput", "fileFormat", "fileInput", "fileSource", "sfInput", "fOutput", "sfSource", "sfOutput", "fileOutput", " fSource"], "in": ["ln", "ins", "In", "b", "n", "connection", "scan", "init", "data", "version", "ner", "reading", "inc", "socket", "f", "gin", "input", "vin", "din", "IN", "inn", "lin", "inas", "out", "s", "conn", "cin", "sin", "kin", "rin", "reader", "win", "inside", "nin", "login", "inner", "min", "id", "bin", "c", "pin", "ini", "again", "line", "isin"]}}
{"id1": "14567939", "id2": "18114701", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"baseHash": ["Basehash", "BaseFile", " chainFile", " generateSecret", " chainhash", "baseFile", "BaseHash", "BaseSecret", " generatehash", "baseSecret", " generateFile", " generateHash", " chainSecret", "basehash", " chainHash"], "name": ["ame", "NAME", "prefix", "resource", "image", "parent", "style", "n", "data", "hello", "part", "alias", "member", "definition", "hash", "named", "key", "type", "class", "create", "Name", "base", "user", "object", "id", "address", "names", "account", "string", "file", "host", "path", "normal", "word", "secret"], "password": ["crypt", "prefix", "text", "padding", "attribute", "auth", "priv", "profile", "data", "username", "sword", "phrase", "hash", "input", "paste", "key", "wallet", "wd", "pass", "code", "source", "seed", "token", "string", "account", "stroke", "security", "device", "pattern", "diff", "words", "path", "word", "value", "Password", "secret", "PASS"], "digest": ["Diger", "Digusher", "mdester", "DigEST", "Digger", "modest", "modester", "signger", "Digester", "mdEST", "digEST", "Digest", " digested", "Digr", "mdr", "decr", "signusher", "signest", "digger", " diger", "signer", " digusher", "moder", " digester", " digger", "Digested", "digester", "decester", "signester", "decest", "diger", "digested", "mdest", "decEST", "digusher", "digr", "modested"]}}
{"id1": "6840241", "id2": "8788371", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["proxy", "write", "image", "server", "system", "cmp", "io", "sync", "loop", "clone", "clip", "type", "download", "process", "Copy", "create", "size", "slave", "ip", "mop", "load", "share", "cover", "transfer", "opy", "open", "cop"], "source": ["ink", "proxy", "e", "resource", "image", "se", "parent", "null", "server", "connection", "data", "this", "si", "session", "ie", "channel", "Source", "result", "input", "ources", "sin", "iter", "i", "src", "reader", "size", "stream", "target", "slave", "seed", "inner", "slice", "address", "ource", "handler", "start", "service", "SOURCE", "sp", "wrapper", "iterator", "use", "from", "rice"], "sink": ["sigh", "pinker", "dsink", "sinker", "dsinker", "sINK", "partsINK", "dsource", "tinker", "asinker", "pINK", "outsink", " sigh", "outsource", "Source", "outsigh", "tider", "Sinker", "pider", "pource", "Sink", "dsider", "tink", "asigh", "pink", "asource", "sider", "tource", " sinker", "partsinker", "SINK", "partsource", "asink", "partsink", "outsinker"]}}
{"id1": "21491791", "id2": "942693", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"run": ["spawn", "running", "log", "unit", "call", "apply", "build", "Run", "func", "loop", "all", "job", "test", "code", "process", "create", "work", "worker", "command", "fork", "exec", "start", "app", "runner", "invoke", "execute"], "input": ["text", "flow", "resource", "image", "view", "connection", "form", "io", "data", "parser", "reading", "raw", "in", "entry", "audio", "storage", "index", "read", "out", "conn", "instance", "source", "driver", "config", "client", "stream", "work", "worker", "inner", "user", "Input", "internal", "control", "address", "file", "initial", "loader", "up", "context", "state", "iterator", "active", "feed", "request", "readable"], "output": ["page", "text", "exit", "log", "console", "unit", "write", "resource", "image", "parent", "connection", "letter", "outer", "data", "later", "writing", "written", "application", "document", "generated", "index", "Writer", "job", "end", "out", "temp", "source", "Output", "config", "network", "filename", "web", "target", "user", "queue", "control", "object", "cache", "file", "writers", "path", "response", "environment", "operation", "put", "office"], "reader": ["book", "request", "peer", "resource", "image", "server", "rer", "view", "system", "io", "parser", "ner", "reading", "in", "entry", "audio", "Reader", "read", "row", "rator", "builder", "source", "driver", "client", "riter", "stream", "er", "worker", "slave", "inner", "r", "handler", "loader", "context", "wrapper", "author", "oder", "manager", "ri", "owner"], "writer": ["wr", "write", "wan", "connection", "outer", "data", "writing", "engine", "ner", "written", "writ", "entry", "creator", "her", "editor", "Writer", "ew", "out", "wer", "player", "maker", "ws", "rw", "builder", "nw", "driver", "war", "riter", "work", "er", "worker", "ter", "inner", "r", "wa", "wire", "w", "wb", "writers", "wrapper", "or", "word", "office", "author", "manager", "request"], "pump": ["camp", "ppumping", "pumping", "pamp", "prump", "Pmp", "mprint", "dumps", "pdump", " pmp", "Pam", "ppumper", "cump", "ppumps", "Pdump", "humper", "cumper", "mumper", "pumps", "Pumper", " pdump", "Pump", " pumper", "pam", "pumper", "pmp", "Pumping", "prumper", "pprint", "Pprint", "humps", " pumping", "dmp", "mump", "hump", "dump", "Pamp", "pram", "Pumps", " pumps", "dumper", " pam", "hprint", " pamp", "prdump", "ppump", "mumps", "cumping"], "counter": ["enter", "page", "Counter", "url", "server", "clock", "const", "master", "count", "parent", "offset", "num", "race", "outer", "version", "step", "ner", "hello", "sequence", "cookie", "loop", "entry", "now", "result", "meter", "timer", "second", "index", "ener", "row", "code", "ver", "instance", "progress", "consumer", "comment", "trace", "center", "rew", "builder", "keep", "ter", "er", "worker", "seed", "number", "ger", "walker", "lr", "r", "inner", "starter", "repeat", "loader", "continue", "inter", "order", "layer", "runner", "current", "currency", "pointer", "author", "zero", "collection", "keeper", "ception", "processor"], "buffer": ["buf", "page", "uf", "text", "url", "message", "resource", "server", "length", "data", "port", "Buffer", "channel", "limit", "entry", "document", "batch", "source", "iter", "header", "buff", "base", "queue", "position", "address", "file", "loader", "reference", "binary", "layer", "uffer"], "off": ["own", "art", "oa", "Off", "flow", "offset", "OFF", "info", "pos", "offs", "now", "area", "fail", "o", "set", "ref", "end", "out", "Offset", "open", "addr", "ff", "of", "opt", "inner", "eno", "less", "low", "ord", "start", "left", "down", "unknown", "ui", "auto", "head", "on", "offer"], "len": ["fd", "lon", "gen", "log", "ln", "fl", "url", "lf", "fin", "ll", "length", "count", "n", "body", "loc", "en", "lock", "lan", "limit", "in", "pos", "all", "elt", "lin", "ref", "Len", "end", "val", "el", "size", "width", "li", "l", "lit", "lim", "den", "bin", "name", "ld", "layer", "ler", "lc", "lt", "line", "on", "lib"], "rd": ["fd", "rt", "red", "rand", "rm", "rss", "raid", "fr", " r", "xd", "nd", "rx", "rob", "ru", "dr", "RR", "nr", "rc", "rs", "rh", "dd", "d", "rb", "rn", "val", "rid", "RD", "rw", "rl", "rr", "db", "lr", "r", "ind", "adr", "ud", "ord", "dra", "rod", "ld", " prod", "hr", "ra", "cr", "rf", "ds"]}}
{"id1": "21979462", "id2": "4750967", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURLasString", " downloadURLtoStr", " downloadUrltoString", " downloadUrlasLong", " downloadURL2String", " downloadUrltoStr", " downloadUrltoLong", " downloadUrltostring", " downloadURLtoLong", " downloadURL2string", " downloadUrlasstring", " downloadURLintoString", " downloadURLasStr", " downloadURLintoStr", " downloadURLasLong", " downloadUrlasString", " downloadUrlasStr", " downloadURL2Str", " downloadURLintostring", " downloadURLasstring", " downloadURLtostring", " downloadURL2Long", " downloadURLintoLong"], "url": ["page", "uri", "ssl", "resource", "image", "server", "b", "connection", "loc", "remote", "data", "link", "f", "rule", "URL", "ref", "job", "bel", "el", "source", "config", "l", "lr", "base", "user", "address", "gl", "file", "loader", "name", "service", "sl", "path", "Url", "buffer", "http"], "in": ["at", "into", "ln", "ins", "ssl", "fr", "rx", "In", "b", "n", "init", "fb", "data", "inc", "gin", "f", "impl", "it", "input", "din", "IN", "lin", "inn", "read", "h", "out", "s", "i", "is", "source", "reader", "cms", "nin", "login", "db", "inner", "min", "r", "ac", "bin", "err", "ic", "ilo", "re", "af", "ini", "as", "buffer", "again", "isin"], "sb": ["ls", "kb", "sth", "buf", "bsp", "sf", " eb", "b", "sv", "fb", "bt", "bp", "bh", "si", "usb", "xb", "lb", "bc", "pb", "SB", "rb", "lab", "cb", "mb", "s", "bf", "B", "bm", "bd", "amb", "src", "ub", "erb", "buff", "sg", "db", "lr", "ib", "abb", " SB", "zb", "BB", "sa", "gb", "obb", "wb", "buffer", "nb", "eb", "bs", "Bs", "bb"], "str": ["Str", "text", "wr", "stri", "fr", "txt", "arr", "STR", "ct", "b", "st", "dr", "n", "data", "f", "spec", "result", "exp", "coll", "cl", "read", "key", "cur", "s", "pass", "i", "pr", "iter", "l", "tr", "r", "div", "string", "br", "err", "obj", "name", "list", "sr", "sl", "sp", "bl", "lc", "enc", "line", "cr", "doc", "char"]}}
{"id1": "9857412", "id2": "18696387", "code1": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"writeData": ["writeDATA", " writePart", "outputPart", " writeBytes", "sendData", "outputBytes", "outputDATA", "writePart", " writeDATA", "writeBytes", "sendBytes", "sendPart", "outputData", "sendDATA"], "data": ["DATA", "buf", "sample", "text", "array", "resource", "image", "body", "connection", "sequence", "result", "input", "dat", "batch", "bytes", "timeout", "source", "memory", "reader", "multi", "config", "media", "resources", "queue", "video", "cache", "address", "load", "binary", "json", "response", "content", "value", "database"], "options": ["Options", "values", "keys", "resource", "details", "style", "scope", "io", "info", "parts", "times", "headers", "groups", "bytes", "meta", "settings", "results", "config", "properties", "vals", "opt", "files", "resources", "table", "object", "bits", "cache", "address", "obj", "params", "option", "ops", "ts", "json", "flags"], "transferMetaData": [" transferMetLeft", "transfermetaLast", "transferDataData", " transferMetaLeft", " transferMetaBreak", "ferMetaData", "transferDataScript", "ferMetaName", "sendMetaData", "sendMetaBreak", "sendMetaDATA", "transferMediaDATA", "transferMetaName", "transferMetaHash", "transfermetaBreak", "transferMetLast", "transferMediaData", "ferDataHash", "transferDataName", "transfermetaLeft", "transferMetaDATA", "transferMediaBreak", "transfermetaData", " transferMetaLast", "transferMetLeft", "ferDataScript", "transferMetaLeft", "transfermetaName", "transfermetaScript", "transfermetaDATA", "transferMetaBreak", "sendMetaScript", " transferMetLast", "ferDataData", "transferMetBreak", "transferMetData", " transferMetBreak", "transferMediaScript", "ferDataName", "transferMetaLast", "transferMetaScript", " transferMetData", "ferMetaHash", "transfermetaHash", "transferDataHash", "ferMetaScript"], "startTime": [" startTim", "initStream", "startLine", "initTim", " startLine", "StartPoint", "startedTime", "StartTim", "startPoint", " startPoint", "startStream", "initLine", "StartLine", "startTim", " startStream", "initTime", "StartTime", "startedLine", "startedPoint", "StartStream"], "transferredBytesNum": ["transferredbytesBu", "transferredByteChan", "translatedbytesNum", "transferredBytesMon", "translatedPagesLen", "translatedPagesMon", "transferredFilesBu", "transferredFramesMon", "transferredTokensNum", "transendedByteChan", "translatedBytesSum", "transferredBytesChan", "transferredFramesSum", "transferredbytesSum", "transferredPagesBu", "transendedBytesSum", "transferredTokensMon", "translatedbytesVal", "transferredFilesLen", "transferredFramesNum", "translatedPagesBu", "transferredFilesMon", "transendedBytesMon", "transendedBytesChan", "translatedBytesNum", "transferredPagesMon", "transendedByteNum", "transferredbytesVal", "transferredBytesSum", "translatedPagesNum", "transferredbytesLen", "transferredByteSum", "translatedBytesBu", "translatedBytesVal", "transendedByteMon", "transferredFramesChan", "transferredFilesNum", "translatedBytesMon", "transferredBytesBu", "transferredPagesNum", "translatedbytesSum", "transferredTokensChan", "translatedBytesLen", "transendedByteSum", "transferredByteMon", "transferredTokensSum", "transferredBytesLen", "transferredByteNum", "transferredByteVal", "transferredSharesSum", "transendedBytesNum", "transferredbytesNum", "transferredPagesLen", "transferredSharesVal", "transferredBytesVal", "transferredbytesMon", "transferredSharesNum"], "elapsedTime": ["elocatedTimes", "elayedtime", "elivedDuration", "ElapseValue", "elayedDuration", "elapseForce", " elavedForce", " elavedValue", "elroredForce", "elapseTimes", "elapsedForce", "elayedTime", "ElapseTimes", "elavedTime", "elivedtime", "elivedTime", "ElapseDuration", "Elapsetime", "ElapsedTimes", "Elapsedtime", "elapsetime", "ElapsedTime", "elroredValue", " elavedTime", "elapsedtime", "ElapsedDuration", "elavedForce", "elapseValue", " elapsedValue", "elocatedTime", "elapsedTimes", "elapsedDuration", "elocatedValue", "elapseTime", "ElapseTime", "elroredTime", " elapsedForce", "elapseDuration", "elavedValue", "ElapsedValue", "elapsedValue", "elroredTimes"], "opts": ["OPtt", " opments", " optt", "preters", "copts", "optts", "ottr", "OPfs", "optments", "OPps", "opfs", "optTS", "optrs", "opty", "OPters", " optte", "obter", "optps", "prets", "OPty", "optty", "OPter", "opttt", "opters", " oprs", "optr", "coprs", "otTS", "opter", " optts", "prete", " optters", "otter", "oprs", " opps", "opments", "opps", "otts", "OPts", "obTS", "copTS", "OPTS", "obtr", "copments", " optfs", "OPtr", " opty", "optte", "obts", "optt", "prefs", "OPte", "opTS", " opTS", "opte", " opte"], "server": ["prefix", "peer", "uri", "ssl", "resource", "localhost", "ser", "system", "Server", "version", "sys", "socket", "port", "folder", "site", "type", "client", "user", "erver", "address", "email", "string", "name", "service", "host", "domain", "path", "value", "http", "serv", "secret", "database"], "username": ["ame", "prefix", "attribute", "mobile", "auth", "subject", "uri", "USER", "users", "profile", "info", "method", "port", "sword", "family", "key", "uid", "config", "client", "filename", "header", "login", "user", "usr", "email", "address", "string", "account", "character", "token", "machine", "name", "property", "dn", "path", "ername", "ui", "nick", "manager", "person", "database", "staff"], "password": ["prefix", "attribute", "padding", "pad", "auth", "uri", "mask", "resource", "priv", " passwords", "profile", "session", "port", "sword", "phrase", "channel", "fax", "sudo", "key", "wallet", "wd", "pass", "column", "client", "user", "token", "account", "params", "name", "device", "path", "word", "nick", "Password", "secret", "PASS"], "filePath": ["fileParent", "FILEPath", "workpath", "FileUrl", "FILEName", " fileParent", "FILEpath", "basepath", "singleUrl", "workPath", "FILEUrl", "FileParent", "singleInfo", " fileType", "Filepath", "baseName", "resourceName", "fileType", "singlePath", "resourcepath", "fileUrl", " fileHandler", "filepath", "resourceType", "FilePoint", "FileHandler", " fileUrl", "filePoint", "FILEHandler", "workName", "singlepath", " filePoint", "fileInfo", "fileHandler", " fileInfo", "FilePath", "FILEParent", "resourceUrl", "FILEPoint", "singleName", "FileName", "basePath", "workType", " filepath", "resourceInfo", "resourcePath", "baseUrl"], "idx": ["pidx", "intx", "intX", "IDn", "idxs", "Idxc", "indn", " idc", "indx", "IdX", " idxs", "Idn", "indc", "indy", "idy", "intxs", "indxc", " idX", "IDy", " idn", "pidn", "Idy", "IDX", " idy", "pidc", "idv", "intv", "indv", " idv", "idn", "idxc", "indX", "IDx", "idX", "pidX", "idc", "indxs", "Idx", " idxc"], "fileName": [" filePart", "resourceName", "FilePart", "resourcePart", "sourcePart", "fileInfo", "filename", " fileInfo", "Filename", "FileInfo", "FilePath", "sourcename", " filename", "FileName", "filePart", "sourcePath", "resourceInfo", "sourceName", "resourcePath"], "url": ["proxy", "page", "p", "fl", "uri", "ssl", "resource", "z", "build", "b", "g", "connection", "io", "org", "f", "impl", "www", "URL", "o", "str", "bel", "i", "api", "config", "client", "li", "web", "l", "base", "user", "object", "v", "gl", "service", "t", "sl", "host", "json", "Url", "http", "bb", "open", "browser"], "urlc": ["webac", "downloadc", "webcode", "URLfc", "slc", "serverf", "httpp", "urlcf", "httpci", "downloadci", "urlf", "serverfc", "urlac", "webf", "slcf", "urlci", "urlcode", " urlC", "urlp", " urlcode", "downloadfc", "URLc", " urlac", "urlfc", " urlf", "httpf", "httpac", "downloadC", "servercode", "slp", " urlfc", "httpc", "webfc", " urlp", "serverc", "webc", "urlC", "URLC", " urlci", "URLci", " urlcf", "httpcf", "slci", "webp"], "os": ["ros", "oa", "dos", "http", "fits", "ori", "io", "ot", "obs", "las", "ps", "osi", "iso", "oss", "socket", "aos", "cos", "pos", "so", "o", "bos", "us", "oses", "out", "s", "conn", "fs", "oi", "oS", "ios", "is", "i", "Os", "oos", "bits", "mos", "los", "obj", "ob", "ops", "bs", "oid", "boot", "OS", "ors"], "bis": ["ls", "dos", "ins", "pins", "b", "lis", "obs", "ori", "fb", "nis", "usb", "uds", "oss", "cos", "aos", "sb", "bos", "lins", "bytes", "cb", "fs", "oi", " Bis", "abi", "ios", " cis", "is", "bes", "boot", "co", "buff", "opus", "alis", "ses", "bits", "phys", "cache", "los", "ais", "ris", "obj", "sis", "rots", "ob", "ri", "obb", " bos", "bi", "abs", "ois", "bs", "bb", "bps", "ubis"], "buffer": ["border", "buf", "bb", "available", "padding", "button", "message", "resource", "length", "b", "this", "Buffer", "channel", "sequence", "document", "batch", "timeout", "texture", "source", "flush", "memory", "iter", "reader", "header", "buff", "queue", "position", "table", "cache", "string", "window", "binary", "device", "reference", "vector", "pause", "layer", "uffer", "FFER", "value", "feed", "block"], "br": ["buf", "span", "bro", "wr", "fr", "arr", "shr", "j", "gap", "length", "b", "dr", "nr", "mr", "yr", "bp", "bh", "bc", "ele", "bal", "str", "block", "ch", "cb", "el", "ver", "BR", "bf", "bd", "i", "cm", " Br", "bre", "rib", "width", "li", "lr", "ber", "bn", "tr", "ctr", "bar", "r", "div", "err", "obj", "gr", "aa", "pre", "next", "hr", "bl", "ler", "or", "bi", "Br", "bridge", "line", "cr", "p", "img", "char"]}}
{"id1": "18489832", "id2": "15580610", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" doLoadZaggedFiles", " doLoadZedFiles", " doLoadZippedFiles", " doLoadzippedFiles", " doLoadZaggedContent", " doLoadZippingDir", " doLoadzippingContent", " doLoadZippingFile", " doLoadZaggedDir", " doLoadzippedFile", " doLoadzippingFile", " doLoadZippingContent", " doLoadZaggedFile", " doLoadzippingFiles", " doLoadzippedContent", " doLoadZedDir", " doLoadZippedFile", " doLoadZedContent", " doLoadzippedDir", " doLoadzippingDir", " doLoadZippingFiles", " doLoadZedFile", " doLoadZippedContent", " doLoadZippedDir"], "url": ["ur", "proxy", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "b", "connection", "event", "store", "link", "f", "zip", "route", "URL", "download", "i", "source", "pull", "config", "client", "l", "web", "lr", "base", "r", "file", "c", "loader", "sl", "bug", "Url", "or", "update", "http", "lib", "open"], "destDir": ["destFile", " destFile", " destFolder", "tempFile", "destdir", "destFolder", "tmpdir", "tempFolder", " destdir", "tmpDirectory", " destDIR", "tmpDIR", "outputFile", "DestFile", "outputDirectory", " destDirectory", "DestDir", "tempDIR", "tempDir", "outputDIR", "outputDir", "outputFolder", "DestDIR", "destDIR", "destDirectory", "outputdir", "tmpDir", "DestFolder"], "urlConnection": ["urlNetwork", "webConnect", "URLChannel", "urlConnect", "URLconnection", "webChannel", "httpNetwork", "httpFactory", "URLConnect", "webconnection", "downloadNetwork", "webConnection", "URLConnection", "fileConn", "fileFactory", "urlConn", "urlChannel", "urlconnection", "downloadFactory", " urlConnect", " urlChannel", "httpConnection", "fileNetwork", "fileConnection", "downloadConnection", "urlFactory", "downloadConn", " urlconnection", "httpConn"], "tmpFile": ["destFile", "mpfile", "mpFile", " tmpFolder", " tmpPath", "partfile", "mpPath", "tempPath", "tmpFolder", "destWorld", "zipFiles", "tmpfile", "TempPath", "tempFile", "tmpFiles", "destFolder", "tempFiles", "tempEntry", " tmpFiles", "partFolder", "tmpPath", "partFile", "mpDir", "TempWorld", "destPath", "tmpLine", "Tempfile", "tempLine", "partDir", " tmpLine", " tmpfile", "tmpEntry", " tmpDir", "mpFolder", "zipFile", "tempfile", "zipfile", " tmpWorld", "tempDir", "destEntry", "zipLine", "mpFiles", "tmpWorld", "destfile", "tmpDir", "TempFile", " tmpEntry"], "in": ["ex", "ins", "In", "copy", "ax", "n", "connection", "en", "init", "info", "data", "sync", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "Out", "conn", "cin", "i", "is", "win", "source", "reader", "kin", "rin", "pull", "nin", "l", "a", "login", "work", "inner", "min", "r", "id", "token", "ac", "bin", "err", "con", "c", "file", "up", "pin", "ini", "as", "arin", "again"], "out": ["at", "ex", "writer", "one", "server", "call", "copy", "In", "null", "n", "connection", "cmd", "init", "io", "off", "outer", "this", "sync", "inc", "socket", "output", "no", "check", "o", "index", "IN", "Out", "conn", "download", "i", "source", "client", "nin", "co", "login", "inner", "point", "outs", "min", "exec", "bin", "file", "err", "obj", "name", "up", "OUT", "op", "again", "line", "ext"], "localURL": ["externalAPI", "LocalCL", "LocalAPI", "LocalUrl", " localFile", "localFile", "externalCL", "localAPI", "remoteURI", " localCL", "externalURL", "localCL", "externalUrl", "remoteURL", " localAPI", "localURI", "remoteUrl", " localURI", "remoteFile", "LocalURL", "localUrl", " localUrl", "baseFile", "baseURI", "baseURL", "baseUrl"]}}
{"id1": "17729554", "id2": "8150996", "code1": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"clonarFichero": ["clonarfichero", "clonarFaichero", "clonarfIChern", "clonarFaichern", "clonarFivehern", "clonarFICher", "clonarFIChero", "clonarFivehero", "clonarfICher", "clonarFicher", "clonarFicchio", "clonarficher", "clonarFiveher", "clonarfICchio", "clonarFaicchio", "clonarfichern", "clonarFivechio", "clonarFIChern", "clonarFichern", "clonarFICchio", "clonarfIChero", "clonarFaicher", "clonarficchio"], "rutaFicheroOrigen": ["rutaFichestOrigense", "rutaFicheroOpener", "rutaFichestOrigen", "rutaFicherOriginalener", "rutaFicherOrigens", "rutaFichestOriginened", "rutaFicheroOrigense", "rutaFichestOriginen", "rutaFicheroOpEN", "rutaFicheroOriginaleni", "rutaFicheroOrigener", "rutaFicheroOrigened", "rutaFicheroOpen", "rutaFicheroOpened", "rutaFicheroOrigininen", "rutaFicheroOriginalena", "rutaFicherOriginalEN", "rutaFicheroExtena", "rutaFicherOriginalen", "rutaFicheroOriginen", "rutaFicherOrigen", "rutaFicherOriginalens", "rutaFicheroOriginalEN", "rutaFicheroOriginened", "rutaFicheroOpens", "rutaFicheroOrigena", "rutaFicheroExteni", "rutaFichestOrigininen", "rutaFicheroOpense", "rutaFicheroOriginalened", "rutaFicheroOriginalinen", "rutaFicheroOriginalens", "rutaFicheroOriginalener", "rutaFicheroExtened", "rutaFicheroOpinen", "rutaFicheroOriginense", "rutaFicherOrigEN", "rutaFicheroOpeni", "rutaFichestOrigened", "rutaFicheroExten", "rutaFicheroOriginalense", "rutaFichestOriginense", "rutaFicheroOriginalen", "rutaFicheroOrigens", "rutaFicheroOpena", "rutaFicheroOrigeni", "rutaFicheroOrigEN", "rutaFicherOrigener"], "rutaFicheroDestino": ["rutaFicherRestina", "rutaFicheroDestario", "rutaFicheroDesino", "rutaFicheroDesario", "rutaFicherodestINO", "rutaFicheroRestario", "rutaFicheroRestino", "rutaFicherRestario", "rutaFicherOrigino", "rutaFicheroCampin", "rutaFicherodestin", "rutaFicheroDestINO", "rutaFicheroDesINO", "rutaFicherDestin", "rutaFicherDestino", "rutaFicheroOrigino", "rutaFicheroRestina", "rutaFicheroDestination", "rutaFicherodestino", "rutaFicheroCampination", "rutaFicheroOrigin", "rutaFicherRestino", "rutaFicherDestination", "rutaFicherodestination", "rutaFicherDestario", "rutaFicheroCampINO", "rutaFicherDestINO", "rutaFicherRestINO", "rutaFicherDestina", "rutaFicheroOrigINO", "rutaFicherOrigINO", "rutaFicherOrigin", "rutaFicheroDestin", "rutaFicherOrigination", "rutaFicheroOrigination", "rutaFicheroDestina", "rutaFicheroCampino", "rutaFicheroDesina", "rutaFicheroOrigina", "rutaFicheroOrigario", "rutaFicheroRestINO"], "salida": ["Salica", "palada", "Salidi", "malida", "salido", "salica", "Salanta", " salidas", "balida", "malanta", "slida", "palanta", "malidi", "Salida", "slidas", " salanda", "palidi", "salanta", "Salada", "saliza", "Salido", "sliza", " salica", "Saliza", "balido", "Salidas", "salidas", "salada", "malada", " salido", "balica", "slanda", " saliza", "palida", "salidi", "salanda", "balanda", "Salanda"], "canalOrigen": ["canalOrigensen", "canalsOrigEN", "canalorigens", "canalsOriginaln", "canalOrigened", "canalsOriginalensen", "canalOriginalain", "canalsOrigened", "canelOriginalun", "canalOriginalen", "canalOriginalens", "canalOriginens", "canelOriginalens", "canelOrigun", "canalSequen", "canalOrden", "canalOriginalun", "canalorigain", "canalorigened", "canalOriginen", "canalOriginaline", "canalOriginun", "canalsOriginalened", "canalSequn", "canalOrign", "canalOriginalensen", "canelOrigine", "canelOrigens", "canalOrigine", "canelOriginalen", "canalsOrigens", "canelOriginaline", "canalOrigEN", "canalorigine", "canelOrigen", "canalsOriginalen", "canalorigensen", "canalOriginaln", "canalSequens", "canalOrdn", "canalsOriginalens", "canalorigun", "canalSequEN", "canalsOrigain", "canalsOriginalEN", "canalorigen", "canalOriginine", "canalOrigun", "canalOrdens", "canalsOrigensen", "canalOrigens", "canalsOrigen", "canalOriginalEN", "canalOrigain", "canalsOrign", "canalOrdEN", "canalOriginalened", "canalsOriginalain"], "canalDestino": ["canaldestination", "canpalDestination", "canpaldestino", "canaldestri", "canalDestination", "canaldestini", "canaldestino", "canpalDestini", "canpalDestINO", "canpaldestINO", "canalCombini", "canalDestINO", "canalCombINO", "canalsDestino", "canaldestINO", "canpalDestino", "canalOrigino", "canalDestini", "canalsdestination", "canalCombino", "canalCombination", "canalsDestination", "canalDestri", "canpaldestination", "canalsdestri", "canalsDestINO", "canalsDestri", "canalOrigini", "canalsdestino", "canpaldestini", "canalsdestINO", "canalOrigination", "canalOrigINO"], "estado": ["Estar", " estados", "iestado", "Estaban", "iestada", "estano", "estaban", " estaban", "istano", "estados", " featados", " Estaid", " featada", "apestato", "istato", "Estado", " Estada", " featado", " estano", "gestada", "iestato", " Estado", "iestaban", "istaban", "gestato", " estato", "estada", "gestaban", "estato", " estaid", "apestada", " estada", "istado", "Estada", "estaid", " estar", "apestano", "istada", "istar", "estar", "gestado", " Estados", " feataid", "apestado"]}}
{"id1": "20929570", "id2": "7468827", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"toMd5": ["toBd5", "toMmd7", "toMcd512", "toBmd15", "toMm7", "toMd7", "toBd7", "toBmd512", "toMd512", "toMcd7", "toBmd5", "toMmd512", "toBd15", "toMm512", "toBd512", "toMmd5", "toMcd5", "toMd15", "toBmd7", "toMm15", "toMmd15", "toMcd15", "toMm5"], "str": ["kr", "Str", "text", "fr", "txt", "arr", "STR", "e", "stri", "url", "b", "st", "dr", "data", "msg", "in", "f", "result", "input", "exp", "sec", "bytes", "out", "s", "conn", "pass", "temp", "source", "tr", "r", "string", "br", "err", "obj", "name", "sr", "sp", "buffer", "enc", "char"], "messageDigest": ["moreDigeter", "messageDher", " messageDuster", "messageDiguster", "messageMarketter", "messageDest", "messagedigester", "MessageMarketter", " messageDest", "messagedigested", "MessageDefester", "messageDeter", " messageDigEST", "messageDested", "moreDigested", "messageHashested", "messageDigester", "moredigested", "messageMarkester", " messageDester", "moredigester", "MessageDefested", "MessagedigEST", "messagediguster", "MessageMarkest", "MessageMarkester", "messageMixested", "messageGuster", "messageHashest", "messageDefester", "MessageDigetter", "messageDefse", " messageDEST", "messagedigetter", "MessageDigested", "messageDester", "messageMarkest", "messagedigEST", "MessageMarkher", "messageDetter", "MessageDigest", "messageDefested", "messageGester", "messageUploadester", "messagedigest", "messageHasheter", "messageMixester", "messageMarkher", "Messagedigested", "MessageDigse", "messageGEST", "messageDefest", "moreDigester", "messagedigher", "Messagedigester", "messageDigeter", "messageMixse", " messageDiguster", "messageHashester", "messageDse", "moredigest", "MessageDigEST", "MessageDefest", "moredigeter", "messageDigested", "MessageDefse", "messageMixest", "MessageDigher", "messageDuster", "messageUploadest", "messageDEST", "messagedigeter", "Messagedigest", " messageDigester", "messageUploadested", "messageDigse", "messageGest", "messageUploadEST", "MessageDigester", "messageDigEST", "messageDigetter", "messageDigher", "moreDigest"], "byteArray": ["resourceArray", "wordString", "resourceLength", "ByteBuffer", "charOrder", "pixelBuffer", "doubleArray", "doublearray", " byteOrder", " byteIndex", "bitIndex", "ByteAddress", "byteBuffer", "bitBuffer", "byteNumber", "bytearray", "byteIndex", " byteAddress", "charAddress", " byteBuffer", "wordArray", "pixelObject", "byteAddress", " byteString", "charLength", "bitLength", "doubleBuffer", "charBuffer", "ByteAmount", "ByteNumber", "wordBuffer", "charArray", "doubleString", "ByteArray", "byteOrder", "charObject", "pixelLength", "charNumber", "byteString", " bytearray", "ByteLength", "ByteOrder", "bitArray", " byteAmount", "pixelArray", "bitObject", "byteObject", "bitarray", " byteNumber", "byteLength", " byteLength", "wordarray", "resourcearray", "charAmount", "byteAmount", "resourceIndex"], "md5StrBuff": ["md5StApp", "md5StringComp", "md5StringRef", "md6strBuffer", "md2StrBuff", "md2StringText", "md5TrRef", "md5StText", "md5strBuffer", "md5STRComp", "md2StringRest", "md5Strbuff", "md5strbuff", "md5StRef", "md5StDb", "md2StringComp", "md5strApp", "md6strbuff", "md5StringBuffer", "md6StrText", "md5StBuffer", "md2StringRef", "md5StrComp", "md2StrBuffer", "md5TrDb", "md6StrBuff", "md6StrBuffer", "md5TrText", "md5Trbuff", "md5Stringbuff", "md2StringDb", "md5STRRest", "md6strBuff", "md5strText", "md5StrText", "md5StComp", "md2StringBuffer", "md5StringApp", "md5StBuff", "md5StringRest", "md5STRBuffer", "md5TrBuff", "md5StrRest", "md5StringBuff", "md2StrRef", "md2StringBuff", "md5StrApp", "md5StrDb", "md2StrText", "md2StrDb", "md5strBuff", "md5StringDb", "md2StrApp", "md2StrComp", "md2StrRest", "md5STRBuff", "md5StRest", "md6strText", "md5StrRef", "md2StringApp", "md5StrBuffer", "md5TrBuffer", "md6Strbuff", "md5StringText"], "i": ["k", "p", "u", "uri", "e", "j", "length", "b", "n", "fi", "io", "info", "si", "ie", "part", "in", "field", "f", "it", "o", "index", "d", "ci", "h", "iu", "oi", "ji", "abi", "multi", "y", "li", "di", "l", "ip", "pi", "xi", "inner", "slice", "id", "ti", "v", "gi", "c", "name", "ix", "I", "ai", "phi", "ii", "ui", "x", "mu", "qi", "bi", "lc", "ri"]}}
{"id1": "8778962", "id2": "6171406", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "3266833", "id2": "3958807", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"is": ["ins", "fits", "image", "os", "init", "lis", "info", "mis", "iso", "in", "es", "iv", "bis", "IS", "us", "isc", "iris", "ws", "ios", "i", "cms", "im", "ip", "ib", "id", "iss", "ir", "ais", "ris", "has", "Is", "get", "as", "or", "isa", "abs", "close", "bs", "was", "isu", "its"], "name": ["ame", "NAME", "prefix", "description", "url", "default", "one", "image", "large", "module", "parent", "null", "n", "term", "nice", "connection", "database", "data", "version", "this", "title", "part", "alias", "search", "no", "named", "key", "type", "pass", "code", "source", "memory", "Name", "space", "vision", "filename", "size", "directory", "base", "min", "id", "address", "names", "string", "file", "domain", "path", "word", "value", "office", "format", "label"], "contentType": ["contentPoint", "messageInfo", "contentName", "outputName", "sourcePoint", "Contenttype", "sourceType", "mediaType", "mediaName", " contenttype", "sourcetype", "documentPoint", "ContentPath", "messageName", "contentInfo", "sourceInfo", "messageType", "ContentTypes", " contentPoint", " contentInfo", "ContentName", "contenttype", "outputPath", "mediaPath", "contentPath", " contentName", "documenttype", "ContentType", "ContentInfo", "mediaTypes", "outputType", "contentTypes", "messagetype", "outputTypes", "documentType", "documentInfo"], "index": ["prefix", "page", "include", "default", "write", "image", "append", "length", "axis", "offset", "body", "Index", "none", "height", "data", "depth", "weight", "inc", "search", "shape", "in", "input", "error", "end", "key", "type", "timeout", "i", "pull", "multi", "size", "width", "expression", "number", "slice", "position", "id", "address", "string", "alpha", "list", "fix", "x", "value", "pointer", "level", "content", "update", "open"], "extension": ["exturation", "extensions", "configensions", "configension", "extance", "variension", "Extensions", "variance", "configuration", "variuration", "Extension", "Exturation", "Extance", "variensions", "configance"], "isImage": [" isMedia", "ISVideo", "isInstance", "areImages", "isimage", " isimage", "IsPicture", "isImages", " isImages", "isaImage", " isInstance", "areMedia", " isPicture", "ISImage", "asImage", "IsVideo", "isaImages", "asFile", "areFile", "asimage", "isaMedia", "isVideo", "isFile", "isPicture", "ISFile", " isVideo", "IsImage", "ISPicture", "areImage", "areInstance", "asInstance", "isaFile", "IsFile", "isMedia", "areimage", " isFile"], "isAux": ["isAlux", "isOAux", "isAAru", "isAAxt", "isArrayxt", "asAsExcept", " isAx", "asAsex", "isUex", "isAnex", "isAnlux", " isHaux", "isAxt", "isAsUX", "isWaux", "isArrayru", " isHax", " isArrayux", "asAslux", " isAru", "isAru", "isOAUX", "asAsux", "isAcux", " isAxt", " isAlux", " isAUX", "isOAExcept", "isArrayux", "isHaUX", "isAnUX", "isArrayUX", "asAex", "isOAlux", "isAsux", "isAnux", "isHaux", "isAcru", " isHalux", "isUux", "isAAux", "asAUX", "isWax", "isAExcept", "asAsUX", "isUlux", "isAx", "isWalux", " isArrayUX", "isAcxt", "asAlux", "asAux", " isArrayxt", "isAAUX", "isHax", "asAExcept", "isAsx", " isArrayru", "isWaUX", "isAslux", "isHalux", "isAUX", "isAcUX", "isUExcept", "isAsex", "isAsExcept", " isHaUX", "isUUX", "isAex"], "out": ["at", "prefix", "page", "ex", "array", "image", "plain", "copy", "null", "parent", "off", "io", "data", "version", "this", "project", "outer", "sync", "socket", "part", "output", "in", "result", "input", "exp", "o", "Out", "error", " in", "conn", "temp", "source", "size", "client", "a", "work", "inner", "base", "outs", "user", "table", "object", "over", "cache", "exec", "file", "obj", "up", "extra", "OUT", "next", "auto", "pool", "word", "ext", "buffer", "again", "post"], "bufferedImage": ["BufferingImage", "buffendedimage", "bufferingImage", "Bufferingimage", "bufferedimage", "BufferedImage", "Bufferedimage", "bufferingimage", "buffendedImage", "buffledimage", "buffledImage"], "inputStream": ["outputStream", "outputSteam", "inputSteam", " inputSteam", "InputBuffer", "InputSteam", "inputBuffer", "inputstream", "outputBuffer", " inputstream", "outputstream", "Inputstream", "InputStream", " inputBuffer"]}}
{"id1": "9826240", "id2": "9550506", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"checkHashBack": ["checkSumBACK", " checkhashback", " checkHashFront", "checkhashBACK", " checkhashBACK", "checkKeyBACK", "checkSumFront", "checkHashBACK", "checkKeyFront", " checkHashback", " checkhashBack", "checkhashBack", "checkHashback", " checkHashBACK", "checkhashFront", " checkhashFront", "checkhashback", "checkSumBack", "checkKeyback", "checkHashFront", "checkSumback", "checkKeyBack"], "facade": ["fade", "Facide", "humase", "factade", "facase", "factce", "Facades", "factase", " facades", "Facace", "Facade", "Facede", "Facce", "facades", " facce", " facoke", "face", "humade", " facase", "facoke", "facide", "facse", "fase", "humce", "Facse", " facede", "facace", "facce", "factide", "Facale", "foke", " facide", "Facase", "Facoke", "facale", "fades", "fse", "facede", "factoke", " facace", "factse", "humede", "fale", " facale"], "req": ["resp", "rec", "rt", "res", "crit", "fr", "url", "resource", "ru", "view", "cmp", "requ", "form", "info", "sem", "required", "f", "pb", "rb", "ref", "Request", "prof", "cb", "cur", "rf", "sq", "xml", "temp", "require", "pkg", "pr", "wx", "pull", "rr", "base", "util", "r", "cache", "exec", "err", "obj", "app", "def", "gr", "w", "ctx", "proc", "qq", "response", "query", "pro", "jp", "q", "http", "fp", "request"], "txtTransactionID": ["textTransactionType", "textTaskInfo", "txtOperationId", "txtTaskID", "txtOrderID", "txtTaskType", "txtOperationInfo", "txtOperationType", "txtTransactionId", "txtJobID", "txtTransactionName", "txtOrderType", "textTransactionID", "txtOrderId", "textTaskId", "textTransactionId", "textTransactionIP", "txtTaskName", "txtTransactionInfo", "textTaskIP", "txtTaskIP", "textTaskName", "textTransactionName", "txtJobIP", "txtTransactionIP", "txtJobId", "txtJobInfo", "txtOperationID", "textTransactionInfo", "textTaskID", "txtOperationName", "txtTransactionType", "txtOperationIP", "txtTaskInfo", "txtOrderName", "txtTaskId", "textTaskType"], "txtOrderTotal": ["xtOrderTotal", "txtEventNum", "txtEventTotal", "txtOrderNum", "xtOrderToken", "txtBlockToken", "txtBlockInfo", "xtOrderLast", "txtEventInfo", "txtRequestLast", "xtRequestInfo", "xtOrderInfo", "xtOrderNum", "txtAddressInfo", "txtEventToken", "xtBlockInfo", "xtRequestLast", "xtBlockNum", "xtOrdertotal", "txtBlockNum", "txtRequesttotal", "txtOrderToken", "xtBlockToken", "xtBlockTotal", "txtAddressTotal", "xtRequestTotal", "txtAddressLast", "txtJobtotal", "txtJobNum", "txtOrderInfo", "txtOrderLast", "txtBlockTotal", "txtRequestTotal", "txtJobTotal", "txtAddresstotal", "xtRequesttotal", "txtOrdertotal", "txtRequestInfo", "txtJobInfo", "txtJobToken", "txtJobLast"], "txtShopId": ["txtSessionName", "txtShopName", "txtOrderID", "txtFactoryId", "txtJobID", "txtSessionID", "txtJobName", "txtFactoryID", "txtOrderId", "textShopName", "textJobId", "txtFactoryName", "textShopInfo", "txtSessionId", "textJobInfo", "textShopId", "txtJobId", "txtJobInfo", "txtShopInfo", "txtShopID", "txtOrderInfo", "textShopID", "txtOrderName", "textJobID", "textJobName", "txtFactoryInfo", "txtSessionInfo"], "txtArtCurrency": ["txtartCulture", "txtARTSccurrency", "txtArtLCcurrency", "txtArtccurrency", "txtArtScurrencies", "txtArtLCurrencies", "txtArtCcurrency", "txtartcurrency", "txtartcerc", "txtARTSculture", "txtARTScurrency", "txtArtAccurrency", "txtartCurrency", "txtArtcurrency", "txtARTCurrency", "txtArtculture", "txtARTCulture", "txtArtCustomurrency", "txtArtCurrencies", "txtartCerc", "txtARTScurrencies", "txtArtSccurrency", "txtArtCustomerc", "txtArtScurrency", "txtArtcerc", "txtartCcurrency", "txtArtAcurrency", "txtArtAculture", "txtArtcurrencies", "txtartculture", "txtArtLCurrency", "txtArtCerc", "txtArtCustomcurrency", "txtArtAcerc", "txtArtCulture", "txtArtLCulture", "txtArtCustomulture", "txtartccurrency", "txtARTCcurrency", "txtARTCurrencies", "txtArtSculture"], "txtHashBack": ["txtMessageRest", "txtHashReturn", "txtCheckback", "textSumBack", "textHashFront", "txtHashBACK", "txtSHABack", "xtMessageRest", "xtSumback", "txtMessageback", "txtBlockReturn", "txtStyleBack", "txtSumSave", "textSumback", "textSumFront", "txtBlockFront", "txtHandleBack", "xtHashBack", "txtSHAReturn", "xtSumBACK", "txtHandleRest", "xtHashSave", "txtBlockback", "txtBlockRest", "txtHandleback", "textHashback", "txtSumBack", "textSumReturn", "txtHashback", "txtSumReturn", "txtStyleSave", "xtMessageback", "txtHashSave", "xtMessageBack", "txtMessageBack", "xtHashReturn", "txtHashRest", "xtHashBACK", "txtMessageReturn", "txtCheckSave", "txtStyleback", "txtSHAFront", "textHashBack", "xtHashback", "xtSumBack", "txtSumBACK", "txtSumFront", "txtHashFront", "xtMessageReturn", "txtBlockBack", "txtSHAback", "textHashReturn", "txtCheckBACK", "txtHandleReturn", "xtHashRest", "xtSumSave", "txtSumback", "txtCheckBack", "txtStyleBACK"], "hashSeed": ["hashPresees", "hashSlees", "HashSlees", "hashSeriesees", "hashSeeds", "hashRee", "hashSees", " hashSeeds", "hashSlql", " hashReeds", " hashRead", " hashReed", "hashSleeds", "hashSee", " hashSee", "hashSleed", "HashSees", "HashSql", "HashSeeds", "hashSql", "hashReed", "hashSlee", "hashPreseed", "hashSeriesql", "hashSerieseeds", "HashSleeds", "HashSlql", " hashRee", "hashPreseeds", " hashSead", "HashSleed", "hashSerieseed", "hashPresql", "hashSead", "hashReeds", "hashRead", "HashSeed", "hashSlead"], "securityValue": [" securityString", " securityFile", "securityKey", "SecurityValue", " securityKey", "secureValue", "SecurityKey", "secureFile", " securityValues", "secureValues", "secureKey", "securityFile", "SecurityValues", "SecurityFile", "securityValues", "securityString", "SecurityString", "secureString"], "digest": [" Digest", "Digusher", "defested", " Digested", " digEST", "DigEST", "sendHash", "logester", "Digence", "Digester", " Digge", "Digest", "digEST", " digested", "logest", "hashed", "digence", "diged", "signest", " digence", "DigHash", " digusher", "digestro", "digge", " Digester", "defester", " digester", "signested", "logence", "Digested", "hashHash", "digester", "signEST", "signester", "defge", " DigEST", " digestro", "digested", "Diged", "digusher", "Digge", "defest", "digHash", " Digestro", "sendEST", "sendest", "sended", "hashest", "hashEST", "Digestro", "logusher"], "array": ["sample", "arrow", "arr", "message", "image", "integer", "data", "allow", "range", "audio", "area", "archive", "storage", "batch", "error", "row", "our", "element", "instance", "record", "section", "pair", "number", "feature", "object", "address", "cache", "string", "Array", "list", "binary", "angle", "order", "environment", "function", "value", "buffer", "ray", "collection", "database"], "sb": ["buf", "kb", "bsp", "ssl", "sf", "sv", "osc", "fb", "bt", "bh", "si", "usb", "xb", "lb", "bc", "sn", "pb", "SB", "su", "rb", "cb", "mb", "s", "sq", "bf", "bm", "src", "bg", "sg", "db", "ib", "abb", "bj", "zb", "string", "BB", "sa", "orb", "gb", "sup", "ob", "sl", "obb", "wb", "buffer", "nb", "eb", "bs", "bb", "nn"], "j": ["ij", "k", "m", "js", "u", "z", "e", "length", "g", "n", "jc", "part", "f", "jj", "o", "ja", "d", "index", "ch", "dj", "uj", "key", "aj", "ji", "J", "jo", "i", "pr", "y", "oj", "section", "li", "l", "bj", "ind", "br", "v", "c", "obj", "dy", "ix", "ii", "jl", "x", "jp", "p"], "b": ["k", "p", "e", "body", "fb", "bp", "lb", "bc", "f", "d", "rb", "job", "cb", "mb", "code", "bf", "B", "i", "bd", "a", "l", "db", "bar", "ib", "ba", "string", "br", "bin", "c", "orb", "be", "ob", "binary", "wb", "bug", "bi", "x", "ab", "nb", "eb", "bs", "bb"], "hash": ["ash", "auth", "url", "report", "message", "image", "html", "build", "math", "sha", "lock", "height", "rh", "ph", "search", "result", "hex", "sum", "password", "error", "h", "key", "handle", "kh", "memory", "hh", "oh", "header", "ruby", "flash", "gh", "db", "number", "mac", "hed", "dash", "address", "cache", "history", "match", "confirmed", "ha", "Hash", "ssh", "sh", "json", "cover", "value", "dh", "block"]}}
{"id1": "17580775", "id2": "4921631", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"runInternal": ["runImpl", " runSync", "processInternal", "doImpl", "runExternal", " runExternal", "doInternal", "processSync", "processExternal", "processImpl", " runImpl", "doExternal", "doSync", "runSync"], "connection": ["component", "default", "image", "volume", "socket", "entry", "password", "graph", "directory", "cache", "context", "condition", "resource", "message", "server", "communication", "remote", "event", "version", "port", "ion", "index", "translation", "error", "timeout", "connected", "builder", "config", "expression", "command", "object", "handler", "con", "c", "option", "entity", "layer", "operation", "lc", "database", "proxy", "log", "loc", "channel", "application", "creator", "section", "character", "environment", "function", "location", "wrapper", "collection", "use", "description", "statement", "body", "session", "engine", "Connection", "document", "connect", "container", "source", "driver", "reader", "client", "inner", "position", "machine", "service", "relation", "current", "request"], "visited": ["viewited", "Vised", "visalled", "VisITED", "invited", "Visitted", "Visalled", "viewITED", "VISITED", "Visited", "invalled", "viewitted", "VISitted", "vised", "VISed", "invitted", "invITED", "viewed", "visITED", "VISalled", "VISited", "visitted"], "startTimeStamp": ["startLineEstamped", "startLineStamped", "startLineEstng", "startTimeStamped", "startTimestamped", "startTimeEstamp", "startTimestamp", "startTimestamps", "startTimeEstamped", "startTimeestamp", "startTimeStng", "startLineEstamp", "startLineEstamps", "startTimeStamps", "startLineStamp", "startTimestng", "startLineStng", "startTimeestng", "startTimeEstng", "startTimeestamps", "startTimeEstamps", "startTimeestamped", "startLineStamps"], "delayedProgress": ["elayedContent", "delayedStatus", "deladedProgress", "elayedProgress", "deliverStatus", "deladedContent", "delivedStatus", "delivedContent", "eladedContent", "elayedStatus", "delivedComplete", "elayedComplete", "delivedProgress", "delayedContent", "deladedStatus", "eladedComplete", "deliverComplete", "eladedStatus", "eladedProgress", "deliverProgress", "delayedComplete", "deladedComplete", "deliverContent"], "conn": ["conv", "ls", "att", "ct", "ssl", "cn", "uc", "cp", "n", "loc", "act", "rc", "cmp", "io", "sync", "channel", "Connection", "connect", "mc", "nt", "ch", "nc", "ci", "cb", "h", "Conn", "connected", " con", "cc", "config", "client", "cli", "l", "co", "db", "ad", "ann", "exec", "con", "c", "obj", "dc", "comm", "ctx", "cf", "lc", "enc", "http", "open"], "fileName": [" fileKey", "FileKey", "contentName", "filePath", " fileArea", " filePath", "urlArea", "urlName", "fileArea", "urlKey", "fileKey", "imageName", "fileSpace", "filename", "urlPath", "FileArea", "imageSpace", "contentPath", " fileSpace", "FilePath", " filename", "imagePath", "FileName", "contentname", "imagename", "contentSpace"], "disp": ["interap", "prop", "Dispart", "interP", "interpp", "Dispr", "disap", "prope", "propr", "disP", "defpend", "defps", "scheap", " dispe", "Dispatch", "detP", "detp", "Disps", "dispart", "Dispe", "dispatch", "interpatch", "broadp", "interpe", "interp", "dispr", "Dispend", "defp", "schepe", "schep", "propose", "Disp", "defpart", "dispe", "broadps", "broadpend", "Dispose", " dispose", "Dispp", "detpp", "DisP", "dispp", "broadpart", "dispose", " dispr", "schepatch", "disps", "dispend", "detpatch", "Disap"], "p": ["at", "after", "m", "pe", "np", "lp", "e", "col", "j", "vp", "pat", "b", "g", "n", "loc", "pl", "bp", "part", "pos", "f", "P", "pa", "o", "index", "d", "end", "h", "i", "pr", "api", "y", "l", "ip", "pi", "point", "r", "po", "v", "patch", "c", "ap", "ping", "t", "pre", "sp", "op", "jp", "q", "pp", "rep", "tp"], "response": ["prot", "resp", "page", "description", "respond", "uri", "message", "image", "server", "resource", "complete", "body", "Response", "en", "successful", "version", "data", "reset", "respons", "output", "model", "status", "result", "site", "radius", "reply", "index", "error", "timeout", "code", "api", "found", "id", "success", "next", "json", "path", "value", "pointer", "function", "collection", "http", "feed", "request", "ception", "received"], "contentType": ["messageInfo", "contentLength", "contentName", "messageLength", " contentLength", "documentTyp", "messageLen", "contentInfo", "contentTyp", "messageType", " contentInfo", "ContentName", " contentTyp", "documentLength", "ContentLen", " contentName", "ContentType", "ContentInfo", "ContentLength", "documentName", "documentType", "ContentTyp"], "contentEncoding": ["contentCasing", "loadEnaring", "contentencoding", "contentEncaring", "contentencoder", "contentEnryption", "contentEncryption", "contentLocaring", "ContentDecoding", "contentEncReading", "loadEnryption", "loadEncaring", "ContentEncoding", "ContentDecocol", "contentDecoding", "ContentDecoder", "loadEncasing", "contentEReading", "loadEnasing", "contentDecoder", "contentencReading", "contentLocryption", "contentEocol", "contentEoding", "loadEncryption", "ContentDecReading", "contentEncoder", "contentEnaring", "contentEncasing", "contentEoder", "contentDecocol", "contentCaring", "contentCryption", "loadEnoding", "loadEncoding", "contentLocoding", "contentEncocol", "contentCoding", "contentLocasing", "ContentEncReading", "ContentEncoder", "contentDecReading", "contentEnoding", "contentEnasing", "contentencocol", "ContentEncocol"], "contentLen": ["resourceLength", "contentLength", " contentSize", "resourcelen", "contentlen", "ContentSl", " contentLength", "activityLen", " contentlen", "Contentlen", "activitySize", " contentSl", "activityLength", "ContentLen", "resourceSize", "activitySl", "ContentLength", "contentSize", "ContentSize", "contentSl", "resourceLen"], "is": ["un", "isl", "ss", "os", "ot", "mis", "version", "not", "ig", "it", "ion", "IS", "isc", "us", "ys", "out", "ync", "ios", "isp", "ub", "im", "ip", "can", "iss", "net", "igh", "are"], "url": ["page", "text", "log", "uri", "ssl", "resource", "image", "server", "html", "org", "username", "link", "socket", "channel", "document", "status", "str", "URL", "download", "source", "config", "client", "user", "email", "address", "string", "file", "service", "sl", "host", "context", "path", "Url", "json", "location", "layer", "buffer", "http", "feed"], "loadNext": ["loadsPrevious", "loadingLast", "loadingPrevious", "loadLast", "loadingNext", "checkNext", "loadPrevious", "loadsNext", "loadsFirst", "loadingFirst", "loadFirst", "checkPrevious", "checkLast", "checkFirst", "loadsLast"], "itemsLoadedPartially": ["itemsLoadedCopally", "itemsLoadedPARTally", "itemsLoadedCopial", "itemsLoadedPARTials", "itemsLoadedpartially", "itemsLoadippedPartials", "itemsLoadippedpartially", "itemsLoadippedpartials", "itemsLoadedPARTially", "itemsLoadippedpartial", "itemsLoadedPartial", "itemsLoadippedPartally", "itemsLoadedpartally", "itemsLoadedpartial", "itemsLoadedPartally", "itemsLoadedCopially", "itemsLoadedPARTial", "itemsLoadedPartials", "itemsLoadedCopials", "itemsLoadedpartials", "itemsLoadippedpartally", "itemsLoadippedPartially", "itemsLoadippedPartial"]}}
{"id1": "13783898", "id2": "19810820", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "23666973", "id2": "4531653", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openFileRaw", "openSteamInternal", "openStreamAsync", "openSteamSource", "openstreamSource", "createStreamAsync", "openFileAsync", "openstreamAsync", "openFileInternal", "createStreamRaw", "createSteamSource", "openstreamInternal", "createStreamInternal", "createStreamSource", "createSteamInternal", "openStreamSource", "openFileSource", "openSteamRaw", "openStreamInternal", "openSteamAsync", "openstreamRaw", "createSteamRaw", "createSteamAsync"], "filename": ["fd", "SourceFile", "prefix", "fn", "actual", "ppa", "jpg", "subject", "uri", "txt", "resource", "lua", "FILE", "sf", "length", "n", "il", "acl", "data", "username", "sql", "journal", "title", "phrase", "f", "fax", "password", "undle", "href", "nil", "kn", "download", "dll", "wl", "source", "class", "src", "size", "directory", "fil", "l", "license", "login", "rl", "which", "Filename", "kl", "string", "file", "sound", "name", "loader", "path", "location", "word", "utf", "fp", "ename", "database"], "stream": ["image", "core", "parent", "null", "view", "Stream", "steam", "socket", "loop", "row", "temp", "class", "thread", "string", "file", "context", "resource", "message", "server", "uc", "form", "event", "back", "port", "model", "result", "zip", "input", "coll", "draft", "accept", "through", "live", "download", "ream", "pair", "control", "object", "video", "upload", "w", "path", "content", "enc", "feed", "log", "length", "sync", "channel", "impl", "iv", "cur", "instance", "pull", "size", "hook", "transform", "sl", "clean", "wrapper", "value", "buffer", "http", "sw", "bb", "open", "stage", "sample", "ssl", "body", "method", "child", "session", "raw", "output", "f", "stack", "valid", "rest", "source", "reader", "client", "slice", "trans", "load", "continue", "full", "host", "pool", "response", "cont", "current", "callback"], "url": ["page", "fl", "ssl", "uri", "resource", "e", "server", "ll", "image", "b", "rel", "loc", "ul", "data", "channel", "f", "www", "URL", "coll", "el", "source", "api", "l", "web", "base", "id", "string", "file", "loader", "name", "sl", "plug", "path", "Url", "line", "http", "feed", "lib"], "cl": ["ls", "scl", "pe", "fl", "ct", "ssl", "ll", "col", "uc", "CL", "loc", "lock", "pl", "acl", "shell", "Cl", "bc", "ec", "coll", "comb", "el", "cc", "decl", "ctrl", "ocl", "class", "cel", "cle", "client", "cli", "l", " CL", "sc", "kl", "gl", "con", "c", "hell", "loader", "ml", "sl", "sel", "ctx", "bl", "sh", "cont", "lc", "cr", "lib"], "cn": ["Ns", "fn", "ln", "ct", "core", "gn", "uh", "n", "cdn", "nic", "act", "ains", "cone", "ns", "icon", "jc", "ec", "gin", "ain", "sn", "mc", "rn", "coll", "nc", "ae", "cb", "auc", "kn", "conn", "cc", "kin", "cm", "arn", "nat", "mn", "bn", "CW", "xc", "con", "abc", "dc", "dn", "net", "cf", "cy", "lc", "CA", "ca", "hn", "wcs", "nam", "enc", "cr", "CN"]}}
{"id1": "15051083", "id2": "8932510", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessageDesignest", "getmessageDigest", "getMessageDigester", "getMessageHashest", "getMessageHashests", "getMessageHashester", "getmessagedigester", "getmessageDigester", "getMessagedigester", "getmessagedigests", "getMessageHashature", "getMessageDigature", "getMessageDesignature", "getMessagedigature", "getmessageDigature", "getMessageDesignests", "getMessageDigests", "getMessagedigest", "getMessagedigests", "getmessagedigest", "getmessagedigature", "getMessageDesignester", "getmessageDigests"], "digest": ["Diger", " Digest", "digiter", "hexest", "greatest", "hexEST", "sandest", "DigEST", "Digger", " digEST", " digeter", "greatiter", "Digeter", "feedester", "Digex", "Digester", "digEST", "Digest", " digested", " Digeter", "sandesting", " digex", "digesting", "greatester", "hexex", " Digger", "sandester", "signest", "digger", "sandested", "hexests", " diger", " Dighed", "greatested", " digests", " Digester", " digester", " digger", "signested", " Diger", "digeter", "Digested", "Digesting", "digester", "digex", "signester", "Digests", "digests", "dighed", "Dighed", "Digiter", "diger", " dighed", "digested", "signesting", "feedest", "feedested", "signiter"], "node": ["component", "Node", "uri", "one", "resource", "server", "module", "parent", "n", "connection", "remote", "event", "child", " nodes", "document", "ode", "route", "index", " source", "element", "instance", "source", "config", " parent", "network", "self", " annotation", "point", "internal", "object", "local", "address", "name", "entity", " namespace", "root", "global", " Node", "location", "path", " child", "odes"], "external": ["intern", "ex", "ternal", "resource", "e", "n", "remote", " remote", "outer", "international", "outside", "foreign", "External", "tern", "multiple", "out", "element", "instance", "source", "network", "client", "target", "Intern", "internal", "object", "local", "https", "account", "name", "secondary", "global", "binary", "reference", " foreign", "environment", " global", " External", "export"], "messageDigest": ["messageMarkester", "messageModester", "messageSignested", "MessageDigest", "messagedigger", "messageMarkested", "messageModesting", "messageDigested", "messageDesignesting", "messagedigest", " messageHashest", "messageDigesting", " messageHashesting", "messageHashesting", "messageDesignest", " messageDesignger", "MessageSignest", "messageDesignger", " messageDigesting", "messageMarkenge", "messageDest", "messagedigester", " messageDigger", " messageDesignest", "messageSignenge", "messageDenge", "messageDesignested", "messageDigger", "messagedigested", " messageDigester", "messageModest", " messageDesignester", "messageHashest", "MessageSignester", "messageModested", "MessageDigenge", "MessageSignested", "messageDigenge", "messageDesignester", "messageSignest", " messageHashested", "messageDested", "messageMarkest", "messageSignester", " messageDigested", "MessageDigester", "MessageDigested", "messageHashested", "messageDester", "MessageSignenge", "messageHashester", " messageHashester", " messageDesignested", "messageDigester"]}}
{"id1": "16550855", "id2": "23402240", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"readPage": ["readFile", "getPages", "openFile", "readpage", "readPages", "getpage", "getFile", "findPage", "findPages", "openPages", "findpage", "openPage", "findFile", "getPage", "openpage"], "ignoreComments": ["orecomments", " ignoreQuotes", "includeComments", " ignoreTags", "includeComment", " ignoreComment", "includeTags", "useQuotes", "useComments", "oreQuotes", "useTags", "oreTags", "ignoreQuotes", "usecomments", "includecomments", "ignoreComment", " ignorecomments", "oreComments", "ignoreTags", "oreComment", "ignorecomments"], "in": ["into", "rec", "m", "ins", "url", "ssl", "e", "image", "In", "b", "connection", "init", "data", "version", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "inn", "lin", "index", "h", "out", "s", "i", "kin", "win", "source", "reader", "is", "client", "inside", "nin", "stream", "login", "inner", "user", "min", "r", "id", "token", "bin", "c", "err", "con", "file", "loader", "re", "t", "ini", "as", "buffer", "again", "http", "on", "isin"], "inputLine": ["rawText", "installLook", "ifLook", "requestCo", "inputPage", "Inputline", "inputText", "InputCell", "requestLink", "pullRow", " inputRow", "ifline", "pullLink", "inputCo", "requestLook", "incLook", " inputCell", "requestRow", "inputL", "pullline", "imageLine", "InputLine", "InputName", "InputPage", "rawL", "inputRow", "ifCo", "rawName", "incLine", "commentLine", " inputLink", "commentline", "installL", " inputline", "installLine", "requestline", " inputLook", "imageline", "installline", "imageLook", "pullLine", "ifLine", "inputCell", "commentCell", "imageL", "InputLink", "inputLook", "inputName", " inputText", "InputText", "inputLink", "InputLook", "InputL", "rawline", " inputName", "rawLink", "commentPage", " inputCo", "incline", "rawLine", "inputline", " inputPage", "requestLine", " inputL", "incL"], "html": ["css", "high", "page", "text", "bsp", "rss", "js", "url", "message", "plain", "details", "view", "body", "summary", "links", "flat", "data", "htm", "msg", "link", "strong", "blog", "title", "part", "output", "ht", "wrap", "f", "result", "www", "tt", "str", "template", "attr", "h", "tf", "live", "home", "inline", "bf", "xml", "temp", "source", "api", "article", "war", "atom", "header", "flash", "web", "gh", "dump", "base", "HTML", "show", "hard", "amp", "hot", "detail", "tml", "embed", "json", "ui", "content", "format", "http", "doc", "img"]}}
{"id1": "19849797", "id2": "5299276", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "copyfile", " copyfile", "transferfile", " copySource", "copyFiles", "clonefile", "copySource", "transferSource", "cloneFiles", "cloneFile", "cloneSource", "transferFiles", "transferFile"], "sourceFile": ["SourceFile", " sourceDir", "ourceFile", "SourceUrl", "ourceDirectory", "sourceDirectory", "sourceFolder", "srcDir", "Sourcefile", "srcfile", " sourceFolder", "ourceUrl", "sourcefile", "ourcefile", "destUrl", "destDirectory", "SourceFolder", "sourceUrl", "srcFolder", " sourcefile", "destfile", "SourceDirectory", "srcFile", "SourceDir", "sourceDir"], "destFile": [" destPoint", "DestPoint", "foreignFiles", "foreignFile", "resultLine", "sourcePoint", "destFiles", "DestDirectory", "targetPath", "targetDir", "destPoint", "srcDirectory", "srcDir", "srcFiles", "foreignPath", "srcLine", "destPath", "resultDir", "srcfile", "targetLine", "resultFile", "targetFiles", "resultfile", "DestFile", "destDir", "Destfile", " destDirectory", " destfile", "DestPath", "DestDir", "targetfile", "targetFile", " destFiles", "destDirectory", "sourceFiles", "foreignfile", "destfile", "srcFile", " destDir", "DestFiles", "destLine", "sourceDir"], "source": ["proxy", "component", "url", "uri", "unit", "resource", "image", "core", "server", "parent", "dest", "null", "scope", "view", "connection", "remote", "ce", "this", "si", "session", "ie", "channel", "output", "status", "Source", "result", "input", "site", "route", "storage", "index", "sin", "iter", "api", "src", "reader", "size", "client", "config", "stream", "target", "slave", "seed", "inner", "slice", "table", "object", "id", "cache", "ource", "file", "start", "service", "reference", "root", "SOURCE", "context", "get", "wrapper", "current", "secure", "scene", "manager", "use", "from"], "destination": ["domation", "distination", "generruction", "Destribution", "constination", "domination", "participinate", "identinated", "distion", "destinate", "Destation", "generinator", "constribution", "distruction", "destation", "destruction", "distinator", "Destinator", "distinated", "Destinate", "participinated", "generinated", "Destion", " destinated", "destion", "participinator", " destribution", "destribution", "identination", " destinator", "destinated", "Destination", " destation", "construction", "identinate", " destruction", "destinator", "Destinated", "Destruction", "dominator", "dominated", "generination", "constinator", " destion", "participination", "identinator"]}}
{"id1": "22022715", "id2": "8385785", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"digest": ["doested", "genester", "mdester", "generit", "dger", "digure", "dest", "Digit", "Digure", "Digester", "genests", "Digest", " digested", "mdested", "mdure", "generester", "digit", "digger", "generest", "mdger", "generger", "doit", " digests", "doest", " digester", "Digested", "digester", "mdit", "Digests", "digests", "dester", "doure", "digested", "genested", "mdest", "dit", "genest"], "s": ["ls", "m", "ssl", "e", "message", "b", "g", "ss", "n", "os", "ps", "rs", "ns", "data", "sb", "f", "es", "d", "password", "bytes", "lines", "ms", "ws", "is", "i", "source", "sym", "a", "ses", "S", "string", "c", "params", "words", "gs", "services", "strings", "p", "ds"], "ret": ["replace", "rt", "secret", "std", "res", "array", "arr", "default", "xt", "pat", "Return", "info", "data", "rev", "result", "hash", "nt", "reply", "valid", "val", "key", "out", "pass", "bf", "addr", "al", "fun", "alt", "det", "Ret", "match", "obj", "success", "mem", "re", "def", "continue", "repl", "arg", "value", "rets", "RET", "ext"], "md": ["mad", "m", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "um", "dig", "dd", "gd", "rpm", "editor", "mc", "mag", "d", "od", "meta", "mb", "wd", "me", "nm", "amd", "mg", "dm", "bd", "pkg", "metadata", "pd", "MD", "di", "ad", "mac", "ind", "mand", "mm", "ma", "am", "cb", "pm", "arm", "mt", "cd", "mod", "df"]}}
{"id1": "9802073", "id2": "12078471", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"testAutoCommit": ["testSyncDebite", "testAutoComite", "testSyncCommits", "testSyncDebIT", "testAutoDebite", "testAutoDebit", "testAutoCommite", "testAutoComIT", "testAutoComits", "testAutoommits", "testAutoCommits", "testAutoommite", "testAutoComit", "testSyncCommit", "testSyncDebits", "testAutoDebIT", "testAutoommIT", "testSyncDebit", "testSyncCommIT", "testAutoDebits", "testAutoCommIT", "testSyncCommite", "testAutoommit"], "con": ["conv", "un", "cn", "core", "act", "CON", "an", "sql", "bc", "cl", "cas", "conn", "Conn", "ver", "class", "win", "min", "cache", "ac", "pc", "fac", "pre", "context", "non", "ocon", "pen", "com", "m", "crit", "uc", "connection", "en", "rc", "syn", "coll", "cc", "ctrl", "config", "can", "c", " conn", "ctx", "cf", "pub", "ca", "close", "util", "cr", "fn", "gen", "log", "ct", "col", "sync", "mc", "ran", "union", "cur", "pr", "co", " CON", "db", "platform", "common", "conf", "n", "lock", "tc", "Con", "session", "Connection", "cond", "connect", "cm", "client", "fc", "pool"], "stmt": ["stur", "Stmp", "stb", "Stm", " stm", " stbl", "stmp", "STm", " stMT", " stsp", "stnt", "Stmb", "Stur", " stmn", "ctmt", "ctmp", "slmn", "stmb", "slmp", " storp", "STmt", "Storp", "stmd", "stor", "Stpt", "stpt", "rb", "slmt", " stpt", "STsp", "Stmn", "Stbl", "stsp", "Stor", " stmb", "stMT", "STmb", "ctmb", "rorp", " stor", "slur", "rmd", "ctor", " stur", "rmt", "STnt", "estmt", "estsp", "Stb", " stb", " stmd", "Stnt", "stmn", "Stmd", "Stmt", "estMT", "STMT", "STbl", "STpt", "storp", "estmb", "STmp", " stmp", "stbl", "stm", " stnt"], "rs": ["ls", "rt", "ros", "res", "rss", " r", "rows", "ins", "rx", " Rs", "ubs", "mr", "rc", "ps", " sr", "acks", "relations", " results", "ges", "hs", "ows", "rys", "ms", "row", "Rs", "RS", "ry", "results", "pr", " res", "src", "reader", "rl", " rc", "rr", "ras", "r", "sc", "ars", " RS", "ris", "eers", "RC", "repl", "xs", "rd", "sr", "errors", "hr", "ra", "cs", " rows", "cr", "runs", "vers"]}}
{"id1": "6403868", "id2": "300397", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUninstallSources", "extractUnzipSources", "extractUnpackfiles", "extractUnInstallSources", "extractUnzipfiles", "extractUnzipFiles", "extractUninstallFile", "extractUnpackFiles", "extractUpinstallFile", "extractUnpackSources", "extractUpinstallSources", "extractUnInstallFiles", "extractUnzipFile", "extractUppackFile", "extractUpinstallfiles", "extractUpinstallFiles", "extractUnInstallFile", "extractUnpackFile", "extractUppackFiles", "extractUninstallfiles", "extractUppackfiles", "extractUppackSources", "extractUnInstallfiles"], "_destPath": ["_distPath", "_downloadFile", "_destDir", "_tmpPath", " _sourceHome", "_DestHome", "_srcFile", " _destDirectory", " _sourcePath", "_distDir", "_sourceFile", "_destFile", " _sourceFile", "_downloadDirectory", "_DestPath", "_downloadHome", "_distDirectory", "_Destpath", "_tmppath", "_DestDirectory", "_tmpDir", "_sourcepath", " _sourceDirectory", "_downloadPath", "_sourceDir", "_sourcePath", "_tmpDirectory", " _destHome", "_destDirectory", "_distFile", "_srcPath", "_DestDir", "_srcDir", "_destpath", " _destFile", "_DestFile", "_sourceHome", "_sourceDirectory", "_srcDirectory", "_destHome"], "upgrade": ["Upgrade", "Upge", " upge", "offgrading", "ipgrading", " upgrades", "offgrade", "upinstall", "duge", "UpGrade", "Upgrading", "dugrading", "ipinstall", "offgrades", "upgrades", "duGrade", "upGrade", "ipgrades", "upge", " upGrade", " upinstall", "dugrade", "upgrading", " upgrading", "offinstall", "ipgrade"], "lastVer": ["LastVersion", "LastVER", "nextVers", "prevVers", " lastVersion", "lastver", "lastVers", "nextVer", "lastVersion", "prevver", " lastVER", "firstVer", "Lastver", "prevVersion", "LastVer", "firstVersion", "nextVersion", "prevVer", "firstver", " lastVers", " lastver", "firstVER", "lastVER", "nextver"], "oldlog": ["olderLog", "Oldlog", " oldtext", "oldbug", "newpath", "oldtext", "oldLOG", "newLOG", "OLDbug", " oldLog", " oldpath", "Oldpath", "olderLOG", "OLDlog", " oldLOG", "OldLOG", "oldertext", "oldpath", "newbug", "olderlog", "OldLog", "newlog", "OLDLog", "oldLog", " oldbug", "newtext", "newLog"], "destPath": ["descFile", "destPATH", "exportpath", "descCh", "flatPath", " destFolder", "securePath", "constpath", "constPath", "usrpath", "usrFile", "usrPath", "homepath", "destDir", "DestPath", " destDirectory", "Destpath", "postPATH", "donePath", " destCh", " destWin", "exportPath", "descPath", "sourcepath", "destLog", "constHome", "srcPATH", "flatDir", "destKit", "DestHome", "DestFile", " destKit", "descName", "exportDirectory", "DestDir", "secureLog", "contath", "doneDir", "homePath", "targetFile", " destath", "exportPATH", "descDir", "homeKit", " destpath", "constFile", "homeDir", "sourcePath", "DestFolder", "destath", "srcpath", "DestRoot", "destFile", "contpath", "flatFolder", "srcPath", "secureWin", "targetDir", "sourceDirectory", "destFolder", "doneWin", "homeLog", "secureDir", "targetPATH", "homeName", "contPath", "doneLog", "postpath", "Destath", "descKit", "destHome", " destDir", "destName", " destLog", "sourceDir", "destpath", "contDir", "DestCh", "DestPATH", "destWin", " destFile", " destHome", " destName", "DestDirectory", "targetPath", "donepath", "srcDirectory", "destCh", "postRoot", "targetpath", "destRoot", "postPath", " destRoot", "destDirectory", "flatpath", " destPATH", "descpath", "targetRoot"], "lastVerPath": ["lastVerpath", "lastVERPath", "lastVersPath", "lastVersionEx", "lastTestPath", "lastverFile", "lastVersionName", "prevVerPath", "lastVerFile", " lastVerFile", "lastverCh", "lastVerDir", " lastVerDir", " lastVersionId", "lastModpath", " lastModPath", "lastVerEx", "nextVerFile", "nextverpath", "lastTestId", "lastVersionFile", "prevverPath", "prevverpath", " lastVersionCh", "lastVERDir", "lastVersionpath", "prevVerName", " lastModDir", "lastVerName", "lastVerspath", "nextVerPath", "prevverFile", "nextVerCh", " lastVerId", "lastVersionPath", "prevverName", "lastTestpath", "lastverId", "lastVersionId", "lastModCh", "lastVerId", "nextverFile", "lastModPath", "lastverpath", "lastVEREx", "prevVerpath", "lastVERpath", "lastVERCh", " lastVersionPath", "lastModDir", "nextverCh", "lastVersionCh", " lastVersionFile", "lastModFile", " lastVerpath", " lastVerCh", " lastVersionEx", "lastModName", "prevVerFile", " lastModpath", " lastVerEx", " lastModCh", " lastVersionpath", "lastverDir", "nextverPath", "nextVerpath", "lastTestFile", "lastverName", "lastverPath", "lastVersFile", "lastVersCh", "lastVerCh", "lastverEx"], "bkdir": [" bkdesc", "bvpath", " bkpath", "bktfile", "bkbfile", "bKpath", "Bkdirectory", "BckDir", "bkkDir", " bakloc", "bktdir", "bvdir", " bkDir", " bkloc", "bvloc", "Bkdir", "bkgdir", "bkloc", "bakdirectory", " bktdesc", "Bkpath", " bkir", "bkkir", "bkbdir", "bakdir", "bckdir", " bakpath", "bkdesc", "bkbdesc", " bktfile", "bkkdir", "bakpath", "BkDir", "Bckdirectory", "bvDir", "bkfile", "bKdir", "bkbloc", " bktloc", " bakdir", " bkfile", "bkkpath", "bkkdesc", "bakir", "bkdirectory", " bktdir", "bakDir", "bkgir", "bckDir", " bakDir", "bkkloc", "bktloc", "bkgDir", "Bckpath", "Bckdir", "bkpath", "bkkfile", " bakir", "bckdirectory", "bakloc", "bckpath", "bkDir", "bktdesc", "bKdirectory", "bkir", "bKDir"], "oldClassCopied": ["oldFilecopies", "oldClassCopyies", "oldFilecopied", "oldFileCopies", "oldFileCopied", "oldClassCrossied", "oldClassCopyie", "oldClassSkored", "oldclassCopied", "oldClasscopie", "oldClasscopies", "oldFileCopying", "oldClasscopied", "oldclassCopored", "oldClassCopiated", "oldFileCopified", "oldclassCopies", "oldClasscopored", "oldClassSkies", "oldClassCrossified", "oldClassSkie", "oldClassCopyiated", "oldFileCopiated", "oldFilecopie", "oldFileCopyying", "oldClassCopies", "oldclassCopie", "oldClassSkied", "oldFileCopyied", "oldClassCopyied", "oldFileCopyiated", "oldFilecopying", "oldClassCopying", "oldFileCopie", "oldClassCopyying", "oldClassCopified", "oldClasscopying", "oldClassCopored", "oldClassCrossiated", "oldClassCrossying", "oldClassCopie", "oldFileCopyified", "oldClassCopyified"], "ls": ["ln", "fl", "ails", "lf", "ll", "lp", "als", "lbs", "iffs", "lis", "tl", "acl", "lists", "ns", "igs", "lb", "vs", "fts", "lines", "fs", "ols", "LS", "dl", "wl", "ches", "les", "rl", "l", "qs", "lr", "files", "ils", "lv", "los", "irs", "mails", "sels", "less", "list", "la", "locks", "lc", "cs", "lt", "bs", "bps"], "i": ["ij", "m", "p", "u", "uri", "z", "e", "j", "b", "fi", "io", "info", "si", "part", "f", "it", "o", "index", "d", "ci", "iu", "oi", "type", "s", "end", "ji", "abi", "multi", "y", "li", "di", "l", "mi", "ip", "pi", "hi", "xi", "inner", "slice", "eni", "yi", "id", "uli", "ind", "ti", "v", "gi", "c", "start", "t", "ix", "I", "ai", "phi", "ini", "ii", "ui", "x", "mu", "qi", "lc", "q", "min", "ri"]}}
{"id1": "7396682", "id2": "300397", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "url", "write", " cp", "cp", "remote", "link", "sync", "drop", "archive", "paste", "split", "clone", "clip", "download", "move", "cat", "Copy", "create", "source", "delete", "dump", "change", "load", "share", "file", "get", "path", "transfer", "update", "opy", "cop"], "srcFS": [" srcfs", "srcTS", "sbFs", "sbFP", "rcFC", "rcFS", "sourceFB", "rcFs", "srcFC", " srcFP", "rcfs", "sbfs", "sbFS", " srcFB", "srcFB", " srcTS", "sourceFS", "rcFP", "rcTS", "sourceTS", "sourceFC", "sourceFs", "rubyFs", "rubyFS", "rubyFB", "srcFP", " srcFC", "srcFs", "srcfs", "rubyfs", " srcFs", "sourcefs"], "src": ["SourceFile", "sth", "req", "rss", "url", "uri", "ssl", "resource", "core", "dest", "view", "st", "cmp", "loc", "rc", "bh", "project", "username", "sys", "sync", "sb", "inst", "Source", "spec", "sn", "sec", "rb", "supp", "attr", "href", "gb", "cb", "inf", "code", "rest", "sin", "source", "config", "filename", "sub", "stream", "target", "slice", "sc", "sit", "ource", "share", "obj", "dist", "RC", "sup", "upload", "file", "name", "sr", "sl", "host", "sel", "ctx", "path", "secure", "http", "fp", "img", "feat"], "dst": ["ddST", "ddest", "Ddest", " drest", "lsts", "lst", "dsc", "Drc", "drc", "ddst", "pdST", "cdST", "dsts", " drc", "ddsc", " dsts", "dST", "idst", "cdrc", "ddrc", "lST", "DST", "ldest", "iddest", "idrest", "Dst", "pdrc", "cddest", " dST", "pdst", "idsts", "drest", "Drest", "pdsc", "Dsts", " ddest", "cdst", " dsc"], "deleteSource": ["deleteTarget", "deleteMode", "DeleteSources", " deleteMode", "deleteOrigin", "DeleteType", "DeleteSource", " deleteTarget", "destroyOrigin", " deleteSources", "delSource", "destroyTarget", " deleteType", "delType", "delSources", "DeleteOrigin", "destroyMode", "delOrigin", "copyMode", "copySource", "delTarget", "deleteType", "DeleteTarget", "deleteSources", "DeleteMode", "copyTarget", "destroySource", "copyOrigin", " deleteOrigin", "delMode"], "conf": ["conv", "prop", "param", "cn", "const", "uc", "cfg", "cmp", "fi", "info", "bc", "f", "cor", "ref", " Conf", "cl", "ch", "ci", "cb", "conn", "cc", "Conf", "comment", "cm", "config", "client", "raf", "cli", "sc", "cache", "con", "c", "confirmed", "def", "ctx", "bug", "cf", "context", "cd", "lc", "cs", "ca", "cr"], "contents": ["CONTences", "latent", "containers", "stENTS", "contENTS", "contContents", "CONTients", "contentENTS", "stacts", "CONTainers", "contentents", "latents", "locains", "Contacts", "Contents", "ContContents", "locents", "Contils", " contENTS", "Contences", "latacts", "Content", "contients", "stents", "contains", "locContents", " contients", "contils", "CONTains", "stences", "ContENTS", "contences", "CONTent", "contacts", "CONTacts", "content", "locainers", " content", "CONTils", "CONTents", "CONTContents", "contentent", "contentients", "CONTENTS", "latils", "Containers", "Contains"], "i": ["k", "m", "u", "uri", "e", "j", "count", "b", "n", "fi", "init", "ori", "io", "data", "si", "ie", "f", "iv", "o", "index", "d", "ci", "key", "type", "oi", "h", "iu", "ji", "abi", "uni", "multi", "y", "li", "di", "ip", "pi", "hi", "inner", "xi", "slice", "id", "ti", "v", "gi", "c", "start", "name", "ri", "I", "ai", "phi", "diff", "ix", "ii", "ui", "x", "mu", "qi", "ini", "p"], "in": ["ins", "In", "b", "ax", "connection", "thin", "data", "inc", "socket", "part", "f", "gin", "input", "din", "IN", "inn", "inas", "out", "conn", "pass", "is", "source", "sin", "win", "rin", "kin", "a", "nin", "l", "login", "min", "r", "id", "ac", "bin", "file", "c", "con", "ini", "as", "serv", "doc"]}}
{"id1": "9371421", "id2": "1985677", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"eventHash": ["messageDig", " eventKey", "bytehash", "byteDig", "messageKey", " eventDig", "byteHash", "eventDig", "byteKey", "eventhash", "eventKey", "messagehash", " eventhash", "messageHash"], "eventstr": ["errorStr", "eventdict", "Eventstr", " eventsource", "exStr", "Eventstring", "exstr", " eventStr", "errorsource", "errorstring", "Eventdict", "EventStr", " eventstring", "Eventsource", " eventdict", "eventStr", "exdict", "errorstr", "exstring", "eventstring", "eventsource"], "md": ["m", "wd", "hd", " MD", "mp", "dr", "cmd", "sha", "data", "mo", "dig", "dd", "rpm", "hash", "map", "mc", "mag", "d", "vd", "od", "ms", "meta", "key", "hm", "ng", "amd", "mg", "dm", "bd", "mb", "metadata", "cm", "MD", "di", "mn", "ad", "mac", "id", "mand", "mm", "sm", "ma", "mem", "ke", "ld", "em", "pm", "mt", "mu", "mod", "dh", "doc"], "theDigest": ["TheDigEST", " theSignester", " theSignEST", "thedigester", "theDigester", "theHashEST", "theHashester", "thedighest", "thedigEST", " theDighest", "TheDigester", "Thedigester", "theDighest", "theSignest", "theSignEST", "ThedigEST", " theSignest", "theSignester", "theHashest", "theDigEST", "thedigest", "theSignhest", " theDigEST", " theSignhest", "Thedigest", " theDigester", "TheDigest"]}}
{"id1": "3430784", "id2": "23452437", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"decodeBody": ["decodedPart", "decodedStream", "decodedBody", " decodedFile", " decodeStream", "decodesBody", "decodedFile", "decodeFile", " decodeFile", "decodingPart", "decodePart", " decodedBody", "decodeStream", "decodesStream", "decodingFile", "decodesFile", " decodePart", " decodedStream", "decodingStream", "decodingBody", " decodedPart", "decodesPart"], "in": ["into", "m", "ex", "ins", "url", "resource", "image", "In", "b", "body", "connection", "init", "data", "version", "session", "socket", "inc", "gin", "it", "f", "input", "din", "IN", "inn", "inas", "read", "conn", "pass", "cin", "i", "source", "is", "win", "reader", "src", "config", "inside", "nin", "work", "login", "inner", "min", "r", "id", "ac", "load", "con", "bin", "exec", "file", "err", "loader", "c", "get", "ini", "as", "content", "buffer", "again", "serv", "request", "isin"], "contentTransferEncoding": ["contentRestEncaming", "contentTransferCoding", "contentTransferEcitting", "contentTransferEasing", "contentTransferencitting", "contentTransferEngoded", "contentPartEryption", "contentPartEasing", "contentTransferencording", "contentTransferEncoder", "contentTransferCoded", "contentTransferCoder", "contentTransferencoder", "contentTransferEnosing", "contentPartEncryption", "contentTransferEoding", "contentRestEnording", "contentTransferEncaming", "contentTransferEcording", "contentTransferAcasing", "contentTransferEncoded", "contentTransferCearing", "contentTransferEnoder", "contentTransferEncosing", "contentTransferEncasing", "contentTransferEcoding", "contentTransferEngearing", "contentTransferEcaming", "contentRestEnoder", "contentPartEoder", "contentTransferCasing", "contentTransferEndoder", "contentRestEncoder", "contentTransferEncryption", "contentTransferEnoding", "contentTransferEndasing", "contentTransferCryption", "contentPartEncoder", "contentTransferEnearing", "contentTransferEnryption", "contentTransferEnasing", "contentTransferCaming", "contentPartEoding", "contentTransferencoding", "contentTransferEngoding", "contentPartEncasing", "contentTransferAcoder", "contentTransferEngasing", "contentTransferEndoding", "contentTransferEoder", "contentRestEnoding", "contentTransferEncearing", "contentTransferCording", "contentRestEnaming", "contentTransferAcoding", "contentTransferEndoded", "contentPartEncoding", "contentRestEncoding", "contentTransferAcosing", "contentTransferEnoded", "contentTransferEncitting", "contentTransferEnording", "contentTransferEnaming", "contentTransferEryption", "contentTransferEosing", "contentTransferEcoder", "contentTransferEnitting", "contentRestEncording", "contentTransferEncording"], "tempBody": ["outputLife", "tmpbody", " tempCore", "tempFile", "TempCore", "TempBody", " tempFile", "outputbody", "tmpCore", "tmpBody", "outputFile", "tmpLife", "tempbody", "outputBody", "Tempbody", " tempLife", "tempCore", "tempLife", " tempbody", "TempFile", "tmpFile"], "out": ["page", "ex", "writer", "resource", "copy", "null", "parent", "body", "connection", "init", "io", "off", "data", "this", "sync", "socket", "raw", "channel", "output", "o", "Out", "conn", "temp", "i", "source", "client", "a", "inner", "base", "outs", "user", "object", "cache", "exec", "bin", "file", "err", "obj", "c", "app", "extra", "OUT", "path", "pool", "again", "line", "ext"]}}
{"id1": "15051083", "id2": "17558353", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessageDesignest", "getmessageDigest", "getMessageDigester", "getMessageHashest", "getMessageHashests", "getMessageHashester", "getmessagedigester", "getmessageDigester", "getMessagedigester", "getmessagedigests", "getMessageHashature", "getMessageDigature", "getMessageDesignature", "getMessagedigature", "getmessageDigature", "getMessageDesignests", "getMessageDigests", "getMessagedigest", "getMessagedigests", "getmessagedigest", "getmessagedigature", "getMessageDesignester", "getmessageDigests"], "digest": ["Diger", " Digest", "digiter", "hexest", "greatest", "hexEST", "sandest", "DigEST", "Digger", " digEST", " digeter", "greatiter", "Digeter", "feedester", "Digex", "Digester", "digEST", "Digest", " digested", " Digeter", "sandesting", " digex", "digesting", "greatester", "hexex", " Digger", "sandester", "signest", "digger", "sandested", "hexests", " diger", " Dighed", "greatested", " digests", " Digester", " digester", " digger", "signested", " Diger", "digeter", "Digested", "Digesting", "digester", "digex", "signester", "Digests", "digests", "dighed", "Dighed", "Digiter", "diger", " dighed", "digested", "signesting", "feedest", "feedested", "signiter"], "node": ["component", "Node", "uri", "one", "resource", "server", "module", "parent", "n", "connection", "remote", "event", "child", " nodes", "document", "ode", "route", "index", " source", "element", "instance", "source", "config", " parent", "network", "self", " annotation", "point", "internal", "object", "local", "address", "name", "entity", " namespace", "root", "global", " Node", "location", "path", " child", "odes"], "external": ["intern", "ex", "ternal", "resource", "e", "n", "remote", " remote", "outer", "international", "outside", "foreign", "External", "tern", "multiple", "out", "element", "instance", "source", "network", "client", "target", "Intern", "internal", "object", "local", "https", "account", "name", "secondary", "global", "binary", "reference", " foreign", "environment", " global", " External", "export"], "messageDigest": ["messageMarkester", "messageModester", "messageSignested", "MessageDigest", "messagedigger", "messageMarkested", "messageModesting", "messageDigested", "messageDesignesting", "messagedigest", " messageHashest", "messageDigesting", " messageHashesting", "messageHashesting", "messageDesignest", " messageDesignger", "MessageSignest", "messageDesignger", " messageDigesting", "messageMarkenge", "messageDest", "messagedigester", " messageDigger", " messageDesignest", "messageSignenge", "messageDenge", "messageDesignested", "messageDigger", "messagedigested", " messageDigester", "messageModest", " messageDesignester", "messageHashest", "MessageSignester", "messageModested", "MessageDigenge", "MessageSignested", "messageDigenge", "messageDesignester", "messageSignest", " messageHashested", "messageDested", "messageMarkest", "messageSignester", " messageDigested", "MessageDigester", "MessageDigested", "messageHashested", "messageDester", "MessageSignenge", "messageHashester", " messageHashester", " messageDesignested", "messageDigester"]}}
{"id1": "18613870", "id2": "16719805", "code1": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", " copyStream", "CopyFiles", " copyFiles", "copyfile", " copyfile", "CopyStream", "transferfile", "copyFiles", "Copyfile", "transferStream", "copyStream", "transferFiles", "transferFile"], "src": ["conv", "ls", "ins", "url", "image", "server", "dest", "b", "loc", "rc", "this", "sb", "gd", "inst", "input", "rb", "ources", "s", "inf", "download", "sq", "conn", "sin", "source", "config", "filename", "stream", "l", "files", "slice", "sc", "sit", "upload", "gb", "dist", "sel", "ctx", "http", "img"], "dst": ["sddest", "ddest", "Ddest", "dbsts", "dest", "drc", "dsts", " dsts", "dST", "dbst", "dbST", "DST", "rddest", "dbdest", "Dst", "adst", "sdst", "rdrc", "adrc", "sdrc", " dST", "rdst", "addest", "Dsts", "rdest", "sdest", "adest", " ddest"], "in": ["ins", "url", "image", "In", "null", "n", "connection", "init", "io", "sync", "inc", "socket", "part", "gin", "f", "input", "din", "IN", "inn", "conn", "cin", "i", "is", "win", "source", "reader", "rin", "inside", "nin", "kin", "pull", "login", "inner", "min", "r", "id", "pc", "con", "bin", "file", "start", "up", "pin", "ini", "as", "again"], "out": ["at", "ex", "writer", "write", "image", "server", "call", "parent", "copy", "b", "plain", "n", "connection", "null", "init", "io", "off", "outer", "this", "bit", "outside", "inc", "sync", "not", "channel", "output", "gin", "exp", "o", "Out", "conn", "temp", "i", "client", "outs", "user", "exec", "bin", "err", "file", "c", "obj", "other", "extra", "up", "net", "OUT", "x", "again", "img"]}}
{"id1": "6371580", "id2": "23452437", "code1": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 0, "substitutes": {"insertDomain": ["updateDom", " insertdomain", " insertHost", "addDomain", "addHost", "updateHost", "insertDom", "insertdomain", "addDom", " insertDom", "updatedomain", "adddomain", "updateDomain", "insertHost"], "domains": ["messances", "commains", "Domands", "Domales", "domales", "dimales", "dimains", "messain", "domands", "demains", "dimages", "domages", "Domages", "demages", "domances", "demain", "messains", "commances", "commands", "dimands", "Domains", "demands", "commain", "demances", "demales", "messands"], "psImpl": [" psManager", "paramsInstance", "PSFactory", "ipsEl", "paramsInterface", "ipsimpl", "psInterface", "paramsManager", "psManager", "upsUl", "psEl", "PSimpl", "PSEl", "osEl", "ipsInstance", "osFactory", "qsUl", " psInstance", "PSImpl", "upsImpl", "psOrg", " psFactory", "ipsManager", "ipsImpl", "psUl", "upsimpl", "paramsImpl", "ipsOrg", "ipsInterface", " psInterface", "osimpl", "psFactory", " psOrg", "psInstance", "osImpl", "psimpl", "PSUl", "PSOrg", "qsImpl", " psimpl", " psEl", "qsimpl"], "iter": ["enter", "page", "inse", "e", "itter", "oper", "ner", "inc", "cer", "in", "loop", "it", "entry", "finder", "coll", "set", "index", "upper", "sort", "end", "el", "gener", "apper", "i", "is", "parse", "reader", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "over", "ir", "err", "Iter", "ider", "inter", "ator", "order", "next", "ite", "cher", "izer", "chain", "iterator", "feed"], "domain": ["prefix", "page", "description", "url", "role", "message", "module", "unit", "example", "remote", "data", "version", "zone", "folder", "range", "model", "result", "site", "rule", "str", "route", "index", "country", "key", "type", "division", "agent", "command", "base", "feature", "node", "Domain", "company", "id", "address", "string", "file", "product", "name", "origin", "root", "host", "region", "pattern", "query", "value", "format", "dom", "brand"]}}
{"id1": "17475530", "id2": "1598693", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinkstoPicture", "testAddLinkToFile", "testAddLinkToPicture", "testAddLinksToLink", "testAddLinksToPicture", "testAddLinkstoFile", "testAddLinkFromImage", "testAddLinkFromLink", "testAddLinkToLink", "testAddLinkstoLink", "testAddLinkstoImage", "testAddLinkOfImage", "testAddLinkOfLink", "testAddLinkFromFile", "testAddLinksToImage", "testAddLinkOfFile", "testAddLinkOfPicture", "testAddLinktoFile", "testAddLinktoImage", "testAddLinkFromPicture", "testAddLinktoPicture", "testAddLinksToFile", "testAddLinktoLink"], "in": ["at", "m", "ex", "ins", "ssl", "url", "resource", "image", "uri", "In", "copy", "ax", "n", "connection", "data", "version", "inc", "socket", "f", "gin", "input", "exp", "din", "IN", "index", "inn", "val", "out", "conn", "pass", "el", "cin", "xml", "is", "source", "win", "i", "reader", "with", "rin", "nin", "work", "stream", "login", "min", "r", "id", "token", "ac", "exec", "bin", "file", "con", "err", "name", "diff", "pin", "get", "ini", "as", "path", "or", "again", "serv", "doc", "isin"]}}
{"id1": "421042", "id2": "22977189", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 0, "substitutes": {"url": ["ur", "uri", "ssl", "resource", "ll", "server", "image", "fr", "null", "html", "connection", "loc", "io", "link", "f", "www", "URL", "ref", "href", "bel", "el", "xml", "source", "config", "rl", "filename", "l", "lr", "base", "id", "address", "string", "file", "name", "loader", "service", "ob", "sl", "host", "location", "Url", "path", "buffer", "http", "feed"], "in": ["m", "ex", "ins", "ssl", "resource", "image", "In", "n", "init", "io", "data", "this", "socket", "inc", "part", "f", "gin", "impl", "input", "din", "IN", "inn", "val", "out", "conn", "xml", "i", "is", "source", "rin", "reader", "config", "cms", "inside", "a", "nin", "login", "inner", "min", "r", "id", "token", "con", "file", "err", "c", "bin", "pin", "ini", "as", "or", "again", "serv", "isin"]}}
{"id1": "3631989", "id2": "5989666", "code1": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"run": ["exit", "running", "unit", "report", "server", "background", "build", "Run", "init", "output", "loop", " runs", "Main", "test", "process", "foo", "work", " execute", " Run", "exec", "start", " test", "runner", "execute", " running"], "url": ["ur", "page", "fr", "uri", "resource", "image", "server", "e", "ll", "ssl", "cert", "connection", "il", "org", "data", "link", "socket", "blog", "f", "rule", "URL", "www", "bel", "out", "el", "i", "source", "api", "l", "web", "github", "stream", "base", "address", "file", "name", "re", "ob", "up", "sl", "host", "plug", "path", "Url", "hub", "buffer", "http", "feed", "bb", "open", "ball", "browser"], "in": ["into", "ins", "ssl", "e", "fr", "fin", "In", "b", "connection", "init", "io", "fb", "inc", "f", "gin", "impl", "input", "din", "IN", "inn", "lin", "read", "out", "s", "conn", "i", "is", "kin", "reader", "inside", "nin", "stream", "l", "login", "inner", "r", "bin", "err", "file", "con", "ini", "again", "line", "isin"], "str": ["text", "Str", "fr", "arr", "st", "body", "data", "raw", "part", "entry", "status", "ch", "code", "comment", "source", "header", "inner", "r", "br", "string", "exec", "err", "obj", "start", "name", "content", "line", "doc", "char"]}}
{"id1": "12883117", "id2": "15351863", "code1": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"url": ["ur", "page", "uri", "ssl", "resource", "image", "server", "b", "connection", "io", "org", "data", "this", "f", "str", "URL", "source", "config", "stream", "l", "lr", "base", "r", "object", "address", "gl", "file", "name", "loader", "service", "sl", "path", "Url", " URL", "location", "buffer", "http", "feed"], "reader": ["writer", "resource", "server", "rx", "rer", "dr", "connection", "io", "data", "this", "parser", "reading", "ner", "socket", "in", "entry", "loop", "result", "Reader", "input", "editor", "read", "row", "player", "element", "i", "source", "iter", "driver", "builder", "stream", "er", "rr", "worker", "ger", "inner", "slice", "r", "handler", "file", "loader", "per", "layer", "keeper", "ler", "or", "buffer", "author", "oder", "feed"], "line": ["page", "pe", "LINE", "text", "log", "frame", "unit", "message", "e", "lf", "le", "write", "style", "body", "connection", "letter", "item", "cell", "data", "link", "sync", "part", "no", "entry", "zip", "rule", "str", "valid", "strip", "lin", "lines", "error", "key", "inline", "row", "end", "code", "element", "comment", "source", "parse", "header", "li", "l", "len", "number", "point", "user", "object", "look", "day", "string", "file", "Line", "liner", "name", "layer", "word", "lc", "feed", "block"], "phonesetMap": ["phonessetList", "phonessetCache", "phonesSetCache", " phonesetTable", " phonessetList", "phonesetCache", "phonesetList", "phonessetMap", " phonessetTable", "phonesSetList", "phonesSetMap", "phonesSetTable", "phonesetsTable", "phonesetTable", "phonessetTable", " phonesetCache", "phonesetsMap", "phonesetsCache", " phonessetCache", " phonessetMap", "phonesetsList", " phonesetList"], "lineCount": [" lineIndex", "LineCount", " linecount", "pagecount", "linecount", "LineIndex", "pageCount", "lineIndex", "Linecount", "pageIndex"]}}
{"id1": "11305840", "id2": "10674824", "code1": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "label": 0, "substitutes": {"setUpdateCliente": ["setUpdateContactes", "setupdateClienteur", "setupdateclienten", "setUpdateclientes", "setupdatecliente", "setUpdateclienten", "setUpdateCompanyes", "setUpdateContacten", "setUpdatecliente", "setUpdateContacte", "setUpdateClientes", "setUpdateCompanye", "setUpdateCompanyeur", "setUpdateclienteur", "setupdateClienten", "setupdateclienteur", "setupdateClientes", "setUpdateCompanyen", "setUpdateClienteur", "setupdateclientes", "setupdateCliente", "setUpdateClienten", "setUpdateContacteur"], "IDcliente": ["IDquanto", " IDservere", "IDprojectee", "IDclientpe", "IDquante", "IDprojecte", "IDprojectpe", "IDCliente", "IDprojectes", "IDClientpe", " IDclientes", " IDclientee", " IDclientE", "ENDclientee", "IDClientee", "IDClientE", "IDquantisi", " IDserverpe", "ENDCliento", "IDclientee", "IDClientes", "ENDCliente", "IDClientisi", "IDcliento", "ID1000isi", " IDserveres", "ENDClientisi", "ENDclientisi", "IDCliento", "ENDcliento", "IDservere", "ID1000e", "IDclientisi", "ID1000ee", "IDserverpe", "ENDcliente", " IDclientpe", "IDserveree", " IDserveree", "IDclientE", "IDclientes", "IDserveres", "ID1000o", "ENDClientee", "IDserverE", "IDquantee"], "nombre": ["Nuclere", " nomeber", "Nombber", "Nombrero", "nombber", "nugere", "nucleber", "nucleres", "nomerero", "numbred", "Nuclerero", "nomeber", " nombrero", "nugerero", "Nombres", " nomered", "nomeres", " nomere", "nugeber", "nombres", "nugered", " nomerero", " nombber", "numbres", "nomere", "Nombre", "Nucleber", "nomered", "nombred", "numbrero", " nombred", "nuclerero", "numbber", "numbre", "nombrero", "nuclere", "Nucleres"], "paterno": ["pterno", "patterno", "matterno", "paserno", "natern", "patersNo", "matterna", "patterNo", "natterno", "patersn", "pterna", "nattern", "paserNo", "natterna", "mattername", "patername", "patern", "pasern", "materna", "naterna", "patersno", "naterno", "patterna", "patersna", "pattername", "natterNo", "paterNo", "paterna", "paserna", "ptername", "naterNo", "pattern", "ptern", "matername", "mattern", "matern", "patersname"], "materno": ["matterno", "morterno", "MATERno", "mortern", "maternot", "natern", "MaterNo", "matersn", "natternot", "maserno", "natterno", "mATERna", "mATERno", "matersnot", "nattern", "maserna", "mATERn", "morternot", "MATERna", "naternot", "morterNo", "matternot", "masern", "mATERNo", "matersNo", "matersna", "matersno", "materna", "materNo", "naterno", "MATERNo", "natterNo", "Matern", "Materna", "matterNo", "maserNo", "naterNo", "MATERn", "Materno", "mattern", "matern"], "ocupacion": ["OCuppaci", "ocupsatio", "ocupaton", "ocuppacion", "oculpaton", "ocovacion", "ocovaci", "OCupaton", "ocuppaton", "acupacion", "OCupaci", "acuppruction", "ocopacia", "ocupruction", "ocupsacion", "OCuppatio", "ocovruction", "acupruction", "ocupatio", "OCuppaton", "ocopaci", "oculpaci", "ocupacia", "ocuppruction", "acupacia", "OCupacion", "ocuppaci", "ocopruction", "ocovacia", "oculpatio", "acuppacion", "acupaci", "ocuppacia", "ocopacion", "ocupaci", "acuppacia", "OCuppacion", "ocupsaton", "ocupsaci", "acuppaci", "OCupatio", "oculpacion", "ocuppatio"], "rfc": ["sriff", "srpc", "rbf", "srfc", "Rfc", "rspc", "Rpc", "rrfc", "rrpc", "srfe", " rbf", "riff", "Rf", "rrf", "rsfe", " rfe", "rrbf", " rf", " riff", "rsfc", " rpc", "rfe", "Rbf", "rsiff", "rf", "rpc"], "stm": ["Stm", "STm", "stf", "ctf", "ntm", "stmt", "ntbm", "ctmt", "crbm", " stbm", "STmt", "Stf", "ctm", "ntM", "crM", "StM", "crm", " stdm", "ntdm", "stM", "stbm", "crdm", "STM", "STf", "stdm", "Stmt", "ctM", " stM"], "update": ["replace", "save", "include", "component", "UPDATE", "unit", "write", "module", "apply", "build", "complete", "lock", "equal", "event", "updated", "enable", "it", "draw", "result", "check", "set", "valid", "run", "remove", "error", "accept", "fill", "out", "end", "create", "add", "Update", "edit", "send", "id", "change", "load", "initial", "other", "continue", "up", "diff", "ite", "json", "response", "current", "ify", "author", "where", "use", "open", "database"]}}
{"id1": "14783950", "id2": "12004824", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"compressWithZip": ["compressUsingJar", "compressUsingZip", "compressInZip", "compresswithZip", "compresswithSax", "compressedWithJar", "compressInSax", "compressedWithZip", "compressWithJar", "compressUsingSax", "compresswithJar", "compressInJar", "compressedWithSax", "compressedUsingJar", "compressedUsingZip", "compressedUsingSax", "compressWithSax"], "fileList": [" fileChain", "wordString", "FileStream", "zipSet", "FileString", "fileStream", "modelCollection", "wordName", "inputEx", "modelEx", "fileCollection", "FileSet", "fileString", "modelList", "wordStream", "modelStream", "FileList", "inputCollection", "fileEx", "FileChain", "filelist", " fileSet", "zipList", "inputList", "inputStream", "wordList", "ziplist", "fileChain", "stringName", " fileEx", "stringlist", " fileStream", "Filelist", " fileCollection", " fileString", "FileName", "stringList", "stringChain", "zipName", "fileSet", " filelist"], "zipFileName": ["folderGlobalPath", "archiveDirDir", "zipFullname", "zipDirname", "zipFileDir", "archiveDirPath", "zipGlobalNames", "zipFullPath", "folderGlobalname", "zipFilename", "archiveFileName", "archiveFilePath", "zipDirDir", "zipPackagePath", "zipFullName", "zipFileNames", "archiveDirName", "folderFileNames", "zipGlobalPath", "folderFileName", "zipFullDir", "zipPackageName", "zipPackageDir", "folderGlobalName", "zipDirNames", "zipDirName", "archiveFileDir", "zipFullNames", "zipGlobalName", "zipDirPath", "zipFilePath", "folderFilename", "folderFilePath", "zipGlobalname", "folderGlobalNames"], "fos": ["Fosh", "infoS", "Fos", "flos", "faos", "infos", "fosh", "infaos", "afoS", "foS", "flis", "Faos", "FoS", " fosh", "afaos", "infis", "flosh", "afis", "afos", "Fis"], "zos": ["css", "zz", "ros", "dos", "closure", "z", "fits", "kos", "tz", "fi", "ZA", "os", "jas", "jobs", "ozo", "osi", "uz", "iframe", "nz", "cos", "loop", "zip", "es", "bis", "bos", "lins", "bag", "chini", "zes", "oses", "zzy", "seconds", "abi", "zik", "lol", "bes", "zar", "zag", "zo", "zers", "zen", "LOS", "outs", "zl", "rez", "ses", "onz", "zb", "ZI", "packs", "gz", "zx", "zer", "zy", "webkit", "obb", "zi", "phi", "zon", "zan", "spin", "budget", "inos"], "iter": ["enter", "inse", "fr", "e", "itter", "ser", "loc", "outer", "oper", "ner", "inc", "ie", "it", "f", "set", "index", "upper", "finder", "sort", "coll", "end", "test", "ener", "el", "gener", "i", "is", "parse", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "slice", "ir", "file", "err", "fer", "list", "Iter", "inter", "ator", "izer", "next", "ite", "order", "cher", "liter", "iner", "chain", "iterator", "iz", "http"], "fileName": ["filenamename", "pageString", "FileString", " filePart", "FileUrl", "fName", "filePath", " filePath", "localname", "fileOpen", "filenameName", "currentname", "fileData", " fileLine", " fileType", " fileData", "FileFull", "fullOpen", "fileString", " fileFull", "fileType", "FilePart", "simplePath", "filenameInfo", "fileUrl", "currentData", "pageType", "currentName", " fileUrl", "FileLine", "pagename", "localPart", "fileInfo", "filename", "localName", "currentUrl", "simpleOpen", " fileInfo", "Filename", "FileInfo", "FilePath", " filename", "fPart", "fileFull", " fileString", "FileName", "fullPath", "localPath", "filePart", "FileData", "fullName", "fLine", "pageName", "FileType", " fileOpen", "fileLine", "simpleName", "filenameFull", "fname"], "ind": ["bind", "fr", "z", "vert", "nd", "j", "length", "count", "loc", "mid", "ded", "inc", "pos", "in", "cond", "pt", "index", "inn", "d", "ci", "val", "end", "eff", "i", "pull", "dir", "rib", "len", "ad", "id", "div", "ord", "IND", "start", "ld", "ix", "mind", "ii", "x", "Ind", "wind", "pend"], "shortName": ["Shortname", "ShortPath", " shortString", "longName", "smallname", "shortPart", "ShortString", "shortname", "ShortPart", "smallPart", "shortPath", "shortString", "ShortName", "longPart", "shortLine", "smallPath", "fullname", " shortPath", "longLine", "fullString", " shortname", "smallName", "longPath", "longname", "fullPath", "fullName", "fullLine", " shortLine"], "fis": [" fiss", "pisa", "fisa", "Fos", "fris", "cfis", "Fiss", "gisa", " fris", "cfs", " fisa", "gis", "fs", "pis", "fios", "Fs", "gios", "pris", "fiss", "pios", "cfiss", "gris", "afiss", "cfris", "cfos", " fs", "afris", "afis", " fios", "afos", "Fis"], "buf": ["fd", "cv", "uf", "bu", "uc", "b", "loc", "rc", "fb", "data", "bh", "bp", "lb", "feat", "bc", "pb", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cur", "bf", "bd", "grab", "tmp", "buff", "ff", "queue", "ba", "br", "v", "lim", "bin", "la", "vec", "wb", "bl", "buffer", "seq", "box", "bb"], "bytesRead": [" bytesLength", "flowsWrite", "tesRead", "flowsRead", "bitsSkip", " bytesWrite", "bitsLength", "bitsRead", " bytesNeed", " bytesLoad", "bytesNeed", "bitsWrite", "tesWrite", "tesSkip", "bitsUse", "secondsRead", "wordsWrite", "bytesUse", "wordsUse", "bitsLoad", "secondsWrite", "bytesSkip", "tesLoad", "wordsRead", "bytesLoad", "bytesLength", "secondsLength", "bytesWrite", "flowsNeed", "secondsNeed", "flowsLength", " bytesUse", "wordsLength", " bytesSkip"]}}
{"id1": "838844", "id2": "20128728", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "701029", "id2": "19868933", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadSourceCode": ["getSourceCode", "loadsourceCode", "loadsourceFile", "getSourcecode", "loadSourceFile", "loadSourcecode", "loadsourcecode", "loadCodeFile", "getSourceFile", "loadCodecode", "loadCodeCode"], "length": ["page", "text", "delay", "count", "build", "style", "lock", "version", "depth", "weight", "data", "ph", "L", "duration", "part", "limit", "shape", "zip", "read", "end", "key", "type", "code", "time", "total", "class", "th", "library", "size", "width", "filename", "work", "l", "len", "Length", "number", "base", "capacity", "position", "id", "address", "string", "load", "name", "angle", "full", "path", "value", "content", "buffer", "block", "open", "ext"], "file": ["page", "book", "pe", "log", "FILE", "resource", "flow", "e", "play", "image", "b", "connection", "force", "il", "io", "data", "folder", "f", "check", "feed", "fs", "source", "class", "filename", "l", "use", "self", "db", "files", "base", "object", "name", "loader", "full", "File", "get", "path", "buffer", "fe", "http", "fp"], "buff": ["buf", " rest", "uf", "text", "txt", " chars", " text", " buffer", "Buffer", "ch", " chunk", "Buff", " arr", " buffers", " char", " ch", " Buffer", " style", " background", "buffer", "comp", "utf", "bb", " buf"], "is": ["ur", "p", "res", "uri", "fr", "resource", "isi", "isl", "loc", "os", "il", "io", "ie", "in", "it", "es", "bis", "iv", "IS", "isc", "out", "s", "i", "api", "src", "ar", "l", "web", "ip", "are", "r", "ib", "address", "iss", "ir", "err", "ris", "ais", "Is", "ob", "sr", "get", "as", "ui", "or", "isa", "abs", "http", "serv", "ri"], "isr": ["arsr", "Islr", "Isr", "israr", "bsr", "ISr", "servr", "issri", "servrt", "bsrr", "isrc", "ISri", " isrs", "asrb", "bsrt", "ISrb", "arsrr", "asr", "islr", "servrar", " isri", "isrs", " isrc", "servrr", "isrr", "isri", "ISrc", "aslr", "issrb", "isrb", "bsrar", " islr", "issrc", " isrb", "Isrb", "asrs", "isrt", "arsrt", "arsrar", "issr", "Isrs"], "cv": ["conv", "vert", "vp", "b", "view", "cp", "rc", "tc", "cam", "sv", "uv", "bc", "vv", "vr", "vs", "mc", "cpp", "cb", "cur", "cc", "gg", "nv", "ctrl", "cu", "cm", "ctr", "lv", "sc", "CV", "v", "c", "VC", "fc", "vc", "ctx", "cf", "vm", "lc", "hw"], "url": ["ur", "page", "log", "fl", "uri", "fr", "resource", "ssl", "server", "image", "view", "loc", "il", "link", "blog", "f", "str", "URL", "el", "download", "source", "api", "rl", "stream", "l", "web", "lr", "base", "r", "id", "address", "string", "err", "loader", "name", "re", "ob", "sl", "host", "location", "Url", "path", "http", "feed"], "reader": ["roller", "writer", "resource", "server", "rx", "rer", "ser", "rc", "io", "ner", "rar", "parser", "reading", "in", "Reader", "editor", "read", "row", "player", "i", "iter", "source", "war", "builder", "bird", "stream", "er", "rr", "l", "ger", "inner", "worker", "r", "holder", "handler", "ir", "loader", "re", "cher", "or", "ler", "buffer", " readers", "oder", "http", "ri", "ry"], "sourceCode": ["ourceFile", "SourceContent", " sourceFile", "parentCode", "parentcode", " sourcecode", " sourceLine", "proxyFile", "byteLine", "sourceLine", "ourceScript", "sourceScript", "sourceFile", "bytecode", "ourceCode", "ourceText", "proxycode", "SourceCode", "SourceLine", "proxyCode", " sourceText", "sourceContent", " sourceContent", "sourceText", "ourceContent", "SourceScript", "Sourcecode", " sourceScript", "parentText", "sourcecode", "byteCode", "ourcecode"], "line": ["page", "LINE", "text", "frame", "lf", "message", "one", "write", "le", "unit", "body", "letter", "none", "cell", "data", "link", "hide", "sync", "part", "no", "in", "entry", "model", "str", "lin", "lines", "error", "inline", "end", "row", "key", "code", "element", "source", "comment", "parse", "record", "li", "l", "ip", "number", "base", "position", "object", "id", "day", "string", "character", "c", "Line", "liner", "sl", "pre", "next", "auto", "word", "content", "lc", "non", "office", "on"]}}
{"id1": "659316", "id2": "13783898", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"argv": ["Argve", "Argb", " argve", " argver", " argl", "interV", "argsv", "argV", "argumentc", "Argver", "Argf", "Argl", "paramb", "argumentv", "argumentve", "Argc", "argver", "interc", "argsc", " argb", " argc", "interv", " argV", "argf", " argf", "paramV", "interl", "paramv", "argve", "argb", "argsl", "Argv", "argl", "argumentver", "argsf", "paraml", "ArgV", "argc"], "sources": ["tources", "fides", "psides", "sences", "tides", "sesores", "vesores", "sides", "sesigs", "vesences", "sigs", "statources", "fource", "statigs", "tresources", "fors", "sesources", "vesigs", " sides", "issource", "issides", "psources", "fources", "statores", "psresources", "issors", "psource", "fresources", "sresources", "sors", " sors", "issources", "sesences", "vesources", "sores", "tource", "statences"], "targets": [" taxets", "targends", "taxels", " tokets", "tangets", "taxes", "tangels", " targencies", " targens", "Tangens", "targels", "tokets", "targencies", "tagnencies", " tokencies", "tigens", " targes", "tokens", "tanget", "toket", "tagnets", "tamplets", "tampens", "tampels", "targens", " targends", "tigets", "tagnens", "Targlets", "tanges", "tangens", "tiges", " tokens", "targes", " taxes", "taxends", "Tanglets", " taxens", "Targens", "tangencies", "Tangels", " toket", "taxens", "tangends", "Targets", "tampets", "taxets", "Targels", "tagnet", "tokencies", "taxlets", "tigends", "tanglets", "Tangets", "targlets", " taxends"], "srclen": ["srploen", " srplength", "srselen", " srclength", "srplen", "rscelens", "srCLen", "srclength", "rscln", "srClens", "srCLoen", " srploen", "srceln", " srcloen", "rsclens", "srcloen", "srctoen", "srCLeno", "srclens", "srcln", "srctength", "srCln", "srcteno", "srClen", "rscelEN", "srcelens", "srseln", "srClEN", "srpleno", "srcelEN", " srcleno", "srcten", "srplength", " srplen", "srselEN", "srCLength", " srpleno", "rsceln", "rsclen", "srcleno", "rsclEN", "rscelen", "srcelen", "srselens", "srclEN"], "source": ["proxy", "component", "url", "ssl", "uri", "resource", "image", "unit", "parent", "dest", "copy", "scope", "view", "rc", "remote", "event", "single", "link", "channel", "in", "model", "Source", "input", "ources", "out", "s", "type", "create", "driver", "src", "reader", "size", "client", "config", "stream", "seed", "self", "slice", "id", "cache", "ource", "start", "service", "sl", "SOURCE", "get", "path", "current", "secure", "force", "use"], "tgt": ["ptnt", " tgz", "tgh", "bitgt", "ptarg", " tgs", " tkt", "hret", "larg", " tbuster", "rgs", "ptgt", "hgt", "lret", " targ", "tnt", "Tch", " tch", "biticket", "Tgt", "tgs", " ticket", "lgt", "Tgh", "lnt", "tch", " tnt", "tkt", "bitarg", "Tgs", "ticket", "rgt", " tret", "targ", "Ticket", "rch", "ptbuster", "hnt", "tbuster", "hgz", "lbuster", "rkt", "tret", "Tkt", "lgz", " tgh", "bitgh", "Targ", "tgz"], "target": ["to", "component", "url", "unit", "resource", "image", "core", "parent", "dest", "master", "null", "view", "connection", "rel", "manager", "remote", "event", "io", "project", "mount", "session", "child", "port", "external", "director", "channel", "output", "member", "it", "result", "cross", "route", "archive", "nt", "out", "conn", "download", "plugin", "driver", "client", "slave", "Target", "point", "base", "object", "match", "arget", "handler", "service", "goal", "next", "path", "current", "tail", "force", "open"], "deletes": ["delises", "Deletes", "kesleted", "downgrades", " deleted", "exgrades", "kesouts", "disles", "kesises", "desletes", "delouts", "downletes", "delletes", "disists", " delete", "delleted", "deises", "downlete", "downdates", "exdates", "exletes", "degrades", "desles", "deouts", "deires", "delete", " deouts", "exlete", "deists", " degrades", "Deists", "disires", "dedates", "Deires", "desires", "desists", "disletes", " deises", "Deles", "kesletes", "deles", "deleted", " dedates"], "del": ["fl", "delay", "install", "ll", "se", "copy", "null", "rel", "lock", "ul", " delete", "data", "dec", "syn", "model", "fail", "d", "coll", "nl", "remove", "el", "download", "dl", "pull", "add", "dir", "delete", "base", "de", "local", "change", "neg", "skip", "id", "err", "file", "name", "Delete", "def", "up", "sel", "diff", "down", "get", "clean", "Del", "bl", "update", " Del"]}}
{"id1": "17786231", "id2": "19810820", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": [" downloadStream", "downloadStream", "copyfile", "copyFile", "transferfile", "copyFiles", "transferFile", "copyStream", "transferStream", " downloadFiles", "downloadFiles", " downloadfile", "transferFiles", "downloadfile"], "downloadUrl": ["updateurl", "outputLine", "outputurl", "updateLine", "transferFile", "downloadURL", "transferurl", "updateUrl", "downloadLine", "transferURL", "outputUrl", "updateURL", " downloadURL", "downloadurl", "outputURL", " downloadLine", " downloadurl", "updateFile", "transferUrl"], "destinationFile": ["destporaryFiles", "destigrationFILE", "destoutputString", "DestinatingFILE", "destoutputImage", "destinatedFILE", "destinatedFile", "destigrationFile", "destporaryString", "destinatingFile", "DestinationFile", "DestinatingString", "destinatingFilename", "destinatingImage", "destporaryImage", "destigrationFiles", "DestinatingFiles", "destigrationFilename", "DestinationFILE", "DestinatingFilename", "DestinatingFile", "DestinationString", "DestinatingImage", "destinatingString", "destoutputFile", "destinatingFILE", "destinatedFilename", "destporaryFile", "destinationImage", "destinationFILE", "destinationFilename", "destoutputFiles", "destinationString", "DestinationImage", "destinatingFiles", "DestinationFiles", "DestinationFilename", "destinationFiles", "destinatedFiles"], "client": ["proxy", "url", "uri", "resource", "server", "call", "parent", "connection", "force", "remote", "ce", "method", "project", "session", "channel", "application", "connect", "cl", "conn", "plugin", "api", "config", "bird", "cli", "contact", "self", "Client", "queue", "cache", "https", "con", "c", "handler", "app", "service", "per", "cher", "get", "query", "http", "request"], "httpGet": ["HttpCreate", "ttpCall", "httpCall", "ttpSend", " httpSend", "ttpCreate", "resourcePut", "httpSend", "ttpGet", "HttpCall", "resourceCall", "httpPut", "resourceget", "HttpGet", " httpPut", "Httpget", "resourceGet", "HttpPut", " httpCall", " httpget", "httpCreate", "httpget", " httpCreate", "HttpSend"], "outputFile": ["outputFiles", "referencePath", "writeFile", "referenceFile", "targetDir", "writeStream", "inputFile", " outputPath", " outputDirectory", "targetFiles", " outputfile", "outputDirectory", "outfile", "outStream", "writePath", "outputPath", "referencefile", "targetFile", "inputDirectory", "inputDir", " outputFiles", "referenceStream", "targetDirectory", "outputDir", "outPath", "outFile", "inputFiles", " outputDir", "writefile", "outputfile"], "outputStream": ["inputSteam", "inputWriter", "outputStreamer", " outputSteam", " outputForm", "logWriter", "inputFile", "outputForm", "responseFile", "inputStreamer", "inputForm", "responseStream", "responseSteam", "outputWriter", " outputWriter", "logSteam", "logStream", "OutputWriter", " outputStreamer", "responseWriter", "OutputForm", "OutputStream", "OutputSteam", "outputSteam", "logStreamer", "OutputFile"], "response": ["resp", "respond", "report", "resource", "message", "image", "server", "Response", "connection", "body", "event", "data", "version", "session", "output", "application", "status", "document", "result", "reply", "error", "api", "queue", "object", "handler", "success", "relation", "json", "query", "generation", "collection", "http", "feed", "request", "ception", "received"], "entity": ["pe", "component", "attribute", "ity", "url", "unit", "resource", "e", "image", "server", "message", "volume", "body", "connection", "Entity", "item", "ce", "event", "data", "ie", "channel", "output", "model", "document", "entry", "result", "status", "application", "coll", "translation", "ent", "el", "xml", "instance", "element", "issue", "metadata", "source", "api", "media", "comment", "agent", " identity", "node", "object", "id", "cache", "email", "file", "machine", "service", "environment", "json", "content", "state", "collection"], "inputStream": ["downloadLength", "inputChannel", "inputSteam", " inputSteam", "InputLength", "childSteam", "audioSteam", "InputFile", "InputChannel", "outputStreamer", "outputstream", "selectFile", "inputFile", "childStream", "audiostream", "inputStreamer", "audioStream", "downloadSteam", "selectSteam", "inputLength", " inputStreamer", "Inputstream", "InputStreamer", "downloadstream", "childChannel", "audioStreamer", " inputFile", "childStreamer", " inputLength", " inputBuffer", "selectStream", "downloadStream", "outputSteam", "InputBuffer", "InputSteam", "inputBuffer", "outputChannel", "outputBuffer", "inputstream", " inputstream", "selectStreamer", "InputStream", " inputChannel"], "callback": ["proxy", "closure", "url", "CB", "message", "resource", "call", "connection", "Callback", "cell", "event", "fb", "back", "data", "sync", "func", "result", "batch", "clone", "cb", "band", "code", "cc", "plugin", "consumer", "future", "config", "ff", "backs", "cache", "handler", "loader", "behavior", "function", "wrapper", "state", "buffer", "collection", "processor"], "copiedLength": ["copiedlength", "copippedLength", "copodedWidth", "copyiedWidth", "copedBytes", "copodedSize", "copyingLength", "copyingCount", "copedSize", "copiedCount", "copyiedSize", "copyippedWidth", "copedLength", "copyinglength", "copixedBytes", "copiedBytes", "copyiedCount", "copyippedLength", "copodedLength", "copyingWidth", "copyiedLength", "copixedCount", "copyedLength", "copodedlength", "copyingSize", "copyiedlength", "copyiedBytes", "copippedlength", "copyingBytes", "copixedSize", "copixedLength", "copiedSize", "copedCount", "copyippedlength", "copippedWidth", "copippedSize", "copiedWidth", "copyedBytes", "copyedSize", "copyippedSize", "copyedCount"], "percentage": ["Percentance", "percentile", "Percentade", " percentages", "milade", " Percentages", " Percentance", "percentaged", " Percentile", "percentages", "milance", " percentance", "percentance", " percentade", " percentaged", "Percentaged", "milage", "Percentages", " Percentage", "Percentile", "percentade", " percentile", "milaged", "Percentage"]}}
{"id1": "22977189", "id2": "2511579", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"in": ["ln", "ins", "url", "image", "In", "g", "b", "n", "init", "data", "this", "inc", "socket", "gin", "f", "input", "din", "IN", "inn", "lin", "read", "pass", "cin", "i", "is", "win", "source", "reader", "inside", "nin", "er", "login", "inner", "min", "r", "id", "con", "err", "bin", "c", "re", "up", "ini", "as", "plus", "again", "isin"], "out": ["ex", "writer", "default", "flow", "parent", "init", "data", "part", "o", "password", "conn", "temp", "a", "self", "outs", "r", "cache", "exec", "err", "file", "list", "query", "page", "server", "call", "connection", "this", "inc", "editor", "error", "key", "point", "object", "w", "word", "prefix", "log", "plain", "io", "outer", "off", "sync", "Out", "s", "comment", "flush", "user", "bin", "obj", "app", "up", "again", "block", "at", "write", "copy", "b", "n", "raw", "output", "f", "strip", "client", "inner", "window", "name", "OUT", "pool", "as", "ext"], "line": ["page", "text", "pe", "LINE", "log", "url", "lf", "message", "write", "unit", "style", "letter", "lock", "cell", "data", "link", "entry", "f", "rule", "str", "lin", "cl", "lines", "end", "key", "inline", "row", "code", "pass", "column", "i", "comment", "source", "header", "l", "id", "string", "character", "file", "c", "Line", "name", "sl", "next", "word", "content", "lc", "value", "feed", "block", "char"]}}
{"id1": "12678045", "id2": "14038176", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"addQDInformation": ["addQdDirectory", "addKDinformation", "addQdInformation", "addQDMDirectory", "addQdinformation", "addKDDirectory", "addKDInfo", "addKdInformation", "addQDMinformation", "addKDInformation", "addQdInfo", "addQDinformation", "addKdinformation", "addQDSDirectory", "addQDDirectory", "addQDSInformation", "addQDInfo", "addKdInfo", "addQDSInfo", "addQDMInformation", "addQDSinformation", "addKdDirectory", "addQDMInfo"], "qdDate": [" qdModule", "sqpName", "qpType", "qdType", "qidVal", " qdDay", "qcDate", "qdyStatus", "qtData", " qfData", " qdAge", "qdName", "qsTime", "qfFile", "qdxType", " qfFile", "qfDate", "sqdDate", "qdatDay", "qsModule", "sqpDate", "qdatTime", " qdTime", "qdTime", "sqdVal", "qpVal", "qidType", "qdtTime", " qtTime", " qsName", "qdStatus", " qfStatus", "qdVal", "qdatAge", " qdName", "qtAge", "sqdName", "qdyModule", "qdtDate", "qdxVal", "qtTime", "qfStatus", "qdyTime", "qtDate", "qcAge", "qdDay", " qtDay", "qdxDate", " qsTime", "qtFile", "qcTime", "qtStatus", "qsName", " qsModule", " qtAge", "qdyName", "qdyFile", "qtDay", " qdData", "qidName", "qdModule", "qdData", "qpName", "qpDate", "qfData", "qcDay", "qdyData", "qdxName", "qsDate", "qdtName", " qdStatus", "qidDate", "qdatDate", "qdtModule", " qtDate", " qfDate", "sqpVal", "sqpType", "qdyDate", "qdAge", "sqdType", " qsDate"], "qdFile": [" qdFolder", "qdInfo", "qdsLog", "qsfile", "qdBuffer", "qdFolder", "qdsFile", "qddInfo", " qfDir", "qdxFile", " qdDir", "qdsfile", " qfInfo", "qdDir", "qsDir", " qdInfo", " qdLog", "qdaLog", "sqdfile", "qfFolder", "qddFile", "sqdFile", "sqdReader", "qdaFile", "qdaFolder", "qdReader", "qfFiles", "qdFiles", "qdsReader", "qfBuffer", " qfBuffer", "qfFile", "qdfile", " qdsFile", "qdsBuffer", "sqdsFile", "sqdsDir", " qfFile", "qdxReader", "qdsFiles", " qdsLog", "sqdsfile", "qdsDir", " qdsFolder", "qdxDir", "qfDir", "qsFile", "qfLog", "qdLog", "qdxfile", "sqdDir", "sqdsReader", "qdsInfo", "qdsFolder", " qdFiles", "qfInfo", "qsReader", " qdBuffer", "qddDir", " qdsFiles", "qdaFiles", "qddBuffer"], "_qdFileDate": ["_qdDirectoryDate", "_qndFiledate", "_qdMinName", "_qdcFileStatus", "_qdBaseName", "_qdfileDate", "_qdBaseStatus", "_qdBaseUpdate", "_qdcfileStatus", "_qdfileDesign", "_qdcFileUpdate", "_qdDirectoryDesign", "_qdfileStatus", "_qdMinStatus", "_qdMinUpdate", "_qdFileName", "_qdfileUpdate", "_qdTimeDate", "_qdcFileName", "_qdfileName", "_qdcfileName", "_qdDirectoryStatus", "_qdTimeStatus", "_qndTimeStatus", "_qdFileStatus", "_qdFileUpdate", "_qdBaseDate", "_qdTimedate", "_qndTimeDesign", "_qdcFileDate", "_qndFileStatus", "_qdfiledate", "_qdTimeDesign", "_qdDirectorydate", "_qdcfileUpdate", "_qndFileDate", "_qdMinDate", "_qdFileDesign", "_qndTimedate", "_qdcfileDate", "_qdFiledate", "_qndTimeDate", "_qndFileDesign"], "ii": ["que", " iii", "uri", "lu", "image", "vid", "fi", "ori", "II", "si", "ie", "ni", "oe", "index", "ci", "iu", "oi", "ji", "inf", "uni", "iii", "i", "mini", "abi", "ice", "li", "di", "qa", "ei", "vi", "pi", "xi", "hi", "eni", "ind", "id", "yi", "ti", "gi", "iri", "ix", " i", "zi", "ai", "ih", "ou", "ini", "ui", "chi", "jp", "bi", "qi"], "info": ["fo", "txt", "kid", "conf", "Info", "b", "prev", "init", "off", "data", "child", "link", "part", "alias", "entry", "f", "py", "archive", "ref", "error", "INFO", "h", "end", "job", "inf", "ignore", "home", "abi", "i", "comment", "api", "qa", "li", "di", "buff", "hi", "opt", "fw", "fam", "object", "id", "gi", "handler", "information", "obj", "name", "def", "af", "extra", "bug", "op", "ui", "feed", "ext"], "_qdValue": ["_sqdcInfo", "_sqdInfo", "_sqdData", "_sqdName", "_qdsValue", "_qdcData", "_qdcName", "_qDName", "_qdInfo", "_qdsName", "_sqdValue", "_qdcInfo", "_qDData", "_qdsInfo", "_qdData", "_qDInfo", "_qDValue", "_qdsData", "_sqdcData", "_sqdcName", "_qdName", "_sqdcValue", "_qdcValue"], "reader": ["fd", "http", "writer", "uri", "resource", "report", "server", "rer", "dr", "rc", "io", "data", "parser", "rar", "reading", "entry", "f", "result", "Reader", "input", "read", "row", "player", "source", "iter", "driver", "library", "client", "er", "rr", "worker", "ger", "inner", "r", "handler", "loader", "re", "service", "per", "ler", "or", "buffer", "author", "manager", "feed", "ri"], "urlName": [" urlFamily", " urlArea", "urlname", " urlname", "uriName", "urlArea", "urlFile", " urlString", "UrlInfo", "urlKey", "URLInfo", "URLname", "urlFamily", "URLString", "UrlString", "webInfo", "UrlKey", " urlKey", "urlPart", "URLName", "Urlname", "URLKey", "UrlArea", "UrlName", " urlInfo", "uriFamily", "UrlFile", "URLFile", "urlInfo", "URLArea", "UrlPart", "uriInfo", "webFamily", " urlPart", "webName", " urlFile", "urlString", "URLPart"], "url": ["page", "uri", "ssl", "resource", "server", "large", "connection", "data", "socket", "director", "channel", "f", "www", "URL", "bel", "source", "pull", "web", "l", "base", "user", "r", "address", "string", "gl", "name", "sl", "host", "path", "Url", " URL", "buffer", "http", "feed", "open", "ball", "browser"], "stream": ["writer", "resource", "view", "Stream", "form", "io", "data", "oper", "socket", "raw", "channel", "in", "f", "zip", "input", "coll", "draft", "out", "row", "s", "download", "source", "driver", "ream", "client", "flash", "user", "r", "control", "trans", "v", "handler", "sl", "per", "response", "buffer", "http", "feed", "open"], "file": ["book", "page", "log", "writer", "http", "resource", "report", "ile", "server", "b", "body", "lock", "io", "data", "socket", "part", "folder", "f", "fp", "handle", "source", "parse", "l", "use", "db", "files", "user", "r", "object", "handler", "loader", "File", "buffer", " File", "feed"], "line": ["one", "letter", "data", "single", "part", "entry", "split", "cl", "row", "band", "pass", "column", "cle", "l", "string", "page", "text", "pe", "message", "style", "connection", "cell", "link", "shell", "no", "limit", "definition", "status", "error", "phase", "key", "el", "parse", "lo", "word", "lc", "cr", "LINE", "log", "frame", "sync", " Line", "rule", "str", "lin", "job", "lines", "comment", "section", "side", "user", "look", "Line", "pin", "buffer", "force", "block", "lf", "le", "se", "body", "item", "ge", "range", "strip", "nl", "inline", "home", "header", "base", "day", "name", "response"], "_qdDate": ["_sqdData", "_qndData", "_QdDat", "_sqdcDay", "_qndDat", "_sqdcTime", "_qndTime", "_qdMonth", "_qdsDate", "_qdDay", "_qndYear", "_qdsDay", "_qdsNumber", "_qdcDat", "_qdcData", "_qdcDay", "_sqdcDate", "_qndNumber", "_QdsDat", "_sqdDate", "_qdsDat", "_qdTime", "_QdMonth", "_qdsMonth", "_qdYear", "_qdDat", "_sqdNumber", "_qfData", "_qfDay", "_sqdTime", "_qdNumber", "_sqdsDate", "_sqdsNumber", "_qdData", "_QdsDate", "_qdcDate", "_qndDate", "_QdDate", "_qndMonth", "_qcdNumber", "_sqdsData", "_qcdYear", "_QdsTime", "_qdsData", "_sqdcData", "_sqdYear", "_sqdsYear", "_qdcTime", "_QdTime", "_qdcMonth", "_QdsMonth", "_qcdData", "_qdsYear", "_sqdDay", "_qfDate", "_qdsTime", "_qcdDate", "_qfTime"], "pos": ["prop", "POS", "doc", "nos", "unit", "col", "Pos", "j", "length", "axis", "offset", "n", "loc", "os", "act", "rel", "off", "ps", "pl", "mid", "port", "part", "in", "pt", "limit", "spec", "no", "all", "block", "o", "pres", "index", "sort", "pid", "end", "dev", "type", "val", "pass", "i", "pr", "pull", "push", "size", "pose", "len", "point", "min", "position", "po", "neg", "start", "sp", "next", "down", "x", " position", "p", "open", "post"], "projectNum": ["componentHash", "taskLen", " projectName", "projectLen", "componentFamily", "componentNumber", "productFamily", "projectHash", "taskNumber", "productNumber", " projectNumber", " projectFamily", " projectHash", "productNum", "componentNum", "productHash", "projectFamily", " projectLen", "projectName", "ProjectLen", "ProjectNumber", "taskNum", "ProjectNum", "projectNumber", "ProjectName", "taskName"], "value": ["values", "description", "resource", "message", "amount", "Value", "data", "version", "project", "scale", "profile", "group", "range", "price", "result", "trial", "key", "val", "type", "target", "number", "feature", "object", "v", "name", "vector", "response"]}}
{"id1": "9371421", "id2": "1141361", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"eventHash": ["messageDig", " eventKey", "bytehash", "byteDig", "messageKey", " eventDig", "byteHash", "eventDig", "byteKey", "eventhash", "eventKey", "messagehash", " eventhash", "messageHash"], "eventstr": ["errorStr", "eventdict", "Eventstr", " eventsource", "exStr", "Eventstring", "exstr", " eventStr", "errorsource", "errorstring", "Eventdict", "EventStr", " eventstring", "Eventsource", " eventdict", "eventStr", "exdict", "errorstr", "exstring", "eventstring", "eventsource"], "md": ["m", "wd", "hd", " MD", "mp", "dr", "cmd", "sha", "data", "mo", "dig", "dd", "rpm", "hash", "map", "mc", "mag", "d", "vd", "od", "ms", "meta", "key", "hm", "ng", "amd", "mg", "dm", "bd", "mb", "metadata", "cm", "MD", "di", "mn", "ad", "mac", "id", "mand", "mm", "sm", "ma", "mem", "ke", "ld", "em", "pm", "mt", "mu", "mod", "dh", "doc"], "theDigest": ["TheDigEST", " theSignester", " theSignEST", "thedigester", "theDigester", "theHashEST", "theHashester", "thedighest", "thedigEST", " theDighest", "TheDigester", "Thedigester", "theDighest", "theSignest", "theSignEST", "ThedigEST", " theSignest", "theSignester", "theHashest", "theDigEST", "thedigest", "theSignhest", " theDigEST", " theSignhest", "Thedigest", " theDigester", "TheDigest"]}}
{"id1": "7169984", "id2": "8216539", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"connRemote": ["invokeRemote", " execIP", "execURL", " execURL", "execRemote", "invokeIP", " executeRemote", " executeIP", " execRemote", "invokeLocal", " execLocal", "execLocal", "invokeURL", " executeURL", " executeLocal", "execIP"], "jsonObject": ["httpOperation", "jsonObj", "customObj", " jsonBody", " jsonString", "customObject", "httpObj", "JSONObject", "JSONArray", "jsonOb", " jsonOb", "JSONObj", "jsonBody", "javaBody", "JSONOb", "jsonOperation", "httpArray", "JSONString", "httpObject", "javaObject", "javaOb", "javaString", "JSONBody", "jsonArray", "jsonString", "customArray", "customOperation", "JSONOperation"], "OPCode": ["opName", "OpCode", "OPERCode", "opAction", "Opcode", "OPERcode", "opCode", " OPcode", " OPAction", "opcode", "OPAction", "OPERName", "OpName", "OPcode", " OPName", "OPName", "OpAction"], "retSrc": ["retOsRC", " retDsrc", "retNrc", "retOsrc", " retSrt", "retInrc", "RetAsck", "retSuc", "retAsck", "retAsrc", "retSsrc", "retPvc", "retPrc", "retInRC", "RetSRC", "retNrt", "retOsrt", " retSsrc", "RetAsrc", "retSvc", "RetSck", "retAsuc", "retSRC", "retSck", "retDuc", "RetSuc", "RetSrc", "retAsRC", "retNsrc", "RetAsRC", " retDRC", "retDRC", "retNRC", "RetAsuc", "retSrt", "retDrc", "retPRC", " retSRC", " retDrc", "retNvc", "retDrt", "retInck", "retDsrc", "retOssrc", " retSvc", " retDrt", "retDck", "retInuc", "retPsrc"], "httpClient": ["HttpClient", "httpsclient", "httpCall", "xmlCase", "httpProxy", "apiClient", "HttpProxy", " httpCase", "httpsClient", "phpclient", "HttpConnection", "phpPost", "xmlConnection", " httpConnection", "apiclient", "apiCall", "phpClient", "xmlClient", "phpCall", "httpCase", "apiPost", "httpConnection", "HttpCase", " httpProxy", "xmlProxy", "httpclient", "httpsCall", "httpsPost"], "httpPost": ["HttpCopy", "htmlPost", "autoPOST", "workpost", "httpsCopy", " httpDo", "htmlCopy", "HttpRequest", "httpsPOST", "htmlPOST", "autoCopy", "HttpPOST", "htmlDo", " httpCopy", "httpDo", "phpPOST", "phpDo", "httpsPre", "autoPost", "workDo", "phpRequest", "phpPost", "workPost", "httpRequest", "httpPOST", "HttpPre", "httppost", "httpCopy", "workPre", "httpPre", "webpost", "HttpDo", "HttpPost", " httpRequest", " httpPre", " httppost", "webDo", "webPost", "webPre", "autoPre", " httpPOST", "httpsPost"], "httpParams": ["httpVariums", "httpPams", "httpCatms", "hrPam", " httpParam", "httpArgam", "httpVariars", " httpPars", "httpPam", " httpParars", "httpPars", "httpArgms", "httpParms", "hrPms", " httpPam", "httpVariams", "hrParams", "httpPums", "httpParars", "httpArgars", "httpPeram", "httpParam", "hrParam", "httpCatars", "httpPms", " httpParums", "httpCatam", "hrParms", "httpParums", " httpPums", "httpPerams", "httpCatams", "httpPerums", "httpArgams", "hrPars", "httpVariam", "hrParars", "hrPams", "httpPerars", " httpPams"], "nameValuePair": ["nameValueLolder", "nameNamepiece", "nameValueFiece", "nameNameLair", "nameValuepatch", "nameValueFair", "nameVCair", "nameNamePatch", "nameNamePortion", "nameValuePeratch", "nameNameProtenter", "nameValuepolder", "nameValueProtenter", "nameValueCait", "nameVPpair", "nameNamePore", "nameValueParait", "nameValuePointenter", "nameValueProtair", "nameValueCpair", "nameNameLatch", "nameValueppair", "nameValuepiece", "nameValueParair", "nameValuePhortion", "nameValueParpair", "nameNamePpair", "nameValuePerolder", "nameValuePhiece", "nameValueSpair", "nameValueSair", "nameValueSore", "nameNameportion", "nameValuePointpair", "nameValuePointair", "nameNameProtore", "nameValuePpair", "nameVPair", "nameNameProtpair", "nameValuePore", "nameValueProtore", "nameValuePiece", "nameNamepair", "nameNamePiece", "nameNamePolder", "nameValuePait", "nameValuePhair", "nameVPait", "nameValueProtpair", "nameValuePolder", "nameValueCair", "nameValueLair", "nameValuePatch", "nameNamePenter", "nameValuepait", "nameValuePenter", "nameValueportion", "nameValuePortion", "nameVCpair", "nameValuePointore", "nameNameLolder", "nameNameProtair", "nameValuePerair", "nameValueSenter", "nameVCait", "nameValueFortion", "nameValueLatch", "nameNamePair", "nameValuepair"], "response": ["wave", "resp", " Response", "page", "res", "respond", "resource", "e", "message", "server", "view", "body", "Response", "connection", "method", "data", "session", "channel", "output", "application", "f", "status", "result", "site", "jet", "block", "reply", "i", "api", "tree", "object", "v", "success", "entity", "full", "environment", "json", "throw", "http", "feed", "request"]}}
{"id1": "21308543", "id2": "823074", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyContent", "transferContent", " copyStream", " copyFiles", " copiedContent", " copiedFile", "copyFiles", " copiedStream", " copyContent", " copiedFiles", "copyStream", "transferStream", "transferFiles", "transferFile"], "src": ["ls", "js", "url", "uri", "resource", "image", "core", "server", "dest", "loc", "remote", "rc", "rs", "sci", "project", "this", "inst", "input", "rb", "attr", "href", "inf", "download", "code", "sin", "source", "media", "ruby", "stream", "filename", "slice", "sc", "sit", "string", "ource", "upload", "sel", "path", "scene", "http", "img", "feat"], "target": ["prot", "to", "text", "writer", "url", "resource", "large", "parent", "dest", "master", "rel", "loc", "remote", "project", "port", "external", "tx", "output", "it", "result", "effect", "nt", "eth", "out", "type", "temp", "source", "top", "Target", "base", "object", "arget", "name", "reference", "arg", "next", "goal", "path", "content", "fat", "secure", "director", "compatible"], "ic": ["ct", "iac", "ico", "cit", "loc", "rc", "nic", "ick", "aic", "sci", "io", "ics", "acl", "mic", "inc", "bc", "ec", "it", "pic", "mc", "isc", "cl", "ci", "cc", "ici", "cin", "irc", "i", "ip", "aci", "ib", "xc", "ac", "pc", "cci", "c", "exec", "fc", "ix", "vc", "ai", "lc", "IC", "icc", "voc", "enc", "ik"], "oc": ["ocol", "bb", "roc", "uc", "loc", "acs", "rc", "nic", "io", "org", "arc", "mic", "bc", "ec", "anc", "output", "soc", "pic", "iv", "mc", "o", "ace", "isc", "ci", "cc", "alloc", "aco", "irc", "AC", "oci", "oca", "co", "toc", "xc", "sc", "ac", "pc", "exec", "c", "abc", "ocr", "other", "fc", "vc", "voc", "cs", "enc", "OC"]}}
{"id1": "15516136", "id2": "949327", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPELMedia", "loadBufferedJPPGMedia", "loadBufferedMPEGMedia", "loadBufferedJPELimage", "loadBufferedMPPGImage", "loadBufferedMPPGimage", "loadBufferedMPEGimage", "loadBufferedJPEGFile", "loadBufferedMPPGFile", "loadBufferedMPPGMedia", "loadBufferedMPEGFile", "loadBufferedJPEGimage", "loadBufferedJPELImage", "loadBufferedJPEGMedia", "loadBufferedJPNGFile", "loadBufferedJPPGimage", "loadBufferedMPEGImage", "loadBufferedJPNGMedia", "loadBufferedJPNGimage", "loadBufferedJPELFile", "loadBufferedJPNGImage", "loadBufferedJPPGImage", "loadBufferedJPPGFile"], "url": ["ur", "page", "log", "uri", "ssl", "resource", "server", "ll", "large", "play", "style", "connection", "loc", "remote", "data", "link", "mount", "blog", "f", "rule", "www", "URL", "coll", "ref", "job", "href", "el", "download", "xml", "dl", "source", "pull", "src", "config", "media", "filename", "stream", "l", "base", "alt", "object", "id", "address", "email", "string", "gl", "found", "file", "loader", "name", "service", "sl", "host", "layer", "path", "Url", "location", "buffer", "http", "feed", "bb"], "image": ["default", "large", "parent", "view", "data", "icon", "shadow", "issue", "gallery", "feature", "cache", "file", "pm", "ini", "ui", "img", "available", "m", "page", "jpg", "photo", "message", "resource", "connection", "info", "model", "Image", "result", "zip", "error", "xml", "element", "i", "config", "object", "video", "hole", "show", "upload", "age", "layer", "eye", "game", "database", "build", "pixel", "thin", "site", "archive", "job", "out", "instance", "api", "ami", "size", "im", "gif", "up", "pin", "cover", "picture", "value", "manager", "copy", "output", "figure", "f", "audio", "document", "container", "source", "cm", "media", "work", "inner", "slice", "position", "bug", "auto", "p"], "in": ["fd", "m", "ex", "ins", "ssl", "In", "b", "ax", "n", "init", "fb", "data", "socket", "inc", "part", "f", "gin", "impl", "input", "din", "IN", "inn", "inas", "container", "out", "el", "pass", "conn", "xml", "cin", "is", "i", "source", "win", "reader", "rin", "kin", "inside", "a", "l", "stream", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "con", "c", "err", "file", "pin", "cf", "ini", "or", "again", "serv", "doc", "isin"], "decoder": ["encoder", "decode", "Decode", "Decoding", "recenter", "Decoder", "decoding", " decoding", "deoder", "deenter", " decoded", "deode", "recoder", "Decoded", "encode", "deoding", "Decenter", "decoded", "encoded", "encoding", "recode", "decenter", "recoding", " decode"]}}
{"id1": "9449064", "id2": "14758866", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"readExp": ["readExt", "loadEXP", " readEx", "writeExt", "writeExpl", " readExt", "ReadExp", "writeexp", "Readexp", "writeEx", "loadEx", "readExpl", "loadExpl", "readEXP", "loadExt", "readexp", "loadexp", " readExpl", " readEXP", " readexp", "ReadExpl", "loadExp", "ReadEXP", "readEx"], "writeExp": ["writingExp", "readExt", "WriteExp", "writeCom", "WriteExt", "WriteExpl", " writeEx", "writeExt", " writeExt", "writeExpl", "writeexp", "WriteCom", "WriteEx", "writeEx", "writingCom", "readExpl", " writeexp", "Writeexp", "readexp", "writingexp", " writeExpl", "writingEx", "readEx", " writeCom"], "expFile": ["xpDir", " expPlace", "expLine", "ExpSourceFile", "expFiles", "ExpString", "EXPFile", " expFiles", "Expfile", "xpFiles", " experimentFiles", " experimentPlace", "expPlace", "expressLine", "EXPLine", "xpLine", " expDir", "expressSourceFile", "ExpLine", "expDir", "xpString", "ExpDir", "expressfile", " experimentFile", "expfile", "ExpFile", "EXPfile", " expLine", "EXPDir", " expSourceFile", "xpFile", "xpPlace", "expSourceFile", "ExpPlace", "expString", "EXPSourceFile", "xpfile", " experimentLine", "EXPString", "expressPlace", "expressDir", "expressFile", "EXPPlace"], "exp": ["imp", "expr", "rep", "example", "scope", "act", "pl", "form", "project", "serv", "expl", "nz", "model", "f", "inst", "zip", " expand", "spec", "str", "acc", "dj", "test", " expansion", "inf", "ng", "i", "pr", "push", "xp", "asm", "sc", "div", " experiment", "obj", "app", "express", "host", "vec", "prov", "query", "ef", " exam", "x", "jp", "lc", " expanded", "fe", "iz", "plus", "EXP", "p", "ext", "feat", "Exp"], "fi": ["ifa", "sf", "isi", "ffe", "wi", "sci", "fb", "Fi", "info", "si", "osi", "py", "ni", "flo", "fa", "lli", "ci", "ji", "ani", "abi", "i", "li", "ifi", "eni", "xi", "pi", "yi", "FI", "fc", "fy", "zi", "cf", "ini", "ii", "bi", "afi", "fe", "fp", "qi"], "oi": ["oa", "isi", "uci", "ki", "ori", "io", "ski", "shi", "si", "osi", "ahi", "ofi", "avi", "ni", "obi", "ogi", "flo", "asi", "lli", "ci", "oni", "ji", "ani", "abi", "i", "oci", "li", "di", "agi", "eni", "eu", "omi", "ti", "cci", "ilo", "odi", "obb", "ai", "ini", "ii", "ui", "bi", "eye", "oxy", "ois", "oid", "qi", "edi"], "jf": ["jb", "ujfp", "jfs", "jjcf", "pp", "uje", "ujfs", "djf", "pfr", "jarp", "Jfe", "Jfx", "Jf", "xf", "xcf", "JF", "appcf", "djfx", "je", "jtf", "djcf", "jpF", "jpcf", "jpf", "jjf", "Jcf", " jcf", "jjfx", "ujf", " jfs", "pb", "jfm", "appfx", "appf", " je", "jcf", "jF", " jfp", "xtf", "jfr", "pf", "jjfm", " jfr", " jfx", "ff", "jarfr", "jpfx", " jfm", "jarf", "jfx", "zf", " jtf", "zfp", "appfe", "Jb", "ffs", " jp", "jfp", "xfp", "ztf", " jF", "jp", " jb", "jfe", "ffp", "fe", "zcf", "jpb", "djfm", "jarb", " jfe"], "sp": ["osp", "imp", "page", "bsp", "js", "spe", "sf", "se", "vp", "scope", "mp", "cp", "ss", "html", "ps", "sv", "pl", "sci", "esp", "bp", "si", "sb", "fp", "py", "spec", "inst", "so", "str", "ch", "s", "pr", "wp", "Sp", "sc", "SP", "amp", "ap", "sm", "sup", "app", "service", "sl", "ctx", "sk", "cf", "gp", "sh", "op", "jp", "fe", "pp", "ep", "sw", "p", "tp", "space", "serv"], "e": ["pe", "ee", "ev", "se", "en", "ce", "event", "ie", "ec", "es", "ent", "ae", "el", "et", "v", "t", "w", "ctx", "Event", "x", "ef", "events", "fe", "exc", "ep", "ception", "ext"], "fo": ["ato", "wo", "FO", "oooo", "ico", "os", "io", "info", "ooo", "mo", "tto", "ph", "osa", " lo", "py", "f", "so", "flo", "fa", "o", "olo", "ko", "bo", "ao", "jo", "vo", "ho", "co", "zo", "foo", "po", "obj", "la", "lo", "fe", "obo", "yo"], "oo": ["wo", "oooo", "FO", "que", "oa", "va", "ico", "ollo", "os", "io", "loo", "ooo", "mo", "osa", "oe", "so", "flo", "o", "oto", "cro", "ox", "olo", "ko", "bo", "ao", "bean", "aco", "argo", "obe", "oh", "qa", "co", "foo", "oos", "po", "elo", "ilo", "oda", "la", "ou", "lo", "obo", "oid", "OO", "goo"], "ex": ["exit", "js", "res", "ct", "se", "null", "ax", "except", "act", "lex", "event", " exc", "Ex", "six", " Ex", "expl", "nex", "inc", "tx", "es", "fail", "su", "error", "cl", "ignore", "class", "Exception", "pex", "Exc", "sex", "ass", "con", "err", "obj", "ic", "aux", "re", "def", "ix", "used", "x", "EX", "tex", "rex", "exc", "ception", "ext", "com"]}}
{"id1": "16550855", "id2": "1357662", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"readPage": ["readFile", "getPages", "openFile", "readpage", "readPages", "getpage", "getFile", "findPage", "findPages", "openPages", "findpage", "openPage", "findFile", "getPage", "openpage"], "ignoreComments": ["orecomments", " ignoreQuotes", "includeComments", " ignoreTags", "includeComment", " ignoreComment", "includeTags", "useQuotes", "useComments", "oreQuotes", "useTags", "oreTags", "ignoreQuotes", "usecomments", "includecomments", "ignoreComment", " ignorecomments", "oreComments", "ignoreTags", "oreComment", "ignorecomments"], "in": ["into", "rec", "m", "ins", "url", "ssl", "e", "image", "In", "b", "connection", "init", "data", "version", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "inn", "lin", "index", "h", "out", "s", "i", "kin", "win", "source", "reader", "is", "client", "inside", "nin", "stream", "login", "inner", "user", "min", "r", "id", "token", "bin", "c", "err", "con", "file", "loader", "re", "t", "ini", "as", "buffer", "again", "http", "on", "isin"], "inputLine": ["rawText", "installLook", "ifLook", "requestCo", "inputPage", "Inputline", "inputText", "InputCell", "requestLink", "pullRow", " inputRow", "ifline", "pullLink", "inputCo", "requestLook", "incLook", " inputCell", "requestRow", "inputL", "pullline", "imageLine", "InputLine", "InputName", "InputPage", "rawL", "inputRow", "ifCo", "rawName", "incLine", "commentLine", " inputLink", "commentline", "installL", " inputline", "installLine", "requestline", " inputLook", "imageline", "installline", "imageLook", "pullLine", "ifLine", "inputCell", "commentCell", "imageL", "InputLink", "inputLook", "inputName", " inputText", "InputText", "inputLink", "InputLook", "InputL", "rawline", " inputName", "rawLink", "commentPage", " inputCo", "incline", "rawLine", "inputline", " inputPage", "requestLine", " inputL", "incL"], "html": ["css", "high", "page", "text", "bsp", "rss", "js", "url", "message", "plain", "details", "view", "body", "summary", "links", "flat", "data", "htm", "msg", "link", "strong", "blog", "title", "part", "output", "ht", "wrap", "f", "result", "www", "tt", "str", "template", "attr", "h", "tf", "live", "home", "inline", "bf", "xml", "temp", "source", "api", "article", "war", "atom", "header", "flash", "web", "gh", "dump", "base", "HTML", "show", "hard", "amp", "hot", "detail", "tml", "embed", "json", "ui", "content", "format", "http", "doc", "img"]}}
{"id1": "6890417", "id2": "16931472", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"a1": ["alpha2", "an1", "A2", "an2", "A3", "a0", " a0", "an01", "alpha01", "an3", "ga1", "alpha0", "ga2", "a01", "ga01", "A01", "ga0", "A1", "alpha1", " a01"], "a2": ["n8", "n2", "A2", "A5", "n5", "n4", "A4", "p5", "p1", "p2", "A8", "p4", "A1"], "a3": ["a23", "an33", " a33", "alpha2", "a33", "an23", "alpha5", "ga3", "ga5", " a23", "alpha3", "an3", "ga2", "alpha9", "la3", "la33", "ga9", "la23"], "a4": ["A2", "as9", "ga8", "A5", "pa8", "pa4", "pa10", "A4", "ma10", "ma8", "as2", "ga4", "ma4", "ga10", "as5", "A9", "as4"], "a5": ["n2", " a6", "a6", "p7", "alpha8", "alpha6", "A5", "a7", "alpha5", "n5", "alpha4", "n6", "A4", "p5", "p2", "A8", "n7", "p6", "A6", " a7"], "a8": ["alpha11", " a6", "an7", "a6", "an6", "alpha8", "alpha6", "b4", "a7", "an8", "alpha4", "b7", "A11", "A4", "an10", "b11", "b6", "b10", "A8", "A6", " a7", "b8"], "a9": ["alpha10", "alpha11", "p10", "p7", "alpha8", "a7", "alpha7", "a09", "p09", "A11", " a09", "A7", "alpha9", "A8", "A9", " a7", "p9", "alpha09"], "a10": ["alpha10", "as8", "as9", "as09", "alpha8", "a12", "an8", "A10", "a09", "an12", "b09", "as10", "A09", "an10", "alpha9", "an9", "b10", "A8", "alpha12", "A9", " a12", "b9", "b8"], "a11": ["alpha11", "am7", "alpha8", "a12", "a7", "A10", "alpha18", "A18", "am10", "a18", "a13", "A11", "am13", " a18", " a13", "A7", "A8", "alpha12", "am11", " a7", "A12", " a12", "A13"], "ps": ["ls", "ppa", "proxy", "pe", "pes", "js", "res", "ins", "gets", "details", "als", "ss", "points", "ipes", "rs", "os", "ases", "PS", "ns", "parts", "aps", "cases", "pos", "pse", "py", "es", "vs", "pa", "pres", "lines", "ips", "settings", "s", "ms", "pass", "alls", "posts", "Ps", "pr", "ws", "is", "hes", "properties", "qs", "pps", "pi", "ports", "ras", "eps", "files", "ils", "params", "ams", "tests", "ops", "ts", "rules", "per", "ons", "as", "gs", "jp", "ples", "cs", "ups", "pers", "pp", "p", "ks", "ds", "changes"], "url": ["ls", "proxy", "page", "log", "fl", "uri", "ssl", "ll", "image", "server", "build", "connection", "cloud", "f", "document", "www", "URL", "download", "config", "client", "contact", "l", "web", "base", "user", "control", "object", "address", "string", "gl", "file", "service", "sl", "bug", "Url", "response", "buffer", "twitter", "http", "browser"], "request": ["pe", "req", "p", "respond", "resource", "report", "server", "call", "complete", "connection", "remote", "method", "info", "this", "child", "session", "hello", "external", "result", "connect", "reply", "Request", "rest", "temp", "pull", "create", "builder", "access", "push", "client", "web", "worker", "user", "r", "upload", "re", "per", "next", "response", "transfer", "buffer", "http", "use", "open", "post", "rate"]}}
{"id1": "21754659", "id2": "11952735", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSenico", "getbuttonSenido", "getButtonJonendo", "getButtonSonico", "getbuttonSenendo", "getButtonJonira", "getButtonSenira", "getButtonSenendo", "getbuttonSonira", "getButtonJonico", "getButtonSonendo", "getButtonJonido", "getButtonSonira", "getbuttonSenira", "getButtonSenido", "getButtonSenico", "getbuttonSonendo", "getbuttonSonico", "getbuttonSonido"], "buttonSonido": ["buttonDonardo", "btnSonido", "btnSonado", "buttonSenado", "buttonSonigo", "buttonTanardo", "buttonTanado", "buttonHomardo", "buttonHonido", "buttonsonido", " buttonSenida", "btnDonigo", "buttonsonigo", " buttonSonida", "btnDonado", " buttonSonado", "ButtonSonado", "btnDonardo", "buttonSenigo", "buttonDonini", "buttonTanido", "buttonHonino", "btnDonido", "buttonHomado", "buttonHonardo", "buttonsonado", "ButtonDonido", "buttonSonado", "buttonDonino", "ButtonSonido", " buttonSenado", "buttonSonardo", "btnSonigo", "buttonDonida", "buttonHomida", "buttonSonino", "buttonDonado", "buttonHomido", "ButtonDonida", "buttonSenido", "buttonSenardo", "buttonSenida", "btnSonini", " buttonSonino", "ButtonDonado", "ButtonSonardo", "buttonsonardo", "buttonSenino", "buttonDonigo", "buttonSonini", " buttonSenido", "buttonDonido", " buttonSenardo", "ButtonDonini", " buttonSenino", "buttonHonado", "buttonTanida", "ButtonSonida", "buttonsonini", "buttonSonida", "buttonSenini", "ButtonDonardo", "btnSonardo", " buttonSonardo", "ButtonSonini"], "e": [" inst", " cause", "ee", " te", "event", " exc", " ace", " exception", " events", " je", " ate", " pe", " ie", " ignored", " fe", " Event", " ev", " en", "E", " invoked", " caught", "t", "Event", " exp", "ed", " other", " E"], "fc": ["fd", "FS", "fn", "fl", "fr", "ct", "lf", "CF", " FC", "FE", "wt", "roc", "fi", "fed", "xf", "tc", "il", "fb", "bc", "ec", "LC", "f", "GF", "WF", "wic", "fm", "flo", "PF", "mc", "fa", "Factory", "isc", "nc", "fs", "bf", "irc", "FC", "fx", "fw", "xc", "DC", "WC", "pc", "con", "c", "dc", "af", "cf", "wk", "F", "lc", "fe", "enc", "fp"], "returnVal": ["returnval", "continueValue", "backval", "ReturnNum", " returnNum", "continueval", " returnVAL", "continueVal", "backValue", "returnValue", "continueNum", "backVAL", "returnVAL", "ReturnValue", "Returnval", "ReturnVal", " returnval", "returnNum", "backVal", "ReturnVAL", " returnValue"], "file": ["to", "page", "log", "FILE", "url", "resource", "ile", "image", "sf", "uri", "b", "message", "connection", "up", "lock", "io", "info", "data", "single", "socket", "part", "folder", "f", "document", "zip", "input", "feed", "out", "type", "class", "source", "dir", "directory", "filename", "l", "use", "db", "files", "base", "user", "object", "local", "handler", "name", "binary", "global", "full", "File", "per", "php", "cf", "path", "get", "function", "fe", "http", "fp", "lib"], "rutaGlobal": ["rundaGeneral", "rutaGeneral", " rutoInternational", " rutaGeneral", "rutiLocal", " rutoGlobal", "rutaCore", "srettaLocal", "rundaInternational", "rettaLocal", "srettaGlobal", "srutaReal", "rutoLocal", "rutiInternational", "rutaLocal", "rettaInternational", " rutoGeneral", "rettaReal", "rutiGeneral", "rucaGlobal", "srutaInternational", "srettaInternational", "rottaLocal", "rutoCore", "srutaGeneral", "srutaLocal", "rucaInternational", "srutaGlobal", "rutoInternational", "rottaGlobal", "rettaGlobal", "rutiGlobal", "rottaCore", "srottaGlobal", "srottaCore", "rutoGeneral", "rottaGeneral", "srettaReal", " rutaInternational", "rugaLocal", "srottaGeneral", "rundaGlobal", "rugaGlobal", "srottaLocal", "rutaReal", "rutoGlobal", "rutaInternational", "rugaReal", "rucaGeneral", "rutiReal", "srutaCore", "rugaInternational", "rutiCore"], "rutaRelativa": ["rutaRelativ", "rutaRelarativism", "rutaRelarivism", "rutaRelarivas", "rutaMalarivo", "rutaRelattivo", "rutaRelattivism", "rutaRelativas", "rutaRelattiv", "rutaRelariva", "rutaRelATiv", "rutaRelarivo", "rutaMalativas", "rutaRelarativa", "rutaRelATivas", "rutaMalativa", "rutaRelativism", "rutaMalariva", "rutaRelarativas", "rutaRelATivo", "rutaRelattivas", "rutaRelateiva", "rutaMalativo", "rutaRelariv", "rutaRelateivo", "rutaRelATiva", "rutaRelateivism", "rutaRelarativ", "rutaRelarativo", "rutaMalativism", "rutaRelateiv", "rutaRelattiva", "rutaMalarivism", "rutaRelativo", "rutaMalarivas"], "fis": [" fir", "Fis", "xris", "FIs", "fir", " fiss", "friss", "xis", " fys", "Fos", "Fris", "fris", "Fir", "Fiss", " fris", "fys", "fIs", "fiss", "xys", "vis", "Fys", "xiss", "vos", "viss", "frir", "vIs", "fros", " fIs"], "fos": ["fo", "fileocks", "tfops", "fOS", "Fops", "Fos", "infos", "Fo", "fileo", "fileos", " fops", " fOS", "infOS", " fo", "fios", "focks", "tfos", "fileops", " focks", "Fios", "infios", "fops", "infis", "tfOS", "FOS", " fios", "Focks", "Fis", "tfo"], "canalFuente": ["canalFiencer", "canalKuente", "canalFuent", "canalKuenza", "canalFiente", "canalBuente", "canalFuante", "canalBuenza", "canalfuenza", "canulFuencer", "canallFuenza", "canallBuence", "canalFience", "canalsFuent", "canalfuente", "canulFient", "canalFuento", "canalBugent", "canalfugent", "canallBuenza", "canalsFuento", "canallBugent", "canalJuento", "canalKugent", "canalsFuante", "canalsFuente", "canalBuent", "canalsBuent", "canallFuente", "canalFUento", "canulFience", "canallBuente", "canalFient", "canalFUante", "canalBuence", "canulFiente", "canalsBuante", "canalKuence", "canalsBuento", "canalJuante", "canalFUent", "canallFuence", "canalBuento", "canalJuente", "canalJuencer", "canalsBuente", "canalFuence", "canalFuenza", "canalJuence", "canalBuante", "canalMuencer", "canalMuent", "canulFuent", "canulFuente", "canalFuencer", "canalFugent", "canalMuente", "canalMuence", "canulFiencer", "canalfuence", "canalFUente", "canallFugent", "canulFuence", "canalJuent"], "canalDestino": ["canaldestination", "canelCampino", "canalDestinos", "canalCampination", "canalldestino", "canalDestination", "canallDestino", "canaldestino", "canallDestinos", "canelDestination", "canalCampania", "canelDestina", "canelDestania", "canelDestino", "canalldestina", "canalNegania", "canalNegino", "canalCampino", "canalNegina", "canalldestania", "canallDestania", "canelCampination", "canaldestinos", "canalCampina", "canelCampina", "canalldestinos", "canalDestina", "canelCampania", "canaldestina", "canalNegination", "canalDestania", "canaldestania", "canallDestina", "canalCampinos"]}}
{"id1": "15516136", "id2": "4895903", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPELMedia", "loadBufferedJPPGMedia", "loadBufferedMPEGMedia", "loadBufferedJPELimage", "loadBufferedMPPGImage", "loadBufferedMPPGimage", "loadBufferedMPEGimage", "loadBufferedJPEGFile", "loadBufferedMPPGFile", "loadBufferedMPPGMedia", "loadBufferedMPEGFile", "loadBufferedJPEGimage", "loadBufferedJPELImage", "loadBufferedJPEGMedia", "loadBufferedJPNGFile", "loadBufferedJPPGimage", "loadBufferedMPEGImage", "loadBufferedJPNGMedia", "loadBufferedJPNGimage", "loadBufferedJPELFile", "loadBufferedJPNGImage", "loadBufferedJPPGImage", "loadBufferedJPPGFile"], "url": ["ur", "page", "log", "uri", "ssl", "resource", "server", "ll", "large", "play", "style", "connection", "loc", "remote", "data", "link", "mount", "blog", "f", "rule", "www", "URL", "coll", "ref", "job", "href", "el", "download", "xml", "dl", "source", "pull", "src", "config", "media", "filename", "stream", "l", "base", "alt", "object", "id", "address", "email", "string", "gl", "found", "file", "loader", "name", "service", "sl", "host", "layer", "path", "Url", "location", "buffer", "http", "feed", "bb"], "image": ["default", "large", "parent", "view", "data", "icon", "shadow", "issue", "gallery", "feature", "cache", "file", "pm", "ini", "ui", "img", "available", "m", "page", "jpg", "photo", "message", "resource", "connection", "info", "model", "Image", "result", "zip", "error", "xml", "element", "i", "config", "object", "video", "hole", "show", "upload", "age", "layer", "eye", "game", "database", "build", "pixel", "thin", "site", "archive", "job", "out", "instance", "api", "ami", "size", "im", "gif", "up", "pin", "cover", "picture", "value", "manager", "copy", "output", "figure", "f", "audio", "document", "container", "source", "cm", "media", "work", "inner", "slice", "position", "bug", "auto", "p"], "in": ["fd", "m", "ex", "ins", "ssl", "In", "b", "ax", "n", "init", "fb", "data", "socket", "inc", "part", "f", "gin", "impl", "input", "din", "IN", "inn", "inas", "container", "out", "el", "pass", "conn", "xml", "cin", "is", "i", "source", "win", "reader", "rin", "kin", "inside", "a", "l", "stream", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "con", "c", "err", "file", "pin", "cf", "ini", "or", "again", "serv", "doc", "isin"], "decoder": ["encoder", "decode", "Decode", "Decoding", "recenter", "Decoder", "decoding", " decoding", "deoder", "deenter", " decoded", "deode", "recoder", "Decoded", "encode", "deoding", "Decenter", "decoded", "encoded", "encoding", "recode", "decenter", "recoding", " decode"]}}
{"id1": "189963", "id2": "4629990", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readandrewrites", "readandrewrite", "readAndRebrites", "readandRewrite", "readAndRebrite", "readAndrewrite", "readandRewwrite", "readAndRewrap", "readAndSwrites", "readAndSwwrite", "readAndrewwrite", "readandrewwrite", "readAndRebwrite", "readAndRewrites", "readAndSwrite", "readAndrewrap", "readandRewrap", "readAndrewrites", "readAndRebrap", "readandrewrap", "readAndSwrap", "readandRewrites", "readAndRewwrite"], "inFile": ["InFile", "infile", "oldFile", " inFiles", "inFilename", "oldFiles", "inputFile", " inFilename", " inSourceFile", "outFiles", "loginFiles", "loginfile", "loginFilename", "outfile", "Infile", "inputFilename", "outFilename", "oldfile", "outSourceFile", "InFiles", "oldFilename", "InSourceFile", "inputfile", "loginFile", "inputFiles", "inFiles", "inSourceFile", " infile"], "outFile": ["outFILE", " outfile", "processPlace", " outDir", "thisFilename", "exFILE", "outputPlace", "offFilename", "newfile", "processFilename", "outDir", "thisFILE", "exFilename", "exFile", "newStream", "thisFile", "outputFile", "offFILE", "outStream", "outfile", "outputFILE", " outStream", "outFilename", "offPlace", "thisfile", "newFile", "OutDir", "offFile", "Outfile", "newDir", "processFile", "OutStream", "outputFilename", "OutFile", "processFILE", "outPlace", "outputfile", "exfile"], "iis": ["ciiss", "IIS", "Iis", "iniris", " iais", " iiss", "iniiss", "iais", "ciais", "ciris", "ciIS", "Iiss", " iIS", "iiIs", " iIs", "iiiss", "iiis", "iris", "iiris", "iiIS", " iris", "iIS", "iniIS", "iniIs", "ciIs", "ciis", "iiss", "iniis", "iIs", "Iais"], "dcmParser": ["DcmInstallation", " dcmReader", "dpmPlugin", "dcmPolicy", "dkmHelper", "dbmParser", "dmcarser", "dmissionParser", " dcmparser", "dmoduleParser", "dhemParser", "dcmPlugin", " dcmLoader", "fpmParser", " dcmPolicy", " dcmHelper", "dpmInstallation", " dpmJar", "dcrPlugin", " dcmLanguage", "dCMparser", "dcmLoader", "dcmReader", "dcrParser", "dmissionReader", "dmcParser", "dkmParser", " dcrParser", "dcmparser", "dhemInstallation", "dkmPlugin", " dpmLanguage", "dmmparser", "dmParser", "dpmHandler", "dmissionPlugin", "dcmPar", "dCMReader", "dmoduleJar", "dcrLoader", "dcrJar", "dmmParser", "dbmPolicy", "dmodulePlugin", "dmReader", "dhemJar", " dcrReader", " dpmPar", " dpmPlugin", "fcmHandler", " dcrLoader", "fpmHandler", "dpmarser", "dmLoader", "dpmPolicy", "dbmHelper", "dcrarser", "dpmparser", "dbmPlugin", "dpmLanguage", "fcmReader", "fpmReader", "dcmarser", " dpmparser", " dcmPar", "dmPlugin", " dpmHelper", "dcmHelper", " dpmPolicy", "dmissionLanguage", "dcrPar", "dpmReader", "dCMHandler", "fpmparser", " dpmReader", " dpmarser", "DcmParser", "dpmParser", "dpmPar", "dkmPolicy", "dcmInstallation", "fcmParser", "DcmJar", " dcmJar", "dCMLoader", "fcmparser", "dmmPlugin", "dpmLoader", "dhemReader", "dmoduleReader", "dpmJar", "dCMParser", "dCMPlugin", "DcmReader", "dmcPar", "dmmLoader", "dpmHelper", "dmcJar", " dcmarser", "dcmHandler", " dpmLoader", " dcrPlugin", " dcmPlugin", "dmoduleparser", "dcrReader", "dcmLanguage", "dcmJar", " dpmParser"], "ds": ["ks", "ls", "Db", "ros", "js", "des", "ads", "DS", "ins", "details", "ss", "dr", "cdn", "df", "ps", "rs", "points", "os", "data", "ns", "parts", "sys", "session", "uds", "sync", "dd", "tx", "gd", "vs", "Ds", "amps", "d", "dat", "asi", "ys", "s", "conn", "ws", "is", "drivers", "tes", "src", "pd", "vals", "di", "qs", "db", "Os", "ras", "da", "eps", "ils", "iss", "dds", "icks", "dc", "xs", "ld", "ts", "ays", "nas", "gs", "cs", "utils", "services", "bs", "ants", "dt"], "pdReader": ["ddLoader", "pdLoader", "dsLoader", "pcLoader", "hdStream", "hdLoader", "pcReader", "hdRead", "ddReader", "hdReader", "dsWriter", "hdWriter", "dsreader", "pbRunner", "xdReader", "hdreader", "pdreader", "dsReader", "dsRead", "pdRunner", "pcRead", "ddRunner", "hdRunner", "pbReader", "pdStream", "pcWriter", "pbLoader", "xdRead", "pdRead", "xdWriter", "ddStream", "pbStream", "xdreader"], "out": ["ex", "writer", "default", "flow", "image", "parent", "null", "term", "data", "part", "in", "her", "exp", "o", "password", "conn", "pass", "temp", "cli", "outs", "over", "cache", "exec", "file", "err", "list", "net", "lib", "img", "page", "connection", "dot", "inc", "group", "model", "result", "key", "code", "builder", "point", "object", "w", "down", "layer", "word", "oder", "to", "gen", "url", "io", "outer", "store", "later", "sys", "sync", "Out", "dev", "s", "co", "login", "db", "user", "obj", "up", "device", "order", "diff", "again", "manager", "director", "at", "array", "ssl", "write", "copy", "lock", "child", "session", "external", "output", " in", "with", "client", "inner", "base", "name", "full", "OUT", "auto", "as", "line", "doc", "ext"], "dcmEncParam": ["dcmDecParam", "dcmEstPar", "dcmDecPart", "dcmEnType", "dcmElParameter", "dcmSecParam", "dcmEstParam", "dcmDecPar", "dcmElPar", "dcmDecParameter", "dcmArchParam", "dcmSecPart", "dcmEnParameter", "dcmEncArg", "dcmArchParameter", "dcmEncType", "dcmEnArg", "dcmEstType", "dcmSecType", "dcmEnPar", "dcmEncParameter", "dcmSecPar", "dcmArchArg", "dcmElParam", "dcmEstParameter", "dcmEncPart", "dcmElType", "dcmDecType", "dcmDecArg", "dcmEncPar", "dcmEnPart", "dcmEnParam"], "pdWriter": ["htWriter", "ddReader", "dsOutput", "hdWrite", "hdReader", "hdOutput", "htWriting", "pdWrite", "dsWriter", "ddWrite", "hdWriter", "dsReader", "dsWrite", "PDWriter", "dpWriter", "dpWriting", "PDReader", "PDWrite", "dpReader", "pdWriting", "ddWriter", "pdOutput", "ddOutput", "dpWrite", "htWrite", "htReader", "PDWriting"]}}
{"id1": "12146394", "id2": "21152728", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["md4Hash", "md6crypt", "md6Hash", "md5Key", "md6Crypt", "MD2crypt", "md5Hash", "MD2Key", "MD5crypt", "md2crypt", "md2Crypt", "MD5Crypt", "md2Key", "MD2Crypt", "MD5Hash", "md6Key", "md4Crypt", "md5crypt", "md4crypt", "md4Key", "MD5Key", "md2Hash", "MD2Hash"], "key": ["k", "ee", "image", "core", "parent", "scope", "Key", "blow", "data", "phrase", "year", "password", "date", "row", "temp", "y", "self", "kw", "sign", "cache", "token", "string", "wire", "list", "root", "magic", "cy", "secret", "char", "m", "text", "power", "message", "server", "call", "connection", "here", "empty", "version", "this", "no", "zip", "input", "hash", "type", "code", "element", "pair", "point", "x", "word", "KEY", "air", "length", "none", "material", "carry", "sync", "rule", "ch", "proof", "time", "trust", "size", "seed", "user", "any", "my", "id", "fee", "order", "transfer", "value", "shift", "use", "req", "ssl", "kid", "cert", "money", "ask", "copy", "lock", "ce", "cer", "cookie", "ace", "go", "source", "kh", "ip", "number", "base", "ke", "name", "other", "service", "full", "state"], "salt": ["southalt", "sol", "Sal", "ssol", "southodium", "svALT", "ssalt", " sart", " skey", " sol", "sart", "osul", "asALT", "asalt", "sessecret", "sesul", "sass", "ssecret", "seskey", "sift", "sul", "asal", " sALT", "ssALT", "SALT", " sodium", "skey", "sesort", "sesalt", "sesALT", "Ssecret", "sort", "southart", "sal", "southALT", "sesal", "southift", "osift", "Salt", "sesol", "sALT", "svort", "Sodium", "sesass", "osalt", "svalt", "assecret", "sesift", "osALT", "sesart", " ssecret", "southsecret", "sodium", "sval", " sift", "ssass", " sass"], "_md": ["\u00a0md", " _dm", "copydm", "\u00a0m", "Newmd", "__dm", "_key", "copycmd", "\u00a0mand", "Newamd", "\u00a0nm", "localmd", "__amd", "_db", " _key", "copymd", "Newcmd", "__cmd", "localmg", "\u00a0mode", "localcmd", "\u00a0cmd", "_mand", " _amd", "_m", "_MD", " _cmd", "\u00a0dm", "copykey", "Newdm", " _nm", "_dm", "_mb", " _db", "localmb", "_nm", "__md", "_mg", "_mode", " _m", "_cmd", "_amd", " _MD"], "md2": ["md62", "MD3", " md02", " mdTwo", "hd62", "cmd5", "MD1", "md02", "MD5", "mdTwo", "cmd1", "md32", " md5", "amd2", "md1", "hd2", "MD62", "md4", "amd62", " md62", "cmd02", "amdTwo", "amd4", " md32", "MD4", "md5", "amd32", "MD2", " md1", "hd32", "cmd62", " md4", "cmd4", "hdTwo", "amd02", "cmd3", "cmd2"], "abyFinal": ["amyInitial", "amySuccess", "babyLast", "babyTotal", "abeFinal", "babyfinal", "abyLast", "amySpecial", "abiesLast", "abySuccess", "aberTotal", "abiesSuccess", "abyfinal", "andyInitial", "babySpecial", "abiesFinal", "rayInitial", "saySpecial", "andyFinal", "sayInitial", "BabyFull", "abyFinish", "rayLast", "babyResult", "babySuccess", "abeFinish", "abiesFinish", "butFinal", "abyFull", "abeFull", "abiesResult", "abySpecial", "andyLast", "aberfinal", "butLast", "babyFinal", "aberFinal", "abyInitial", "butInitial", "babyInitial", "BabyLast", "aberInitial", "Babyfinal", "abeLast", "andyTotal", "BabyFinish", "sayFinal", "BabyFinal", "andyfinal", "abyTotal", "abyResult", "abiesFull", "amyResult", "amyFinal", "rayFinal"], "n": ["span", "nu", "m", "k", "un", "fn", "np", "z", "cn", "g", "b", "yn", "en", "num", "gn", "none", "ns", "ner", "not", "no", "syn", "f", "ni", "all", "sn", "o", "nt", "d", "ny", "inn", "nc", "pn", "conn", "ng", "nw", "y", "network", "don", "ne", "mn", "l", "a", "byn", "number", "len", "min", "node", "r", "na", "v", "br", "c", "name", "dn", "t", "net", "adj", "x", "non", "nor", "nb", "N", "nan", "on", "p", "nn"], "j": ["ij", "k", "js", "u", "fr", "z", "b", "num", "io", "si", "jc", "ie", "ni", "jj", "o", "ja", "d", "index", "dj", "ci", "uj", "aj", "ji", "J", "y", "section", "li", "ne", "l", "di", "xi", "bj", "ind", "yi", "v", "c", "adj", "I", "jl", "ii", "qi", "x", "jp", "q", "p"], "i": ["p", "e", "ki", "fi", "io", "si", "ie", "ni", "o", "index", "ci", "iu", "oi", "ji", "ani", "mini", "multi", "y", "ali", "li", "di", "mi", "pi", "xi", "eni", "yi", "ti", "gi", "c", "gu", "I", "zi", "phi", "ai", "ini", "ui", "ii", "qi", "bi", "mu", "chi", "ri"], "sbPasswd": ["sbSecretwd", "sbPassrc", "sbFailphrase", "sbParwords", "sbPassword", "sfSecretword", "sbParphrase", "sbPasswords", "sbSecretwords", "sbParword", "bbParrc", "sbFailw", "sfPassword", "sfSecretwd", "sfPasswords", "bbParword", "bbParwd", "rbCrw", "rbCrWD", "sbCrw", "sfSecretwords", "rbCrwd", "bbPassword", "sfSecretw", "sbParw", "rbPassword", "sbCrwd", "sfPassw", "sbParWD", "cbParword", "bbPasswd", "sbParrc", "sbPassphrase", "sbFailword", "sbCrrc", "sbCrword", "sbSecretword", "bbPassrc", "cbPassphrase", "rbCrword", "sbCrwords", "sbPassWD", "cbParwd", "sbSecretw", "sbCrWD", "cbPasswd", "cbPassw", "rbPasswd", "sbPassw", "bbParw", "cbParw", "cbParphrase", "rbPassWD", "sbParwd", "bbPassw", "sfPasswd", "sbFailwd", "cbPassword", "rbPassw"], "md3": ["mdthree", " mdthird", "mand15", "MD3", "amd03", "amdthird", "amd3", " md23", "mand23", "MD53", " md03", " mdthree", "ms03", "md53", "MD1", " md53", "cmd23", "cmd1", "md1", "amd23", "cmd2", "MD23", "msthird", "mag3", "md15", "msthree", "mdthird", "md23", "mag23", "mag512", "mand512", "md03", "mand3", "MD2", " md1", "ms3", "amdthree", "cmd53", "amd512", "md512", "cmd3", "amd15", "mag15"]}}
{"id1": "21491791", "id2": "9347451", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"run": ["spawn", "running", "log", "unit", "call", "apply", "build", "Run", "func", "loop", "all", "job", "test", "code", "process", "create", "work", "worker", "command", "fork", "exec", "start", "app", "runner", "invoke", "execute"], "input": ["text", "flow", "resource", "image", "view", "connection", "form", "io", "data", "parser", "reading", "raw", "in", "entry", "audio", "storage", "index", "read", "out", "conn", "instance", "source", "driver", "config", "client", "stream", "work", "worker", "inner", "user", "Input", "internal", "control", "address", "file", "initial", "loader", "up", "context", "state", "iterator", "active", "feed", "request", "readable"], "output": ["page", "text", "exit", "log", "console", "unit", "write", "resource", "image", "parent", "connection", "letter", "outer", "data", "later", "writing", "written", "application", "document", "generated", "index", "Writer", "job", "end", "out", "temp", "source", "Output", "config", "network", "filename", "web", "target", "user", "queue", "control", "object", "cache", "file", "writers", "path", "response", "environment", "operation", "put", "office"], "reader": ["book", "request", "peer", "resource", "image", "server", "rer", "view", "system", "io", "parser", "ner", "reading", "in", "entry", "audio", "Reader", "read", "row", "rator", "builder", "source", "driver", "client", "riter", "stream", "er", "worker", "slave", "inner", "r", "handler", "loader", "context", "wrapper", "author", "oder", "manager", "ri", "owner"], "writer": ["wr", "write", "wan", "connection", "outer", "data", "writing", "engine", "ner", "written", "writ", "entry", "creator", "her", "editor", "Writer", "ew", "out", "wer", "player", "maker", "ws", "rw", "builder", "nw", "driver", "war", "riter", "work", "er", "worker", "ter", "inner", "r", "wa", "wire", "w", "wb", "writers", "wrapper", "or", "word", "office", "author", "manager", "request"], "pump": ["camp", "ppumping", "pumping", "pamp", "prump", "Pmp", "mprint", "dumps", "pdump", " pmp", "Pam", "ppumper", "cump", "ppumps", "Pdump", "humper", "cumper", "mumper", "pumps", "Pumper", " pdump", "Pump", " pumper", "pam", "pumper", "pmp", "Pumping", "prumper", "pprint", "Pprint", "humps", " pumping", "dmp", "mump", "hump", "dump", "Pamp", "pram", "Pumps", " pumps", "dumper", " pam", "hprint", " pamp", "prdump", "ppump", "mumps", "cumping"], "counter": ["enter", "page", "Counter", "url", "server", "clock", "const", "master", "count", "parent", "offset", "num", "race", "outer", "version", "step", "ner", "hello", "sequence", "cookie", "loop", "entry", "now", "result", "meter", "timer", "second", "index", "ener", "row", "code", "ver", "instance", "progress", "consumer", "comment", "trace", "center", "rew", "builder", "keep", "ter", "er", "worker", "seed", "number", "ger", "walker", "lr", "r", "inner", "starter", "repeat", "loader", "continue", "inter", "order", "layer", "runner", "current", "currency", "pointer", "author", "zero", "collection", "keeper", "ception", "processor"], "buffer": ["buf", "page", "uf", "text", "url", "message", "resource", "server", "length", "data", "port", "Buffer", "channel", "limit", "entry", "document", "batch", "source", "iter", "header", "buff", "base", "queue", "position", "address", "file", "loader", "reference", "binary", "layer", "uffer"], "off": ["own", "art", "oa", "Off", "flow", "offset", "OFF", "info", "pos", "offs", "now", "area", "fail", "o", "set", "ref", "end", "out", "Offset", "open", "addr", "ff", "of", "opt", "inner", "eno", "less", "low", "ord", "start", "left", "down", "unknown", "ui", "auto", "head", "on", "offer"], "len": ["fd", "lon", "gen", "log", "ln", "fl", "url", "lf", "fin", "ll", "length", "count", "n", "body", "loc", "en", "lock", "lan", "limit", "in", "pos", "all", "elt", "lin", "ref", "Len", "end", "val", "el", "size", "width", "li", "l", "lit", "lim", "den", "bin", "name", "ld", "layer", "ler", "lc", "lt", "line", "on", "lib"], "rd": ["fd", "rt", "red", "rand", "rm", "rss", "raid", "fr", " r", "xd", "nd", "rx", "rob", "ru", "dr", "RR", "nr", "rc", "rs", "rh", "dd", "d", "rb", "rn", "val", "rid", "RD", "rw", "rl", "rr", "db", "lr", "r", "ind", "adr", "ud", "ord", "dra", "rod", "ld", " prod", "hr", "ra", "cr", "rf", "ds"]}}
{"id1": "12085127", "id2": "5808579", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 0, "substitutes": {"navigate": [" Navigation", "ivigating", "avigate", "Navigated", " Navigate", " Navigating", "ajigate", "ajigation", "Navigate", "ivigated", "Navigation", "navigating", "Navigating", "ajigating", "Navig", "avigating", "avigated", "ivigation", "navigation", "navig", "avigation", " Navig", "ajig", "ivigate", "navigated"], "url": ["page", "uri", "resource", "image", "server", "ssl", "ll", "e", "html", "build", "org", "link", "blog", "follow", "entry", "f", "fr", "rule", "route", "str", "URL", "www", "job", "element", "plugin", "i", "source", "api", "article", "config", "client", "l", "web", "base", "user", "r", "object", "position", "address", "id", "account", "gl", "file", "obj", "c", "service", "sl", "host", "bug", "location", "Url", "http", "feed"], "connection": ["page", "proxy", "uri", "unit", "resource", "server", "communication", "b", "loc", "io", "link", "session", "socket", "ie", "bc", "channel", "Connection", "application", "connect", "coll", "ci", "conn", "connected", "i", "client", "l", "position", "which", "character", "con", "c", "handler", "cf", "context", "response", "condition", "or", "lc", "wrapper", "http", "open", "database"], "is": ["ins", "gets", "isl", "isi", "os", "lis", "il", "io", "info", "mis", "iso", "in", "es", "bis", "IS", "us", "isc", "ci", "fs", "s", "iris", "ios", "i", "api", "im", "ip", "ib", "ils", "iss", "ais", "ir", "ris", "Is", "ops", "ai", "ii", "ui", "as", "isa", "was", "cs", "abs", "bs", "its", "isu", "serv"]}}
{"id1": "15018553", "id2": "14878593", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["decrypt", "decipher", "secipher", "Encrypt", "secrypt", "encryption", "enccrypt", "encipher", "seccrypt", "Enccrypt", "Encipher", "Encryption", "decryption", "secryption", "deccrypt"], "text": ["font", "txt", "message", "image", " Text", "length", "struct", "connection", "letter", "method", "data", "sequence", "output", "input", "str", "hex", "password", "template", "bytes", "key", "test", "code", "class", "source", "config", "seed", "number", "TEXT", "object", "address", "token", "string", "name", "binary", "pattern", "path", "transfer", "word", "content", "buffer", "ext", "contract", "secret", "Text"], "md": ["m", "rm", "hd", " MD", "Cmd", "message", "mp", "cmp", "cmd", "dr", "pg", "sha", "data", "mo", "dig", "dd", "hash", "mc", "mag", "d", "od", "meta", "me", "ms", "mb", "wd", "amd", "mg", "dm", "bd", "pkg", "metadata", "cm", "pd", "MD", "hm", "mn", "mi", "db", "ad", "mac", "mand", "mm", "ma", "sm", "gb", "am", "ld", "mk", "pm", "em", "mt", "mod", "df"], "md5hash": ["md25Hash", " md4sum", " md5sum", "md4Hash", "md6Hash", "md4sum", "MD512key", "md512key", "MD5hash", "md5Hash", "md5block", "md512hash", "MD512hash", "md7hash", "MD5hex", "md2sum", "md7block", "md5hex", "md6hash", "md4block", "md7Hash", "md256key", "md6hex", "md4hash", "md25log", "md4log", " md4hash", " md5log", "md2block", "md5log", "md256hash", "md2hash", "md6log", "md25sum", "md5sum", "md25hash", " md4block", "MD5key", "md7sum", "md512hex", "MD512hex", "md256hex", "md5key", " md5Hash", " md5block", "md6sum", "md6key", " md4log", "md2Hash", " md4Hash"]}}
{"id1": "12236729", "id2": "22338097", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"copy": ["replace", " transfer", "cp", "cmp", "io", "sync", "py", " copying", " copied", "zip", "paste", "split", "clone", "clip", "download", "cat", "Copy", "dump", " Copy", "upload", " dup", "diff", "get", "php", "transfer", "p", "cop"], "inputFile": ["outputFiles", " inputfile", "currentFile", " inputFiles", " inputDir", "currentDir", "sourceFile", "sourcefile", " inputPath", "outputPath", "inputDir", "outputDir", "currentFiles", "inputfile", "currentfile", "sourceFiles", "inputFiles", "sourcePath", "outputfile", "inputPath"], "outputFile": ["referenceFile", "tempFile", "OutputDirectory", " outputDirectory", " outputFilename", "referenceDir", " outputfile", "outputDirectory", "tempfile", "referencefile", "inputFilename", "inputDir", "tempDir", "outputDir", "OutputDir", "tempDirectory", "inputfile", "referenceFilename", "OutputFile", " outputDir", "outputFilename", "Outputfile", "outputfile"], "in": ["into", "ln", "ins", "e", "image", "In", "n", "connection", "lock", "init", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "read", "s", "conn", "cin", "i", "sin", "win", "kin", "reader", "source", "is", "inside", "nin", "l", "a", "login", "inner", "min", "r", "id", "pull", "bin", "con", "err", "file", "up", "pin", "get", "ini", "as", "again"], "out": ["at", "ex", "log", "writer", "one", "write", "plain", "parent", "b", "null", "n", "io", "outer", "off", "sync", "outside", "inc", "socket", "output", "o", "Out", "error", "conn", "temp", "i", "outs", "over", "cache", "exec", "bin", "file", "err", "v", "obj", "extra", "up", "w", "net", "OUT", "plus", "again", "line", "post"], "c": ["k", "m", "u", "ct", "esc", "e", "col", "uc", "C", "b", "count", "n", "rc", "ce", "ec", "f", "o", "d", "ch", "cl", "ci", "code", "cc", "i", "cu", "cm", "a", "l", "r", "xc", "id", "sc", "pc", "character", "v", "fc", "cf", "cd", "x", "cy", "pointer", "lc", "line", "cr", "p", "char"]}}
{"id1": "2009072", "id2": "1005107", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    public void googleImageSearch() {\n        if (artist.compareToIgnoreCase(previousArtist) != 0) {\n            MusicBoxView.googleImageLocation = 0;\n            try {\n                String u = \"http://images.google.com/images?q=\" + currentTrack.getArtist() + \" - \" + currentTrack.getAlbum() + \"&sa=N&start=0&ndsp=21\";\n                if (u.contains(\" \")) {\n                    u = u.replace(\" \", \"+\");\n                }\n                URL url = new URL(u);\n                HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n                httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n                BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n                String text = \"\";\n                String lin = \"\";\n                while ((lin = readIn.readLine()) != null) {\n                    text += lin;\n                }\n                readIn.close();\n                if (text.contains(\"\\n\")) {\n                    text = text.replace(\"\\n\", \"\");\n                }\n                String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n                for (String s : array) {\n                    if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                        String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                        googleImages.add(s1);\n                    }\n                }\n            } catch (Exception ex4) {\n                MusicBoxView.showErrorDialog(ex4);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openInput": ["openContent", "getInput", "openOutput", "OpenOutput", "createInput", "getResource", "createOutput", "OpenInput", "OpenContent", "createResource", "getOutput", "getContent", "createContent", "openResource", "OpenResource"], "path": ["filter", "prefix", "text", "request", "uri", "txt", "image", "parent", "form", "relative", "data", "ath", "method", "part", "PATH", "input", "str", "route", "index", "ref", "template", "end", "key", "s", "xml", "temp", "api", "stream", "self", "Path", "tree", "base", "transform", "node", "inner", "object", "sign", "id", "user", "string", "file", "c", "obj", "name", "list", "root", "pattern", "full", "next", "context", "clean", "word", "content", "value", "pointer", "plus", "enc", "http"], "len": ["span", "lon", "fl", "ln", "lp", "lf", "fin", "ll", "le", "length", "count", "n", "en", "part", "limit", "pos", "str", "split", "lin", "Len", "end", "val", "iter", "size", "li", "l", "base", "v", "list", "sl", "sp", "lc", "line"], "p": ["param", "m", "pe", "np", "u", "lp", "j", "vp", "cp", "ps", "py", "f", "P", "pa", "o", "pb", "s", "pr", "i", "api", "l", "ip", "point", "po", "pc", "v", "ap", "c", "t", "pre", "sp", "jp", "pp", "ep", "fp", "tp"], "url": ["page", "fl", "uri", "ssl", "resource", "image", "server", "html", "b", "connection", "link", "blog", "channel", "f", "www", "URL", "conn", "source", "api", "client", "l", "web", "base", "user", "object", "string", "file", "ob", "sl", "host", "Url", "location", "http", "feed", "open", "ball", "browser"], "result": ["page", "res", "array", "uri", "ssl", "report", "resource", "message", "air", "event", "data", "this", "raw", "output", "entry", "val", "results", "instance", "source", "api", "reader", "tmp", "stream", "Result", "r", "object", "match", "err", "obj", "up", "ret", "response", "content", "buffer", "http", "request", "open"]}}
{"id1": "11556231", "id2": "6866575", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"ByURL": ["bySSL", "ByUrl", "CreateURI", "createURL", "byUrl", "byURL", "createUrl", "createSSL", "byURI", "CreateURL", "CreateSSL", "createURI", "ByURI", "BySSL", "CreateUrl"], "urlstr": ["urlStr", "urlname", " urlname", " urlstring", "UrlStr", "httpstr", "URLname", "Urlstr", "URLStr", "urlstring", " urlSTR", "urlSTR", "Urlname", "URLSTR", "httpStr", "URLstring", "URLstr", "UrlSTR", "httpstring", "httpSTR", "Urlstring"], "uri": ["prefix", "description", "attribute", "text", "direction", "resource", "image", "server", "manager", "io", "username", " URI", "route", "URL", "href", "type", "i", "directory", "filename", "pi", "base", "id", "address", "string", "file", "URI", "iri", "absolute", "host", "domain", "location", "Url", "ui", "path", "qi", "query", "collection", "http", "ri", "database"], "url": ["proxy", "page", "ssl", "resource", "image", "server", "system", "loc", "link", "session", "channel", "f", "URL", "conn", "download", "client", "li", "l", "stream", "web", "base", "user", "id", "address", "string", "file", "loader", "service", "sl", "host", "location", "Url", "path", "http", "feed"], "connection": ["writer", "resource", "server", "system", "body", "io", "socket", "director", "channel", "Connection", "application", "connect", "URL", "conn", "connected", "i", "client", "directory", "stream", "l", "control", "con", "c", "handler", "relation", "context", "response", "or", "collection", "http", "open", "database"], "in": ["writer", "ins", "In", "init", "inc", "socket", "f", "connect", "input", "IN", "lin", "inn", "and", "out", "s", "conn", "i", "kin", "cms", "client", "a", "stream", "login", "inner", "r", "ac", "con", "bin", "c", "ini", "as", "or"], "reader": ["writer", "resource", "server", "rc", "io", "parser", "reading", "channel", "entry", "result", "Reader", "input", "read", "out", "row", "conn", "iter", "i", "client", "stream", "er", "inner", "r", "handler", "ais", "loader", "ini", "wrapper", "or", "ler", "buffer"], "is": ["rss", "ins", "isi", "isl", "os", "lis", "rs", "io", "info", "mis", "si", "nis", "iso", "bis", "IS", "ci", "out", "s", "conn", "iris", "fs", "ios", "i", "src", "cms", "im", "iss", "ais", "err", "ris", "has", "Is", "iri", "sr", "sp", "ai", "as", "ui", "or", "isa", "was", "serv", "ri"], "document": ["m", "writer", "resource", "message", "parent", "output", "application", "result", "graph", "docs", " documents", "xml", "element", "class", "Document", "config", "Documents", "node", "object", " documentation", "root", "ocument", "response", "content", "collection", "doc", "database"], "source": ["text", "unit", "resource", "parent", "info", "parser", "Source", "input", "container", "element", "instance", "class", "driver", "src", "stream", "node", "object", "language", "string", "file", "service", "SOURCE", "context", "content"], "name": ["NAME", "prefix", "description", "text", "attribute", "resource", "parent", "tag", "info", "definition", "named", "key", "type", "element", "instance", "comment", "Name", "filename", "base", "node", "object", "id", "names", "string", "file", "URI", "property", "root", "domain", "location", "word", "value", "format"], "namespaceURI": ["NamespacesFINE", "namesistenceMI", "namesheetGI", "namesheeturi", "perspaceuri", "Namespaceuri", "nameservingURI", "NamespaceURI", "namespaceuri", "namesistenceuri", "namesistenceURI", "namespaceduri", "namesheetURI", "perspaceURI", "NamespaceMI", "namesferenceuri", "namespacesURI", "Namespacesuri", "perspacedGI", "nameservingNS", "namespacedNS", "namespacedURI", "namespacesuri", "nameservinguri", "namespaceFINE", "NamespacesURI", "namesferenceMI", "namesistenceFINE", "NamespaceFINE", "namespacesFINE", "namespaceNS", "namespaceMI", "namesferenceFINE", "namesferenceURI", "perspacedURI", "namespaceGI", "perspaceGI", "perspaceduri", "NamespacesMI", "NamespaceNS", "namespacedGI", "namespacesMI"], "qualifiedName": ["fixedPath", "localname", "fixedType", "simplename", "fixedName", "fixedname", " qualifiedname", "simplePath", "qualPath", " qualifiedURI", "qualName", "simpleURI", "qualURI", " qualifiedType", "qualifiedname", " qualifiedPath", "qualname", "localType", "localPath", "qualifiedPath", "qualifiedURI", "qualifiedType", "simpleName"], "data": ["DATA", "NAME", "text", "description", "default", "resource", "message", "parent", "script", "body", "info", "child", "output", "definition", "model", "input", "str", "comments", "template", "type", "element", "xml", "class", "config", "media", "stream", "number", "base", "ata", "node", "object", "id", "language", "string", "property", "def", "context", "content", "value", "format", "buffer", "doc"], "tagName": [" tagClass", "TagClass", "TagName", "localClass", "tagClass", "localname", "Tagname"], "target": ["NAME", "prop", "component", "resource", "parent", "info", "method", "template", "href", "instance", "uid", "class", "Target", "base", "node", "object", "address", "property", "root", "host", "next", "domain", "location", "path", "format", "head", "label"], "elementId": ["objectTag", "elementID", "nodeID", " elementTag", " elementid", "nodeId", "nodeTag", "elementid", "elementTag", "objectId", "objectid", " elementID", "nodeid", "objectID"], "tagname": ["className", "classNAME", " tagNAME", "TagName", "tagNAME", "TagNAME", "Tagname", "classname"], "localName": ["qualifiedNAME", "qualifiedname", "clientName", " localNAME", " localname", "clientNAME", "clientname", "localname", "localNAME"]}}
{"id1": "9347451", "id2": "19608872", "code1": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"writeData": ["writeDATA", " writeText", "appendDATA", "WriteDATA", "writedata", "WriteData", "Writedata", " writeDATA", "appendData", "WriteText", "writeText", "appendText", " writedata", "appenddata"], "name": ["ame", "NAME", "prefix", "url", "report", "image", "parent", "n", "info", "data", "old", "title", "part", "model", "f", "str", "named", "index", "date", "key", "type", "out", "pass", "code", "temp", "time", "class", "Name", "size", "filename", "l", "base", "table", "id", "names", "string", "start", "path", "word", "active", "line"], "items": ["keys", "chains", "item", "jobs", "cases", "Items", "sections", "groups", "plugins", "features", "planes", "classes", "projects", "lines", "ips", "flows", "objects", "xml", "images", "days", "pieces", "files", "pages", "ids", "units", "steps", "names", "models", "tests", "locks", "amples", "blocks", "types", "events", "months", "ints"], "mzmin": ["mwmax", "mvmin", "mxstart", "mZstart", "dizstart", "MZstart", "mizmax", "mxmins", "mczstart", "dizmax", "mczmax", "mzstart", "mozMin", "mvmins", "dzmin", "Mzstart", "dzMin", "mizmin", "Mxmin", "mczMin", "mczmin", "mizMin", "mozstart", "mozmin", "mwmin", "Mzmax", "MzMin", "mozmins", "mizstart", "mozmax", "Mxmins", "mzmins", "mvMin", "mzMin", "mZmax", "mwstart", "mxMin", "Mzmin", "dizMin", "dzstart", "mZmin", "dizmin", "MZmin", "Mxstart", "dzmax", "mxmin", "mvstart", "Mzmins", "mxmax", "MZmax", "MxMin"], "mzmax": ["MzMAX", "MZax", "mxMAX", "mizmax", " mzhMax", "mZMax", " mzhend", "Mzlast", " mizmin", "mjMax", "Mzax", "MzMax", "mzend", " mzhmin", "mizmin", "mzax", "mZend", "mizlast", "mgzlast", "MZlast", "mzhmax", "mzMax", "mgzmin", " mzMax", "mZax", "mZlast", "Mzmax", "mxax", "mazmin", "mjlast", " mizMax", "mxlast", "mjmax", " mzhmax", "mazMAX", "mZmax", "mzMAX", "mizMax", "mazmax", "mgzMax", "Mzmin", "mzhmin", " mzend", " mizlast", "mZmin", "MZMax", "mxend", "MZmin", "mazax", "mzhMax", "mzlast", "mzhend", " mzlast", "mxmin", " mizmax", "mjmin", "mxMax", "MZMAX", "mZMAX", "mgzmax", "mxmax", "MZmax"], "tstart": ["pstart", "tnstart", "pmin", "fmin", " tstop", "fstart", "fadd", " tmin", "tend", "tadd", "fstop", "ttstop", "tnmin", "ttstart", "ttmin", " tadd", "pstop", "fend", "tnadd", " tend", "ttend", "tmin", "pend", "tstop"], "tdelta": ["tdatum", "tdiff", "ulediffs", "ndata", "ruedatum", "dtiffs", "ruediff", "ruediffs", "tdiffs", "ndiff", "dtiff", "TDiffs", "dtata", "ddiffs", "ruedelta", "TDelta", "ddiff", "TDiff", "uledelta", "TDatum", "ddata", "ndelta", "uledatum", "ddelta", "tdata", "ulediff", "ndiffs", "dtelta"], "peaks": ["meakers", "meakes", "keakes", "peak", "feaks", "speaked", "meaks", "peakers", "peasons", "feasons", "leakes", "teakes", "leaks", "keaks", "leak", "speak", "keaked", "teaks", "meak", "speasons", "feakes", "feakers", "leaked", "keak", "speakes", "teak", "feak", "speakers", "peakes", "teasons", "speaks"], "file": ["writer", "FILE", "report", "image", "core", "parent", "view", "letter", "single", "socket", "temp", "class", "l", "files", "place", "queue", "cache", "per", "wave", "page", "pe", "unit", "e", "resource", "server", "message", "form", "info", "this", "port", "group", "folder", "model", "result", "h", "el", "let", "handle", "parse", "ger", "object", "show", "loader", "global", "w", "path", "where", "feed", "save", "book", "log", "il", "io", "check", "tool", "site", "run", "out", "comment", "print", "db", "user", "File", "function", "buffer", "http", "use", "fp", "force", "sample", "module", "write", "ile", "le", "b", "lock", "output", "f", "it", "source", "reader", "work", "base", "bar", "table", "pipe", "load", "full", "get", "auto", "pool", "fit", "fe", "line", "lib"], "i": ["m", "p", "u", "z", "uri", "e", "n", "fi", "init", "io", "info", "adi", "si", "step", "ie", "part", "it", "ni", "f", "jj", "index", "d", "ci", "iu", "oi", "h", "is", "mini", "multi", "api", "y", "li", "di", "im", "mi", "ip", "eni", "xi", "hi", "pi", "slice", "l", "yi", "id", "uli", "ti", "gi", "v", "c", "start", "sup", "ri", "I", "ai", "ix", "phi", "ini", "ii", "ui", "bi", "x", "mu", "chi", "qi", "ik"], "nothing": ["sorry", " rest", " difference", "Nothing", "hack", "miss", "good", "thing", " no", "init", "yeah", " worst", "none", "info", "empty", "terror", "hello", "different", "tips", " tid", "no", "how", "it", "stuff", " stop", "tt", "done", "ta", "missing", "them", "broken", "T", "total", " tot", "life", "notice", "what", "shit", " trials", " it", "wrong", "anything", "show", " skip", "tests", "everything", "little", "xxx", "wait", "worst", "diff", " trial", "unknown", "whatever", "something", "things", "false", "zero", "huge", " tries", "dt", " total"], "fileLoc": [" fileLOC", "baseLocation", "fLoc", "Fileloc", "fileLOC", "FileLoc", "FileLOC", "floc", " fileloc", " fileLocation", "fileloc", "fLOC", "baseLOC", "fLocation", "fileLocation", "baseloc", "FileLocation", "baseLoc"], "tempDate": [" tempLine", "tmpDat", "tempdate", "tmpdate", "tmpDay", "TempDate", "fakeDat", "temdate", " tempDat", "temDat", "tmpLine", "fakedate", "fakeDate", "tmpDate", "TempLine", "TempDat", " tempdate", " tempDay", " tempSign", "TempSign", "TempDay", "tempDat", "Tempdate", "tempDay", "tempSign", "tmpSign", "tempLine", "temDate"], "t": ["at", "m", " difference", "e", "g", "tz", "n", "b", "flat", "ot", "duration", " tid", "it", "f", " ng", "tt", "d", "ta", "the", " tail", "out", "utt", " n", "that", "tf", "T", "total", "y", " tot", " p", "l", "target", "tim", " it", "ti", "c", " tf", " ta", "ts", " pt", " title", "p", "dt", " ti", " e"], "k": ["ks", "ky", "kr", "K", "dk", "uk", "u", "kat", "z", "kid", "e", "b", "g", "n", "ok", "ki", "ku", "ek", "kick", "f", "jj", "o", "d", "ck", "ka", "ko", "kn", "key", "ijk", "ak", "kh", "y", "work", "l", "kk", "kw", "kl", "v", "unk", "c", "kind", "ke", "w", "mk", "sk", "x", "tk", "q", "p", "ik"], "j": ["ij", "jen", "m", "js", "u", "fr", "z", "e", "b", "g", "n", "off", "kj", "jc", "ie", "f", "it", "jj", "jet", "ja", "o", "d", "ch", "dj", "job", "uj", "key", "aj", "ji", "J", "el", "pass", "jo", "pr", "y", "oj", "li", "l", "bj", "r", "ind", "br", "v", "err", "obj", "dy", "adj", "jl", "ii", "x", "jp", "q", "p", "ik"], "peaked": ["speaky", "cleaked", "meaker", "peaky", "peaker", "speaken", "feaking", "peak", "keaking", "ceaky", "meaken", "keake", "apeaking", "speaked", "cleaken", "paaked", "pak", "apeaked", "peake", "feaken", "cleaking", "ceaking", "ceaked", "paken", "paked", "feaked", "speak", "keaky", "keaked", "meaked", "cleake", "keaker", "peaking", "meaking", "apeaken", "ceaken", "ceak", "paaken", "paake", "keak", "paaking", "paky", "peaken", "ceaker", "feaker", "keaken", "apeaker"], "test": ["filter", "txt", "pack", "report", "server", "call", "build", "master", "scan", "here", "data", "this", "Test", "search", "loop", "f", "all", "py", "check", "result", "trial", "fail", "valid", "end", "out", "val", "pass", "ver", "temp", "iter", "driver", "reader", "print", "inner", "user", "tr", "table", "match", "show", "v", "err", " tests", "tests", "start", "diff", "cher", "runner", "testing", "train", "feed"]}}
{"id1": "8515891", "id2": "16673769", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "label": 0, "substitutes": {"readUrl": ["processUrl", "ReadUrl", "getQuery", "processPage", "getUrl", "processURL", "processQuery", "readPage", "getURL", "readURL", "ReadQuery", "ReadURL", "readQuery", "getPage", "ReadPage"], "svnUrl": ["svNFile", "svbUrl", "svNURL", " svNFile", "svcnUrl", "svpnFile", "svnEl", "svcnStr", " svnEl", "svpnUr", "svbUr", "svNUr", " svnStr", "svNEl", "svlUrl", "svlStr", "svcnEl", "svnFile", " svNUr", " svnFile", "svlURL", "svbFile", "svbURL", "svnURL", " svNStr", "svpnUrl", "svNStr", "svcnURL", " svNUrl", " svNURL", "svnUr", " svnUr", " svNEl", "svlEl", "svnStr", " svnURL", "svpnURL", "svNUrl"], "url": ["ur", "page", "log", "uri", "ssl", "resource", "server", "b", "connection", "loc", "ul", "org", "this", "blog", "bc", "f", "www", "URL", "cl", "cur", "conn", "pull", "config", "client", "web", "l", "stream", "user", "util", "r", "c", "fc", "up", "sl", "ob", "bug", "context", "plug", "Url", "path", "http", "feed", "bb", "open"], "uc": ["UC", "uri", "ssl", "roc", "cp", "connection", "loc", "rc", "tc", "uci", "ul", "usc", "bc", "ec", "userc", "soc", "anc", "connect", "mc", "coll", "us", "cl", "cas", "cur", "auc", "conn", "cc", "cu", "ub", "client", "co", "oc", "sc", "ac", "pc", "con", "c", "cci", "ocr", "exec", "fc", "up", "uca", "ucc", "bug", "cf", "lc", "hub", "http"], "userPassword": ["userAuth", "userpassword", "currentSecret", "userPass", " userPass", " userSecret", "currentpassword", "useSecret", " userAuth", " userpassword", "usePassword", "useAuth", "currentPassword", "UserAuth", "usePass", "UserPass", "Userpassword", "userSecret", "usepassword", "UserPassword", "currentPass"], "encoding": ["enasing", "encoder", "engoding", "enoder", "enoded", "Encasing", "engoder", "enording", "engoded", " encoded", "enoding", " encording", "Encoded", "encoded", " encoder", "Encoder", "encasing", "engasing", "encording", "Encording", "Encoding"], "is": ["ls", "ins", "uri", "isi", "isl", "os", "lis", "ori", "init", "info", "nis", "si", "iso", "ie", "it", "es", "vs", "bis", "IS", "us", "isc", "ci", "ms", "out", "fs", "s", "iris", "ws", "ios", "i", "irc", "api", "src", "ip", "ib", "id", "iss", "ir", "ais", "ris", "has", "Is", "as", "ui", "was", "isa", "cs", "abs", "ois", "are", "its", "ri", "serv"], "in": ["into", "m", "rec", "ins", "In", "tin", "edIn", "reading", "inc", "raw", "gin", "f", "oin", "input", "vin", "din", "IN", "inn", "inas", "read", "out", "cin", "i", "rin", "source", "kin", "reader", "inside", "nin", "login", "inner", "id", "string", "pc", "bin", "con", "re", "atin", "pin", "ini", "arin", "again", "line", "isin"]}}
{"id1": "22752444", "id2": "8064604", "code1": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", "encress", " encryption", "escress", "encryption", " encipher", "decress", "escipher", " encress", "escrypt", "encipher", "escryption", "decipher", "decryption"], "plainText": ["plainString", "plainForm", "binaryCode", "flatForm", " plainCode", "singleContent", "singleString", "lineContent", " plaintext", " plainString", "flattext", "plainCode", "singleBody", "plainData", " plainData", "flatText", " plainBody", "linetext", "plainBody", "singletext", "singleData", "singleText", " plainContent", "lineData", "plainContent", "plaintext", " plainForm", "singleForm", "singleCode", "binaryBody", "binaryText", "flatString", "binarytext", "lineText"], "hash": ["text", "ash", "log", "auth", "array", "url", "message", "image", "html", "copy", "build", "sha", "cmd", "body", "material", "tag", "data", "rh", "msg", "dig", "block", "hex", "sum", "password", "error", "h", "key", "row", "code", "kh", "header", "db", "base", "mac", "id", "cache", "match", "string", "Hash", "json", "format", "secret"], "md": ["mad", "m", "rm", "hd", " MD", "Cmd", "mp", "dr", "cmd", "sha", "material", "data", "um", "mo", "dig", "dd", "mc", "mag", "d", "vd", "od", "meta", "mb", "hm", "ms", "wd", "amd", "mg", "dm", "bd", "metadata", "cm", "pd", "MD", "di", "mn", "ad", "da", "mac", "mand", "mm", "sm", "ma", "mem", "am", "pm", "mt", "mu", "cd", "mod", "dh", "df"], "raw": ["buf", "text", "shared", "array", "original", "pack", "message", "image", "null", " Raw", "data", "RAW", "dec", "pure", "wrap", "draw", "ode", "input", "hex", "out", "row", "ng", "instance", "ack", "rew", "flash", "stream", " RAW", "inner", " hex", "sc", "load", "initial", "Raw", "full", "json", "clean", "unknown", "unsigned", "buffer", "orig", "serial", "enc", "feed", "block"]}}
{"id1": "17193692", "id2": "17083703", "code1": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"execUpdate": [" ExecUpdate", " ExecUPDATE", " executeUPDATE", "ExecUPDATE", "executeUPDATE", " executeupdate", " executeUpdate", " ExecWhere", "ExecUpdate", "executeUpdate", "ExecWhere", " executeWhere", "executeWhere", "executeupdate", "Execupdate", " Execupdate"], "sqlStmts": ["sqlStmmbs", "sqlStrrters", "sqlStgmsts", "sqlStvps", "sqlStmtsts", "sqlSTmbs", "sqlStmtps", "sqlStmtms", "sqlStpsts", "sqlScmtts", "sqlStimls", "sqlStvms", "sqlSTmgs", "sqlstvps", "sqlStrmtats", "sqlstvms", "sqlStmuts", "sqlStrmts", "sqlStrments", "sqlStlls", "sqlStmtcs", "sqlStfmsts", "sqlStmments", "sqlStfmuts", "sqlStmters", "sqlStmmTS", "sqlStmtments", "sqlStmtls", "sqlStmmts", "sqlStluts", "sqlStfmls", "sqlStrrts", "sqlStmtTS", "sqlStamuts", "sqlStrmtts", "sqlStrmtTS", "sqlStmtters", "sqlStimts", "sqlStamts", "sqlstmuts", "sqlStrmters", "sqlStrrments", "sqlStfmgs", "sqlStpats", "sqlSTmsbs", "sqlstvts", "sqlSTmssts", "sqlStmmgs", "sqlStmmsts", "sqlStimcs", "sqlStfmbs", "sqlStrmtsts", "sqlStfmps", "sqlStpts", "sqlStrsts", "sqlStfmcs", "sqlScmts", "sqlStmls", "sqlstvuts", "sqlScmtuts", "sqlSclts", "sqlStfmts", "sqlStrmments", "sqlStrmats", "sqlStmgs", "sqlStimuts", "sqlstmms", "sqlScmcs", "sqlStmms", "sqlStmtats", "sqlStmtuts", "sqlScmuts", "sqlStmsts", "sqlScmps", "sqlSTmsts", "sqlStmsgs", "sqlStamls", "sqlstmts", "sqlSTmts", "sqlSTmsgs", "sqlStmbs", "sqlScmtls", "sqlStamps", "sqlStrrsts", "sqlStgmts", "sqlStgmments", "sqlstmps", "sqlStmmats", "sqlStrts", "sqlStmcs", "sqlStvts", "sqlStfmms", "sqlStpTS", "sqlScmtcs", "sqlStrmTS", "sqlStrmsts", "sqlStmps", "sqlSclps", "sqlStmtts", "sqlStrters", "sqlStmTS", "sqlStlps", "sqlStgmters", "sqlScluts", "sqlStmssts", "sqlScmls", "sqlStmsbs", "sqlStvuts", "sqlStmats", "sqlStlts", "sqlSclls"], "i": ["k", "m", "p", "u", "uri", "e", "j", "count", "b", "fi", "init", "io", "si", "ie", "part", "f", "o", "index", "d", "ci", "key", "oi", "type", "h", "iu", "ji", "abi", "temp", "multi", "y", "li", "di", "l", "vi", "pi", "xi", "base", "eni", "slice", "id", "ti", "v", "gi", "c", "start", "t", "ix", "I", "ai", "phi", "ini", "ui", "ii", "x", "bi", "mu", "qi", "ri"], "stmt": ["strtr", "stmr", "fsm", " ststatement", "symt", "stmp", "fmt", " sttr", "sysm", "strmr", "slmd", " stst", "fmn", "ndstatement", "slmn", "slmp", "strmt", "symn", "stmd", "stsm", "slmt", "ststatement", "stst", "ndmt", "symp", "Stst", " stmd", "fmp", "Sttr", "stmn", "Stmd", "Stmt", "sltr", "strstatement", "ndmr", "slsm", "ndtr", "sttr", "slst", " stmr"]}}
{"id1": "16511008", "id2": "4562786", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMessageCyletter", "createNewProfilingMessageSymletter", "createNewProfilingMsgSymb", "createNewProfilingMsgSyletter", "createNewProfilingMessageCymbol", "createNewProfilingMessageYmb", "createNewProfilingMessageSymb", "createNewProfilingMsgSymletter", "createNewProfilingMsgSymbol", "createNewProfilingMessageSymmbol", "createNewProfilingMessageYmbol", "createNewProfilingMessageCymb", "createNewProfilingMsgSymmbol", "createNewProfilingMessageSyletter", "createNewProfilingMessageSymmb", "createNewProfilingMessageYletter", "createNewProfilingMsgSymmb"], "configID": ["ConfigUID", " configUID", "projectId", "ConfigId", " configION", "configION", "projectID", "projectION", "ConfigID", " configURL", "ConfigURL", "ConfigION", " configId", "configId", "configURL", "projectUID", "configUID", "projectURL"], "programMessageSymbolID": ["programMessageSymbolName", "programMessageSychid", "programMessageSyncmbolId", "programMessageSyncmbName", "programMessageSyntaxid", "programMessageSyklName", "programMessageSymbName", "programMessageSyymName", "programMessageSyncmbolID", "programMessageSyncmbolName", "programMessageSymbIP", "programMessageSyntaxName", "programMessageSymbolid", "programMessageSychID", "programMessageSymbID", "programMessageSyntaxId", "programMessageSyncmbIP", "programMessageSyklID", "programMessageSymbolId", "programMessageSyymId", "programMessageSyncmbolIP", "programMessageSymbid", "programMessageSyntaxID", "programMessageSyymID", "programMessageSyncmbId", "programMessageSymbolIP", "programMessageSychId", "programMessageSymbId", "programMessageSyncmbID", "programMessageSyncmbolid", "programMessageSyymIP", "programMessageSyklId", "programMessageSyncmbid"], "profilingMessageSymbol": ["profilingApplicationSymletter", "profilingFileSymmb", "profilingFileSymbol", "profilingMessageYmbol", "profilingMessageTyPart", "profilingApplicationSymmb", "profilingApplicationSymb", "profilingMessageYletter", "profilingMessageSymb", "profilingFileSyletter", "profilingMessageCyletter", "profilingMessageSyPart", "profilingMessageSymmbol", "profilingMessageTymbol", "profilingApplicationSymmbol", "profilingMessageTymb", "profilingFileSymmbol", "profilingApplicationSyletter", "profilingFileSymletter", "profilingMessageYmb", "profilingMessageCymb", "profilingFileSyPart", "profilingApplicationSymbol", "profilingMessageSyletter", "profilingFileSymb", "profilingMessageSynmbol", "profilingMessageSymmb", "profilingFileSymPart", "profilingMessageSynPart", "profilingMessageSymPart", "profilingMessageCymbol", "profilingMessageSynmb", "profilingMessageSymletter"], "connection": ["log", "unit", "image", "server", "communication", "lock", "si", "session", "sql", "engine", "socket", "bc", "channel", "Connection", "application", "cond", "document", "connect", "result", "ion", "index", "password", "error", "conn", "connected", "driver", "config", "section", "client", "directory", "db", "command", "table", "position", "cache", "con", "c", "machine", "relation", "ctx", "environment", "context", "pool", "condition", "response", " Connection", "state", "function", "collection", "manager", "use", "database", "ongo"], "statement": ["Session", "writer", "unit", "message", "report", "se", "volume", "summary", "lock", "si", "session", "sql", "Query", "parser", "usage", "part", "Connection", "document", "study", "result", "connect", "str", "commit", "storage", "stat", "error", "timeout", "out", "conn", "pass", "comment", "parse", "Statement", "section", "directory", "library", "agent", "expression", "db", "command", "table", "position", "joined", "string", "ment", "ma", "relation", "mt", "function", "condition", "response", "state", "execute", "collection", "use", "database"], "resultSet": [" resultType", "ResultSplit", "resultsSet", "resultLine", " resultLine", "rowSource", "rowType", "resultSplit", "resultType", "dataRow", " resultSplit", "ResultList", "dataSource", "resultList", "ResultRow", "replySplit", "dataSet", "replySet", "rowSet", "ResultSet", "resultGen", "replyList", "ResultType", "rowS", "resultSource", "resultsGen", "dataList", "resultS", " resultList", "responseList", "dataLine", "ResultLine", "responseSet", " resultSource", "replyLine", "dataGen", "ResultSource", "resultsSource", "ResultS", " resultS", "responseRow", "ResultGen", " resultGen", "resultRow"], "query": ["filter", "description", "uri", "message", "report", "module", "call", "script", "style", "scan", "reason", "lock", "Query", "sql", "eries", "search", "qu", "result", "rule", "str", "o", "index", "error", "go", "type", "timeout", "key", "sq", "code", "comment", "parse", "work", "expression", "qs", "command", "feature", "table", "send", "id", "string", "question", "name", "select", " Query", "root", "function", "condition", "value", "update", "execute", "q", "request", "database", "ql", "join"], "msg": ["m", "og", "text", "cap", "gen", "log", "message", "e", "rag", "html", "g", "cfg", "cmd", "mr", "reason", "fg", "dr", "cmp", "tag", "loc", "ug", "ge", "md", "title", "phrase", "var", "status", "agg", "tool", "str", "map", "bag", "error", "ms", "nm", "mg", "pkg", "cm", "gm", "bg", "mn", "sg", "db", "ger", "sim", "rr", "gor", "Msg", "id", "desc", "err", "ma", "name", "comm", "gr", "op", "mt", "gs", "format", "ag", "Message", "exc", "lang", "doc"]}}
{"id1": "23118425", "id2": "18613870", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"encrypt": [" Encipher", "enrypted", " Encrypted", " Encrypt", "Encrypt", "enipher", "enrypt", "enccrypt", "encipher", "encrypted", "Enccrypt", "Encipher", "Encrypted", " Enccrypt"], "plaintext": ["broadtext", "flatdata", "plaindata", "plainstruct", "protectedText", "plainText", " plainText", "flattext", "broadText", "flatText", "broadsource", " plaindata", "flatstring", " plainsource", "protecteddata", "plainstring", "flatsource", "flatstruct", " plainstring", " plainstruct", "protectedtext", "broadstring", "plainsource", "protectedstruct"], "md": ["mad", "m", "mb", "hd", " MD", "Cmd", "message", "mp", "sha", "cmd", "pg", "material", "data", "mo", "ph", "dig", "dd", "mc", "mag", "d", "vd", "od", "meta", "nm", "hm", "wd", "code", "amd", "mg", "dm", "bd", "pkg", "metadata", "pd", "MD", "db", "ad", "mac", "mand", "ms", "mm", "ma", "mem", "dc", "am", "ld", "pm", "kg", "mt", "cd", "mu", "mod", "dh"], "raw": ["buf", "partial", "original", "shared", "array", "pack", "message", "image", "null", "empty", "RAW", "dec", "channel", "wrap", "input", "hex", "feed", "row", "ng", "instance", "ack", "rew", " RAW", "stream", " hex", "local", "load", "initial", "Raw", "def", "binary", "full", "clean", "response", "unknown", "unsigned", "content", "buffer", "serial", "enc", "custom", "block"], "hash": ["secret", "crypt", "text", "ash", "array", "auth", "log", "url", "message", "image", "html", "build", "sha", "rh", "empty", "data", "version", "her", "hex", "sum", "password", "h", "key", "row", "code", "kh", "header", "base", "mac", "id", "cache", "string", "full", "Hash", "response", "value", "buffer", "block"]}}
{"id1": "16557837", "id2": "6501291", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["copyFromFile", "transferfromTo", "copyDirFile", "copyfromTo", "transferfromWith", "transferFromFile", "copyFromFrom", "transferfromFile", "transferFromFrom", "copyfromFile", "copyFileTo", "copyfromWith", "copyfromFrom", "copyFromWith", "transferFromTo", "copyDirWith", "copyFileFrom", "transferfromFrom", "copyFileFile", "copyDirTo", "copyDirFrom", "transferFromWith", "copyFileWith"], "srcFile": ["destPage", "srcSourceFile", "destClass", "srcPath", "rcPage", " srcfile", " srcSourceFile", "destFiles", "rcDir", "rcSourceFile", "srcDir", "srcClass", "srcFiles", " srcPath", "srcPage", "srcfile", "rcfile", "destDir", "sourceFile", "rcPath", "sourcefile", " srcDir", " srcPage", "sourceClass", "sourceSourceFile", "sourceFiles", " srcFiles", "destfile", "sourcePath", "destSourceFile", "rcFile", "rcFiles", "sourceDir", " srcClass"], "destFile": ["destPage", " destPage", "srcFilename", "destPlace", " destFine", " destSourceFile", "defaultDir", "southDir", "destFiles", "targetDir", "targetPath", "DestSourceFile", "srcDir", " destinationDir", " destinationFiles", " destinationFile", "destPath", "destFilename", " destPlace", "targetFiles", "DestFile", "destDir", "defaultfile", " destinationFine", " destinationfile", "Destfile", "DestPath", " destfile", "wbSourceFile", "srcPlace", "wbFiles", "southPlace", "destFine", "destroyFilename", "DestDir", "targetFile", "wbFile", "defaultFile", " destFiles", "southFilename", "DestFilename", "southFile", " destFilename", "wbFilename", "destroyPage", "destfile", "destroyFine", " destDir", "DestFiles", "destSourceFile", "destroyFile", " destPath", "defaultFiles", " destinationPage", " destinationFilename"], "in": ["ins", "url", "image", "In", "b", "n", "connection", "init", "like", "io", "inc", "socket", "part", "channel", "f", "input", "o", "din", "IN", "inn", "index", "Out", "lin", "ci", "h", "cin", "i", "is", "win", "source", "reader", "rin", "pull", "inside", "co", "nin", "login", "inner", "min", "r", "id", "ac", "con", "c", "bin", "err", "file", "pin", "ini", "as", "x", "again", "p", "isin"], "out": ["ex", "writer", "image", "parent", "term", "socket", "part", "o", "conn", "win", "cli", "outs", "cache", "string", "exec", "file", "err", "list", "net", "pre", "lib", "query", "page", "resource", "server", "call", "In", "connection", "this", "inc", "group", "no", "input", "error", "key", "code", "dump", "ger", "point", "c", "down", "json", "post", "to", "prefix", "gen", "log", "url", "ico", "cmd", "io", "outer", "off", "store", "sys", "sync", "channel", "IN", "Out", "job", "comment", "co", "user", "bin", "obj", "extra", "up", "ou", "diff", "again", "note", "write", "copy", "lock", "session", "raw", "output", "source", "client", "inner", "base", "window", "name", "OUT", "auto", "state", "line", "doc", "ext"], "fis": ["FIs", "fais", "pIs", "hos", "fi", "gais", "lis", "cfoss", "Fos", "flos", "Fris", "fris", "pos", "flios", "cfis", " fi", " fIs", " fris", "fross", "gis", "frris", "pis", "his", "fios", "li", "pris", "fIs", " foss", "hi", "flis", "gi", "los", "cfris", " fais", "fli", "cfos", "gos", "foss", "hios", "lais", "cfios", "cfi", "fros", "Fis"], "fos": ["tis", "fo", "infose", "fose", "flout", "poes", " faos", "fout", "eis", "boes", "lis", "bics", "Fos", "flos", "eoss", "loss", "tics", "pos", "faos", "infos", " fics", "flo", "Fo", "bis", "bos", "eose", "go", "infoss", " fout", "gose", "pis", " fose", " fo", "flose", "fics", "lose", "Faos", "tos", "po", "los", "infis", "gos", "foss", " foes", "Foes", "foes", "gout", "eos", "toes", "paos", "Fis"], "srcModified": ["srcMetressed", "srcMinIFIED", "srcVered", "srcXed", "sourceModify", " srcModification", "srcModined", "srcmodressed", "srcVerified", "srcModIFIED", "srcXification", "srcModressed", "srcmodIFIED", "srcXified", "srcmodify", "srcModification", "sourceMinify", "sourceModIFIED", "sourceMinified", " srcModressed", "srcMetified", "srcModify", "sourceMinIFIED", " srcModed", "srcMetification", "srcModed", "srcVerification", "srcmodification", " srcModined", "sourceModified", "sourceMinification", "sourceModification", "srcMinified", "srcmodified", " srcModIFIED", "srcMinify", "srcVerined", "srcMetIFIED", "srcMinification", "srcXined"]}}
{"id1": "4398382", "id2": "9081749", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"digest": ["digress", "mdester", "generests", "encester", "Digester", "Digest", " digested", "mdested", " digress", "generester", "encse", "generest", "generested", " digests", " digester", "digse", "digester", "digests", "encest", "digested", "Digse", "encress", "mdest", "Digress", " digse", "mdests"], "algorithm": ["challgo", "algo", "Alignment", " algo", " alenge", "argebra", "malignment", "Aloding", "algebra", "alenge", "aroding", "Alenge", "Algorithm", "arignment", "malgorithm", "alignment", "aloding", "challgorithm", " algebra", "maloding", "Algo", "malgebra", "argorithm", "challgebra", "Algebra", "challenge"], "text": ["attribute", "url", "txt", "message", "image", "struct", "length", "connection", "letter", "data", "username", "sequence", "output", "input", "str", "password", "bytes", "test", "code", "source", "config", "TEXT", "object", "address", "token", "string", "name", "pattern", "path", "word", "content", "buffer", "value", "format", "ext", "feed", "secret", "Text"], "mDigest": ["mdigester", "MDigest", "mSignenge", "mEncast", " mGast", "mDester", "MDester", "mPostested", "mCodest", "mDigEST", " mDigester", "mSignast", "mdiger", "amDigest", "mDEST", "MDigEST", "mDesignest", " mDigast", "mDigast", "MDgest", "mdigest", " mGester", "mCodener", "mSignester", "mdigener", "MDiger", "mDigested", "mDest", "MDigester", "mEncge", "mGester", "mSignge", "mDigenge", "mdigested", "mDesigngest", "mEncester", "mGest", "mSignest", "mPostener", " mDigge", " mGge", "mDigester", "mGge", "amPostest", "amPostested", "mDer", "MDest", "mDesignester", "mDesigner", "mDigge", "MDigenge", "amDigested", "mDigener", "MDiggest", "mDiggest", "mGast", "mCodested", "amPostener", " mGest", "mdiggest", "MDer", "mDgest", "amDigener", "mPostest", "mDenge", "mEncest", "mDiger", "mSignEST"], "raw": ["buf", "partial", "original", "array", "default", "message", "image", "null", "none", "data", "RAW", "output", "wrap", "result", "input", "hex", "container", "row", "instance", "source", "internal", "initial", "Raw", "binary", "full", "json", "response", "clean", "unsigned", "content", "buffer", "orig", "serial", "enc", "feed"], "encoder": ["ecoded", "decode", "ecoder", "enoder", "decoding", "eccode", "encode", " encoded", "Encode", "decoder", "enccode", " encoding", "enoding", "enode", "Encoded", "encoded", "Encoder", "encoding", "ecoding", " encode", "Encoding", "deccode", "ecode"]}}
{"id1": "5148212", "id2": "18782385", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["createFile", "transferDir", " copyFiles", "copyDir", "copyfile", " copyfile", "createfile", "createFiles", "transferfile", "copyFiles", " copyDir", "createDir", "transferFiles", "transferFile"], "src": ["proxy", "req", "url", "uri", "resource", "image", "view", "loc", "rc", "cdn", "remote", "project", "ie", "sb", "impl", "input", "archive", "rb", "ref", "href", "s", "download", "source", "config", "filename", "stream", "l", "slice", "r", "sc", "ource", "file", "obj", "upload", "RC", "name", "gb", "dist", "gz", "loader", "sl", "path", "http", "fp", "img"], "dest": [" Dest", "p", "url", "txt", "parent", "b", "style", "master", "null", "Dest", "destroy", "cdn", "loc", "flat", "data", "later", "this", "project", "output", "folder", "du", "dep", "zip", "route", "archive", "exp", "d", "dat", "done", "comb", " destination", "wd", "home", "temp", "rest", "source", "dir", "config", "tmp", "di", "filename", "target", "delete", "opt", "de", "slice", "id", "trans", "desc", "v", "file", "obj", "dist", "dc", "name", "origin", "wb", "path", "front", "orig", "doc", "img"], "bufSize": ["bufLen", " bufLen", "ufSize", "buffsize", "buffLen", " bufCount", "bufsize", "bufName", "buffName", "ufsize", "buffSize", " bufsize", "bufCount", "bufferCount", "ufCount", "bufferLen", "bufferName", "buffCount", "buffersize", "ufName", "bufferSize", "ufLen"], "force": ["replace", "delay", "play", "write", "parent", "count", "apply", "style", "Force", "remote", "act", "reason", "like", "die", "store", "child", "forces", "sync", "allow", "enable", "ride", "orce", "route", "effect", "forced", "only", "ignore", "require", "flush", "pull", "push", "keep", "send", "forcing", "cache", "hard", "load", "file", "err", "kill", "want", "service", "deep", "fix", "auto", "front", "false", "close", "secure", "use", "dirty", "cop"], "f": ["fd", "m", "fn", "uf", "u", "e", "j", "b", "g", "n", "fb", "folder", "fm", "o", "d", "feed", "h", "fs", "s", "rf", "bf", "i", "dir", "l", "self", "ff", "base", "fx", "r", "cache", "v", "c", "file", "fc", "t", "w", "path", "F", "fe", "fp", "p", "df"], "buffer": ["border", "wave", "buf", "page", "pad", "url", "write", "resource", "message", "length", "null", "b", "offset", "data", "Buffer", "raw", "sequence", "limit", "result", "input", "batch", "bytes", "flush", "iter", "source", "reader", "size", "buff", "seed", "number", "base", "queue", "slice", "position", "cache", "bin", "binary", "reference", "uffer", "transfer", "value", "feed", "bb"], "read": ["ink", "k", "text", "play", "write", "se", "length", "count", "copy", "build", "ok", "n", "view", " Read", "lex", "io", "data", "sync", "reading", "inc", "raw", "connect", "check", "input", "reads", "READ", "set", "index", "Read", "run", "feed", " write", "end", "key", "fill", "seek", "pass", "i", "add", "iter", "max", "reader", "size", "parse", "ip", "len", "ad", "send", "r", "ind", "id", "skip", "show", "load", "exec", "c", "start", "select", "find", "wait", "get", "x", "sleep", "use", "block", "open", "rate"], "in": ["m", "request", "ex", "ins", "url", "In", "b", "ax", "n", "connection", "thin", "init", "child", "inc", "socket", "gin", "impl", "input", "din", "IN", "inn", "lin", "s", "conn", "pass", "cin", "download", "i", "source", "win", "rin", "reader", "kin", "pull", "client", "nin", "l", "a", "login", "inner", "r", "id", "token", "ac", "bin", "con", "c", "err", "re", "up", "pin", "ini", "as", "or", "again", "on", "p"], "out": ["to", "ex", "log", "writer", "one", "write", "server", "image", "parent", "null", "b", "plain", "n", "connection", "init", "off", "io", "data", "outer", "sync", "inc", "socket", "output", "gin", "cookie", "exp", "o", "sum", "Out", "error", "conn", "pass", "client", "ne", "nin", "co", "inner", "outs", "user", "object", "id", "cache", "exec", "bin", "v", "obj", "err", "c", "name", "other", "up", "net", "OUT", "w", "plus", "again", "line", "lib", "ext"]}}
{"id1": "15645004", "id2": "19109981", "code1": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unzip": ["freepatch", "freearchive", "unpatch", " unress", " unpatch", "Unarchive", "Unzip", " unarchive", "Unress", "freeress", "unress", "freezip", "Unpatch", "unarchive"], "filename": ["fd", "SourceFile", "fn", "prefix", "url", "txt", "FILE", "uri", "ssl", "connection", "sheet", "il", "username", "socket", "journal", "folder", "f", "document", "zip", "via", "archive", "nil", "out", "download", "xml", "wl", "source", "metadata", "directory", "l", "files", "queue", "Filename", "kl", "string", "file", "upload", "name", "loader", "binary", "File", "path", "location", "json", "word", "iterator", "manager", "fp", "database"], "in": ["into", "rec", "ln", "ins", "ssl", "fin", "In", "io", "info", "inc", "ie", "gin", "impl", "zip", "oin", "input", "vin", "din", "IN", "lin", "inn", "zin", "inas", "out", "cin", "is", "i", "win", "kin", "reader", "source", "inside", "nin", "login", "inner", "internal", "cache", "bin", "file", "con", "ilo", "obj", "pin", "ini", "arin", "again", "afi", "orig", "line", "isin"], "entry": ["enter", "page", "log", "url", "install", "module", "image", "server", "connection", "cell", "info", "ge", "je", "si", "child", "parser", "inc", "ie", "part", "folder", "it", "zip", "archive", "exp", "ga", "ace", "draft", "ent", "country", "key", "out", "row", "Entry", "container", "element", "jo", "plugin", "source", "parse", "reader", "record", "section", "directory", "article", "inner", "de", "internal", "object", "id", "string", "file", "obj", "name", "service", "entity", "next", "path", "auto", "or", "lc", "ident", "office", "iterator", "line", "feed", "database", "ry"], "first_entry": ["first_connection", " first_connection", "first_zip", "empty_ent", " first_element", " first_Entry", " first_ent", "first_section", "firstxreader", "firstxEntry", "empty_section", "first_enter", "first_ent", "first_Entry", "firstxentry", "firstxconnection", "first_reader", "first_element", "empty_enter", " first_zip", " first_reader", "empty_entry"], "subdir": [" subfile", " subDir", "superdir", "subfolder", "ubdir", "ubDir", "superDir", "partfile", " subclass", "singdir", "singDir", "ubclass", " subdb", "Subdist", "singdb", "Subdirectory", "SubDir", " subfolder", "ubfile", " subdist", "partDir", "singclass", " subdirectory", "subclass", "ubdirectory", "subDir", "subfile", "Subfile", "ubfolder", "partdir", "subdb", "subdirectory", "Subdir", "superfolder", "superfile", "subdist", "partdirectory", "ubdb", "ubdist"], "dir": ["prefix", "direction", "log", "url", "uri", "module", "parent", "build", "dr", "loc", "lock", "manager", "DIR", "rc", "folder", "group", "du", " directory", "spec", "area", "zip", "Directory", "coll", "finder", "draft", "done", "sort", "wd", "home", "pkg", "iter", "directory", "target", "tree", "db", "base", "id", "div", "desc", "ir", "file", "window", "dist", "root", "lib", "host", "diff", "domain", "path", "Dir", "mod", "http", "doc"], "outfile": [" outfiles", "fullfolder", "exurl", " outfolder", " outf", "exdir", "infile", "fulldir", "Outfiles", "Outpath", "inpath", " outFile", "Outurl", "exFile", "inFile", "outputFile", "outpath", "Outfolder", "execf", "indir", "Outdir", "infiles", "outfolder", "fullfile", "fullf", "inurl", "outf", "Outf", "outurl", "outfiles", "outputpath", "outFile", "Outfile", "execdir", "outputdir", "execfolder", "execfile", "OutFile", "outputfile", "exfile"], "outdir": ["Outdirectory", " outDir", " outfolder", "infile", "outdirectory", "outputfolder", "outDir", "outputdirectory", " outdirectory", "Outfolder", "indirectory", "indir", "inDir", "Outdir", "outfolder", "OutDir", "infolder", "Outfile", "outputdir", "outputfile"], "fo": ["wo", "FO", "ro", "ico", "gio", "os", "io", "info", "mo", "iso", "osa", "oe", "so", "flo", "bis", "o", "olo", "prof", "bo", "ko", "tra", "ao", "jo", "ho", "co", "zo", "fam", "po", "obj", "oo", "ob", "op", "lo", "obo"], "bos": ["tis", "ros", "dos", "rows", "fits", "kos", "obs", "os", "bh", "uds", "osi", "iso", "osa", "bc", "aos", "oss", "zos", "obi", "bs", "so", "flo", "bis", "lins", "bott", "ko", "bo", "fs", "oS", "ios", "bes", "zo", "opus", "oos", "outs", "bits", "mos", "los", "bin", "bas", "gb", "ob", "ops", "lo", "bi", "oops", "obo", "ubis"], "read": ["pe", "text", " load", "play", "pack", "write", "e", "call", "length", "count", " Read", "copy", "n", "en", "scan", "io", "child", "allow", "sync", "inc", "raw", "pos", "ride", "shape", "connect", "check", "input", "reads", "READ", "index", "Read", "run", "seek", "fill", "tell", "end", "pass", "i", "add", "parse", "create", "reader", "size", "use", "ip", "send", "ind", "skip", "load", "c", "start", "find", "select", "wait", "next", "get", "transfer", "x", "put", "buffer", "level", "current", "feed", "open", "readable"], "data": ["DATA", "pad", "ada", "message", "image", "one", "write", "length", "style", "body", "empty", "raw", "no", "result", "input", "str", "d", "dat", "batch", "bytes", "results", "i", "memory", "reader", "size", "number", "da", "slice", "cache", "address", "load", "bin", "start", "alpha", "aa", "next", "response", "value", "buffer", "zero", "feed", "block"], "read_position": ["read_length", "read_limit", " read_limit", " read_length", "read_pos", " read_pos"]}}
{"id1": "11562173", "id2": "14231545", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkFileStream", " checkOutputChannel", "checkOutputStream", "checkOutputSteam", "checkOutputChannel", "checkIOStream", " checkInputSteam", "checkFileSteam", "checkIOstream", "checkFileChannel", " checkInputChannel", " checkOutputstream", " checkInputstream", "checkOutputstream", " checkOutputSteam", "checkIOChannel", "checkIOSteam", "checkInputSteam", "checkFilestream", " checkOutputStream", "checkInputChannel", "checkInputstream"], "in": ["into", "ins", "image", "In", "connection", "io", "data", "inc", "input", "din", "IN", "inn", "index", "is", "source", "ack", "reader", "src", "login", "inner", "min", "bin", "c", "con", "ic", "up", "ini", "as", "x", "plus", "comp", "again", "p", "isin"], "cmp": ["conv", "asc", "prefix", "np", "roc", "mp", "omp", "cp", "rc", "pixel", "loc", "prev", "cho", "spec", "cpp", "coll", "ch", "index", "sort", "ci", "cb", "clip", "code", "cc", "ctrl", "comment", "upp", "config", "co", "cache", "match", "pc", "amp", "c", "mom", "sup", "up", "ctx", "pre", "diff", "proc", "op", "lc", "comp", "cs", "cup", "fp", "p", "cop", "com"], "all": ["asc", "partial", "array", "default", "one", "call", "parent", "null", "except", "best", "none", "acl", "each", "allow", "not", "valid", "coll", "All", "sum", "cl", "and", "only", "process", "total", "al", "l", "a", "ann", "any", "local", "match", "ALL", "alpha", "list", "am", "global", "full", "both", "auto", "always", "p"], "stream": ["null", "speed", "Stream", "form", "this", "steam", "port", "raw", "socket", "channel", "output", "model", "impl", "document", "result", "input", "stack", "coll", "feed", "test", "temp", "instance", "progress", "source", "ack", "roll", "ream", "client", "reader", "self", "track", "src", "user", "round", "transform", "object", "trans", "string", "v", "platform", "up", "per", "host", "context", "pool", "response", "cont", "wrapper", "comp", "iterator", "sw"], "out": ["prefix", "array", "image", "copy", "null", "parent", "b", "io", "outer", "data", "project", "this", "sync", "inc", "part", "not", "output", "result", "block", "exp", "o", "index", "sum", "Out", "comment", "point", "outs", "user", "v", "bin", "c", "obj", "name", "list", "other", "option", "full", "OUT", "up", "extra", "response", "x", "again", "p"], "i": ["k", "u", "uri", "e", "j", "b", "n", "fi", "init", "io", "info", "si", "f", "it", "index", "d", "end", "key", "type", "ci", "oi", "ji", "h", "abi", "multi", "li", "di", "l", "mi", "hi", "pi", "xi", "slice", "r", "ind", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "ix", "strength", "ini", "ii", "ui", "x", "bi", "qi", "lc", "p"]}}
{"id1": "19944975", "id2": "3330775", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static JSONObject getJSONData(String url) throws JSONException {\n        JSONObject jObject = null;\n        InputStream data = null;\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        URI uri;\n        try {\n            uri = new URI(url);\n            HttpGet httpGet = new HttpGet(uri);\n            HttpResponse response = httpClient.execute(httpGet);\n            data = response.getEntity().getContent();\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader;\n            reader = new BufferedReader(new InputStreamReader(data), 8192);\n            while ((line = reader.readLine()) != null) builder.append(line);\n            reader.close();\n            jObject = (JSONObject) new JSONTokener(builder.toString()).nextValue();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return jObject;\n    }\n", "label": 0, "substitutes": {"writeConfiguration": ["saveReport", "WriteConfiguration", "writeReport", " writeReport", " writeSection", "writeSection", "saveConfiguration", "WriteConfig", "WriteSection", "saveSection", " writeConfig", "saveConfig", "writeConfig", "WriteReport"], "out": ["at", "m", "prefix", "res", "ex", "writer", "report", "resource", "write", "plain", "server", "parent", "scope", "connection", "init", "io", "this", "project", "sync", "external", "output", "exp", "o", "inas", "IN", "password", "Out", "key", "conn", "xml", "temp", "flush", "reader", "config", "client", "filename", "dump", "inner", "base", "outs", "user", "object", "string", "exec", "file", "obj", "c", "err", "name", "list", "window", "w", "OUT", "path", "pool", "again", "line", "lib", "ext"], "url": ["page", "uri", "ssl", "resource", "ll", "server", "image", "b", "connection", "rel", "io", "org", "data", "channel", "f", "URL", "conn", "xml", "source", "api", "config", "stream", "l", "web", "base", "r", "object", "address", "string", "file", "service", "ob", "sl", "path", "Url", "location", "http", "feed", "open"], "in": ["ins", "ssl", "resource", "In", "copy", "b", "n", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "xml", "cin", "i", "is", "rin", "source", "reader", "win", "kin", "inside", "nin", "stream", "a", "login", "cms", "inner", "min", "r", "id", "ac", "bin", "c", "err", "file", "pin", "ini", "as", "again", "serv", "isin"]}}
{"id1": "19206412", "id2": "2217889", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"md5String": ["md6Str", "md6String", "md4String", " md5Str", "md6string", "md4string", "md512string", "md5string", " md512Str", "md512String", "md6Bytes", "md5Str", "md512Bytes", " md5string", " md512Bytes", " md512string", " md512String", "md4Str", "md5Bytes", " md5Bytes", "md512Str", "md4Bytes"], "str": ["kr", "Str", "text", "fr", "txt", "arr", "STR", "e", "stri", "url", "st", "star", "dr", "data", "msg", "this", "f", "result", "exp", "bytes", "out", "s", "dict", "pass", "self", "er", "strings", "tr", "r", "string", "br", "err", "obj", "name", "re", "sr", "sp", "hr", "enc", "doc", "char"], "md": ["m", "hd", " MD", "Cmd", " Md", "mp", "cmp", "cmd", "data", "mo", "um", "dig", "dd", "rpm", "map", "mc", "mag", "d", "vd", "sum", "od", "me", "ms", "hm", "mb", "code", "amd", "mg", "dm", "bd", "wd", "metadata", "pd", "MD", "db", "ad", "mac", "mand", "mm", "sm", "ma", "am", "ld", "mk", "pm", "mt", "cd", "mu", "mail", "mod", "dh", "df"], "hash": ["filter", "ash", "array", "url", "arr", "image", "html", "count", "sha", "body", "rh", "dot", "part", "search", "range", "f", "her", "check", "hex", "sum", "index", "error", "key", "h", "code", "ver", "kh", "memory", "print", "header", "number", "base", "tr", "id", "cache", "address", "chip", "bin", "host", "ha", "diff", "Hash", "sh", "value", "block", "char"], "hexChars": ["hexKhashes", "hashCHashes", "hexCHashes", "hexCHacters", " hexChashes", "hexchashes", "hexCharacters", "hashchARS", "hashChash", "hexKhash", "hashchases", "hexCHases", "hexChashes", "hexCharashes", "hexCharats", "hexCharars", "hashCHARS", "hexCHats", " hexChats", "hexCash", "hexChARS", "hashchacters", "hexChats", "hexChases", "hashChars", "hexCharases", "hexchacters", " hexchARS", "hexchats", " hexchashes", "hashCHash", "hexKhars", "hashChacters", "hexChacters", "hashChashes", "hexchars", "hexchARS", " hexchats", "hexCHars", " hexchars", "hashChases", "hexCHash", "hexChash", "hashCHars", "hashchars", "hexCharARS", " hexChARS", "hexKhARS", "hexCashes", "hashChARS", "hexCars", "hexCHARS", "hexchases", "hexCARS"], "res": ["css", "cons", "resp", "ros", "req", "rss", "des", "rows", "arr", "details", "ss", "ps", "rs", "ress", "rev", "data", "reg", "result", "es", "RES", "vs", "pres", "us", "bytes", "out", "s", "Rs", "RS", "results", "rus", "vals", "ras", "Result", "rez", "r", "cache", "string", "err", "ris", "re", "resolution", "Res", "rules", "ret", "response", "cs", "abs", "rex", "Results", "pers", "bs", "vers"], "i": ["k", "m", "u", "uri", "e", "j", "length", "b", "io", "info", "si", "ie", "part", "in", "field", "f", "it", "o", "index", "d", "ci", "h", "oi", "iu", "ji", "code", "abi", "temp", "multi", "y", "li", "a", "di", "l", "ip", "pi", "xi", "base", "hi", "id", "ti", "v", "gi", "c", "ri", "ix", "I", "ai", "phi", "diff", "ii", "ui", "x", "bi", "qi", "mu", "p"]}}
{"id1": "9805906", "id2": "19096138", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["save", "ln", "copy", "info", "data", "store", " dumping", "f", " dumps", "zip", "all", "out", "download", "flush", " dumped", "dir", "db", "files", "load", "println", "diff", "transfer", "ump", "update", "Dir", "export", "df"], "source": ["uri", "unit", "resource", "server", "se", "core", "parent", "view", "connection", "remote", "this", "series", "Source", "site", "input", "ources", "s", "sin", "iter", "src", "stream", "slave", "base", "slice", "address", "string", "ource", "file", "start", "service", "SOURCE", "current", "scene", "http", "use", "from"], "target": ["replace", "to", "resource", "large", "parent", "dest", "null", "master", "connection", "project", "port", "follow", "output", "alias", "it", "result", "effect", "template", "out", "settings", "top", "src", "Target", "base", "table", "object", "address", "arget", "file", "platform", "root", "goal", "next", "host", "path", "pointer", "office", "enemy", "force", "database"], "is": ["ls", "ins", "gets", "isi", "isl", "ps", "ori", "lis", "info", "mis", "obs", "io", "nis", "ics", "iso", "oss", "in", "es", "bis", "bos", "IS", "us", "ists", "oses", "ens", "s", "iris", "ws", "ios", "i", "im", "ip", "ses", "iss", "ais", "ris", "has", "Is", "ops", "ai", "ui", "as", "or", "isa", "cs", "abs", "opens", "ois", "bs", "was", "its"], "os": ["ros", "oa", "dos", "nos", "ss", "acs", "ps", "io", "ori", "obs", "ies", "osi", "oss", "cos", "aos", "pos", "ose", "es", "ows", "o", "bos", "vs", "us", "oses", "ips", "fs", "s", "ols", "ens", "ues", "ios", "i", "Os", "oos", "oes", "outs", "los", "ais", "ops", "as", "or", "cs", "bs", "its", "boot", "ks", "OS", "ds"], "done": ["loaded", "after", "enabled", "running", "odo", "one", "complete", "ready", "got", "nice", "none", "started", "die", "empty", "data", "later", "last", "part", "gone", "once", "progress", "finished", "future", "made", " finished", " Done", "foo", "checked", "Done", "de", "doing", "due", "disabled", "confirmed", "defined", "next", "expected", "current", "always", "did", "yes", "dirty", "dad"]}}
{"id1": "4468255", "id2": "21656668", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "log", "write", " cp", "cp", "info", "link", "sync", "zip", "paste", "split", "clone", "clip", "download", "process", "move", "cat", "ignore", "Copy", "create", "parse", "delete", "dump", "load", "file", "share", "get", "ssh", "transfer", "put", "update", "opy", "cop"], "from": ["at", "original", "log", "From", "url", "without", "one", "resource", "e", "se", "html", "parent", " form", "connection", "form", "os", "ce", "io", "empty", "data", "back", "this", "link", "before", " the", " file", "old", "part", "range", "f", "entry", "zip", "so", "o", "missing", "the", "code", "source", "add", "with", "dir", "client", "config", "stream", "er", "of", "base", "user", "id", "ate", "string", "file", "c", "start", "name", "by", "vol", "left", "context", "path", "normal", "or", "http", "open"], "to": ["one", "parent", "null", "data", "socket", "not", "termin", "tom", "so", "flo", "o", "temp", "target", "de", "cache", "po", "token", "file", "root", "dis", "front", "on", "pe", "resource", "disk", "connection", "two", "back", "tto", "no", "all", "template", "jo", "TO", "dir", "path", "eto", "x", "database", "too", "io", "sync", "site", "storage", "me", "process", "top", "size", "db", "toc", "user", "by", "t", "plus", "To", "http", "se", "system", "os", "output", "about", "stat", "source", "client", "base", "son", "load", "name", "sp", "auto", "as", "or", "office", "comp", "yet", "but", "line", "p"], "result": ["replace", "res", "url", "default", "mask", "report", "arr", "length", "count", "math", "ok", "term", "rc", "lock", "event", "die", "info", "data", "method", "allow", "part", "follow", "search", "member", "entry", "status", "var", "effect", "fail", "valid", "sum", "error", "date", "val", "test", "accept", "pass", "ver", "results", "cur", "comment", "source", "future", "true", "work", "Result", "mer", "sign", "r", "found", "cache", "match", "br", "ure", "err", "card", "success", "continue", "ult", "up", "diff", "ret", "function", "current", "plus", "compl", "force", "use"], "subFiles": [" subDir", "newsParts", " subParts", "ubfiles", "ubDir", "subFs", "newPages", "ubFiles", "partfiles", " subPages", "singfiles", "SubTokens", " subFile", "newsfiles", " subContents", "subPages", "singFiles", "subTokens", " subfiles", "SubContents", "subContents", "ubContents", "partParents", "SubPages", "ubFile", "Subfiles", "SubFiles", "subParents", "singParents", "newfiles", "SubFile", " subParents", "subfiles", "SubParts", "newFile", "subDir", "newParts", "subParts", "partFs", "partFiles", "newsFiles", "subFile", "ubPages", "newFiles", "newsTokens", " subTokens", " subFs", "singFs"], "i": ["k", "p", "u", "uri", "e", "j", "b", "n", "ori", "io", "si", "ie", "f", "it", "iv", "o", "index", "d", "ci", "h", "oi", "iu", "key", "s", "is", "multi", "y", "li", "di", "a", "mi", "ip", "pi", "hi", "xi", "l", "slice", "inner", "id", "ti", "v", "gi", "c", "name", "ix", "I", "ai", "phi", "ini", "ii", "ui", "x", "bi", "q", "ri"], "newDir": ["newDIR", "NewFolder", "newJar", "NewDirectory", " newFile", " newD", "NewFile", " newQu", "nextFile", "oldFile", "subD", "oldFolder", "newFolder", "nowDir", " newJar", "NewD", "nowDIR", " newDirectory", "nowFolder", "subDirectory", "nowDirectory", " newFolder", "newQu", " newDIR", "nextFolder", "subQu", "NewDir", "nextDir", "newDirectory", "subJar", "oldDir", "newFile", "oldDirectory", "subDir", "NewJar", "subFile", "oldDIR", "subFolder", "nextQu", "nextDirectory", "newD"], "in": ["m", "ex", "ins", "url", "e", "image", "In", "b", "lock", "init", "thin", "data", "this", "on", "inc", "ie", "socket", "part", "f", "gin", "it", "input", "o", "din", "IN", "lin", "inn", "index", "conn", "cin", "is", "win", "pull", "reader", "source", "a", "nin", "l", "login", "inner", "min", "r", "id", "bin", "file", "c", "con", "err", "re", "up", "diff", "pin", "ini", "again", "serv", "isin"], "out": ["at", "ex", "log", "writer", "write", "one", "call", "b", "n", "lock", "off", "io", "sync", "img", "socket", "inc", "on", "output", "all", "exp", "o", "sum", "ch", "Out", "conn", "cat", "with", "client", "co", "inner", "base", "outs", "can", "exec", "bin", "file", "err", "c", "obj", "name", "up", "w", "net", "OUT", "ou", "post", "op", "word", "cy", "again", "line", "serv", "lib", "ext"], "fileLength": [" fileLen", "baseSize", "baselength", "pagelength", " fileName", "pageSize", "lineSize", "fileName", "FileLen", "fileLen", "Filelength", "FileSize", "baseLen", "pageLength", "lineLength", "filelength", "FileLength", "fileSize", "linelength", " fileSize", "baseLength", "pageName", "lineName", " filelength"], "charBuff": [" charMatrix", " charBuffer", "pairMatrix", "charMatrix", "pairBuffer", "stringBuff", "stringBuffer", "charBuffer", "pairBuff", "stringMatrix"], "len": ["ln", "fl", "lf", "fin", "cmp", "n", "en", "rev", "part", "pos", "ni", "nt", " Len", "split", "Len", "val", " split", "iter", "li", "l", "lit", "id", " pos", "bin", "start", "name", "line"], "oneChar": ["nextCor", "onechar", "zeroCharacter", "singlechar", "oneCar", "oneCor", "zeroCor", "singleCor", "oneCh", " oneCh", "nextChar", "zeroChar", "singleCar", " onechar", "nextCar", " oneCharacter", "fourCor", "fourchar", "singleCharacter", "fourChar", "oneCharacter", "singleChar", "fourCharacter", " oneCor", " oneCar", "zerochar", "eachChar", "nextCh", "eachCor", "singleCh", "eachCharacter", "eachchar"]}}
{"id1": "1798720", "id2": "7908169", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"save": ["pack", "install", "Save", "report", "apply", "build", "copy", "data", "store", "archive", "clone", "process", "move", "create", "saving", "dump", "transform", "make", "change", "load", "upload", "transfer", "release", "setup", "update", "stage", "open"], "packageName": ["directoryDir", "packageNames", "pluginPart", " packagename", "moduleInfo", "packagePath", "directoryNames", "directoryName", "moduleDir", "packagename", "PackageDir", "directoryInfo", "PackageNames", "packageInfo", " packageNames", " packagePart", "packagePart", "moduleName", " packagePath", "sourcename", "modulePath", "pluginName", "pluginDir", "pluginPath", "PackageName", "PackageInfo", "sourcePath", "sourceName", "PackagePath", "directoryPath", "sourceDir", " packageInfo", "directoryPart", "directoryname"], "fileContents": ["imageHours", "getNames", "fileParts", "FileSources", "FileTextures", " fileContent", "FileContents", "getParts", "FileNames", "ileSources", "ileNames", "FileParts", "imageNames", "FileHours", "fileContent", " fileTextures", "getContent", "ileContents", " fileSources", "fileSources", " fileParts", "fileHours", "fileTextures", "imageParts", "FileContent", " fileHours", "imageContents", "ileTextures", "getContents"], "fileNames": ["fName", "filenames", "fullContents", "playName", "playContents", "FileContents", "viewNames", " fileName", "FileNames", "viewTypes", "FileNumbers", "fNames", "fNumbers", "pageTypes", "fileNumbers", "fileName", "FileTypes", "playNames", "fTypes", "logNames", "viewnames", "logTypes", "pageNames", "fullTypes", "fullNames", "pagenames", " filenames", "logName", "FileName", "fileTypes", " fileNumbers", "fullName", " fileTypes", "logContents"], "dirBase": ["packageRoot", "dirDir", "DirKit", "directoryDir", "packagebase", "directoryBase", "directoryKit", "DirRoot", "packagePath", "dirBased", " dirPath", "folderBased", " dirbase", "dirbase", "DirBase", "directoryBased", "moduleDir", "moduleKit", "dirKit", "directorybase", "DirPath", "folderDir", "folderBase", "dirRoot", "dirPath", "Dirbase", "packageBase", "DirDir", "moduleBased", "moduleBase", "folderbase", "modulebase", " dirRoot"], "packageDir": ["directoryDir", "packageDirectory", " packageFile", " packageFolder", " packageDirectory", "parentFile", "folderLib", "packageLib", "packagePath", "PackageDirectory", "directoryUrl", "parentDir", "packageFolder", " packageBase", "moduleDir", "PackageDir", "packageFile", "folderDir", "folderBase", "directoryDirectory", "moduleLib", "packageUrl", "parentFolder", " packagePath", "parentUrl", "modulePath", "PackageFile", "directoryFolder", "packageBase", " packageLib", "folderPath", " packageUrl", "moduleBase", "PackagePath", "directoryPath", "directoryFile"], "created": ["loaded", "established", "raised", "authorized", "founded", "null", "failed", "edited", "updated", "successful", "activated", "released", "icated", "required", "paid", "creator", "result", "generated", "aaaa", "called", "added", " existed", " Created", "worked", "create", "made", "true", "found", "owned", "Created", "creation", "confirmed", "produced", "formed", "left", "existent", "path", "were", "used", "ed", "needed", "controlled"], "currentPath": ["currentpath", " currentLocation", " currentPage", "CurrentPath", "currentRoot", "newPath", "newpath", " currentpath", "currentPage", "currentLocation", "currentlyPath", " currentDirectory", "newRoot", "CurrentRoot", "currentlypath", " currentRoot", "currentDirectory", "CurrentPage", "CurrentLocation", "CurrentDirectory", "newLocation", "currentlyPage", "Currentpath", "currentlyDirectory"], "i": ["k", "p", "u", "uri", "z", "e", "j", "isi", "b", "n", "fi", "init", "ori", "io", "info", "si", "ie", "part", "f", "it", "index", "d", "ci", "iu", "oi", "h", "ji", "me", "key", "s", "multi", "y", "li", "di", "mi", "ip", "pi", "xi", "hi", "eni", "slice", "inner", "yi", "id", "ti", "gi", "v", "c", "start", "name", "ix", "I", "ai", "phi", "zi", "ini", "ii", "ui", "bi", "x", "qi", "mu", "current", "ri"], "file": ["book", "pe", "http", "log", "uri", "unit", "resource", "play", "ile", "le", "b", "letter", "il", "io", "ul", "data", "child", "folder", "entry", "f", "rule", "feed", "out", "s", "source", "dir", "filename", "work", "l", "files", "base", "place", "name", "up", "per", "File", "full", "path", "or", "fe", "fp"], "fos": ["fo", "fis", "Fosh", "cfob", "ufob", "ofops", " fob", "fou", "ofos", "Fops", "flos", "Fos", "cfo", "ufo", "voes", "flou", "fosh", "ufos", "ofosh", " fops", " fo", "fios", "flis", "Fios", "Fou", "fops", " fosh", "fob", " fis", "cfos", "ofou", "vos", " foes", "Foes", "flosh", "vops", "foes", "ufoes", "flops", " fios", "cfoes", "Fis", "vios"], "fileSrc": [" fileSsrc", " fileSRC", "fileAsource", "FileDrec", "fileDRC", "FileDource", "fileNsrc", "FileDrc", "FileSrc", " fileDsrc", "fileSRC", "FileSRC", "FileSource", "fileSrs", "fileAsrs", " fileDrs", "fileDrc", "fileNRC", " fileSrs", "fileSource", "fileSrec", "fileDource", " fileDrc", " fileDRC", "fileAssrc", "fileDrec", "FileSrec", "fileAsrec", "FileDRC", "fileAsRC", "fileDsrc", "fileSsrc", "fileNrc", "fileAsrc", "fileDrs", "fileNrs"], "fileDst": ["fileDayst", "fileEnST", "FileDst", "fileDaysc", "fileNsrc", "FileDrc", "FileSrc", "FileSst", "fileFsc", "FileFst", "fileEnrc", "FileSsrc", "fileNsc", "fileDsc", "fileDaysrc", "fileNst", "fileDrc", "fileFst", "FileDsc", "fileFrc", "fileFST", "fileEnst", "FileSsc", "FileDST", "fileDST", "FileFsc", "FileFrc", "fileSST", "fileEnsc", "fileDayrc", "FileFST", "FileDsrc", "fileDsrc", "fileSsc", "fileSsrc", "fileSst", "fileNrc"], "reader": ["book", "report", "e", "rx", "ro", "rer", "server", "rc", "io", "data", "parser", "ner", "reading", "rar", "entry", "audio", "right", "Reader", "editor", "read", "row", "builder", "iter", "driver", "stream", "er", "rr", "worker", "inner", "r", "handler", "loader", "re", "per", "layer", "ler", "or", "buffer", "author", "oder", "director", "keeper", "ri", "ry"], "writer": ["book", "widget", "wr", "write", "e", "server", "message", "master", "connection", "sheet", "outer", "data", "later", "writing", "parser", "socket", "written", "writ", "output", "entry", "document", "editor", "o", "Writer", "key", "out", "player", "ws", "rw", "maker", "builder", "element", "driver", "war", "with", "riter", "width", "work", "er", "worker", "ger", "inner", "walker", "r", "wa", "handler", "wire", "loader", "w", "per", "writers", "words", "wrapper", "word", "ler", "buffer", "author", "office", "value"], "line": ["page", "text", "LINE", "log", "url", "lf", "write", "message", "unit", "le", "style", "connection", "letter", "item", "cell", "data", "ge", "link", "sync", "part", "entry", "model", "inline", "definition", "rule", "str", "lin", "lines", "error", "key", "type", "end", "row", "code", "pass", "jo", "column", "job", "source", "comment", "cle", "header", "l", "object", "id", "look", "cr", "string", "character", "stroke", "Line", "name", "response", "word", "lc", "buffer", "feed", "block", "char"]}}
{"id1": "22552318", "id2": "3806532", "code1": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadDSL", "loadingDDLM", "loadDDLE", "loadDSLM", "loadDSDL", "loadDDDL", "loadCDDL", "loadingDDL", "loadingDSL", "loadDSLE", "loadDBLE", "loadDBLM", "loadingDDDL", "loadDBL", "loadingDDLE", "loadingDSDL", "loadCDLM", "loadCDLE", "loadingDSLE", "loadDDLM", "loadCDL", "loadingDSLM", "loadDBDL"], "stmt": ["stsmd", "strmn", "strtr", " stnt", "Stm", " stMT", " stm", "stmp", "stmit", " sttr", "stdb", "stnt", "shdb", "ostmp", "ostm", "Stmit", " stmn", "Stdb", "strmt", "shpr", "stsmt", " stdb", "strnt", "stmd", "Stpt", "stpt", "stpr", " stpr", " stpt", "stsmit", "ostmt", "Stmn", "ostmn", "stMT", "StMT", "estmp", "estmt", " stmd", "stsMT", "Sttr", "stmn", "Stmd", "Stmt", "Stnt", "shMT", "Stpr", " stmit", "estm", "ostpt", " stmp", "shmt", "ostMT", "sttr", "stm", "estmn"], "qry": [" qty", "dqrys", "requrys", "qri", "dqry", "qries", " qy", "quty", "qy", "qurys", "dqri", " qries", "quri", "quy", "requty", "dqries", " qri", "requry", "qty", "quries", "qrys", " qrys", "requy", "qury"], "q": [" req", "k", "req", "request", "e", "b", "n", "rc", "ue", "dq", "qu", "f", "eq", "str", "d", "h", "iq", "sq", "i", "qa", "work", "qs", "queue", "r", "id", "v", " query", "c", "qt", "select", "t", "w", "qq", "query", "Q", " msg", "quest", "p", "ql"]}}
{"id1": "14882263", "id2": "14502142", "code1": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"UploadActionPerformed": ["UploadActionReformed", "UploadButtonOccumed", "UploadButtonOccformed", "UploadActionReuted", "UploadActionOccuted", "UploadActionOccumed", "UploadActionEnformed", "UploadButtonPeruted", "UploadButtonPerced", "UploadButtonPerumed", "UploadActionOccformed", "UploadActionEnuted", "UploadActionOccced", "UploadActionReumed", "UploadActionPeruted", "UploadButtonOccced", "UploadActionPerumed", "UploadButtonPerformed", "UploadActionReced", "UploadActionEnced", "UploadActionEnumed", "UploadActionPerced", "UploadButtonOccuted"], "evt": [" evtf", " Evt", "Evt", " avertf", " evte", " Evtf", "Evts", " Evte", " evts", " averts", " averte", "Evtf", " Evts", " avert", "Evte"], "chooser": ["closen", "choiner", "dialcho", "comboser", "chooe", "choosen", "Choosed", "dialosen", "joosen", "combosed", "coosed", "dialose", "coiner", "dialoser", "compo", "promosite", "promosen", "joose", "closed", "Chooser", "promose", "closer", "joosed", "chocho", "choo", "choosing", "choosite", "joosing", "Choose", "compose", "joo", "cooser", "jooser", "joiner", "coosite", "promoe", "cooe", "combose", "coose", "composer", "Choosite", "Choosing", "promo", "Chocho", "promoser", "closing", "choose", "composen", "combiner", "Chooe", "Choosen", "choosed", "compcho"], "filter": ["fl", "url", "sf", "b", "form", "lock", "atter", "flat", "acl", "method", "search", "limit", "model", "f", "map", "finder", "sort", "type", "plugin", "class", "config", "fil", "ff", "self", "user", "object", "match", "cache", "handler", "file", "name", "list", "Filter", "aff", "pattern", "path", "query", "format", "force", "ext"], "dir": ["fd", "log", "direction", "url", "uri", "conf", "loc", "lock", "DIR", "info", "data", "store", "project", "part", "folder", "f", " directory", "zip", "area", "dat", "type", "out", "home", "pkg", "source", "config", "directory", "db", "base", "user", "id", "cache", "handler", "file", "ir", "dist", "name", "loader", "root", "path", "Dir", "doc"], "parent": ["page", "component", "url", "menu", "resource", "image", "Parent", "child", "port", "part", "channel", "folder", "document", "editor", "parents", "pid", "container", "home", "instance", "section", "directory", "self", "ip", "point", "user", "object", "id", "div", "handler", "file", "name", "root", "path", "location", "current", "p"], "returnVal": ["returnval", "continueValue", "errorVal", " returnObj", "continueval", "errorval", "errorValue", "continueVal", "errorVol", "returnObj", "returnValue", "returnVol", "ReturnVol", " returnVol", "ReturnObj", "ReturnValue", "Returnval", "ReturnVal", "continueObj", " returnval", " returnValue"], "client": ["proxy", "friend", "request", "console", "ssl", "default", "standard", "server", "call", "core", "complete", "simple", "connection", "force", "remote", "google", "ce", "cell", "session", "phone", "socket", "cloud", "external", "channel", "connect", "quit", "cl", "end", "out", "conn", "plugin", "i", "cm", "api", "config", "cli", "web", "use", "ip", "Client", "pi", "base", "user", "util", "co", "queue", "local", "cache", "https", "pc", "con", "c", "file", "contact", "app", "help", "service", "grid", "net", "per", "get", "clean", "contract", "secure", "close", "http", "custom", "p", "open"], "reply": ["resp", "req", "exit", "respond", "uri", "message", "write", "count", "connection", "reason", "rc", "like", "info", "back", "msg", "link", "sync", "status", "result", "mode", "answer", "ise", "error", "code", "action", "parse", "xxxxxxxx", "ply", "rr", "send", "id", "err", " replied", "repl", " replies", "next", "response", " response", "query", "state", "Reply", "close", "post", "ry"], "in": ["rec", "ex", "ins", "resource", "image", "In", "ax", "n", "tin", "io", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "out", "conn", "i", "is", "source", "reader", "nin", "l", "stream", "login", "inner", "min", "r", "id", "ac", "pc", "bin", "file", "con", "ic", "fc", "up", "pin", "ini", "again", "cgi", "on", "p", "serv"]}}
{"id1": "17947246", "id2": "4118412", "code1": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"readURL": ["createUrl", "createURL", "readUrl", "downloadURI", "loadURL", "loadurl", "downloadUrl", "readurl", "createurl", "readURI", "downloadurl", "createURI", "downloadURL", "loadUrl", "loadURI"], "urlLocation": ["llocation", "lLocation", "urlLoc", "URLContents", "baseLocation", "filePath", "pageLocation", "lUrl", "resourcePosition", "fileLoc", "pageLocated", " urlLocated", "URLPath", "urllocation", "filelocation", "urlUrl", " urlUrl", "pagelocation", "resourceLoc", "resourcelocation", "fileUrl", "urlPosition", "lContents", " urlLoc", "urlLocated", "URLLoc", "resourceLocated", " urllocation", "URLlocation", "URLLocation", "urlPath", "resourceUrl", "urlContents", " urlPosition", "basePosition", "baseUrl", "fileLocation", "URLUrl", " urlContents", "resourceLocation", "resourcePath", "baseLoc"], "headers": ["fields", "values", "keys", "pins", "rows", "archives", "html", "details", "users", "links", "ppers", "parts", "styles", "liners", "plugins", "groups", "features", "comments", "lines", "breaks", "objects", "hers", "drivers", "properties", "heads", "strings", "qs", "files", "resources", "ids", "pages", "frames", "names", "errors", "codes", "params", "ers", "cells", "blocks", "writers", "types", "words", "authors", "boxes", "events", "limits", "head", "http", "ors"], "c": ["m", "e", "server", "C", "g", " mc", "n", "tc", "ce", "engine", " C", "bc", "ec", "f", "controller", "mc", "o", "d", "ci", "h", "cc", "config", "client", "cli", "l", "r", "cache", "pc", "con", "dc", "t", "ctx", "context", "Controller", "content", "lc", "cs", "enc", "cr", "p"], "url": ["ur", "page", "log", "fl", "ssl", "uri", "resource", "ll", "server", "e", "cert", "uc", "b", "build", "connection", "loc", "rel", "il", "org", "ul", "socket", "fr", "f", "www", "URL", "coll", "ch", "nl", "bel", "el", "config", "client", "rl", "l", "web", "lr", "base", "cache", "gl", "con", "file", "loader", "ob", "sl", "host", "location", "Url", "path", "buffer", "q", "http"], "conn": ["conv", "resp", "rt", "oa", "auth", "ssl", "ct", "cn", "col", "uc", "conf", "n", "connection", "loc", "rc", "cp", "cdn", "pg", "cmd", "act", "org", "ns", "sync", "socket", "reg", "oss", "part", "Connection", "impl", "connect", "fail", "mc", "nt", "coll", "ch", "nc", "ci", "cb", "error", "Conn", "cc", "ctrl", "config", "client", "cli", "co", "db", "inner", "ann", "pc", "con", "exec", "obj", "err", "dc", "ob", "dn", "ctx", "host", "ai", "cf", "pub", "ca", "utils", "enc", "http", "serv", "open"], "istream": ["ismorage", "istig", "ismream", "ismub", "astub", "ISTream", "istsream", "ismeal", "istREAM", "astream", "xtorage", "istsREAM", "ISTorage", "astorage", "iestub", "xtig", "iestorage", "istorage", "iesteal", "istsorage", "istub", "asteal", "ISTig", "isteal", "istsig", "xtream", "ISTREAM", "iestream", "xtREAM"], "i": ["m", "p", "u", "uri", "j", "b", "ori", "io", "info", "si", "ie", "part", "in", "f", "o", "d", "index", "ci", "h", "oi", "iu", "multi", "y", "li", "di", "ip", "pi", "hi", "xi", "inner", "slice", "vi", "ind", "id", "eni", "ti", "v", "gi", "ix", "I", "ai", "phi", "ini", "ii", "ui", "bi", "mu", "qi", "ri"], "header": ["prop", "forward", "param", "page", "attribute", "writer", "frame", "uri", "message", "resource", "server", "dr", "body", "event", "version", "part", "field", "cookie", "entry", "definition", "document", "rule", "hash", "block", "str", "second", "index", "upper", "h", "code", "column", "comment", "metadata", "driver", "reader", "section", "filename", "pair", "iter", "er", "Header", "inner", "feature", "variable", "object", "id", "address", "token", "string", "holder", "handler", "character", "name", "wire", "property", "host", "layer", "cover", "response", "content", "buffer", "head", "line", "request"], "key": ["ky", "k", "prefix", "pe", "ee", "keys", "uri", "col", "core", "parent", "lock", "Key", "ey", "link", "ie", "part", "field", "hash", "str", "iv", "index", "ck", "ace", "val", "type", "code", "ver", "element", "hop", "section", "co", "ip", "kw", "base", "feature", "variable", "sign", "id", "my", "string", "ke", "name", "wire", "by", "query", "x", "cy", "ray", "q", "head", "label", "owner", "secret", "KEY"], "value": ["values", "text", "description", "default", "message", "resource", "va", "parent", "null", "style", "Value", "version", "info", "hello", "part", "var", "entry", "model", "iv", "valid", "end", "val", "type", "test", "ver", "element", "media", "target", "vi", "alt", "feature", "string", "v", "gi", "name", "property", "reference", "VALUE", "json", "content", "format", "label"], "data": ["DATA", "pad", "array", "offset", "body", "info", "area", "str", "map", "bytes", "breaks", "type", "class", "media", "number", "ata", "cache", "string", "start", "next", "blocks", "content", "buffer", "format", "block"], "curPos": [" curToken", "CurPosition", "serPosition", "serEnd", "serPos", "curToken", " curEnd", "CurEnd", "CurPos", "curEnd", "curPosition", "serToken", " curPosition", "CurToken"], "contentLength": ["resourceLength", " contentLen", " contentSize", "loadType", "byteInfo", "resourceType", "contentInfo", "loadLength", " contentInfo", "loadInfo", " contentType", "loadSize", "contentType", "ContentLen", "loadLen", "byteType", "ContentType", "resourceSize", "ContentLength", "byteLength", "contentSize", "ContentSize", "contentLen", "resourceLen"], "byteSize": ["bytesLen", "bytesData", "wordLen", "wordSize", " byteTime", "ByteWidth", " byteWidth", " byteLen", "ByteSize", "ByteLen", "ByteType", "wordData", "byteWidth", "contentTime", "ByteTime", "byteLen", "bytesSize", "byteData", "contentType", "bytesLength", "ByteLength", "byteType", "bytesWidth", " byteType", "byteLength", " byteLength", "contentSize", " byteData", "byteTime", "wordLength"]}}
{"id1": "19378010", "id2": "8079516", "code1": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"getProteins": ["getPinyans", "getPetteus", "getPettein", "getProtein", "getPinyin", "getProroteins", "getPteus", "getPetteans", "getProteans", "getProrotein", "getPetteins", "getProroteans", "getPinyus", "getPteins", "getProroteus", "getPinyins", "getProteus", "getPtein", "getPteans"], "queries": [" quences", "critery", "queeries", "quences", "critires", "quares", "queares", "acqueries", "quirements", "acquares", "quires", "acquires", "acquery", "acquirements", " quires", "queences", "critirements", "criteries", " quares", "queires", "acquences", " quirements"], "taxon": ["productonomy", "Taxon", "TaxON", "Taxonomy", "productron", " taxonomy", "acton", "taxan", "taxonomy", "taxion", " taxion", "producton", "Taxron", "taxON", "Taxion", "action", " taxON", " taxron", "taxron", "actron", "Taxan", "productan", " taxan", "actON"], "parser": ["writer", "lp", "server", "se", "b", "library", "manager", "Builder", "session", "dd", "document", "xml", "instance", "plugin", "builder", "parse", "reader", "pd", "driver", "paragraph", "l", "er", "self", "worker", "base", "string", "handler", "loader", "Parser", "lib", "root", "context", "layer", "buffer", "oder", "http", "p", "arser"], "xpe": ["xPE", "expe", "xme", "xxpe", "xxpa", "nexme", "xxme", "exPE", " xPE", "xpex", "nexpe", "rxpa", " xpa", " xpex", "xpa", "nexPE", "rxpe", "nexfe", "rxpex", "xfe", "rxme", " xme", " xfe", "exme", "exfe", "xxpex"], "proteins": ["pregeons", "progeans", "preteons", "proroteins", "prooeis", "proroteINS", "prochein", "Proroteis", "Proteins", "ProteINS", "proroteis", "propleins", "pregeins", "pregeans", "proteINS", "prooeINS", "pretein", "Proteinas", "procheinas", "proteinas", "prorotein", "prooeins", "progeins", "prooeinas", "proroteons", "preteans", "ProroteINS", "pregein", "Protein", "Proroteins", "Proteis", "proteons", "progein", "propleis", "procheins", "proteans", "proplein", "propleons", "proroteans", "propleINS", "progeons", "preteins", "procheis", "propleans", "prooein", "Prorotein", "proteis", "Proroteinas", "proroteinas", "protein"], "query": ["filter", "prefix", "expr", "text", "uri", "resource", "module", "server", "call", "script", "scope", "body", "term", "scan", "tag", "info", "Query", "sql", "eries", "search", "qu", "entry", "route", "str", "block", "password", "error", "key", "timeout", "row", "iq", "sq", "type", "source", "comment", "parse", "expression", "command", "feature", "id", "string", "question", "params", "name", " Query", "path", "json", "value", "update", "q", "request", "database"], "connection": ["to", "proxy", "established", "statement", "log", "writer", "uri", "resource", "image", "server", "message", "communication", "parent", "loc", "manager", "remote", "io", "link", "session", "closed", "socket", "director", "channel", "Connection", "application", "document", "creator", "connect", "URL", "password", "error", "ci", "timeout", "key", "container", "conn", "connected", "builder", "source", "api", "config", "section", "client", "directory", "driver", "co", "reader", "db", "position", "cache", "string", "handler", "c", "con", "service", "relation", "ctx", "context", "location", "response", "wrapper", "state", "function", "condition", "current", "or", "pool", "collection", "http", "open", "database"], "encoded": [" decoder", "encoder", " deccoded", "enoder", "enoded", "encrypted", " decoded", " decrypted", "engoder", "Enccoded", "Encrypted", "enrypted", "engoded", "Encoded", " encoder", "enccoded", "Encoder", " enccoded", "engcoded", "engrypted", " encrypted"], "url": ["ls", "page", "log", "uri", "ssl", "resource", "image", "server", "build", "b", "loc", "org", "link", "session", "channel", "impl", "www", "URL", "job", "conn", "builder", "source", "api", "config", "client", "l", "web", "base", "user", "address", "string", "file", "service", "location", "Url", "path", "http", "feed", "browser"], "stream": ["resource", "image", "server", "view", "body", "Stream", "form", "data", "session", "raw", "channel", "output", "document", "f", "result", "input", "coll", "feed", "bean", "out", "row", "xml", "source", "record", "reader", "ream", "client", "media", "user", "object", "trans", "string", "file", "context", "path", "response", "content", "sw", "request"], "doc": ["m", "text", "DOC", "module", "html", "body", "dot", "data", "project", "dec", "md", "bc", "document", "f", "map", "nt", "d", "coll", "docs", "dict", "xml", "parse", "Doc", "tree", "toc", "db", "oc", "div", "pc", "desc", "file", "dc", " document", "root", " docs", "proc", "response", "dom", "df"], "nodes": [" notes", "notes", "Notes", "ynodes", "Noms", "ions", "Node", "ynons", " nod", "anoms", "enoms", "Numbers", " nasts", "enotes", "nons", "sasts", "iods", " noms", "nod", "anodes", "soms", "sumbers", "Nodes", "sodes", "Nops", "enops", "nods", "Nod", "anotes", "enodes", "ynotes", " nops", "nops", "anode", "noms", "enod", "nasts", "ynods", "iotes", "numbers", " numbers", "Nasts", "enods", "enons", "iodes"], "n": ["span", "m", "k", "ln", "z", "j", "length", "count", "b", "en", "num", "ns", "sn", "o", "d", "nl", "nc", "s", "ng", "network", "y", "ne", "l", "nin", "len", "number", "v", "c", "t", "net", "x", "nb", "N", "p", "nn"], "i": ["k", "p", "u", "uri", "z", "j", "b", "init", "io", "info", "si", "ie", "in", "f", "ni", "it", "o", "index", "ci", "key", "oi", "h", "end", "multi", "y", "li", "di", "l", "mi", "ip", "pi", "xi", "eni", "hi", "inner", "slice", "id", "ti", "v", "gi", "c", "ix", "I", "ai", "phi", "chi", "ii", "ui", "bi", "x", "qi", "ini", "shift", "ri"], "node": ["page", "text", "component", "Node", "one", "e", "parent", "cdn", "num", "none", "outer", "data", "child", "link", "entry", "document", "ode", "edge", "route", "missing", "bean", "key", "type", "row", "element", "network", "slave", "tree", "object", "id", "load", "card", "name", "entity", "layer", "path", "word", "content", "value", "scene", "label", "nn"]}}
{"id1": "13563706", "id2": "13666876", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "handleGET", "handleget", "doget", "didget", "doPut", "handlePut", " doget", " doGET", " doPut", "didGet", "didPut", "doGET", "didGET"], "request": ["attribute", "req", "p", "url", "frame", "resource", "report", "server", "message", "image", "complete", "view", "Response", "connection", "remote", "event", "method", "data", "info", "application", "model", "document", "result", "input", "Request", "type", "xml", "instance", "create", "QUEST", "config", "client", "user", "queue", "object", "string", "query", "current", "buffer"], "response": ["resp", " Response", "description", "res", "writer", "subject", "respond", "report", "resource", "server", "message", "image", "view", "Response", "connection", "body", "reason", "output", "model", "application", "status", "result", "site", "document", "reply", "index", "error", "results", "api", "client", "header", "object", "wa", "re", "service", "location", "pool", "json", "query", "collection", "http", "feed", "onse"], "selectedPage": [" selectedHour", "namedpage", "selectedLine", "selectionFile", " selectedAction", "namedPage", "namedFile", "selectedButton", "lectedpage", "lectedFile", " selectedItem", "lectedLine", "selectionpage", "namedLine", "selectedpage", " selectedLine", "lectedSite", "lectedAction", "electedPage", " selectedFile", "electedLine", "selectedFile", "selectionItem", " selectedButton", "lectedPage", "electedpage", "lectedItem", "selectionAction", "namedSite", " selectedSite", "selectionButton", "electedButton", "lectedButton", "lectedHour", "selectedAction", " selectedpage", "selectedSite", "selectionPage", "selectedItem", "selectionLine", "selectionHour", "selectedHour"], "page": ["menu", "image", "parent", "html", "view", "pg", "profile", "row", "queue", "cache", "po", "per", "pp", "photo", "Page", "unit", "resource", "message", "server", "connection", "port", "display", "model", "result", "type", "plugin", "record", "article", "point", "change", "layout", "handler", "age", "proxy", "url", "channel", "site", "route", "rule", "me", "instance", "section", "user", "node", "account", "location", "block", "peer", "module", "pl", "item", "ge", "project", "je", "child", "phone", "document", "f", "client", "ice", "ip", "number", "position", "address", "language", " Page", "sp", "pool", "office", "fe", "p"], "portalRequest": ["portortalRequest", "PortortalUser", "portpalResponse", "portelQuery", "portelCommand", "portalAccess", "PortortalEvent", "portALEvent", "portugalEvent", "portallResponse", "portalResponse", "portugalUser", "portALUser", "portortalServer", " portialRequest", "portialQuery", "portbalQuery", "portallingPage", "portalPage", "PortortalAccess", "PortortalCommand", "portortalUser", " portialResponse", "portugalServer", "portialRequest", "PortalEvent", " portialQuery", "portALRequest", "portelRequest", "PortortalResponse", "portalEvent", "portpalRequest", "portALResponse", " portalQuery", "portbalResponse", "PortalOrder", "PortalCommand", "portailRequest", "portbalRequest", "PortalAccess", "portelResponse", "portugalResponse", "portallingResponse", "PortortalServer", "portallUser", "portailOrder", "portugalOrder", " portalResponse", " portalPage", "portialPage", "portallingRequest", "portalUser", " portialPage", "portpalPage", "portalServer", "portallingAccess", "portailUser", "PortortalRequest", "portallServer", "portortalOrder", "portelPage", "portortalPage", "PortalRequest", "portortalResponse", "portallRequest", "portalQuery", "PortalResponse", "PortortalOrder", "portortalEvent", "portbalPage", "portialResponse", "PortalUser", "portallingCommand", "PortalServer", "PortortalPage", "portugalRequest", "portalOrder", "portailResponse", "portortalCommand", "portortalAccess", "portpalAccess", "portalCommand", "PortalPage"], "pageProp": ["projectProp", "pluginPro", "projectProperty", "PageProp", "parentProperty", "pageObj", "pagePro", "agePro", "projectprop", "parentProp", "peerStr", "pluginProperty", "pluginprop", "PagePro", "parentObj", "pageprop", "resourceProperty", "resourceProp", " pageProperty", " pageObj", "PageProperty", "ageProperty", "pageProperty", "Pageprop", "ageprop", "PageStr", "peerProp", "resourcePro", "pluginProp", "pageStr", "ageProp", "projectPro", "peerProperty", "PageObj", " pagePro", "parentPro", " pageStr", "peerPro", "resourceprop"], "possiblePage": ["possibilityPage", "possibleItem", "puredPage", "permanentpage", "PossiblyPage", "possiblyGroup", "pablePages", "PossiblyItem", "PossibilityLine", "patchingGroup", "patchingpage", "possiblyLine", "Possiblepage", "patchedPage", "permanentLine", "PossibleGroup", "patchedOrder", "possiblePages", "possibleGroup", "patchingPage", "puredGroup", "possibleLine", "PossibleOrder", "possiblyPage", "PossiblyLine", "possiblyItem", "pablepage", "PossiblePages", "puredpage", "patchingItem", "possiblyPages", "possiblepage", "PossibilityPage", "PossibleLine", "possiblyOrder", "patchedpage", "permanentPage", "PossibilityPages", "possibilityPages", "PossiblePage", "Possiblypage", "puredItem", "possibilityLine", "pableLine", "possibilitypage", "PossibleItem", "PossiblyOrder", "pablePage", "patchedLine", "Possibilitypage", "PossiblyGroup", "permanentOrder", "possiblypage", "possibleOrder"], "property": ["prop", "prefix", "attribute", "p", "Property", "resource", "integer", "maximum", "uration", "term", "notation", "profile", "data", "project", "operator", "duration", "f", "result", "set", "key", "type", "binding", "class", "future", "config", "properties", "section", "header", "expression", "perties", "number", "feature", "table", "variable", "object", "address", "language", "string", "character", " Property", "name", "entity", "t", "binary", "layer", "function", "value", "label"], "referer": ["diffrer", "fere", "Referen", "referers", "refiner", " refre", "referen", "rerer", "reere", "redrer", "Referer", "redber", "Refeline", "Refender", "Refere", "affere", "Refre", "Refiner", "defrer", "afferen", "defere", "reiner", "deferer", "ferers", "rere", "refre", "reerer", "rederer", "differer", " referers", " refrer", " refender", "redeline", " refeline", "frer", "refber", "refeline", "affrer", "refender", "refere", "Referers", "defender", "afferer", "diffiner", "Refber", " referen", "diffender", " refere", "defber", "Refrer", " refiner", "refrer", "ferer", " refber"], "e": ["ee", "esi", "message", "one", "se", "null", "event", "this", "ie", "ele", "f", "es", "o", "d", "ae", "error", "me", "type", "see", "element", "i", "a", "er", "E", "de", "eme", "err", "ea", "or", "ed", "fe", "exc", "p", "ception"]}}
{"id1": "2168610", "id2": "1508161", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"update": ["replace", "save", "text", "UPDATE", "unit", "message", "write", "resource", "apply", "build", "complete", "view", "connection", "lock", "event", "updated", "version", "sync", "inc", "range", "status", "draw", "result", "check", "set", "family", "run", "index", "end", "date", "timeout", "error", "fill", "handle", "instance", "pull", "create", "add", "config", "future", "Update", "width", "edit", "delete", "send", "position", "id", "change", "address", "load", "patch", "name", "up", "grade", "diff", "ite", "get", "bug", "response", "insert", "put", "current", "value", "state", "where", "http", "use", "open", "database"], "o": ["k", "m", "oa", "e", "one", "n", "connection", "os", "none", " object", "mo", "online", "f", "oe", " O", "so", "ion", "od", "oi", "ao", "conn", "bo", "co", "object", "po", "c", "obj", "oo", "t", "ou", "ob", "O", "or", "office", "oid", "p", "ono"], "contact": [" Contact", "Contact", "report", "call", "communication", "cmp", "connection", "form", "act", "event", "cell", "info", "project", "cart", "sync", "phone", "conference", "entry", "f", "model", "result", "check", "charge", "connect", "lead", "fax", "coll", "ace", "date", "cc", "config", "client", "co", "work", "campaign", "point", "company", "control", "object", "address", "match", "account", "character", "email", "product", "relation", "content", "concept", "office", "front", "lc", "contract", "collection", "feed", "choice"], "pst": ["spst", "wpcr", "prsp", " pdd", "opste", "Post", "Pct", " psh", " put", "Psts", "prost", "psp", "Psc", "pdd", "prsc", "lpsta", "put", " psts", "wpst", "prct", " psc", "Pcr", "PST", "pST", "psts", " pct", "lptd", "wpsh", "prdd", "pstd", "lpcr", "Pdd", "prest", "pste", "Pste", " ptd", " post", "psst", "prste", " psp", "Pst", " pST", "prsl", "prtd", "preut", "post", "opst", " psl", "epST", "psc", "epsts", "psh", "pssl", " psta", "spct", "epcr", " pcr", "wptd", "lpsh", "prST", "prcr", "prsts", "prsta", "opct", "sput", "epst", "ptd", "prst", "lpsts", "Psp", "pcr", "lpST", "opsts", " pste", "pssts", "psta", "preste", "pct", "psl", "spste", "lpst", "prect"]}}
{"id1": "22268798", "id2": "3806532", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["loadcontent", "loadContents", "loadContent", "getResource", "createContents", "createcontent", "createContent", "createResource", "getContents", "buildcontent", "getcontent", "buildResource", "buildContents", "buildContent", "loadResource"], "principal": ["Princincipal", "prunctificate", "pricipential", "princificate", "princeter", "Princuncteter", "Princincential", "pricipipal", "Princunctential", "pricipificate", "prercificate", "pruncteter", "prunctipal", "prerceter", "prercential", "Princinceter", "prunctential", "Princunctipal", "princential", "prercipal", "Princunctificate", "Princincificate", "pricipeter"], "path": ["prop", "prefix", "text", "uri", "resource", "parent", "method", "data", "ath", "project", "link", "info", "part", "PATH", "instance", "class", "source", "api", "client", "Path", "user", "node", "object", "string", "file", "name", "loader", "property", "root", "pattern", "next", "context", "location", "pointer", "format", "request"], "version": ["Version", "resource", "server", "parent", "depth", "project", "VERSION", "model", "str", "date", "val", "out", "ver", "vision", "target", "node", "versions", "object", "string", "v", " versions", "json", "release", "current", "value", "format", "level"], "properties": ["prop", "fields", "values", "Property", "details", "Pro", "ps", "options", "data", "plugins", "features", "classes", "ips", "settings", "objects", "results", "metadata", "perties", "resources", "address", "params", "property", "types", "json", "pro", "state", "items"], "uniqueName": ["UniquePath", "UniqueType", "filePath", "uniquename", "blockType", "stringKey", "uniquePath", " uniquePath", "baseName", "UniqueName", "blockPath", "blockName", "fileName", "baseKey", "Uniquename", "filename", "stringPath", "uniqueTime", " uniqueKey", "stringName", "UniqueKey", " uniqueTime", "uniqueKey", " uniquename", "UniqueTime", "stringname", "basename", "basePath", "blockKey", "uniqueType", " uniqueType", "fileTime"], "url": ["ls", "page", "proxy", "log", "uri", "ssl", "ll", "image", "server", "resource", "parent", "build", "html", "loc", "this", "link", "channel", "f", "www", "URL", "coll", "error", "conn", "download", "el", "source", "client", "l", "web", "base", "user", "position", "object", "found", "address", "string", "file", "name", "ob", "sl", "host", "layer", "Url", "location", "http", "feed", "bb", "open"], "content": ["page", "proxy", "cover", "default", "resource", "message", "const", "core", "parent", "copy", "server", "image", "complete", "remote", "ce", "data", "this", "child", "output", "model", "document", "creator", "result", "coll", "container", "Content", "key", "conn", "code", "location", "temp", "instance", "cf", "comment", "create", "cm", "config", "section", "client", "media", "source", "reader", "user", "node", "object", "address", "change", "ac", "load", "handler", "file", "c", "cache", "host", "full", "layer", "response", "cont", "wrapper", "condition", "ca", "current", "update", "lc", "common", "ext"], "connection": ["proxy", "uri", "resource", "image", "server", "communication", "loc", "io", "data", "session", "channel", "Connection", "application", "creator", "connect", "coll", "container", "conn", "connected", "config", "section", "client", "directory", "reader", "number", "control", "object", "position", "string", "character", "handler", "con", "c", "relation", "context", "pool", "response", "http", "open", "database"], "mimeType": ["mmimetype", "metyType", "miveType", "MIMEtype", "mimesPath", "Mimetype", "MIMEPath", "mimePath", "miveInfo", "mangPath", "mimestype", "mmivetype", "mimetype", "MimeType", "MIMEName", "mangtype", "mangType", "mimesName", "metyInfo", "MimeName", "mIMEtype", "mIMEName", "mIMEType", "metytype", "mimeInfo", "mIMEInfo", "mimeName", "mimesType", "mmimeType", "mIMEPath", "mmiveInfo", "mangName", "mmiveType", "MIMEType", "mmimeInfo", "mivetype", "MimePath"]}}
{"id1": "22022715", "id2": "21827619", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"digest": ["doested", "genester", "mdester", "generit", "dger", "digure", "dest", "Digit", "Digure", "Digester", "genests", "Digest", " digested", "mdested", "mdure", "generester", "digit", "digger", "generest", "mdger", "generger", "doit", " digests", "doest", " digester", "Digested", "digester", "mdit", "Digests", "digests", "dester", "doure", "digested", "genested", "mdest", "dit", "genest"], "s": ["ls", "m", "ssl", "e", "message", "b", "g", "ss", "n", "os", "ps", "rs", "ns", "data", "sb", "f", "es", "d", "password", "bytes", "lines", "ms", "ws", "is", "i", "source", "sym", "a", "ses", "S", "string", "c", "params", "words", "gs", "services", "strings", "p", "ds"], "ret": ["replace", "rt", "secret", "std", "res", "array", "arr", "default", "xt", "pat", "Return", "info", "data", "rev", "result", "hash", "nt", "reply", "valid", "val", "key", "out", "pass", "bf", "addr", "al", "fun", "alt", "det", "Ret", "match", "obj", "success", "mem", "re", "def", "continue", "repl", "arg", "value", "rets", "RET", "ext"], "md": ["mad", "m", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "um", "dig", "dd", "gd", "rpm", "editor", "mc", "mag", "d", "od", "meta", "mb", "wd", "me", "nm", "amd", "mg", "dm", "bd", "pkg", "metadata", "pd", "MD", "di", "ad", "mac", "ind", "mand", "mm", "ma", "am", "cb", "pm", "arm", "mt", "cd", "mod", "df"]}}
{"id1": "8770016", "id2": "1508930", "code1": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"loadResource": ["createFile", "readFile", "createUrl", "createURL", "readUrl", "newResource", "newURL", "loadURL", "createResource", "newUrl", "readURL", "loadFile", "loadUrl", "readResource", "newFile"], "location": ["description", "uri", "localhost", "resource", "length", "uration", "loc", "remote", "ocation", "link", "area", "route", "Location", "URL", "href", "timeout", "type", "source", "config", "directory", "filename", "l", "target", "point", "base", "position", "local", "address", "language", "layout", "string", "file", "name", "loader", "property", "reference", "region", "layer", "path", "response", "pointer", "content", "operation", "level", "collection"], "url": ["page", "log", "ssl", "uri", "resource", "image", "server", "e", "build", "null", "connection", "loc", "rel", "remote", "event", "org", "this", "link", "external", "f", "site", "route", "URL", "ref", "job", "jar", "xml", "element", "source", "i", "config", "rl", "l", "web", "base", "object", "address", "string", "file", "loader", "name", "ob", "sl", "plug", "Url", "path", "layer", "buffer", "http"]}}
{"id1": "2521141", "id2": "3958807", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"copy": ["ame", "ize", "rm", "pe", "write", "image", " cp", "cp", "attach", "ge", "link", "sync", "zip", "archive", "paste", "clone", "clip", "type", "download", "ignore", "move", "cat", "Copy", "create", "source", "config", "open", "directory", "delete", "dump", "change", "load", "file", "share", "upload", "diff", "get", "transfer", "update", "opy", "cop"], "from_name": [" from_key", "source_memory", "fromMname", "source_name", " from_Name", "from_path", "fromMfile", "from_key", " from_names", "from_Name", "fromFfilename", "source_filename", "from__memory", "from_names", "from__filename", "fromFpath", "from__path", "fromFmemory", "fromMnames", "from_memory", "to_path", "fromFname", "source_path", "to_filename", "from_filename", "from__name"], "to_name": ["toampath", "toamfile", "to_Name", "to_path", "to_home", "toamname", " to_Name", " to_home", "toamhome", " to_path", "to_filename", "from_path", "from_filename"], "from_file": ["from___filename", "fromapplane", "source_resource", "from_resource", " from_filename", "fromCfilename", " from_folder", "from_files", " from_auto", "source_name", " from__name", "from__file", "from__resource", "from_auto", " from__file", "remote_function", "from___name", " from__filename", "from_lane", "fromCname", "fromappfile", " from_source", "from_folder", " from_files", "remote_file", " from__auto", "source_directory", "source_filename", "from_log", " from_directory", "from___file", "remote_log", "remote_lane", "source_files", "from___auto", "fromappfunction", "from_source", "fromCbrain", "from_function", "from__filename", "from__files", "fromCfile", "from__directory", "source_brain", "from__auto", "source_file", "from_brain", "from_directory", "from_filename", "fromapplog", "from__name"], "to_file": ["into_function", "tojname", "to_dir", "eto_name", "from_files", "into_use", "eto___remote", " to_filename", "tojuse", "to67file", "to64function", " to_queue", "to64file", "intojfunction", "tojfile", "to_class", "to64use", "to__dir", "to_queue", "from_model", "to_server", "to__name", "intojname", "source_filename", "eto_remote", "to_bar", "to___file", "to_use", "from_stream", "toJname", "to___name", "to_load", "source_files", "to_files", "to__file", "toJfile", "eto___file", "to67name", "toJbar", "to_model", " to_model", "eto___name", "intojfile", " to_class", "to__load", " to_files", "into_name", "eto_file", "to64name", "to_remote", "to___remote", "to_binary", "intojuse", "to_stream", "tojfunction", "source_file", "from_dir", "to_function", "from_bar", "toJstream", "to67dir", "from_binary", "into_file", "source_server", "to_filename", "from_load", "to67load"], "parent": ["ppa", "null", "term", "part", "search", "pa", "temp", "directory", "target", "div", "po", "cache", "string", "patch", "file", "ac", "root", "per", "owner", "page", "uri", "unit", "resource", "server", "connection", "Parent", "par", "remote", "port", "inc", "old", "folder", "test", "type", "tree", "point", "handler", "mother", "global", "path", "content", "url", "complete", "loc", "rule", "parents", "out", "api", "memory", "size", "user", "any", "id", "function", "location", "manager", "child", "session", "container", "home", "source", "client", "ip", "address", "name", "am", "full", "host", "pool", "current", "or", "author", "fat", "p"], "dir": ["url", "nav", "module", "build", "dr", "loc", "rel", "manager", "lock", "io", "die", "data", "md", "dec", "part", "folder", "group", "entry", "f", " directory", "dep", "in", "block", "exp", "d", "coll", "dev", "container", "out", "wd", "home", "cur", "ver", "dict", "cat", "class", "iter", "directory", "di", "keep", "db", "user", "tr", "r", "object", "id", "div", "cache", "ir", "file", "name", "dc", "def", "global", "root", "per", "dis", "path", "or", "Dir", "director", "doc"], "from": ["pe", "component", "From", "url", "fr", "one", "e", "server", "se", "without", "view", "connection", "form", "ce", "two", "io", "empty", "this", "link", "part", "range", "entry", "flo", "so", "cor", "ch", "feed", "bean", "conn", "source", "add", "api", "with", "parse", "client", "cm", "stream", "self", "base", "can", "address", "cache", "who", "low", "file", "con", "start", "name", "find", "by", "vol", "when", "left", "per", "ou", "get", "auto", "normal", "or", "ra", "context", "cf", "fe", "http", "cr"], "to": ["proxy", "too", "write", "one", "server", "dest", "connection", "two", "io", "fb", "store", "tto", "session", "sync", "socket", "not", "output", "via", "so", "flo", "about", "o", "storage", "su", "out", "type", "conn", "that", "see", "ver", "api", "top", "TO", "client", "size", "co", "with", "target", "pi", "db", "base", "will", "po", "token", "file", "by", "t", "per", "thro", "op", "until", "auto", "as", "or", "value", "To", "office", "fat", "http", "on"], "buffer": ["border", "wave", "buf", "bb", "page", "padding", "writer", "url", "default", "message", "resource", "server", "length", "b", "null", "data", "duration", "Buffer", "channel", "shape", "document", "batch", "read", "row", "texture", "total", "flush", "iter", "memory", "source", "reader", "header", "comment", "buff", "seed", "number", "queue", "position", "slice", "variable", "address", "character", "window", "binary", "reference", "layer", "uffer", "transfer", "feed", "block"], "bytes_read": ["bytes_load", "bytes_en", "byteslexcurrent", "bytesXcurrent", "bytes_reads", "bytes_current", "gets___allow", "bytes___pass", "gets_pass", "gets_read", "bytes___reads", "byte_read", "bytes___read", "bytesXbefore", "bytesXread", "gets___pass", "gets___reads", "byteslexread", "bytes_before", "byte_load", "bytes_write", "gets_allow", "bytesXload", "byte_before", "bytes___allow", "byteslexbefore", "gets___read", "bytes_allow", "gets_reads", "byte_current", "byteslexload", "bytes_pass", "bytes_found", " bytes_found", " bytes_write", " bytes_en"]}}
{"id1": "6190356", "id2": "13012591", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForNewMD3", " hashPasswordForNewMD5", " hashPasswordForNewM3", " hashPasswordForOldMC3", " hashPasswordForOldMD512", " hashPasswordForNewM512", " hashPasswordForNewM4", " hashPasswordForOldmd5", " hashPasswordForNewMD4", " hashPasswordForOldmd4", " hashPasswordForOldmd512", " hashPasswordForOldMC5", " hashPasswordForOldMC512", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForNewM5", " hashPasswordForOldMD3", " hashPasswordForOldMD4", " hashPasswordForOldM3", " hashPasswordForOldMC4", " hashPasswordForOldM512", " hashPasswordForOldM4", " hashPasswordForOldmd3"], "password": ["crypt", "secret", "text", "padding", "pad", "array", "auth", "message", " passwords", "data", "username", "sword", "phrase", "result", "hash", "input", "encrypted", "key", "wd", "wallet", "pass", "code", "seed", "address", "token", "string", "account", "name", "pattern", "words", "path", "word", "content", "buffer", "value", "Password", "p", " Password", "PASS"], "md": ["m", "rm", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "um", "dig", "dd", "km", "gd", "f", "managed", "rpm", "mc", "mag", "d", "vd", "od", "mb", "meta", "hm", "wd", "nm", "amd", "dm", "bd", "metadata", "pd", "MD", "di", "mac", "ind", "mand", "mm", "ma", "dc", "am", "pm", "grad", "mt", "cd", "clean", "vm", "mod", "df"], "messageDigest": ["messageModester", "messagedigests", "messageAddse", "MessageDigEST", "MessageDigest", "messageAddester", "messageAddEST", "messageModEST", "messagedigest", " messageModester", " messageModEST", "messageAddests", "MessageModse", "messageDest", "messagedigester", "MessageAddse", "messageDEST", "messageAddest", "MessageDigse", " messageDigester", "messageModest", "MessageModester", " messageModest", "messageModse", "MessageModest", " messageDigEST", "messagedigEST", "messageDigse", "MessageAddester", "MessageAddest", "messagedigse", "messageDigests", "MessageDigester", "messageModests", "messageDigEST", "MessageAddEST", "messageDester", "MessageModEST", " messageDigests", "messageDse", "messageDigester", " messageModests"], "hexString": ["stringSection", "stringService", "crossstring", "stringString", " hexstring", " hexFunction", "crossFunction", "sumstring", "octBuffer", "hexBuffer", "transformStr", " hexFile", "transformString", "tempFile", "hexstring", "hexService", "stringArray", " hexStr", "transformBuffer", "tempString", "hexArray", "hexStr", "hashString", "hashSection", "transformArray", " hexArray", "hashService", "crossStr", "tempStr", "sumString", "sumFile", "tempstring", "octStr", "octString", " hexService", " hexSection", "hexFunction", "octArray", "hexSection", "tempFunction", "hexFile", "hashArray", " hexBuffer", "crossString", "sumStr"], "i": ["k", "m", "p", "u", "uri", "e", "j", "length", "b", "n", "fi", "io", "info", "si", "f", "o", "index", "d", "ci", "h", "oi", "s", "ji", "multi", "li", "a", "l", "di", "ip", "pi", "xi", "slice", "r", "id", "ti", "v", "c", "t", "ix", "I", "ai", "phi", "ii", "ui", "x", "bi", "qi", "ri"], "hex": ["text", "ex", "he", "pack", "default", "hack", "length", "null", "cmp", "letter", "form", "pixel", "none", "rh", "data", "nexus", "bit", "hello", "raw", "cookie", "result", "hash", "str", "exp", "digit", "batch", "shift", "utf", "h", "temp", "pex", "buff", "ip", "oct", "lit", "transform", "cache", "sex", "string", "character", " Hex", "alpha", "binary", "host", "full", "pattern", "json", "path", "comp", "zero", "orig", "serial", "rex", "format", "http", "char"]}}
{"id1": "1371265", "id2": "16353490", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["replace", "save", "UPDATE", "write", "report", "append", "resource", "apply", "updated", "info", "data", "set", "index", "run", "create", "add", "Update", "edit", "delete", "table", "select", "json", "query", "insert", "request", "post"], "channelPath": ["downloadpath", "downloadObject", "fileObject", "downloadMap", " channelpath", "resourceObject", "filePath", "resourceMap", "downloadPath", "resourcePath", "resourcepath", "fileMap", "filepath", " channelObject", " channelMap"], "dataField": ["responseFIELD", "alphaField", "DataArea", "resourceField", "dataTerm", " dataFIELD", "responseTerm", "responseField", "DataField", "dataArea", "responsefield", "DataTerm", " dataTerm", "resourcefield", "alphaTable", "resourceFIELD", "alphaArea", "resourceTerm", "alphaTerm", " datafield", "DataTable", "datafield", "dataTable", " dataTable", "dataFIELD", " dataArea"], "fatherDocId": ["fatherDocName", "fatherPoID", "fatherFilePath", "motherDocInfo", "motherDocID", "fatherPoid", "fatherDocInfo", "motherDocumentInfo", "fatherDocumentName", "fatherDocumentPath", "fatherdocName", "motherDocName", "fatherdocId", "motherDocumentid", "fatherDocID", "motherDocumentName", "fatherdocInfo", "fatherWriterName", "motherDocId", "fatherWriterID", "motherDocumentID", "fatherFileid", "fatherFileName", "motherDocumentId", "motherDocid", "fatherFileID", "motherDocumentPath", "fatherPoName", "fatherdocPath", "fatherWriterInfo", "fatherWriterId", "motherDocPath", "fatherWriterid", "fatherDocumentId", "fatherDocumentID", "fatherFileInfo", "fatherFileId", "fatherDocid", "fatherDocumentInfo", "fatherDocPath", "fatherPoId", "fatherDocumentid"], "sqlInitial": ["qlinitial", "qlFinal", "qlInitialized", " sqlInitialized", "sqlInitialized", "qlInitial", "SQLInitialized", "SQLInitial", "sqlinitial", "queryInit", "SQLInit", " sqlInit", "SQLinitial", " sqlinitial", "queryInitial", "queryinitial", "queryFinal", "SQLFinal", "qlInit", "sqlInit", "sqlFinal"], "sqlsortURL": ["sqlssortURI", "sqlsORTURI", "sqlsourceURL", "sqlsorturl", "sqlsendURL", "sqlsORTurl", "sqlsaltSSL", "sqlsORTURL", "sqlsortUrl", "sqLSORTURI", "sqLSorturl", "sqlsaltURI", "sqlsortSSL", "sqllortUrl", "sqlsaltURL", "sqllortURI", "sqllaltURL", "sqLSortURI", "sqlssorturl", "sqlsendUrl", "sqlsourceUrl", "sqLSortURL", "sqLSORTURL", "sqLSortUrl", "sqlsendURI", "sqlssortUrl", "sqllaltURI", "sqlsaltUrl", "sqlsendSSL", "sqlsourceURI", "sqllortURL", "sqlsORTUrl", "sqlsourceurl", "sqlsortURI", "sqllaltUrl", "sqLSORTurl", "sqLSORTUrl", "sqllaltSSL", "sqlssortURL", "sqlsourceSSL", "sqllortSSL"], "conn": ["rt", "res", "ct", "cn", "col", "core", "Connect", "conf", "cp", "connection", "n", "rc", "pg", "en", "act", "lock", "session", "sql", "sync", "reg", "oss", "Connection", "ht", "pt", "syn", "connect", "mc", "nt", "coll", "ch", "nc", "ci", "ens", "Conn", "cc", " con", "cat", "pr", "oci", "client", "co", "db", "apt", "ann", "orp", "pc", "con", "c", "dc", "dn", "net", "ctx", "pub", "cs", "ca", "enc", "cr", "p", "ds"], "rs": ["rt", "ros", "maps", "asts", "res", "rss", "rors", "arch", "ins", "rows", "DS", "rx", "mr", "rc", "obs", "PS", "ns", "acks", "ges", "hs", "ows", "vs", "rys", "rb", "ys", "lines", "ms", "rg", "s", "Rs", "RS", "results", "ues", "pr", "its", "src", "rl", "rr", "qs", "ras", "r", "sc", "ars", "ris", "ocr", "icks", "sels", "xs", "repl", "rd", "sr", "ts", "ans", "hr", "ats", "ra", "cs", "pers", "bs", "cr", "rep", "ks", "runs", "ds", "vers"], "ps": ["ros", "pe", "res", "ins", "DS", "ss", "pg", "pl", "os", "PS", "ns", "aps", "pos", "pse", "pt", "syn", "fs", "vs", "pa", "pres", "amps", "ys", "ips", "ens", "s", "Rs", "RS", "ws", "Ps", "pr", "pass", "LS", "posts", "pex", "co", "ports", "ras", "pps", "eps", "po", "ms", "pc", "con", "ars", "ts", "pre", "sp", "pm", "ans", "ons", "gs", "jp", "ples", "cs", "ups", "pers", "pp", "bs", "p", "ks", "ds"], "dbo": ["Dbo", "ldbo", "bpo", "dba", " dBo", "bbo", "dBo", "dbc", " dbc", "Dpo", "mdBo", "Dbi", " dba", " dbi", "mdbo", "dbi", "bbi", "dpo", "mdba", "DBo", "mdbc", "bBo", "ldba", " dpo", "ldbc", "ldBo"], "url": ["ur", "page", "text", "fl", "uri", "ssl", "resource", "ll", "image", "server", "html", "fr", "view", "loc", "rel", "force", "data", "username", "blog", "f", "rule", "route", "www", "URL", "str", "href", "nl", "date", "download", "source", "src", "rl", "filename", "l", "hl", "r", "id", "address", "language", "string", "email", "file", "name", "sl", "host", "layer", "path", "Url", "location", "response", "q", "http", "feed", "request"], "st": ["ost", "sth", "std", "rt", "pe", "Str", "est", "fr", "stri", "nd", "const", "ss", "ste", "ut", "sts", "stress", "ST", "pt", "sb", "inst", "str", "sn", "stack", "cl", "s", "rest", "stop", "pr", "St", "th", "src", "ist", "l", "sw", "ft", "r", "sc", "string", "start", "rd", "t", "sl", "sp", "ast", "ld", "la", "bl", "sh", "sta", "x", "ust", "cr", "p"], "sortDocId": ["updateDocumentInfo", "updateDocumentid", " sortFileId", "sortdocName", "sortDOCid", "sortDocumentId", "sortDepID", "updateDocID", " sortDocumentid", "sortDepInfo", "sortDocumentid", " sortFileID", " sortDocumentID", "sortWriterID", " sortDocumentId", "sortdocid", "updateDocumentId", "sortDepId", "sortdocId", "sortPageid", "sortDocumentInfo", "sortdocPath", "sortDOCName", "sortdocInfo", "sortDocid", "sortWriterid", "sortFilePath", " sortDocID", "sortPageName", "sortFileid", "sortDepid", "sortDocumentID", "updateDocumentID", "updateDocid", "sortPageID", "sortDocumentPath", " sortDocPath", "updateDocId", " sortDocumentName", "sortDocPath", "sortDOCID", "sortDocumentName", "sortFileInfo", "updateDocInfo", "sortDocInfo", " sortFilePath", "sortWriterName", "sortdocID", "sortFileID", "sortDocName", " sortDocName", "sortDOCId", "sortWriterId", " sortFileInfo", "sortDocID", "sortPageId", " sortDocid", "sortDepName", "sortFileId", " sortDocInfo"], "flag": ["prop", "fl", "standard", "debug", "count", "offset", "star", "FLAG", "tag", " Flag", "data", "leaf", "store", "child", "sync", "bit", "blog", "part", "func", "bool", "field", "status", "agg", "str", "key", "inline", "only", "cat", "fun", "Flag", "id", "ind", "match", "string", "lag", "file", "start", "wait", "binary", "arg", "bug", "ret", "format", "flags", "ag", "force", "use", "kind", "ext", "char"], "sqlsort": ["sqLSorted", " sqlesort", "sqlessort", "sqllorter", "sqLSsort", " sqLSort", "sqLSORT", " sqlesorter", "sqlesORT", "sqLSorts", "sqlesort", " sqLSorts", "sqLSort", " sqLSORT", " sqlsorted", " sqlssort", "sqLSorter", "sqllORT", "sqlsORT", "sqssort", "sqsORT", " sqlsorter", "sqllorted", " sqlesORT", "sqlsorter", "sqllort", "sqlssort", " sqlesorted", "sqlesorted", " sqLSsort", "sqlsorts", "sqlsorted", "sqlesorts", "sqsorts", " sqlsORT", "sqlesorter", " sqlsorts", "sqsort"], "sortURL": ["editurl", "altSSL", "altUrl", " sortSSL", "sortID", "ortID", "editUrl", "SortUrl", " sortURI", "SortURL", "searchUrl", "sortURI", "searchID", "updateSSL", "updateUR", " sorturl", "sortSSL", " sortUrl", "updateURL", "editUR", "sorturl", "searchURI", "editURL", "ortURL", "updateURI", "SortUR", "ortSSL", " sortUR", "altURL", "sortUR", "altUR", "searchURL", "ortURI", "searchUR", "sortUrl", " sortID", "ortUR", "Sorturl", "ortUrl"], "sortflag": ["addressflag", "considerflag", " sortFlag", "ortFlag", "sortfeed", "considerfeed", " sorttype", "orttype", "sortFlag", "ortflags", "filtertype", "SortFlag", "Sortflag", "considerflags", "addressfeed", "ortlike", "sorttype", "ortFLAG", "sortlike", "SortFLAG", "addressflags", "filterFLAG", "sortflags", "sortFLAG", " sortFLAG", "addresslike", "filterflag", "ortflag", "considerlike", "ortfeed"]}}
{"id1": "2461169", "id2": "3430784", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "7087108", "id2": "19096138", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["processGet", "doPut", " doDownload", "processDownload", "didDownload", "doDownload", " doGET", " doPut", "processPut", "didGet", "doGET", "didPut", "didGET", "processGET"], "request": ["forward", "req", "subject", "url", "uri", "report", "resource", "server", "message", "parent", "complete", "view", "connection", "event", "method", "data", "info", "project", "child", "version", "this", "external", "application", "model", "result", "input", "route", "Request", "error", "type", "xml", "instance", "builder", "QUEST", "create", "reader", "config", "client", "web", "target", "self", "user", "object", "string", "name", "host", "context", "query", "json", "current", "buffer", "condition", "http", "use"], "response": ["wave", "resp", "page", "writer", "respond", "report", "resource", "server", "message", "example", "image", "view", "Response", "connection", "body", "remote", "method", "version", "output", "application", "document", "status", "result", "site", "model", "reply", "out", "results", "client", "object", "cache", "service", "reference", "json", "content", "collection", "http"], "path": ["filter", "text", "p", "url", "uri", "message", "image", "resource", "info", "data", "ath", "method", "output", "folder", "PATH", "route", "index", "key", "out", "dir", "config", "directory", "filename", "Path", "base", "point", "object", "id", "cache", "string", "name", "pattern", "location", "content", "value", "format", "http"], "file": ["to", "pe", "log", "url", "FILE", "resource", "uri", "image", "le", "b", "connection", "lock", "info", "data", "child", "socket", "part", "folder", "f", "it", "zip", "rule", "route", "feed", "h", "out", "class", "source", "dir", "directory", "filename", "l", "use", "work", "files", "base", "object", "local", "handler", "name", "up", "full", "File", "function", "fe", "http", "fp", "lib"], "in": ["ins", "resource", "In", "copy", "b", "ax", "thin", "init", "data", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "lin", "inn", "out", "s", "cin", "i", "is", "source", "kin", "reader", "rin", "win", "nin", "stream", "login", "inner", "r", "id", "ac", "bin", "c", "con", "binary", "pin", "ini", "as", "serv", "isin"]}}
{"id1": "1954410", "id2": "3945236", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"doExecute": ["doSendutes", "doexecuteutes", "submitExecApply", "doexecuteRun", "doExecutes", "submitexecuteRun", "submitexecuteute", "doSendApply", "doexecuteApply", "doExecApply", "submitexecuteutes", "submitexecuteApply", "doSendRun", "doExecRun", "doSendute", "submitExecRun", "submitExecute", "doexecuteute", "submitExecutes"], "mapping": ["amapping", "amatching", " matching", "fapping", " mapper", "matching", "amapper", "fatching", "mapper", " minding", "fapper", "aminding", "finding", "minding"], "form": ["forms", "page", "Form", "component", "url", "flow", "method", "field", "definition", "template", "formation", "xml", "builder", "config", "command", "transform", "control", "object", " forms", "submit", "FORM", "app", "pattern", "format", "dom", "feed", "post", "owner"], "request": ["req", "url", "uri", "frame", "resource", "message", "server", "report", "parent", "call", "complete", "view", "requ", "_", "Response", "HTTP", "method", "data", "this", "hello", "session", "application", "model", "result", "input", "route", "Request", "type", "Upload", "s", "xml", "instance", "pull", "QUEST", "create", "reader", "add", "client", "self", "worker", "user", "queue", "object", "address", "submit", "name", "re", "Accept", "ware", "Bytes", "context", "json", "query", "path", "current", "format", "q", "Reply", "use"], "response": ["resp", " Response", "page", "req", "res", "resource", "message", "report", "server", "view", "Response", "data", "output", "application", "status", "model", "result", "reply", "xml", "Resp", "client", " responses", "object", "v", "handler", "json"], "errors": [" logs", " this", " status", " management", " flashes", " Messages", " error", " mess", " messages", " messenger", " events", " managers", " session", " calls", " payload", " problems", " translations", " failures", " logger", " warnings", " responses", " commands", " streams", " updates", "mess", " replies", " acc", " changes", " messaging"], "isMultipart": ["isMultippedart", "isMultompPart", "isMultiage", "isMultiparts", "isMultiIPPart", "isMultippedost", "isMultippage", "isMultippart", "isMultiIPost", "isMultipPart", "isMultompost", "isMultIPart", "isMultompart", "isMultipparts", "isMultippedound", "isMultiart", "isMultipound", "isMultIPPart", "isMultipost", "isMultitage", "isMultompound", "isMultipated", "isMultiipart", "isMultiated", "isMultiipound", "isMultitated", "isMultipage", "isMultIPound", "isMultiipost", "isMultippedPart", "isMultiIPart", "isMultippated", "isMultitart", "isMultitarts", "isMultiIPound", "isMultIPost", "isMultiarts", "isMultiipPart"], "mailInstance": ["fileUsage", " emailInst", " mailManager", "fileManager", " emailinstance", "emailManager", " mailUsage", " emailInstance", "emailInst", "mailinstance", "fileinstance", " emailUsage", "mailUsage", "mailInst", "mailManager", " mailinstance", "emailinstance", "emailInstance", "fileInst", "fileInstance", " mailInst"], "fields": ["forms", "maps", "keys", "gets", "archives", "rows", "details", "links", "users", "data", "parts", "lists", "forces", "tags", "acks", "headers", "dates", "field", "loads", "plugins", "groups", "input", "features", "comments", "classes", "lines", "s", "flows", "objects", "posts", "facts", "holders", "properties", "qs", "states", "files", "pages", "ids", "models", "packs", "params", "cells", "locks", "atts", "checks", "views", "ments", "rules", "types", "words", "boxes", "events", "members", "utils", "uploads", "services", "strings", "changes"], "attachments": ["Attachments", "attees", "payments", "attachlements", "achparts", "attments", "Attachlements", "attachees", "payresses", "attlements", "payparts", "Attachees", "extments", "supplements", "attachps", "attachparts", "attions", "achment", "attment", " attachresses", "Attachps", " attachparts", "payment", "suppment", "extions", "achresses", "Attachers", "suppees", "Attachment", "achments", "attachresses", "suppments", "attachers", "attachment", "extps", "exters", "Attachions", "attachions", "atters", "attps", " attachment"], "items": ["keys", "ins", "rows", "apters", "links", "lists", "parts", "data", "reports", "apps", "Items", "es", "groups", "plugins", "lines", "ips", "children", "objects", "results", "alls", "qs", "files", "pages", "ids", "orders", "names", "models", "ers", "list", "locks", "ops", "types", "events", "phones", "its"], "iter": ["enter", "page", "altern", "http", "master", "itter", "ser", "loc", "ul", "event", "outer", "oper", "ner", "inc", "loop", "it", "zip", "exp", "finder", "coll", "upper", "end", "el", "ver", "gener", "i", "reader", "li", "keep", "ter", "er", "edit", "ip", "inner", "Iterator", "former", "slice", "walker", "skip", "ir", "file", "err", "list", "Iter", "inter", "ator", "izer", "order", "ite", "cher", "chain", "iterator"], "item": ["art", "widget", "image", "volume", "data", "more", "entry", "temp", "issue", "hop", "token", "anything", "file", "update", "page", "resource", "server", "event", "info", "folder", "all", "result", "coll", "index", "missing", "type", "element", "plugin", "i", "er", "object", "handler", "entity", "layer", "custom", "post", "attribute", "original", "url", "complete", "site", "storage", "val", "instance", "api", "section", "atom", "album", "user", "obj", "app", "extra", "up", "order", "next", "example", "it", "area", "container", "source", "reader", "li", "ip", "inner", "base", "slice", "Item", "load", "name", "other", "service", "full", "get", "or", "current"], "aux": ["asc", "imp", "buf", "prefix", "uf", "array", "des", " Aux", "frac", "uc", "ru", "cmp", "except", "aw", "off", "data", "ux", "aos", "anc", "alias", "offs", "etc", "fax", "axe", "ox", "cas", "auc", "union", "pkg", "aus", "packages", "sub", "ras", "amp", "au", "abc", "sup", "af", "extra", "aff", "ou", "lc", " auxiliary", "ups", "abs", "strings", "lang", "ants", "ext"], "part": ["art", "partial", " Part", "component", "one", "html", "parent", "b", "connection", "act", "info", "data", "parts", "back", "step", "pos", "field", "fact", "f", "area", "group", "no", "block", "ch", "ref", "and", "key", "type", "val", "player", "error", "element", "instance", "plugin", "class", "action", "add", "section", "pair", "PART", "l", "co", "pi", "base", "user", "point", "Part", "object", "joined", "po", "change", "id", "patch", "file", "obj", "start", "name", "list", "per", "full", "diff", "pre", "layer", "word", "comp", "format", "but", "on", "p", "join"], "baos": [" bao", "BAosh", " bais", "Bao", "haoss", "paOS", "baOs", "bao", "paot", "BAOs", "bois", "BaoS", "pao", " baOS", "bais", "boOS", " baot", "Baos", " baoS", "baosi", "abaOs", "BAoS", "hais", "Bais", "paosh", "baot", "haos", "baOS", "abais", "boot", "BAosi", "boos", "boosh", "boo", "pais", "abaos", "hao", "BAoss", "baoss", "BaOs", "abaosi", "baosh", "BAis", "BAos", "Baosi", "BAo", "paos", "baoS", " baoss"], "body": ["text", "description", "url", "message", "resource", "length", "null", "b", "html", "connection", "summary", "data", "parts", "options", "shell", "port", "headers", "output", "document", "zip", "reply", "translation", "template", "end", "type", "pass", "source", "comment", "header", "size", "media", "flash", "tree", "object", "string", "fee", "params", "name", "binary", "full", "json", "query", "content", "value", "state", "common", "Body"], "preferencesInstance": ["prefirmsInstance", "prefiesInstance", "prefferencesClient", "prefferencesInstance", "preffeesClient", "prefiesClient", "preffeesinstance", "prefirmsClient", "preferencesClient", "prefferencesinstance", "prefiesinstance", "prefeesClient", "prefeesInstance", "preferencesinstance", "prefeesinstance", "prefirmsinstance", "preffeesInstance"]}}
{"id1": "1698200", "id2": "11341711", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginBitShares", "loginBandRay", "loginbitShares", "loginbitshare", " loginBitRay", "loginBandshare", " loginBitshare", " loginBitShares", "loginbitShare", "loginBitshare", "loginBandShares", "loginBandShare", "loginbitRay", "loginBitRay"], "params": ["ls", "param", "page", "lp", "ssl", "eters", "server", "details", "cmp", "par", "manager", "ps", "fps", "options", "parts", "ns", "parser", "reports", "phrase", "radius", "bis", "vs", "Parameters", "photos", "settings", "results", "posts", "api", "parse", "properties", "config", "license", "ip", "Par", "pi", "base", "eps", "cache", "mm", "ams", "ops", "ctx", "pm", "php", "rules", "words", "json", "pro", "utils", "services", "http", "p", "ds"], "httpclient": ["ttpserver", "webserver", "httpsclient", "httpsapi", " httphttp", "phpapi", "htmlclient", "ttpClient", "httpsconnection", "htmlresponse", "webClient", "httpClient", "webclient", " httpapi", "httpconnection", "ttphttp", "httpsresponse", "httphttp", " httpserver", "httpsClient", "phpclient", " httpClient", "phpconnection", "httpserver", "htmlClient", "httpapi", "phpClient", "webhttp", " httpconnection", "ttpclient", "htmlconnection"], "httppost": ["httpport", " httplost", " httplort", "httpoint", "httpperost", "httphort", "httphost", "httppeost", " httpoint", " httposter", "httport", " httppeood", "httpood", "httppsoint", " httppeost", "httppeoint", "httcppood", "httcpposter", " httppood", " httploster", "httcppost", " httppoint", " httpprost", "httphoster", "httpprost", " httpost", "httplpost", "httppsost", " httprost", "httploster", "httppsoster", "httplost", "httprost", " httpposter", " httppeoster", "httppoint", "httpposter", "httppood", "httcppoint", "httphpost", "httposter", "httpppost", "httpost", " httppeoint", "httppeoster", " httpport", "httplort", " httpppost", "httppeood", " httplpost", "httppsrost"], "formparams": ["formparam", "formedblock", "Formparams", "FORMams", "formedams", "Formsettings", "handargs", "fauthors", "feedparam", "formams", "feedsettings", "feedparams", "feedams", "handParameters", "handams", "headparam", "formargs", " formblock", "formauthors", "fams", "fparams", " formams", " formparam", "Formparam", "FORMparams", " formnames", " formsettings", "FORMblock", " formargs", "formnames", "formedparam", "FORMparam", "FormParameters", "headnames", " formauthors", "Formargs", "formedparams", "formsettings", "formParameters", "handparams", "Formams", "formedauthors", "Formnames", "headams", " formParameters", "fparam", "headparams", "formblock"], "entity": ["page", " entities", "url", "ities", "e", "resource", "server", "html", "body", "connection", "form", "Entity", "event", "data", "output", "ec", "entry", "document", "model", "result", "translation", "ent", "type", "el", "xml", "api", "article", "db", "et", "object", "email", "file", " Entity", "service", "environment", "json", "response", "query", "content", "collection", "person"], "httpresponse": ["phpresponse", "phpresp", "htmlclient", "htmlresponse", " httpresp", "hyperclient", "Httpresponse", "hyperserver", "httpresp", " httpserver", "phpserver", "htmlserver", "httpserver", "hyperresponse", "Httpserver", "Httpresp"], "it": ["ort", " It", "ins", "ct", "ait", "IT", "It", "st", "init", "ul", "iti", "si", "you", "not", "in", "ati", "entry", "iv", "set", "index", "itted", "sort", "and", "end", "the", "i", "ist", "mit", "l", "edit", "ip", "lit", "slice", "pit", "ind", "which", "ic", "start", "I", "op", "ite", "cont", "or", "iz", "quit", "its", "rit"], "escookie": ["Escaddy", " escaddy", "Escerve", "ascinel", "descenter", "estaddy", "escinel", " esccookie", "ascake", "escake", "ascaddy", "sccel", " enookie", "estenter", "scale", " encookie", "escenter", "cookie", "ecookie", "esccookie", "eccookie", "scake", "scookie", "Escenter", "ascale", "esccel", "desccel", "Escinel", "ascookie", "descake", "caddy", "escoding", "Esccel", "ascerve", "escaddy", "escale", "Escookie", "asccel", "estookie", "descaddy", "cerve", "ecoding", "ecaddy", "escerve", "descookie", "estcel", " escoding", "cinel", " enoding", "descale", " enaddy"]}}
{"id1": "8921716", "id2": "8320469", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"MD5": ["MP512", "MD512", " MD512", "SHA5", "SHA4", "MD8", "MP5", "MP4", "SHA8", "MP8", "MD4", " MD8", "SHA512", " MD4"], "text": ["font", "prefix", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "this", "in", "output", "input", "str", "editor", "hex", "password", "template", "bytes", "key", "test", "code", "class", "source", "config", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "path", "word", "content", "ext", "format", "buffer", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedEncodedATION", "UnsupportedEncagingception", "Unsupportedencodingception", "UnsupportedEncodingATION", "UnsupportedencodingATION", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingATION", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedEncasingException", "UnsupportedencodedATION", "UnsupportedEncagingException", "Unsupportedencodedception", "UnsupportedEncagingATION"], "md": ["m", "rm", "hd", " MD", "Cmd", "message", "mp", "body", "cmd", "sha", "pg", "method", "data", "mo", "dig", "dd", "rpm", "mode", "hash", "mc", "valid", "d", "mag", "vd", "od", "ms", "meta", "me", "mb", "code", "amd", "mg", "dm", "bd", "wd", "metadata", "cm", "bf", "pd", "MD", "docker", "di", "ad", "mac", "nm", "mand", "match", "mm", "ma", "ld", "pm", "mt", "cd", "mod", "manager", "df"], "md5hash": ["md25Hash", " md5sum", "md8hash", "md5version", " md5hex", "md4Hash", "mand53Hash", " md6hash", "md6Hash", "md4sum", "md6kh", "md53version", "mddownsum", "md5Hash", "mddownHash", "md2sum", "mddownkh", "md2html", "mand5version", "md5hex", "mand5hash", "md6hash", "md6hex", "md8hex", "md25version", "md8Hash", "mddownhash", "md2version", "md25html", "md4hash", "md8sum", "md53hash", " md6hex", " md6Hash", " md6sum", "md2hash", " md5kh", "md25hash", "mand5Hash", "md53Hash", "mand5html", "md5sum", "mand53version", "md2kh", "md4hex", " md5Hash", "mand53hash", "md6sum", " md6kh", "mand53html", "md5kh", "md53html", "md2Hash", "md5html"]}}
{"id1": "21642215", "id2": "23088292", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["addLinks", " addIDS", "addIDS", "loadIDs", "loadLinks", " addLinks", "addID", "loadIDS", " addID", "findID", "findIDs", "findLinks", "findIDS", "loadID"], "row": ["array", "rows", "report", "col", "server", "ro", "copy", "view", "scan", "item", "cell", "info", "raw", "group", "entry", "result", "index", "ow", "batch", "job", "key", "tab", "column", "builder", "reader", "record", "table", "r", "tr", "user", "Row", "list", "up", "per", "bug", "query", "head", "feed", "post", "ry"], "name": ["NAME", "ame", "filter", "prefix", "description", "resource", "image", "n", "connection", "info", "username", "title", "search", "alias", "str", "named", "key", "type", "time", "source", "Name", "size", "filename", "number", "string", "file", "start", "path", "query", "word"], "in": ["at", "rec", "m", "ex", "gen", "ins", "ssl", "resource", "image", "In", "b", "n", "lock", "init", "session", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "inn", "container", "out", "s", "conn", "xml", "cin", "i", "source", "is", "win", "reader", "record", "with", "iter", "a", "stream", "l", "nin", "login", "inner", "min", "user", "r", "cache", "token", "string", "bin", "err", "c", "con", "file", "ic", "re", "diff", "pin", "ini", "query", "as", "path", "buffer", "again", "update", "http", "serv", "doc"], "urlName": ["urlStr", "urlname", " urlname", "filePath", " urlPath", "lPath", "toolPath", "lStr", "URLPath", "UrlType", "UrlStr", "lType", "URLname", "fileName", " urlType", "lName", "urlPart", "UrlPath", "filename", "urlPath", "URLName", "Urlname", "UrlName", "lname", "toolName", "toolname", "UrlPart", "filePart", " urlPart", " urlStr", "urlType"], "url": ["fl", "uri", "ssl", "resource", "image", "server", "b", "connection", "io", "org", "link", "socket", "channel", "f", "input", "URL", "bel", "out", "source", "reader", "client", "stream", "l", "web", "base", "user", "r", "gl", "file", "loader", "service", "sl", "path", "Url", " URL", "hub", "buffer", "http", "feed", "open"], "inputLine": ["searchFile", "baseLINE", "updateline", "responseLINE", "againLine", "rawL", "accessLINE", "output\n", "indexLine", "baseLine", "inputStream", " inputEntry", "InputRoute", " inputFile", "htmlString", "dataLine", "issueLine", "htmlLINE", "typeLine", "requestUrl", " inputEmail", " inputWrite", "Input\n", "rawFile", "inputString", "formline", "inputWrite", " input\n", " inputL", "dataWrite", "inputEmail", "typeline", "Inputline", "dataLink", " inputRoute", "InputFile", "againLINE", "formLINE", "InputBlock", "inputLin", "updateLine", "execUrl", "responseLink", "dataSync", "requestLINE", "indexEntry", "dataBlock", "baseline", "InputLo", "readLook", "updateLin", "readL", " inputLINE", "requestEmail", "uploadSel", "readSync", "dataLin", "searchL", "dataLINE", "inputline", "uploadline", "input\n", "readLin", "InputLINE", "dataFile", "updateLINE", " inputLo", "execEmail", "inputBlock", "dataRoute", " inputUrl", "requestString", "uploadLin", "inputL", "accessSync", " inputSource", "responseLine", "InputLine", "inputUrl", "formLine", "issueLin", "uploadLine", "execLine", "dataUrl", "searchLine", "issueline", "inputSync", "issueSel", " inputLook", "requestline", "accessEntry", " inputStream", "searchStream", "htmlline", "inputLook", "inputRoute", "inputSource", " inputBlock", "InputSync", "inputLo", "formLin", " inputSel", "requestLine", "inputLink", "InputStream", "dataline", " inputSync", "typeLink", "readLine", "againUrl", "execline", "inputEntry", "inputFile", " inputString", "readFile", "responseFile", "dataSource", "readline", "typeLINE", " inputLink", "inputSel", " inputline", "againWrite", "InputSource", "indexLINE", "InputLink", "indexSync", "dataLo", "htmlLine", "dataLook", "InputL", "rawline", "baseFile", "rawLine", " inputLin", "accessLine", "inputLINE"], "score": ["confidence", "message", "core", "length", "count", "speed", "gain", "ranking", "loss", " Score", "weight", "ner", "winner", "status", "result", "price", "index", "error", "key", "test", "live", "code", "player", "time", "size", "width", "seed", "feature", "sc", "match", "fee", "scoring", "cost", "grade", "rank", "Score", "value", "fit", "level", "game", "rice", "rate"], "metaboliteID": ["metaboliciteInfo", "metabolizeID", "metabolitationName", "metmbolitableIndex", "metovaliteId", "metaboliqueIDs", "metabololeID", "metabolitionIndex", "metabolizeInfo", "metovaliteAddress", "metaboliqueID", "metmboliqueIDs", "metaboliteIN", "metabolicizeInfo", "metabololeSize", "metaboliteSize", "metovalriteIN", "metabolverseIN", "metabolicizeScore", "metabolitableId", "metaboliqueType", "metabolicizeID", "metmbolitableSize", "metabolheticID", "metabolriteIDs", "metovalriteId", "metabolriteAddress", "metmboliteType", "metabolriteIN", "metaboliciteName", "metaboliciteScore", "metabolizeScore", "metaboliteInfo", "metmboliqueType", "metaboliqueId", "metmboliteID", "metabolitationId", "metmboliqueId", "metovaliteIN", "metabolriteInfo", "metabolitionId", "metabolitableIndex", "metabolriteName", "metabolitionAddress", "metabolitionID", "metaboliteIndex", "metmboliteId", "metaboliciteID", "metabolverseId", "metmboliteSize", "metaboliteIDs", "metabolriteScore", "metabolitableIDs", "metabololeIndex", "metabolicizeName", "metabolidateID", "metovalriteID", "metmbolitableID", "metabolitableName", "metabolriteIndex", "metabolriteType", "metabolitationID", "metovaliteName", "metabolitationIN", "metmboliteIndex", "metabolitableSize", "metovaliteID", "metabolidateName", "metmboliteName", "metaboliteAddress", "metmbolitableName", "metovalriteAddress", "metabololeName", "metaboliteScore", "metaboliteId", "metovalriteIndex", "metabolidateScore", "metabolriteId", "metabolheticId", "metabolriteID", "metovaliteIndex", "metmboliqueID", "metabolheticIndex", "metabolriteSize", "metaboliteName", "metabolidateInfo", "metovalriteName", "metabolizeName", "metabolitableType", "metabolheticAddress", "metaboliteType", "metmboliteIDs", "metabolverseName", "metabolitableID", "metabolverseID"], "dataScore": [" dataWeight", "videoWeight", "indexID", "videoScore", "doubleType", "dataID", "dataRank", "numberGrade", "dataType", "inputMatch", "numberRank", "dataGrade", "DataSum", "DataSize", "numberWeight", "doubleWeight", "styleWeight", "doubleScore", "dataSize", " dataMatch", "doubleRank", "dataSource", "indexSource", "inputID", "laSum", "inputSize", "numberLevel", " dataSum", "numberType", "laPath", "DataMatch", "styleScore", " dataGrade", "DataPath", "styleType", "styleSize", "videoSize", "inputScore", "dataSum", "dataLevel", " dataPath", "indexScore", "videoType", "indexPath", " dataSource", "laLevel", "DataGrade", "inputSource", "DataRank", "dataWeight", "DataScore", "dataPath", "DataLevel", " dataRank", " dataType", " dataID", " dataLevel", " dataSize", "numberScore", "laScore", "inputPath", "dataMatch"], "data": ["DATA", "sample", "text", "pad", "array", "resource", "image", "message", "style", "body", "empty", "info", "weight", "area", "zip", "input", "result", "map", "split", "dat", "batch", "missing", "error", "done", "key", "code", "results", "source", "size", "media", "number", "ata", "div", "change", "string", "alpha", "extra", "json", "response", "picture", "ui", "content", "value", "buffer"], "molecularWeight": ["molesularSize", "molescularSize", "moleciumFlow", "mosellularWidth", "mosellularWeight", "molecularSize", "moleculeFlow", "moleularSize", "moleculeWidth", "moleuralWidth", "molesularWidth", "moleculeWeight", "molescularWeight", "molescularWidth", "molesularWeight", "molecularWidth", "mosecularWidth", "mosecularWeight", "molellularWeight", "moleciumWeight", "moleularWeight", "moleularWidth", "molecularFlow", "molellularWidth", "molellularFlow", "moleciumWidth", "moleculeSize", "moleuralSize", "moleuralWeight", "mosecularFlow", "mosellularFlow"]}}
{"id1": "19335986", "id2": "21656668", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["unchandledEvent", "uncachedException", "CaughtEvent", "unchandledexc", "CaughtException", "uncachedexc", "uncatchedException", "uncachedEvent", "CatchedEvent", "uncatchedexc", "uncaughtEvent", "uncatchedEvent", "Caughtexc", "uncaughtexc", "Catchedexc", "CatchedException", "unchandledException"], "t": ["m", "g", "n", "title", "tx", "f", "it", "d", "out", "s", "type", "let", "T", "te", "ing", "l", "tree", "tr", "r", "c", "ts", "w", "ed", " td", "ty", "p", " T"], "e": ["m", "enter", "pe", "ee", "ev", "esi", "j", "se", "example", "eb", "en", "ce", "event", "data", "ge", "ie", "ec", "ele", "f", "oe", "es", "o", "d", "ace", "error", "ae", "me", "s", "el", "code", "element", "i", "Exception", "ne", "er", "E", "eu", "de", "r", "c", "err", "be", "diff", "environment", "ed", "fe", "exc", "ep", "p", "ception"], "display": ["page", "description", "console", "play", "default", "report", "image", "style", "view", "body", "panel", "summary", "profile", "this", "hide", "status", "d", "container", "me", "monitor", "process", "config", "Display", "design", "de", "position", "object", "screen", "scroll", "layout", "show", "window", "platform", "app", "host", "dis", "content", "fe", "p"], "shell": ["m", "console", "log", "image", "server", "copy", "b", "math", "body", "system", "lock", "child", "bash", " Shell", "sb", "loop", "status", "tool", "echo", "launch", "Shell", "cl", "clone", "container", "h", "live", "el", "process", "xml", "tools", "sym", "gui", "cli", "l", "exec", "machine", "sound", "hell", "app", "help", "ml", "kernel", "host", "environment", "sh", "mail", "buffer", "poll"], "message": ["m", "page", "description", "management", "console", "log", "image", "report", "server", "copy", "view", "body", "summary", "event", "data", "msg", "output", "member", "model", "status", " messenger", "application", "meter", " exception", "document", "result", "translation", "error", "essage", "monitor", "xml", "header", "media", "flash", "queue", "object", "email", "address", "mess", "response", "mail", "content", "buffer", "update", "value", "Message", "request"], "e1": [" e8", "E8", " e3", "E2", "E1", "exc3", "exc2", "e3", "E3", "exc1", " e2", "e8", "e2", "exc8"]}}
{"id1": "1180878", "id2": "7499186", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrlDATA", "fetchHTTPdata", "fetchHTTPData", "fetchJSONdata", "fetchUrlData", "fetchURLDATA", "fetchHTTPDATA", "fetchJSONDATA", "fetchUrldata", "frieveUrldata", "fetchURLdata", "frieveURLdata", "frieveURLData", "frieveUrlDATA", "frieveUrlData", "fetchJSONData", "frieveURLDATA"], "url": ["ur", "ls", "page", "text", "fl", "uri", "ssl", "resource", "image", "server", "html", "view", "connection", "loc", "data", "username", "f", "www", "URL", "href", "el", "download", "xml", "source", "api", "src", "filename", "l", "base", "user", "address", "string", "gl", "file", "name", "sl", "host", "path", "Url", "location", "http", "feed"], "proxyHost": ["cacheAddress", "remoteDomain", "cachePort", " proxyServer", "ProxyPort", "baseHost", "proxyDomain", "serverHost", "baseHead", "Proxyhost", "proxyServer", "proxyHead", "ProxyPath", "ProxyDomain", "ProxyHost", "proxyPath", " proxyAddress", "remoteAddress", "proxyAddress", "serverServer", "ProxyServer", "cacheHost", "serverAddress", "serverPath", "ProxyAddress", "baseAddress", "ProxyHead", "baseDomain", "remoteHead", "cachehost", "proxyhost", " proxyPath", "remoteHost", " proxyhost"], "proxyPort": ["cacheAddress", "cachePort", " proxyServer", "ProxyPort", "httpServer", "httpPort", "proxyServer", "ProxyHost", " proxyAddress", "proxyAddress", "cacheport", "httpHost", "cacheHost", "Proxyport", "ProxyAddress", "proxyport", " proxyport", "httpAddress", "ProxyServer"], "con": ["conv", "rec", "un", "cn", "act", "CON", "an", "socket", "bc", "part", "fa", "cl", "cas", "conn", "ver", "win", "min", "xc", "cache", "ac", "pc", "exec", "fac", "per", "pre", "ai", "on", "ocon", "pen", "com", "uc", "cp", "connection", "en", "rc", "remote", "cone", "inc", "func", "syn", "cc", "ctrl", "can", "change", "c", "cf", "pub", "x", "ca", "close", "cr", "ls", "gen", "fl", "sync", "ran", "mc", "ch", "run", "ci", "cur", "out", "don", "co", "login", "re", "pin", "http", "common", "open", "cons", "canon", "conf", "n", "Con", "ec", "f", "connect", "fan", "go", "cm", "sub", "fun", "fc"], "is": ["js", "does", "isl", "isi", "act", "os", "ps", "lis", "ori", "info", "mis", "il", "ics", "si", "iso", "oss", "ie", "cos", "in", "it", "es", "vs", "bis", "IS", "us", "isc", "ci", "out", "fs", "conn", "s", "iris", "ws", "ios", "i", "api", "cms", "ar", "im", "can", "are", "ib", "id", "iss", "ais", "ir", "ris", "has", "Is", "ri", "ops", "sp", "ai", "get", "as", "was", "or", "state", "isa", "cs", "abs", "bs", "its", "p", "isin", "isu", "serv"], "u": ["ur", "m", "nu", "un", "uri", "lu", "uc", "ru", "b", "uci", "os", "fu", "ul", "io", "ue", "ut", "uv", "f", "o", "su", "us", "iu", "h", "conn", "i", "cu", "api", "client", "l", "user", "v", "c", "file", "tu", "yu", "U", "ou", "up", "hu", "ui", "q", "http", "p"], "proxy": ["prot", "XY", "pe", "p", "uri", "ssl", "resource", " proxies", "server", "copy", "connection", "force", "remote", "xy", "port", "socket", "phone", "pse", "f", "zip", " Proxy", "pa", "shadow", "clone", "bean", "timeout", "type", "create", "api", "config", "client", "roxy", "l", "web", "ip", "Proxy", "cache", "address", "pc", "c", "host", "pin", "pool", "wrapper", "x", "plus", "fe", "http", "lib", "cop"], "baos": ["alos", "BAros", "balos", "paOS", "baOs", "abOs", "bao", "aOS", "BAOs", "pao", "baros", "calos", "aos", "bais", "haOS", "boas", "Baos", "boOS", "aas", "abos", "hais", "Bais", "haos", "abis", "baOS", "bolos", "caos", "boos", "pais", "hao", "baas", "BAOS", "BaOs", "BAis", "BAos", "caas", "caOS", "BAo", "Baros", "paos", "abros"]}}
{"id1": "647224", "id2": "3731077", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["Uploadfile", "uploadFiles", " uploadfile", " uploadDir", "uploadfile", "processDir", "UploadFile", "UploadDir", "processfile", "processFile", "uploadDir", " uploadFiles", "processFiles", "UploadFiles"], "inputFile": [" inputfile", "targetFolder", "inputPage", "InputFiles", "sourceLog", "inputFolder", "sourceType", "InputFile", " inputFiles", "InputDir", "targetDir", " inputDir", " inputFilename", " inputType", "sourceFolder", "initialFilename", "targetPage", "initialFolder", " inputFolder", " inputLog", "sourcePage", "targetStream", "targetFiles", "inputType", "sourceFile", "inputStream", "sourcefile", "initialFile", " inputStream", "inputFilename", "targetfile", "InputType", "targetFilename", "InputFolder", "inputDir", "initialStream", "inputfile", "targetLog", "inputFiles", " inputPage", "sourceStream", "inputLog", "InputStream", "Inputfile"], "targetFile": ["outputFiles", " targetName", "Targetfile", "outputLine", "outputName", " targetDir", "TargetName", "inputPlace", "targetPath", "targetDir", "TargetLine", "externalPath", " targetFiles", "externalFile", " targetfile", "TargetFile", "targetLine", "targetFiles", "sourcePlace", "sourceFile", "externalfile", "TargetDir", "targetPlace", "TargetPath", "outputPath", " targetLine", "targetfile", "inputDir", "TargetFiles", " targetPlace", " targetPath", "outputDir", "externalName", "sourcePath", "targetName", "sourceDir", "inputPath"], "outputFile": ["outputFiles", "outputStream", "inputPage", " targetDirectory", "currentFile", "currentFolder", "inputFolder", " outputFolder", "writeFile", "targetPath", "writeStream", "outputPlace", " targetFiles", "inputQueue", " outputPath", " outputDirectory", " outputPlace", "OutputFolder", "outPlace", "inputUrl", "outFolder", "targetFiles", " targetQueue", "targetQueue", " outputfile", "outputDirectory", "outfile", "currentPlace", "outputUrl", "inputStream", "outputQueue", "outputPath", "writeUrl", "targetfile", "outDirectory", "inputDirectory", "inputDir", " outputFiles", "OutputDir", "outputDir", "targetDirectory", "outputFolder", "inputfile", "outPath", "currentfile", "outputPage", " outputPage", "outFile", " outputUrl", " outputStream", "OutputFile", "inputFiles", " outputDir", "writePage", "Outputfile", "outputfile", "inputPath"], "in": ["rec", "ins", "url", "In", "init", "io", "data", "inc", "input", "din", "IN", "lin", "inn", "read", "s", "pass", "cin", "i", "is", "win", "pull", "reader", "kin", "issue", "inside", "nin", "stream", "rin", "login", "sub", "inner", "r", "id", "ac", "bin", "err", "con", "up", "diff", "pin", "ini", "source", "again", "serv", "isin"], "out": ["to", "page", "ex", "log", "writer", "console", "write", "report", "one", "image", "copy", "plain", "n", "cmd", "lock", "io", "off", "data", "outer", "sys", "this", "sync", "inc", "output", "o", "Out", "error", "s", "conn", "source", "print", "client", "co", "dump", "ger", "point", "user", "table", "r", "outs", "base", "cache", "inner", "exec", "bin", "file", "err", "println", "by", "inter", "net", "up", "OUT", "state", "again", "ext"], "line": ["page", "pe", "LINE", "log", "url", "frame", "unit", "e", "lf", "write", "le", "lock", "cell", "data", "link", "sync", "part", "limit", "range", "entry", "rule", "split", "lin", "lines", "job", "inline", "type", "row", "error", "code", "pass", "comment", "header", "base", "string", "file", "Line", "name", "word", "lc", "buffer", "ine", "block", "char"], "bytes": ["ls", "values", "rows", "Bytes", "items", "length", " lines", "count", "os", "ones", "pos", "es", "zip", "reads", "bs", "groups", "comments", "classes", "lines", "ines", "s", "ips", "code", "seconds", "i", "tes", "size", "les", "len", "pages", "units", "number", "files", "outs", "bits", " cycles", "steps", "eps", "codes", "binary", "blocks", "words", "cycles", "bps", "odes"]}}
{"id1": "1954410", "id2": "21489105", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"doExecute": ["doSendutes", "doexecuteutes", "submitExecApply", "doexecuteRun", "doExecutes", "submitexecuteRun", "submitexecuteute", "doSendApply", "doexecuteApply", "doExecApply", "submitexecuteutes", "submitexecuteApply", "doSendRun", "doExecRun", "doSendute", "submitExecRun", "submitExecute", "doexecuteute", "submitExecutes"], "mapping": ["amapping", "amatching", " matching", "fapping", " mapper", "matching", "amapper", "fatching", "mapper", " minding", "fapper", "aminding", "finding", "minding"], "form": ["forms", "page", "Form", "component", "url", "flow", "method", "field", "definition", "template", "formation", "xml", "builder", "config", "command", "transform", "control", "object", " forms", "submit", "FORM", "app", "pattern", "format", "dom", "feed", "post", "owner"], "request": ["req", "url", "uri", "frame", "resource", "message", "server", "report", "parent", "call", "complete", "view", "requ", "_", "Response", "HTTP", "method", "data", "this", "hello", "session", "application", "model", "result", "input", "route", "Request", "type", "Upload", "s", "xml", "instance", "pull", "QUEST", "create", "reader", "add", "client", "self", "worker", "user", "queue", "object", "address", "submit", "name", "re", "Accept", "ware", "Bytes", "context", "json", "query", "path", "current", "format", "q", "Reply", "use"], "response": ["resp", " Response", "page", "req", "res", "resource", "message", "report", "server", "view", "Response", "data", "output", "application", "status", "model", "result", "reply", "xml", "Resp", "client", " responses", "object", "v", "handler", "json"], "errors": [" logs", " this", " status", " management", " flashes", " Messages", " error", " mess", " messages", " messenger", " events", " managers", " session", " calls", " payload", " problems", " translations", " failures", " logger", " warnings", " responses", " commands", " streams", " updates", "mess", " replies", " acc", " changes", " messaging"], "isMultipart": ["isMultippedart", "isMultompPart", "isMultiage", "isMultiparts", "isMultiIPPart", "isMultippedost", "isMultippage", "isMultippart", "isMultiIPost", "isMultipPart", "isMultompost", "isMultIPart", "isMultompart", "isMultipparts", "isMultippedound", "isMultiart", "isMultipound", "isMultIPPart", "isMultipost", "isMultitage", "isMultompound", "isMultipated", "isMultiipart", "isMultiated", "isMultiipound", "isMultitated", "isMultipage", "isMultIPound", "isMultiipost", "isMultippedPart", "isMultiIPart", "isMultippated", "isMultitart", "isMultitarts", "isMultiIPound", "isMultIPost", "isMultiarts", "isMultiipPart"], "mailInstance": ["fileUsage", " emailInst", " mailManager", "fileManager", " emailinstance", "emailManager", " mailUsage", " emailInstance", "emailInst", "mailinstance", "fileinstance", " emailUsage", "mailUsage", "mailInst", "mailManager", " mailinstance", "emailinstance", "emailInstance", "fileInst", "fileInstance", " mailInst"], "fields": ["forms", "maps", "keys", "gets", "archives", "rows", "details", "links", "users", "data", "parts", "lists", "forces", "tags", "acks", "headers", "dates", "field", "loads", "plugins", "groups", "input", "features", "comments", "classes", "lines", "s", "flows", "objects", "posts", "facts", "holders", "properties", "qs", "states", "files", "pages", "ids", "models", "packs", "params", "cells", "locks", "atts", "checks", "views", "ments", "rules", "types", "words", "boxes", "events", "members", "utils", "uploads", "services", "strings", "changes"], "attachments": ["Attachments", "attees", "payments", "attachlements", "achparts", "attments", "Attachlements", "attachees", "payresses", "attlements", "payparts", "Attachees", "extments", "supplements", "attachps", "attachparts", "attions", "achment", "attment", " attachresses", "Attachps", " attachparts", "payment", "suppment", "extions", "achresses", "Attachers", "suppees", "Attachment", "achments", "attachresses", "suppments", "attachers", "attachment", "extps", "exters", "Attachions", "attachions", "atters", "attps", " attachment"], "items": ["keys", "ins", "rows", "apters", "links", "lists", "parts", "data", "reports", "apps", "Items", "es", "groups", "plugins", "lines", "ips", "children", "objects", "results", "alls", "qs", "files", "pages", "ids", "orders", "names", "models", "ers", "list", "locks", "ops", "types", "events", "phones", "its"], "iter": ["enter", "page", "altern", "http", "master", "itter", "ser", "loc", "ul", "event", "outer", "oper", "ner", "inc", "loop", "it", "zip", "exp", "finder", "coll", "upper", "end", "el", "ver", "gener", "i", "reader", "li", "keep", "ter", "er", "edit", "ip", "inner", "Iterator", "former", "slice", "walker", "skip", "ir", "file", "err", "list", "Iter", "inter", "ator", "izer", "order", "ite", "cher", "chain", "iterator"], "item": ["art", "widget", "image", "volume", "data", "more", "entry", "temp", "issue", "hop", "token", "anything", "file", "update", "page", "resource", "server", "event", "info", "folder", "all", "result", "coll", "index", "missing", "type", "element", "plugin", "i", "er", "object", "handler", "entity", "layer", "custom", "post", "attribute", "original", "url", "complete", "site", "storage", "val", "instance", "api", "section", "atom", "album", "user", "obj", "app", "extra", "up", "order", "next", "example", "it", "area", "container", "source", "reader", "li", "ip", "inner", "base", "slice", "Item", "load", "name", "other", "service", "full", "get", "or", "current"], "aux": ["asc", "imp", "buf", "prefix", "uf", "array", "des", " Aux", "frac", "uc", "ru", "cmp", "except", "aw", "off", "data", "ux", "aos", "anc", "alias", "offs", "etc", "fax", "axe", "ox", "cas", "auc", "union", "pkg", "aus", "packages", "sub", "ras", "amp", "au", "abc", "sup", "af", "extra", "aff", "ou", "lc", " auxiliary", "ups", "abs", "strings", "lang", "ants", "ext"], "part": ["art", "partial", " Part", "component", "one", "html", "parent", "b", "connection", "act", "info", "data", "parts", "back", "step", "pos", "field", "fact", "f", "area", "group", "no", "block", "ch", "ref", "and", "key", "type", "val", "player", "error", "element", "instance", "plugin", "class", "action", "add", "section", "pair", "PART", "l", "co", "pi", "base", "user", "point", "Part", "object", "joined", "po", "change", "id", "patch", "file", "obj", "start", "name", "list", "per", "full", "diff", "pre", "layer", "word", "comp", "format", "but", "on", "p", "join"], "baos": [" bao", "BAosh", " bais", "Bao", "haoss", "paOS", "baOs", "bao", "paot", "BAOs", "bois", "BaoS", "pao", " baOS", "bais", "boOS", " baot", "Baos", " baoS", "baosi", "abaOs", "BAoS", "hais", "Bais", "paosh", "baot", "haos", "baOS", "abais", "boot", "BAosi", "boos", "boosh", "boo", "pais", "abaos", "hao", "BAoss", "baoss", "BaOs", "abaosi", "baosh", "BAis", "BAos", "Baosi", "BAo", "paos", "baoS", " baoss"], "body": ["text", "description", "url", "message", "resource", "length", "null", "b", "html", "connection", "summary", "data", "parts", "options", "shell", "port", "headers", "output", "document", "zip", "reply", "translation", "template", "end", "type", "pass", "source", "comment", "header", "size", "media", "flash", "tree", "object", "string", "fee", "params", "name", "binary", "full", "json", "query", "content", "value", "state", "common", "Body"], "preferencesInstance": ["prefirmsInstance", "prefiesInstance", "prefferencesClient", "prefferencesInstance", "preffeesClient", "prefiesClient", "preffeesinstance", "prefirmsClient", "preferencesClient", "prefferencesinstance", "prefiesinstance", "prefeesClient", "prefeesInstance", "preferencesinstance", "prefeesinstance", "prefirmsinstance", "preffeesInstance"]}}
{"id1": "1798720", "id2": "18989018", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "label": 0, "substitutes": {"save": ["pack", "install", "Save", "report", "apply", "build", "copy", "data", "store", "archive", "clone", "process", "move", "create", "saving", "dump", "transform", "make", "change", "load", "upload", "transfer", "release", "setup", "update", "stage", "open"], "packageName": ["directoryDir", "packageNames", "pluginPart", " packagename", "moduleInfo", "packagePath", "directoryNames", "directoryName", "moduleDir", "packagename", "PackageDir", "directoryInfo", "PackageNames", "packageInfo", " packageNames", " packagePart", "packagePart", "moduleName", " packagePath", "sourcename", "modulePath", "pluginName", "pluginDir", "pluginPath", "PackageName", "PackageInfo", "sourcePath", "sourceName", "PackagePath", "directoryPath", "sourceDir", " packageInfo", "directoryPart", "directoryname"], "fileContents": ["imageHours", "getNames", "fileParts", "FileSources", "FileTextures", " fileContent", "FileContents", "getParts", "FileNames", "ileSources", "ileNames", "FileParts", "imageNames", "FileHours", "fileContent", " fileTextures", "getContent", "ileContents", " fileSources", "fileSources", " fileParts", "fileHours", "fileTextures", "imageParts", "FileContent", " fileHours", "imageContents", "ileTextures", "getContents"], "fileNames": ["fName", "filenames", "fullContents", "playName", "playContents", "FileContents", "viewNames", " fileName", "FileNames", "viewTypes", "FileNumbers", "fNames", "fNumbers", "pageTypes", "fileNumbers", "fileName", "FileTypes", "playNames", "fTypes", "logNames", "viewnames", "logTypes", "pageNames", "fullTypes", "fullNames", "pagenames", " filenames", "logName", "FileName", "fileTypes", " fileNumbers", "fullName", " fileTypes", "logContents"], "dirBase": ["packageRoot", "dirDir", "DirKit", "directoryDir", "packagebase", "directoryBase", "directoryKit", "DirRoot", "packagePath", "dirBased", " dirPath", "folderBased", " dirbase", "dirbase", "DirBase", "directoryBased", "moduleDir", "moduleKit", "dirKit", "directorybase", "DirPath", "folderDir", "folderBase", "dirRoot", "dirPath", "Dirbase", "packageBase", "DirDir", "moduleBased", "moduleBase", "folderbase", "modulebase", " dirRoot"], "packageDir": ["directoryDir", "packageDirectory", " packageFile", " packageFolder", " packageDirectory", "parentFile", "folderLib", "packageLib", "packagePath", "PackageDirectory", "directoryUrl", "parentDir", "packageFolder", " packageBase", "moduleDir", "PackageDir", "packageFile", "folderDir", "folderBase", "directoryDirectory", "moduleLib", "packageUrl", "parentFolder", " packagePath", "parentUrl", "modulePath", "PackageFile", "directoryFolder", "packageBase", " packageLib", "folderPath", " packageUrl", "moduleBase", "PackagePath", "directoryPath", "directoryFile"], "created": ["loaded", "established", "raised", "authorized", "founded", "null", "failed", "edited", "updated", "successful", "activated", "released", "icated", "required", "paid", "creator", "result", "generated", "aaaa", "called", "added", " existed", " Created", "worked", "create", "made", "true", "found", "owned", "Created", "creation", "confirmed", "produced", "formed", "left", "existent", "path", "were", "used", "ed", "needed", "controlled"], "currentPath": ["currentpath", " currentLocation", " currentPage", "CurrentPath", "currentRoot", "newPath", "newpath", " currentpath", "currentPage", "currentLocation", "currentlyPath", " currentDirectory", "newRoot", "CurrentRoot", "currentlypath", " currentRoot", "currentDirectory", "CurrentPage", "CurrentLocation", "CurrentDirectory", "newLocation", "currentlyPage", "Currentpath", "currentlyDirectory"], "i": ["k", "p", "u", "uri", "z", "e", "j", "isi", "b", "n", "fi", "init", "ori", "io", "info", "si", "ie", "part", "f", "it", "index", "d", "ci", "iu", "oi", "h", "ji", "me", "key", "s", "multi", "y", "li", "di", "mi", "ip", "pi", "xi", "hi", "eni", "slice", "inner", "yi", "id", "ti", "gi", "v", "c", "start", "name", "ix", "I", "ai", "phi", "zi", "ini", "ii", "ui", "bi", "x", "qi", "mu", "current", "ri"], "file": ["book", "pe", "http", "log", "uri", "unit", "resource", "play", "ile", "le", "b", "letter", "il", "io", "ul", "data", "child", "folder", "entry", "f", "rule", "feed", "out", "s", "source", "dir", "filename", "work", "l", "files", "base", "place", "name", "up", "per", "File", "full", "path", "or", "fe", "fp"], "fos": ["fo", "fis", "Fosh", "cfob", "ufob", "ofops", " fob", "fou", "ofos", "Fops", "flos", "Fos", "cfo", "ufo", "voes", "flou", "fosh", "ufos", "ofosh", " fops", " fo", "fios", "flis", "Fios", "Fou", "fops", " fosh", "fob", " fis", "cfos", "ofou", "vos", " foes", "Foes", "flosh", "vops", "foes", "ufoes", "flops", " fios", "cfoes", "Fis", "vios"], "fileSrc": [" fileSsrc", " fileSRC", "fileAsource", "FileDrec", "fileDRC", "FileDource", "fileNsrc", "FileDrc", "FileSrc", " fileDsrc", "fileSRC", "FileSRC", "FileSource", "fileSrs", "fileAsrs", " fileDrs", "fileDrc", "fileNRC", " fileSrs", "fileSource", "fileSrec", "fileDource", " fileDrc", " fileDRC", "fileAssrc", "fileDrec", "FileSrec", "fileAsrec", "FileDRC", "fileAsRC", "fileDsrc", "fileSsrc", "fileNrc", "fileAsrc", "fileDrs", "fileNrs"], "fileDst": ["fileDayst", "fileEnST", "FileDst", "fileDaysc", "fileNsrc", "FileDrc", "FileSrc", "FileSst", "fileFsc", "FileFst", "fileEnrc", "FileSsrc", "fileNsc", "fileDsc", "fileDaysrc", "fileNst", "fileDrc", "fileFst", "FileDsc", "fileFrc", "fileFST", "fileEnst", "FileSsc", "FileDST", "fileDST", "FileFsc", "FileFrc", "fileSST", "fileEnsc", "fileDayrc", "FileFST", "FileDsrc", "fileDsrc", "fileSsc", "fileSsrc", "fileSst", "fileNrc"], "reader": ["book", "report", "e", "rx", "ro", "rer", "server", "rc", "io", "data", "parser", "ner", "reading", "rar", "entry", "audio", "right", "Reader", "editor", "read", "row", "builder", "iter", "driver", "stream", "er", "rr", "worker", "inner", "r", "handler", "loader", "re", "per", "layer", "ler", "or", "buffer", "author", "oder", "director", "keeper", "ri", "ry"], "writer": ["book", "widget", "wr", "write", "e", "server", "message", "master", "connection", "sheet", "outer", "data", "later", "writing", "parser", "socket", "written", "writ", "output", "entry", "document", "editor", "o", "Writer", "key", "out", "player", "ws", "rw", "maker", "builder", "element", "driver", "war", "with", "riter", "width", "work", "er", "worker", "ger", "inner", "walker", "r", "wa", "handler", "wire", "loader", "w", "per", "writers", "words", "wrapper", "word", "ler", "buffer", "author", "office", "value"], "line": ["page", "text", "LINE", "log", "url", "lf", "write", "message", "unit", "le", "style", "connection", "letter", "item", "cell", "data", "ge", "link", "sync", "part", "entry", "model", "inline", "definition", "rule", "str", "lin", "lines", "error", "key", "type", "end", "row", "code", "pass", "jo", "column", "job", "source", "comment", "cle", "header", "l", "object", "id", "look", "cr", "string", "character", "stroke", "Line", "name", "response", "word", "lc", "buffer", "feed", "block", "char"]}}
{"id1": "19307120", "id2": "7633336", "code1": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 0, "substitutes": {"sendPost": ["doSub", "dopost", "executePost", "sendPOST", "postSub", "postPOST", "sendSub", "executeSub", "doPost", "postPost", "executepost", "executePOST", "postpost", "sendpost", "doPOST"], "url": ["ur", "ls", "page", "uri", "ssl", "ll", "resource", "server", "html", "connection", "loc", "remote", "link", "route", "www", "URL", "source", "api", "l", "base", "address", "string", "file", "name", "service", "sl", "host", "full", "bug", "path", "Url", "location", "hub", "http", "feed"], "param": ["page", "resource", "connection", "par", "Param", "info", "data", "part", "channel", "phrase", "output", "meter", "input", "ram", "password", "error", "Parameter", "temp", "source", "comment", "config", "base", "prom", "object", "address", "string", "patch", "question", "params", "name", "extra", "arg", "proc", "arm", "path", "query", "p"], "result": ["description", "res", "array", "default", "message", "report", "resource", "reason", "data", "msg", "output", "status", "answer", "valid", "error", "date", "test", "our", "home", "results", "comment", "true", "work", "Result", "user", "feature", "found", "match", "string", "load", "err", "success", "params", "extra", "grade", "ret", "json", "response", "runner", "function", "value", "buffer", "current", "expected", "request"], "httpurl": ["httpconfig", "workurl", "baseconfig", "phpurl", "httpUrl", "workcf", "phpUrl", "httpURL", "phpcf", "phpURL", "phpconfig", "baseurl", "workconn", "phpconn", " httpconfig", "httpconn", "workURL", " httpconn", " httpUrl", " httpURL", " httpcf", "baseURL", "baseUrl", "httpcf"], "httpConn": ["HttpExec", "webConnect", "httpsconn", "perExec", "perConn", "urlConnect", "phpConn", "webCon", "httpExec", "httpConnect", "httpsConnection", "httpsCon", " httpExec", "HttpConnect", " httpConnect", "perConnect", "webConnection", "urlCon", "phpconn", " httpCon", "HttpConnection", "webconn", "phpConnection", "HttpCon", "httpsConn", " httpConnection", "httpconn", " httpconn", "HttpConn", "urlConn", "Httpconn", "perconn", "webConn", "httpCon", "urlConnection", "httpConnection", "phpConnect", "urlconn"], "out": ["prefix", "ex", "log", "writer", "flow", "write", "plain", "copy", "null", "b", "In", "n", "connection", "parent", "init", "io", "outer", "inc", "socket", "output", "f", "exp", "o", "password", "Out", "h", "key", "conn", "pass", "temp", "flush", "cli", "dump", "inner", "outs", "user", "r", "file", "err", "extra", "w", "net", "OUT", "word", "plus", "again", "p"], "in": ["into", "rec", "ins", "In", "b", "init", "inc", "gin", "f", "input", "din", "IN", "lin", "inn", "read", "conn", "s", "cin", "i", "is", "win", "rin", "reader", "kin", "nin", "stream", "login", "inner", "min", "r", "id", "ac", "bin", "con", "err", "ic", "re", "pin", "ini", "as", "again", "serv", "isin"], "line": ["page", "text", "pe", "LINE", "log", "unit", "message", "e", "lf", "le", "letter", "cell", "data", "ge", "link", "entry", "model", "str", "lin", "cl", "lines", "job", "key", "inline", "row", "code", "end", "me", "i", "source", "comment", "reader", "record", "l", "ip", "user", "r", "id", "string", "character", "file", "Line", "name", "continue", "sl", "sel", "pin", "response", "word", "lc", "cr", "block", "char"]}}
{"id1": "22441244", "id2": "20939940", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"send": ["text", "sent", "message", "write", "append", "build", "set", "reply", "end", "add", "create", "parse", "delete", "export", "address", "exec", "submit", "start", "Send", "get", "transfer", "mail", "execute", "from", "open", "post"], "hsession": ["hsess", "hmessions", "hessions", "HSession", "opensessions", "hmsession", "hsSession", "opensess", "hhessions", "HSSession", "hsort", "hhort", "hesess", "hSession", "hmession", "hhSession", "hesort", "hessession", "hssession", "hmSession", "hsessions", "opensSession", "opensort", "hhession", "hesession", "opensession", "openssession", "HSsession", "hhsession", "HSessions", "hession", "hhess"], "session": ["proxy", "Session", "message", "resource", "server", "parent", "connection", "event", "project", "port", "chat", "application", "document", "site", "class", "ession", "client", "cache", "security", "essions", "host", "sl", "context", "response", "mail", "state", "manager"], "repositoryName": ["reposositoryAddress", "repoositoryEmail", "repositoryPath", "repoositoryPath", "repoitoryAddress", "reposessionName", "repoitoryEmail", "reposicleAddress", "reposicationAddress", "repoositoryFamily", "repositiveNAME", "reposessionNAME", "repositoryNAME", "reposicationFamily", "repositoryAddress", "repoositoryNAME", "repositoryFamily", "repoositoryAddress", "repoitoryName", "repositiveName", "reposicleName", "repositiveEmail", "repositivePath", "reposicleEmail", "reposessionPath", "reposositoryPath", "reposositoryNAME", "reposositoryFamily", "reposicationEmail", "reposicationName", "repoositoryName", "reposositoryEmail", "repoitoryPath", "reposicleFamily", "reposessionEmail", "repoitoryNAME", "reposositoryName", "repoitoryFamily", "repositoryEmail"], "ideIdint": ["IDEIdInt", "ideidn", "IDEIdn", "ideNamenumber", "IDEIdints", "ideInn", "IDEidn", "IDENameInt", "IDEidints", "ideTimeout", "IDEIdint", "ideAuthInt", "ideInint", "ideAuthint", "ideIdInt", "ideIdints", "IDEIdout", "IDENamenumber", "ideIdn", "ideNameInt", "ideNameint", "ideInfonumber", "ideInInt", "ideInfoInt", "IDEIdnumber", "ideIdout", "ideTimeInt", "ideInfoout", "ideIdnumber", "IDENameout", "ideNameout", "IDENameint", "IDEidint", "ideAuthn", "ideInints", "ideidInt", "ideTimeint", "ideAuthints", "ideidints", "ideTimenumber", "IDEidInt", "ideInfoint", "ideidint"], "to": ["prefix", "mobile", "uri", "message", "summary", "options", "phone", "title", "site", "about", "reply", "tel", "template", "settings", "source", "TO", "top", "client", "with", "contact", "sub", "target", "company", "address", "token", "account", "po", "name", "by", "location", "response", "mail", "office", "To", "from"], "cc": ["ct", "cn", "uc", "rc", "tc", "ce", "phone", "ec", "ck", "password", "cl", "nc", "ci", "cb", "code", "cca", "comment", "client", "contact", "cus", "company", "sc", "CC", "ac", "account", "address", "c", "card", "dc", "cf", "lc", "cs", "ca", "cr", "from"], "bcc": ["bbrc", "pce", "bce", "pcc", "pck", "bc", " brc", " bc", " bck", "bbc", "abcc", "bbcc", " bce", "abck", "abce", "pc", "frc", "abc", "fcc", "fc", "brc", "fck", "bck", "bbck"], "subject": ["prefix", "description", "uri", "message", "reason", "method", "username", "phone", "title", "Subject", "reply", "template", "comment", "header", "filename", "sub", "object", "host", "response", "mail", "state", "author", "format", "content", "ject", "head", "request"], "body": ["text", "description", "url", "message", "resource", "money", "plain", "html", "length", "style", "view", "connection", "summary", "reason", "lock", "foot", "empty", "data", "shell", "part", "how", "zip", "password", "template", "code", "pass", "comment", "source", "bound", "header", "media", "tree", "pod", "base", "inner", "object", "string", "name", "left", "function", "response", "normal", "wrapper", "content", "line", "secret", "Body"], "attachments": ["embedings", "Attachments", "attachings", "embedents", "attachents", "embedment", "messments", "Attachents", "messings", "Attachings", "Attachment", "embedments", "messents", "messment"], "isHtml": ["isWhtml", "isWhhtml", "isPhail", "isChail", "isHive", "isWhive", "isHattp", "isCail", "isHttp", " isWhive", " isChhtml", "isChtml", "isHaail", "isHahtml", "isHatml", "isChhtml", " isWhhtml", " isHive", "isCive", "isPhttp", "isPhtml", "isHail", " isChtml", " isHhtml", "isPhhtml", " isChail", " isWhtml", "isChive", "isHhtml", "isChttp", " isWhail", " isChttp", "isWhail", " isHttp", " isHail", "isCtml"], "charset": ["chearspace", "chARSeting", "chanset", "chasets", "chasET", "Charseting", "chARSet", "cheansetter", "chansET", "Charsetting", "cheansetting", "chARSetting", "chasetting", "charsets", "chansetter", "chashesET", "chacksete", "chaseset", "chacksetting", "cheanspace", "chaspace", "chasesetting", "charspace", "chaseseting", "chanspace", "chansete", "chansetting", "CharsET", "charsetting", "chearsete", "cheanset", "cheansET", "Charset", "chearsetting", "chacksET", "charsete", "chearsET", "chasetter", "chasesET", "charsetter", "chARSET", "cheansete", "chaseting", "chashesetter", "chARSets", "chashespace", "chaset", "chasheset", "chearset", "chARSete", "charsET", "charseting", "chearsetter", "Charsets", "chackset"], "headers": [" recipients", "users", "options", " messages", "status", "groups", "comments", "classes", "lines", "settings", " emails", "metadata", "properties", "header", "files", "names", "mails", "errors", " cookies", "ers", "params", "types", "writers", "authors", "content", "strings"], "priority": [" severity", "prefix", "length", " recipients", "quote", "reason", "phone", "title", "status", "mode", "comments", "reply", "template", "date", "code", "comment", "theme", "class", "queue", "language", "security", "state", "level", "author", "lang", " title", "secret"], "email": ["enter", "business", "text", "url", "ssl", "default", "message", "e", "server", "install", "html", "example", "core", "view", "letter", "en", "lex", "event", "info", "data", "username", "international", "engine", "online", "external", "output", "model", "document", "oe", "result", "fax", "zip", "password", "template", "test", "el", "element", "xml", "create", "article", "print", "contact", "base", "object", "address", "account", "ilo", "liner", "name", "Email", "service", "entity", "em", "generic", "pm", "auto", "response", "mail", "office", "note", "update", "line", "export", "ext", "gmail"], "user": ["User", "mobile", "people", "role", "e", "USER", "resource", "connection", "users", "info", "data", "username", "profile", "member", "model", "creator", "me", "type", "plugin", "uid", "consumer", "client", "er", "ip", "object", "id", "token", "account", "string", "character", "name", "unknown", "author", "use", "friend", "person"], "identity": ["authentication", "ethnicifier", "ethnicentity", "authentity", "Identity", "identITY", "ethnicity", "authorITY", "idonymous", "authentization", "authentITY", "personITY", "electricITY", "authorication", "IDENTITY", "authorifier", "idententity", "personity", "installonymous", "entityity", "identization", "IDENTities", "electricity", "IDENTentity", "Identities", "entityifier", "installITY", "authentifier", "idITY", "publicity", "identication", "IdentITY", "publicITY", "authentonymous", "installity", "authoronymous", "Idententity", "IDENTity", "entityonymous", "authority", "personentity", "identonymous", "idization", "electricentity", "idifier", "entityization", "publiciciary", "electriconymous", "identifier", "ethnicITY", "installentity", "ethnicication", "authorities", "identiciary", "identities", "authoriciary", "idication", "personifier", "ethniciciary", "publicentity", "authorentity", "idity"], "_returnPath": ["_returnPart", "_replyNode", " _returnUrl", "_replyPath", " _returnName", "_addpath", "_successText", "_resultPath", "_resultName", "_responsePath", "_returnMid", " _backTo", "_backHalf", "_correctPath", " _backPath", "_returnHalf", "_returnUrl", "_addType", "_backTo", "_displayNode", "_displayPath", "_replyPart", "_returnName", "_returnId", "_resultTo", "_backpath", " _backName", "_backType", "_displayPart", "_correctId", "_returnDirectory", "_inputUrl", "_resultHalf", "_relationDirectory", " _returnPart", "_successId", "_backName", "_backPath", "_relationText", "_relationId", "_relationPath", "_returnNode", "_responseType", "_returnpath", "_correctDirectory", "_displayUrl", "_backUrl", " _returnTo", "_inputPath", "_correctText", " _backHalf", " _backUrl", "_successPath", "_backPart", "_displayMid", "_responsepath", "_returnText", "_replyUrl", "_returnType", "_addPath", "_returnTo", " _returnHalf", "_inputNode", "_inputMid", "_successDirectory", " _backPart", "_replyMid"], "_from": ["placeowner", "placeto", "_source", "existingfrom", "workfrom", "blockfrom", "existingto", "blockto", " _source", " _owner", "existingfor", " _who", "workto", "existingowner", " _error", "_for", "_error", "worksource", "placefrom", "_with", "_owner", "_From", " _for", "blockFrom", "workwho", " _From", "_who", "blockerror", "placefor", " _with"], "_replyTo": ["_replyPoint", "_returnUrl", "_reasonTo", " _replyFrom", "_respondTo", "_respondAddress", " _returnUrl", "_respondUrl", "_commentTo", "_replyOf", "_returnAddress", " _returnFrom", "_closeTO", " _replyUrl", "_respondPoint", "_respondFrom", "_reasonUrl", "_returnPoint", "_commentOf", "_addTo", "_returnOf", "_replyAddress", "_addFrom", "_replyUrl", " _returnTO", "_returnTo", "_reasonFrom", "_commentTO", "_addPoint", "_addAddress", "_returnTO", "_closeFrom", "_commentFrom", " _replyTO", "_replyFrom", "_reasonTO", "_respondTO", "_closeTo", "_replyTO", "_closeOf", " _returnTo", "_returnFrom"], "_to": ["Jabout", "_about", " _about", "Jtarget", "Jfrom", "Jto", " _target", "_target"], "_cc": ["_cd", "_ce", " _ce", " _cd", "_cf", " _cf"], "_bcc": [" _bc", "_rbcc", "_abce", "_sbcs", "_bc", "_rbcs", "_rbc", "_bce", "_abcs", " _abc", " _bce", "_abcc", "_abc", "_rbce", "_bcs", "_sbc", " _abce", "_sbce", " _abcc", "_sbcc", " _bcs", " _abcs"]}}
{"id1": "4599372", "id2": "11673907", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readFixString": ["readFixedContent", "readAdjustString", "readFixArray", "readFixedArray", "readFixContent", "createFixedContent", "readfixstring", "createFixContent", "readFixedString", "readFixedstring", "readAdjustArray", "createFixArray", "readAdjuststring", "readFixstring", "createFixstring", "createFixedstring", "readAdjustContent", "readfixArray", "createFixedArray", "createFixedString", "readfixContent", "createFixString", "readfixString"], "len": ["fn", "ln", "lp", "lf", "e", "ll", "le", "length", "count", "n", "body", "en", "loc", "enc", "data", "part", "limit", "pos", "f", "str", "split", "lin", "Len", "val", "code", "el", "i", "size", "li", "l", "lit", "base", "string", "file", "list", "sl", "lc", "lt", "line"], "sw": ["bb", "writer", "wr", "iw", "fl", "sf", "wt", "null", "ss", "aw", "sv", "io", "serv", "wra", "sb", "es", "zip", "so", " SW", "sn", "ow", "ew", "ws", "rw", "wx", "nw", "SW", "stream", "wp", "WS", "Sw", "fw", "sc", "lv", "wa", "sa", "ww", "w", "sl", "sp", "sr", "wb", "sh", "tw", "wh", "hw"]}}
{"id1": "10361370", "id2": "20717531", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "label": 1, "substitutes": {"hash": ["crypt", "ash", "html", "build", "sha", "version", "check", "hex", "sum", "index", "password", "shadow", "key", "fill", "h", "comment", "header", "dump", "sign", "ashing", "cache", "match", "Hash", "render", "update", "dh", "block"], "saltBefore": ["saltFrom", "singaltAfter", "saultFrom", "singALTBefore", "sALTStart", "singALTAfter", "isaltFrom", "sultFrom", "sALTAbove", "saltAbove", "isaltBefore", "saultStart", "isaltHead", "sultHead", "sALTBefore", "saltStart", "sintStart", "isaltStart", "seedBefore", "isaultHead", "saultBefore", "singaltBefore", "isaultStart", "seedStart", "isaultBefore", "seedAfter", "singaltAbove", "singaltStart", "sultStart", "sertStart", "sintBefore", "sintFrom", "seedAbove", "sALTAfter", "sertAbove", "sertBefore", "isaultFrom", "sertAfter", "singALTAbove", "saltHead", "singALTStart", "saultHead", "sultBefore", "sintHead"], "content": ["text", "url", "message", "image", "resource", "length", "parent", "script", "body", "method", "data", "music", "version", "raw", "sequence", "output", "model", "document", "creator", "input", "str", "password", "Content", "code", "xml", "temp", "source", "comment", "section", "header", "filename", "media", "stream", "expression", "size", "object", "address", "cache", "string", "character", "entity", "pattern", "json", "cont", "word", "value", "format", "buffer"], "saltAfter": [" sALTExtra", "saltafter", "saltedEnd", "singaltAfter", "sALTExtra", "saltedBefore", "singALTBefore", "sALTafter", "sintAfter", " saltExtra", "singALTAfter", "sintExtra", "saultExtra", " sALTAfter", "singALTAround", " sALTafter", "saltEnd", "sALTBefore", "sALTAround", "saltedAfter", "saultafter", "saltExtra", "saultBefore", "singaltBefore", "saltedAround", "saultAfter", "singALTEnd", "sintafter", "sintBefore", " sALTBefore", "singaltEnd", "sALTAfter", "sertBefore", "singaltAround", " saltafter", "sALTEnd", "sertEnd", "sertAfter", "sertAround", "saltAround"], "repeatedHashingCount": ["repeatedHashedcount", "repeatedChashesType", "repeatedShashCode", "repeatedChashingType", "repeatedHashCode", "repeatedHashingType", "repeatedHashesNumber", "repeatedHashCount", "repeatedHashesCount", "repeatedShashingCounter", "repeatedHashLength", "repeatedHashesCounter", "repeatedHashCounter", "repeatedHashingNumber", "repeatedHashingCode", "repeatedHashingCounter", "repeatedHashingLength", "repeatedHumpingCount", "repeatedChashingNumber", "repeatedShashCount", "repeatedHashesType", "repeatedHashedCount", "repeatedHashingcount", "repeatedHashedNumber", "repeatedShashCounter", "repeatedHatingCode", "repeatedHashedType", "repeatedChashingCount", "repeatedHashesCode", "repeatedChashingcount", "repeatedHashescount", "repeatedHumpingType", "repeatedShashingCode", "repeatedHatingCount", "repeatedHatingLength", "repeatedChashescount", "repeatedHatingCounter", "repeatedShashingLength", "repeatedChashesNumber", "repeatedHashesLength", "repeatedChashesCount", "repeatedHumpingcount", "repeatedHumpingNumber", "repeatedShashLength", "repeatedShashingCount"], "digest": ["loger", "Diger", " Digest", "Digusher", "hexest", "digString", "valider", " digEST", "DigEST", "Digger", " diggest", "Diggest", "logester", "validest", "ngested", "mixested", " Digator", "nger", "signger", "Digester", "generests", "mixester", "Digest", " digested", "digEST", "hashests", "hashested", "loggest", " digator", "mixest", "mixusher", "Digator", "logest", "finester", "hashString", "generester", "ngest", "signest", "digger", "generest", "hexests", " diger", " digusher", "finested", "DigString", "generested", " digests", " Digester", " digester", " digger", "signested", " Diger", "Digested", "digester", "digator", "signEST", "signester", "hexString", "digests", "Digests", "ngester", "finest", "finests", "diger", "digested", "digusher", "hashest", "hexested", "diggest", "validester", "validested"], "digestLength": ["digestsLen", " digestlength", "digestingLen", "digestingLength", "DigestLen", " digestLen", " digesterLength", "DigesterLen", "digestedLength", "digestsLength", "digesterLen", "digestType", " digestType", " digesterlength", "digestedlength", "DigesterLength", "digestlength", "DigestLength", "Digestlength", "digestinglength", "digesterlength", "digestedLen", "digestsType", "digestingType", "Digesterlength", "digestslength", " digesterLen", "digesterType", " digesterType", "digesterLength", "digestLen"], "i": ["k", "u", "uri", "e", "j", "anti", "length", "count", "b", "n", "fi", "io", "info", "si", "f", "o", "index", "d", "ci", "h", "oi", "s", "iu", "multi", "api", "ami", "li", "di", "l", "pi", "xi", "slice", "id", "ti", "v", "gi", "c", "start", "t", "ri", "I", "ai", "phi", "zi", "ini", "ii", "ui", "x", "bi", "mu", "lc", "qi", "chi", "p", "wei"]}}
{"id1": "14783950", "id2": "17475530", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressUsingJar", "compressUsingZip", "compressInZip", "compresswithZip", "compresswithSax", "compressedWithJar", "compressInSax", "compressedWithZip", "compressWithJar", "compressUsingSax", "compresswithJar", "compressInJar", "compressedWithSax", "compressedUsingJar", "compressedUsingZip", "compressedUsingSax", "compressWithSax"], "fileList": [" fileChain", "wordString", "FileStream", "zipSet", "FileString", "fileStream", "modelCollection", "wordName", "inputEx", "modelEx", "fileCollection", "FileSet", "fileString", "modelList", "wordStream", "modelStream", "FileList", "inputCollection", "fileEx", "FileChain", "filelist", " fileSet", "zipList", "inputList", "inputStream", "wordList", "ziplist", "fileChain", "stringName", " fileEx", "stringlist", " fileStream", "Filelist", " fileCollection", " fileString", "FileName", "stringList", "stringChain", "zipName", "fileSet", " filelist"], "zipFileName": ["folderGlobalPath", "archiveDirDir", "zipFullname", "zipDirname", "zipFileDir", "archiveDirPath", "zipGlobalNames", "zipFullPath", "folderGlobalname", "zipFilename", "archiveFileName", "archiveFilePath", "zipDirDir", "zipPackagePath", "zipFullName", "zipFileNames", "archiveDirName", "folderFileNames", "zipGlobalPath", "folderFileName", "zipFullDir", "zipPackageName", "zipPackageDir", "folderGlobalName", "zipDirNames", "zipDirName", "archiveFileDir", "zipFullNames", "zipGlobalName", "zipDirPath", "zipFilePath", "folderFilename", "folderFilePath", "zipGlobalname", "folderGlobalNames"], "fos": ["Fosh", "infoS", "Fos", "flos", "faos", "infos", "fosh", "infaos", "afoS", "foS", "flis", "Faos", "FoS", " fosh", "afaos", "infis", "flosh", "afis", "afos", "Fis"], "zos": ["css", "zz", "ros", "dos", "closure", "z", "fits", "kos", "tz", "fi", "ZA", "os", "jas", "jobs", "ozo", "osi", "uz", "iframe", "nz", "cos", "loop", "zip", "es", "bis", "bos", "lins", "bag", "chini", "zes", "oses", "zzy", "seconds", "abi", "zik", "lol", "bes", "zar", "zag", "zo", "zers", "zen", "LOS", "outs", "zl", "rez", "ses", "onz", "zb", "ZI", "packs", "gz", "zx", "zer", "zy", "webkit", "obb", "zi", "phi", "zon", "zan", "spin", "budget", "inos"], "iter": ["enter", "inse", "fr", "e", "itter", "ser", "loc", "outer", "oper", "ner", "inc", "ie", "it", "f", "set", "index", "upper", "finder", "sort", "coll", "end", "test", "ener", "el", "gener", "i", "is", "parse", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "slice", "ir", "file", "err", "fer", "list", "Iter", "inter", "ator", "izer", "next", "ite", "order", "cher", "liter", "iner", "chain", "iterator", "iz", "http"], "fileName": ["filenamename", "pageString", "FileString", " filePart", "FileUrl", "fName", "filePath", " filePath", "localname", "fileOpen", "filenameName", "currentname", "fileData", " fileLine", " fileType", " fileData", "FileFull", "fullOpen", "fileString", " fileFull", "fileType", "FilePart", "simplePath", "filenameInfo", "fileUrl", "currentData", "pageType", "currentName", " fileUrl", "FileLine", "pagename", "localPart", "fileInfo", "filename", "localName", "currentUrl", "simpleOpen", " fileInfo", "Filename", "FileInfo", "FilePath", " filename", "fPart", "fileFull", " fileString", "FileName", "fullPath", "localPath", "filePart", "FileData", "fullName", "fLine", "pageName", "FileType", " fileOpen", "fileLine", "simpleName", "filenameFull", "fname"], "ind": ["bind", "fr", "z", "vert", "nd", "j", "length", "count", "loc", "mid", "ded", "inc", "pos", "in", "cond", "pt", "index", "inn", "d", "ci", "val", "end", "eff", "i", "pull", "dir", "rib", "len", "ad", "id", "div", "ord", "IND", "start", "ld", "ix", "mind", "ii", "x", "Ind", "wind", "pend"], "shortName": ["Shortname", "ShortPath", " shortString", "longName", "smallname", "shortPart", "ShortString", "shortname", "ShortPart", "smallPart", "shortPath", "shortString", "ShortName", "longPart", "shortLine", "smallPath", "fullname", " shortPath", "longLine", "fullString", " shortname", "smallName", "longPath", "longname", "fullPath", "fullName", "fullLine", " shortLine"], "fis": [" fiss", "pisa", "fisa", "Fos", "fris", "cfis", "Fiss", "gisa", " fris", "cfs", " fisa", "gis", "fs", "pis", "fios", "Fs", "gios", "pris", "fiss", "pios", "cfiss", "gris", "afiss", "cfris", "cfos", " fs", "afris", "afis", " fios", "afos", "Fis"], "buf": ["fd", "cv", "uf", "bu", "uc", "b", "loc", "rc", "fb", "data", "bh", "bp", "lb", "feat", "bc", "pb", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cur", "bf", "bd", "grab", "tmp", "buff", "ff", "queue", "ba", "br", "v", "lim", "bin", "la", "vec", "wb", "bl", "buffer", "seq", "box", "bb"], "bytesRead": [" bytesLength", "flowsWrite", "tesRead", "flowsRead", "bitsSkip", " bytesWrite", "bitsLength", "bitsRead", " bytesNeed", " bytesLoad", "bytesNeed", "bitsWrite", "tesWrite", "tesSkip", "bitsUse", "secondsRead", "wordsWrite", "bytesUse", "wordsUse", "bitsLoad", "secondsWrite", "bytesSkip", "tesLoad", "wordsRead", "bytesLoad", "bytesLength", "secondsLength", "bytesWrite", "flowsNeed", "secondsNeed", "flowsLength", " bytesUse", "wordsLength", " bytesSkip"]}}
{"id1": "397240", "id2": "17207832", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readandrewrites", "readandrewrite", "readAndRebrites", "readandRewrite", "readAndRebrite", "readAndrewrite", "readandRewwrite", "readAndRewrap", "readAndSwrites", "readAndSwwrite", "readAndrewwrite", "readandrewwrite", "readAndRebwrite", "readAndRewrites", "readAndSwrite", "readAndrewrap", "readandRewrap", "readAndrewrites", "readAndRebrap", "readandrewrap", "readAndSwrap", "readandRewrites", "readAndRewwrite"], "inFile": ["InFile", "infile", "oldFile", " inFiles", "inFilename", "oldFiles", "inputFile", " inFilename", " inSourceFile", "outFiles", "loginFiles", "loginfile", "loginFilename", "outfile", "Infile", "inputFilename", "outFilename", "oldfile", "outSourceFile", "InFiles", "oldFilename", "InSourceFile", "inputfile", "loginFile", "inputFiles", "inFiles", "inSourceFile", " infile"], "outFile": ["outFILE", " outfile", "processPlace", " outDir", "thisFilename", "exFILE", "outputPlace", "offFilename", "newfile", "processFilename", "outDir", "thisFILE", "exFilename", "exFile", "newStream", "thisFile", "outputFile", "offFILE", "outStream", "outfile", "outputFILE", " outStream", "outFilename", "offPlace", "thisfile", "newFile", "OutDir", "offFile", "Outfile", "newDir", "processFile", "OutStream", "outputFilename", "OutFile", "processFILE", "outPlace", "outputfile", "exfile"], "iis": ["ciiss", "IIS", "Iis", "iniris", " iais", " iiss", "iniiss", "iais", "ciais", "ciris", "ciIS", "Iiss", " iIS", "iiIs", " iIs", "iiiss", "iiis", "iris", "iiris", "iiIS", " iris", "iIS", "iniIS", "iniIs", "ciIs", "ciis", "iiss", "iniis", "iIs", "Iais"], "dcmParser": ["DcmInstallation", " dcmReader", "dpmPlugin", "dcmPolicy", "dkmHelper", "dbmParser", "dmcarser", "dmissionParser", " dcmparser", "dmoduleParser", "dhemParser", "dcmPlugin", " dcmLoader", "fpmParser", " dcmPolicy", " dcmHelper", "dpmInstallation", " dpmJar", "dcrPlugin", " dcmLanguage", "dCMparser", "dcmLoader", "dcmReader", "dcrParser", "dmissionReader", "dmcParser", "dkmParser", " dcrParser", "dcmparser", "dhemInstallation", "dkmPlugin", " dpmLanguage", "dmmparser", "dmParser", "dpmHandler", "dmissionPlugin", "dcmPar", "dCMReader", "dmoduleJar", "dcrLoader", "dcrJar", "dmmParser", "dbmPolicy", "dmodulePlugin", "dmReader", "dhemJar", " dcrReader", " dpmPar", " dpmPlugin", "fcmHandler", " dcrLoader", "fpmHandler", "dpmarser", "dmLoader", "dpmPolicy", "dbmHelper", "dcrarser", "dpmparser", "dbmPlugin", "dpmLanguage", "fcmReader", "fpmReader", "dcmarser", " dpmparser", " dcmPar", "dmPlugin", " dpmHelper", "dcmHelper", " dpmPolicy", "dmissionLanguage", "dcrPar", "dpmReader", "dCMHandler", "fpmparser", " dpmReader", " dpmarser", "DcmParser", "dpmParser", "dpmPar", "dkmPolicy", "dcmInstallation", "fcmParser", "DcmJar", " dcmJar", "dCMLoader", "fcmparser", "dmmPlugin", "dpmLoader", "dhemReader", "dmoduleReader", "dpmJar", "dCMParser", "dCMPlugin", "DcmReader", "dmcPar", "dmmLoader", "dpmHelper", "dmcJar", " dcmarser", "dcmHandler", " dpmLoader", " dcrPlugin", " dcmPlugin", "dmoduleparser", "dcrReader", "dcmLanguage", "dcmJar", " dpmParser"], "ds": ["ks", "ls", "Db", "ros", "js", "des", "ads", "DS", "ins", "details", "ss", "dr", "cdn", "df", "ps", "rs", "points", "os", "data", "ns", "parts", "sys", "session", "uds", "sync", "dd", "tx", "gd", "vs", "Ds", "amps", "d", "dat", "asi", "ys", "s", "conn", "ws", "is", "drivers", "tes", "src", "pd", "vals", "di", "qs", "db", "Os", "ras", "da", "eps", "ils", "iss", "dds", "icks", "dc", "xs", "ld", "ts", "ays", "nas", "gs", "cs", "utils", "services", "bs", "ants", "dt"], "pdReader": ["ddLoader", "pdLoader", "dsLoader", "pcLoader", "hdStream", "hdLoader", "pcReader", "hdRead", "ddReader", "hdReader", "dsWriter", "hdWriter", "dsreader", "pbRunner", "xdReader", "hdreader", "pdreader", "dsReader", "dsRead", "pdRunner", "pcRead", "ddRunner", "hdRunner", "pbReader", "pdStream", "pcWriter", "pbLoader", "xdRead", "pdRead", "xdWriter", "ddStream", "pbStream", "xdreader"], "out": ["ex", "writer", "default", "flow", "image", "parent", "null", "term", "data", "part", "in", "her", "exp", "o", "password", "conn", "pass", "temp", "cli", "outs", "over", "cache", "exec", "file", "err", "list", "net", "lib", "img", "page", "connection", "dot", "inc", "group", "model", "result", "key", "code", "builder", "point", "object", "w", "down", "layer", "word", "oder", "to", "gen", "url", "io", "outer", "store", "later", "sys", "sync", "Out", "dev", "s", "co", "login", "db", "user", "obj", "up", "device", "order", "diff", "again", "manager", "director", "at", "array", "ssl", "write", "copy", "lock", "child", "session", "external", "output", " in", "with", "client", "inner", "base", "name", "full", "OUT", "auto", "as", "line", "doc", "ext"], "dcmEncParam": ["dcmDecParam", "dcmEstPar", "dcmDecPart", "dcmEnType", "dcmElParameter", "dcmSecParam", "dcmEstParam", "dcmDecPar", "dcmElPar", "dcmDecParameter", "dcmArchParam", "dcmSecPart", "dcmEnParameter", "dcmEncArg", "dcmArchParameter", "dcmEncType", "dcmEnArg", "dcmEstType", "dcmSecType", "dcmEnPar", "dcmEncParameter", "dcmSecPar", "dcmArchArg", "dcmElParam", "dcmEstParameter", "dcmEncPart", "dcmElType", "dcmDecType", "dcmDecArg", "dcmEncPar", "dcmEnPart", "dcmEnParam"], "pdWriter": ["htWriter", "ddReader", "dsOutput", "hdWrite", "hdReader", "hdOutput", "htWriting", "pdWrite", "dsWriter", "ddWrite", "hdWriter", "dsReader", "dsWrite", "PDWriter", "dpWriter", "dpWriting", "PDReader", "PDWrite", "dpReader", "pdWriting", "ddWriter", "pdOutput", "ddOutput", "dpWrite", "htWrite", "htReader", "PDWriting"]}}
{"id1": "15580610", "id2": "18433984", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainclassify", "trainTestifier", " trainclassLoader", "trainClassLoader", "trainclassifier", "trainclassification", "trainTestification", "trainClassify", " trainClassification", "trainTestify", " trainclassifier", "trainModelification", " trainClassify", " trainClassLoader", " trainclassification", "trainTestLoader", "trainClassification", "trainModelLoader", "trainModelifier", "trainModelify", "trainclassLoader", "trainclassify"], "dir": ["fd", "doc", "direction", "url", "uri", "report", "module", "build", "loc", "DIR", "data", "project", "md", "folder", "output", "model", "group", " directory", "du", "d", "out", "wd", "home", "class", "config", "directory", "filename", "di", "target", "env", "db", "files", "base", "object", "div", "file", "window", "dist", "name", "root", "domain", "path", "cd", "Dir", "lib", "database"], "command": ["attribute", "component", "array", "power", "menu", "module", "message", "one", "image", "script", "volume", "cmd", "system", "reason", "connection", "event", "info", "project", "child", "this", "shell", "program", "usage", "sequence", "model", "document", "input", "sudo", "archive", "password", "error", "and", "move", "comment", "action", "config", "directory", "media", "cli", "delete", "slave", "which", "Command", "control", "category", "three", "string", "exec", "history", "file", "language", "machine", "name", "help", "service", "root", "pattern", "domain", "function", "path", "query", "operation", "word", "clear", "argument", "force", "request", "database"], "length": ["distance", "span", "padding", "power", "count", "style", "body", "loc", "letter", "form", "depth", "before", "last", "duration", "ph", "part", "sequence", "limit", "shape", "range", "how", "now", "creator", "zip", "sum", "end", "type", "ength", "time", "th", "class", "max", "section", "size", "width", "l", "capacity", "Length", "number", "len", "inner", "slice", "position", "id", "match", "character", "dim", "angle", "left", "full", "strength", "square", "both", "prime", "or", "word", "value", "level", "head", "join"], "process": ["component", "console", "task", "processing", "call", "parent", "script", "master", "system", "cmd", "connection", "cess", "method", "this", "project", "session", "sync", "child", "program", "display", "output", "group", "application", "status", "document", "result", "run", "pid", "out", "python", "handle", "class", "parse", "thread", "worker", "user", "exec", "file", "share", "machine", "app", "service", "host", "Process", "proc", "post", "function", "path", "plus", "use", "p", "processor"]}}
{"id1": "19912848", "id2": "4716110", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "19251426", "id2": "14691829", "code1": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"recurseFiles": ["recerveChildren", "reiveFile", "recurseImages", "reiveFiles", "recursiveFile", "reciveImages", "recorderfiles", "recursivefiles", "recurseItems", "reciveFiles", "recurseFile", " recurseChildren", "recieveChildren", "recerveFile", "recieveItems", "recursiveFiles", "recursiveItems", "recieveFile", " recurseItems", " recursiveFile", "reurseFiles", "reciveFile", "reiveImages", "reivefiles", " recursiveFiles", " recursiveChildren", "recorderFile", " recursiveItems", "recursiveImages", "recerveFiles", "recerveItems", "reursefiles", "recorderFiles", "reurseFile", " recurseFile", "recorderImages", "recursefiles", "recurseChildren", "recieveFiles", "recivefiles", "recursiveChildren", "reurseImages"], "root": ["prefix", "Root", "array", "writer", "url", "default", "uri", "resource", "module", "server", "ro", "parent", "b", "loc", "remote", "back", "project", "this", "folder", "output", "f", "result", "rule", "zip", "oot", "archive", "out", "home", "ver", "xml", "source", "ree", "dir", "reader", "directory", "rew", "tree", "base", "user", "node", "r", "object", "string", "bin", "loader", "name", "cover", "path", "or", "roots", "box"], "file": ["page", "pe", "log", "FILE", "url", "e", "image", "ile", "resource", "parent", "module", "b", "style", "server", "force", "letter", "leaf", "data", "single", "info", "child", "project", "folder", "model", "f", "entry", "document", "zip", "uri", "type", "code", "xml", "time", "source", "class", "comment", "dir", "future", "directory", "work", "use", "tree", "base", "db", "table", "queue", "object", "local", "cache", "number", "handler", "name", "binary", "full", "File", "get", "path", "auto", "line", "or", "content", "function", "collection", "http", "fp"], "zaos": ["ziis", "gaot", "wao", "yaoS", "gaOS", "qaoss", "zaas", "gao", "zeos", "zoose", "zoS", "naose", "zis", "waos", "zos", "zios", "waoS", "ziot", "qaoS", "zeose", "qais", "wais", "zes", "qaos", "zaoss", "zeis", "naoss", "zioS", "gaoS", "zao", "waOS", "qaot", "zioss", "zo", "zooss", "naas", "zais", "ziOS", "naos", "zaose", "zaOS", "zaot", "zaoS", "zeas", "gaos", "zeo", "zaes", "yao", "zeoss", "zoas", "waoss", "zoos", "qaOS", "yaos", "gaes", "yaes", "zeoS"], "absolute": ["attribute", "mobile", "uri", "append", "apply", "complete", "Abs", "offset", "able", "ical", "simple", "empty", "relative", "international", "physical", "external", "required", "alias", "enable", "document", "compatible", "valid", "positive", "encrypted", "multiple", "inline", "automatic", "total", "al", "use", "atomic", "base", "reverse", "alpha", "aggressive", "olute", "optional", "full", "fixed", "auto", "supported", "always", "based", "abs", "active", "http", "ative", "exclusive", "negative"], "files": ["ls", "pes", "log", "keys", "rows", "books", "links", "users", "sites", "f", "apps", "es", "groups", "plugins", "features", "classes", "split", "projects", "lines", "ips", "fs", "s", "balls", "docs", "objects", "results", "alls", "images", "qs", "pages", "names", "models", "cells", "iles", "blocks", "Files", "ples", "events", "items"], "file2": ["fileSub", "filestwo", "filenametwo", "file1", "letter2", "filetwo", "files1", "object1", " file1", "files02", "filename2", " fileSub", "filename1", "letter1", "object2", " file02", "files2", "letterSub", "filename02", "objectSub", " filetwo", "file02"], "filename": ["ame", "SourceFile", "ppa", "description", "subject", "url", "uri", "txt", "message", "module", "append", "length", "connection", "loc", "letter", "summary", "sheet", "il", "ema", "username", "shell", "title", "folder", "phrase", "f", "zip", "archive", "family", "password", "nil", "kn", "download", "metadata", "size", "directory", "l", "fil", "slice", "which", "Filename", "email", "language", "string", "token", "kl", "name", "binary", "sl", "wb", "location", "path", "whatever", "word", "json", "utf", "database", "fp", "ename"], "zae": ["zade", "fae", " zanne", "fade", "zace", "Zade", "zoda", "zaobe", "ezace", "zeae", "zaoda", "zeade", " zace", "ezcoe", "zoe", "zaae", "zobe", "foe", "zipobe", "fanne", "zape", "zeace", "ezade", " zobe", "zaape", "zipape", "zipoda", " zade", " zcoe", "ezae", "Zae", "zecoe", " zoe", "Zoe", "zanne", "Zanne", " zape", " zoda", "zcoe", "zipae"], "fis": ["lris", "fais", "fisa", "lis", "cais", "zis", "sfisc", "fris", "lisa", " fris", " fisa", "fisc", "fwas", "sfwas", "cisa", "sfais", "zais", " fisc", " fais", "sfis", "cris", "zwas", "zisc", "lais", "cis", " fwas"]}}
{"id1": "18782385", "id2": "732800", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"saveFile": ["uploadDirectory", "uploadImage", " saveFiles", "uploadFiles", "writeImage", " saveImage", "saveDirectory", "writeDirectory", " saveDirectory", "writeFile", "saveFiles", "uploadFile", "saveImage", "writeFiles"], "window": [" dialog", "widget", "console", "flow", "menu", "image", "parent", "scope", "volume", " office", "view", " host", "band", "win", "gallery", " Window", "directory", "target", "feature", "scroll", "wa", "file", "ui", "img", "hw", "browser", "visual", " video", "server", " world", "style", "remote", "event", "Window", " widget", "input", "angular", "gui", "command", "video", "layout", "show", "w", "microsoft", "layer", "dom", "game", "space", "frame", "wall", " canvas", " container", "time", "youtube", "screen", "device", "buffer", "manager", "stage", "button", " GUI", " wizard", "system", "project", "session", "motion", "document", "draw", "audio", "GUI", "home", "wx", "driver", "client", "media", "machine", "host", " wid", "office", "box", "doc"], "stream": [" webcam", " app", " this", " video", " upload", " form", "Stream", " buffer", "os", "io", " console", " w", " resource", "output", "f", "document", " webpage", "OU", " prog", "out", " temp", "file", " OUT", " streams", "w", " bout"], "outputDoc": ["externalDiv", "externalDoc", "OutputDocument", " outputDocument", "targetDocument", "targetDiv", "externalDocument", "inputFile", "externalFile", "updateDiv", "targetDoc", "updateDocument", "outputDiv", "OutputDiv", "inputDocument", "inputDoc", "outputFile", "OutputDoc", " outputFile", "targetFile", "inputDir", "updateDir", "outputDocument", "outputDir", "OutputDir", " outputDiv", "OutputFile", " outputDir", "updateDoc"], "dtd": ["Dlt", " ddd", "std", "fdTD", " ddl", "fddl", " dlt", " ddt", "ddd", "fdtd", "DTD", "slt", "fddd", " dTD", "Dtd", "ddt", "Ddd", "ddl", "sTD", "sdt", "dlt", "dTD", "Ddl", "Ddt"], "uiElement": ["UIModule", "cliSource", "uniMember", "UIDoc", "uriE", "guiMember", "cliElement", "utilElement", "uriEntry", "uiDoc", "guiE", "guiDoc", "uElement", "volumeObject", "uriEntity", "utilEl", "uiMember", "uriEmail", "uriObject", "clielement", "uEl", "guiModule", "suElement", "uriEngine", "uiEntry", "uiEle", " UIEl", "apiEntity", "uiModule", "luElement", "suEmail", "uniEl", "uiEngine", "ouElement", " UIEditor", "ioEl", "uielement", "UIDocument", "uiObject", "ioElement", "ioDoc", "UIEl", "uiDocument", "UIEle", "utilDoc", "guiEntity", "ouEditor", "uiEntity", "unielement", "UIEntry", "luEngine", "uiEmail", "ouEl", "urielement", "apiEl", "apiE", "guiElement", "uniElement", "uelement", "guiEl", "uiSource", "guielement", "uiEl", "volumeDocument", "uiE", "uiEditor", " UIEle", "luEmail", "suEntity", "luEntity", "uSource", "uniE", "uriEl", "UIObject", "uriDocument", "UIE", "cliEntry", "apiElement", "cliEl", " UIElement", "UIEditor", "volumeEntry", "ioModule", "UISource", "UIElement", "UIelement", "UIMember", "uriElement", "ouEle", "suEngine", "uniEntity"], "currentLFClassName": ["currentLFFunctionName", "currentLFFunctionAlias", "currentLDFFilename", "currentLFFileDesc", "currentLFclassDesc", "currentLDFClassname", "currentLDFFileString", "currentLFCLASSPath", "currentLELFCLASSPath", "currentLDFClassString", "currentLFFileName", "currentLFclassname", "currentLELFCLASSAlias", "currentLELFClassDesc", "currentLFFunctionPath", "currentLFClassAlias", "currentLFclassAlias", "currentLDFFileDesc", "currentLFCLASSName", "currentLDFFileName", "currentLFclassString", "currentLFClassPath", "currentLELFClassPath", "currentLFFilename", "currentLFClassDesc", "currentLELFClassAlias", "currentLFClassString", "currentLELFCLASSDesc", "currentLELFCLASSName", "currentLFCLASSAlias", "currentLFFunctionDesc", "currentLFclassPath", "currentLDFClassDesc", "currentLFClassname", "currentLFclassName", "currentLFFileString", "currentLDFClassName", "currentLELFClassName", "currentLFCLASSDesc"], "systemLFClassName": ["systemLfPackageDesc", "systemLFClassCode", "systemLFPackageString", "systemLFPackageDesc", "systemLfPackagename", "systemLfClassCode", "systemLfPackageName", "systemLFclassDesc", "systemLfClassDesc", "systemLFFullName", "systemLFPackageName", "systemLfClassString", "systemLFFullString", "systemLFclassString", "systemLfClassName", "systemLFClassString", "systemLFPackagename", "systemLfPackageString", "systemLFFullDesc", "systemLFClassDesc", "systemLfClassname", "systemLFClassname", "systemLFPackageCode", "systemLfPackageCode", "systemLFclassName"], "mainWindowElement": ["mainGroupElement", "currentWindowPage", "mainWheelElement", "mainFrameEl", "mainFrameElement", "mainWheelEnvironment", "mainFlowE", "mainWebEngine", "mainFrameMember", "mainWebAddress", "mainWindowPage", "mainFrameFrame", "MainWindowE", "centralFrameEl", " mainWheelEl", "mainFlowEnvironment", "centralFrameelement", "mainGroupObject", "MainWindowFrame", "mainFrameContainer", "mainWindowE", "centralWindowelement", "centralFrameElement", " mainHostElement", " mainWebElement", "mainStreamContainer", "mainWindowelement", "currentFrameElement", "mainHostElement", "centralWindowEl", "mainQueueElement", "mainWebEl", "mainWebE", "mainFlowBuilder", "mainWebBuilder", "mainWindowEnvironment", "mainFlowEngine", " mainWebEngine", " mainWindowEl", " mainWheelEnvironment", "mainWindowEngine", " mainWindowObject", "mainWindowObject", " mainWindowE", " mainHostAddress", " mainHostBuilder", "currentFramePage", "mainMenuContainer", "mainWindowFrame", " mainWindowBuilder", "MainWindowEl", "centralWindowElement", "currentWindowEl", "MainWindowElement", " mainWheelMember", "mainWebEnvironment", "mainTimeelement", " mainWindowEnvironment", "mainFrameEnvironment", "mainWindowEl", "mainMenuElement", "mainWindowsElement", "mainQueueFrame", "mainWindowBuilder", "mainQueueE", " mainWindowMember", " mainWindowEngine", "mainMenuPage", "currentFrameContainer", "mainFlowAddress", "mainFrameE", "mainWindowsEl", "mainWebMember", "MainFrameFrame", "mainTimeElement", "mainStreamPage", "mainStreamEl", "MainFrameE", "mainStreamElement", "MainFrameEl", "currentWindowContainer", "mainScreenEl", "mainHostE", "mainQueueEl", "currentFrameEl", " mainWebEnvironment", " mainWheelElement", "mainWebElement", "mainHostBuilder", "mainTimeEl", "mainScreenelement", "mainMenuEl", "mainFrameelement", " mainWebObject", " mainWindowAddress", "mainFlowObject", " mainHostE", "mainWindowContainer", "mainWindowAddress", "currentWindowElement", "mainWindowsE", "mainWindowsFrame", "mainFramePage", "mainFlowElement", "MainFrameElement", "mainScreenElement", "mainWheelEl", "mainWheelMember", "mainGroupEngine", "mainWebObject", "mainGroupEnvironment", "mainHostAddress", "mainWindowMember"], "volumeElement": ["audioElement", "soundlement", "VolumeEntry", "voiceContainer", "audioEntry", "volumeEngine", " volumeEl", "voiceEl", "voiceLayer", "audiolement", "soundEl", "volumelement", "soundPart", "audioPart", "audioEngine", "volumePart", " volumeEntry", " volumeLayer", "voiceEngine", "audioEl", "VolumeEl", "voiceEntry", " volumeEngine", "volumeEntry", "voiceElement", " volumePart", "soundElement", "VolumeElement", "volumeLayer", " volumeContainer", "volumeContainer", "audioLayer", " volumelement", "volumeEl", "VolumeContainer"], "player": ["players", "caster", "roller", "play", "e", "ater", "aster", "ser", "able", "par", "act", "profile", "part", "watch", "audio", "ader", " Player", "live", "monitor", "apper", "plays", "driver", "Play", "er", "Player", "db", "min", "position", "video", "handler", "file", "mor", "app", "loader", "ayer", "per", "ower", "layer", "transfer", "ler", "active", "game", "playing"]}}
{"id1": "22441244", "id2": "11933797", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"send": ["text", "sent", "message", "write", "append", "build", "set", "reply", "end", "add", "create", "parse", "delete", "export", "address", "exec", "submit", "start", "Send", "get", "transfer", "mail", "execute", "from", "open", "post"], "hsession": ["hsess", "hmessions", "hessions", "HSession", "opensessions", "hmsession", "hsSession", "opensess", "hhessions", "HSSession", "hsort", "hhort", "hesess", "hSession", "hmession", "hhSession", "hesort", "hessession", "hssession", "hmSession", "hsessions", "opensSession", "opensort", "hhession", "hesession", "opensession", "openssession", "HSsession", "hhsession", "HSessions", "hession", "hhess"], "session": ["proxy", "Session", "message", "resource", "server", "parent", "connection", "event", "project", "port", "chat", "application", "document", "site", "class", "ession", "client", "cache", "security", "essions", "host", "sl", "context", "response", "mail", "state", "manager"], "repositoryName": ["reposositoryAddress", "repoositoryEmail", "repositoryPath", "repoositoryPath", "repoitoryAddress", "reposessionName", "repoitoryEmail", "reposicleAddress", "reposicationAddress", "repoositoryFamily", "repositiveNAME", "reposessionNAME", "repositoryNAME", "reposicationFamily", "repositoryAddress", "repoositoryNAME", "repositoryFamily", "repoositoryAddress", "repoitoryName", "repositiveName", "reposicleName", "repositiveEmail", "repositivePath", "reposicleEmail", "reposessionPath", "reposositoryPath", "reposositoryNAME", "reposositoryFamily", "reposicationEmail", "reposicationName", "repoositoryName", "reposositoryEmail", "repoitoryPath", "reposicleFamily", "reposessionEmail", "repoitoryNAME", "reposositoryName", "repoitoryFamily", "repositoryEmail"], "ideIdint": ["IDEIdInt", "ideidn", "IDEIdn", "ideNamenumber", "IDEIdints", "ideInn", "IDEidn", "IDENameInt", "IDEidints", "ideTimeout", "IDEIdint", "ideAuthInt", "ideInint", "ideAuthint", "ideIdInt", "ideIdints", "IDEIdout", "IDENamenumber", "ideIdn", "ideNameInt", "ideNameint", "ideInfonumber", "ideInInt", "ideInfoInt", "IDEIdnumber", "ideIdout", "ideTimeInt", "ideInfoout", "ideIdnumber", "IDENameout", "ideNameout", "IDENameint", "IDEidint", "ideAuthn", "ideInints", "ideidInt", "ideTimeint", "ideAuthints", "ideidints", "ideTimenumber", "IDEidInt", "ideInfoint", "ideidint"], "to": ["prefix", "mobile", "uri", "message", "summary", "options", "phone", "title", "site", "about", "reply", "tel", "template", "settings", "source", "TO", "top", "client", "with", "contact", "sub", "target", "company", "address", "token", "account", "po", "name", "by", "location", "response", "mail", "office", "To", "from"], "cc": ["ct", "cn", "uc", "rc", "tc", "ce", "phone", "ec", "ck", "password", "cl", "nc", "ci", "cb", "code", "cca", "comment", "client", "contact", "cus", "company", "sc", "CC", "ac", "account", "address", "c", "card", "dc", "cf", "lc", "cs", "ca", "cr", "from"], "bcc": ["bbrc", "pce", "bce", "pcc", "pck", "bc", " brc", " bc", " bck", "bbc", "abcc", "bbcc", " bce", "abck", "abce", "pc", "frc", "abc", "fcc", "fc", "brc", "fck", "bck", "bbck"], "subject": ["prefix", "description", "uri", "message", "reason", "method", "username", "phone", "title", "Subject", "reply", "template", "comment", "header", "filename", "sub", "object", "host", "response", "mail", "state", "author", "format", "content", "ject", "head", "request"], "body": ["text", "description", "url", "message", "resource", "money", "plain", "html", "length", "style", "view", "connection", "summary", "reason", "lock", "foot", "empty", "data", "shell", "part", "how", "zip", "password", "template", "code", "pass", "comment", "source", "bound", "header", "media", "tree", "pod", "base", "inner", "object", "string", "name", "left", "function", "response", "normal", "wrapper", "content", "line", "secret", "Body"], "attachments": ["embedings", "Attachments", "attachings", "embedents", "attachents", "embedment", "messments", "Attachents", "messings", "Attachings", "Attachment", "embedments", "messents", "messment"], "isHtml": ["isWhtml", "isWhhtml", "isPhail", "isChail", "isHive", "isWhive", "isHattp", "isCail", "isHttp", " isWhive", " isChhtml", "isChtml", "isHaail", "isHahtml", "isHatml", "isChhtml", " isWhhtml", " isHive", "isCive", "isPhttp", "isPhtml", "isHail", " isChtml", " isHhtml", "isPhhtml", " isChail", " isWhtml", "isChive", "isHhtml", "isChttp", " isWhail", " isChttp", "isWhail", " isHttp", " isHail", "isCtml"], "charset": ["chearspace", "chARSeting", "chanset", "chasets", "chasET", "Charseting", "chARSet", "cheansetter", "chansET", "Charsetting", "cheansetting", "chARSetting", "chasetting", "charsets", "chansetter", "chashesET", "chacksete", "chaseset", "chacksetting", "cheanspace", "chaspace", "chasesetting", "charspace", "chaseseting", "chanspace", "chansete", "chansetting", "CharsET", "charsetting", "chearsete", "cheanset", "cheansET", "Charset", "chearsetting", "chacksET", "charsete", "chearsET", "chasetter", "chasesET", "charsetter", "chARSET", "cheansete", "chaseting", "chashesetter", "chARSets", "chashespace", "chaset", "chasheset", "chearset", "chARSete", "charsET", "charseting", "chearsetter", "Charsets", "chackset"], "headers": [" recipients", "users", "options", " messages", "status", "groups", "comments", "classes", "lines", "settings", " emails", "metadata", "properties", "header", "files", "names", "mails", "errors", " cookies", "ers", "params", "types", "writers", "authors", "content", "strings"], "priority": [" severity", "prefix", "length", " recipients", "quote", "reason", "phone", "title", "status", "mode", "comments", "reply", "template", "date", "code", "comment", "theme", "class", "queue", "language", "security", "state", "level", "author", "lang", " title", "secret"], "email": ["enter", "business", "text", "url", "ssl", "default", "message", "e", "server", "install", "html", "example", "core", "view", "letter", "en", "lex", "event", "info", "data", "username", "international", "engine", "online", "external", "output", "model", "document", "oe", "result", "fax", "zip", "password", "template", "test", "el", "element", "xml", "create", "article", "print", "contact", "base", "object", "address", "account", "ilo", "liner", "name", "Email", "service", "entity", "em", "generic", "pm", "auto", "response", "mail", "office", "note", "update", "line", "export", "ext", "gmail"], "user": ["User", "mobile", "people", "role", "e", "USER", "resource", "connection", "users", "info", "data", "username", "profile", "member", "model", "creator", "me", "type", "plugin", "uid", "consumer", "client", "er", "ip", "object", "id", "token", "account", "string", "character", "name", "unknown", "author", "use", "friend", "person"], "identity": ["authentication", "ethnicifier", "ethnicentity", "authentity", "Identity", "identITY", "ethnicity", "authorITY", "idonymous", "authentization", "authentITY", "personITY", "electricITY", "authorication", "IDENTITY", "authorifier", "idententity", "personity", "installonymous", "entityity", "identization", "IDENTities", "electricity", "IDENTentity", "Identities", "entityifier", "installITY", "authentifier", "idITY", "publicity", "identication", "IdentITY", "publicITY", "authentonymous", "installity", "authoronymous", "Idententity", "IDENTity", "entityonymous", "authority", "personentity", "identonymous", "idization", "electricentity", "idifier", "entityization", "publiciciary", "electriconymous", "identifier", "ethnicITY", "installentity", "ethnicication", "authorities", "identiciary", "identities", "authoriciary", "idication", "personifier", "ethniciciary", "publicentity", "authorentity", "idity"], "_returnPath": ["_returnPart", "_replyNode", " _returnUrl", "_replyPath", " _returnName", "_addpath", "_successText", "_resultPath", "_resultName", "_responsePath", "_returnMid", " _backTo", "_backHalf", "_correctPath", " _backPath", "_returnHalf", "_returnUrl", "_addType", "_backTo", "_displayNode", "_displayPath", "_replyPart", "_returnName", "_returnId", "_resultTo", "_backpath", " _backName", "_backType", "_displayPart", "_correctId", "_returnDirectory", "_inputUrl", "_resultHalf", "_relationDirectory", " _returnPart", "_successId", "_backName", "_backPath", "_relationText", "_relationId", "_relationPath", "_returnNode", "_responseType", "_returnpath", "_correctDirectory", "_displayUrl", "_backUrl", " _returnTo", "_inputPath", "_correctText", " _backHalf", " _backUrl", "_successPath", "_backPart", "_displayMid", "_responsepath", "_returnText", "_replyUrl", "_returnType", "_addPath", "_returnTo", " _returnHalf", "_inputNode", "_inputMid", "_successDirectory", " _backPart", "_replyMid"], "_from": ["placeowner", "placeto", "_source", "existingfrom", "workfrom", "blockfrom", "existingto", "blockto", " _source", " _owner", "existingfor", " _who", "workto", "existingowner", " _error", "_for", "_error", "worksource", "placefrom", "_with", "_owner", "_From", " _for", "blockFrom", "workwho", " _From", "_who", "blockerror", "placefor", " _with"], "_replyTo": ["_replyPoint", "_returnUrl", "_reasonTo", " _replyFrom", "_respondTo", "_respondAddress", " _returnUrl", "_respondUrl", "_commentTo", "_replyOf", "_returnAddress", " _returnFrom", "_closeTO", " _replyUrl", "_respondPoint", "_respondFrom", "_reasonUrl", "_returnPoint", "_commentOf", "_addTo", "_returnOf", "_replyAddress", "_addFrom", "_replyUrl", " _returnTO", "_returnTo", "_reasonFrom", "_commentTO", "_addPoint", "_addAddress", "_returnTO", "_closeFrom", "_commentFrom", " _replyTO", "_replyFrom", "_reasonTO", "_respondTO", "_closeTo", "_replyTO", "_closeOf", " _returnTo", "_returnFrom"], "_to": ["Jabout", "_about", " _about", "Jtarget", "Jfrom", "Jto", " _target", "_target"], "_cc": ["_cd", "_ce", " _ce", " _cd", "_cf", " _cf"], "_bcc": [" _bc", "_rbcc", "_abce", "_sbcs", "_bc", "_rbcs", "_rbc", "_bce", "_abcs", " _abc", " _bce", "_abcc", "_abc", "_rbce", "_bcs", "_sbc", " _abce", "_sbce", " _abcc", "_sbcc", " _bcs", " _abcs"]}}
{"id1": "15799935", "id2": "6470716", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAppensionPart", "saveAttachedBody", "saveAttPartBody", "saveAppachmentBody", "saveAppensionBody", "saveAttensionBody", "saveAttachedPart", "saveAppachmentPart", "saveAttachedbody", "saveAttachmentbody", "saveAttachmentFile", "saveAppensionFile", "saveAttensionFile", "saveAttensionbody", "saveAppachmentbody", "saveAttachmentPart", "saveAttPartFile", "saveAppachmentFile", "saveAttPartPart", "saveAttensionPart", "saveAppensionbody", "saveAttPartbody"], "context": ["text", "component", "subject", "message", "resource", "parent", "view", "connection", "system", "ce", "event", "version", "project", "channel", "definition", "document", "input", "mc", "coll", "translation", "template", "support", "community", "container", "Context", "cca", "driver", "config", "cms", "client", "media", "contact", "reader", "center", "network", "queue", "cache", "present", "c", "service", "kernel", "ctx", "host", "environment", "cf", "current", "state", "concept", "front", "ca", "content", "collection", "manager", "request", "processor"], "part": ["art", "to", "partial", " Part", "component", "message", "image", "parent", "html", "body", "connection", "event", "parts", " parts", "channel", "area", "block", "Parts", "translation", "phase", "type", "comment", "source", "mission", "section", "plan", "media", "PART", "pod", "base", "place", "point", "position", "Part", "object", "po", "patch", "file", "chapter", "upload", "start", "app", "name", "service", "per", "pre", "or", "state", "from", "p"], "localAttachment": ["localArtment", "LocalAttail", "LocalAssachment", "localAssention", "localAssment", "localAssachment", "localAddachment", "localAttention", "localAddrollment", " localAttention", "localAttachrollment", "LocalAssail", "LocalAttention", "localAttachacher", " localExtention", " localAttribution", "localattention", " localPartention", "localattachment", "localPartachment", " localAttrollment", "localExtachment", " localExtacher", "localAddail", "localAttachachment", " localExtachment", "localAvacement", "localAddment", " localAttacement", "localAvacher", "localAttail", "localInstachment", " localAttachachment", "localPartension", "localPartribution", "LocalAttachment", " localAttachrollment", "LocalAssment", "LocalAttment", " localAttacher", " localExtacement", "localInstension", " localPartension", "localattment", "localAttrollment", "localAttension", "localExtacement", " localAttachention", " localAttension", "localAttachention", "localAttachension", " localPartachment", "LocalAssention", "localArtail", "localAvachment", "localInstention", "localExtention", "localAttachacement", "localAttacement", "localAttachribution", "localExtacher", "localattrollment", " localPartribution", " localAttment", "localAttribution", "localAttment", "localInstribution", "localAssail", "localArtention", "localPartention", "localAddention", "localArtachment", "localAttacher", "localAvention"], "accountId": ["feedName", "AccountName", "accInfo", "jobName", "appID", "contractId", "appid", "jobid", "contactId", "contractName", "accid", "accID", "AccountID", " accountID", "accountName", "feedId", " accountid", "jobId", "accountInfo", "jobID", "AccountId", " accountName", "accountid", "contractid", "appId", " accountInfo", "Accountid", "contactid", "feedid", "appInfo", "accountID", "contactName", "accId", "feedID"], "attachmentId": ["attociationType", "addachmentType", "extensionSource", "atachmentID", "addachmentId", "attachedID", "attentionID", "attensionSource", "attentionIndex", "attagramInfo", "attlementName", "attagramId", "attlementId", "adachmentIndex", "addentionId", "attensionId", "attmissionSource", "attachmentid", "atociationID", "attentionUrl", "attachmentSource", "attociationReference", "attensionID", "addentionID", "attmissionID", "extachmentSource", "adentionId", "atociationId", "attmissionId", "attmentName", "attociationName", "attachmentType", "adachmentId", "attptionIndex", "attachmentID", "attptionInfo", "addentionType", "attachedType", "extensionId", "attachedId", "attociationID", "atachmentReference", "attachmentReference", "attachmentInfo", "attentionInfo", "addentionUrl", "attachmentName", "addachmentID", "attagramID", "extachmentId", "attmentId", "atachmentName", "attensionid", "adentionIndex", "atociationReference", "extachmentID", "extensionID", "attmentReference", "attlementReference", "attachedUrl", "attptionID", "adachmentInfo", "attentionId", "attachmentIndex", "extensionid", "adentionID", "attagramIndex", "attociationId", "atachmentId", "attentionSource", "attentionid", "attmissionid", "attlementID", "adachmentID", "adentionInfo", "attmentID", "addachmentUrl", "attentionType", "attachmentUrl", "attociationUrl", "extachmentid", "atociationName", "attptionId"], "in": ["ins", "url", "image", "In", "copy", "init", "info", "data", "inc", "socket", "gin", "f", "it", "input", "din", "IN", "inn", "conn", "pass", "cin", "i", "is", "source", "pull", "reader", "inside", "nin", "a", "login", "inner", "slice", "id", "ac", "load", "bin", "file", "con", "err", "up", "pin", "ini", "as", "or", "plus", "again", "p"], "saveIn": [" saveOut", " saveIN", " savein", "savein", "SaveOut", "savOut", "stageOut", "saveOut", "aveAs", "savin", "aveIN", "writein", "writeOut", "stageAs", "writeIN", "avein", "stageIn", "stageIns", "aveIn", "saveIns", "SaveIns", "savIn", "savAs", " saveIns", "saveIN", "SaveAs", "aveOut", "SaveIn", "writeIn"], "saveAs": [" saveOut", " saveFile", "SaveOut", "copyAs", " saveAS", "writeAS", "copyAS", "openFile", "saveOut", "copyas", "saveAS", "saveas", "createAS", "copyIn", " saveas", "createFile", "writeOut", "openAt", "createAt", "writeAs", "saveFile", "Saveas", " saveAt", "openAs", "saveAt", "createAs", "SaveAs", "SaveAS", "SaveIn", "writeIn", "openAS"], "out": ["at", "to", "page", "ex", "writer", "default", "flow", "image", "copy", "null", "init", "io", "off", "data", "outer", "this", "sync", "inc", "output", "o", "Out", "s", "conn", "temp", "source", "client", "a", "inner", "outs", "cache", "string", "v", "bin", "file", "c", "err", "exec", "name", "other", "up", "OUT", "path", "as", "plus", "again", "line", "ext"], "copySize": ["opensize", "leSIZE", " copysize", "saveLength", "copysize", "openLength", " copyLength", "leLength", "CopyLength", " copySIZE", " copyAddress", "openSize", "byteAddress", "copyLength", "savesize", "saveAddress", "CopySize", "copyAddress", " copyTime", "lesize", "saveSize", "CopyTime", "leSize", "copyTime", "bytesize", "byteLength", "openSIZE", "byteTime", "copySIZE", "byteSize", "Copysize"], "contentUriString": ["contentIiStr", "contentUriStr", "contentUiniByte", "contentIriStr", "contentUristring", "contentUiniStr", "contentIriUnit", "contentIrisUnit", "contentUiniNumber", "contentUiNumber", "contentUioString", "contentUriUnit", "contentUuriStr", "contentUridString", "contentIriNumber", "contentUpiString", "contentUiostring", "contentUriByte", "contentUridStr", "contentIrisstring", "contentIriString", "contentUiString", "contentUrisStr", "contentUiStr", "contentUioStr", "contentUrisstring", "contentIriInt", "contentUiniString", "contentUpiInt", "contentUrisInt", "contentUuriNumber", "contentUiByte", "contentIrisStr", "contentIrisInt", "contentUpistring", "contentIriByte", "contentUrisString", "contentUuriString", "contentUridUnit", "contentIiString", "contentIiNumber", "contentUrisUnit", "contentUriInt", "contentUioInt", "contentUiUnit", "contentUriNumber", "contentIrisString", "contentIiByte", "contentUuriByte", "contentIristring", "contentUpiStr"], "mSize": ["pSize", "pCount", "iSize", "mCount", "pLength", "pName", "cCount", "mName", "mLength", "iName", "cLength", "cName", "cSize", "iLength", "iCount"], "mContentUri": ["mContentIci", "mResourceUri", "mContentOUric", "mResourceIci", "mResourceIris", "mContentOUci", "mContentIric", "mResourceIri", "mContentUrris", "mResourceUci", "mResourceUric", "mContentUrri", "mContentUris", "mContentUric", "mContentOUris", "mResourceUris", "mResourceIric", "mContentIri", "mContentUrci", "mContentOUri", "mContentIris", "mContentUci", "mContentUrric"], "cv": ["conv", "buf", "cap", "que", "core", "vp", "uc", "cp", "loc", "rc", "sv", "um", "av", "uv", "csv", "bc", "vv", "vr", "vs", "mc", "pb", "iv", "coll", "nc", "cb", "auc", "iq", "cc", "nv", "ctrl", "cu", "cm", "keep", "co", "ov", "xc", "sc", "CV", "lv", "cr", "v", "c", "VC", "fc", "GV", "vc", "ctx", "cf", "cd", "cover", "vm", "lc", "content", "cs", "ca", "enc", "fp"], "uri": ["prefix", "proxy", "attribute", "url", "resource", "data", "username", "universal", " URI", "range", "route", "iv", "storage", "href", "ci", " Uri", "uni", "i", "uid", "metadata", "api", "cli", " url", "mi", "pi", "base", "point", " ur", "id", "address", "string", " scheme", "URI", "gb", "iri", "environment", "path", "ui", "query", "qi", "location", "format", "http", "oid", "ri"]}}
{"id1": "3558512", "id2": "12306305", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialize", "normalized", "normalze", "Serialze", "finalized", "erialization", "Serialify", " serialization", "finalify", "Serialized", "finalize", "serialze", "Serializable", "erialize", "Serialization", "finalze", "normalize", "erialze", " serialze", "serialify", " serializable", "serializable", "serialization", "serialized", "normalify", "erializable"], "out": ["page", "ex", "gen", "writer", "report", "image", "server", "copy", "parent", "io", "data", "raw", "output", "archive", "o", "Out", "conn", "temp", "i", "source", "client", "filename", "a", "png", "dump", "outs", "cache", "string", "exec", "bin", "err", "file", "obj", "name", "loader", "up", "w", "OUT", "pool", "content", "buffer"], "parser": ["pe", "pillar", "writer", "lp", "txt", "server", "copy", "master", "parent", "ss", "cp", "system", "rar", "tt", "test", "plugin", "pkg", "instance", "class", "xml", "parse", "reader", "builder", "seed", "er", "worker", "base", "cache", "handler", "file", "upload", "loader", "Parser", "up", "per", "php", "as", "wrapper", "pp", "manager", "p", "processor", "arser"], "on_disk": ["off_demand", "on_delete", "off_drive", "onbootstorage", "onJdisk", "onbookdisk", "off_delete", "off_disk", "on_drive", "on_lock", "onJlock", "onnetfile", "off_storage", "onbootdrive", "onnetdemand", "onjdrive", "on_demand", "onjdisk", "off_lock", "onnetdrive", "off_file", "onjspace", "onnetspace", "onnetdisk", "onJdemand", "on_file", "onjfile", "onbootlock", "on_space", "onbootdisk", "onbookdelete", "onbookdrive", "on_storage", "off_space", "onJdrive"], "in": ["ins", "In", "copy", "ax", "connection", "thin", "info", "data", "inc", "socket", "f", "input", "o", "din", "IN", "inn", "lin", "inas", "conn", "pass", "i", "rin", "win", "kin", "reader", "source", "stream", "login", "inner", "min", "r", "ac", "bin", "file", "con", "c", "pin", "ini", "as", "again"]}}
{"id1": "21821404", "id2": "6457199", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 0, "substitutes": {"getWebPage": ["parseWebpage", "parsewebpage", "getwebPage", "getWebpage", "getwebpages", "getwebpage", "getVirtualpage", "getVirtualPage", "getWebpages", "getVirtualpages", "parsewebPage", "parseWebpages", "parseWebPage", "parsewebpages"], "urlObj": ["strInst", "urlInst", "blogobj", "resourceobj", " urlExt", "urlExt", "urlObject", "blogInst", "httpObj", "UrlObj", "urlOb", "strObj", "urlobj", "URLObject", "URLExt", "URLObj", " urlInst", "blogObject", "UrlOb", "blogObj", "httpOb", "resourceObj", " urlobj", "resourceObject", "strobj", " urlObject", "URLobj", " urlOb", "Urlobj", "strObject", "httpobj", "resourceExt"], "content": ["java", "css", "page", "text", "array", "url", "message", "resource", "report", "core", "server", "write", "html", "body", "empty", "data", "online", "raw", "output", "model", "document", "result", "comments", "coll", "lines", "Content", "out", "code", "source", "comment", "section", "header", "work", "object", "address", "string", "load", "file", "c", "continue", "clean", "response", "cont", "json", "value", "buffer", "feed"], "is": ["est", "ins", "does", "isi", "isl", "ser", "os", "lis", "il", "io", "info", "mis", "problem", "ps", "nis", "you", "iso", "ie", "in", "it", "es", "site", "bis", "ise", "IS", "isc", "us", "fs", "s", "out", "iris", "rest", "ios", "i", "irc", "isp", "cms", "ar", "im", "stream", "al", "ip", "any", "r", "id", "iss", "ir", "ais", "ris", "Is", "be", "ops", "ai", "as", "ui", "or", "isa", "x", "was", "abs", "ires", "ois", "its", "ri"], "reader": ["writer", "e", "server", "ro", "rer", "rx", "ser", "rc", "io", "parser", "ner", "reading", "rar", "director", "actor", "in", "Reader", "editor", "read", "h", "row", "i", "iter", "driver", " Reader", "bird", "stream", "er", "rr", "l", "worker", "inner", "r", "handler", "loader", "ler", "x", "buffer", "or", "oder", "ri"], "line": ["page", "text", "LINE", "url", "lf", "message", "col", "server", "body", "connection", "item", "cell", "data", "link", "part", "entry", "f", "str", "strip", "lin", "cl", "lines", "key", "out", "row", "inline", "code", "pass", "column", "comment", "source", "cle", "section", " inline", "l", "user", "object", "cr", "string", "character", "file", "Line", "name", "response", "word", "lc", "buffer", "ine", "block", "char"]}}
{"id1": "11341711", "id2": "5951961", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"makeBackup": ["makeBackups", "makeCleanups", "createBackUp", "createBackdown", "makePickup", "makebackup", "makeCleanup", "createBackups", "makePickups", "createbackup", "createbackdown", "makebackdown", "createBackup", "makebackUp", "makeCleanUp", "makePickUp", "createbackups", "createbackUp", "makeCleandown", "makeBackdown", "makeBackUp", "makePickdown", "makebackups"], "dir": ["log", "direction", "url", "module", "build", "dest", "rc", "init", "DIR", "io", "data", "store", "md", "director", "folder", "group", "dep", "zip", "Directory", "d", "run", "done", "wd", "dict", "download", "pkg", "source", "config", "directory", "work", "db", "base", "cache", "desc", "ir", "file", "dist", "name", "up", "root", "lib", "diff", "path", "Dir", "manager", "doc"], "sourcedir": ["asourcedir", "sortedore", "seedir", "sodedirs", "ssodedIR", "seeddir", "asourcedore", "sourcedIR", "asortedirs", "ssodedir", "sourcedore", "sodedore", "ssourceddir", "sourcesiri", "sodeddir", "sodedir", "sodediri", "ssodeddir", "asortedore", "sourceddir", "sourcesore", "sourcesdir", "sourcesirs", "sourcesir", "ssourcediri", "sortedir", "asourcedirs", "sortedirs", "ssourcedIR", "sortedIR", "sourcedirs", "seedIR", "seediri", "ssourcedir", "ssodediri", "asortedir", "sourcesIR", "asourcedIR", "sodedIR", "sourcediri", "asortedIR"], "destinationdir": ["Destinationfolder", "Destificationdirection", "DestificationDir", "destinatorfile", "dominationDir", "destinationsfile", "destinatorDIR", "dominatorDir", "destinatefolder", "destinationsDir", "destinatordir", "destinatefile", "destificationdirection", "desturationDir", "destinationDIR", "dominatordir", "destificationfolder", "Destinationdirection", "destinationfolder", "destificationdir", "desturationdirection", "dominationfile", "destinatorDir", "destinationsdir", "dominationDIR", "destinatedirection", "destinateDIR", "destinationDir", "destinationdirection", "desturationdir", "dominatorDIR", "destinationfile", "Destificationdir", "destinationsDIR", "dominationdir", "destificationDir", "desturationfolder", "destinateDir", "destinatedir", "DestinationDir", "Destinationdir", "dominatorfile", "Destificationfolder"], "destinationDirEnding": ["destinationDirEndning", "destinationDirEndining", "destinationDirENDning", "destinationDirENDging", "destinationDirectoryEndING", "destinationPathEndning", "destinationDirSigning", "destinationDirPassging", "destinationPathBegining", "destinationDirSignING", "destinationPathEndING", "destinationDirLeadening", "destinationDirectorySignING", "destinationDirEndging", "destinationDirLeadining", "destinationDirPassing", "destinationDirENDing", "destinationDirectoryEndening", "destinationPathEnding", "destinationDirectorySignening", "destinationDirBeginging", "destinationDirPassING", "destinationDirLeading", "destinationDirEndening", "destinationDirSignening", "destinationPathEndging", "destinationDirectoryEndining", "destinationPathBeginging", "destinationDirSignining", "destinationDirLeadING", "destinationDirEndING", "destinationDirectoryEnding", "destinationDirENDING", "destinationDirPassning", "destinationDirBeginening", "destinationPathBeginning", "destinationDirectorySigning", "destinationDirBeginining", "destinationDirBeginING", "destinationDirBegining", "destinationDirBeginning", "destinationDirectorySignining", "destinationPathBeginING"], "files": ["ls", "fields", "keys", "log", "ins", "rows", "books", "modules", "ps", "users", "links", "data", "reports", "output", "sections", "planes", "groups", " Files", "parents", "features", "split", "classes", "projects", "index", "lines", "balls", "fs", "children", "ips", "docs", "objects", "xml", "results", "flows", "images", "thumbnails", "l", "resources", "pages", "ids", "names", "models", "file", "errors", "tests", "bugs", "locks", "actions", "iles", "rules", "blocks", "Files", "words", "types", "boxes", "events", "uploads", "services", "strings", "items", "its", "runs"], "checkdir": [" checklog", "ckfolder", "searchdirectory", "checkdirectory", "calldir", "calldirectory", "blockdirectory", "searchdir", "workFolder", "lockDir", "workdir", "blockdir", "Checkdir", "blockdraft", "workfolder", "workDIR", "ckd", "checkfolder", " checkDIR", "checkDir", "workfile", "callfolder", "worklog", "CheckDir", "checkd", "blockDir", " checkdirectory", "workdraft", "checkFolder", "locklog", "checkDIR", " checkfolder", "workDir", "ckDir", "ckdirectory", "calld", "workdirectory", "searchDir", " checkDir", "checkdraft", " checkd", "searchdraft", " checkfile", "checklog", "ckfile", " checkFolder", "Checkfile", "lockFolder", "lockdir", "CheckDIR", "checkfile", "ckdir"], "date": ["at", "m", "log", "e", "image", "late", " Date", "event", "tag", "data", "ge", "md", "mate", "zone", "now", "set", "d", "dat", "time", "open", "config", "ime", "contact", "month", "sign", "de", "user", "change", "day", "ate", "file", "Date", "start", "name", "age", "mu", "state", "update", "doc", "dt", "rate"], "msec": ["css", "rsecond", "rss", " minsec", "dsecond", "dsec", " minsc", " minSec", "Msecond", "msecond", "lsecond", "lsec", "misec", " msc", "mss", "dseconds", "mnsc", "rseconds", "Msec", "fmsec", "mnsec", "mnSec", "msc", "fmseconds", "mSec", "lseconds", "csec", "fmisec", "mnif", "cseconds", " mif", "disec", "mif", " minif", "mseconds", "Mseconds", "fmsecond", "Misec", "lss", "rsec", "csecond", " mSec"], "checkFile": ["CheckFile", " checkLine", "controlFile", "ckFiles", "changefile", "changeFile", "ckDirectory", "checkLine", " checkFiles", "controlfile", "workFile", " checkFilename", "checkDir", "workfile", "controlFilename", "checkFilename", "CheckDirectory", "changeLine", "CheckDir", "checkDirectory", "workFiles", " checkDirectory", "workDir", "ckFile", " checkDir", "checkFiles", "CheckFiles", " checkfile", "ckfile", "Checkfile", "changeFilename", "controlLine", "checkfile"], "i": ["m", "p", "u", "uri", "e", "j", "b", "n", "fi", "io", "info", "si", "ie", "part", "field", "index", "ci", "iu", "oi", "key", "ji", "is", "multi", "y", "li", "di", "im", "ip", "pi", "xi", "hi", "eni", "slice", "vi", "id", "ti", "gi", "v", "ix", "I", "ai", "phi", "ini", "ii", "ui", "bi", "x", "mu", "qi", "ri"], "f": ["fd", "m", "fn", "u", "fl", "fr", "e", "j", "sf", "b", "n", "fi", "fb", "info", "folder", "o", "d", "feed", "h", "fs", "l", "fun", "fx", "r", "v", "file", "fc", "t", "w", "cf", "F", "q", "fe", "fp", "p", "df"], "g": ["gar", "m", "og", "eg", "u", "e", "G", "gn", "b", "n", "pg", "erg", "ge", "msg", "reg", "ig", "group", "gd", "gin", "ga", "d", "gc", "rg", "vg", "ng", "gg", "go", "mg", "s", "h", "tg", "gm", "bg", "gh", "sg", "l", "ger", "r", "gi", "file", "gb", "gu", "global", "t", "w", "gp", "gs", "q", "p"], "destinationFile": ["destacementfile", "destationfile", "DestationFilename", "DestificationDir", "DestificationFile", "destiningDir", "Destationfile", "DestinationLocation", "destificationFile", "DestationDir", "destationFilename", "destinationsDir", "destinationsDirectory", "destiningfile", "destinationsFile", "DestinationFile", "DestificationLocation", "destinationDirectory", "destinatorDir", "destacementDir", "destacementFile", "destinationDir", "DestificationDirectory", "destinatorLocation", "destificationDirectory", "destacementFilename", "destinatorFile", "destinationsLocation", "destinationfile", "destificationDir", "destationDir", "DestinationDirectory", "DestationFile", "Destinationfile", "destinationFilename", "destificationLocation", "destinationLocation", "destationFile", "destiningFilename", "DestinationFilename", "destiningFile", "DestinationDir", "destinatorDirectory"], "sourceFile": ["SourceFile", "ourceDir", " sourceDir", "ourceFile", "ourceDirectory", "srcModule", "sourceDirectory", "inputFile", "srcDir", "Sourcefile", " sourceFiles", " sourceDirectory", "srcfile", "sourceModule", "sourcefile", "ourceFiles", "inputDirectory", "inputDir", " sourceModule", "SourceModule", "sourceFiles", " sourcefile", "inputFiles", "srcFile", "SourceDir", "sourceDir"], "infile": ["difffile", "InFile", "inputf", "winstream", "windir", "inputFile", "diffdir", "instream", "indata", "outdir", "inFile", "diffFile", " inFile", "inf", "indir", " indata", "Infile", "Inf", "Instream", "outdata", "winFile", "outf", "inputfile", "outstream", "outFile", "winfile", "inputdata", "inputstream", " instream", "diffstream"], "outfile": ["intstream", "againFile", "outfunction", "againpage", "inputFile", " outpage", " outFile", "intlive", "exFile", "intFile", "outline", "intfile", "Outline", "expage", "againfile", "inputfunction", "exstream", " outline", "inputfile", "outstream", "outFile", "Outstream", " outfunction", "Outfile", "Outlive", " outlive", "againstream", "outlive", "Outfunction", "OutFile", "inputline", " outstream", "outpage", "exfile"], "c": ["k", "m", "u", "ct", "z", "esc", "e", "col", "uc", "C", "b", "n", "rc", "dec", "channel", "in", "ec", "o", "d", "ch", "index", "cl", "ci", "h", "end", "code", "comment", "cu", "cm", "ice", "a", "l", "r", "xc", "id", "ac", "v", "pc", "string", "character", "abc", "t", "w", "cont", "x", "lc", "cy", "pointer", "enc", "cr", "p", "char"]}}
{"id1": "9954926", "id2": "11933797", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"simulate": ["animure", "imulate", "Simulator", "Simure", "animulation", "imulation", "animulate", "imure", "simulation", "Simulate", "simure", "imulator", "animulator", "simulator", "Simulation"], "out": ["ex", "writer", "flow", "report", "parent", "null", "view", "data", "part", "in", "exp", "o", "conn", "temp", "cli", "outs", "cache", "string", "err", "list", "net", "pre", "page", "resource", "server", "info", "group", "result", "error", "key", "dump", "point", "object", "con", "w", "down", "word", "post", "prefix", "gen", "log", "exit", "plain", "io", "outer", "sys", "store", "Out", "flush", "comment", "co", "db", "user", "bin", "obj", "up", "buffer", "again", "write", "copy", "lock", "session", "external", "raw", "output", "now", "client", "tmp", "base", "table", "window", "name", "full", "OUT", "pool", "state", "line", "lib"], "file": ["book", "page", "pe", "log", "FILE", "url", "report", "resource", "message", "le", "ile", "unit", "b", "connection", "data", "socket", "port", "output", "in", "f", "rule", "feed", "source", "filename", "stream", "l", "files", "base", "queue", "cache", "address", "handler", "name", "loader", "full", "File", "path", "buffer", "fe", "collection", "line", "fp"], "obtainUserReputationRequest": ["obtainUserAnnutationRequest", "obtainUserReputedGrant", "obtainUserRepositoryResponse", "obtainUserRepurationResponse", "obtainUserComputationInfo", "obtainUserAnnigrationQuery", "obtainUserReputableResponse", "obtainUserRelutationGrant", "obtainUserRepurationRequest", "obtainUserComputationEntry", "obtainUserRepulationInput", "obtainUserReputedResponse", "obtainUserReputionGrant", "obtainUserRelutationrequest", "obtainUserRepigrationInfo", "obtainUserRelentionrequest", "obtainUserRelutationResponse", "obtainUserReputedrequest", "obtainUserReputionrequest", "obtainUserReputationGrant", "obtainUserComputationInput", "obtainUserAnnutationGrant", "obtainUserRepigrationQuery", "obtainUserReputeResponse", "obtainUserReputableRequest", "obtainUserRelentionRequest", "obtainUserRepigrationRequest", "obtainUserRepulationResponse", "obtainUserRepentionGrant", "obtainUserReputationEntry", "obtainUserReputeEntry", "obtainUserReputedRequest", "obtainUserRepigrationGrant", "obtainUserComputationrequest", "obtainUserAnnigrationResponse", "obtainUserAnnigrationRequest", "obtainUserComputeResponse", "obtainUserRepentionRequest", "obtainUserComputeEntry", "obtainUserComputerequest", "obtainUserRepigrationResponse", "obtainUserRepositoryrequest", "obtainUserRepurityInput", "obtainUserComputeInfo", "obtainUserReputeGrant", "obtainUserComputationResponse", "obtainUserReputationQuery", "obtainUserAnnutationResponse", "obtainUserRepulationEntry", "obtainUserRelentionGrant", "obtainUserReputionResponse", "obtainUserRepositoryRequest", "obtainUserRepentionrequest", "obtainUserRelentionResponse", "obtainUserReputationInfo", "obtainUserReputerequest", "obtainUserReputationrequest", "obtainUserReputationInput", "obtainUserComputeRequest", "obtainUserComputeInput", "obtainUserAnnutationQuery", "obtainUserReputablerequest", "obtainUserRepigrationrequest", "obtainUserRepurationQuery", "obtainUserReputeQuery", "obtainUserReputeInfo", "obtainUserRepurationGrant", "obtainUserRepentionResponse", "obtainUserRepulationRequest", "obtainUserReputeInput", "obtainUserAnnigrationGrant", "obtainUserReputionRequest", "obtainUserReputeRequest", "obtainUserRepositoryInfo", "obtainUserRepurityResponse", "obtainUserRelutationRequest", "obtainUserComputationRequest", "obtainUserRepurityRequest", "obtainUserRepurityEntry"], "obtainUserReputationResponse": ["obtainUserRepositoryRequest", "obtainUserReputationResp", "obtainUserExpositoryResp", "obtainUserExputationResponse", "obtainUserRepositoryResponse", "obtainUserRepurationResponse", "obtainUserReputeResponse", "obtainUserExputationResp", "obtainUserExpositoryResponse", "obtainUserRepurationResp", "obtainUserExputationRequest", "obtainUserExpositoryRequest", "obtainUserReputeResp", "obtainUserRepurationRequest", "obtainUserReputeRequest", "obtainUserRepositoryResp"], "rateUserRequest": ["rateUsageReturn", "rateuserrequest", " rateuserrequest", "rateFileCommand", "RateFileResponse", "rateMachinerequest", "rateMachineRequest", "rateUQUEST", "rateUserFunction", "gradeLineError", "rateFileQUEST", " rateUserQUEST", "issueCustomerForce", "rateUError", "ratedFileCommand", "rateLineGrant", "ratedUserrequest", "RateFileQUEST", "rateFileVersion", "rateWordCustomer", "gradeUserRequest", "rateCustomerForce", "RateUserQUEST", "rateMachineResult", "RateFilerequest", "rateHumanVersion", "rateUQuery", "rateLineResponse", " rateClientRequest", "rateHumanResult", " rateClientGrant", "rateServiceQuery", "rateUserResult", "rateWordError", "rateUserReturn", " rateuserRequest", "gradeUserCustomer", "rateClientGrant", "rateMachineVersion", "rateUResponse", "ratedUsageForce", "rateWordQuery", "rateApplicationRequest", "rateUsageQUEST", "rateUserGrant", "RateUserRequest", "issueUserRequest", "rateHumanrequest", "rateServiceFunction", "rateUCommand", "gradeUserError", "ratedUserFunction", "issueCustomerReturn", "rateUsageUser", "rateLineError", "rateUserQUEST", "rateuserQUEST", "ratedUsageRequest", "issueCustomerRequest", "rateFilerequest", "ratePostrequest", " rateUserGrant", "rateUserError", "ratePostRequest", "rateFileRequest", " rateuserResponse", " rateClientrequest", "featureMachinerequest", "ratedFileRequest", "rateUsageQuery", "ratedUserQUEST", "issueCustomerQUEST", " rateuserQUEST", "featureMachineVersion", "ratedUserCommand", "rateUForce", "rateUsageRequest", "rateFileResponse", "rateUserForce", "rateUserrequest", "issueUserReturn", " rateUserQuery", " rateApplicationRequest", "featureMachineResult", "rateServiceCommand", "ratedUsagerequest", "rateCustomerReturn", "rateApplicationResponse", "rateUSERQUEST", "rateUserUser", "rateUserQuery", " rateApplicationQuery", "rateUsageGrant", "featureUserRequest", "rateFileQuery", "rateuserResponse", "featureMachineRequest", "rateUsageForce", "rateuserRequest", "rateLinerequest", "rateUsagerequest", "rateFileResult", "rateCustomerQUEST", " rateApplicationResponse", "rateClientRequest", "gradeLinerequest", "rateLineCustomer", "rateUsRequest", "rateUsReturn", "ratedUserRequest", "featureUserResult", "rateWordrequest", " rateApplicationUser", " rateUserUser", "rateUsForce", "ratedUsageQUEST", "ratedUsageQuery", "rateApplicationQuery", "rateUSERRequest", "rateLineRequest", "issueUserQUEST", " rateUserrequest", "ratedFileFunction", "rateUserCommand", "ratedFileQuery", "gradeLineRequest", "ratePostQUEST", "rateLineQUEST", "issueUserForce", "RateFileRequest", "rateUSERrequest", "rateLineQuery", "rateUSERForce", "gradeUserrequest", "rateClientrequest", "rateFileFunction", "ratedUserForce", "featureUserVersion", "rateUserCustomer", "rateWordRequest", "rateURequest", "RateUserrequest", "RateUserResponse", "ratedUserQuery", "rateUsQUEST", "rateUrequest", "rateUsageResponse", "rateHumanRequest", "rateApplicationUser", "rateFileUser", "rateServiceRequest", "ratePostResponse", "gradeLineCustomer", "rateUFunction", "rateUCustomer", "featureUserrequest", "rateUserVersion", "rateCustomerRequest"], "rateUserResponse": ["rateuserData", "rateFileStatus", "rateCustomerReference", "rateUsersResource", " rateUserReference", "rateUsersResp", "rateUserResource", "RateTimeStatus", "RateUserResource", " rateApplicationData", "rateCustomerResource", " rateFileResult", "rateUserResult", "RateUserStatus", "RateTimeResp", "RateTimeResponse", "rateUserReply", " rateUresponse", "rateApplicationReference", "rateUResponse", "RateUserRequest", "rateApplicationResp", "rateTimeResp", "rateClientResponse", "rateuserresponse", "rateFileresponse", " rateUResponse", "rateCustomerResp", "rateUresponse", "rateUserData", "rateuserReference", " rateApplicationReference", "rateCustomCustomer", " rateApplicationResp", " rateFileResp", "rateUsersResult", "rateApplicationData", "rateTimeCustomer", "rateFileResponse", " rateUserResult", "rateCustomResponse", " rateFileResponse", "rateuserReply", "rateUserReference", "rateUsersStatus", "rateClientStatus", "rateApplicationResponse", "rateTimeResponse", "rateuserResult", "rateuserResp", "rateuserResponse", "rateFileResult", "rateUsersRequest", "RateTimeCustomer", " rateApplicationResponse", "rateCustomResp", "rateUserResp", "rateCustomStatus", " rateUResp", "rateuserStatus", " rateUserReply", "rateTimeStatus", "RateUserResp", "RateUserCustomer", "rateUserStatus", "rateCustomerResponse", " rateUserresponse", "rateFileReply", " rateUserStatus", "rateClientCustomer", "rateUserCustomer", "RateUserResponse", "rateUResp", " rateFileStatus", "rateCustomerData", "rateUsersResponse", "rateFileResp", "rateClientResp", " rateUserData", " rateUserResp", "rateUReply", "rateUserresponse", " rateUReply", "rateCustomerRequest"], "fis": ["Fis", "FIs", " fiss", "sfiss", "sfris", "Fris", "fris", "sfIs", "Fiss", "bis", " fris", "bIs", "biss", "fIs", "bris", "fiss", "sfis", " fIs"], "br": ["buf", "res", "bro", "wr", "fr", "arr", "fin", "b", "body", "dr", " tr", "io", "bp", "bc", "result", "Reader", "str", "rb", "ch", "ref", " bio", "brush", "BR", "pr", "reader", "lr", "ber", "tr", "r", "cr", "err", "bed", " fr", "ob", "gr", "sp", "hr", "bl", "ler", "buffer", "Br", "bridge", "bs", "sw", "browser"], "call": ["text", "doc", "calling", "url", "play", "flow", "message", "e", "ell", "body", "cod", "loc", "cell", "info", "data", "msg", "phone", "output", "f", "result", "charge", "input", "str", "fax", "check", "ck", "cl", "claim", "called", "type", "code", "xml", "cat", "comment", "cu", "ack", "roll", "push", "create", "contact", "co", "work", "user", "sc", "address", "string", "load", "c", "Line", "name", "response", "query", "voice", "invoke", "buffer", "Call", "throw", "line", "use", "request", "callback"]}}
{"id1": "16556717", "id2": "16048516", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "label": 0, "substitutes": {"getSHADigest": ["getSHADIGest", "getSHADIGEST", "getSHADipEST", "getSHADegEST", "getSHADegester", "getSHADigher", "getSHADigEST", "getSHAPigEST", "getSHADegher", "getSHAPigest", "getSHAPegester", "getSHADipest", "getSHADegest", "getSHADIGher", "getSHAPigher", "getSHAPegEST", "getSHADIGester", "getSHADipester", "getSHADigester", "getSHAPigester", "getSHAPegher", "getSHAPegest", "getSHADipher"], "password": ["secret", "crypt", "text", "padding", "prefix", "attribute", "auth", " passwords", "data", "username", "sword", "phrase", "hash", "input", "encrypted", "key", "wd", "pass", "code", "config", "user", "Pass", "id", "address", "token", "string", "email", "security", "name", "pattern", "words", "path", "word", "buffer", "Password", "p", "PASS"], "digest": ["hexest", "digress", "Digusher", "dighest", "digString", "greatest", "generhest", " digEST", "DigEST", "hashester", "Digester", "digEST", "Digest", "hashests", " dighest", "digesting", "greatester", "greatEST", "hashusher", "Dighest", " digesting", " digress", "digkey", "hashString", "generester", "generEST", "generest", "hexests", "greatesting", " digusher", "DigString", " digester", "Digkey", "Digesting", "digester", "hexkey", "hexString", "digests", "Digests", "hashkey", "digusher", "hashest", "Digress", "hashress"], "sha": ["ppa", "oa", "va", "volume", "ema", "pg", "ah", "acl", "HA", "shi", "si", "ph", " SHA", "alias", "hash", "pa", "mc", "ga", "sum", "ta", "ka", "h", "meta", "asha", "cca", "ami", "api", "hh", "qa", "a", "lambda", "slave", "pi", "SHA", "da", "mac", "na", "ba", "po", "sa", "wa", "acha", "alpha", "ma", "ua", "la", "eta", "ha", "ssh", "sh", "ca", "aa"], "pwhash": [" pwhashed", "pWHa", "pwest", "pphash", " pwhest", "pwheash", "jpwhashed", "pphest", "pWhashed", "pwhashed", "jpWHa", "pWHest", "jpWHashed", "pWhash", " pwashed", "pWHashed", "jpwhash", "pwhade", "pWhest", "pwheest", "jpwha", "pphade", "pwashed", "jpWHest", "pwhest", "pwash", "pwha", " pwest", "pphashed", "pWHash", "pwade", " pwade", " pwhade", "jpWHash", "pwa", "pwhea", "jpwhest", " pwash", "pWhade", "pwheashed"]}}
{"id1": "21181542", "id2": "18217985", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "label": 0, "substitutes": {"deleteRoleType": [" deleteRoletype", "deleteroleType", "deleteRoletype", "deleteResourcetype", " deleteRoleTyp", "deleteFunctionType", "deleteRoleTyp", " deleteroleTypes", "deleteroleTyp", "deleteResourceType", " deleteroleType", "deleteroletype", "deleteroleTypes", "deleteResourceTypes", "deleteFunctiontype", "deleteResourceTyp", " deleteRoleTypes", "deleteRoleTypes", " deleteroletype", "deleteFunctionTypes", "deleteFunctionTyp", " deleteroleTyp"], "id": ["ID", "url", "uri", "kid", "parent", "length", "vid", "view", "connection", "lock", "like", "data", "info", "version", "mid", "sid", "part", "in", "model", "it", "f", "aid", "Id", "index", "pid", "error", "key", "type", "end", "rid", "code", "uid", "source", "i", "is", "section", "edit", "ip", "ids", "object", "address", "string", "start", "name", "path", "ident", "oid", "request"], "namespaceId": ["namespacesInfo", "namespaceContext", "namespacedInfo", "memberspaceId", "asentityName", "namesspaceId", "membersetId", "nspaceid", "namespacedType", "namesaceID", "namesentityName", "asentityInfo", "namesaceInfo", "nspaceId", "namespacesid", "namesenceType", "workspaceType", "memberspaceType", "NamespaceId", "aspaceID", "workspacesid", "workspaceKey", "memberspaceName", "namespaceKey", "namespacesContext", "namespacesID", "namesetid", "namesentityID", "Namespaceid", "workspaceInfo", "namesentityId", "namesaceId", "nspaceID", "aspaceName", "namesplaceid", "namesetId", "namesenceId", "namesspaceKey", "membersetid", "workspacesId", "workspacePath", "worksspacePath", "workspaceId", "namespacesKey", "workspacesType", "namespaceid", "worksspaceId", "namespacedId", "workspaceid", "workspaceContext", "namespacesName", "nsaceid", "namesaceid", "worksspaceInfo", "namespacedName", "NamespacedType", "namesplaceInfo", "NamespaceName", "namesspaceInfo", "namespacedKey", "namesentityInfo", "namesenceid", "NamespaceType", "namesaneName", "namesetID", "namespacePath", "namespaceType", "Namespacedid", "namesaceType", "namespacedid", "nsaceID", "aspaceInfo", "namesplaceId", "membersetName", "NamespacedName", "namespaceInfo", "nspaceInfo", "nsaceInfo", "namespaceID", "namesetInfo", "namesaneId", "namespaceName", "namesetType", "worksspaceKey", "NamespacedId", "namesspacePath", "nsaceId", "workspacesContext", "namesenceContext", "asentityId", "namespacedPath", "namesaneType", "namesaneid", "memberspaceid", "membersetType", "asentityID", "aspaceId", "namesplaceID", "namespacesType", "namespacesId", "namesaceContext", "namespacesPath", "namesetName"], "removeReferencesInRoleTypes": ["removeReferencesFromRoleNames", "removeReferencesInroleRelations", "removeReferencesInRoleType", "removeReferencesInServiceRelations", "removeReferencesedInroleType", "removeReferencesedInroletypes", "removeReferencesInServiceType", "removeReferencesInRoletypes", "removeReferencesInRuleType", "removeReferencesedInRoleTypes", "removeReferencesFromRoleRelations", "removeReferencesedInRoleNames", "removeReferencesInRuleRelations", "removeReferencesFromroleNames", "removeReferencesedInroleTypes", "removeReferencesInServiceNames", "removeReferencesedInroleNames", "removeReferencesInRoleNames", "removeReferencesFromroleTypes", "removeReferencesInRoleRelations", "removeReferencesInroleType", "removeReferencesInServiceTypes", "removeReferencesFromroleRelations", "removeReferencesInRuleTypes", "removeReferencesFromroleType", "removeReferencesInRuleNames", "removeReferencesInroletypes", "removeReferencesInroleTypes", "removeReferencesedInRoletypes", "removeReferencesedInRoleType", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInRuletypes", "removeReferencesFromRoleType"], "permit": ["permits", "permmissions", "Permissions", "perMIT", "PERMIT", "PerMIT", "permission", "recmits", "permMIT", " perit", "Perit", "Permit", "permmit", "recmit", "recmission", "Permits", " permission", "Permission", "permissions", " permits", "perit", "PERmission", "permmission", "PERmissions", "recit", "PERmit"], "exist": ["purpose", "icate", "include", "write", "apply", "cmp", "except", "form", "destroy", "know", "stick", "inc", "draw", "check", "fail", "index", "support", "fill", "existence", "create", "add", "ist", "register", "keep", "edit", "delete", "same", "present", "match", "start", "list", "continue", "destruct", "existing", "diff", "existent", "cont", "ident", "front", "update"], "msgBuf": [" msgBuff", "msgEBuff", " msgFuf", "msgPlaf", "messageFbox", "msgPluf", "msgEBuf", " msgFbuf", "messageBbuf", "msgDuff", "msgAUF", "msgBbox", "msgFBUF", "messageFbuf", "msgDBuff", "msgBbuf", "msgFuf", "messageAuf", "msgFundle", "msgFbox", "msgDbuf", "msgDaf", "msgBob", "msgBraf", "msgLuff", "msgBUF", "msgDBuf", "messageAbuf", "msgPluff", " msgLaf", "msgLuf", "msgFBob", "msgEBbuf", "msgFBuff", "msgCuf", " msgLuff", "messageBuf", "msgLUF", "msgCuff", " msgFuff", "msgLaf", "msgLundle", "msgFUF", "msgFBuf", "msgBaf", "msgAraf", "messageBuff", "messageFob", "msgAuf", " msgFraf", "messageFUF", "messageBob", "msgAuff", "msgFbuf", " msgBundle", "messageBbox", "msgAbox", "msgDuf", "msgFob", "msgCob", "msgBundle", "msgLob", "msgAbuf", "msgAob", "msgAbuff", " msgBbuf", " msgFbuff", "msgFaf", " msgLundle", "msgBbuff", "msgFuff", " msgBaf", " msgFaf", "messageFuf", "messageFuff", " msgBbuff", "messageBUF", "msgFbuff", "msgAaf", "messageAuff", "msgBuff", " msgLuf", "messageAUF", "msgDBbuf", "msgFraf", " msgBraf", "msgEBbox", "msgCbuf", "msgDBUF", "msgPlundle"], "objects": ["notes", "values", "keys", "ins", "people", "pins", "kids", "archives", "products", "owners", "points", "os", "obs", "links", "users", "jobs", "parts", "cats", "relations", "archs", "oids", "agents", "apps", "plugins", "groups", "organisms", "parents", "features", "classes", "projects", "lines", "children", "results", "images", "properties", "pps", "files", "resources", "ids", "object", "frames", "names", "articles", "models", "obj", "bugs", "cells", "locks", "actions", "ops", "blocks", "types", "boxes", "members", "phones", "items", "ks", "roots"], "sqlRightId": ["sqlrightId", "sqlRightRef", "sqlRightPoint", "sqlRightType", "SQLRightID", "sqlRestId", "sqlRRef", "sqlRID", "sqlrightPoint", " sqlrightid", "sqlRestID", "SQLRightRef", "SQLRestID", "SQLRestId", "SQLRestid", "sqlLeftid", " sqlRightPoint", "sqlRId", " sqlrightId", "SQLRightid", "SQLRightId", "sqlRightID", "sqlRightid", " sqlrightPoint", "sqlrightid", "SQLRestRef", "sqlRestRef", " sqlrightType", "sqlLeftType", "sqlrightType", "sqlLeftId", "sqlLeftPoint", " sqlRightid", "sqlRestid", "sqlRid", " sqlRightType"], "sqlParent": [" sqlparent", "qlRoot", "suparent", "qlparent", "sqlParents", "suParents", " sqlRoot", "suParent", "qlParent", "suRoot", " sqlParents", "sqlparent", "qlParents", "sqlRoot"], "sql": ["replace", " db", "description", "log", "url", " SQL", "acl", "msg", "link", "session", " params", "error", " session", "conn", "s", "dl", " url", "delete", "db", "select", "repl", "sl", "operation", " msg", "where", "update", "SQL", "ql"], "pstmt": ["pctbl", " pSttr", "pftr", "pStm", " pndmt", "pndmb", "Pcttr", " pstmb", "pstatnt", " pStmt", "pctmb", "pmtbl", "postnt", " pstnt", "New", "pStct", "Security", "pmtmb", " pStm", "Pctct", "pstbl", "_", "pstrtr", "this", "pstm", "All", "pfct", "pStmt", " pStct", "add", "pstrm", "Pctmd", "pstmd", "pctmr", "Pstct", " pstmr", "pctm", "psttr", " pndmb", "pctct", "Pstmd", "postct", "Pctmt", "s", " pndct", " pstbl", "pndct", "pmtct", "pfmt", "pstatmt", "postmr", " postnt", "pmtmd", "pfmd", "pstatct", "Pstmt", "pstmb", "pstatmr", " pstm", "pctmd", "pmtmt", "pstmr", "pndbl", "The", "postmt", " pstct", "Error", "pstct", "pstnt", "pstrmt", "pctnt", "pSttr", "pndmt", " pndbl", "delete", " postmt", " postmr", "pstrct", " psttr", "pmttr", "pctmt", " postct", "Delete", "Psttr", "pcttr"], "typeGid": ["typegID", "linkGid", "linkGID", "TypeCmin", "TypeCID", "linkGoid", "typeGUid", "typeGVID", "typeGUname", "typegname", "TypeGmin", "typeGmin", "typeAccid", "typeWID", "TypeGid", "linkGname", "typeCname", "typeGname", "TypeCname", "TypeGname", "typegid", "typeGoid", "linkGVID", "TypeGID", "typeGVoid", "typeGID", "typeGUoid", "linkGVid", "typeWid", "linkGVoid", "TypeCid", "linkGVname", "typegoid", "typeGUID", "typeCmin", "typeGVid", "typeCID", "typeAccID", "typeAccname", "typeAccmin", "typeWname", "typeWmin", "typeCid", "typeGVname"], "defaultLevel": ["configDepth", "configCl", " defaultCl", "DefaultLevel", "defaultCl", "defaultMode", "configMode", " defaultDepth", "configLevel", "DefaultCl", "defaultDepth", " defaultMode", "DefaultDepth", "DefaultMode"], "success": ["warning", "replace", "resp", "message", "successfully", "complete", "failed", "successful", "data", "reg", "status", "result", "fail", "launch", "batch", "error", "accept", "test", "results", "Success", "progress", "roll", "match", "submit", "continue", "response", "serial"]}}
{"id1": "12428013", "id2": "20019847", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"polishOff": [" synchroniceDown", " synchroniceOffline", " synchronipeOffline", " synchronishingDown", " synchroniceOff", " polishingDown", " synchronishingOffline", " polishDown", " synchronishDown", " polishingOffline", " synchroniceOn", " polishOn", " synchronishOffline", " synchronishingOff", " synchronishOn", " synchronipeOn", " polishOffline", " synchronipeDown", " synchronishOff", " synchronipeOff", " polishingOn", " synchronishingOn", " polishingOff"], "monitor": ["mon", "m", "widget", "component", "log", "annot", "unit", "report", "message", "image", "core", "clock", "master", "module", "body", "reason", "method", "username", "oper", "duration", "program", "port", "watch", "member", "status", "meter", "timer", "controller", "mc", "Monitor", "stat", "timeout", "container", "conn", "dm", "progress", "consumer", "cm", "driver", "config", "thread", "don", "period", "directory", "client", "number", "control", "object", "counter", "match", "handler", "mor", "sm", "loader", "pm", "umi", "cher", "function", "runner", "or", "state", "condition", "update", "manager", "callback", "processor"], "from": ["at", "prefix", "attribute", "component", "From", "uri", "url", "resource", "server", "connection", "loc", "remote", "form", "ce", "org", "back", "username", "actor", "part", "channel", "range", "route", "about", "small", "type", "code", "source", "add", "action", "since", "with", "size", "contact", "base", "user", "id", "address", "email", "string", "who", "start", "name", "origin", "by", "vol", "left", "host", "ou", "path", "or", "front", "false", "owner"], "to": ["prefix", "into", "url", "uri", "resource", "server", "dest", "connection", "remote", "two", "io", "info", "version", "pos", "range", "site", "so", "about", "o", "reply", "ref", "su", "go", "type", "out", "key", "source", "TO", "top", "size", "with", "target", "toc", "base", "user", "table", "address", "po", "token", "file", "name", "repl", "by", "left", "full", "until", "location", "eto", "value", "To", "database"], "renameTo": [" RenameTo", "renamTarget", "renenameFrom", "renamelOf", "relameFrom", " RenameFor", "renewTo", "renributeWill", " RenameWill", " RenAMETarget", "renributeTarget", "relameUrl", "renameTarget", " renAMETarget", " renameTarget", "renameTO", "renseOf", "reameToken", "renalTO", " renAMEFrom", "renamFor", "renenameTo", "renalTo", "relenameto", "relameto", "relameTarget", "reameTO", "renamelFor", "relenameUrl", "renseTo", "renAMETo", "renenameto", "renokeFor", "renamelTo", "renameFor", "renokeTO", "renamTo", "renAMETO", " renameFrom", "renokeTo", "renameFrom", " RenameTarget", "reageTO", "reameto", " RenseTo", "renenameTarget", " RenameOf", "renameUrl", "renamWill", "renageto", "renAMEto", "renameWill", "rennameFrom", "renewFrom", "renameto", "relameTo", " RenAMETo", "renributeTo", "renoketo", " RenAMEWill", " renAMETo", "renameToken", " RenseOf", "rennameto", "rennameTarget", "renseTO", "reameTo", "relenameTo", "reageto", " RenseFor", "renAMEFrom", "renseFor", "renenameUrl", "renAMEToken", "renewTarget", "renAMETarget", "renAMEFor", "reageTo", "renageTO", "relalTo", "renalFrom", "renalTarget", "relalFrom", "renameOf", "renokeFrom", "relalto", " RenseTO", "renageTo", " RenameTO", "renalToken", " RenAMEFor", "reageToken", "renAMEWill", "renalto", "renokeUrl", "renokeOf", "renamelTO", "rennameTo", "renAMEUrl", "relalTarget", "renributeFor", "relenameFrom", "renageToken"], "ftpClient": ["ftpGuest", "ftiClient", "ctcpChannel", "ftpsContainer", "ftbCan", "ftpoClient", " ftpoCenter", " ftpCommunity", "ftcpHelper", " ftpCloud", "ftpcCloud", "ftpCommunity", " ftnClient", "afttClient", "ftoCan", " ftpHost", " fticlient", "ctcpServer", "ftfpClient", "ftpConnection", "ftpsControl", " ftpChannel", "ftnClient", "ftcpResource", "ftpcServer", "fttStream", " ftpiChannel", " ftiGuest", "ftpContainer", "ftlConnection", "ftpControl", "ftfpCenter", "ftmResource", "ftpoCloud", " ftpclient", "ftpcContainer", " ftoHost", "ftfpResource", "ftbrClient", " ftpiServer", "ftapiCloud", " ftpoClient", "ftmClient", " ftpControl", "ftnHost", "ftcpConnection", " ftpoCloud", "ftapiClient", "ftapiServer", "ftlCommunity", "ftcpCommunity", "ftpcConnection", "ftpiHost", "ctpClient", "aftpClient", "ftpcCenter", "ftcClient", " ftpiClient", " ftapiClient", "ftpcCommunity", "fttpHost", "ftpHelper", "fticlient", "ftmChannel", " ftapiServer", "fttpControl", "ftpsClient", " ftpGuest", " ftpClass", "fttpClass", "fttpServer", " ftnHost", "fttpContainer", " fttpClient", "ftlCenter", "ftpsClass", " ftoClient", "ctcpResource", "ftoHost", " ftlCommunity", "ctpServer", "ftcpCloud", "ftbrStream", "ftpiChannel", "ctpResource", "fttClient", "ftpiClient", "ftpCenter", "ftpclient", "ftcServer", "ftoServer", "ftnServer", "ftpcClient", " fttpContainer", "ftpHost", " ftoServer", "fttpClient", "ftfpServer", " ftpConnection", " ftiClient", "ftpStream", "ftcpChannel", "ftiServer", "ftcpclient", " ftpHelper", " ftapiHelper", "ftpCan", " ftlClient", "ftpcClass", "ftpcHelper", " ftpContainer", "ftfClient", "ftfpCloud", "fttpChannel", " ftoCan", " ftiServer", "ftcpServer", "ftoClient", "ftcpClient", "ftbClient", "ftcpCenter", "ctpChannel", " ftapiCloud", "ftpCloud", "ftpoCenter", " ftnServer", " ftpServer", "ftpChannel", " ftpCan", "ftbServer", "fttpStream", "ctcpClient", "fttpCan", " ftpCenter", "ftpResource", "ftfCenter", "ftpClass", "ftcGuest", " ftlCenter", "ftfpChannel", "ftcclient", "ftlClient", "ftbHost", "ftpiServer", "afttStream", "aftpStream", "ftcpHost", " ftlConnection", "ftcpGuest", "ftpServer", " fttpClass", "ftpcControl", " fttpControl", "ftmServer", "ftfCloud", "ftapiHelper", " ftpiHost", "ftiGuest"], "ftpHolder": ["fttpHard", "ftphather", "ftpholder", "ftpHather", "ftpShander", "ftpShard", "ftphard", "fttpHolder", "ftpCholder", "ftpWather", "ftpcHather", "fttpHander", "fttpChander", "ftpWorkholder", "ftpcWather", "ftpChard", "ftpChander", "ftpWolder", "ftpHook", "ftpShook", "ftpcWolder", "ftpChook", "ftphholder", "ftpWholder", "ftpcHold", "fttpChook", "ftpHander", "ftpWorkather", "ftpcHholder", "fttpCholder", "ftpcWholder", "fttpHook", "ftpcWold", "ftpWorkold", "ftpSholder", "ftpWorkolder", "ftpHholder", "ftpHold", "fttpChard", "ftphander", "ftphold", "ftpcHolder", "ftpHard", "ftphook", "ftpWold"], "iter": ["enter", "e", "itter", "ser", "loc", "init", "info", "outer", "ipper", "ner", "oper", "inc", "collect", "in", "limit", "entry", "it", "f", "result", "iv", "set", "index", "ener", "finder", "coll", "end", "gener", "ver", "i", "reader", "size", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "id", "skip", "over", "ir", "file", "err", "list", "Iter", "inter", "ator", "next", "izer", "cher", "ite", "or", "chain", "iterator", "http", "its"], "element": ["component", "ee", "parent", "letter", "data", "part", "entry", "variable", "token", "per", "owner", "page", "text", "e", "resource", "server", "style", "connection", "Element", "event", "cell", "empty", "this", "folder", "ele", "definition", "result", "editor", "input", "coll", "key", "type", "el", "plugin", "article", "expression", "er", "et", "object", "email", "match", "option", "entity", "layer", "content", "attribute", "air", "instance", "comment", "action", "section", "atom", "node", "optional", "next", "environment", "value", "activity", "module", "item", "child", "output", "member", "document", "container", "reader", "header", "number", "inner", "service", "or", "line"]}}
{"id1": "13563706", "id2": "17158020", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"doGet": ["handleGet", "handleGET", "handleget", "doget", "didget", "doPut", "handlePut", " doget", " doGET", " doPut", "didGet", "didPut", "doGET", "didGET"], "request": ["attribute", "req", "p", "url", "frame", "resource", "report", "server", "message", "image", "complete", "view", "Response", "connection", "remote", "event", "method", "data", "info", "application", "model", "document", "result", "input", "Request", "type", "xml", "instance", "create", "QUEST", "config", "client", "user", "queue", "object", "string", "query", "current", "buffer"], "response": ["resp", " Response", "description", "res", "writer", "subject", "respond", "report", "resource", "server", "message", "image", "view", "Response", "connection", "body", "reason", "output", "model", "application", "status", "result", "site", "document", "reply", "index", "error", "results", "api", "client", "header", "object", "wa", "re", "service", "location", "pool", "json", "query", "collection", "http", "feed", "onse"], "selectedPage": [" selectedHour", "namedpage", "selectedLine", "selectionFile", " selectedAction", "namedPage", "namedFile", "selectedButton", "lectedpage", "lectedFile", " selectedItem", "lectedLine", "selectionpage", "namedLine", "selectedpage", " selectedLine", "lectedSite", "lectedAction", "electedPage", " selectedFile", "electedLine", "selectedFile", "selectionItem", " selectedButton", "lectedPage", "electedpage", "lectedItem", "selectionAction", "namedSite", " selectedSite", "selectionButton", "electedButton", "lectedButton", "lectedHour", "selectedAction", " selectedpage", "selectedSite", "selectionPage", "selectedItem", "selectionLine", "selectionHour", "selectedHour"], "page": ["menu", "image", "parent", "html", "view", "pg", "profile", "row", "queue", "cache", "po", "per", "pp", "photo", "Page", "unit", "resource", "message", "server", "connection", "port", "display", "model", "result", "type", "plugin", "record", "article", "point", "change", "layout", "handler", "age", "proxy", "url", "channel", "site", "route", "rule", "me", "instance", "section", "user", "node", "account", "location", "block", "peer", "module", "pl", "item", "ge", "project", "je", "child", "phone", "document", "f", "client", "ice", "ip", "number", "position", "address", "language", " Page", "sp", "pool", "office", "fe", "p"], "portalRequest": ["portortalRequest", "PortortalUser", "portpalResponse", "portelQuery", "portelCommand", "portalAccess", "PortortalEvent", "portALEvent", "portugalEvent", "portallResponse", "portalResponse", "portugalUser", "portALUser", "portortalServer", " portialRequest", "portialQuery", "portbalQuery", "portallingPage", "portalPage", "PortortalAccess", "PortortalCommand", "portortalUser", " portialResponse", "portugalServer", "portialRequest", "PortalEvent", " portialQuery", "portALRequest", "portelRequest", "PortortalResponse", "portalEvent", "portpalRequest", "portALResponse", " portalQuery", "portbalResponse", "PortalOrder", "PortalCommand", "portailRequest", "portbalRequest", "PortalAccess", "portelResponse", "portugalResponse", "portallingResponse", "PortortalServer", "portallUser", "portailOrder", "portugalOrder", " portalResponse", " portalPage", "portialPage", "portallingRequest", "portalUser", " portialPage", "portpalPage", "portalServer", "portallingAccess", "portailUser", "PortortalRequest", "portallServer", "portortalOrder", "portelPage", "portortalPage", "PortalRequest", "portortalResponse", "portallRequest", "portalQuery", "PortalResponse", "PortortalOrder", "portortalEvent", "portbalPage", "portialResponse", "PortalUser", "portallingCommand", "PortalServer", "PortortalPage", "portugalRequest", "portalOrder", "portailResponse", "portortalCommand", "portortalAccess", "portpalAccess", "portalCommand", "PortalPage"], "pageProp": ["projectProp", "pluginPro", "projectProperty", "PageProp", "parentProperty", "pageObj", "pagePro", "agePro", "projectprop", "parentProp", "peerStr", "pluginProperty", "pluginprop", "PagePro", "parentObj", "pageprop", "resourceProperty", "resourceProp", " pageProperty", " pageObj", "PageProperty", "ageProperty", "pageProperty", "Pageprop", "ageprop", "PageStr", "peerProp", "resourcePro", "pluginProp", "pageStr", "ageProp", "projectPro", "peerProperty", "PageObj", " pagePro", "parentPro", " pageStr", "peerPro", "resourceprop"], "possiblePage": ["possibilityPage", "possibleItem", "puredPage", "permanentpage", "PossiblyPage", "possiblyGroup", "pablePages", "PossiblyItem", "PossibilityLine", "patchingGroup", "patchingpage", "possiblyLine", "Possiblepage", "patchedPage", "permanentLine", "PossibleGroup", "patchedOrder", "possiblePages", "possibleGroup", "patchingPage", "puredGroup", "possibleLine", "PossibleOrder", "possiblyPage", "PossiblyLine", "possiblyItem", "pablepage", "PossiblePages", "puredpage", "patchingItem", "possiblyPages", "possiblepage", "PossibilityPage", "PossibleLine", "possiblyOrder", "patchedpage", "permanentPage", "PossibilityPages", "possibilityPages", "PossiblePage", "Possiblypage", "puredItem", "possibilityLine", "pableLine", "possibilitypage", "PossibleItem", "PossiblyOrder", "pablePage", "patchedLine", "Possibilitypage", "PossiblyGroup", "permanentOrder", "possiblypage", "possibleOrder"], "property": ["prop", "prefix", "attribute", "p", "Property", "resource", "integer", "maximum", "uration", "term", "notation", "profile", "data", "project", "operator", "duration", "f", "result", "set", "key", "type", "binding", "class", "future", "config", "properties", "section", "header", "expression", "perties", "number", "feature", "table", "variable", "object", "address", "language", "string", "character", " Property", "name", "entity", "t", "binary", "layer", "function", "value", "label"], "referer": ["diffrer", "fere", "Referen", "referers", "refiner", " refre", "referen", "rerer", "reere", "redrer", "Referer", "redber", "Refeline", "Refender", "Refere", "affere", "Refre", "Refiner", "defrer", "afferen", "defere", "reiner", "deferer", "ferers", "rere", "refre", "reerer", "rederer", "differer", " referers", " refrer", " refender", "redeline", " refeline", "frer", "refber", "refeline", "affrer", "refender", "refere", "Referers", "defender", "afferer", "diffiner", "Refber", " referen", "diffender", " refere", "defber", "Refrer", " refiner", "refrer", "ferer", " refber"], "e": ["ee", "esi", "message", "one", "se", "null", "event", "this", "ie", "ele", "f", "es", "o", "d", "ae", "error", "me", "type", "see", "element", "i", "a", "er", "E", "de", "eme", "err", "ea", "or", "ed", "fe", "exc", "p", "ception"]}}
{"id1": "19584877", "id2": "16388708", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "6987642", "id2": "14785308", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"encodePassword": [" enodePassword", "enodePassword", " encodeString", "encodePass", " enodeAuth", " enodeString", "enodedPassword", "enressAuth", "encodeAuth", "enodePass", "enodeString", "enodedPass", "enodeAuth", " encodePass", " encodeAuth", " enodePass", "enressString", "enressPass", "enressPassword", "encodeString", "enodedAuth", "enodedString"], "password": ["crypt", "prefix", "text", "p", "padding", "auth", "message", "sha", " passwords", "data", "username", "sword", "phrase", "hash", "input", "wd", "out", "pass", "code", "number", "SHA", "user", "Pass", "address", "token", "string", "name", "confirmed", "pattern", "words", "path", "word", "content", "value", "Password", "secret", " Password", "database", "PASS"], "md": ["mad", "m", "rm", "hd", " MD", "Cmd", " Md", "nd", "mp", "sha", "cmd", "dr", "data", "mo", "dig", "dd", "gd", "hash", "mc", "mag", "d", "vd", "od", "me", "ms", "mb", "hm", "ng", "amd", "mg", "dm", "bd", "metadata", "pd", "MD", "di", "mn", "ad", "mac", "ind", "mand", "mm", "sm", "ma", "am", "pm", "grad", "mt", "mod", "dh"], "encodedPassword": ["encachedText", "encodedText", "enodedText", "encodingString", "enccodedUser", "encachedSecret", "Enccodedpassword", "encodedString", "Encodedpassword", "enccodedString", "EnccodedUser", "enodedPassword", "enodedSecret", "enccodedpassword", "enryptedPassword", "EncodedPassword", "encryptedString", "enryptedText", "encodepassword", "enryptedString", "encryptedText", "EnccodedString", "encodingPassword", "encodedUser", "encryptedUser", "encodingText", "encryptedPassword", "encachedPassword", "EncodedUser", "EnccodedPassword", "encodingSecret", "encodeString", "encryptedSecret", "encryptedpassword", "encodedpassword", "enodedString", "enccodedPassword", "enryptedSecret", "encodedSecret", "EncodedString", "encodeUser", "encachedString"]}}
{"id1": "6171406", "id2": "942693", "code1": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"createTar": ["createHar", "makeTar", "buildJar", " createHar", "makeJar", "buildTar", "createJar", "buildHar", " createJar", "makeHar"], "directoryToPack": ["directoryFrompack", "directoryToUse", "categoryToPush", "dirtoSave", "directoryOfpack", "directorySyncpack", "filenameTopack", "directionTOSave", "DirectorytoSave", " directorytoSave", "directoryToZip", "directorySyncSave", "databaseToSave", "DirectorytoPack", "directoryToPush", "directoryTOSave", "directoryToHack", "DirectoryToZip", "directoryOfPack", "Directorytopack", "directionTOPush", "directoryPopack", "directorytoPack", "filenameToSave", "directionToSave", "directory2Pack", "filenameToPack", "directorytoUse", "directoryToSave", " directoryTopack", "dirtoPack", "dirToPush", "directoryPoPush", "directoryPoPack", "directionToPack", "filenameToPush", "DirectoryTopack", "filenametoSave", "directoryOfSave", "directoryTOHack", "directorytopack", "directoryWillPack", "directory2pack", "directory2Push", "filenametoPack", "directoryFromSave", "directoryWillHack", "dirTopack", "directionTOpack", "directorySyncPush", "categoryPoPush", "filenametoPush", "dirtopack", "DirectoryToPack", "directoryTOUse", "directoryTOpack", "categoryPopack", "filenametopack", "directionToPush", "directionTopack", " directoryToPush", " directoryToUse", "directoryFromPush", "categoryPoPack", "directorySyncPack", "directoryTOPush", "directorytoPush", " directorytopack", "DirectoryToSave", "databaseTOpack", "dirToSave", "directoryFromPack", "directorytoHack", "databaseTOPack", "directorytoZip", "directionTOPack", "databaseTOSave", "directoryTOPack", " directoryToHack", "databaseToPack", "databaseTopack", "categoryTopack", "categoryToPack", "directoryWillZip", " directoryToSave", " directorytoUse", "directorytoSave", "directoryTopack", "directory2Save", "directoryWillpack", " directorytoPack", "dirToPack", "directoryWillSave", "dirtoPush", "directoryOfUse", " directorytoHack", "directoryWillPush", " directorytoPush", "DirectorytoZip"], "targetTarFile": ["targetTarPlace", "targetTarString", "targetFileFile", "targetRaFile", "targetHarEntry", "targetRaMessage", "targetTransferFile", "targetFileEntry", " targetHarPath", " targetTarPlace", " targetScarFile", "argetTransferFiles", "targetTarfile", "targetTargetPath", "targetWarfile", "targetHarPlace", "argetScarPath", "targetScarU", "targetJarFile", "targetHarU", "targetTarMessage", "targetTransferFiles", "targetWarU", "targetHarfile", "argetScarFile", " targetHarPlace", "argetTransferFile", "targetScarFile", "targetJarFunction", "argetTarFunction", "targetFilefile", " targetHarEntry", "targetWarPlace", " targetScarPath", " targetHarFiles", " targetScarfile", "targetTarEntry", "targetTargetfile", "targetTarPath", "argetTarPath", " targetHarMessage", "targetScarPlace", "argetTarU", "targetWarString", " targetScarFiles", "targetHarPath", "targetRafile", " targetTarfile", " targetTarFiles", "targetWarPath", "targetWarFile", "argetTarString", "targetRaPath", "targetHarFiles", "targetJarFiles", "targetJarString", "argetTarFile", "argetTarFiles", "targetTarFunction", " targetHarfile", "targetScarPath", "targetWarFiles", "argetTransferString", "targetScarfile", " targetHarFile", "argetTransferFunction", "targetTargetPlace", "targetJarEntry", "targetTransferFunction", "targetWarFunction", "argetScarU", "targetTarU", "targetFilePath", "argetScarFiles", "targetTransferString", "targetJarfile", "targetHarFile", " targetTarMessage", " targetTarEntry", "targetHarMessage", "targetTarFiles", "targetJarPath", "targetTargetFile", " targetTarPath", "targetScarFiles"], "buffer": ["buf", "array", "writer", "resource", "image", "length", "copy", "offset", "info", "data", "Buffer", "channel", "input", "map", "key", "type", "source", "memory", "header", "buff", "queue", "position", "object", "address", "cache", "reference", "block"], "targetOutput": ["externaloutput", "TargetInput", "sourceoutput", "targetoutput", "targetInput", "tarInput", "Targetoutput", "TargetOutput", "sourceInput", "externalFile", "taroutput", "TargetFile", "sourceTar", "tarOutput", "targetTar", "externalInput", " targetoutput", "targetFile", "tarTar", "sourceOutput", "externalOutput", " targetTar", " targetFile", " targetInput"], "targetOutputTar": ["targetInputHar", "TargetoutputT", "TargetOutputFile", " targetOutputStream", "targetOutputHar", "TargetoutputDirectory", "targetoutputT", " targetInputFile", "targetOutputT", "targetoutputDirectory", "targetInputFile", "targetoutputFile", "targetInputT", " targetInputTar", "TargetoutputTar", "targetOutputFile", "targetOutputDirectory", "targetConnectionTar", "targetInputTar", "targetoutputStream", "TargetoutputFile", "targetConnectionFile", "targetInputStream", "targetConnectionStream", "targetoutputTar", "TargetOutputTar", " targetOutputHar", "targetoutputHar", "targetOutputStream", " targetInputHar", "targetInputDirectory", " targetInputStream", " targetOutputFile", "targetConnectionHar", "TargetOutputT", "TargetOutputDirectory"], "fileList": [" fileChain", "FileStream", "dirStream", "queueQueue", "fileStream", "FileQueue", "fileSt", "FileSet", "queueList", "FileList", "FileChain", "filelist", " fileSet", "dirSt", " fileQueue", "fileChain", " fileSt", "queuelist", " fileStream", "Filelist", "dirList", "dirSet", "fileQueue", "fileSet", "queueChain", "FileSt", " filelist"], "iter": ["enter", "e", "itter", "ser", "loc", "init", "info", "outer", "oper", "ner", "ipper", "inc", "ele", "loop", "it", "her", "finder", "set", "coll", "upper", "ver", "gener", "i", "reader", "dir", "li", "keep", "ter", "er", "ip", "inner", "walker", "former", "r", "over", "skip", "ir", "err", "loader", "list", "Iter", "ider", "inter", "other", "izer", "order", "ator", "ite", "cher", "ler", "chain", "iterator"], "file": ["un", "FILE", "flow", "image", "core", "parent", "letter", "profile", "data", "single", "part", "entry", "py", "class", "directory", "l", "self", "fil", "files", "place", "queue", "cache", "string", "root", "ball", "page", "pe", "uri", "resource", "e", "message", "style", "_", "connection", "remote", "info", "back", "link", "folder", "model", "zip", "index", "template", "phase", "key", "type", "live", "let", "element", "plugin", "dir", "er", "object", "local", "change", "show", "handler", "entity", "layer", "path", "format", "where", "log", "url", "play", "plain", "complete", "il", "application", "check", "route", "archive", "only", "comment", "future", "pull", "stream", "db", "binary", "File", "function", "http", "force", "use", "fp", "module", "ile", "b", "item", "flat", "project", "child", "session", "f", "document", "it", "source", "filename", "same", "base", "name", "service", "full", "get", "current", "fe", "line"], "filePathInTar": ["filepathedInHar", "filePathOutsideEar", "filepathInHar", "filePathinJar", "filePathedInTr", "filepathinTr", "filePathInHar", "fileNameInPrivate", "filePathInEar", "fileNameInTar", "filePathedInEar", "filePathINTar", "filePathedIntar", "filePathintar", "filePathOutsideJar", "filePathinHar", "filePathedInJar", "filePathInsideJar", "filePathInTr", "filePathForTar", "filePathInJar", "fileNameInEar", "filePathOutsideTar", "filePathForJar", "filePathForEar", "filepathinJar", "fileNameedInJar", "filePathINHar", "filepathedInTar", "fileNameedInPrivate", "filePathOutsidePrivate", "filePathINtar", "filepathedIntar", "filePathinTar", "fileNameInJar", "filepathInTar", "filePathIntar", "filePathinTr", "filePathForPrivate", "filePathedInPrivate", "fileNameedInTar", "fileNameedInEar", "filepathInTr", "filepathinTar", "filePathInsideTar", "filePathedInTar", "filePathInsideTr", "filepathInJar", "filePathInPrivate", "filePathedInHar", "filePathINJar", "filepathedInJar", "filepathIntar"], "tarAdd": ["drAdded", "parseCreate", "parseAdd", "catAdded", "arAdded", "aradd", "arAdd", "drEntry", "TarAdded", "drAdd", "tarCreate", "carAdd", "carAdded", " tarCreate", "catCopy", "taradd", " tarAdded", "parseEntry", "carCreate", "catAdd", "parseAdded", "carEntry", "drCreate", "tarAdded", "TarCopy", "rarCreate", "tarCopy", "Taradd", "rarEntry", "rarAdd", "TarAdd", "tarEntry", " tarEntry", "catadd", "arCopy", "rarAdded"], "in": ["at", "gen", "ins", "In", "yn", "n", "en", "thin", "an", "this", "outside", "inc", "it", "gin", "IN", "inn", "index", "d", "and", "the", "inline", "out", "s", "under", "is", "sin", "inside", "nin", "sub", "of", "inner", "inv", "internal", "id", "ass", "bin", "by", "per", "ans", "on", "from"]}}
{"id1": "19584877", "id2": "397240", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "19235551", "id2": "237493", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"handleFCLAException": [" handleFCMA1", " handleFCMAception", " handleFCMAException", " handleFCMAError", " handleFCLAError", " handleFCL1", " handlePCL1", " handleFCLception", " handlePCLAception", " handleFCLAception", " handleFCAException", " handlePCLException", " handlePCLAException", " handleFCAception", " handleFCLException", " handleFCLA1", " handlePCLAError", " handleFCLError", " handlePCLA1", " handlePCLception", " handleFCA1", " handleFCAError", " handlePCLError"], "params": ["image", "core", "rs", "data", "apps", "vs", "results", "temp", "files", "cache", "names", "models", "list", "types", "members", "server", "details", "parts", "styles", "model", "status", "result", "es", "settings", "type", "plugin", "i", "parse", "config", "eps", "video", "global", "ops", "rules", "json", "vm", "database", "css", "ls", "pins", "master", "points", "ps", "series", "pos", "spec", "site", "Parameters", "photos", "s", "api", "resources", "phys", "ams", "services", "manager", "http", "param", "res", "module", "options", "tags", "relations", "external", "plugins", "features", "posts", "source", "images", "media", "same", "base", "errors", "words", "as", "request", "changes"], "uri": ["component", "nuclear", "menu", "image", "core", "volume", "nexus", "verb", "sequence", "directory", "cli", "license", "eni", "wiki", "URI", "origin", "iri", "ini", "ui", "query", "unit", "resource", "message", "server", "remote", "version", "link", "duration", "uin", "folder", "type", "uni", "plugin", "i", "theme", "metadata", "gi", "umi", "path", "oid", "database", "prefix", "general", "io", "course", "doi", "mode", "site", "route", "archive", "tile", "future", "api", "pi", "containing", "id", "binary", "domain", "location", "picture", "transfer", "http", "force", "distance", "description", "direction", "module", "ori", "username", "title", "href", "source", "multi", "filename", "mi", "slice", "address", "detail", "service", "response", "git", "ri"], "url": ["page", "proxy", "ssl", "resource", "image", "server", "system", "loc", "link", "director", "channel", "URL", "conn", "plugin", "source", "config", "client", "li", "l", "target", "web", "base", "user", "control", "object", "id", "string", "file", "window", "sl", "layer", "path", "Url", "location", "http", "orb", "open", "browser"], "connection": ["proxy", "resource", "image", "server", "communication", "body", "io", "data", "socket", "channel", "Connection", "application", "document", "connect", "result", "ion", "conn", "connected", "i", "config", "section", "client", "db", "control", "object", "string", "character", "handler", "con", "c", "service", "relation", "context", "response", "condition", "close", "http", "open", "database"]}}
{"id1": "15580610", "id2": "13333160", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainclassify", "trainTestifier", " trainclassLoader", "trainClassLoader", "trainclassifier", "trainclassification", "trainTestification", "trainClassify", " trainClassification", "trainTestify", " trainclassifier", "trainModelification", " trainClassify", " trainClassLoader", " trainclassification", "trainTestLoader", "trainClassification", "trainModelLoader", "trainModelifier", "trainModelify", "trainclassLoader", "trainclassify"], "dir": ["fd", "doc", "direction", "url", "uri", "report", "module", "build", "loc", "DIR", "data", "project", "md", "folder", "output", "model", "group", " directory", "du", "d", "out", "wd", "home", "class", "config", "directory", "filename", "di", "target", "env", "db", "files", "base", "object", "div", "file", "window", "dist", "name", "root", "domain", "path", "cd", "Dir", "lib", "database"], "command": ["attribute", "component", "array", "power", "menu", "module", "message", "one", "image", "script", "volume", "cmd", "system", "reason", "connection", "event", "info", "project", "child", "this", "shell", "program", "usage", "sequence", "model", "document", "input", "sudo", "archive", "password", "error", "and", "move", "comment", "action", "config", "directory", "media", "cli", "delete", "slave", "which", "Command", "control", "category", "three", "string", "exec", "history", "file", "language", "machine", "name", "help", "service", "root", "pattern", "domain", "function", "path", "query", "operation", "word", "clear", "argument", "force", "request", "database"], "length": ["distance", "span", "padding", "power", "count", "style", "body", "loc", "letter", "form", "depth", "before", "last", "duration", "ph", "part", "sequence", "limit", "shape", "range", "how", "now", "creator", "zip", "sum", "end", "type", "ength", "time", "th", "class", "max", "section", "size", "width", "l", "capacity", "Length", "number", "len", "inner", "slice", "position", "id", "match", "character", "dim", "angle", "left", "full", "strength", "square", "both", "prime", "or", "word", "value", "level", "head", "join"], "process": ["component", "console", "task", "processing", "call", "parent", "script", "master", "system", "cmd", "connection", "cess", "method", "this", "project", "session", "sync", "child", "program", "display", "output", "group", "application", "status", "document", "result", "run", "pid", "out", "python", "handle", "class", "parse", "thread", "worker", "user", "exec", "file", "share", "machine", "app", "service", "host", "Process", "proc", "post", "function", "path", "plus", "use", "p", "processor"]}}
{"id1": "4501356", "id2": "932225", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"calculateProfileDiffDigest": ["calculateProfileDiffdigests", "calculateProfileDiffCodests", "calculateProfilediffdigest", "calculateProfileDiffdigr", "calculateProfileDiffdigHash", "calculateProfileDiffdigest", "calculateProfilediffdigests", "calculateProfilediffDigHash", "calculateProfileDiffCodest", "calculateProfileDiffCodHash", "calculateProfileDiffDigr", "calculateProfilediffDigr", "calculateProfilediffdigr", "calculateProfileDiffDigests", "calculateProfileDiffMDHash", "calculateProfileDiffMDr", "calculateProfilediffDigest", "calculateProfilediffdigHash", "calculateProfileDiffDigHash", "calculateProfileDiffMDest", "calculateProfileDiffCodr", "calculateProfileDiffMDests", "calculateProfilediffDigests"], "profileDiff": ["messageInfo", "summaryEdit", "settingsDiff", "settingsDelta", "profileDust", "settingsDust", " profileDie", "profileName", "imageDelta", "profdiff", "familyDiff", "summaryInfo", "messagePath", "profPath", "imageDiff", "styleInfo", "pictureInfo", "styleName", "messagediff", "pictureName", " profileInfo", "picturediff", " profileName", "settingsDie", "familyInf", "familyEdit", "profileDie", " profileDust", "profilePath", "profileInf", "stylediff", "profDiff", "familyInfo", "imageDust", " profileDelta", " profilediff", "profInfo", " profilePath", "profileInfo", "profileDelta", "pictureDiff", "imageDie", "profileEdit", "summaryInf", "summaryDiff", "styleDiff", " profileInf", " profileEdit", "profilediff", "messageDiff"], "normaliseWhitespace": ["normaliseWhitesSpace", "normaliseWhipesspace", "normaliseWhpacepace", "normaliseWhpacespaces", "normaliseWitespace", "normaliseWhipspaces", "normaliseWpacespace", "normaliseWhickspace", "normaliseWhickspaced", "normaliseWhipespaces", "normaliseWhipspace", "normaliseWitespaces", "normaliseWhpacesspace", "normaliseWhitesspace", "normaliseWpacespaced", "normaliseWhipespaced", "normaliseWhickspaces", "normaliseWpacesSpace", "normaliseWhipespace", "normaliseWhpacespace", "normaliseWpacespaces", "normaliseWhpacespaced", "normaliseWhpaceSpace", "normaliseWhitespaces", "normaliseWhitespaced", "normaliseWpacesspace", "normaliseWitesspace", "normaliseWhipsspace", "normaliseWhpacesSpace", "normaliseWhpacepaces", "normaliseWitespaced", "normaliseWitesSpace", "normaliseWhipsSpace", "normaliseWhicksspace"], "md": ["ds", "mad", "m", "rm", "hd", "sd", " MD", "Cmd", "message", "b", "mp", "sha", "cmd", "msg", "dig", "dd", "gd", "f", "hash", "editor", "mc", "mag", "d", "od", "mb", "wd", "meta", "me", "amd", "mg", "dm", "bd", "bf", "metadata", "pd", "MD", "db", "mac", "mand", "mm", "ma", "pm", "diff", "mt", "cd", "df"]}}
{"id1": "17583193", "id2": "13159394", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"populateRecord": ["populatesInstance", "popractAll", "populateInstance", "popractModel", "populatesRecord", "poputeModel", "populatesModel", "extulateModel", "poputeAll", "extractModel", "populateModel", "extractAll", "extractInstance", "populateAll", "poputeRecord", "extulateRecord", "popractInstance", "popractRecord", "extulateInstance", "poputeInstance", "populatesAll", "extulateAll", "extractRecord"], "attrIDs": ["attributeIDs", "addrID", "tagIDS", "sortID", "attENTS", "attributeIDS", "sortids", "attrIDES", "attIDS", "tagIDES", "addrENTS", "tagIDs", "addrIDS", "attIDs", "sortIDS", "sortIDES", "attributeID", "attrids", "attrIDS", "attributeENTS", "attributeIDES", "attID", "attrID", "attIDES", "addrIDs", "tagID", "attids", "attrENTS", "attributeids"], "i": ["k", "ki", "init", "in", "ni", "o", "iu", "y", "cli", "l", "a", "eni", "start", "ai", "ini", "ui", "m", "u", "uri", "z", "e", "g", "info", "si", "ie", "index", "h", "key", "is", "gi", "c", "I", "x", "qi", "ik", "length", "io", "d", "ci", "api", "ami", "pi", "ind", "id", "my", "ix", "ij", "p", "b", "n", "fi", "ori", "f", "it", "oi", "ji", "multi", "li", "di", "mi", "ip", "xi", "inner", "slice", "yi", "ti", "v", "left", "phi", "ii", "bi", "ri"], "sortIDs": ["searchIDS", "ortIDES", "useID", "allIDS", "syncIDS", "useIDs", "SortIDES", " sortIDES", "SortID", "sortID", "ortID", "orderIDES", "useIDES", "attrADS", "filterIDs", " sortIDS", "orderids", "altID", "altIDES", "syncIDES", "altIDs", "orderIDs", "sortids", "searchID", "orderID", "updateIDs", " sortids", "updateIDS", "altIDS", "useIDS", "sortIDS", "updateFiles", "sortIDES", "attrUID", "sortUID", " sortFiles", "updateIDES", "orderADS", "searchids", "ortIDs", "sortADS", " sortUID", "updateID", "allID", "filterID", "syncIDs", "attrIDS", "searchIDES", "syncID", "allIDs", " sortADS", "ortUID", "SortIDs", "allIDES", "ortIDS", "orderIDS", "orderFiles", "SortIDS", "attrID", "attrFiles", " sortID", "SortUID", "filterIDS", "filterUID", "ortids", "searchIDs", "sortFiles"], "j": ["ij", "k", "p", "js", "u", "fr", "z", "e", "b", "n", "je", "last", "ie", "part", "jc", "f", "jj", "jet", "ja", "o", "d", "dj", "job", "uj", "key", "aj", "ji", "J", "h", "jo", "pr", "y", "oj", "section", "li", "di", "l", "xi", "bj", "br", "v", "obj", "adj", "w", "left", "next", "ix", "jl", "ii", "ui", "jp", "x", "q", "qi"], "temp": ["partial", "ash", "ex", "pack", " Temp", " fake", "tc", "flat", "empty", "porary", " dummy", "Temp", "wrap", " modified", "test", "key", " unused", "max", "iter", "tmp", " original", "modified", "alt", "tr", "stable", "holder", " tmp", " test", "fake", " orig", "get", "used", "ed", "non", "orig", " temporary", "needed", "emp", "tem", " result"]}}
{"id1": "416857", "id2": "12417893", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"process": [" analyze", " finish", "report", " processing", " handle", "init", " inspect", " program", "output", "loop", "status", " display", "run", " processes", "parse", " Process", " loop", "exec", " report", " test", "Process", "proc", " analyse", " browse", " work"], "dir": ["fd", "prefix", "p", "doc", "direction", "url", "txt", " Dir", "dest", "dr", "IR", "loc", "rel", "DIR", "lock", "data", "project", "md", "folder", "pos", "zip", "str", "Directory", "d", "dat", "wd", "home", "dict", "download", "pkg", "source", "dl", "Name", "directory", "filename", "config", "work", "keep", "src", "db", "target", "base", "object", "id", "string", "ir", "file", "c", "dist", "dy", "name", "dn", "root", "File", "diff", "cd", " d", "Dir", "manager", "lib"], "list": ["parent", "null", "view", "data", "entry", "loop", "www", "set", "split", "cl", "l", "queue", "cache", "names", "string", "file", "pre", "tail", "page", "pe", "we", "e", "server", "call", "lists", "link", "group", "status", "all", "result", "input", "map", "coll", "index", "sort", "test", "live", "key", "download", "code", "see", "iter", "parse", "record", "config", "keep", "tree", "match", "show", "x", "lc", "close", "post", "ls", "log", "j", "complete", "last", "batch", "out", "pull", "print", "size", "listed", "id", "diff", "chain", "block", "open", "filter", "array", "arr", "write", "lock", "output", "LIST", "stat", "source", "header", "li", "table", "load", "v", "detail", "name", "left", "full", "get", "bl", "cont", "state", "line", "p"], "n": ["m", "fn", "ln", "z", "e", "j", "count", "b", "g", "en", "num", "none", "ot", "ns", "ner", "not", "no", "ni", "all", "sn", "nt", "d", "nc", "nl", "h", "conn", "iter", "y", "network", "nat", "size", "ne", "l", "len", "number", "node", "v", "c", "name", "t", "net", "w", "left", "adj", "x", "nb", "N", "p", "nn"], "bubblesort": ["bubbleorts", "bubbssort", "bubblehop", "bubblingorted", "grabblersort", "bubblerort", "rubblesort", "bubblesord", "grabblesorter", "ubblesort", "bubblingORT", "barblerport", "bubbesord", "bubbledhop", "rubblingorted", "rubbledsort", "bubblingport", "bubblinghop", "grabblersorter", "bubblerorts", "bubblersorted", "ubblingort", "bubbleorted", "bubblersalt", "barblesport", "barblerord", "bubblingort", "rubblesorted", "bubbsort", "bubbleort", "rubblesorts", "bubbleORT", "bubblersorter", "ubblesport", "rubblesORT", "bubbledorts", "bubblingorter", "bubbsorts", "bublessort", "bubblesport", "bubbleorter", "bubbledsort", "grabblerssort", "grabblesalt", "bubbledort", "rubblessort", "bubblersport", "bubbledorted", "rubbledorts", "bubblesalt", "bubbledORT", "bublesort", "rubbleort", "bubbesport", "bubblerport", "bubbsorted", "bubblerord", "bubblersord", "bubblessort", "bubblesorts", "ubblingport", "barblesort", "bubblesorted", "rubbledort", "ubblessort", "ubbleorted", "rubblesorter", "bubbleshop", "bublesorter", "rubbledorter", "rubbleorts", "bubblersort", "bubblingsort", "ubbleort", "bubblerorter", "ubbleshop", "bubbsorter", "ubblingsort", "rubblingorter", "bubbesort", "bubblesORT", "bublesalt", "bubblingalt", "bubbledorter", "rubbleORT", "rubblingsort", "grabblersalt", "ubblingorted", "barblerort", "ubblesorted", "ubblehop", "grabblesort", "bubblerssort", "bubblesorter", "bubblingorts", "rubblingort", "barblesord", "bubbesorter", "rubbleorted", "grabblessort", "barblesorter", "bubbledport", "barblerorter"], "i": ["image", "init", "part", "in", "field", "ni", "inst", "iu", "y", "directory", "cli", "l", "eni", "start", "sup", "ai", "ini", "ui", "chi", "m", "u", "uri", "z", "e", "g", "si", "ie", "index", "is", "hi", "gi", "c", "I", "mu", "x", "lc", "qi", "ik", "j", "anti", "io", "iv", "d", "ci", "api", "ei", "pi", "ind", "id", "uli", "ix", "next", "diff", "shift", "isin", "b", "fi", "ori", "it", "oi", "ji", "multi", "li", "di", "mi", "xi", "inner", "slice", "yi", "ti", "v", "name", "ri", "phi", "ii", "bi", "p"], "f": ["fd", "m", "fn", "fr", "e", "j", "sf", "b", "g", "fi", "fb", "folder", "fa", "d", "h", "fs", "raf", "l", "base", "fx", "fw", "r", "v", "c", "file", "obj", "w", "F", "fe", "fp", "p", "df"], "img": ["m", "jpg", "url", "image", "j", "fig", "g", "pg", "fb", "icon", "iframe", "gd", "Image", "impl", "inst", "fm", "NG", "pic", "iv", "input", "h", "tf", "inf", "ani", "ng", "images", "api", "src", "tif", "im", "bg", "l", "gif", "agi", "ff", "png", "fw", "div", "br", "v", "obj", "app", "fc", "sl", "aff", "ai", "hr", "plug", "picture", "aug", "imag", "p", " image"], "whichcase": ["existingcode", " whichmatch", "hispatch", "existingpatch", "Whichpath", "whichmatch", "Whichpatch", "WhichCase", "howpath", "whethermatch", "whosecase", " whichspace", "whoCase", "whosecode", "hiscase", "whoseCase", "existingCase", "hiscode", "Whichcode", "whetherCase", "whocase", "whosespace", " whichcode", "whatspace", " whichCase", "whosepatch", " whichpath", "Whichmatch", "whosematch", "whichpath", "whosepath", "whatCase", "whatpath", "Whichcase", "howconfig", "whoseconfig", "hisCase", "whocode", "howcase", "whichCase", "whichspace", "Whichconfig", "whatcase", "whetherpatch", "whichconfig", "whethercase", "whichcode", "existingcase", "whatcode", "whichpatch", "howCase"], "lastDigit": ["lastAddith", "lastDigits", " lastAddits", "lastPosit", " lastDigition", " lastDigbit", "lastSignith", " lastAdditon", "lastdigiton", "LastDigash", "lastCommith", "lastAdditon", "lastModits", "lastPosith", "lastDigi", "lastAddit", "lastModIT", "lastModbit", "lastSignger", " lastDigiton", "lastdigger", "lastdigith", " lastAddith", "lastMarkit", "lastDith", "lastdigit", "lastDigition", "lastCommit", " lastDigits", "lastDigiton", "lastModit", "lastdigbit", "lastdigits", "lastPosition", "lastSignbit", "lastDigbit", "lastDigIT", "lastModash", "LastDigith", "lastPosi", "lastDit", "lastDigith", "lastMarkith", "lastDigash", " lastDigi", "lastCommi", "lastDits", "LastDigIT", "lastPosbit", "lastMarkits", "lastDigger", "lastModi", "lastMarkash", "LastDigits", "lastCommition", " lastDigger", "lastSignit", " lastDigith", " lastAddit", "LastDigit", "lastDIT", "lastModith", "lastAddits"], "sorted": ["unsorter", "absorter", "insorting", "unsort", "nsaved", "Sort", "Sorting", " sorting", "nsorted", "saved", "setsorted", "sort", "insored", "setsaved", "unsorting", " sort", "setsored", "sorting", " sorter", "nsored", "Sorted", "insorted", "absorting", "sorter", "insaved", "unsorted", "absorted", "absort", "setsorting", "Sorter", "nsorting", "sored"], "temp": ["m", "z", " big", " Temp", " tem", " count", " buffer", " w", "Temp", " seq", " tail", "out", " template", "size", "tmp", "l", " result", " mem", "c", " tmp", "w", " output", " orig", " mm", "buffer", " temporary", " buf"], "tempp": ["mempar", "memporal", "prompp", "prompl", "prompar", "promporal", "timpp", "tempar", "temporal", "timporal", "timpar", "templ", "mempl", "mempp", "timpl"]}}
{"id1": "9261777", "id2": "4389475", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"source": ["sample", "prefix", "text", "proxy", "shared", "original", "url", "uri", "unit", "resource", "image", "se", "parent", "dest", "style", "view", "scope", "null", "copy", "flat", "empty", "info", "data", "options", "single", "project", "session", "in", "spec", "Source", "zip", "result", "site", "rule", "input", "strip", "index", "sort", "missing", "template", "element", "sin", "comment", "parse", "src", "config", "size", "seed", "target", "inner", "base", "slice", "id", "address", "token", "string", "ource", "file", "start", "name", "service", "sl", "SOURCE", "path", "query", "secure", "force", "use", "request"], "destination": ["distination", "destignment", "dependipping", "databaseination", " destension", "domination", " destinating", "destinate", "Destignment", "distipping", "homeinator", "destinations", "dominations", "Destinator", "dependination", "dependension", "homeignment", "domuration", "coordinator", "distinated", " destignment", "Destinate", " destinated", "databaseinations", " destinator", "destinated", "homeination", "Destination", "databaseinated", "destipping", "coordinating", "coordinate", "homeinated", "Destinating", "Desturation", "desturation", "databaseuration", "destinator", "Destinated", " destinate", "coordination", "dominated", "destension", "Destinations", "dependinated", " destipping", "distension", "destinating"], "is": ["ins", "esi", "se", "isl", "isi", "act", "obs", "ori", "io", "info", "mis", "init", "lis", "nis", "ics", "osi", "iso", "ie", "oss", "cos", "in", "zip", "bs", "es", "bis", "IS", "us", "isc", "ci", "out", "fs", "s", "iris", "ens", "ios", "i", "sin", "api", "src", "ar", "ip", "eni", "ib", "id", "iss", "ir", "ais", "ris", "ic", "Is", "sis", "ob", "ops", "ai", "get", "as", "ui", "or", "isa", "was", "ii", "abs", "close", "ois", "are", "serv", "ri"], "os": ["ls", "ros", "oa", "js", "dos", "nos", "ss", "acs", "obs", "ot", "io", "ies", "ori", "sys", "osi", "socket", "oss", "cos", "aos", "ose", "pos", "oise", "es", "so", "vs", "o", "bos", "us", "ow", "oses", "out", "s", "ens", "fs", "oS", "ios", "i", "ends", "Os", "oes", "mos", "los", "ais", "ob", "ops", "ou", "op", "ol", "as", "or", "bs", "boot", "ks", "OS", "ds"], "buffer": ["border", "wave", "buf", "page", "padding", "pad", "writer", "url", "image", "server", "copy", "b", "null", "data", "Buffer", "sequence", "limit", "channel", "result", "batch", "read", "bytes", "iter", "flush", "reader", "header", "size", "buff", "seed", "number", "base", "slice", "position", "queue", "address", "string", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "length": ["distance", "partial", "of", "url", "power", "count", "ring", "quote", "offset", "style", "volume", "lock", "data", "depth", "weight", "last", "duration", "part", "sequence", "limit", "shape", "range", "index", "split", "strip", "end", "key", "type", "row", "code", "division", "total", "reader", "section", "size", "width", "l", "len", "Length", "number", "point", "slice", "position", "object", "id", "address", "lower", "string", "character", "match", "load", "start", "age", "ob", "left", "full", "get", "value", "level", "line", "feed", "block"]}}
{"id1": "20100809", "id2": "23370621", "code1": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "write", " cp", "cp", "remote", "ge", "sync", "part", "py", "zip", "map", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "Copy", "create", "delete", "dump", "change", "load", "patch", "share", "get", "transfer", "update", "opy", "cop"], "srcPath": ["rubyPath", "destFile", "rubyHalf", "sourcepath", "rcDir", "srcDir", "rubypath", "destPath", " srcRoot", "sourceRoot", "destDir", "sourceFile", "srcpath", "rubyRoot", "rcHalf", " srcDir", "srcHalf", "rcpath", "srcName", "rcRoot", " srcHalf", "rcName", " srcpath", "srcFile", "sourcePath", "sourceName", "rcFile", " srcName", " srcFile", "srcRoot", "sourceDir", "destpath", "rcPath"], "dstPath": ["drcPATH", "dtdpath", "drdpath", "drcPath", "dstsLocation", "fstpath", "dndName", "DrcPath", "drcDirectory", "sdostPath", "dstDirectory", "fftName", "drestPath", "dndUrl", "dstName", " dspHome", "drestpath", "dftPath", " dstFile", "dstFile", "drcDir", "ddestpath", "dstLocation", "dstsRoot", "drcpath", "sdstDirectory", "Drcpath", "dftName", "drcUrl", "ddestLocation", "drcHome", "DrcDir", "dstsName", "fftPath", "dndFile", "drcRoot", "dftpath", "sdostDirectory", "dsppath", "drdPath", "fftpath", "sdstPath", "dostHome", " dsppath", "dstHome", "dtdPATH", "fstPath", "dstUrl", "DrcFile", "dstDir", "dspHome", "dostDirectory", " drcPATH", " dstHome", "dstsPath", "ddestDir", "ddestPath", "drdUrl", "dostRoot", "DrcLocation", "dstsDirectory", " dstpath", "sdostRoot", "dstsFile", "dstsDir", " dstPATH", "DstPath", "dspFile", " drcpath", "DstDir", "dostpath", "fftFile", "DstFile", "DstUrl", "dndpath", "dspPath", "dftFile", "dostPATH", "drcFile", "sdstRoot", "dtdPath", " dspPath", "drestFile", "drdFile", "dstRoot", " drcPath", "fstFile", "dostPath", "dstpath", "DrcUrl", "drestHome", "sdostpath", "drcLocation", "Dstpath", " dspFile", "dtdHome", "dstspath", " drcHome", "dstPATH", "fstName", "DstLocation", "dndPath", "sdstpath"], "result": ["replace", "res", "arr", "report", "dest", "master", "ok", "reason", "rc", "form", "event", "rh", "successful", "here", "df", "rar", "mate", "inc", "func", "member", "status", "rule", "acc", "valid", "attr", "val", "pass", "results", "comment", "ack", "true", "rr", "Result", "sign", "feature", "make", "found", "match", "ure", "err", "card", "success", "start", "particip", "force"], "files": ["ls", "fields", "keys", "sheets", "ins", "books", "users", "data", "assets", "f", "sections", "plugins", "apps", "features", "classes", "lines", "bytes", "balls", "fs", "ips", "objects", "tools", "images", "filename", "resources", "pages", "names", "models", "cells", "blocks", "Files", "boxes", "events", "strings", "items"], "file": ["page", "pe", "uri", "url", "unit", "e", "ile", "le", "resource", "b", "view", "letter", "info", "data", "child", "part", "folder", "entry", "f", "it", "rule", "input", "route", "feed", "key", "el", "source", "filename", "l", "work", "use", "queue", "object", "id", "string", "load", "name", "per", "File", "path", "current", "content", "fe", "line", "fp"], "in": ["into", "m", "ins", "url", "image", "server", "call", "In", "b", "view", "n", "connection", "thin", "init", "info", "sync", "inc", "socket", "part", "f", "gin", "input", "din", "IN", "inn", "index", "s", "conn", "pass", "cin", "i", "source", "win", "rin", "reader", "pull", "client", "inside", "a", "l", "nin", "login", "work", "inner", "min", "r", "id", "token", "ac", "con", "c", "bin", "err", "name", "re", "by", "up", "lib", "diff", "pin", "get", "path", "as", "ini", "again", "on", "p", "serv"], "out": ["to", "ex", "writer", "url", "flow", "write", "image", "server", "plain", "b", "n", "connection", "io", "off", "outer", "sync", "socket", "inc", "part", "channel", "output", "no", "group", "gin", "cookie", "exp", "o", "ch", "Out", "key", "conn", "home", "i", "with", "client", "inner", "base", "outs", "point", "cache", "bin", "err", "name", "other", "by", "up", "net", "ou", "OUT", "w", "extra", "pool", "word", "plus", "again", "manager", "serv", "lib", "ext"], "size": ["ize", "pack", "unit", "write", "length", "count", "speed", "offset", "loc", "en", "empty", "data", "weight", "si", "scale", "shape", "now", "mode", "SIZE", "sum", "sec", "seek", "small", "bytes", "end", "type", "code", "time", "i", "flush", "eng", "width", "ice", "sized", "len", "capacity", "number", "send", "id", "address", "Size", "age", "name", "order", "path", "clear", "transfer", "content", "iz", "close", "enc", "shift", "export", "open"], "buf": ["cap", "cv", "uf", "seq", "uc", "b", "cmp", "rc", "fb", "data", "av", "Buffer", "bc", "map", "bag", "coll", "rb", "batch", "BU", "bytes", "job", "cb", "cas", "bf", "abi", "pkg", "bd", "buff", "ff", "r", "ba", "br", "bin", "la", "vec", "ha", "cf", "buffer", "box", "line", "feat"]}}
{"id1": "18339787", "id2": "5998352", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"reload": ["overload", "reloading", "preload", "refload", "reffill", "preloading", "prefill", "overresh", "overloading", "refresh", "preresh", "refloading", "reresh", "overfill", "refill"], "currentDate": ["currentDay", " currentTime", "newUpdate", " currentDay", "reportedTime", "currentUpdate", "newDay", "CurrentTime", " currentName", "newDate", "currentName", " currentUpdate", "reportedDate", "currentKey", "newKey", "CurrentKey", "CurrentDate", "CurrentDay", "reportedName", "CurrentUpdate", " currentKey", "currentTime", "reportedDay", "CurrentName"], "xpath": ["exPath", " xparent", " xstream", "Xath", "lexstream", "expath", "axpath", " xPath", "XPath", " xcase", "Xp", "lexparent", "xPath", "lexpath", "xcase", "axath", "xstream", "exp", "Xstream", "txstream", " xath", "Xcase", "xp", "xparent", "xprop", "lexPath", "Xpath", "exstream", "txpath", " xp", "exparent", " xprop", "Xprop", "xath", "axPath", "exprop", "exath", "txPath", "axcase"], "docBuilderFactory": ["docbuilderFactor", "projectBuilder2", "projectBuilderInterface", "projectBuilderFactory", "docBuilderFactor", "docManagerInterface", "docBuildService", "documentBuildService", "docbuilderFactory", "docManagerFactory", "docBuilderF", "docBuilderInterface", "docBuilder2", "projectbuilder2", "docbuilderService", "projectbuilderInterface", "documentBuilderF", "projectbuilderFactor", "docBuild2", "docBuildFactory", "projectBuilderFactor", "documentBuilderService", "docManager2", "docBuildFactor", "docbuilder2", "docBuildF", "docBuilderService", "docbuilderInterface", "documentBuilderFactory", "projectbuilderFactory", "documentBuildF", "documentBuildFactory", "docManagerFactor", "docbuilderF", "docBuildInterface"], "docBuilder": ["docFactory", "documentFactory", "fileBook", "documentParser", "documentBuilder", "xmlParser", "documentBuild", "documentbuilder", "docParser", "Docbuilder", "documentBook", " docBuild", "docbuilder", "fileBuilder", " docBook", " docFactory", "DocParser", "xmlbuilder", "docBook", "fileFactory", "DocBuild", "xmlBuilder", "DocBuilder", "fileBuild", "docBuild", "xmlBuild"], "conn": ["conv", "log", "ssl", "ct", "cn", "server", "uc", "conf", "cp", "connection", "loc", "lock", "body", "cmd", "session", "socket", "channel", "Connection", "connect", "URL", "nt", "coll", "ch", "nc", "ci", "cb", "out", "Conn", "cm", "api", "config", "client", "cli", "l", "db", "ann", "exec", "con", "c", "loader", "ctx", "path", "Url", "lc", "enc", "http", "serv"], "url": ["ls", "log", "ssl", "uri", "ll", "resource", "server", "fr", "image", "build", "connection", "org", "data", "blog", "channel", "f", "impl", "www", "URL", "str", "coll", "bel", "download", "config", "client", "l", "web", "db", "base", "string", "gl", "file", "err", "loader", "ob", "sl", "host", "path", "Url", "http", "feed", "serv"], "xml": ["page", "doc", "rss", "log", "writer", "arr", "txt", "image", "wt", "html", "example", "event", "apache", "data", "model", "document", "zip", "input", "graph", "date", "children", "el", "element", "temp", "wl", "parse", "config", "reader", "atom", "stream", "tree", "node", "email", "layout", "address", "file", "ml", "root", "php", "context", "json", "path", "response", "x", "content", "office", "events", "update", "dom", "http", "feed", "request"], "exchangeRateDate": ["expirePricePrice", "exchangeRateFile", "excurrencyRateDuration", "exchangeRateTime", "exchangeRatingPrice", "exchangeWeightPrice", "exchangeFactorTime", "expireRateDate", "exchangeTimeFile", "excurrencyRateFile", "exchangePricePrice", "exchangePriceKey", "exchangePriceDate", "exchangeRateDuration", "exchangeWeightDate", "exchangeRatingFormat", "exchangeRatingDate", "expirePriceFormat", "exchangePriceFormat", "excurrencyRateTime", "exchangeTimeDate", "exchangeRatingKey", "exchangeTimeDuration", "expirePriceDate", "excurrencyTimeDate", "exchangeTimeTime", "excurrencyTimeDuration", "expireRateKey", "expirePriceKey", "exchangeRateKey", "exchangeWeightKey", "exchangeRateFormat", "excurrencyTimeFile", "excurrencyTimeTime", "expireRatePrice", "expireRateFormat", "exchangeWeightFormat", "exchangeFactorFile", "excurrencyRateDate", "exchangeFactorDate", "exchangeFactorDuration", "exchangeRatePrice"], "currenciesNode": ["curcurrencyPath", "currenciesBlock", "curcurrencyNode", "contractrenciesDocument", "curportsNode", "courrenciesnode", "curatorsNode", "comrenciesNode", "comrenciesPath", "currenciesPath", "cururrenciesnode", "currenciesRoot", "curatorsArray", "courrenciesContainer", "contracturrenciesBlock", "cururrenciesContainer", "comportsBlock", "curportsPath", "currenciesnode", "contracturrenciesRoot", "comportsPath", "contracturrenciesNode", "currenciesArray", "cururrenciesBlock", "corenciesNode", "curitiesnode", "curatorsnode", "currenciesContainer", "curlationsElement", "curriesRoot", "curlationsBlock", "contractrenciesNode", "contracturrenciesDocument", "curitiesArray", "curportsElement", "currenciesElement", "curportsBlock", "corenciesnode", "curitiesContainer", "courrenciesNode", "cururrenciesArray", "curcurrencyBlock", "curatorsContainer", "curitiesNode", "curlationsPath", "curratesRoot", "curriesNode", "curratesDocument", "currenciesDocument", "contractrenciesBlock", "comrenciesElement", "curriesDocument", "corenciesArray", "cururrenciesDocument", "cururrenciesRoot", "comportsElement", "comportsNode", "curriesBlock", "comrenciesBlock", "contractrenciesRoot", "curlationsNode", "corenciesContainer", "courrenciesArray", "curcurrencyElement", "curratesNode", "curratesBlock", "cururrenciesNode"], "currencies": ["locales", "chcoins", "curacters", "charrencies", "scherency", "urversions", "urums", "curums", " currency", " curversions", "churrency", "peracters", " curacters", " curums", "cururrency", "curversions", "scherencies", "curales", "curcoins", "locurrency", "cururrencies", "charrency", "perversions", "carrencies", "uracters", "carcoins", "perrencies", " curries", "chales", "chrencies", "scheurrencies", "perums", "loccoins", "carurrency", "scheries", "urrencies", " cururrencies", "charurrencies", "carales", "charries", "locrencies", "curries", "currency"], "i": ["m", "u", "z", "uri", "e", "j", "b", "g", "n", "fi", "io", "info", "si", "in", "f", "it", "o", "index", "ci", "iu", "oi", "ji", "end", "abi", "multi", "y", "li", "di", "l", "ip", "pi", "xi", "hi", "eni", "slice", "r", "yi", "id", "ti", "v", "gi", "c", "start", "t", "ri", "I", "ai", "phi", "chi", "ii", "ui", "x", "mu", "qi", "bi", "lc", "q", "p"]}}
{"id1": "22366505", "id2": "4481712", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"incluir": ["inclurear", "inclituiro", "incluiro", "inCLuire", "inCLUir", "inclUear", "inCLuiro", "inclurir", "inclituear", "inCLuear", "inCLUire", "inclituir", "inclurire", "incluriro", "incluear", "inCLUear", "inCLuir", "incluire", "inclUir", "inclUire", "inclituire", "inCLUiro", "inclUiro"], "igreja": ["igr\u00e9jas", "igreji", "igereji", "igruza", "iggrej", "igruya", "ligr\u00e9j", "igreraya", " igreji", "ligr\u00e9ja", " igreya", "ligreje", " igreraya", "igrej", "igruj", "igreraji", " igreraza", " iggreJa", "igruje", " igreraja", "igruji", "igreya", "igreraza", "iggrejas", "ligreja", "igcreJa", " igrej", "ligr\u00e9jas", "igr\u00e9ja", "ligr\u00e9je", "igcreji", "igruja", "igreraja", "igereJa", "iggreji", " igreza", "igreJa", " iggreja", " iggrej", "igreje", "ligrej", "igr\u00e9j", "igerej", "iggreJa", "igrujas", "iggreza", "ligrejas", "igrejas", "igreza", " iggreji", "iggreja", "iggreya", " igreraji", "igcrej", " igreJa", "igr\u00e9je", "igcreja", "igereja", "iggreje"], "connection": ["description", "statement", "server", "core", "communication", "system", "loc", "lock", "event", "session", "engine", "socket", "bc", "Connection", "application", "document", "connect", "ion", "index", "graph", "error", "union", "conn", "connected", "cc", "config", "section", "directory", "client", "BC", "db", "table", "position", "cache", "con", "c", "machine", "option", "relation", "ctx", "environment", "context", "cf", "function", "condition", "pool", " Connection", "query", "collection", "manager", "database"], "sql": ["ls", "sol", "fn", "statement", "log", "ln", "url", "ssl", "null", "term", "SQL", "sys", "session", "sync", "csv", "socket", "sb", "spec", "stat", "nl", "s", "conn", "sq", "dl", "section", "filename", "seed", "db", "eps", "id", "string", "params", "select", "printf", "sl", "function", "query", "setup", "seq", "database", "ql", "join"], "sql2": ["ssl2", "ql02", "ssl02", "url1", "sslII", "ql2", "ql1", "ssl1", " sql1", "sql02", "sqlII", " sql02", "sql1", " sqltwo", "qltwo", "url2", "sqltwo", " sqlII", "qlII", "urltwo"], "stmt": ["frmn", "sth", "ostmr", "stmr", "fh", "Stm", "tmr", " stm", "stdb", " sttr", "fmt", "frconn", "frmt", "istmt", "STmd", " stst", "tpt", "Stmb", " stmn", " sth", "tm", "stmb", "strmt", "strmd", "STmt", " stdb", "istmn", "stmd", "Stpt", "stpt", " stpt", "STst", "ostmt", "stst", "tmt", "Stmn", "ostmn", "frtr", " stmb", "STmb", "ostmd", "istconn", "Stql", "stql", "ostql", " stmd", "Stst", "stmn", "Stmd", "Stmt", " stconn", "sttr", "Stmr", "fmd", "stconn", "strh", "fdb", " stql", "strdb", "stm", "isttr", " stmr"], "stmt2": [" stmt4", " stmp4", "stmd1", "stm4", "ctmt2", "stmdTwo", "stmt3", "stmt4", "stmp2", " stmt1", "stbmTwo", " stmrTwo", "stmn4", "stmp3", " stmp1", "stmr1", "stmp1", "stmtTwo", " stmp3", "stmpTwo", " stmr1", "stm1", "stmp4", " stmt3", "stmn2", " stmpTwo", "stmr3", "stmr4", "stbm2", "stmt02", "stmr02", " stmtTwo", "stmn1", " stmr02", " stmt02", "stm2", " stmp2", "stbm1", "ctmp2", "ctmpTwo", "stmp02", "stmd3", "stmd4", "ctmp1", "stmnTwo", "ctmt1", "stmd2", "stmr2", "stmrTwo", "stmt1", "ctmtTwo", " stmr2", "stbm02"], "rs": ["ls", "ros", "res", "rss", "ins", "rows", "details", "ss", "mr", "rc", "ps", "relations", "hs", "ows", "rys", "ys", "ms", "s", "RS", "Rs", "conn", "results", "row", "pr", "rr", "qs", "ras", "r", "ars", "ris", "eers", "errors", "rates", "xs", "params", "rd", "sr", "ts", "gs", "cs", "cr", "ks", "runs", "ds", "vers"], "retorno": ["retago", "resporn", "ntour", "ntro", "respago", " retago", "retorn", "Retour", "resporno", " retro", "ntorn", "retro", "retour", "Retorno", "respro", "Retro", " retour", "ntorno", " retorn", "Retorn", "Retago"]}}
{"id1": "13086936", "id2": "4461350", "code1": "            public void run() {\n                waiting(200);\n                txtinfo.post(new Runnable() {\n\n                    public void run() {\n                        txtinfo.setText(\"Searching\");\n                    }\n                });\n                try {\n                    URL url = new URL(urlAddress);\n                    SAXParserFactory spf = SAXParserFactory.newInstance();\n                    SAXParser sp = spf.newSAXParser();\n                    XMLReader xr = sp.getXMLReader();\n                    XMLHandlerReviews myXMLHandler = new XMLHandlerReviews();\n                    xr.setContentHandler(myXMLHandler);\n                    xr.parse(new InputSource(url.openStream()));\n                    if (statuscode != 200 && statuscode != 206) {\n                        throw new Exception();\n                    }\n                    nReviewsOnPage = myXMLHandler.nItems;\n                    statuscode = myXMLHandler.statuscode;\n                    if (nReviewsOnPage > 0) {\n                        authors = new String[nReviewsOnPage];\n                        reviews = new String[nReviewsOnPage];\n                        ratings = new String[nReviewsOnPage];\n                        titles = new String[nReviewsOnPage];\n                        listtext = new String[nReviewsOnPage];\n                        for (int i = 0; i < nReviewsOnPage; i++) {\n                            reviews[i] = myXMLHandler.reviews[i];\n                            authors[i] = myXMLHandler.authors[i];\n                            titles[i] = myXMLHandler.titles[i];\n                            ratings[i] = myXMLHandler.ratings[i];\n                            if (authors[i] == null || authors[i] == \"\") {\n                                authors[i] = \"Anonymous\";\n                            }\n                            if (ratings[i] == null || ratings[i] == \"\") {\n                                listtext[i] = titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            } else {\n                                listtext[i] = \"Score: \" + ratings[i] + \" - \" + titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            }\n                        }\n                        nTotalReviews = myXMLHandler.nTotalItems;\n                        final int fnmin = iFirstReviewOnPage;\n                        final int fnmax = iFirstReviewOnPage + nReviewsOnPage - 1;\n                        final int fntotalitems = nTotalReviews;\n                        if (nTotalReviews > fnmax) {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(0);\n                                }\n                            });\n                        } else {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(8);\n                                }\n                            });\n                        }\n                        if (iFirstReviewOnPage > 1) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(0);\n                                }\n                            });\n                        } else if (nTotalReviews > fnmax) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(8);\n                                }\n                            });\n                        } else {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(4);\n                                }\n                            });\n                        }\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                if (title != null && title != \"\") {\n                                    txtinfo.setText(title + \"\\n\" + getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                } else {\n                                    txtinfo.setText(getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                }\n                            }\n                        });\n                        handlerSetList.sendEmptyMessage(0);\n                    } else {\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                txtinfo.setText(title + getString(R.string.no_reviews_for_this_album));\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    final Exception ef = e;\n                    txtinfo.post(new Runnable() {\n\n                        public void run() {\n                            txtinfo.setText(R.string.search_failed);\n                        }\n                    });\n                }\n                dialog.dismiss();\n                handlerDoneLoading.sendEmptyMessage(0);\n            }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"run": ["un", "running", "unit", "background", "call", "apply", "build", "Run", "func", "in", "output", "loop", "su", "job", "man", "graph", "container", "pass", "process", "thread", "work", "worker", "fun", "login", "base", "exec", "submit", "start", "name", "runner", "execute", "use", "runs"], "url": ["page", "uri", "ssl", "resource", "ll", "server", "image", "html", "b", "connection", "io", "org", "this", "channel", "f", "www", "URL", "source", "api", "src", "l", "stream", "base", "user", "r", "address", "string", "file", "service", "sr", "sl", "left", "path", "Url", "location", "buffer", "http", "open"], "spf": ["spfs", "pF", "pfs", "Spfd", "skf", " spfen", "scfs", "scF", "spF", "skfen", "scf", "ppf", "pfd", "ppfen", "ppfx", "pf", " spfx", "spfen", "Spfs", "SpF", "skfs", "spfx", " spfs", "Spf", "spfd", "skfx", "ppfs", "scfd"], "sp": ["lp", "ssl", "se", "sf", "html", "g", "scope", "st", "server", "par", "pg", "sv", "esp", "asp", "si", "steam", "parser", "sb", "py", "f", "so", "xml", "pr", "source", "parse", "wp", "Sp", "er", "sc", "SP", "sa", "sm", "service", "sr", "sl", "sh", "pp", "http", "sw", "p", "space", "serv"], "xr": ["xR", "swhr", "byr", " xhr", "txrb", "rxrr", "swrs", "xer", "txr", "txer", "txhr", "swr", "txrs", "byR", "rxR", "xrs", " xrb", "Xrs", "txR", "xhr", "rxr", "XR", " xer", "byrb", "swrb", " xrs", "xrb", "rxrb", "xrr", " xrr", "byrr", "Xer", " xR", "Xr"], "myXMLHandler": ["myYSLContext", "myXRLEvent", "myFXMLPath", "myXELHandler", "myXMLManager", "myXLSParser", "myXMLConfig", "myXSLHandler", "myXMLContext", "myFXMLReader", "myWorkMLPath", "myFXMLParser", "myXELReader", "myYMLParser", "myTXELParser", "myXmlManager", "myXLSLParser", "myYSLParser", "myTXmlHandler", "myXLSReader", "myXELManager", "myXSLManager", "myFXmlManager", "myXMLInfo", "myFXmlReader", "myXMLPath", "myYSLService", "myXRLHandler", "myYMLReader", "myXSLConfig", "myXPCReader", "myYMLService", "myXSLInfo", "myWorkMLReader", "myXmlParser", "myXLMLReader", "myXCLParser", "myXMLParser", "myXPCService", "myWorkmlParser", "myTXMLParser", "myTXmlEvent", "myXCLConfig", "myXCLService", "myXSLParser", "myTXMLReader", "myYSLReader", "myFXMLHandler", "myXCLContext", "myXmlInfo", "myXLSLPath", "myTXmlReader", "myXMLService", "myYSLConfig", "myXmlConfig", "myTXMLHandler", "myWorkmlHandler", "myXELEvent", "myXRLPath", "myTXMLEvent", "myXCLReader", "myXSLService", "myXCLHandler", "myFXmlHandler", "myXSLPath", "myXRLParser", "myXMLEvent", "myXRLInfo", "myTXELReader", "myXCLManager", "myYMLHandler", "myXPCHandler", "myXLSLReader", "myXSLContext", "myXLSHandler", "myXCLPath", "myXELPath", "myXLMLPath", "myTXmlInfo", "myXPCContext", "myFXmlParser", "myTXELEvent", "myYMLContext", "myWorkmlPath", "myXLSEvent", "myTXMLInfo", "myFXMLManager", "myWorkMLHandler", "myXmlContext", "myXmlHandler", "myYMLConfig", "myFXmlPath", "myXmlEvent", "myXLMLHandler", "myWorkmlReader", "myXSLEvent", "myXSLReader", "myWorkMLParser", "myXRLContext", "myXLMLParser", "myXLSLHandler", "myXMLReader", "myYSLHandler", "myXmlPath", "myXELParser", "myXRLReader", "myTXELHandler", "myXmlReader"], "nReviewsOnPage": ["nReviewesOnpage", "nReviewingsONRequest", "nReviewmentsPerpage", "nReviewsThisFile", "nReviewsONpage", "nReviewesPerPage", "nReviewsForFile", "nReviewesPerPages", "nReviewesCurrentLine", "nReviewsOffLine", "nReviewsonpage", "nReviewsONPages", "nReviewsOnFile", "nReviewsThisLine", "nReviewsOffpage", "nReviewsonPage", "nReviewingsPerpage", "nReviewsCurrentLine", "nReviewingsONLine", "nReviewsOffPage", "nReviewsInpage", "nReviewmentsOnPage", "nReviewesOnPages", "nReviewsCurrentPage", "nReviewesCurrentFile", "nReviewsOffPages", "nReviewsPerSection", "nReviewsForpage", "nReviewsOnSection", "nReviewsOnPages", "nReviewingsONPage", "nReviewsPerPage", "nReviewingsOnSection", "nReviewsOnlinePage", "nReviewsOnlineRequest", "nReviewsOnlinepage", "nReviewesCurrentPage", "nReviewingsOnLine", "nReviewsPerRequest", "nReviewmentsPerPage", "nReviewmentsOnpage", "nReviewsPerDisk", "nReviewsPerPages", "nReviewingsPerSection", "nReviewesPerpage", "nReviewsonFile", "nReviewsOnpage", "nReviewsOnDisk", "nReviewingsPerFile", "nReviewmentsPerLine", "nReviewsOnlineLine", "nReviewsInSection", "nReviewsONPage", "nReviewingsOnFile", "nReviewsPerLine", "nReviewsONRequest", "nReviewsThisPage", "nReviewsCurrentFile", "nReviewesOnPage", "nReviewsForLine", "nReviewsonLine", "nReviewsInDisk", "nReviewesCurrentpage", "nReviewmentsOnLine", "nReviewingsOnRequest", "nReviewsInLine", "nReviewsForPage", "nReviewingsOnpage", "nReviewingsPerPage", "nReviewsDuringDisk", "nReviewsThisSection", "nReviewesOnFile", "nReviewsDuringLine", "nReviewsCurrentpage", "nReviewsInPage", "nReviewsDuringpage", "nReviewsonPages", "nReviewingsPerLine", "nReviewsONLine", "nReviewsOnRequest", "nReviewmentsPerDisk", "nReviewsDuringPage", "nReviewingsONpage", "nReviewingsOnPage", "nReviewsPerpage", "nReviewesOnLine", "nReviewsInFile", "nReviewesPerLine", "nReviewsOnLine", "nReviewsPerFile", "nReviewmentsOnDisk"], "statuscode": ["postcodes", " statuscodes", " statusCode", "statcodes", "statuscodes", "levelcodes", "zipCode", "levelstate", "msgcount", "zipstatus", "statstate", "resultcodes", " statusmessage", "zipcode", "statuscase", "postcode", "statusCode", "Statusstate", " statuscase", "msgmessage", "msgcode", "levelcase", "statcode", "postCode", "statuscount", "statusstatus", "poststatus", " statusstatus", "statusstate", "Statuscodes", "Statuscount", "statusmessage", "Statuscode", "msgcodes", "levelcode", "statcase", "resultcode", " statusstate", "resultmessage", "resultcount", "msgstate", "zipcodes", "resultstate"], "authors": ["workers", "papers", "artifacts", "weights", "abet", "marks", "archives", "people", "ins", "owners", "letters", "books", "apters", "users", "apers", "ppers", "tags", "relations", "archs", "casters", "reports", "headers", "testers", "styles", "quarters", "agents", "apps", "sections", "plugins", "reads", "parents", "features", "comments", "projects", "itles", "attacks", "settings", "docs", "journal", "posts", "thumbnails", "rators", "images", "anners", "pages", "resources", "versions", "names", "articles", "errors", "abilities", "blogs", "rights", "atts", "rules", "builders", "blocks", "criptions", "writers", "humans", "runners", "yrs", "words", "masters", "members", "author", "verbs", "services", "includes", "strings", "ants", "ors"], "reviews": ["reviewins", " reviewp", "downloads", "reviewments", "reviewp", "reviewions", "reviewers", "feeds", " reviewings", "Reviewions", "feedations", "reviewings", "signings", "reviewations", "signs", "followings", "Reviews", "Reviewp", "authorins", "follows", "reviewes", "downloading", "authores", "Reviewments", " reviewments", "authoring", "Reviewes", "sellers", "following", "Reviewers", "followes", "reviewing", "feedings", "sellings", "signins", "sellions", "authorp", "Reviewings", "authorments", "downloadments", "Reviewing", "authorings", "authorions", "sells", "signations", "authorers", "feedins", "downloadings", "authorations"], "ratings": ["ritins", "raties", "roundings", "ratins", "variions", "latensions", "ritings", "trios", "ratitles", "prings", "prensions", "latings", " ratning", "latitles", "ratensions", " ratensions", "roundensions", "trings", "statitles", "pititles", "roundations", "variings", "tins", "latations", "tacters", "ratickets", "authorins", "ratations", "rations", "ratning", "rities", " ratickets", "practers", "authorifications", "statios", "ties", "statings", "statickets", "statning", " ratitles", "ritions", "pritles", "tings", "rounditles", " ratios", "statages", "ratifications", "tions", "ratages", "pitings", "trages", " ratacters", "ratios", "tensions", "variitles", "statifications", "authories", "statensions", "statations", "authorings", "authorning", "authorions", "pitations", "tations", "variations", "authorages", "trickets", "ratacters", " ratages", " ratifications", "pitions"], "titles": ["ttickets", "litles", "tickets", "ratitles", "sitles", " tames", "untls", "Titles", " tales", "tticks", "ttributes", " thips", "ratames", "lickets", " tributes", "tales", " tapes", "tacters", " ticks", "lapes", " tickets", "sapes", "ttls", "lributes", "untitles", "untickets", "sasks", "thips", "Tacters", " tings", "tapes", "untings", "Tames", "tings", "tributes", "ttitles", "lractions", "Tings", "tapers", "lhips", " tacters", "ttales", "ratapers", " tasks", "tames", "ttractions", " tls", "ships", "ticks", "tls", "tasks", "tractions", " tractions", "Ticks", "lasks", "Tapers", "Tales", "ratacters", " tapers", "ttings"], "listtext": ["LISTTEXT", "listobject", "testobject", "summaryname", "listtxt", "summarytext", " listobject", "detailtext", " listtxt", " liststr", "flattxt", "listbody", "testbody", "liststr", "listTEXT", "testtext", "flattext", "summaryTEXT", "teststr", "summaryText", "flatText", "flatTEXT", " listTEXT", " listText", "listname", "detailstr", "summaryformat", "listText", "detailobject", " listbody", "LISTtext", " listformat", "LISTname", "detailbody", "summarytxt", "listformat", " listname", "LISTformat"], "i": ["m", "p", "u", "uri", "z", "e", "j", "isi", "b", "g", "fi", "ki", "init", "ori", "io", "info", "si", "ie", "it", "ni", "f", "iv", "o", "index", "ci", "iu", "oi", "ji", "s", "abi", "uni", "is", "multi", "y", "api", "li", "di", "cli", "mi", "ip", "pi", "xi", "hi", "ei", "eni", "vi", "yi", "id", "uli", "ti", "gi", "v", "ic", "sup", "l", "ix", "I", "phi", "ri", "ai", "chi", "ii", "ui", "bi", "ini", "lc", "current", "x", "qi"], "nTotalReviews": ["nTotalDownloades", "nTotalDownloads", "nAllReviewEvents", "nTotalGraphes", "nTotalGraphs", "nTotalDownloadEvents", "nAllReviewed", "nTotalreviewes", "nTotalreviewEvents", "nAllreviewes", "nTotalReviewEvents", "nAllreviews", "nAllreviewEvents", "nAllReviewes", "nTotalReviewed", "nTotalGraphed", "nTotalReviewes", "nTotalDownloaded", "nAllreviewed", "nTotalreviews", "nTotalreviewed", "nAllReviews", "nTotalGraphEvents"], "fnmin": [" fmin", " fstart", " fndiff", " nmin", "fndiff", " nall", " nstart", "fnall", "fnstart", " fdiff", " fnall", " ndiff", " fall", " fnstart"]}}
{"id1": "16760971", "id2": "16556717", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"generateHash": ["generoseMac", "generateKey", "generatesKey", " GenerateHash", " GeneratedHash", "generatedHash", " GenerateSalt", "generoseHash", "generatedSalt", " GeneratedMac", " GenerateKey", "generoseSalt", "generatesSalt", "generatedKey", "generatesHash", " GeneratedSalt", "generatesMac", "generoseKey", " GeneratedKey", " GenerateMac", "generatedMac", "generateMac", "generateSalt"], "key": ["k", "crypt", "prefix", "text", "pe", "keys", "url", "message", "cert", "body", "connection", "Key", "ce", "data", "msg", "char", "rule", "hash", "str", "block", "hex", "ace", "password", "date", "type", "proof", "code", "trust", "pair", "seed", "work", "self", "point", "base", "mac", "sign", "user", "id", "address", "token", "string", "fee", "file", "name", "full", "path", "word", "cy", "secret", "KEY"], "md": ["mad", "m", "wd", "rm", "hd", " MD", "Cmd", "message", " Md", "nd", "mp", "dr", "cmd", "df", "mo", "dig", "dd", "rpm", "hash", "editor", "mc", "mag", "d", "od", "mage", "ms", "me", "nm", "hm", "mb", "amd", "mg", "dm", "bd", "metadata", "cm", "bm", "pd", "MD", "di", "ad", "mac", "mand", "po", "mm", "sm", "ma", "dc", "mem", "am", "ld", "pm", "mt", "cd", "clean", "mail", "mod", "dh", "ds"], "bytes": ["ls", "values", "keys", "pins", "rows", "Bytes", "items", "b", "letters", "os", "fb", "data", "parts", "ones", "zip", "es", "vs", "bis", "lines", "ips", "s", "bles", "objects", "seconds", "vals", "les", "pieces", "pages", "files", "outs", "bits", "errors", "codes", "gb", "cells", "binary", "ops", "blocks", "words", " bits", "strings", "bs", "boot", "bps"], "buff": ["buf", "kb", "uf", "txt", "append", "hack", "html", "b", "cp", "eb", "flat", "fb", "ph", "Buffer", "sb", "f", "py", "agg", "tt", "pb", "cpp", "bis", "bag", "batch", "mb", "cb", "Buff", "bo", "tf", "bf", "uff", "bd", "bm", "tmp", "ff", "fx", "fw", "abb", "amp", "gb", "app", "ob", "cast", "obb", "ctx", "diff", "bug", "buffer", "nb", "pp", "bb"], "l": ["ls", " L", "u", "ln", "fl", "z", "lp", "ll", "e", "j", "col", "length", "ell", "b", "lu", "n", "le", "pl", "il", "ul", "ly", "L", "lb", "f", "o", "d", "cl", "nl", "h", "el", "dl", "i", "rl", "li", "al", "lv", "kl", "v", "c", "la", "t", "sl", "bl", "jl", "x", "lc", "p", "ol"], "hx": ["Hy", "dhex", "hxc", "hwx", "Hex", "hc", "Hrx", "Hwx", "dhxc", " hxc", "Hxs", "Hc", "hex", "hxs", "hsxc", "hsrx", " hc", "hmx", " hrx", "hy", " hxs", "hsx", " hex", "Hxa", " hxa", "hswx", "hmxs", "hmy", " hy", "hrx", "Hxc", "dhc", "hxa", "dhx", "Hx", "hmxa", " hwx"]}}
{"id1": "18489832", "id2": "5998352", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" doLoadZaggedFiles", " doLoadZedFiles", " doLoadZippedFiles", " doLoadzippedFiles", " doLoadZaggedContent", " doLoadZippingDir", " doLoadzippingContent", " doLoadZippingFile", " doLoadZaggedDir", " doLoadzippedFile", " doLoadzippingFile", " doLoadZippingContent", " doLoadZaggedFile", " doLoadzippingFiles", " doLoadzippedContent", " doLoadZedDir", " doLoadZippedFile", " doLoadZedContent", " doLoadzippedDir", " doLoadzippingDir", " doLoadZippingFiles", " doLoadZedFile", " doLoadZippedContent", " doLoadZippedDir"], "url": ["ur", "proxy", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "b", "connection", "event", "store", "link", "f", "zip", "route", "URL", "download", "i", "source", "pull", "config", "client", "l", "web", "lr", "base", "r", "file", "c", "loader", "sl", "bug", "Url", "or", "update", "http", "lib", "open"], "destDir": ["destFile", " destFile", " destFolder", "tempFile", "destdir", "destFolder", "tmpdir", "tempFolder", " destdir", "tmpDirectory", " destDIR", "tmpDIR", "outputFile", "DestFile", "outputDirectory", " destDirectory", "DestDir", "tempDIR", "tempDir", "outputDIR", "outputDir", "outputFolder", "DestDIR", "destDIR", "destDirectory", "outputdir", "tmpDir", "DestFolder"], "urlConnection": ["urlNetwork", "webConnect", "URLChannel", "urlConnect", "URLconnection", "webChannel", "httpNetwork", "httpFactory", "URLConnect", "webconnection", "downloadNetwork", "webConnection", "URLConnection", "fileConn", "fileFactory", "urlConn", "urlChannel", "urlconnection", "downloadFactory", " urlConnect", " urlChannel", "httpConnection", "fileNetwork", "fileConnection", "downloadConnection", "urlFactory", "downloadConn", " urlconnection", "httpConn"], "tmpFile": ["destFile", "mpfile", "mpFile", " tmpFolder", " tmpPath", "partfile", "mpPath", "tempPath", "tmpFolder", "destWorld", "zipFiles", "tmpfile", "TempPath", "tempFile", "tmpFiles", "destFolder", "tempFiles", "tempEntry", " tmpFiles", "partFolder", "tmpPath", "partFile", "mpDir", "TempWorld", "destPath", "tmpLine", "Tempfile", "tempLine", "partDir", " tmpLine", " tmpfile", "tmpEntry", " tmpDir", "mpFolder", "zipFile", "tempfile", "zipfile", " tmpWorld", "tempDir", "destEntry", "zipLine", "mpFiles", "tmpWorld", "destfile", "tmpDir", "TempFile", " tmpEntry"], "in": ["ex", "ins", "In", "copy", "ax", "n", "connection", "en", "init", "info", "data", "sync", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "Out", "conn", "cin", "i", "is", "win", "source", "reader", "kin", "rin", "pull", "nin", "l", "a", "login", "work", "inner", "min", "r", "id", "token", "ac", "bin", "err", "con", "c", "file", "up", "pin", "ini", "as", "arin", "again"], "out": ["at", "ex", "writer", "one", "server", "call", "copy", "In", "null", "n", "connection", "cmd", "init", "io", "off", "outer", "this", "sync", "inc", "socket", "output", "no", "check", "o", "index", "IN", "Out", "conn", "download", "i", "source", "client", "nin", "co", "login", "inner", "point", "outs", "min", "exec", "bin", "file", "err", "obj", "name", "up", "OUT", "op", "again", "line", "ext"], "localURL": ["externalAPI", "LocalCL", "LocalAPI", "LocalUrl", " localFile", "localFile", "externalCL", "localAPI", "remoteURI", " localCL", "externalURL", "localCL", "externalUrl", "remoteURL", " localAPI", "localURI", "remoteUrl", " localURI", "remoteFile", "LocalURL", "localUrl", " localUrl", "baseFile", "baseURI", "baseURL", "baseUrl"]}}
{"id1": "11477906", "id2": "16623181", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadDefaultParameters", "loaddefaultsettings", "getdefaultConfiguration", "loadDefaultsettings", "getDefaultConfiguration", "loadGlobalParameters", "getDefaultSettings", "getdefaultParameters", "getDefaultParameters", "getdefaultsettings", "loadApplicationSettings", "loadGlobalsettings", "loaddefaultConfiguration", "loadApplicationsettings", "loadGlobalConfiguration", "loadDefaultConfiguration", "loadApplicationParameters", "loaddefaultSettings", "loadGlobalSettings", "getDefaultsettings", "loadApplicationConfiguration", "loaddefaultParameters", "getdefaultSettings"], "configFileName": ["ConfigFileUrl", "configFileString", "configModuleString", "ConfigModuleString", "configFilesLocation", "fileFileName", "configFilesName", "configModuleName", "configPlaceUrl", "ConfigFileString", "ConfigModuleLocation", "configFullLocation", "fileFileTime", "fileFILEType", "configFilenameTime", "configFilenameName", "configModuleUrl", "fileFileType", "configPlaceName", "fileFILELocation", "configFILEName", "configFilesType", "configFileTime", "configFileType", "configFILELocation", "configFilenameType", "ConfigModuleName", "configFileUrl", "ConfigFileLocation", "configPlaceString", "ConfigModuleUrl", "configModuleLocation", "fileFILETime", "configPlaceLocation", "configFilenameLocation", "fileFileLocation", "fileFILEName", "configFILEType", "configFullUrl", "ConfigFileName", "configFILETime", "configFileLocation", "configFullString", "configFullName", "configFilesTime"], "in": ["m", "log", "ins", "url", "ssl", "resource", "In", "n", "init", "data", "this", "inc", "socket", "it", "f", "input", "din", "IN", "inn", "read", "conn", "pass", "cin", "is", "i", "source", "pull", "reader", "config", "inside", "nin", "stream", "work", "login", "a", "inner", "base", "r", "id", "pc", "con", "err", "bin", "up", "diff", "pin", "ini", "as", "plus", "again"], "out": ["to", "prefix", "ex", "log", "writer", " file", "default", "write", "image", "server", "one", "copy", "null", "parent", "view", "connection", "able", "io", "off", "data", "back", "version", "this", "sync", "socket", "inc", "output", "it", "all", "f", "exp", "o", "set", "d", "password", "Out", "and", "error", "timeout", "conn", "s", "instance", "config", "client", "point", "outs", "user", " back", "object", "string", "exec", "bin", "err", "obj", "file", "c", "name", "up", "net", "ou", "OUT", "t", " output", "again", "lib", "ext"]}}
{"id1": "23677142", "id2": "4750967", "code1": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"BubbleSortShort2": ["bubbleSortInt4", "bubbleOrdershort3", "bubbleOrderShort1", "bubbleSortshort3", "bubbleOrderShort3", "bubbleSortInt3", "bubbleSortShort4", "bubbleOrdershort2", "bubbleSortInt1", "bubbleSortShort3", "bubbleOrdershort1", "bubbleSortshort1", "bubbleOrderShort2", "bubbleSortShort2", "bubbleSortshort2", "bubbleSortshort4", "bubbleOrdershort4", "bubbleSortShort1", "bubbleOrderShort4", "bubbleSortInt2"], "num": ["un", "menu", "one", "nine", "null", "init", "data", "NUM", "sum", "cum", "former", "div", "mom", "tu", "ui", "mon", "m", "text", "u", "unit", "nom", "form", "two", "empty", "result", "index", "sort", "comb", "test", "Num", "uni", "prim", "oct", "con", "lim", "initial", "umi", "dom", "nam", "om", "prefix", "nu", "loc", "ul", "off", "um", "du", "man", "union", "out", "im", "transform", "node", "mult", "bin", "begin", "dim", "zero", "common", "ut", "block", "from", "four", "buf", "param", "np", "n", "f", "valid", "multi", "number", "current"], "last_exchange": ["last_Exchange", "last_expplay", "last_exception", "last_interbreak", "last_exppire", "last_expbreak", "last_explay", "last_exorder", "last_xbreak", "last_remcode", "last_interception", "last_expception", "last_Explay", "last_exaction", "last_combreak", "last_excode", "last_xcode", "last_comchange", "last_lexchange", "last_explace", "last_outplay", "last_outchange", "last_xpire", "last_expire", "last_lexcode", "last_Exorder", "last_xaction", "last_Exception", "last_outception", "last_remchange", "last_xchange", "last_Explace", "last_remception", "last_outorder", "last_xception", "last_interpire", "last_Exbreak", "last_lexaction", "last_complace", "last_lexbreak", "last_lexplace", "last_interchange", "last_expchange", "last_comception", "last_exporder", "last_exbreak", "last_lexception", "last_remaction"], "right_border": [" right_radius", " right_margin", "same_origin", "rightfulborder", "right_cookie", "same_border", "right_radius", "right_byte", "samefulborder", "rightfulorigin", " right_cookie", "rightfulbalance", "right_margin", "right_origin", "samefulbalance", "rightAradius", "same_balance", "samefulorigin", "rightAcookie", "right_balance", "rightAborder", " right_byte"], "j": ["ij", "jen", "k", "js", "u", "fr", "z", "e", " dj", "b", "g", "n", "off", "kj", "jc", "pt", "f", "jj", "jet", "ja", "o", "d", "jit", "index", "dj", "job", "uj", "key", "aj", "ji", "J", "jo", "i", "pr", "y", "oj", "li", "l", "bj", "ind", "v", "obj", "dy", "adj", "left", "ix", "next", "jl", "json", "x", "jp", "qi", "ii", "p"], "temp": ["prefix", "shared", "pack", "z", "txt", " Temp", "copy", "parent", "style", "prev", "tc", "flat", "init", "Temp", "output", "f", "comb", "dev", "test", "i", "mini", "iter", "max", "tmp", "base", "stable", "div", "cache", "v", "c", "obj", "adj", "pre", "diff", "fake", "lc", "buffer", "orig", "emp", "tem", "shift"]}}
{"id1": "2017833", "id2": "12066447", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["replace", "crypt", "ash", "message", "html", "build", "sha", "check", "str", "hex", "set", "sum", "h", "create", "add", "print", "parse", "dump", "number", "base", "transform", "string", "Hash", "get", "format", "update", "block"], "text": ["font", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "output", "input", "str", "editor", "hex", "translation", "password", "template", "bytes", "key", "out", "test", "code", "source", "class", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "context", "path", "word", "content", "ext", "format", "buffer", "value", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedencodedWarning", "Unsupportedencodingception", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedencodingWarning", "UnsupportedEncasingWarning", "UnsupportedEncgorithmException", "UnsupportedEncasingException", "UnsupportedEncgorithmception", "UnsupportedEncodingWarning", "UnsupportedEncgorithmWarning", "Unsupportedencodedception", "UnsupportedEncodedWarning"], "md": ["mad", "m", "rm", "hd", " MD", "message", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "gd", "f", "mc", "mag", "d", "vd", "od", "meta", "ms", "hm", "wd", "mb", "amd", "mg", "dm", "bd", "bf", "metadata", "bm", "MD", "ad", "mac", "ind", "nm", "mand", "mm", "ma", "am", "ld", "pm", "mt", "mod", "ds"], "sha1hash": ["sha2h", "sha2hex", "SHA2Hash", "SHA1hash", "sha1hex", "ha1match", "sha4Hash", "shaonehash", "SHA2hash", "ha2match", "ha1hash", "sha1Hash", "sha3hash", "sha2hash", "sha3match", "sha2Hash", "SHA2sum", "sha4hex", "sha5h", "SHA1h", "sha5hex", "sha2sum", "SHA2h", "sha1sum", "SHA1Hash", "shaonematch", "sha1h", "SHA1sum", "ha2hex", "sha3hex", "sha5sum", "sha256h", "sha5Hash", "sha2match", "sha256sum", "sha5hash", "ha1hex", "sha4sum", "ha2hash", "shaonesum", "sha3sum", "sha1match", "sha256hash", "ha2sum", "ha1sum", "shaonehex", "sha256Hash", "sha4hash", "SHA1hex"]}}
{"id1": "807346", "id2": "16820041", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 0, "substitutes": {"runScript": ["Runscript", "execCode", "runscript", "execscript", "RunCode", "execScript", "runCode", "runJS", " runscript", "RunJS", "execJS", " runJS", "RunScript", " runCode"], "scriptName": ["scriptname", "codePath", "ScriptUrl", "filePath", " scriptFile", "ScriptNames", " scriptUrl", " scriptNames", "scriptFile", "scriptNames", "Scriptname", "fileUrl", "codename", "fileName", "codeName", "codeNames", "ScriptFile", " scriptPath", "fileFile", "scriptPath", "scriptUrl", "ScriptName", " scriptname", "ScriptPath"], "data": ["DATA", "text", "partial", "message", "write", "one", "append", "html", "script", "complete", "body", "empty", "info", "this", "raw", "part", "output", "no", "result", "input", "str", "valid", "split", "dat", "batch", "index", "error", "missing", "key", "type", "template", "out", "code", "results", "i", "source", "action", "api", "media", "a", "number", "base", "ata", "div", "layout", "string", "start", "alpha", "name", "next", "function", "json", "response", "content", "buffer", "value", "format", "feed"], "url": ["ls", "page", "log", "uri", "ssl", "ll", "resource", "server", "image", "b", "connection", "f", "impl", "zip", "www", "URL", "bel", "i", "source", "rl", "l", "stream", "web", "base", "user", "id", "file", "service", "up", "sl", "host", "path", "Url", "buffer", "http", "feed", "bb", "open", "ball", "browser"], "in": ["fd", "ins", "ssl", "resource", "In", "b", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "out", "s", "pass", "conn", "is", "i", "win", "source", "reader", "cms", "client", "with", "a", "stream", "login", "inner", "r", "id", "ac", "bin", "file", "err", "ini", "as", "buffer", "serv"], "buffIn": ["bbIn", "bbIns", "bufin", "bbin", "BuffIn", "BuffedIn", "bufferIns", "bufferedIn", "buffedIn", "bufOut", "buffin", "bufferIn", "Buffin", "bufIn", "ufIns", "buffOut", "BuffOut", "buffIns", "bbOut", "ufIn", "BuffIns", "bufIns", "bufferin", "ufedIn", "ufin"], "temp": ["partial", "flow", "unit", " Temp", "length", "count", "dest", "offset", "num", "tc", "empty", "enc", "cut", "raw", "Temp", "output", "pt", "ptr", "f", "zip", "input", "index", "read", "test", "type", "i", "total", "iter", "source", "cel", "size", "tmp", "len", "number", "base", "stable", "div", "c", "start", "extra", "wait", "fake", "current", "content", "buffer", "pointer", "emp", "tem", "char"]}}
{"id1": "15516136", "id2": "5725177", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPELMedia", "loadBufferedJPPGMedia", "loadBufferedMPEGMedia", "loadBufferedJPELimage", "loadBufferedMPPGImage", "loadBufferedMPPGimage", "loadBufferedMPEGimage", "loadBufferedJPEGFile", "loadBufferedMPPGFile", "loadBufferedMPPGMedia", "loadBufferedMPEGFile", "loadBufferedJPEGimage", "loadBufferedJPELImage", "loadBufferedJPEGMedia", "loadBufferedJPNGFile", "loadBufferedJPPGimage", "loadBufferedMPEGImage", "loadBufferedJPNGMedia", "loadBufferedJPNGimage", "loadBufferedJPELFile", "loadBufferedJPNGImage", "loadBufferedJPPGImage", "loadBufferedJPPGFile"], "url": ["ur", "page", "log", "uri", "ssl", "resource", "server", "ll", "large", "play", "style", "connection", "loc", "remote", "data", "link", "mount", "blog", "f", "rule", "www", "URL", "coll", "ref", "job", "href", "el", "download", "xml", "dl", "source", "pull", "src", "config", "media", "filename", "stream", "l", "base", "alt", "object", "id", "address", "email", "string", "gl", "found", "file", "loader", "name", "service", "sl", "host", "layer", "path", "Url", "location", "buffer", "http", "feed", "bb"], "image": ["default", "large", "parent", "view", "data", "icon", "shadow", "issue", "gallery", "feature", "cache", "file", "pm", "ini", "ui", "img", "available", "m", "page", "jpg", "photo", "message", "resource", "connection", "info", "model", "Image", "result", "zip", "error", "xml", "element", "i", "config", "object", "video", "hole", "show", "upload", "age", "layer", "eye", "game", "database", "build", "pixel", "thin", "site", "archive", "job", "out", "instance", "api", "ami", "size", "im", "gif", "up", "pin", "cover", "picture", "value", "manager", "copy", "output", "figure", "f", "audio", "document", "container", "source", "cm", "media", "work", "inner", "slice", "position", "bug", "auto", "p"], "in": ["fd", "m", "ex", "ins", "ssl", "In", "b", "ax", "n", "init", "fb", "data", "socket", "inc", "part", "f", "gin", "impl", "input", "din", "IN", "inn", "inas", "container", "out", "el", "pass", "conn", "xml", "cin", "is", "i", "source", "win", "reader", "rin", "kin", "inside", "a", "l", "stream", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "con", "c", "err", "file", "pin", "cf", "ini", "or", "again", "serv", "doc", "isin"], "decoder": ["encoder", "decode", "Decode", "Decoding", "recenter", "Decoder", "decoding", " decoding", "deoder", "deenter", " decoded", "deode", "recoder", "Decoded", "encode", "deoding", "Decenter", "decoded", "encoded", "encoding", "recode", "decenter", "recoding", " decode"]}}
{"id1": "11562173", "id2": "4164833", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkFileStream", " checkOutputChannel", "checkOutputStream", "checkOutputSteam", "checkOutputChannel", "checkIOStream", " checkInputSteam", "checkFileSteam", "checkIOstream", "checkFileChannel", " checkInputChannel", " checkOutputstream", " checkInputstream", "checkOutputstream", " checkOutputSteam", "checkIOChannel", "checkIOSteam", "checkInputSteam", "checkFilestream", " checkOutputStream", "checkInputChannel", "checkInputstream"], "in": ["into", "ins", "image", "In", "connection", "io", "data", "inc", "input", "din", "IN", "inn", "index", "is", "source", "ack", "reader", "src", "login", "inner", "min", "bin", "c", "con", "ic", "up", "ini", "as", "x", "plus", "comp", "again", "p", "isin"], "cmp": ["conv", "asc", "prefix", "np", "roc", "mp", "omp", "cp", "rc", "pixel", "loc", "prev", "cho", "spec", "cpp", "coll", "ch", "index", "sort", "ci", "cb", "clip", "code", "cc", "ctrl", "comment", "upp", "config", "co", "cache", "match", "pc", "amp", "c", "mom", "sup", "up", "ctx", "pre", "diff", "proc", "op", "lc", "comp", "cs", "cup", "fp", "p", "cop", "com"], "all": ["asc", "partial", "array", "default", "one", "call", "parent", "null", "except", "best", "none", "acl", "each", "allow", "not", "valid", "coll", "All", "sum", "cl", "and", "only", "process", "total", "al", "l", "a", "ann", "any", "local", "match", "ALL", "alpha", "list", "am", "global", "full", "both", "auto", "always", "p"], "stream": ["null", "speed", "Stream", "form", "this", "steam", "port", "raw", "socket", "channel", "output", "model", "impl", "document", "result", "input", "stack", "coll", "feed", "test", "temp", "instance", "progress", "source", "ack", "roll", "ream", "client", "reader", "self", "track", "src", "user", "round", "transform", "object", "trans", "string", "v", "platform", "up", "per", "host", "context", "pool", "response", "cont", "wrapper", "comp", "iterator", "sw"], "out": ["prefix", "array", "image", "copy", "null", "parent", "b", "io", "outer", "data", "project", "this", "sync", "inc", "part", "not", "output", "result", "block", "exp", "o", "index", "sum", "Out", "comment", "point", "outs", "user", "v", "bin", "c", "obj", "name", "list", "other", "option", "full", "OUT", "up", "extra", "response", "x", "again", "p"], "i": ["k", "u", "uri", "e", "j", "b", "n", "fi", "init", "io", "info", "si", "f", "it", "index", "d", "end", "key", "type", "ci", "oi", "ji", "h", "abi", "multi", "li", "di", "l", "mi", "hi", "pi", "xi", "slice", "r", "ind", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "ix", "strength", "ini", "ii", "ui", "x", "bi", "qi", "lc", "p"]}}
{"id1": "16079868", "id2": "22503685", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "label": 1, "substitutes": {"readIntoList": ["readIntonMap", "readIntoMap", "readIntoLog", "readInttoLog", "readInttoList", "readTextoLog", "readInttoMap", "readTextoList", "readTextoMap", "readIntonList", "readIntonLog"], "url": ["uri", "ssl", "resource", "image", "server", "connection", "remote", "io", "org", "data", "link", "channel", "rule", "input", "URL", "job", "date", "source", "config", "rl", "l", "stream", "base", "user", "object", "email", "address", "string", "gl", "file", "name", "service", "sl", "host", "location", "Url", "path", "buffer", "http", "feed"], "list": ["array", "menu", "we", "nav", "server", "parent", "view", "info", "data", "lists", "this", "part", "group", "member", "all", "status", "result", "map", "LIST", "index", "coll", "batch", "test", "out", "dict", "see", "code", "temp", "record", "client", "li", "listed", "l", "self", "tree", "user", "table", "queue", "object", "cache", "show", "load", "obj", "detail", "name", "get", "pool", "json", "join"], "in": ["rec", "m", "ins", "ssl", "fr", "image", "In", "b", "io", "data", "inc", "raw", "f", "gin", "input", "din", "IN", "inn", "lin", "read", "h", "out", "i", "source", "iter", "is", "reader", "client", "a", "l", "stream", "er", "nin", "inner", "login", "min", "r", "token", "bin", "c", "file", "err", "con", "loader", "re", "ini", "as", "buffer", "again"], "inputLine": ["argumentBlock", "Inputline", "inputText", "outputLine", "commandName", "commandBlock", "inputBlock", "InputFile", "ifline", "argumentLine", "outputString", "InputString", "InputBlock", "inputLin", "ifName", "commandline", "inputL", "inputFile", " inputString", "commandLine", "argumentStream", "InputLine", "InputName", "commandText", "issueLin", "outputFile", "outputText", "inputStream", " inputline", "issueline", "requestline", "outputL", " inputStream", "InputItem", "ifLine", "requestText", " inputFile", "outputline", " inputText", "inputName", "issueLine", "InputText", "commandFile", " inputItem", "issueName", "inputItem", "InputL", "argumentL", " inputName", " inputBlock", "requestL", "inputline", "inputString", "commandItem", "requestLine", " inputLin", " inputL", "InputStream", "ifLin"], "commandNameBegin": ["CommandLinebegin", "commandStringbegin", "commandTimeCreate", "CommandNameBegin", "CommandLineBegin", " commandLineBegin", "commandLineBegin", "commandLinebegin", " commandStringEnd", "commandLineBeginning", " commandTimeCreate", " commandTimeBegin", "commandParambegin", "commandLengthBegin", "CommandLineBeginning", " commandLinebegin", "commandNamebegin", " commandNameBeginning", "commandTimebegin", " commandStringBegin", "commandStringBegin", "commandNameBeginning", "commandLengthEnd", "commandLengthBeginning", "commandStringBeginning", "commandLineEnd", "commandTimeEnd", "commandParamBegin", " commandStringBeginning", "commandPathBegin", "commandNameCreate", "CommandNameEnd", "CommandLineEnd", " commandLineEnd", "commandStringEnd", " commandStringbegin", " commandNameCreate", "commandTimeBegin", "commandLengthCreate", "CommandNameBeginning", "commandPathEnd", "commandLineCreate", " commandTimeBeginning", "commandParamEnd", "commandParamBeginning", " commandLineBeginning", "commandPathBeginning", "commandPathbegin", " commandNamebegin", " commandTimeEnd", "commandTimeBeginning", "CommandNamebegin"], "commandNameEnd": ["operationNameEnd", "commandNameStart", " commandNameEND", "operationParamStart", "commandPathend", "operationParamBegin", " commandLineBegin", "commandLineBegin", "operationParamEnd", "operationNameend", "operationNameBegin", "commandParamend", "commandLineend", "commandParamStart", "commandParamEND", " commandLineend", "commandnameend", "commandPathStart", "commandTimeend", "commandTimeEnd", "commandParamBegin", "commandTimeEND", "commandLineEnd", "commandnameEND", "commandPathBegin", " commandLineStart", " commandLineEnd", "commandnameEnd", "commandNameEND", "commandLineStart", "commandTimeStart", " commandTimeEND", "commandTimeBegin", "operationNameStart", " commandNameend", "commandPathEnd", " commandNameStart", "commandLineEND", "commandParamEnd", " commandLineEND", "commandNameend", "commandPathEND", " commandTimeEnd", " commandTimeend", "operationParamend"], "item": ["page", "p", "menu", "image", "server", "temp", "parent", "option", "manager", "add", "event", "info", "data", "si", "link", "part", "channel", "group", "entry", "it", "area", "site", "result", "job", "el", "xml", "element", "i", "instance", "plugin", "iter", "hop", "api", "client", "li", "builder", "action", "edit", "er", "article", "atom", "base", "bar", "user", "ip", "object", "Item", "handler", "obj", "app", "other", "admin", "up", "service", "order", "next", "extra", "name", "layer", "source", "ui", "response", "or", "json", "update", "items", "owner"], "e": ["ve", "pe", "ee", "u", "ev", "esi", "one", "se", "le", "en", "ce", "event", "this", "ie", "ec", "f", "oe", "es", "edge", "ise", "o", "d", "ae", "error", "me", " pe", "i", "te", "ze", " ev", "a", "l", "er", "ne", "E", "change", "v", "handler", "c", "err", "ke", "re", "t", "Event", "ite", " event", "ea", "or", "x", "ed", "fe", "exc", "force", "p", "ception"]}}
{"id1": "19113613", "id2": "4716110", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "write", " cp", "cp", "sync", "zip", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "Copy", "create", "delete", "change", "load", "share", "upload", "get", "ssh", "transfer", "Cop", "put", "update", "p", "opy", "cop"], "in": ["ins", "url", "image", "In", "n", "connection", "init", "thin", "data", "this", "project", "inc", "old", "part", "f", "input", "din", "IN", "inn", "lin", "index", "plugin", "cin", "i", "kin", "win", "reader", "sin", "config", "inside", "client", "work", "a", "login", "inner", "base", "min", "id", "token", "bin", "c", "ic", "name", "diff", "pin", "get", "ini", "as", "again", "update", "on"], "out": ["at", "page", "ex", "vert", "one", "image", "resource", "call", "parent", "b", "null", "n", "connection", "remote", "init", "io", "off", "outer", "dot", "project", "this", "version", "outside", "inc", "external", "part", "output", "no", "group", "input", "block", "o", "Out", "conn", "with", "client", "self", "work", "base", "outs", "point", "user", "object", "app", "cache", "exec", "bin", "c", "v", "err", "obj", "option", "name", "net", "goal", "OUT", "up", "root", "other", "path", "x", "again", "line", "p", "ext"], "source": ["prefix", "proxy", "pe", "component", "attribute", "direction", "subject", "secret", "url", "uri", "unit", "resource", "parent", "dest", "scope", "view", "ce", "username", "project", "status", "Source", "site", "route", "family", "missing", "type", "sin", "iter", "class", "src", "size", "base", "feature", "alt", "internal", "position", "id", "ource", "name", "origin", "service", "reference", "SOURCE", "format", "secure", "force", "use", "from"], "target": ["prefix", "component", "direction", "url", "resource", "parent", "master", "dest", "null", "project", "output", "alias", "site", "route", "about", "template", "home", "cat", "top", "config", "src", "Target", "alt", "base", "point", "wrong", "address", "token", "arget", "detail", "name", "origin", "service", "reference", "root", "pattern", "host", "next", "goal", "path", "current", "value", "tail", "format", "force"], "files": ["ls", "keys", "ions", "ins", "links", "users", "obs", "jobs", "data", "assets", "f", "sections", "apps", "groups", "plugins", "features", "classes", "lines", "fs", "s", "children", "flows", "objects", "results", "docs", "tools", "images", "filename", "ports", "pages", "resources", "names", "models", "cells", "iles", "blocks", "Files", "items"], "file": ["page", "FILE", "url", "e", "resource", "ile", "uri", "parent", "le", "b", "unit", "letter", "item", "data", "single", "child", "part", "folder", "entry", "f", "it", "feed", "live", "el", "fe", "future", "dir", "directory", "filename", "l", "base", "object", "id", "local", "string", "load", "name", "entity", "binary", "per", "File", "layer", "path", "function", "current", " File", "line", "fp", "lib"], "inCh": ["InChan", "INChannel", "inCH", "InChannel", "INCH", "inch", "inChan", "outCH", " inch", "InCH", " inChan", " inCH", "outch", "Inch", "InCh", "outChan", "outChannel", " inChannel", "INChan", "inChannel", "INCh"], "outCh": ["Outch", "OutChan", "OutCH", "inCH", " outChannel", "inch", " outch", "inChan", "outCH", "OutChannel", "outputCh", "outch", "outputChan", "outChan", " outCH", "outChannel", "outputCH", "inChannel", "OutCh", "outputch"]}}
{"id1": "11840277", "id2": "2168610", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"clearTables": ["clearContows", "cacheTableations", "clearContaches", "clearStaces", "clearTemings", "clearTows", "clearTableows", "clearContaces", "clearStables", "clearStaches", "cacheTations", "cacheTableables", "cacheTables", "clearTemations", "cacheTings", "createTables", "clearTemables", "clearContables", "clearBows", "createTaches", "clearTings", "clearTemows", "createStaces", "clearBings", "clearBables", "clearBations", "createTows", "clearTations", "clearStows", "clearBaches", "clearTaches", "cacheTows", "cacheTableows", "clearBaces", "clearTableations", "clearTableings", "clearTaces", "createStables", "createTaces", "clearTableables", "createStows", "cacheTableings", "createStaches"], "conn": ["sth", "bb", "log", "ct", "ssl", "cn", "col", "server", "Connect", "conf", "n", "connection", "loc", "cp", "act", "pg", "cmp", "lock", "rc", "ns", "org", "session", "sql", "jc", "oss", "Connection", "cond", "connect", "mc", "nt", "coll", "ch", "nc", "ci", "h", "wd", "cb", "Conn", "cc", "error", "cat", "cm", "oci", "config", "client", "co", "di", "db", "ann", "cache", "ac", "exec", "con", "c", "obj", "dc", "dn", "ob", "ou", "ctx", "ai", "pub", "path", "mt", "cf", "state", "lc", "ca", "close", "enc", "p", "open"], "stmt": ["strMT", "stnt", "actmn", "emt", " stmn", "tm", " str", " stbm", "stprint", " stager", "ctm", " stgr", "Stmi", "ssmn", "dm", "playtx", "actnt", "tct", "stbm", "stmc", "stql", "estmt", "stmn", "Stmd", "ftmt", " stlt", "putlt", "STmc", "puttor", "stager", "ftlt", "ldager", "est", "Stmc", "ctgr", "ctql", "ftbm", "dr", "stswd", "ctmt", "stap", " stma", "stsmt", "STmt", "stwd", "ssmt", "actmi", "ftmn", "Stmn", "playtor", "STprint", "stct", "STmn", "stwt", "stmm", "StMT", "STlt", "putma", "estmm", "putager", " stmi", "stlt", "stgr", "STMT", "putwt", " stmc", "eprint", " stql", "putmn", "ewd", " stct", "Stlt", "Stm", " stm", "strlt", "istmt", "strml", "STmd", "putmt", "playwt", "putm", "Stgr", "strmt", "ssbm", " stwt", "stmd", "str", "Stct", "dmt", "STst", "putMT", "stst", "tmt", "istgr", "ldma", "stMT", "playmt", "ctr", " stmd", "Stnt", "stmi", " stap", "stml", "ldmt", "Sttor", "sttx", " stnt", "puttx", "Stwt", "dql", "STgr", "stsst", "putap", "actmt", "tnt", "istmn", "Stml", "Stap", "ldmn", "putmm", "sswt", "sttor", "putml", "estwt", "STbm", "STwd", "putbm", "stsprint", " stml", "Stmt", "ctmd", "Sttx", "stma", "estm", "Stmm", "stm", "istMT"]}}
{"id1": "17724879", "id2": "10674824", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "label": 0, "substitutes": {"getDigest": ["getSignests", "getdigHash", "getSignHash", "createdigHash", "createDigester", "getSignester", "getdigests", "createDigests", "getMDHash", "getdigester", "getMDest", "getDigester", "createdigest", "createdigests", "createdigester", "getMDests", "getDigests", "getMDester", "getSignest", "getdigest", "createDigHash", "createDigest", "getDigHash"], "attribute": ["prefix", "att", "component", "subject", "uri", "resource", "image", "message", "connection", "event", "data", "username", "individual", "entry", "document", "application", "definition", "audio", "route", "set", "attr", "type", "ribute", "element", "instance", "plugin", "class", "metadata", "api", "config", "directory", "client", "pair", "expression", "feature", "node", "variable", "object", "address", "character", "name", "property", "entity", "reference", "device", "function", "layer", "operation", "value", "ident", "argument", "manager", "Attribute"], "digestAlgorithm": ["digESTAlg", "digesterAlgebra", "digestalger", "digestElg", "digestElger", "digestAlgorith", "digestalgo", "digesterAlgo", "digestAlg", "digESTAlgo", "digesterAlgorith", "digESTAlgorithm", "digestAlgo", "digestalg", "digestalgorith", "digestAlgebra", "digestalgorithm", "digestElgo", "digestALgorithm", "digestALgebra", "digesterAlgorithm", "digestALgorith", "digestElgorithm", "digestALgo", "digestAlger", "digESTAlger", "digestalgebra"], "digest": ["labest", "DigEST", " digEST", "dger", "bigester", "dest", "bigger", "bigest", "Digester", "signger", "digEST", "Digest", " digested", "diguration", "longester", "Digtest", "digtest", "multipluration", "multiplEST", "labEST", "digger", "multiplest", "signest", " diguration", "multiplester", " digester", "longEST", "Digested", "digester", " digtest", "signester", "dester", "biggest", "labtest", "dgest", "digested", "labester", "diggest", "Diguration", "longest", "signgest", "longested"], "md": ["ds", "own", "m", "wd", "rm", "doc", "mad", "hd", "sd", " MD", "der", "module", "nd", "mp", "cmd", "mr", "mo", "um", "mid", "dd", "ht", "editor", "mc", "mag", "d", "od", "mb", "ms", "dev", "ng", "nm", "amd", "plugin", "dm", "bd", "meta", "metadata", "cm", "pd", "MD", "di", "mn", "mi", "db", "ad", "mac", "my", "id", "po", "mm", "ma", "sm", "app", "ml", "ld", "cb", "pm", "kg", "arm", "mt", "cd", "ui", "mod", "manager", "df"]}}
{"id1": "17580775", "id2": "22442270", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"runInternal": ["runImpl", " runSync", "processInternal", "doImpl", "runExternal", " runExternal", "doInternal", "processSync", "processExternal", "processImpl", " runImpl", "doExternal", "doSync", "runSync"], "connection": ["component", "default", "image", "volume", "socket", "entry", "password", "graph", "directory", "cache", "context", "condition", "resource", "message", "server", "communication", "remote", "event", "version", "port", "ion", "index", "translation", "error", "timeout", "connected", "builder", "config", "expression", "command", "object", "handler", "con", "c", "option", "entity", "layer", "operation", "lc", "database", "proxy", "log", "loc", "channel", "application", "creator", "section", "character", "environment", "function", "location", "wrapper", "collection", "use", "description", "statement", "body", "session", "engine", "Connection", "document", "connect", "container", "source", "driver", "reader", "client", "inner", "position", "machine", "service", "relation", "current", "request"], "visited": ["viewited", "Vised", "visalled", "VisITED", "invited", "Visitted", "Visalled", "viewITED", "VISITED", "Visited", "invalled", "viewitted", "VISitted", "vised", "VISed", "invitted", "invITED", "viewed", "visITED", "VISalled", "VISited", "visitted"], "startTimeStamp": ["startLineEstamped", "startLineStamped", "startLineEstng", "startTimeStamped", "startTimestamped", "startTimeEstamp", "startTimestamp", "startTimestamps", "startTimeEstamped", "startTimeestamp", "startTimeStng", "startLineEstamp", "startLineEstamps", "startTimeStamps", "startLineStamp", "startTimestng", "startLineStng", "startTimeestng", "startTimeEstng", "startTimeestamps", "startTimeEstamps", "startTimeestamped", "startLineStamps"], "delayedProgress": ["elayedContent", "delayedStatus", "deladedProgress", "elayedProgress", "deliverStatus", "deladedContent", "delivedStatus", "delivedContent", "eladedContent", "elayedStatus", "delivedComplete", "elayedComplete", "delivedProgress", "delayedContent", "deladedStatus", "eladedComplete", "deliverComplete", "eladedStatus", "eladedProgress", "deliverProgress", "delayedComplete", "deladedComplete", "deliverContent"], "conn": ["conv", "ls", "att", "ct", "ssl", "cn", "uc", "cp", "n", "loc", "act", "rc", "cmp", "io", "sync", "channel", "Connection", "connect", "mc", "nt", "ch", "nc", "ci", "cb", "h", "Conn", "connected", " con", "cc", "config", "client", "cli", "l", "co", "db", "ad", "ann", "exec", "con", "c", "obj", "dc", "comm", "ctx", "cf", "lc", "enc", "http", "open"], "fileName": [" fileKey", "FileKey", "contentName", "filePath", " fileArea", " filePath", "urlArea", "urlName", "fileArea", "urlKey", "fileKey", "imageName", "fileSpace", "filename", "urlPath", "FileArea", "imageSpace", "contentPath", " fileSpace", "FilePath", " filename", "imagePath", "FileName", "contentname", "imagename", "contentSpace"], "disp": ["interap", "prop", "Dispart", "interP", "interpp", "Dispr", "disap", "prope", "propr", "disP", "defpend", "defps", "scheap", " dispe", "Dispatch", "detP", "detp", "Disps", "dispart", "Dispe", "dispatch", "interpatch", "broadp", "interpe", "interp", "dispr", "Dispend", "defp", "schepe", "schep", "propose", "Disp", "defpart", "dispe", "broadps", "broadpend", "Dispose", " dispose", "Dispp", "detpp", "DisP", "dispp", "broadpart", "dispose", " dispr", "schepatch", "disps", "dispend", "detpatch", "Disap"], "p": ["at", "after", "m", "pe", "np", "lp", "e", "col", "j", "vp", "pat", "b", "g", "n", "loc", "pl", "bp", "part", "pos", "f", "P", "pa", "o", "index", "d", "end", "h", "i", "pr", "api", "y", "l", "ip", "pi", "point", "r", "po", "v", "patch", "c", "ap", "ping", "t", "pre", "sp", "op", "jp", "q", "pp", "rep", "tp"], "response": ["prot", "resp", "page", "description", "respond", "uri", "message", "image", "server", "resource", "complete", "body", "Response", "en", "successful", "version", "data", "reset", "respons", "output", "model", "status", "result", "site", "radius", "reply", "index", "error", "timeout", "code", "api", "found", "id", "success", "next", "json", "path", "value", "pointer", "function", "collection", "http", "feed", "request", "ception", "received"], "contentType": ["messageInfo", "contentLength", "contentName", "messageLength", " contentLength", "documentTyp", "messageLen", "contentInfo", "contentTyp", "messageType", " contentInfo", "ContentName", " contentTyp", "documentLength", "ContentLen", " contentName", "ContentType", "ContentInfo", "ContentLength", "documentName", "documentType", "ContentTyp"], "contentEncoding": ["contentCasing", "loadEnaring", "contentencoding", "contentEncaring", "contentencoder", "contentEnryption", "contentEncryption", "contentLocaring", "ContentDecoding", "contentEncReading", "loadEnryption", "loadEncaring", "ContentEncoding", "ContentDecocol", "contentDecoding", "ContentDecoder", "loadEncasing", "contentEReading", "loadEnasing", "contentDecoder", "contentencReading", "contentLocryption", "contentEocol", "contentEoding", "loadEncryption", "ContentDecReading", "contentEncoder", "contentEnaring", "contentEncasing", "contentEoder", "contentDecocol", "contentCaring", "contentCryption", "loadEnoding", "loadEncoding", "contentLocoding", "contentEncocol", "contentCoding", "contentLocasing", "ContentEncReading", "ContentEncoder", "contentDecReading", "contentEnoding", "contentEnasing", "contentencocol", "ContentEncocol"], "contentLen": ["resourceLength", "contentLength", " contentSize", "resourcelen", "contentlen", "ContentSl", " contentLength", "activityLen", " contentlen", "Contentlen", "activitySize", " contentSl", "activityLength", "ContentLen", "resourceSize", "activitySl", "ContentLength", "contentSize", "ContentSize", "contentSl", "resourceLen"], "is": ["un", "isl", "ss", "os", "ot", "mis", "version", "not", "ig", "it", "ion", "IS", "isc", "us", "ys", "out", "ync", "ios", "isp", "ub", "im", "ip", "can", "iss", "net", "igh", "are"], "url": ["page", "text", "log", "uri", "ssl", "resource", "image", "server", "html", "org", "username", "link", "socket", "channel", "document", "status", "str", "URL", "download", "source", "config", "client", "user", "email", "address", "string", "file", "service", "sl", "host", "context", "path", "Url", "json", "location", "layer", "buffer", "http", "feed"], "loadNext": ["loadsPrevious", "loadingLast", "loadingPrevious", "loadLast", "loadingNext", "checkNext", "loadPrevious", "loadsNext", "loadsFirst", "loadingFirst", "loadFirst", "checkPrevious", "checkLast", "checkFirst", "loadsLast"], "itemsLoadedPartially": ["itemsLoadedCopally", "itemsLoadedPARTally", "itemsLoadedCopial", "itemsLoadedPARTials", "itemsLoadedpartially", "itemsLoadippedPartials", "itemsLoadippedpartially", "itemsLoadippedpartials", "itemsLoadedPARTially", "itemsLoadippedpartial", "itemsLoadedPartial", "itemsLoadippedPartally", "itemsLoadedpartally", "itemsLoadedpartial", "itemsLoadedPartally", "itemsLoadedCopially", "itemsLoadedPARTial", "itemsLoadedPartials", "itemsLoadedCopials", "itemsLoadedpartials", "itemsLoadippedpartally", "itemsLoadippedPartially", "itemsLoadippedPartial"]}}
{"id1": "2461169", "id2": "17792212", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "11562173", "id2": "364438", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkFileStream", " checkOutputChannel", "checkOutputStream", "checkOutputSteam", "checkOutputChannel", "checkIOStream", " checkInputSteam", "checkFileSteam", "checkIOstream", "checkFileChannel", " checkInputChannel", " checkOutputstream", " checkInputstream", "checkOutputstream", " checkOutputSteam", "checkIOChannel", "checkIOSteam", "checkInputSteam", "checkFilestream", " checkOutputStream", "checkInputChannel", "checkInputstream"], "in": ["into", "ins", "image", "In", "connection", "io", "data", "inc", "input", "din", "IN", "inn", "index", "is", "source", "ack", "reader", "src", "login", "inner", "min", "bin", "c", "con", "ic", "up", "ini", "as", "x", "plus", "comp", "again", "p", "isin"], "cmp": ["conv", "asc", "prefix", "np", "roc", "mp", "omp", "cp", "rc", "pixel", "loc", "prev", "cho", "spec", "cpp", "coll", "ch", "index", "sort", "ci", "cb", "clip", "code", "cc", "ctrl", "comment", "upp", "config", "co", "cache", "match", "pc", "amp", "c", "mom", "sup", "up", "ctx", "pre", "diff", "proc", "op", "lc", "comp", "cs", "cup", "fp", "p", "cop", "com"], "all": ["asc", "partial", "array", "default", "one", "call", "parent", "null", "except", "best", "none", "acl", "each", "allow", "not", "valid", "coll", "All", "sum", "cl", "and", "only", "process", "total", "al", "l", "a", "ann", "any", "local", "match", "ALL", "alpha", "list", "am", "global", "full", "both", "auto", "always", "p"], "stream": ["null", "speed", "Stream", "form", "this", "steam", "port", "raw", "socket", "channel", "output", "model", "impl", "document", "result", "input", "stack", "coll", "feed", "test", "temp", "instance", "progress", "source", "ack", "roll", "ream", "client", "reader", "self", "track", "src", "user", "round", "transform", "object", "trans", "string", "v", "platform", "up", "per", "host", "context", "pool", "response", "cont", "wrapper", "comp", "iterator", "sw"], "out": ["prefix", "array", "image", "copy", "null", "parent", "b", "io", "outer", "data", "project", "this", "sync", "inc", "part", "not", "output", "result", "block", "exp", "o", "index", "sum", "Out", "comment", "point", "outs", "user", "v", "bin", "c", "obj", "name", "list", "other", "option", "full", "OUT", "up", "extra", "response", "x", "again", "p"], "i": ["k", "u", "uri", "e", "j", "b", "n", "fi", "init", "io", "info", "si", "f", "it", "index", "d", "end", "key", "type", "ci", "oi", "ji", "h", "abi", "multi", "li", "di", "l", "mi", "hi", "pi", "xi", "slice", "r", "ind", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "ix", "strength", "ini", "ii", "ui", "x", "bi", "qi", "lc", "p"]}}
{"id1": "17773263", "id2": "23620712", "code1": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"visar": [" visada", "Visada", "signado", "visada", "Visado", "signando", "Visando", " visando", "visando", "Visar", "signada", "signar"], "ClassNotFoundException": ["ClassNotNullception", "ClassNotSupportedWarning", "ClassAlreadyNullError", "ClassNotSupportedException", "ClassNotFoundWarning", "ClassNotfoundWarning", "ClassNotfoundception", "ClassNotNullError", "ClassAlreadyFoundWarning", "ClassNotSupportedError", "ClassNotfoundError", "ClassNotFoundception", "ClassNotNullWarning", "ClassAlreadyNullException", "ClassAlreadyNullception", "ClassNotSupportedception", "ClassAlreadyNullWarning", "ClassNotNullException", "ClassAlreadyFoundException", "ClassNotFoundError", "ClassAlreadyFoundception", "ClassAlreadyFoundError", "ClassNotfoundException"], "Exception": ["Unknown", "Interface", "Application", "Null", "Adapter", "Response", "except", "Error", "Ex", "End", "Connection", " exception", "Engine", "Failure", "Request", "Warning", "ceptions", "Document", "Class", "Default", "Exc", "Except", "Un", "Event", "F", "Transaction", "ception"], "conn": ["sth", "rt", "cn", "col", "Connect", "conf", "n", "connection", "cp", "en", "pg", "act", "Con", "init", "rc", "session", "sql", "sync", "reg", "Connection", "sb", "connect", "sn", "mc", "nt", "coll", "ch", "nc", "ci", "s", "Conn", "cc", "cat", "oci", "config", "client", "co", "cli", " connection", "db", "ann", "con", "c", "dc", "dn", "ctx", "pub", "state", "jp", " Conn", "ca", "cs", "enc", "p"], "ps": ["pg", "rs", "py", "P", "pa", "vs", "ys", "ips", "ens", "pass", "ports", "files", "po", "pc", "cs", "ups", "pp", "bs", "ks", "ros", "pe", "pes", "js", "DS", "als", "details", "parts", "es", "qs", "eps", "ops", "sk", "jp", "ples", "pers", "post", "css", "ls", "proxy", "gets", "points", "PS", "pos", "pt", "lines", "ms", "fs", "s", "pr", "les", "pi", "ras", "ils", "ts", "gs", "http", "its", "ds", "res", "ins", "pl", "os", "ns", "pse", "ws", "Ps", "posts", "pps", "sp", "ons", "ans", "fe", "p", "cop", "changes"], "fechaSystem": ["fechabSystem", "fechAServer", "firmaSys", "fechoSys", "fichasServer", "fechaServer", "fechadasystem", "fechAsystem", "fechtaSecond", "fechanServer", "fechabServer", "fechASys", "fichasSys", "fichasSystem", "fechaSecond", "fichassystem", "fechoSystem", "fechasServer", "fechtaSystem", "fechasystem", "fuzzaSystem", "fechiSecond", "fuzztaServer", "fechanSystem", "fechaSys", "fichaServer", "fechiSystem", "fechASystem", "fechassystem", "fuzztaSystem", "fichaSys", "fichasystem", "fechadaSystem", "fechtaServer", "fuzzaServer", "firmASys", "fechiSys", "fechadaServer", "fechanSys", "fichaSystem", "fechasSys", "fichasSecond", "firmASystem", "fechasSystem", "fechasSecond", "fechtaSys", "fichaSecond", "firmaSystem"], "aaaammdd": ["aaaambDD", "aaaamds", "aaaampd", "aaaammcd", "mAambDD", "aaaaamds", "aaaamdd", "aaaamd", "aaaarmds", "aaaaammDD", "aaammds", "mAammds", "aaaarmDD", "mAammdd", "aaaammDD", "aaaambds", "aaammDD", "aaaarmcd", "aaaaammdd", "aaammd", "aaaaammds", "aaaambcd", "aaaajDD", "aaaajds", "aaaaamdd", "aaammdd", "aaaampds", "aaaajdd", "aaaampdd", "aaaampDD", "aaaamDD", "aaaammds", "aaaammd", "mAammcd", "aaaambdd", "mAambds", "mAambdd", "aaaajcd", "aaaaamd", "aaaarmdd", "mAammDD", "aaaaamDD", "aaaaammd", "mAambcd"], "hhmmss": ["hhhmmrss", "hmmyiss", "hhcmps", "hhmmmps", "hhmmmss", "hhhmrss", "hhhmss", "hhMMrss", "hhmyds", "hhmmmess", "hhMMess", "hhhmmps", "hhmmds", "hhhmmess", "hhcmiss", "hhhmmss", "hmmmds", "hmmmiss", "hhmss", "hhMMss", "hhmmrss", "hhcmds", "hhMMiss", "hmmyps", "hhhmess", "hhmmmrss", "hhmess", "hhmmps", "hhmmiss", "hmmyds", "hhmps", "hhMMds", "hhmrss", "hhmyss", "hhmyps", "hhMMps", "hmmyss", "hhmmess", "hhmyiss", "hmmmss", "hmmmps", "hhhmps", "hhcmss"], "sss": ["SSp", "ussps", "issps", "SSps", "ussns", "\u00dfh", "csss", "SSb", "SSns", "ssp", "cssp", "cssh", "ssls", "\u00dfb", "usss", "ssns", "issls", "ssps", "SSs", "cssb", "isss", "\u00dfp", "ssb", "SSh", "ssh", "SSls", "issns", "ussls", "\u00dfs"], "ss": ["css", "ls", "ess", "rss", "ssl", "txt", "sf", "se", "tz", "sv", "rs", "ns", "si", "sql", "oss", "dd", "sb", "status", "spec", "sn", "vs", "su", "us", "password", "ys", "SS", "s", "ng", "pass", "ws", "hh", "xx", "WS", "ses", "sc", "ass", "string", "iss", "hess", "less", "mm", "sl", "sel", "ssh", "\u00df", "bs", "sw", "nn", "ds"], "sentenciaSql": ["sentenciaJsse", "sentenciaDq", "sentenciaAsse", "senticioDsl", "sentenciaDsl", "senticioDq", "senticioDql", "sentenceSse", "sentenciaAsql", "sentenceAsQL", "sentenciaJsq", "sentenciaAssl", "sentenciaSq", "senticioDQL", "sentenceSQL", "sentenciaJsQL", "sentenciaSse", "sentenciaPresse", "sentenciaPsq", "sentenciaAsQL", "sentenceAsq", "sentenceSq", "sentenceAsse", "senticioSq", "sentenciaAsq", "sentenciaJsql", "sentenciaDql", "sentenciaPssl", "sentenceSql", "sentenciaPresQL", "sentenciaDQL", "sentenciaSQL", "sentenceAsql", "sentenciaPresql", "senticioSQL", "sentenciaPsql", "senticioSql", "sentenciaPresq", "sentenciaPsQL", "sentenciaSsl", "senticioSsl"], "contador": ["captator", "Controy", "contoder", "constander", "contoor", "constator", " contada", "contato", "captoration", "constato", " contrador", "Contoration", "contoration", "ontator", "constorno", "constoder", "controy", " Contada", "contada", "captander", "collectador", "ontador", "captorno", "Contato", "constador", "contorer", "contorno", "captoor", "Contorer", " container", "constainer", "constroy", " Contador", "Contazar", "ontroy", "container", "collectander", "constoor", "collectator", "constrador", " contazar", "collectoor", "contander", "ontrador", "catator", "catoration", " contator", "captato", " controy", " Contorno", "catoder", "constoration", "Contator", "contazar", "contator", " contoration", "constazar", "Contador", "Contada", "contrador", " contorno", "Contorno", "captador", " Controy", "Container", " contorer", "constorer", "Contoder", "catador"], "visado": ["Visada", "VISado", "visada", "Visado", "Visato", "visados", "missado", "VISados", "VISato", "visato", "missados", "missada", "missato", "VISada", "Visados"]}}
{"id1": "22135199", "id2": "149935", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCachingEmptyStream", "testCodingOfFile", "testCodingOfStream", "testCodingOfSourceFile", "testCodingEmptyFiles", "testCodingZeroFile", "testCodingZeroSourceFile", "testCachingEmptyFile", "testCachingOfSourceFile", "testCodingEmptySourceFile", "testCodingNoStream", "testCachingEmptySourceFile", "testCodingEmptyStream", "testCachingOfFile", "testCodingNoFile", "testCachingOfStream", "testCodingZeroFiles", "testCodingNoFiles", "testCodingZeroStream", "testCodingOfFiles", "testCachingEmptyFiles", "testCachingOfFiles", "testCodingNoSourceFile"], "baos": ["kaos", "buoa", "paOS", "baOs", "bao", "BaOS", "baotes", "waOs", "BaoS", "kao", "pao", " baotes", "aaaaOs", "waos", "waoS", "Baos", " baoS", "baoes", "biotes", "buo", "aaaaoS", "baOS", "buos", "waOS", "aaaaos", "Baotes", " baoes", "aaaaOS", "baoa", "bioS", "buOS", "BaOs", "kaOS", "bioes", "kaoa", "bios", "paoa", "paos", "baoS", "Baoes"], "channel": ["log", "console", "annels", "url", "flow", "server", "parent", "system", "connection", "cam", "an", "io", "data", "cho", "socket", "group", "ch", "bean", "container", "out", "conn", "sea", "source", "chan", "config", "reader", "client", "stream", "self", "can", "queue", "sc", "video", "handler", "c", "service", "context", "camera", "feed", "Channel"], "params": [" param", "css", "param", "null", "cmp", " parameters", "par", "Param", "ps", "stats", "options", "parser", "tx", "Parameters", "settings", "conn", "api", "config", "cms", "size", "Par", "cpu", "mm", "ams", "ops", "ctx", "proc", "http", "processor"], "outbuf": ["outputbuff", "outputqueue", "inputbuf", "inputqueue", "inputbuff", "outqueue", " outbuffer", " outbuff", " outqueue", "Outbuffer", "outbuff", "inputbag", "outputbuf", " outbag", "outputbuffer", " outcb", "outcb", "Outbuff", "Outbuf", "outbag", "outbuffer", "outputcb", "Outcb", "outputbag"], "metrics": ["monras", "monric", "matrics", "Metric", "monrics", "metrix", " metrix", " metric", "Metals", "matals", "metics", "matric", "monics", " metics", "Metrix", "Metras", " metras", "matrix", "metras", "metric", "metals", "Metics", "Metrics", " metals"], "encoder": ["ecoded", " enccode", "ecoder", "enoder", "encipher", "encressor", "Encipher", "enoser", "enoded", "ecler", "ecressor", " encipher", " encler", "encoser", "eccode", "encode", " encoded", "Encode", "enccode", " encressor", " encoding", "ecipher", " encoser", "enode", "Encler", "Encoded", "encoded", "Encoder", "encoding", "ecoser", "ecoding", "encler", " encode", "enressor", "Encoser", "Encoding", "ecode"], "tmpFile": ["vtfile", "mpFilename", "mpfile", "mpFile", " tmpFolder", " tmpPath", "mpPath", "tempPath", "tmpFolder", "tmpFilename", "tmpfile", "tempFile", "tmpFiles", "mpFunction", "testFolder", "tempFiles", " tmpFiles", "tempFolder", "tmpFunction", "poraryFunction", "tmpPath", "mpDir", "vtDir", "mpPage", "vtFilename", "txtFunction", " tmpFilename", " tmpfile", "testfile", "poraryPage", "poraryFile", "poraryfile", "txtPage", " tmpDir", "tempfile", "vtFile", "tmpPage", "txtFile", "testFiles", "mpFiles", "tmpDir", "testFile", "txtfile"], "fout": ["sfout", "furl", "flout", "fio", "fagain", "fdout", "fragain", "frurl", "Fchannel", "Fio", "sfchannel", "flwrite", "fdwrite", "frout", "fwrite", "frwrite", "Fout", "flagain", " ffile", "sffile", "sfio", "ffile", "flurl", "Ffile", " fio", "fdagain", "fdurl"], "wrtout": ["wadrwriter", " wrtin", "wrtagain", "wrdout", "WRTn", "wrcin", "wrout", "Wrtout", " wrcagain", "wadragain", "wRTout", " wrcin", "Wrtwriter", "wrtwriter", " wrcouter", "wrcout", "wRTin", "wadrouter", "wRTouter", "wrcn", "WRTouter", "WRTwriter", "wrdin", "wrtin", "wadrout", "Wrtn", "wrtn", " wrtagain", "wadrin", "wrcOut", "wrOut", "Wrtin", "wrdwriter", "wrin", "WRTout", "wRTOut", "wrcouter", "WrtOut", "wRTn", "wrcagain", "wrtouter", " wrcout", " wrtouter", "WRTin", "wRTwriter", "Wrtouter", "WRTOut", "wRTagain", "wrn", "wrtOut", "wrdouter"], "fchannel": ["pqueue", "hresource", "bchan", "fenresource", " fcontainer", " fconn", "fcontainer", "bchannel", "fresource", "fchan", " fchan", "bconn", "fconn", "pchan", "fenchannel", "fenqueue", "hstream", "pstream", "pchannel", "fqueue", "pconn", "presource", "bcontainer", "fstream", "hchannel", "fenstream", "hqueue", "pcontainer"], "s": ["ls", "m", "u", "js", "ins", "e", "b", "g", "ss", "n", "ps", "os", "ns", "f", "es", "ings", "o", "su", "ms", "settings", "i", "l", "qs", "states", "r", "ses", "S", "string", "v", "c", "t", "ts", "gs", "abs", "services", "strings", "p"]}}
{"id1": "6190356", "id2": "9099457", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForNewMD3", " hashPasswordForNewMD5", " hashPasswordForNewM3", " hashPasswordForOldMC3", " hashPasswordForOldMD512", " hashPasswordForNewM512", " hashPasswordForNewM4", " hashPasswordForOldmd5", " hashPasswordForNewMD4", " hashPasswordForOldmd4", " hashPasswordForOldmd512", " hashPasswordForOldMC5", " hashPasswordForOldMC512", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForNewM5", " hashPasswordForOldMD3", " hashPasswordForOldMD4", " hashPasswordForOldM3", " hashPasswordForOldMC4", " hashPasswordForOldM512", " hashPasswordForOldM4", " hashPasswordForOldmd3"], "password": ["crypt", "secret", "text", "padding", "pad", "array", "auth", "message", " passwords", "data", "username", "sword", "phrase", "result", "hash", "input", "encrypted", "key", "wd", "wallet", "pass", "code", "seed", "address", "token", "string", "account", "name", "pattern", "words", "path", "word", "content", "buffer", "value", "Password", "p", " Password", "PASS"], "md": ["m", "rm", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "um", "dig", "dd", "km", "gd", "f", "managed", "rpm", "mc", "mag", "d", "vd", "od", "mb", "meta", "hm", "wd", "nm", "amd", "dm", "bd", "metadata", "pd", "MD", "di", "mac", "ind", "mand", "mm", "ma", "dc", "am", "pm", "grad", "mt", "cd", "clean", "vm", "mod", "df"], "messageDigest": ["messageModester", "messagedigests", "messageAddse", "MessageDigEST", "MessageDigest", "messageAddester", "messageAddEST", "messageModEST", "messagedigest", " messageModester", " messageModEST", "messageAddests", "MessageModse", "messageDest", "messagedigester", "MessageAddse", "messageDEST", "messageAddest", "MessageDigse", " messageDigester", "messageModest", "MessageModester", " messageModest", "messageModse", "MessageModest", " messageDigEST", "messagedigEST", "messageDigse", "MessageAddester", "MessageAddest", "messagedigse", "messageDigests", "MessageDigester", "messageModests", "messageDigEST", "MessageAddEST", "messageDester", "MessageModEST", " messageDigests", "messageDse", "messageDigester", " messageModests"], "hexString": ["stringSection", "stringService", "crossstring", "stringString", " hexstring", " hexFunction", "crossFunction", "sumstring", "octBuffer", "hexBuffer", "transformStr", " hexFile", "transformString", "tempFile", "hexstring", "hexService", "stringArray", " hexStr", "transformBuffer", "tempString", "hexArray", "hexStr", "hashString", "hashSection", "transformArray", " hexArray", "hashService", "crossStr", "tempStr", "sumString", "sumFile", "tempstring", "octStr", "octString", " hexService", " hexSection", "hexFunction", "octArray", "hexSection", "tempFunction", "hexFile", "hashArray", " hexBuffer", "crossString", "sumStr"], "i": ["k", "m", "p", "u", "uri", "e", "j", "length", "b", "n", "fi", "io", "info", "si", "f", "o", "index", "d", "ci", "h", "oi", "s", "ji", "multi", "li", "a", "l", "di", "ip", "pi", "xi", "slice", "r", "id", "ti", "v", "c", "t", "ix", "I", "ai", "phi", "ii", "ui", "x", "bi", "qi", "ri"], "hex": ["text", "ex", "he", "pack", "default", "hack", "length", "null", "cmp", "letter", "form", "pixel", "none", "rh", "data", "nexus", "bit", "hello", "raw", "cookie", "result", "hash", "str", "exp", "digit", "batch", "shift", "utf", "h", "temp", "pex", "buff", "ip", "oct", "lit", "transform", "cache", "sex", "string", "character", " Hex", "alpha", "binary", "host", "full", "pattern", "json", "path", "comp", "zero", "orig", "serial", "rex", "format", "http", "char"]}}
{"id1": "16466743", "id2": "3309233", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "label": 0, "substitutes": {"getmd5": [" getMD5", "getmn5", " getmd512", " getmd6", "getmd512", " getMD12", "getmetadata12", "getMD5", " getmd12", "getmetadata5", "getMD6", "getMD512", " getMD512", "getMD12", "getmd12", " getMD6", "getmd6", "getmn6", "getmetadata512", "getmn12", "getmn512", "getmetadata6"], "password": ["secret", "crypt", "text", "padding", "prefix", "attribute", "auth", "array", "pad", "message", " passwords", "data", "username", "sword", "phrase", "f", "hash", "input", "encrypted", "key", "wd", "pass", "config", "login", "number", "address", "token", "string", "account", "email", "name", "pattern", "words", "path", "word", "buffer", "Password", "p", " Password", "PASS"], "pwHash": [" pwaHash", "PWMac", "qwSum", "qwDig", "qxHash", " pwSum", " pwDig", "PwBlock", "qxSum", "pwBlock", "pwaDig", "pweHash", "pwhMac", "PWHash", "pwtMac", "pWBlock", "pwaSum", "pwdHash", " pwaSum", "pwtHash", "pwdDig", "pwhSum", " pwahash", "pweDig", "pWSum", "pxDig", "pwdSum", "pwehash", "qxMac", "pWMac", "pwMac", "pwdMac", "pxHash", "pwSum", "qxDig", " pwhash", "pxMac", "pwDig", "pwdhash", "pwtBlock", "qwMac", "pweSum", "pWHash", "PWSum", "PWBlock", "pwtSum", "pwhBlock", "PwMac", "pwhash", " pwaDig", "pwaHash", "pwahash", "qwHash", "pwaMac", "PwHash", "pwhHash", "PwSum", "pxSum"], "md": ["m", "rm", " MD", "Cmd", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "hash", "mc", "mag", "d", "od", "mage", "ms", "mb", "hm", "nm", "meta", "amd", "mg", "dm", "bd", "me", "cm", "metadata", "bm", "pd", "MD", "mi", "db", "ad", "mac", "mand", "mm", "sm", "ma", "dc", "am", "ld", "pm", "kg", "M", "mt", "cd", "mu", "mod"], "b": ["buf", "p", "u", "e", "emb", "fb", "lb", "sb", "f", "bis", "d", "rb", "batch", "bytes", "mb", "cb", "bf", "B", "bd", "a", "buff", "l", "reb", "db", "base", "r", "ib", "ba", "orb", "br", "bin", "gb", "be", "binary", "ob", "wb", "bi", "buffer", "ab", "nb", "eb", "bs", "bb"], "i": ["u", "z", "uri", "e", "j", "n", "io", "info", "data", "si", "f", "it", "ni", "block", "o", "index", "d", "ci", "h", "oi", "s", "ji", "abi", "multi", "li", "a", "l", "di", "ip", "pi", "xi", "base", "vi", "slice", "r", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "zi", "phi", "chi", "ii", "ui", "x", "bi", "mu", "qi", "p"]}}
{"id1": "18731843", "id2": "10361370", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "label": 0, "substitutes": {"doBody": ["DoResponse", " doFile", "doResponse", "doBytes", "handleResponse", "DoFile", "handleBytes", " doBytes", " doResponse", "DoBody", "handleBody", "doFile", "DoBytes", "handleFile"], "req": ["rec", "res", "rss", "crit", "respond", "fr", "report", "resource", "rx", "requ", "rh", "info", "data", "this", "sem", "reg", "spec", "ref", "Request", "conn", "download", "src", "config", "reader", "rr", "r", "err", "obj", "qt", "def", "proc", "qq", "query", "jp", "comp", "q", "http", "serv", "request", "cgi"], "resp": ["prot", "rec", "bb", "res", "request", "p", "respond", "report", "html", "b", "Response", "cmp", "data", "rev", "respons", "part", "pos", "result", "reply", "ref", "job", "cb", "val", "download", "Resp", "api", "rr", "inv", "r", "cache", "err", "obj", "re", "pre", "sp", "proc", "ret", "response", "jp", "comp", "exc", "serv", "rep"], "bis": ["tis", "bb", "bid", "phis", "isin", "pins", "b", "os", "obs", "ori", "lis", "fb", "mis", "bh", "atis", "nis", "usb", "uds", "sb", "obi", "lins", "iris", "abi", "ios", "is", "oris", "bes", "sin", "alis", "obos", "ses", "bits", "iss", "los", "ais", "bin", "ris", "bas", "rots", "sis", "bian", "binary", "obb", "bi", "ois", "bs", "boot", "bps", "ubis"], "bos": ["tis", "ros", "oros", "phis", "fits", "os", "obs", "las", "bh", "osi", "uds", "osa", "obo", "aos", "oks", "zos", "obi", "lins", "bott", "oses", "bo", "oS", "ios", "lol", "abi", "bes", "zo", "opus", "bris", "obos", "oos", "bits", "mos", "los", "bin", "bones", "bas", "ops", "obb", "bi", "oops", "antis", "ois", "bs", "boot", "bps", "ubis"]}}
{"id1": "5723876", "id2": "19276022", "code1": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"calculate": ["calculation", "Calculate", "calcates", "calcate", "Calgenerates", "calacates", "Calgeneration", "calgenerated", "Calculated", "calculates", "calgenerates", "calcation", "Calgenerate", "calcated", "Calculation", "calacate", "calgeneration", "calacated", "Calculates", "calculated", "Calgenerated", "calacation", "calgenerate"], "f": ["fd", "m", "lf", "e", "sf", "n", "fed", "fb", "data", "fa", "d", "ref", "feed", "h", "fs", "s", "tf", "bf", "i", "filename", "a", "l", "files", "r", "v", "c", "file", "af", "t", "w", "fc", "F", "x", "fe", "fp", "p", "df"], "md": ["ds", "mad", "m", "rm", "hd", " MD", "Cmd", "mp", "dr", "cmd", "sha", "mid", "mo", "dig", "dd", "gd", "rpm", "med", "mc", "mag", "d", "vd", "od", "meta", "mb", "hm", "wd", "amd", "mg", "dm", "bd", "metadata", "cm", "pd", "MD", "di", "mn", "db", "ad", "mand", "ud", "mm", "sm", "ma", "ld", "am", "pm", "grad", "cd", "vm", "mail", "mod", "df"], "rd": ["fd", "rt", "red", "rm", "fr", "rob", "nd", "rx", "xd", "ring", "ru", "dr", "RR", "rc", "rs", "rh", "RL", "mid", "dd", "rolog", "rn", "rb", "d", "erd", "rg", "RS", "RD", "rw", "bd", "reader", "pd", "src", "rl", "rr", "r", "ind", "ird", "az", "dra", "rod", "td", "ld", "cd", "ra", "RF", "RM", "rf", "ds"], "buffer": ["wave", "buf", "uf", "array", "writer", "url", "message", "null", "fb", "data", "Buffer", "raw", "bc", "output", "sb", "document", "input", "map", "pb", "stack", "rb", "read", "rf", "row", "bf", "builder", "iter", "source", "reader", "driver", "header", "memory", "buff", "db", "base", "queue", "r", "cache", "address", "string", "binary", "uffer", "feed", "bb", "database", "df"], "line": ["sample", "page", "LINE", "text", "pe", "log", "url", "lf", "message", "one", "le", "style", "body", "letter", "lock", "item", "cell", "data", "link", "sync", "L", "raw", "part", "no", "entry", " Line", "str", "lin", "cl", "lines", "nl", "key", "end", "row", "inline", "code", "pass", "job", "column", "comment", "source", "header", "l", "len", "base", "id", "file", "Line", "name", "response", "lc", "block"], "digest": ["codeter", "genester", "mdester", "ddest", " digEST", "DigEST", " digeter", "Digeter", "Digester", "digEST", "Digest", " digested", "sumest", "sumHash", "mdested", "genHash", " digests", " digester", "codest", "digeter", "Digested", "ddested", "digester", "ddests", "sumested", "Digests", "sumester", "digests", "ddEST", "digested", "mdHash", "mdest", "genested", "digHash", "genest", "codester", "codested"], "result": ["page", "text", "res", "array", "description", "url", "default", "report", "message", "resource", "length", "data", "search", "output", "rule", "answer", "str", "valid", "test", "dict", " Result", "results", "pass", "comment", "future", "instance", "work", "Result", "r", "match", "string", "err", "card", "success", "repl", "continue", "ret", "function", "response", "runner", "value", "content", "cup", "compl", "use"], "b": ["bb", "k", "e", " eb", "g", " B", "body", "bit", "sb", "pb", "d", "rb", "h", "cb", "s", "code", "B", " base", "i", "a", "l", "number", "base", "r", " block", "ba", "v", "br", "c", "gb", "be", "name", "binary", "bi", "bs", "p"]}}
{"id1": "2518655", "id2": "8216539", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"fnOut": ["fpOutput", "fnEx", "lsOutput", "fnIn", "FNOut", "lsOut", "FNIn", "FNOutput", "lsOUT", " fnOUT", "fpEx", "fpOUT", "FNEx", " fnFile", "fnOutput", " fnIn", "fnOUT", "fnFile", "fpFile", " fnOutput", " fnEx", "fpOut", "fpIn", "lsFile"], "writer": ["fd", "widget", "wr", "write", "server", "outer", "writing", "parser", "socket", "writ", "output", "entry", "winner", "editor", "Writer", "key", "out", "ws", "temp", "nw", "builder", "driver", "reader", "war", "riter", "a", "work", "er", "worker", "inner", "usher", "walker", "r", "wa", "handler", "file", "wire", "loader", "w", "per", "writers", "layer", "ler", "word", "buffer", "director"], "i": ["k", "m", "u", "z", "uri", "e", "j", "b", "n", "fi", "ori", "io", "si", "ie", "part", "f", "o", "index", "ci", "h", "type", "s", "iu", "oi", "key", "abi", "ji", "multi", "li", "di", "mi", "ip", "pi", "hi", "xi", "eni", "id", "ti", "v", "gi", "c", "ri", "I", "ai", "ix", "phi", "chi", "ii", "ui", "x", "bi", "ini", "qi", "strength", "p"], "fInput": ["fFormat", " fFormat", "sfinput", "finput", "sfFormat", " fOutput", "fSource", " finput", "fileinput", "fileFormat", "fileInput", "fileSource", "sfInput", "fOutput", "sfSource", "sfOutput", "fileOutput", " fSource"], "in": ["ln", "ins", "In", "b", "n", "connection", "scan", "init", "data", "version", "ner", "reading", "inc", "socket", "f", "gin", "input", "vin", "din", "IN", "inn", "lin", "inas", "out", "s", "conn", "cin", "sin", "kin", "rin", "reader", "win", "inside", "nin", "login", "inner", "min", "id", "bin", "c", "pin", "ini", "again", "line", "isin"]}}
{"id1": "19584877", "id2": "14231545", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "21181542", "id2": "5808579", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 0, "substitutes": {"deleteRoleType": [" deleteRoletype", "deleteroleType", "deleteRoletype", "deleteResourcetype", " deleteRoleTyp", "deleteFunctionType", "deleteRoleTyp", " deleteroleTypes", "deleteroleTyp", "deleteResourceType", " deleteroleType", "deleteroletype", "deleteroleTypes", "deleteResourceTypes", "deleteFunctiontype", "deleteResourceTyp", " deleteRoleTypes", "deleteRoleTypes", " deleteroletype", "deleteFunctionTypes", "deleteFunctionTyp", " deleteroleTyp"], "id": ["ID", "url", "uri", "kid", "parent", "length", "vid", "view", "connection", "lock", "like", "data", "info", "version", "mid", "sid", "part", "in", "model", "it", "f", "aid", "Id", "index", "pid", "error", "key", "type", "end", "rid", "code", "uid", "source", "i", "is", "section", "edit", "ip", "ids", "object", "address", "string", "start", "name", "path", "ident", "oid", "request"], "namespaceId": ["namespacesInfo", "namespaceContext", "namespacedInfo", "memberspaceId", "asentityName", "namesspaceId", "membersetId", "nspaceid", "namespacedType", "namesaceID", "namesentityName", "asentityInfo", "namesaceInfo", "nspaceId", "namespacesid", "namesenceType", "workspaceType", "memberspaceType", "NamespaceId", "aspaceID", "workspacesid", "workspaceKey", "memberspaceName", "namespaceKey", "namespacesContext", "namespacesID", "namesetid", "namesentityID", "Namespaceid", "workspaceInfo", "namesentityId", "namesaceId", "nspaceID", "aspaceName", "namesplaceid", "namesetId", "namesenceId", "namesspaceKey", "membersetid", "workspacesId", "workspacePath", "worksspacePath", "workspaceId", "namespacesKey", "workspacesType", "namespaceid", "worksspaceId", "namespacedId", "workspaceid", "workspaceContext", "namespacesName", "nsaceid", "namesaceid", "worksspaceInfo", "namespacedName", "NamespacedType", "namesplaceInfo", "NamespaceName", "namesspaceInfo", "namespacedKey", "namesentityInfo", "namesenceid", "NamespaceType", "namesaneName", "namesetID", "namespacePath", "namespaceType", "Namespacedid", "namesaceType", "namespacedid", "nsaceID", "aspaceInfo", "namesplaceId", "membersetName", "NamespacedName", "namespaceInfo", "nspaceInfo", "nsaceInfo", "namespaceID", "namesetInfo", "namesaneId", "namespaceName", "namesetType", "worksspaceKey", "NamespacedId", "namesspacePath", "nsaceId", "workspacesContext", "namesenceContext", "asentityId", "namespacedPath", "namesaneType", "namesaneid", "memberspaceid", "membersetType", "asentityID", "aspaceId", "namesplaceID", "namespacesType", "namespacesId", "namesaceContext", "namespacesPath", "namesetName"], "removeReferencesInRoleTypes": ["removeReferencesFromRoleNames", "removeReferencesInroleRelations", "removeReferencesInRoleType", "removeReferencesInServiceRelations", "removeReferencesedInroleType", "removeReferencesedInroletypes", "removeReferencesInServiceType", "removeReferencesInRoletypes", "removeReferencesInRuleType", "removeReferencesedInRoleTypes", "removeReferencesFromRoleRelations", "removeReferencesedInRoleNames", "removeReferencesInRuleRelations", "removeReferencesFromroleNames", "removeReferencesedInroleTypes", "removeReferencesInServiceNames", "removeReferencesedInroleNames", "removeReferencesInRoleNames", "removeReferencesFromroleTypes", "removeReferencesInRoleRelations", "removeReferencesInroleType", "removeReferencesInServiceTypes", "removeReferencesFromroleRelations", "removeReferencesInRuleTypes", "removeReferencesFromroleType", "removeReferencesInRuleNames", "removeReferencesInroletypes", "removeReferencesInroleTypes", "removeReferencesedInRoletypes", "removeReferencesedInRoleType", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInRuletypes", "removeReferencesFromRoleType"], "permit": ["permits", "permmissions", "Permissions", "perMIT", "PERMIT", "PerMIT", "permission", "recmits", "permMIT", " perit", "Perit", "Permit", "permmit", "recmit", "recmission", "Permits", " permission", "Permission", "permissions", " permits", "perit", "PERmission", "permmission", "PERmissions", "recit", "PERmit"], "exist": ["purpose", "icate", "include", "write", "apply", "cmp", "except", "form", "destroy", "know", "stick", "inc", "draw", "check", "fail", "index", "support", "fill", "existence", "create", "add", "ist", "register", "keep", "edit", "delete", "same", "present", "match", "start", "list", "continue", "destruct", "existing", "diff", "existent", "cont", "ident", "front", "update"], "msgBuf": [" msgBuff", "msgEBuff", " msgFuf", "msgPlaf", "messageFbox", "msgPluf", "msgEBuf", " msgFbuf", "messageBbuf", "msgDuff", "msgAUF", "msgBbox", "msgFBUF", "messageFbuf", "msgDBuff", "msgBbuf", "msgFuf", "messageAuf", "msgFundle", "msgFbox", "msgDbuf", "msgDaf", "msgBob", "msgBraf", "msgLuff", "msgBUF", "msgDBuf", "messageAbuf", "msgPluff", " msgLaf", "msgLuf", "msgFBob", "msgEBbuf", "msgFBuff", "msgCuf", " msgLuff", "messageBuf", "msgLUF", "msgCuff", " msgFuff", "msgLaf", "msgLundle", "msgFUF", "msgFBuf", "msgBaf", "msgAraf", "messageBuff", "messageFob", "msgAuf", " msgFraf", "messageFUF", "messageBob", "msgAuff", "msgFbuf", " msgBundle", "messageBbox", "msgAbox", "msgDuf", "msgFob", "msgCob", "msgBundle", "msgLob", "msgAbuf", "msgAob", "msgAbuff", " msgBbuf", " msgFbuff", "msgFaf", " msgLundle", "msgBbuff", "msgFuff", " msgBaf", " msgFaf", "messageFuf", "messageFuff", " msgBbuff", "messageBUF", "msgFbuff", "msgAaf", "messageAuff", "msgBuff", " msgLuf", "messageAUF", "msgDBbuf", "msgFraf", " msgBraf", "msgEBbox", "msgCbuf", "msgDBUF", "msgPlundle"], "objects": ["notes", "values", "keys", "ins", "people", "pins", "kids", "archives", "products", "owners", "points", "os", "obs", "links", "users", "jobs", "parts", "cats", "relations", "archs", "oids", "agents", "apps", "plugins", "groups", "organisms", "parents", "features", "classes", "projects", "lines", "children", "results", "images", "properties", "pps", "files", "resources", "ids", "object", "frames", "names", "articles", "models", "obj", "bugs", "cells", "locks", "actions", "ops", "blocks", "types", "boxes", "members", "phones", "items", "ks", "roots"], "sqlRightId": ["sqlrightId", "sqlRightRef", "sqlRightPoint", "sqlRightType", "SQLRightID", "sqlRestId", "sqlRRef", "sqlRID", "sqlrightPoint", " sqlrightid", "sqlRestID", "SQLRightRef", "SQLRestID", "SQLRestId", "SQLRestid", "sqlLeftid", " sqlRightPoint", "sqlRId", " sqlrightId", "SQLRightid", "SQLRightId", "sqlRightID", "sqlRightid", " sqlrightPoint", "sqlrightid", "SQLRestRef", "sqlRestRef", " sqlrightType", "sqlLeftType", "sqlrightType", "sqlLeftId", "sqlLeftPoint", " sqlRightid", "sqlRestid", "sqlRid", " sqlRightType"], "sqlParent": [" sqlparent", "qlRoot", "suparent", "qlparent", "sqlParents", "suParents", " sqlRoot", "suParent", "qlParent", "suRoot", " sqlParents", "sqlparent", "qlParents", "sqlRoot"], "sql": ["replace", " db", "description", "log", "url", " SQL", "acl", "msg", "link", "session", " params", "error", " session", "conn", "s", "dl", " url", "delete", "db", "select", "repl", "sl", "operation", " msg", "where", "update", "SQL", "ql"], "pstmt": ["pctbl", " pSttr", "pftr", "pStm", " pndmt", "pndmb", "Pcttr", " pstmb", "pstatnt", " pStmt", "pctmb", "pmtbl", "postnt", " pstnt", "New", "pStct", "Security", "pmtmb", " pStm", "Pctct", "pstbl", "_", "pstrtr", "this", "pstm", "All", "pfct", "pStmt", " pStct", "add", "pstrm", "Pctmd", "pstmd", "pctmr", "Pstct", " pstmr", "pctm", "psttr", " pndmb", "pctct", "Pstmd", "postct", "Pctmt", "s", " pndct", " pstbl", "pndct", "pmtct", "pfmt", "pstatmt", "postmr", " postnt", "pmtmd", "pfmd", "pstatct", "Pstmt", "pstmb", "pstatmr", " pstm", "pctmd", "pmtmt", "pstmr", "pndbl", "The", "postmt", " pstct", "Error", "pstct", "pstnt", "pstrmt", "pctnt", "pSttr", "pndmt", " pndbl", "delete", " postmt", " postmr", "pstrct", " psttr", "pmttr", "pctmt", " postct", "Delete", "Psttr", "pcttr"], "typeGid": ["typegID", "linkGid", "linkGID", "TypeCmin", "TypeCID", "linkGoid", "typeGUid", "typeGVID", "typeGUname", "typegname", "TypeGmin", "typeGmin", "typeAccid", "typeWID", "TypeGid", "linkGname", "typeCname", "typeGname", "TypeCname", "TypeGname", "typegid", "typeGoid", "linkGVID", "TypeGID", "typeGVoid", "typeGID", "typeGUoid", "linkGVid", "typeWid", "linkGVoid", "TypeCid", "linkGVname", "typegoid", "typeGUID", "typeCmin", "typeGVid", "typeCID", "typeAccID", "typeAccname", "typeAccmin", "typeWname", "typeWmin", "typeCid", "typeGVname"], "defaultLevel": ["configDepth", "configCl", " defaultCl", "DefaultLevel", "defaultCl", "defaultMode", "configMode", " defaultDepth", "configLevel", "DefaultCl", "defaultDepth", " defaultMode", "DefaultDepth", "DefaultMode"], "success": ["warning", "replace", "resp", "message", "successfully", "complete", "failed", "successful", "data", "reg", "status", "result", "fail", "launch", "batch", "error", "accept", "test", "results", "Success", "progress", "roll", "match", "submit", "continue", "response", "serial"]}}
{"id1": "21016435", "id2": "8079516", "code1": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"getFullScreenUrl": ["getFullscreenImage", "getFullScreenURL", "getFullScreenImage", "getFullScreenLink", "getFullscreenURL", "getFullscreenLink", "getFullscreenUrl"], "u": ["ur", "nu", "uri", "lu", "e", "uc", "uu", "ru", "n", "b", "ul", "ut", "universal", "uv", "f", "o", "su", "d", "iu", "uni", "uid", "cu", "a", "l", "base", "user", "r", "c", "tu", "up", "U", "ou", "hu", "ui", "util", "p"], "conn": ["conv", "rt", "ssl", "nn", "fr", "cn", "ct", "b", "g", "n", "connection", "conf", "lock", "loc", "rc", "cp", "pg", "en", "act", "cmd", "session", "sync", "reg", "Connection", "syn", "pt", "connect", "URL", "rn", "ch", "coll", "nc", "cb", "out", "Conn", "api", "rl", "client", "cli", "l", "db", "ann", "util", "r", "exec", "con", "c", "dc", "dn", "ld", "net", "ctx", "pub", "path", "Url", "enc", "http", "dh", "p", "open", "serv"], "line": ["page", "LINE", "log", "frame", "lf", "message", "one", "label", "le", "write", "style", "letter", "item", "cell", "profile", "link", "sync", "shell", "part", "entry", "f", "definition", "str", "lin", "cl", "nl", "error", "type", "key", "el", "end", "val", "row", "inline", "band", "comment", "job", "parse", "pass", "section", "header", "li", "l", "len", "base", "user", "object", "id", "look", "string", "file", "Line", "name", "sl", "pin", "lc", "feed", "block"], "data": ["DATA", "page", "text", "uri", "photo", "message", "resource", "image", "arr", "html", "style", "body", "info", "single", "parts", "part", "output", "pos", "stuff", "result", "area", "input", "str", "dat", "bytes", "inline", "type", "meta", "home", "download", "code", "results", "source", "action", "api", "media", "di", "a", "base", "ata", "string", "json", "picture", "response", "content", "buffer", "format", "state", "feed", "space"], "fullUrl": ["shorturl", "completeURL", "FullPath", "shortURL", "shortUrl", "shortPath", "fullurl", "FullURL", "Fullurl", "fullURL", " fullurl", " fullURL", " fullPath", "completeurl", "completeUrl", "completePath", "fullPath", "FullUrl"], "url": ["ur", "ls", "fl", "ssl", "uri", "ll", "image", "server", "resource", "fr", "b", "connection", "cdn", "rel", "blog", "channel", "f", "impl", "connect", "www", "URL", "nl", "download", "pull", "api", "rl", "client", "l", "stream", "lr", "r", "con", "obj", "sl", "host", "Url", "lc", "http", "open"], "rd": ["fd", "rt", "rm", "rss", "fr", "xd", "rob", "rx", "nd", "ru", "dr", "mr", "rc", "rs", "rh", "dig", "dd", "director", "gd", "Reader", "vd", "rn", "rb", "erd", "rg", "wd", "RS", "RD", "rw", "bd", "reader", "pd", "rl", "rr", "lr", "r", "ird", "adr", "dra", "td", "ld", "RF", "cr", "ri"], "start": ["art", "pad", "Start", "count", "offset", "st", "info", "last", "pos", "in", "limit", "it", " Start", "no", "check", "set", "index", "end", "stop", "time", "is", "starting", "max", "size", "id", "next", "from"], "lines": ["ls", "forms", "values", "scenes", "rows", "pins", "ins", "items", "points", "books", "links", "sites", "ns", "parts", "lists", "shows", "cases", "dates", "loads", "sections", "plugins", "groups", "lins", "verts", "comments", "split", "elines", "ines", "breaks", "balls", "ips", "lights", "objects", "posts", "flows", "works", "plays", "les", "vals", "qs", "pps", "files", "pages", "states", "ids", "steps", "mails", "bands", "models", "codes", "tests", "xs", "cells", "rules", "blocks", "boxes", "limits", "strings", "ks", "runs", "ds", "styles"], "tmp": ["buf", "bb", "ppa", "own", "pad", "txt", "image", "xt", "html", "b", "mp", "cmp", "cp", "term", "tc", "fb", "bt", "bp", "part", "pos", "sb", "output", "py", "stuff", "zip", "not", "tt", "videos", "rb", "template", "attr", "meta", "test", "lab", "tab", "cb", "temp", "chart", "metadata", "api", "src", "config", "media", "ff", "wp", "kk", "db", "video", "po", "v", "amp", "qt", "obj", "params", "sup", "app", "sp", "proc", "ext", "nb", "pp", "fp", "p", "tp", "img", "cop"], "video_id": ["voice_bid", "video___id", "voice_type", "video_name", "videoFlowident", "media_id", "voice_length", "video_ID", "voice_name", "videoFlowname", "media_type", "video_ident", "video_length", "video___name", "video___ID", "voiceFlowident", "video__id", "video_ids", "video__type", " video_ID", "videoFlowtype", "voice_id", "voiceFlowname", " video_ids", "voiceFlowtype", "video__ids", " video_name", "media_ids", "video___ids", "video_type", "videoFlowid", "voice_ident", "video_bid", "voiceFlowid"], "t": ["at", "m", "text", "txt", "e", "tip", "xt", "g", "b", "term", "ot", "tm", "part", "pt", "f", "tt", "trial", "ta", "template", "the", "test", "type", "tf", "s", "h", "T", "time", "y", "a", "l", "target", "id", "token", "string", "tp", "v", "c", "qt", "name", "ts", "p", "dt"], "title": ["ppa", "page", "description", "text", "doc", "unit", "itle", "tip", "resource", "html", "het", "body", "term", "summary", "version", "duration", "part", "pt", "translation", "template", "meta", "type", "tf", "test", "code", "te", "yt", "api", "media", "filename", "license", "target", "alt", "artist", "id", "video", "Title", "desc", "qt", "alpha", "detail", "name", "sl", "content", "front", "format", "pretty", "note", "label", "plot", "p"], "i": ["k", "m", "p", "uri", "e", "j", "l", "g", "b", "fi", "init", "ori", "io", "info", "si", "ie", "f", "ni", "it", "iv", "index", "d", "ci", "iu", "oi", "key", "uni", "multi", "y", "api", "li", "di", "cli", "mi", "ip", "pi", "xi", "hi", "inner", "slice", "eni", "yi", "id", "vi", "ti", "gi", "v", "ix", "I", "ai", "zi", "phi", "ini", "ii", "ui", "mu", "qi", "x", "q", "ri"], "ytTitle": ["gtTitle", "rtFilename", "ttData", "gtData", "rtData", "rtExt", "ttTitle", "ttFilename", "rtTitle", "ytFilename", "ttExt", "ytExt", "gtExt", "ytData", "gtFilename"]}}
{"id1": "9275622", "id2": "822452", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFile", "transferFolder", " copyFiles", "copyfile", "copyFolder", " copyfile", "moveFiles", "transferfile", "copyFiles", "moveFolder", " copyFolder", "movefile", "transferFiles", "transferFile"], "_file1": ["_fFirst", "_zipFirst", "_File01", "_files1", "_file0", "_fOne", "_file01", "_resourceFirst", "_fone", "_resourceOne", "_File0", "_fileFirst", "_f1", "_zip1", "_zipone", "_files0", "_File1", "_zipOne", "_files2", "_fileone", "_File2", "_files01", "_mail0", "_mail01", "_resourceone", "_mail1", "_fileOne", "_resource1", "_mail2"], "_file2": ["_model1", "_play1", "jmodel2", "jmodel1", "_file4", " _files4", " _files2", " _fileTwo", "_playsecond", "jfile5", "jfile2", "_model5", "_play4", " _filesTwo", "_File1", "_File5", "_playTwo", "_files2", "jmodelsecond", " _file3", "_file5", "jfilesecond", "_file3", "_File2", "jfile1", "_files4", "_fileTwo", "_files3", "_filesecond", "_modelsecond", "_filesTwo", " _files3", "_play3", " _file4", "_play2", "jmodel5", "_play5", "_Filesecond", "_model2"], "fis": [" fils", "lfis", "Fas", "fais", " fiss", "fi", "Fils", "cfas", "Fos", "lfais", "Fris", "fris", "cfis", "infos", " fi", "Fiss", " fris", "fas", " fas", "fils", "fiss", "afais", "lfiss", "infiss", "infils", "cfiss", "afiss", "cfris", " fais", "infis", "cfos", "afis", "afi", "lfi", "Fis"], "fos": ["fo", " fros", "floes", "Foos", "poes", "goses", "fOS", "lOS", " faos", "lis", "Fos", "flos", "info", " foos", "loes", "foos", "fus", "foses", "pos", "flOS", "faos", "infos", "infaos", "Fo", "gis", "infoos", "pis", "Fus", "feus", "fios", "infus", " fo", "infros", "Faos", "Fios", "infios", "Foses", "flis", "los", "feoses", " fus", "Fros", "feis", "gos", "gus", "foes", " fios", "pOS", "fros", "Fis", "feos"], "canalFuente": ["canalBuze", "canalBuencia", "canalKuente", "canalFuestro", "canaledFuestro", "canalBuente", "canalCraente", "canalFUestro", "canallBuence", "canalFUence", "canalsBuence", "canalsBuencia", "canallBuze", "canalSuente", "canalFuento", "canalFuze", "canalCraencia", "canalSuje", "canalFUze", "canalsFuento", "canallFuencia", "canalsFuente", "canaledFuente", "canalCraento", "canallFuze", "canallFuente", "canallBuente", "canalBuence", "canalKuento", "canalFUencia", "canaledFuze", "canalKuence", "canalCraence", "canalsBuento", "canalBuestro", "canaledBuze", "canalKuze", "canalSuze", "canallFuence", "canalBuento", "canalsFuencia", "canalFuence", "canaledBuje", "canalsBuente", "canalFuje", "canallBuencia", "canalsFuence", "canalKuencia", "canalBuje", "canaledBuente", "canalSuestro", "canalFUente", "canalFUje", "canaledBuestro", "canaledFuje", "canalFuencia"]}}
{"id1": "10383721", "id2": "8024375", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processENTriers", "processENTris", "processEllrings", "processDistriers", "runENTris", "processEntriers", "processENTrys", "runEntriers", "processENTrings", "processEntrings", "runEntris", "processEntris", "runENTrys", "runENTriers", "runEntrys", "processDistrys", "runEntrings", "processEllriers", "processEllrys", "processDistrings", "processDistris", "processEllris", "runENTrings"], "urlStr": ["httpString", "httpSTR", "urlSt", " urlString", "UrlStr", "resourcestr", "httpstr", "fileStr", "uriString", "Urlstr", "URLStr", "URLString", "urlstr", " urlSt", "filestr", " urlstr", "fileSTR", " urlSTR", "uriStr", "resourceString", "urlSTR", "URLSTR", "httpStr", "resourceSTR", "URLSt", "uriSTR", "resourceStr", "UrlSTR", "urlString", "uriSt"], "currentFlag": [" currentBit", "nextTag", "reportedField", "activeFlag", "CurrentTag", "Currentflag", " currentField", "nextFlag", "currentText", "CurrentFLAG", "reportedFlag", "CurrentField", "nextflag", "activeTag", "currentTag", "CurrentFlag", "nextFLAG", "currentflag", "currentField", "activeFLAG", "currentBit", "CurrentBit", "reportedText", "activeflag", "reportedBit", "currentFLAG", "CurrentText", " currentText"], "key": ["k", "prefix", "text", "keys", "kid", "message", "lease", "parent", "scope", "lock", "Key", "here", "ey", "method", "data", "empty", "msg", "step", "ie", "part", "search", "field", "entry", "rule", "check", "str", "exp", "hash", "ace", "type", "section", "seed", "point", "base", "mac", "sign", "id", "cache", "match", "string", "fee", "name", "list", "service", "fix", "full", "function", "path", "query", "roy", "or", "value", "secret", "KEY", "ry"], "postList": ["POSTGroup", "POSTlist", " postCollection", "postlist", "postGroup", " postGroup", "PostCollection", "PostGroup", "POSTList", "PostList", "postCollection", "Postlist", "POSTCollection", " postlist"], "url": ["ur", "page", "text", "proxy", "log", "uri", "ssl", "resource", "image", "server", "build", "loc", "org", "data", "link", "socket", "director", "channel", "entry", "www", "URL", "conn", "client", "l", "web", "base", "address", "cache", "string", "file", "service", "sl", "host", "path", "Url", "location", "http", "feed"], "connection": ["to", "proxy", "writer", "uri", "resource", "server", "communication", "b", "body", "remote", "io", "version", "socket", "director", "channel", "Connection", "application", "document", "creator", "connect", "URL", "password", "out", "conn", "connected", "config", "client", "section", "directory", "l", "number", "position", "object", "character", "con", "c", "handler", "machine", "relation", "function", "response", "wrapper", "condition", " Connection", "collection", "http", "open", "database"], "reader": ["writer", "resource", "server", "body", "io", "data", "parser", "reading", "channel", "entry", "f", "document", "Reader", "input", "editor", "read", "row", "xml", "iter", "driver", "client", "stream", "er", "r", "handler", "file", "loader", "per", "ler", "buffer", "oder", "feed"], "builder": ["writer", "default", "image", "build", "b", "manager", "info", "Builder", "parser", "building", "document", "entry", "result", "creator", "editor", "bean", "row", "xml", "driver", "config", "client", "er", "db", "base", "r", "loader", "builders", "bug", "runner", "wrapper", "or", "buffer", "bridge", "http", "keeper", "database"], "doc": ["text", "gen", "writer", "resource", "html", "build", "body", "dr", "info", "data", "project", "md", "parser", "document", "f", "str", "d", "coll", "graph", "docs", "xml", "doctor", "dir", "Doc", "db", "tree", "base", "ger", "node", "r", "div", "file", "app", "dc", "lib", "bug", "context", "git", "open", "df"], "root": ["rec", "component", "rss", "writer", "default", "parent", "null", "scope", "html", "data", "entry", "ver", "r", "div", "string", "bot", "query", "front", "owner", "right", "page", "server", "remote", "empty", "leaf", "back", "parser", "result", "error", "element", "xml", "record", "article", "tree", "loader", "path", "Root", "master", "outer", "sys", "creator", "archive", "comment", "ree", "top", "section", "db", "user", "node", "cover", "first", "zero", "http", "manager", "director", "rt", "nav", "n", "body", "project", "child", "rup", "document", "valid", "container", "home", "rew", "inner", "name", "author", "head", "roots", "box"], "grNamespace": ["grNamespaces", "grMembersche", "grnamespaced", "grnamespaces", "grMemberspace", "GrNamespaces", "grnamesche", "Grnamespaces", "GrNamescape", "Grnamescape", "GrNamesche", "grnamespace", "Grnamespe", "grMemberspaced", "GrNamespaced", "grNamesche", "grMemberspaces", "Grnamespace", "grNamescape", "grNamespe", "grnamespe", "GrNamespe", "GrNamespace", "grnamescape", "grNamespaced"], "namespace": ["Namescape", " Namespec", "membersternal", "namesspace", "technpace", "namespaced", " namespaced", "kesase", "memberspace", " namescore", " Namespace", " Namespaces", "inasternal", " Namespaced", " namesace", "Namesception", "New", "namesase", "kespace", "Namesace", "_", "inasace", "this", "namepace", "xml", "add", "inasspace", " namespaces", "Namespace", "Namespaced", " namesase", "inaspace", "Namescore", "feed", "workspect", "worksception", "nameception", "s", "namespaces", "Namesase", "namesception", "namepaces", "Namespec", " namesternal", "membersspace", "Namesspace", "namescape", "namespec", "technspace", "http", "workspace", "namespect", "kespaced", " namesception", "memberscape", "namesternal", "memberscore", "namesace", " namescape", "Namespaces", " namespect", "nameternal", "Namespect", "namescore", " namespec", "workspaces", "Namesternal", "membersace", " namesspace", "memberspaces", "namecape"], "newflag": ["nextflag", " newstyle", "nextStatus", "lnStatus", "newFlag", "newstyle", "nextFlag", " newFlag", "lnstyle", " newStatus", "nextstyle", "newStatus", "lnFlag", "lnflag"], "title": ["text", "description", "subject", "message", "resource", "itle", "html", "details", "body", "term", "summary", "version", "itles", "template", "type", "Content", "header", "filename", "license", "Title", "name", "format", "author", "label", "published"], "subTitle": ["ubtitle", "ubDescription", "subDescription", "subtitle", "ubName", "SubTitle", "SubName", "SubDescription", "Subtitle", " subtitle", " subDescription", "subName", "ubTitle", " subName"], "entryList": ["entrylist", "elementlist", " entrylist", " entryChain", "tryChain", " entryLIST", "elementQueue", "tryQueue", " entryQueue", "zipL", " entryL", "entryQueue", "zipList", "entryChain", "zipLIST", "elementChain", "elementList", "postLIST", "tryList", "ziplist", "entryL", "entryLIST", "postlist", "trylist", "postL"], "sdf": ["Sfd", "Sdf", "ssdf", "ssde", "psdf", " sde", "psdd", "pscf", "ascf", "rsdd", "scf", "asdd", " sdd", "rsde", " scf", "ssfd", "asdf", "sde", "asde", "sdd", "ssdd", "rsdf", "Sde", "rsfd", "psde", "Sdd", "sfd"], "e": ["ve", "m", "enter", "ee", "esi", "one", "j", "se", "le", "n", "en", "Element", "ce", "event", "ge", "je", "ie", "ec", "pse", "entry", "f", "oe", "edge", "ele", "o", "d", "ae", "end", "me", "el", "element", " pe", " ie", "te", "ze", " entity", "y", "i", "ne", "l", "er", "E", "eu", "node", "r", "de", "c", "be", "entity", "t", "ente", " event", "ea", "ed", " me", " E", "eb", "line", "p", " element"], "post": ["ost", "page", "text", "default", "install", "one", "server", "copy", "POST", "style", "system", "form", "project", "child", "link", "part", "entry", "draw", "result", "check", "Post", "cross", "archive", "set", "valid", "index", "read", "the", "row", "home", "pass", "posts", "comment", "add", "create", "article", "push", "record", "posted", "wp", "edit", "pod", "user", "node", "tax", "object", "load", "patch", "upload", "list", "maybe", "pre", "next", "op", "get", "author", "mod", "head", "feed", "p"], "content": ["page", "text", "description", "resource", "message", "image", "script", "body", "summary", "data", "version", "output", "status", "archive", "comments", "draft", "template", "Content", "code", "source", "header", "media", "size", "language", "file", "name", "path", "value"]}}
{"id1": "2808955", "id2": "17786231", "code1": "    @Override\n    public EntrySet read(EntrySet set) throws ReadFailedException {\n        if (!SourceCache.contains(url)) {\n            SSL.certify(url);\n            try {\n                super.setParser(Parser.detectParser(url.openStream()));\n                final PipedInputStream in = new PipedInputStream();\n                final PipedOutputStream forParser = new PipedOutputStream(in);\n                new Thread(new Runnable() {\n\n                    public void run() {\n                        try {\n                            OutputStream out = SourceCache.startCaching(url);\n                            InputStream is = url.openStream();\n                            byte[] buffer = new byte[100000];\n                            while (true) {\n                                int amountRead = is.read(buffer);\n                                if (amountRead == -1) {\n                                    break;\n                                }\n                                forParser.write(buffer, 0, amountRead);\n                                out.write(buffer, 0, amountRead);\n                            }\n                            forParser.close();\n                            out.close();\n                            SourceCache.finish(url);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n                super.setIos(in);\n            } catch (Exception e) {\n                throw new ReadFailedException(e);\n            }\n            return super.read(set);\n        } else {\n            try {\n                return SourceCache.get(url).read(set);\n            } catch (IOException e) {\n                throw new ReadFailedException(e);\n            }\n        }\n    }\n", "code2": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "label": 0, "substitutes": {"read": ["play", "write", "resource", "copy", "build", "view", "scan", "data", "weak", "reading", "socket", "search", "es", "check", "reads", "input", "block", "READ", "index", "Read", "run", "fill", "process", "add", "create", "reader", "print", "parse", "iter", "stream", "work", "send", "skip", "load", "exec", "ic", "start", "ping", "find", "select", "wait", "next", "get", "query", "current", "content", "update", "close", "http", "feed", "request", "open", "readable", "ry"], "set": ["setting", "url", "ssl", "resource", "server", "init", "reset", "store", "session", "sync", "entry", "spec", "site", "rule", "sets", "end", "test", "settings", "type", "source", "parse", "src", "config", "size", "seed", "base", "send", "et", "object", "id", "cache", "load", "start", "name", "get", "context", "or", "state", "setup", "update", "SET", "use", "ut"], "in": ["ins", "url", "ssl", "resource", "image", "In", "init", "io", "data", "inc", "socket", "gin", "f", "it", "input", "IN", "inn", "i", "win", "pull", "reader", "source", "src", "client", "login", "inner", "min", "id", "cache", "bin", "file", "con", "ic", "pin", "ini", "again", "spin", "on", "p"], "forParser": ["ofListener", "ofJar", " forparser", "ForMaster", "ofReader", "ofParser", " forListener", "foreReader", "Forparser", " forJar", "forJar", "withFile", "withParser", "forMaster", "ForReader", "withparser", "ForJar", "foreparser", "withJar", "forparser", "forReader", "foreParser", "ForListener", " forReader", " forMaster", " forFile", "foreMaster", "forFile", "ForFile", "forListener", "ForParser"], "out": ["to", "page", "ex", "log", "writer", "url", "ssl", "image", "copy", "null", "parent", "init", "os", "io", "outer", "sync", "socket", "inc", "output", "o", "Out", "conn", "i", "source", "client", "cli", "co", "inner", "can", "outs", "cache", "exec", "bin", "err", "file", "app", "up", "net", "OUT", "again", "http", "ext"], "is": ["url", "ins", "does", "isi", "isl", "os", "ps", "lis", "vs", "bis", "IS", "us", "ci", "fs", "s", "iris", "ios", "i", "sin", "api", "im", "ip", "are", "ib", "id", "iss", "ir", "ais", "ris", "has", "Is", "ai", "as", "ui", "was", "isa", "or", "ois", "bs", "its", "ri", "isin"], "buffer": ["border", "buf", "page", "padding", "delay", "url", "uri", "server", "length", "count", "offset", "null", "info", "data", "Buffer", "channel", "limit", "sequence", "phrase", "batch", "bytes", "source", "iter", "memory", "reader", "size", "buff", "seed", "slave", "base", "queue", "slice", "cache", "counter", "address", "bin", "repeat", "binary", "reference", "layer", "uffer", "transfer", "feed"], "amountRead": ["AmountStart", "AmountWrite", "poolReader", " numberHandle", "poolWrite", "amountBuild", "lengthRead", " amountStart", "enoughWrite", "weightLoad", " amountWrite", "AmountLoad", "amountHandle", "weightRead", "numberWrite", "weightReader", "weightBuild", " numberRead", "poolLoad", "AmountRead", " amountBuild", "enoughReader", "AmountReader", " amountLoad", "amountLoad", "numberLoad", "AmountBuild", "poolRead", "lengthLoad", "amountStart", " amountReader", "lengthWrite", "enoughRead", " numberLoad", "amountWrite", "numberRead", "numberReader", "lengthHandle", "enoughStart", "amountReader", " numberWrite", "AmountHandle"]}}
{"id1": "9805906", "id2": "23666867", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["save", "ln", "copy", "info", "data", "store", " dumping", "f", " dumps", "zip", "all", "out", "download", "flush", " dumped", "dir", "db", "files", "load", "println", "diff", "transfer", "ump", "update", "Dir", "export", "df"], "source": ["uri", "unit", "resource", "server", "se", "core", "parent", "view", "connection", "remote", "this", "series", "Source", "site", "input", "ources", "s", "sin", "iter", "src", "stream", "slave", "base", "slice", "address", "string", "ource", "file", "start", "service", "SOURCE", "current", "scene", "http", "use", "from"], "target": ["replace", "to", "resource", "large", "parent", "dest", "null", "master", "connection", "project", "port", "follow", "output", "alias", "it", "result", "effect", "template", "out", "settings", "top", "src", "Target", "base", "table", "object", "address", "arget", "file", "platform", "root", "goal", "next", "host", "path", "pointer", "office", "enemy", "force", "database"], "is": ["ls", "ins", "gets", "isi", "isl", "ps", "ori", "lis", "info", "mis", "obs", "io", "nis", "ics", "iso", "oss", "in", "es", "bis", "bos", "IS", "us", "ists", "oses", "ens", "s", "iris", "ws", "ios", "i", "im", "ip", "ses", "iss", "ais", "ris", "has", "Is", "ops", "ai", "ui", "as", "or", "isa", "cs", "abs", "opens", "ois", "bs", "was", "its"], "os": ["ros", "oa", "dos", "nos", "ss", "acs", "ps", "io", "ori", "obs", "ies", "osi", "oss", "cos", "aos", "pos", "ose", "es", "ows", "o", "bos", "vs", "us", "oses", "ips", "fs", "s", "ols", "ens", "ues", "ios", "i", "Os", "oos", "oes", "outs", "los", "ais", "ops", "as", "or", "cs", "bs", "its", "boot", "ks", "OS", "ds"], "done": ["loaded", "after", "enabled", "running", "odo", "one", "complete", "ready", "got", "nice", "none", "started", "die", "empty", "data", "later", "last", "part", "gone", "once", "progress", "finished", "future", "made", " finished", " Done", "foo", "checked", "Done", "de", "doing", "due", "disabled", "confirmed", "defined", "next", "expected", "current", "always", "did", "yes", "dirty", "dad"]}}
{"id1": "9796161", "id2": "20929570", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD4", "getmd4", "getmdHash", "getmd512", "getHTMLHash", " getSHA4", "getHTML4", "getMDHash", "getSHA5", "getmd5", "getMD512", " getMD512", "getSHA512", "getSHAHash", " getSHA512", " getMD4", "getSHA4", "getHTML512", " getSHAHash", " getMDHash", " getSHA5", "getHTML5"], "s": ["ls", "js", "ssl", " ads", "e", "als", "g", "b", "n", "ss", "os", "rs", "ps", "data", "parts", "ns", "si", "sync", "in", "sb", " fails", "f", "es", "input", "str", "ings", "ows", "comments", "sets", "bytes", "lines", "ms", "ips", "ws", "i", "source", "ends", "is", "sym", "a", "l", "self", "scripts", "ses", "S", "string", "v", "c", "tests", "ts", "gs", "cs", "abs", "ates", "services", "strings", "bs", "its", "p", "ds", "styles"], "m": ["rm", "e", "module", "mut", "mr", "md", "um", "tm", "wm", "f", "fm", "mc", "d", "man", "h", "me", "hm", "ms", "nm", "dm", "i", "bm", "cm", "gm", "l", "mi", "im", "mac", "ym", "mand", "v", "mm", "c", "machine", "sm", "am", "t", "pm", "em", "M", "arm", "mu", "vm", "om", "manager", "p"]}}
{"id1": "12537270", "id2": "20851065", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["ize", "pack", "report", "ract", "se", "apply", "build", "scan", "ge", "arse", "parser", "raw", "split", "read", "process", "see", "xml", "match", "load", "patch", "Parser", " analyse", "format", "update", "eval", "open"], "link": ["ink", "page", "text", "http", "ln", "uri", "message", "e", "image", "Link", "html", "style", "connection", "loc", "links", "rel", "like", "tag", "info", "data", "lock", "msg", "route", "URL", "href", "inline", "type", "linked", "xml", "source", "add", "li", "l", "base", "local", "address", "match", "string", "id", "load", "file", "name", "bug", "path", "location", "word", "line", "lang"], "conn": ["rt", "rec", "ssl", "ct", "cn", "col", "n", "connection", "dr", "loc", "pg", "cp", "cmd", "io", "rc", "act", "socket", "Connection", "pt", "connect", "mc", "nt", "rn", "ch", "nc", "ci", "out", "Conn", "cc", "ctrl", "config", "client", "er", "db", "apt", "ann", "r", "ac", "pc", "Config", "err", "con", "c", "dc", "ctx", "ai", "ca", "enc", "cr", "p", "open"], "rd": ["fd", "rt", "rm", "rss", "fr", "xd", "nd", "rx", "ru", "dr", "RR", "rc", "rs", "rh", "dd", "rn", "rb", "rog", "rg", "RS", "rid", "RD", "rw", "bd", "wd", "reader", "rl", "rr", "lr", "r", "adr", "dra", "dc", "sr", "ld", "hr", "ra", "RM", "ds"], "kit": ["k", "rt", "kat", "ct", "wt", "b", "ku", "ki", "os", "init", "sci", "io", "info", "ut", "kt", "py", "f", "site", "tool", "Kit", "spec", "nt", "h", "pot", "plugin", "cat", "kin", "tools", "api", "reader", "config", "base", "et", "pit", "sit", "cr", "qt", "loader", "t", "w", "lib", "net", "bot", "bug", "auto", "ui", "fit", "tk", "format", "rot", "util", "feed", "p", "browser"], "doc": ["m", "page", "text", "DOC", "fr", "html", "dr", "loc", "body", "tag", "info", "data", "md", "msg", "dec", "tx", "bc", "in", "pos", "document", "f", "tt", "mc", "d", "ref", "coll", "val", "out", "docs", "xml", "api", "dir", "config", "Doc", "di", "db", "base", "de", "div", "po", "ac", "pc", "mm", "file", "desc", "dc", "root", "bug", "pub", "dom", "http", "open"], "url": ["ur", "page", "log", "uri", "ssl", "ll", "image", "resource", "server", "html", "connection", "loc", "cdn", "org", "blog", "f", "URL", "www", "href", "download", "el", "xml", "source", "pull", "src", "config", "rl", "l", "github", "lr", "base", "util", "address", "gl", "file", "name", "service", "sl", "host", "bug", "location", "Url", "path", "hub", "http", "feed"], "it": [" It", "se", "ait", "IT", "It", "st", "init", "iti", "info", "you", "in", "nt", "split", "stat", "ci", "end", "iter", "mit", "l", "edit", "ip", "lit", "r", "pit", "et", "sit", "id", "v", "ic", "t", "ite", "or", "iterator", "iz", "dit", "its", "p"], "elem": ["eler", "eelements", "Element", "peler", " neler", "selem", " Eler", " Element", "oeler", "eade", "pelem", " nelement", "selement", "element", "eelement", "Eler", "eject", "seject", " nelem", " Elem", "eelem", "elev", "Eject", "Elements", "Elem", "selements", "oelem", "eeject", " neade", "Eade", " Eade", "oelement", "pelement", "Elev", "pelev", "oelev", "elements"], "s": ["ls", "m", "u", "sch", "js", "ssl", "e", "server", "se", "sf", "details", "b", "g", "ss", "n", "scope", "os", "rs", "sv", "ps", "ns", "parts", "si", "session", "sync", "sb", "f", "spec", "es", "o", "set", "d", "attr", "sets", "h", "fs", "ws", "sym", "a", "r", "ses", "S", "string", "v", "c", "submit", "params", "xs", "service", "t", "sl", "ts", "ops", "gs", "services", "strings", "p", "ds"], "lnk": ["knK", "lnku", "gnk", "dlky", "olnkr", "lnks", "nlf", "dlke", "knkh", "lenky", "lenke", "olnf", "dnf", "lnke", "nlke", "olnkh", "nnke", "nlks", "nnk", "nlK", "nlky", "dlk", "olnk", "lnf", "olnK", "lenks", "nlkh", "dnky", "linf", "dlf", "nnku", "dlks", "knke", "olnke", "lenk", "dlok", "linky", "gnke", "lnK", "dnkr", "lnky", "linke", "nnky", "gnky", "dnk", "gnok", "nlok", "knk", "lnkh", "dnku", "lnok", "lenku", "lnkr", "dnke", "dlkr", "nlk"], "j": ["ij", "m", "p", "js", "fr", "z", "g", "n", "info", "kj", "si", "jc", "ie", "part", "pos", "syn", "ni", "jj", "ja", "o", "index", "ch", "dj", "job", "uj", "key", "aj", "ji", "J", "jo", "pr", "y", "oj", "li", "im", "ne", "a", "ind", "br", "obj", "name", "adj", "jl", "ii", "x", "jp", "note", "qi"], "urlLink": [" urlLine", "urlConnect", "fileLink", "urlHub", "filePath", " urlPath", " urlPage", "resourceConnect", "UrlPage", "resourceLink", "resourceLine", "urlUrl", " urlRel", "resourcelink", " urlUrl", "UrlHub", "fileUrl", "fileHub", "UrlRel", "URLPage", "UrlPath", "UrlLink", "urlPath", "urlRel", " urllink", "strlink", "URLRel", "URLLink", " urlConnect", "strLine", "urllink", "urlPage", " urlHub", "URLUrl", "strLink", "strConnect", "UrlUrl", "urlLine"], "str": ["kr", "text", "Str", "res", "js", "wr", "fr", "stri", "STR", "arr", "txt", "b", "st", "dr", "n", "data", "dec", "f", "inst", "elt", "coll", "strip", "pass", "pr", "l", "inner", "tr", "r", "ctr", "div", "string", "br", "err", "obj", "name", "sr", "sl", "t", "sp", "spr", "hr", "sta", "enc", "line", "cr", "ext", "char"], "i": ["m", "u", "uri", "e", "b", "n", "en", "fi", "init", "ori", "io", "info", "si", "in", "f", "ni", "o", "index", "ci", "iu", "oi", "ji", "abi", "multi", "y", "li", "di", "l", "mi", "ip", "pi", "hi", "xi", "eni", "slice", "vi", "yi", "id", "uli", "ti", "v", "gi", "c", "ri", "I", "ai", "zi", "ix", "ini", "ii", "qi", "x", "bi", "ui", "phi", "mu", "chi", "p"], "skip": ["replace", "special", " bypass", " duplicate", "append", "copy", "complete", "cmp", "scan", " skipped", "empty", " skipping", "loop", " scan", "error", "ips", "jump", "stop", "iter", "add", " exclude", "Skip", "sp", " dup", "fast", " repeat", "active"]}}
{"id1": "9210168", "id2": "3536332", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"run": ["replace", "un", "running", "unit", "image", "background", "call", "apply", "Run", "display", "in", "output", "loop", "launch", "job", "test", "out", "home", "code", "process", "stop", "add", "create", "register", "work", "inner", "base", "show", "exec", "start", "name", "runner", "invoke", "render", "update", "execute", "runs"], "url": ["ur", "fr", "uri", "resource", "ssl", "server", "image", "b", "nr", "loc", "remote", "f", "str", "URL", "source", "api", "rl", "l", "lr", "base", "user", "id", "address", "string", "file", "err", "loader", "re", "service", "sl", "plug", "path", "Url", "http", "browser"], "fis": ["Fis", "flIs", "FIs", "fais", "pIs", " fiss", " fIS", "fisa", "pisa", "flisa", "bais", "Fiss", "bis", "Fais", "bIs", " fisa", "FIS", "biss", "pis", "piss", "fIs", "fiss", "flis", " fais", "fIS", "fliss", "bIS", " fIs"], "r": ["kr", "ur", "rt", "p", "res", "wr", "fr", "R", "resource", "e", "rx", "b", "ru", "nr", "rc", "mr", "rs", "rh", "rar", "f", "vr", "Reader", "d", "rb", "s", "rf", "BR", "rus", "i", "pr", "is", "reader", "ar", "rl", "l", "er", "rr", "tr", "ir", "err", "c", "sr", "hr", "ler", "cr", "ri"], "br": ["buf", "rt", "res", "wr", "bro", "fr", "arr", "rx", "b", "dr", "mr", "yr", "fb", "bh", "bc", "vr", "result", "str", "HR", "ch", "rb", "brush", "bf", "BR", "B", "reader", "lr", "tr", "err", "be", "ob", "sr", "gr", "hr", "bl", "Br", "bridge", "cr", "bb", "browser"], "line": ["LINE", "lf", "le", "b", "style", "letter", "cell", "data", "ge", "link", "shell", "part", "entry", "f", "str", "split", "lin", "cl", "nl", "lines", "end", "key", "row", "inline", "code", "pass", "el", "column", "i", "comment", "rl", "li", "header", "l", "number", "base", "id", "string", "character", "file", "Line", "liner", "name", "sl", "sel", "bl", "word", "lc", "buffer", "cr", "char"], "sb": ["ls", "buf", "sth", "bsp", "rob", "sf", "b", "sv", "fb", "bt", "bp", "bh", "si", "usb", "xb", "lb", "bc", "sn", "pb", "SB", "storage", "rb", "bis", "cb", "mb", "bf", "amb", "bm", "bd", "src", "erb", "buff", "sg", "db", "lr", "ib", "bj", "abb", "zb", "BB", "sa", "gb", "binary", "obb", "wb", "bl", "buffer", "ab", "nb", "eb", "bs", "bb"], "text": ["font", "txt", "message", "b", "connection", "letter", "info", "data", "title", "output", "entry", "result", "input", "str", "translation", "test", "code", "source", "comment", "config", "TEXT", "object", "id", "string", "obj", "name", "path", "content", "buffer", "format", "ext", "value", "Text"]}}
{"id1": "14758866", "id2": "16719805", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesAsStream", "getResourceAsString", "getResourceasSteam", "getResourceasFile", "getResourceToString", "getResourceasStream", "getResourceASFile", "getResourcesasSteam", "getResourceToFile", "getResourcesAsString", "getResourceToSteam", "getResourceAsSteam", "getResourcesasString", "getResourcesAsSteam", "getResourcesAsFile", "getResourcesasFile", "getResourceToStream", "getResourceASStream", "getResourceasString", "getResourceASSteam", "getResourceAsFile", "getResourcesasStream", "getResourceASString"], "name": ["NAME", "ame", "prefix", "uri", "resource", "parent", "connection", "remote", "info", "data", "version", "username", "part", "alias", "hash", "str", "named", "key", "type", "time", "source", "memory", "Name", "config", "size", "filename", "ip", "base", "object", "id", "address", "names", "string", "cache", "file", "full", "domain", "path", "location", "word"], "inputStream": ["inputChannel", "inputSteam", "InputConnection", "pullChannel", "InputChannel", "currentSteam", "InputBody", " inputBody", "cacheFeed", "inputFeed", " inputChannel", "pullSteam", "Inputstream", "InputStream", "currentBody", " inputFeed", "inputConnection", "currentStream", "pullConnection", "pullStream", "cacheStream", " inputConnection", "cacheSteam", "cachestream", "InputSteam", "inputBody", "currentstream", "inputstream", " inputstream", "InputFeed", " inputSteam"], "in": ["rec", "m", "log", "ins", "image", "In", "data", "socket", "input", "din", "IN", "read", "Out", "source", "reader", "src", "inner", "r", "exec", "bin", "c", "err", "re", "path", "buffer"], "out": ["page", "gen", "log", "writer", "ex", "server", "copy", "debug", "cmd", "lock", "io", "outer", "data", "sys", "msg", "raw", "part", "output", "group", "println", "ref", "Out", "error", "key", "conn", "temp", "flush", "client", "cli", "dump", "ger", "point", "outs", "bar", "user", "object", "r", "cache", "bin", "err", "obj", "file", "params", "list", "window", "up", "inter", "pre", "OUT", "proc", "pool", "query", "state", "buffer", "line"], "url": ["ur", "page", "log", "uri", "ssl", "resource", "image", "server", "b", "connection", "rel", "remote", "loc", "event", "org", "data", "socket", "f", "result", "route", "URL", "coll", "bel", "download", "source", "pull", "api", "config", "client", "li", "stream", "l", "web", "base", "user", "r", "object", "cache", "address", "string", "gl", "https", "file", "service", "ob", "sl", "full", "left", "location", "Url", "path", "update", "http", "feed", "open", "browser"], "remoteName": [" remotename", " remoteUrl", "remotePath", "remotename", "RemotePath", "RemoteName", " remoteKey", "localKey", "fullname", "remoteKey", "RemoteUrl", "remoteUrl", " remotePath", "localUrl", "fullPath", "localPath", "RemoteKey", "fullName", "Remotename", "fullKey"], "localName": [" localPath", "remotePath", "remotename", " localFile", "localFile", "localname", "locName", "locUrl", "LocalPath", " localKey", "globalFile", "globalPath", "localString", "remoteString", "globalKey", "localKey", " localname", "LocalKey", "locname", "remoteKey", "globalName", "LocalName", "Localname", "remoteUrl", " localString", "remoteFile", "localUrl", "locPath", "localPath", " localUrl", "locString", "globalString", "globalname"], "host": ["prefix", "proxy", "arch", "localhost", "uri", "server", "loc", "remote", "username", "h", "type", "home", "conn", "driver", "config", "hop", "addr", "src", "header", "dir", "target", "ip", "address", "string", "hard", "service", "Host", "domain", "path", "format", "head", "http", "database"], "prot": ["conv", "ocol", "prop", "prefix", "att", "txt", "ssl", "cert", "col", "rel", "Prot", "part", " protocols", "pos", "pt", "rot", "ht", " proto", "channel", "family", "stat", "ref", "password", "conn", "pass", "ios", "api", "addr", "config", "nat", "client", "cli", "lat", " plat", "platform", "def", "pattern", "proc", "pro", "afi", " protocol", "serv"], "port": ["ort", "proxy", "direction", "uri", "server", "length", "version", "project", "allow", "phone", "limit", "f", "index", "password", "pid", "timeout", "type", "PORT", "pass", "rest", "time", "pr", "future", "hop", "Port", "size", "width", "target", "ports", "ip", "number", "pi", "point", "slice", "position", "address", "string", "patch", "file", "select", "service", "path", "value", "priority", "p"], "cacheFile": ["storagePlace", "proxyDir", "outputfile", "cacheConnection", "localDirectory", "localFile", "cacheHandle", "cacheLine", "remoteLine", "tempFile", "proxyfile", "storageFiles", "proxyFile", "outputMessage", "baseConnection", "acheFile", " cacheUrl", "CacheFile", "CacheUrl", " cacheFiles", "basefile", "outputFile", "localFiles", "Cachefile", "cacheUrl", "sessionFiles", "sessionUrl", "CacheDirectory", "CacheDir", "cachePlace", "fakeFile", "outputConnection", " cacheDir", "tempfile", "baseMessage", "sessionFile", "localDir", "sessionDir", "cacheDirectory", " cacheConnection", "tempDir", "cachefile", "CacheFiles", " cacheLine", "tempHandle", " cachePlace", "fakefile", "fakeLine", "cacheFiles", "remoteUrl", "fakeUrl", " cachefile", "remotefile", "remoteFile", "cacheMessage", "acheFiles", "baseFile", "localfile", "achePlace", " cacheHandle", "cacheDir", " cacheMessage", "storageFile", " cacheDirectory", "proxyHandle"], "urlConnection": ["slConnection", "webConnect", "urlConnect", "URLCon", "sslConnection", "webCon", "cacheConn", "cacheConnection", "sslconnection", "URLconnection", "slCommand", "urlFile", "httpConnect", "sslFile", "cacheConnect", "slCode", "httpconnection", "URLConnect", "sslConnect", "webconnection", "httpResponse", "urlResponse", "urlCommand", "httpPool", "urlCon", "webConnection", "httpConn", "URLConnection", "urlPart", "httpChannel", "fileConn", "downloadFile", "httpCommand", " urlCommand", "URLConn", " urlConn", "sslConn", "downloadconnection", "urlCode", "urlConn", "httpCode", "urlChannel", "urlPool", "cachePool", "urlconnection", "downloadEntry", "httpCon", " urlConnect", "URLResponse", "sslEntry", "sslResponse", " urlCode", " urlChannel", "fileConnect", "httpConnection", " urlEntry", "filePart", " urlPart", "downloadConnection", " urlconnection", " urlPool", "fileConnection", " urlFile", "slChannel", "urlEntry", "URLPart"], "httpURLConnection": ["shortURLConnection", "upperURLconnection", "urlUrlStatement", "httpURLFunction", "httpREconnection", " httpUrlconnection", "upperURLConnection", "httpRNode", "upperRConnection", "httpURLCode", "cacheUrlConnection", "httpURLClient", "httpURLStatement", "httpDOMConnect", "httpRTransaction", "httpURNode", "httpBLConnection", "httpSLConnection", "urlURLconnection", "httpUrlClient", "httpMConnect", "shortURLconnection", "httpMConnection", "upperRTransaction", "httpMLFunction", "httpMCode", "httpHTTPQuery", "httpBLFunction", "httpCLConnector", "httpUrlFunction", "httpurlconnection", "httpBLQuery", "httpURLNode", "httpURLQuery", "httpRconnection", "httpUrlConnection", "httpHTTPConnection", "httpLLConstruction", "httpUrlStatement", "httpWSTransaction", "httpDOMFunction", "httpLLConnection", "httpWSNode", "urlUrlconnection", "httpFormConnection", "cacheURLConnection", "httpDateConn", "httpCLConnection", "httpURLOperation", "currentURLConnection", " httpLLConn", "httpURLConnect", "httpREConn", "httpSLConnect", "httpSLconnection", "cacheUrlConnector", "httpWSconnection", "httpLLconnection", " httpUrlConnection", "httpUrlconnection", "urlUrlClient", "httpDOMConnection", "urlURLClient", "httpurlConnection", "currentURLCode", "httpCLConnect", " httpHTTPConnection", "httpDOMconnection", "shortSLconnection", "httpMLconnection", "urlURLConnection", "upperURLTransaction", "httpDateConnection", "httpURLConnector", " httpURLconnection", "httpURLconnection", " httpLLconnection", "httpLLConn", "httpRLConnection", "httpDateconnection", "httpREClient", "cacheURLClient", "httpMLConnect", "httpURQuery", "httpRLClient", "httpWSConnection", "httpURLConn", "cacheURLConnect", "httpUROperation", " httpHTTPQuery", "urlURLStatement", "httpRConnection", "shortURLConnect", "httpSLCode", " httpURLQuery", "httpREConnection", "httpUrlConnect", " httpUrlFunction", "httpFormConnect", "httpurlStatement", "httpREStatement", "httpRLConnector", " httpURLConstruction", "httpHTTPFunction", " httpHTTPFunction", "urlUrlConnection", "httpRLConnect", "httpMconnection", "cacheUrlConnect", "cacheURLConnector", "currentURLconnection", "upperURLNode", "httpurlClient", " httpURLFunction", "cacheUrlClient", "httpUrlConnector", "httpDateConstruction", "httpURLConstruction", "httpMLConnection", "httpHTTPOperation", "httpCLClient", " httpURLOperation", "httpBLOperation", " httpHTTPOperation", " httpUrlConnect", " httpURLConnect", "shortSLConnect", "httpURFunction", " httpLLConstruction", "shortSLConnection", "httpURTransaction", "httpURConnection", " httpLLConnection", " httpURLConn", "httpFormconnection", "httpREConstruction", "httpURconnection", "upperRNode", "httpURLTransaction", "currentURLConnect", "upperRconnection", "httpRLconnection"], "responseCode": ["ResponseMessage", "ResponseCount", "responseStatus", "responseCount", "replyMessage", "ResponseType", "statusCode", " responseMessage", "statusType", "replyType", "statusStatus", " responseType", "responseType", "replyCode", "statusCount", "responseMessage", "replyCount", "ResponseStatus", "statusMessage", " responseStatus", "ResponseCode"], "lastModified": ["lastMODied", "lastMODification", "lastEdIFIED", "lastEdified", "nextModIFIED", "nextMODIFIED", "lastmodied", "lastModification", "nextModified", "lastmodIFIED", "New", " lastModined", "nextMODied", " lastMODied", "lastMinIFIED", "_", "lastModed", "lastModined", "this", "lastmoded", "lastmodification", "lastEded", "lastMODified", "lastModied", " lastMODined", "nextMODification", "lastMinified", "lastMODed", "lastModIFIED", " lastMODIFIED", "s", "lastMODined", "lastMinied", "lastMinined", "nextModed", " lastModied", "nextModied", " lastMODified", "lastEdification", "nextMODified", "lastMODIFIED", "nextModification", " lastModIFIED", "nextMODed", "lastmodified"]}}
{"id1": "12128591", "id2": "19307120", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static String sendPost(String url, String param) {\n        String result = \"\";\n        try {\n            URL httpurl = new URL(url);\n            HttpURLConnection httpConn = (HttpURLConnection) httpurl.openConnection();\n            httpConn.setRequestProperty(\"Accept-Language\", \"zh-CN\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            PrintWriter out = new PrintWriter(httpConn.getOutputStream());\n            out.print(param);\n            out.flush();\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(httpConn.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n            in.close();\n        } catch (Exception e) {\n            MsgPrint.showMsg(e.getMessage());\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"hash": ["crypt", "text", "component", "log", "pack", "copy", "build", " Hash", " hashes", " hashing", "check", "str", "hex", "sum", "h", "code", "add", "parse", "print", " fingerprint", "dump", "SHA", "Hash", "get", "update"], "data": ["DATA", "text", "padding", "pad", "message", "image", "length", "style", "body", "connection", "info", "output", "in", "result", "input", "str", "hex", "dat", "missing", "bytes", "template", "s", "class", "source", "memory", "api", "media", "a", "base", "address", "cache", "string", "alpha", "name", "response", "content", "buffer", "format", "value", "p", "database"], "digest": ["Diger", "Digusher", "mdester", "generit", "peder", " digEST", "DigEST", "Digger", "logast", "bigester", "logester", "bigger", "Digast", "generests", "bigest", "Digester", "dige", "digEST", "Digest", " digit", "signusher", "logest", "mdast", "generester", "digit", "signest", "digger", "generest", "logenge", "pedest", " diger", " digusher", "Dige", "decests", " digests", " digester", " digger", " dige", "Digenge", "digester", "decit", "decester", "signEST", "signester", "pedester", "digests", "decest", "digenge", "diger", "mdest", "digusher", "pede", "mdenge", "digast", "bigusher"]}}
{"id1": "14303294", "id2": "20886320", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"getServerHash": [" getServerSalt", "getServerAddress", "getServerSHA", "getSecureSHA", "getSecureAddress", " getSecureHash", " getServerSHA", "getserverAddress", " getServerAddress", " getSecureSHA", " getSecureAddress", "getserverSHA", "getSessionHash", "getServerSalt", "getSessionSHA", "getSessionSalt", "getSessionAddress", " getSecureSalt", "getserverSalt", "getSecureHash", "getserverHash", "getSecureSalt"], "passwordHash": ["privatePassword", "PasswordHash", " passwordCode", " PasswordCode", "passwordPassword", " PasswordHash", "passwordPass", "Passwordhash", " passwordPass", "privateHash", "passwordCode", "passwordhash", " passwordhash", "privatehash", "passwordSalt", "PasswordPass", " passwordSalt", "privateSalt", " PasswordPass", "PasswordPassword", " passwordPassword", "PasswordCode"], "PasswordSalt": ["PasswordHash", "PasswordSecret", "password256", "PASSSalt", "passwordPassword", " PasswordHash", "PASS256", "passwordSecret", " passwordSecret", "passwordSalt", " PasswordSecret", " PasswordPassword", "PASSPassword", "Password256", " Password256", " passwordSalt", "PASSHash", "PasswordPassword", " passwordPassword"], "hash": ["crypt", "ash", "array", "log", "url", "auth", "message", "image", "copy", "html", "build", "sha", "data", "dig", "search", "her", "result", "check", "hex", "sum", "password", "error", "h", "key", "row", "code", "kh", "size", "work", "number", "base", "user", "mac", "change", "address", "string", "cache", "ha", "Hash", "sh", "response", "pool", "value", "buffer", "update", "content", "block"], "digest": ["Diger", "Digusher", "mdester", " digher", "integested", "Digger", "hashester", "integall", " digall", " digener", "signger", "Digester", "digall", "Digest", " digested", "mdested", "digener", "generall", "generester", "signest", "digger", "generest", "digher", " diger", "signer", "signher", " digusher", "generested", "mdusher", "integester", " digester", " digger", "Digested", "digester", "Digher", "integest", "signester", "hasher", "diger", "Digener", "digested", "mdest", "digusher", "hashest", "hashener"]}}
{"id1": "20623709", "id2": "9236363", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"split": ["Split", "append", "copy", "build", "cmp", "init", "sync", "part", "archive", "set", "sort", "run", "process", "add", "parse", "delete", "match", "exec", "share", "start", "diff", "transfer", "format", "update", "execute", "open", "join"], "targetDirectory": ["destFile", "targetFolder", "masterPath", "currentFolder", " targetDir", "targetDatabase", "currentRoot", "TargetDatabase", "targetDir", "targetPath", "baseDirectory", "destFolder", " targetRoot", "baseDir", "TargetRoot", "TargetFile", "outputFile", "destDir", "currentDir", "TargetDir", "outputDirectory", "TargetPath", "TargetDirectory", "targetFile", "currentPath", "currentDirectory", "outputDir", " targetPath", "outputFolder", "masterDir", "TargetFolder", "destDirectory", "masterDirectory", "baseDatabase", " targetFolder", "basePath", "masterDatabase", "baseFile", " targetFile", "baseFolder", "targetRoot"], "prefix": ["prot", "padding", "uri", "unit", "resource", "txt", "append", "offset", "username", "FIX", "sequence", "folder", "index", "template", "timeout", "type", "temp", "config", "directory", "filename", "number", "base", "queue", "cache", "string", "patch", " suffix", "name", "resolution", "ix", "fix", "pre", "domain", "root", "pattern", "path", "fixed", "first", "format", "fp", "Pref"], "maxUnitBases": ["maxUnitEases", "maxUnitAliases", "maxUnitChase", "maxUnitBase", "maxunitAliases", "maxUnitEaches", "maxUnitQueases", "maxunitAliasing", "maxunitAliails", "maxUnitQueasing", "maxUnitAliase", "maxUnitAliasing", "maxUnitChues", "maxUnitAliues", "maxUnitAliails", "maxunitBaches", "maxUnitBaches", "maxUnitEails", "maxUnitPlases", "maxunitBues", "maxUnitAliaches", "maxunitBases", "maxUnitPlase", "maxunitAliaches", "maxUnitBails", "maxunitAliase", "maxunitAliues", "maxUnitPlaches", "maxunitBase", "maxUnitBues", "maxunitBasing", "maxUnitEase", "maxUnitChasing", "maxUnitQueues", "maxUnitBasing", "maxUnitPlails", "maxunitBails", "maxUnitChases", "maxUnitQuease"], "maxUnitEntries": ["maxLineEntrations", "maxUnitEnties", "maxUnitEntryry", "maxLineOrdrations", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdines", "maxUnitErries", "maxUnitEntryresses", "maxUnitIntresses", "maxunitEntries", "maxUnitEntryies", "maxUnitInties", "maxunitEnties", "maxLineEntines", "maxUnitEntines", "maxUnitEntryrys", "maxUnitOrdies", "maxunitEntrys", "maxUnitIntries", "maxLineOrdries", "maxLineEntry", "maxUnitCountries", "maxUnitAddries", "maxUnitEntry", "maxunitEntresses", "maxUnitErry", "maxUnitEntrations", "maxunitEntryresses", "maxUnitOrdrys", "maxUnitCountrations", "maxUnitEntresses", "maxUnitEntrys", "maxLineOrdry", "maxLineOrdines", "maxUnitOrdry", "maxUnitErines", "maxUnitAddures", "maxUnitOrdries", "maxUnitErrations", "maxunitEntryries", "maxUnitEntures", "maxLineEntries", "maxUnitOrdresses", "maxunitEntryies", "maxUnitOrdrations", "maxUnitCountry", "maxUnitIntrys", "maxunitEntryrys", "maxUnitEntryries", "maxUnitAddry", "maxUnitCountines"], "fis": ["forisa", "visa", "foris", "forai", " fiss", "foriss", "fisa", "Fris", "fris", "Fisc", "fai", " fIs", "Fiss", " fris", " fisa", "vai", "forIs", "fisc", "forisc", "forris", " fai", "fIs", "fiss", "vis", " fisc", "vIs", "Fis"], "fci": ["hci", "vcos", "efai", " fii", "fai", "dci", "dii", "hcos", "efco", "bis", "bco", "vai", "Fai", "vco", "Fci", "dco", "efcos", "hai", " foci", "bci", " fai", "foci", "bai", "vci", "Foci", "Fii", "Fco", "fii", "doci", "efci", "fcos", "Fis", "hco"], "fos": ["tis", "fo", "fso", "fscos", "Fos", "infos", "ifo", "Foss", "ifcos", "fsios", "infoss", "toss", "fios", " fo", " fcos", "ifios", "fsos", "tos", "infis", "ifos", "foss", "Foes", "foes", " fios", "infoes", "toes", "fcos", "Fis"], "fco": ["hgo", "dcos", "fileico", "Fbo", "Fico", " fro", "fro", "hci", " fgo", "fbo", "dro", "hcos", "filebo", "fileci", "dci", "fgo", "Fci", "dco", "fico", " fico", "fileco", " fbo", "lro", "lgo", " fcos", "lcos", "lco", "Fco", "fcos", "lci", "hco"], "buffer": ["border", "buf", "request", "pad", "writer", "resource", "message", "server", "image", "length", "copy", "null", "offset", "view", "info", "data", "scale", "Buffer", "bc", "channel", "entry", "document", "result", "input", "translation", "batch", "read", "timeout", "texture", "comment", "iter", "memory", "reader", "flush", "size", "header", "source", "buff", "expression", "capacity", "base", "bar", "queue", "position", "cache", "counter", "bin", "window", "loader", "binary", "reference", "device", "pause", "layer", "response", "uffer", "transfer", "context", "zero", "feed", "block", "callback", "rate"], "currentBasesCount": ["currentBasescount", "currentBasesNum", "currentBatchescount", "currentChasesCounter", "currentChasesNum", "currentBatchesCounter", "currentChasesCount", "currentBaseCount", "currentBaseCounter", "currentChasecount", "currentBasesCounter", "currentBasingCounter", "currentBasecount", "currentBasingNum", "currentChasescount", "currentBatchesCount", "currentBaseNum", "currentBatchesNum", "currentChaseCounter", "currentBasingcount", "currentChaseNum", "currentBasingCount", "currentChaseCount"], "currentEntriesCount": ["currentEntursOffset", "currentEntriesOffset", "currentEntursLimit", "currentAddriesOffset", "currentEntriesSize", "currentEnturesOffset", "currentEntrasCount", "currentEntursCount", "currentEntrasLimit", "currentAddriesLimit", "currentAdduresCount", "currentEnturesCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresSize", "currentEntrasSize", "currentAdduresLimit", "currentEntursSize", "currentEnturesSize", "currentEnturesLimit", "currentAddriesSize", "currentEntriesLimit", "currentAddriesCount"], "targetCount": ["targetSum", "patternSize", "targetcount", "patternCount", "TargetSize", "TargetSum", "argetSum", "argetcount", "patterncount", "Targetcount", "patternSum", "argetSize", "TargetCount", "argetCount", "targetSize"], "fastaChannel": ["fastasChannel", "fastasContext", "fastaqBuffer", "fastasContainer", "fastanContext", "fastasConnection", " fastaContext", " fastABuffer", "fastaqConnection", "fastaConnection", "fastasBuffer", "fastAConnection", "fastaqColumn", " fastAColumn", "fastaqChannel", "fastaContainer", "fastanBuffer", "fastABuffer", " fastAConnection", "fastaColumn", "fastAContext", " fastaConnection", "fastAChannel", " fastAChannel", " fastaColumn", "fastAContainer", " fastAContext", " fastAContainer", " fastaContainer", "fastanChannel", "fastasColumn", "fastanContainer", "fastaContext", "fastAColumn"], "totalSeqCount": ["totalSeqCounter", "totalQueqCount", "totalQueQNum", "totalSeuxNum", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQCounter", "totalSeQcount", "totalQueQCounter", "totalQueqcount", "totalQueqNum", "totalSeuxcount", "totalSeuxCount", "totalQueqCounter", "totalSeuxCounter", "totalSeqNum", "totalSeQNum", "totalSeqsCount", "totalSeqsNum", "totalQueQCount", "totalSeqscount"], "totalResiduesCount": ["totalResiduingNum", "totalResiduesSize", "totalResiduescount", "totalResqueuesNum", "totalResiduingCount", "totalResqueuescount", "totalResqueuresNum", "totalResiduationSize", "totalResqueurescount", "totalResiduationNum", "totalResiduresNum", "totalResiduationCount", "totalResiduationcount", "totalResiduingcount", "totalResqueuresSize", "totalResidurescount", "totalResiduresCount", "totalResiduesNum", "totalResqueuesSize", "totalResqueuresCount", "totalResqueuesCount", "totalResiduingSize", "totalResiduresSize"], "prevTime": ["PrevSize", "PrevValue", "commitSize", "commitFile", " prevSize", "PrevTime", "commitValue", " prevFile", "PrevFile", "prevFile", "commitTime", "prevValue", " prevValue", "prevSize"], "fastaFileSize": ["fastaBlockLength", "fastaBlockCount", "fastaPageAddress", "fastABufferAddress", "fastAFileSize", "fastaHeaderLength", "fastasFileSize", "fastAFileLength", "fastaLineCount", "fastAFileAddress", "fastaHeaderAddress", "fastAFileCount", "fastABufferLength", "fastaBlockSize", "fastaFilesLength", "fastaBufferSize", "fastaFileAddress", "fastasFileAddress", "fastaHeaderName", "fastasHeaderSize", "fastaHeaderSize", "fastaPageName", "fastaLineLength", "fastaFileName", "fastaBufferAddress", "fastaBlockAddress", "fastaFilesSize", "fastasHeaderLength", "fastaLineAddress", "fastasHeaderAddress", "fastaLineSize", "fastABufferSize", "fastABufferCount", "fastaFilesName", "fastasFileLength", "fastaBufferCount", "fastaFileLength", "fastaPageSize", "fastasHeaderName", "fastaBufferLength", "fastaFilesAddress", "fastasFileName", "fastaPageLength", "fastaFileCount"], "fastaFileReadOffset": ["fastaFileWriteAmount", "fastaFileRunEntry", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaFileWriteoffset", "fastaFileLoadAmount", "fastaBufferReadOffset", "fastaBufferReadoffset", "fastaFilesWriteLength", "fastaFileStartOff", "fastaFileRunoffset", "fastaFileReadoffset", "fastaFileReadLength", "fastaFileLengthLength", "fastaFilesReadoffset", "fastaFileWriteEntry", "fastaFilesReadOffset", "fastaFileLoadoffset", "fastaBufferReadAmount", "fastaBufferWriteOffset", "fastaFileReadOff", "fastaBufferWriteoffset", "fastaFileWriteOff", "fastaDirectoryReadEntry", "fastaFilesReadLength", "fastaFilesWriteoffset", "fastaDirectoryWriteOff", "fastaFileRunOff", "fastaBufferReadLength", "fastaFileLengthOffset", "fastaFileWriteOffset", "fastaFilereadoffset", "fastaFilereadLength", "fastaFileLoadOffset", "fastaFilesWriteOff", "fastaFileWriteLength", "fastaFileStartoffset", "fastaDirectoryWriteEntry", "fastaFileStartOffset", "fastaFileReadAmount", "fastaDirectoryReadoffset", "fastaDirectoryReadOff", "fastaFilereadOffset", "fastaFileLengthoffset", "fastaFileLoadLength", "fastaFileRunOffset", "fastaFilesReadOff", "fastaFileReadEntry", "fastaFilesWriteOffset", "fastaDirectoryWriteoffset", "fastaFileLengthOff", "fastaFileStartEntry", "fastaBufferWriteAmount", "fastaFileLengthAmount", "fastaFilereadOff", "fastaBufferWriteLength"], "partitionStartOffset": ["partitionsStartRange", "partitionEndOff", "partitionBufferOff", "partitionStartOff", "partitionsStartOrder", "partitionsEndOff", "partitionStopRange", "partitionBufferOrder", "partitionEndRange", "partitionsEndRange", "partitionsStartOffset", "partitionStopOrder", "partitionBufferRange", "partitionEndOrder", "partitionStopOff", "partitionStartOrder", "partitionStartRange", "partitionsEndOffset", "partitionsStartOff", "partitionBufferOffset", "partitionStopOffset", "partitionsEndOrder"], "bufferSize": ["BufferC", " bufferSIZE", "bufferC", "processC", "BufferSIZE", "processSIZE", "queueSize", "bufferType", "BufferSize", "BufferCount", "BufferType", " bufferCount", "bufferSIZE", "bufferCount", "processType", "queueCount", " bufferType", "processSize", " bufferC"], "fastaBuffer": ["fastasChannel", "FastaBuff", " fastABuff", " fastaBuff", "fastasContainer", "fastasPtr", "fastaaPtr", "fastanFile", "FastasPtr", "FastaStream", "fastAQueue", "fastasFile", "FastaBuffer", " fastasChannel", "fastaQueue", " fastABuffer", "fastaFile", " fastaFile", "fastaStream", "fastAFile", "fastaaBuff", "fastasBuffer", "FastasChannel", "fastanPtr", " fastAQueue", "fastanQueue", "fastaPtr", " fastAFile", "fastaceBuff", "fastaceChannel", "fastaContainer", "fastaaBuffer", "FastaPtr", "fastanBuffer", "FastasBuff", "fastABuffer", "fastasStream", "FastasBuffer", "fastAPtr", " fastasFile", " fastasContainer", "fastAChannel", " fastAChannel", "fastanStream", "fastasBuff", "fastaceBuffer", " fastasBuffer", "fastAContainer", "fastasQueue", "FastasStream", "fastaBuff", " fastaContainer", "fastanChannel", "fastABuff", "fastanBuff", "FastaChannel", "fastaaStream", "fastanContainer", "fastacePtr", " fastaQueue"], "fastaReadState": ["fastasReadstate", "fastasReaderState", "fastaReaderstate", "fastasReaderMode", "fastaReadstate", "fastaReadingState", "fastaReaderState", "fastaReadMode", "fastasReadType", "fastaFileMode", "fastasReadMode", "fastaFileState", "fastaReadingType", "fastasReaderType", "fastaReadType", "fastaReaderMode", "fastasReadState", "fastaFileType", "fastaFilestate", "fastaReaderType", "fastasReaderstate", "fastaReadingstate", "fastaReadingMode"], "nBytes": ["nFrames", " nParts", "obytes", "pbytes", "numFrames", "nFiles", " nFiles", "oParts", "pBytes", "numBytes", "NBytes", "oBytes", "NParts", " nbytes", "lenFrames", "lenbytes", "oFiles", "NByte", " nFrames", "pParts", "Nbytes", "lenFiles", "pByte", "nByte", "nbytes", " nByte", "NFiles", "nParts", "numbytes", "lenBytes", "numFiles"]}}
{"id1": "15797402", "id2": "494226", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"parse": ["replace", "save", "pack", " parsing", "report", "se", "processing", "apply", "view", " process", "scan", " rewrite", " serve", "arse", "parser", "raw", "wrap", "set", "split", "read", " split", "handle", "process", "xml", "print", "worker", " parser", "transform", " transform", "fork", "pc", "patch", "load", "Parser", "service", " analyse", "php", "cover", " dispatch", " convert", "http", "request", "rate"], "stream": ["sample", "writer", "url", "resource", "image", "server", "message", "view", "Stream", "form", "remote", "data", "raw", "channel", "in", "document", "draw", "input", "stack", "read", "through", "handle", "download", "temp", "source", "reader", "src", "client", "inner", "video", "load", "file", "upload", "loader", "down", "response", "content", "iterator", "http", "feed"], "handler": ["writer", "default", "server", "parent", "connection", "event", "info", "data", "parser", "channel", "application", "controller", "hand", "Handler", "phase", "h", "monitor", "handle", "driver", "reader", "client", "di", "base", "handled", "loader", "service", "ctx", "host", "function", "response", "wrapper", "layer", "pointer", "format", "collection", "manager", "processor"], "metadata": ["mon", "m", "attribute", "component", "management", "subject", "uri", "message", "module", "resource", "met", "processor", "connection", "material", "info", "data", "md", "parser", "document", "managed", "mx", "map", "metry", "storage", "template", "meta", "monitor", "xml", "plugin", "source", "config", "properties", "header", "directory", "di", "mi", "runtime", "params", "property", "ctx", "mt", "json", "state", "adata", "content", "collection", "manager", "database"], "context": ["proxy", "text", "component", "subject", "txt", " Context", "resource", "message", "parent", "scope", "cmp", "system", "connection", "event", "method", "data", "tx", "entry", "document", "mc", "translation", "Context", "xml", "instance", "element", "reader", "config", "command", "object", "kernel", "ctx", "environment", "content", "concept", "collection", "manager", "request", "processor", " contexts"], "name": ["NAME", "ame", "prefix", "m", "common", "url", "default", "resource", "message", "image", "call", "large", "null", "n", "connection", "none", "data", "version", "child", "sync", "old", "part", "no", "in", "alias", "search", "model", "route", "named", "missing", "job", "key", "type", "code", "time", "source", "class", "comment", "Name", "action", "size", "filename", "api", "work", "base", "object", "id", "address", "names", "string", "file", "full", "path", "word", "active", "label", "on"], "out": ["page", "ex", "writer", "url", "resource", "image", "server", "plain", "copy", "null", "connection", "manager", "io", "data", "child", "sync", "socket", "channel", "output", "in", "cos", "result", "exp", "o", "Out", "conn", "temp", "instance", "source", "flush", "builder", "client", "outs", "user", "object", "bin", "file", "obj", "err", "window", "extra", "OUT", "path", "pool", "again", "ray", "line", "lib", "ext"]}}
{"id1": "62362", "id2": "18782385", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "20995534", "id2": "3375718", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromclassloader", "loadPropertiesFromclasspath", "loadPropertiesFromClassfile", "loadPropertiesfromClasspath", "loadPropertiesfromclassfile", "loadPropertiesfromClassloader", "loadPropertiesFromSubfile", "loadPropertiesFromClassloader", "loadPropertiesFromSubloader", "loadPropertiesfromClassname", "loadPropertiesFromclassfile", "loadPropertiesFromclassname", "loadPropertiesFromSubname", "loadPropertiesfromclasspath", "loadPropertiesFromClassname", "loadPropertiesfromclassloader", "loadPropertiesFromSubpath", "loadPropertiesfromClassfile", "loadPropertiesfromclassname"], "path": ["prop", "prefix", "text", "request", "log", "uri", "resource", "parent", "method", "data", "ath", "part", "PATH", "route", "template", "error", "key", "type", "xml", "source", "config", "properties", "dir", "filename", "work", "Path", "base", "object", "id", "string", "handler", "c", "name", "loader", "root", "pattern", "host", "full", "context", "location", "pointer", "content", "value", "level", "enc", "p"], "locations": ["operators", "LOCation", " locors", "Lococations", "locions", "Locator", "slATIONS", "colions", "LOCocations", "locator", "LOCions", "Loclements", "LOCors", "Locors", "LocATIONS", "LOCations", "colations", "slators", "locors", "sllements", "Location", "Locions", "locibraries", "Locations", "locATIONS", "colation", " locATIONS", " locator", "lococations", "operations", "LOCATIONS", " location", " locibraries", "slations", "colATIONS", "slibraries", " loclements", "location", "locators", "operation", "operibraries", " lococations", "slation", "loclements", "slator", " locators"], "props": ["suppperties", "pbs", "posps", "propps", "protros", "protbs", " propps", "procs", " propp", " properties", "produpps", "posbs", "suppcs", "produperties", "pebs", " procs", "peperties", "supppps", "probs", " probs", "proros", "properties", "protperties", "peps", "pps", "producs", "peros", "pperties", "suppps", "ppp", "posperties", "propp", "protps", "pbperties", "pbbs", "pospp", "produps", "pbros", "pbps"], "url": ["ls", "uri", "ssl", "e", "resource", "ll", "b", "connection", "loc", "rel", "org", "entry", "f", "route", "str", "URL", "coll", "href", "bel", "out", "key", "el", "element", "i", "class", "source", "src", "rl", "l", "lr", "base", "user", "r", "id", "address", "string", "gl", "ource", "file", "err", "obj", "name", "ob", "sl", "layer", "location", "Url", "http", "feed"], "in": ["into", "ex", "ins", "resource", "image", "In", "n", "connection", "init", "io", "data", "inc", "socket", "f", "gin", "it", "impl", "input", "din", "IN", "inn", "lin", "s", "out", "conn", "i", "is", "source", "config", "reader", "src", "a", "stream", "nin", "login", "inner", "r", "id", "ac", "bin", "file", "c", "err", "con", "ic", "ini", "as", "again", "serv", "isin"]}}
{"id1": "19206412", "id2": "4458076", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public InputStream getInputStream() throws TGBrowserException {\n        try {\n            if (!this.isFolder()) {\n                URL url = new URL(this.url);\n                InputStream stream = url.openStream();\n                return stream;\n            }\n        } catch (Throwable throwable) {\n            throw new TGBrowserException(throwable);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"md5String": ["md6Str", "md6String", "md4String", " md5Str", "md6string", "md4string", "md512string", "md5string", " md512Str", "md512String", "md6Bytes", "md5Str", "md512Bytes", " md5string", " md512Bytes", " md512string", " md512String", "md4Str", "md5Bytes", " md5Bytes", "md512Str", "md4Bytes"], "str": ["kr", "Str", "text", "fr", "txt", "arr", "STR", "e", "stri", "url", "st", "star", "dr", "data", "msg", "this", "f", "result", "exp", "bytes", "out", "s", "dict", "pass", "self", "er", "strings", "tr", "r", "string", "br", "err", "obj", "name", "re", "sr", "sp", "hr", "enc", "doc", "char"], "md": ["m", "hd", " MD", "Cmd", " Md", "mp", "cmp", "cmd", "data", "mo", "um", "dig", "dd", "rpm", "map", "mc", "mag", "d", "vd", "sum", "od", "me", "ms", "hm", "mb", "code", "amd", "mg", "dm", "bd", "wd", "metadata", "pd", "MD", "db", "ad", "mac", "mand", "mm", "sm", "ma", "am", "ld", "mk", "pm", "mt", "cd", "mu", "mail", "mod", "dh", "df"], "hash": ["filter", "ash", "array", "url", "arr", "image", "html", "count", "sha", "body", "rh", "dot", "part", "search", "range", "f", "her", "check", "hex", "sum", "index", "error", "key", "h", "code", "ver", "kh", "memory", "print", "header", "number", "base", "tr", "id", "cache", "address", "chip", "bin", "host", "ha", "diff", "Hash", "sh", "value", "block", "char"], "hexChars": ["hexKhashes", "hashCHashes", "hexCHashes", "hexCHacters", " hexChashes", "hexchashes", "hexCharacters", "hashchARS", "hashChash", "hexKhash", "hashchases", "hexCHases", "hexChashes", "hexCharashes", "hexCharats", "hexCharars", "hashCHARS", "hexCHats", " hexChats", "hexCash", "hexChARS", "hashchacters", "hexChats", "hexChases", "hashChars", "hexCharases", "hexchacters", " hexchARS", "hexchats", " hexchashes", "hashCHash", "hexKhars", "hashChacters", "hexChacters", "hashChashes", "hexchars", "hexchARS", " hexchats", "hexCHars", " hexchars", "hashChases", "hexCHash", "hexChash", "hashCHars", "hashchars", "hexCharARS", " hexChARS", "hexKhARS", "hexCashes", "hashChARS", "hexCars", "hexCHARS", "hexchases", "hexCARS"], "res": ["css", "cons", "resp", "ros", "req", "rss", "des", "rows", "arr", "details", "ss", "ps", "rs", "ress", "rev", "data", "reg", "result", "es", "RES", "vs", "pres", "us", "bytes", "out", "s", "Rs", "RS", "results", "rus", "vals", "ras", "Result", "rez", "r", "cache", "string", "err", "ris", "re", "resolution", "Res", "rules", "ret", "response", "cs", "abs", "rex", "Results", "pers", "bs", "vers"], "i": ["k", "m", "u", "uri", "e", "j", "length", "b", "io", "info", "si", "ie", "part", "in", "field", "f", "it", "o", "index", "d", "ci", "h", "oi", "iu", "ji", "code", "abi", "temp", "multi", "y", "li", "a", "di", "l", "ip", "pi", "xi", "base", "hi", "id", "ti", "v", "gi", "c", "ri", "ix", "I", "ai", "phi", "diff", "ii", "ui", "x", "bi", "qi", "mu", "p"]}}
{"id1": "13421722", "id2": "4798332", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"getFileSize": [" getFileBytes", "getfileLength", "getFilesInfo", "getByteLength", "getfileInfo", " getfileLength", " getfileSize", "getByteBytes", "getFilesSize", "getByteSize", "getFileInfo", " getFileInfo", "getFilesBytes", " getfileInfo", "getfileBytes", " getfileBytes", "getFileBytes", "getFilesLength", " getFileLength", "getFileLength", "getByteInfo", "getfileSize"], "address": ["prefix", "attribute", "array", "uri", "localhost", "report", "resource", "server", "message", "offset", "data", "port", "output", "route", "str", "type", "Address", "code", "source", "addr", "config", "size", "network", "target", "ip", "number", "base", "point", "position", "object", "email", "string", "name", "reference", "host", "location", "path", "content", "format", "request"], "url": ["ur", "page", "proxy", "log", "uri", "ssl", "resource", "image", "server", "e", "ll", "html", "build", "loc", "io", "org", "session", "socket", "channel", "f", "impl", "result", "www", "URL", "str", "job", "conn", "xml", "api", "config", "client", "l", "web", "lr", "base", "user", "object", "found", "string", "orb", "file", "service", "ob", "sl", "host", "bug", "path", "Url", "location", "http", "feed", "lib"], "connection": ["to", "proxy", "uri", "resource", "server", "communication", "event", "io", "info", "version", "session", "socket", "bc", "channel", "Connection", "application", "entry", "connect", "out", "conn", "connected", "config", "section", "client", "control", "object", "position", "character", "handler", "c", "con", "service", "relation", "reference", "environment", "context", "function", "response", "wrapper", "or", "current", "condition", "collection", "http", "use", "request", "open", "database"]}}
{"id1": "2668853", "id2": "2324868", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFiletoStream", "decodeFileAsfile", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeString2File", "decodeFileTofile", "decodeFileAsStream", "decodeStringToFile", "decodeStringTofile", "decodeString2file", "decodeStringToStream", "decodeString2Files", "decodeFileToFiles", "decodeFiletoFile", "decodeFiletoFiles", "decodeFileAsFiles", "decodeFile2file", "decodeFile2Files", "decodeStringToFiles", "decodeFiletofile"], "infile": ["infp", " infiles", "inputfiles", "inputFile", "outfp", "outfilename", "inFile", " inFile", "minfp", "inputfp", "infiles", "infilename", "inputfilename", "minfilename", "minFile", "inputfile", "outfiles", "outFile", "minfile", " infilename"], "outfile": ["infp", " outfilename", "Outfull", " outfull", "outputfilename", " outfolder", "outputfolder", "outputfp", "outfp", " outFile", "outfilename", "outputFile", "Outfolder", " outfp", "outfolder", "infilename", "outputfull", "infolder", "outFile", "Outfile", "outfull", "OutFile", "outputfile"], "in": ["m", "ex", "ins", "e", "image", "In", "b", "init", "data", "this", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "cin", "i", "is", "win", "source", "reader", "rin", "inside", "a", "nin", "login", "inner", "min", "r", "ac", "bin", "err", "con", "ic", "re", "up", "pin", "ini", "as", "again"], "out": ["to", "exit", "ex", "writer", "write", "image", "copy", "In", "b", "lock", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "exp", "o", "Out", "error", "s", "conn", "home", "pass", "client", "co", "target", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "other", "up", "net", "OUT", "op", "as", "ext", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "pad", "url", "resource", "server", "length", "null", "b", "offset", "data", "Buffer", "limit", "shape", "result", "input", "split", "batch", "bytes", "row", "flush", "iter", "memory", "reader", "source", "size", "buff", "seed", "base", "queue", "slice", "address", "bin", "binary", "reference", "pause", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["k", " receive", " r", "count", " find", "reading", "fill", "pass", "ad", "send", "r", "exec", "start", "find", " send", " Read", "inc", "limit", "input", " check", "index", "Read", " write", " use", "add", "parse", "iter", " request", "skip", " reader", "x", "feed", " load", "play", "length", "sync", "check", "reads", " ride", "seek", "run", "tell", "end", "size", " reach", "ind", "id", " get", "wait", "next", " copy", " parse", "use", "open", "write", "se", "copy", " connect", "lex", "allow", "ride", "connect", "READ", "reader", "work", "load", "select", "get", "current", "sleep", " sleep", "line"], "success": ["warning", "danger", "default", "rolling", "successfully", "good", "null", "complete", "ok", "correct", "failed", "cess", "successful", "data", "func", "winner", " Success", "follow", "status", "selected", "result", "fail", "valid", "yes", "done", "error", "job", "accept", " succeed", " successful", "pass", "results", "Success", "roll", "true", " succ", "found", "initial", "safe", "continue", "rolled", "ceed", "full", "first", "response", "fast", "content", "ccess", "again", "zero", "value", "better", "construct"]}}
{"id1": "21438069", "id2": "19608872", "code1": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createNewProjectDeploymentConfig": ["createNewProjectDeployizationFile", "createNewProjectDeployerConfig", "createNewProjectDeployerInfo", "createNewProjectDeploymentInfo", "createNewProjectDeploymentsConfiguration", "createNewProjectDeploymentsFile", "createNewProjectDeploymentFile", "createNewProjectDeployizationConfiguration", "createNewProjectDeploymentConfiguration", "createNewProjectDeploymentsConfig", "createNewProjectDeployizationInfo", "createNewProjectDeploymentsInfo", "createNewProjectDeployerFile", "createNewProjectDeployerConfiguration", "createNewProjectDeployizationConfig"], "projectID": ["packageID", "projectIDs", "projectId", "projectType", "packageIDs", " projectType", "packageType", "projectIL", "packageid", " projectIP", "appID", " projectIDs", "appid", "subjectId", "configIP", "subjectID", "databaseid", "projectIP", "configID", " projectId", "contractType", "configId", "documentid", " projectid", "packageId", "projectid", "configid", " projectIL", "subjectid", "databaseIDs", "appIL", "documentIL", "documentID", "contractid", "appId", "databaseId", "databaseID", "subjectIP", "documentId", "contractID"], "name": ["ame", "NAME", "prefix", "common", "custom", "menu", "image", "parent", "n", "nice", "database", "none", "an", "profile", "version", "username", "data", "session", "title", "part", "alias", "no", "definition", "model", "block", "named", "job", "type", "pass", "plugin", "time", "mini", "create", "Name", "with", "vision", "filename", "size", "id", "na", "names", "string", "address", "creation", "path", "ui", "word", "value", "release", "label", "on", "ename"], "description": ["NAME", "secret", "text", "direction", "des", "esc", "unit", "message", "image", "resource", "uri", "details", "summary", "reason", "version", "username", "duration", "title", "display", "definition", "document", "model", "password", "escription", "type", "comment", " descriptions", "section", "vision", "filename", "expression", "design", "position", "video", "language", "string", "desc", "category", "address", "environment", "location", "operation", "release", "value", "label", "Description"], "config": ["text", "log", "ct", "struct", "uc", "conf", "cfg", "cmd", "rc", " exc", "data", "project", "bc", "cos", "output", "spec", "result", "acc", "sec", "ch", "cb", "settings", "out", "conn", "dict", "instance", "cat", "driver", "section", "client", "gui", "db", " cache", "cache", "exec", "Config", "c", "obj", "service", "def", " lib", "ctx", "proc", "Configuration", "cf", "json", "cont", "current", "lc", "ca", "lib", "ext"], "connection": ["log", "unit", "resource", "message", "server", "image", "communication", "volume", "loc", "lock", "version", "si", "session", "sql", "engine", "socket", "bc", "channel", "Connection", "application", "document", "cond", "connect", "ion", "index", "password", "graph", "error", "container", "conn", "connected", "driver", "section", "client", "directory", "network", "db", "cache", "con", "c", "machine", "relation", "ctx", "context", "pool", "response", "condition", " Connection", "state", "function", "collection", "manager", "use", "database", "ongo"], "statement": ["Session", "writer", "unit", "report", "server", "se", "ss", "summary", "si", "session", "sql", "link", "parser", "usage", "sequence", "Connection", "status", "document", "result", "connect", "str", "commit", "storage", "stat", "conn", "pass", "instance", "i", "comment", "driver", "Statement", "section", "parse", "li", "di", "expression", "db", "command", "table", "string", "ment", "relation", "function", "mt", "response", "condition", "state", "git", "note", "execute", "collection", "use", "ri", "database", "serv"], "resultSet": ["resultsSet", "resultLine", " resultLine", "rowSource", "pageSource", "resultSc", "ResultList", " resultSc", "responseS", "resultList", "ResultRow", "rowSet", "ResultSet", "resultGen", "pageSet", "resultSource", "resultsGen", "rowLine", "pageRow", "resultS", "ResultSc", "responseSc", " resultList", "responseList", "resultsList", "ResultLine", "responseSet", " resultSource", "ResultSource", "responseSource", "resultsSource", "ResultS", " resultRow", " resultS", "ResultGen", " resultGen", "resultRow"], "query": ["filter", "m", "uri", "message", "report", "module", "call", "resource", "scope", "script", "style", "scan", "lock", "Query", "sql", "in", "search", "qu", "result", "rule", "str", "password", "error", "key", "type", "out", "go", "code", "sq", "timeout", "i", "comment", "create", "parse", "expression", "work", "command", "table", "send", "id", "string", "question", "select", "root", "function", "qq", "condition", "json", "update", "where", "q", "database", "request", "join"], "msg": ["m", "og", "text", "req", "gen", "log", "cap", "message", "e", "rag", "html", "g", "cfg", "cmd", "fg", "reason", "mr", " message", "loc", "dr", "tag", "ug", "ge", "md", "title", "phrase", "var", "status", "agg", "fm", "str", "map", "tool", "error", "nm", "type", "essage", "bf", "mg", "pkg", "gm", "bg", "gor", "sg", "rr", "mn", "Msg", "id", "desc", "err", "mor", "ma", "comm", "gr", "op", "mt", "gs", "format", "ag", "Message", "exc", "doc", "ext", "char"]}}
{"id1": "21348951", "id2": "88047", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"processAddByURLSubmit": ["processAddByURLSubmitted", "processAddByURLSummitter", "processAddByURlsubmitted", "processAddByURLSsubmission", "processAddByURlsUBmit", "processAddByURLSubmitter", "processAddByURLSubmission", "processAddByURLSummission", "processAddByURLSummitted", "processAddByURLSUBmission", "processAddByURlsUBmitted", "processAddByURlsUBmission", "processAddByURlsubmit", "processAddByURLSUBmitted", "processAddByURLSUBmitter", "processAddByURlsubmitter", "processAddByURLSUBmit", "processAddByURlsUBmitter", "processAddByURlsubmission", "processAddByURLSummit", "processAddByURLSsubmitter", "processAddByURLSsubmitted", "processAddByURLSsubmit"], "url": ["ur", "ls", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "e", "connection", "loc", "io", "org", "data", "ug", "link", "entry", "route", "str", "URL", "www", "ref", "xml", "source", "src", "l", "stream", "base", "user", "email", "address", "string", "file", "ob", "sl", "host", "location", "Url", "path", "buffer", "secure", "http", "feed"], "invalidUrlMsg": ["invalidTimeMessage", "invalidTimeMsg", "invalidURLmsg", "inbadUrlmsg", "invalidFileUrl", "invalidFileog", "invalidFileMsg", "invalidUrMessage", "inInvalidURLMessage", "inbadFileog", "invalidStringMessage", "invalidURLUrl", "invalidStringmsg", "invalidUrmsg", "inInvalidUrlMsg", "inbadFileMsg", "inInvalidURLMsg", "invalidURLMsg", "inbadFilemsg", "inInvalidUrlStr", "invalidUrlmsg", "invalidStringMsg", "inbadUrlog", "inbadUrlMsg", "invalidURLMessage", "invalidFileMessage", "inbadFileMessage", "inbadUrlMessage", "invalidFileStr", "inInvalidURLmsg", "inInvalidURLUrl", "invalidStringUrl", "inInvalidUrlUrl", "invalidUrog", "invalidTimemsg", "invalidURLog", "invalidUrlMessage", "inInvalidUrlMessage", "invalidUrlog", "invalidTimeStr", "invalidUrlStr", "inInvalidURLStr", "invalidFilemsg", "invalidUrlUrl", "inInvalidUrlmsg", "invalidUrMsg", "invalidURLStr"], "xmlSourceWriter": ["xmlourceWriter", "xmlServiceWritten", "xmlInputWrite", "xmlSourceWritten", "xmlourceReader", "xmlReaderWrite", "xmlStrWriter", "jsonReaderReader", "xmlSourceString", "xmlServicewriter", "xmlourceString", "jsonSourceWriter", "jsonSourceWritten", "xmlServiceReader", "xmlStringReader", "xmlReaderWriter", "jsonSourceReader", "jsonStringReader", "xmlServiceWriter", " xmlSourceReader", " xmlSourceString", " xmlourceWritten", "xmlStringwriter", "jsonStringWriter", "jsonReaderWrite", "jsonSourceWrite", " xmlourceReader", "xmlResourceReader", "xmlInputWriter", "xmlServiceWrite", "xmlInputWritten", "xmlStringWrite", "xmlReaderWritten", "jsonStringwriter", "xmlStrwriter", "xmlSourceWrite", " xmlSourceWritten", " xmlourceWriter", "xmlSourceReader", "xmlStrReader", "xmlReaderReader", "xmlResourceString", " xmlourceString", "jsonReaderWritten", "xmlInputString", "xmlSourcewriter", "xmlStrWrite", "xmlStringWriter", "xmlResourceWritten", "xmlInputReader", "jsonReaderWriter", "jsonSourcewriter", "xmlourceWritten", "jsonStringWrite", "xmlResourceWriter"]}}
{"id1": "21438069", "id2": "18164929", "code1": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"createNewProjectDeploymentConfig": ["createNewProjectDeployizationFile", "createNewProjectDeployerConfig", "createNewProjectDeployerInfo", "createNewProjectDeploymentInfo", "createNewProjectDeploymentsConfiguration", "createNewProjectDeploymentsFile", "createNewProjectDeploymentFile", "createNewProjectDeployizationConfiguration", "createNewProjectDeploymentConfiguration", "createNewProjectDeploymentsConfig", "createNewProjectDeployizationInfo", "createNewProjectDeploymentsInfo", "createNewProjectDeployerFile", "createNewProjectDeployerConfiguration", "createNewProjectDeployizationConfig"], "projectID": ["packageID", "projectIDs", "projectId", "projectType", "packageIDs", " projectType", "packageType", "projectIL", "packageid", " projectIP", "appID", " projectIDs", "appid", "subjectId", "configIP", "subjectID", "databaseid", "projectIP", "configID", " projectId", "contractType", "configId", "documentid", " projectid", "packageId", "projectid", "configid", " projectIL", "subjectid", "databaseIDs", "appIL", "documentIL", "documentID", "contractid", "appId", "databaseId", "databaseID", "subjectIP", "documentId", "contractID"], "name": ["ame", "NAME", "prefix", "common", "custom", "menu", "image", "parent", "n", "nice", "database", "none", "an", "profile", "version", "username", "data", "session", "title", "part", "alias", "no", "definition", "model", "block", "named", "job", "type", "pass", "plugin", "time", "mini", "create", "Name", "with", "vision", "filename", "size", "id", "na", "names", "string", "address", "creation", "path", "ui", "word", "value", "release", "label", "on", "ename"], "description": ["NAME", "secret", "text", "direction", "des", "esc", "unit", "message", "image", "resource", "uri", "details", "summary", "reason", "version", "username", "duration", "title", "display", "definition", "document", "model", "password", "escription", "type", "comment", " descriptions", "section", "vision", "filename", "expression", "design", "position", "video", "language", "string", "desc", "category", "address", "environment", "location", "operation", "release", "value", "label", "Description"], "config": ["text", "log", "ct", "struct", "uc", "conf", "cfg", "cmd", "rc", " exc", "data", "project", "bc", "cos", "output", "spec", "result", "acc", "sec", "ch", "cb", "settings", "out", "conn", "dict", "instance", "cat", "driver", "section", "client", "gui", "db", " cache", "cache", "exec", "Config", "c", "obj", "service", "def", " lib", "ctx", "proc", "Configuration", "cf", "json", "cont", "current", "lc", "ca", "lib", "ext"], "connection": ["log", "unit", "resource", "message", "server", "image", "communication", "volume", "loc", "lock", "version", "si", "session", "sql", "engine", "socket", "bc", "channel", "Connection", "application", "document", "cond", "connect", "ion", "index", "password", "graph", "error", "container", "conn", "connected", "driver", "section", "client", "directory", "network", "db", "cache", "con", "c", "machine", "relation", "ctx", "context", "pool", "response", "condition", " Connection", "state", "function", "collection", "manager", "use", "database", "ongo"], "statement": ["Session", "writer", "unit", "report", "server", "se", "ss", "summary", "si", "session", "sql", "link", "parser", "usage", "sequence", "Connection", "status", "document", "result", "connect", "str", "commit", "storage", "stat", "conn", "pass", "instance", "i", "comment", "driver", "Statement", "section", "parse", "li", "di", "expression", "db", "command", "table", "string", "ment", "relation", "function", "mt", "response", "condition", "state", "git", "note", "execute", "collection", "use", "ri", "database", "serv"], "resultSet": ["resultsSet", "resultLine", " resultLine", "rowSource", "pageSource", "resultSc", "ResultList", " resultSc", "responseS", "resultList", "ResultRow", "rowSet", "ResultSet", "resultGen", "pageSet", "resultSource", "resultsGen", "rowLine", "pageRow", "resultS", "ResultSc", "responseSc", " resultList", "responseList", "resultsList", "ResultLine", "responseSet", " resultSource", "ResultSource", "responseSource", "resultsSource", "ResultS", " resultRow", " resultS", "ResultGen", " resultGen", "resultRow"], "query": ["filter", "m", "uri", "message", "report", "module", "call", "resource", "scope", "script", "style", "scan", "lock", "Query", "sql", "in", "search", "qu", "result", "rule", "str", "password", "error", "key", "type", "out", "go", "code", "sq", "timeout", "i", "comment", "create", "parse", "expression", "work", "command", "table", "send", "id", "string", "question", "select", "root", "function", "qq", "condition", "json", "update", "where", "q", "database", "request", "join"], "msg": ["m", "og", "text", "req", "gen", "log", "cap", "message", "e", "rag", "html", "g", "cfg", "cmd", "fg", "reason", "mr", " message", "loc", "dr", "tag", "ug", "ge", "md", "title", "phrase", "var", "status", "agg", "fm", "str", "map", "tool", "error", "nm", "type", "essage", "bf", "mg", "pkg", "gm", "bg", "gor", "sg", "rr", "mn", "Msg", "id", "desc", "err", "mor", "ma", "comm", "gr", "op", "mt", "gs", "format", "ag", "Message", "exc", "doc", "ext", "char"]}}
{"id1": "1698200", "id2": "14303294", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginBitShares", "loginBandRay", "loginbitShares", "loginbitshare", " loginBitRay", "loginBandshare", " loginBitshare", " loginBitShares", "loginbitShare", "loginBitshare", "loginBandShares", "loginBandShare", "loginbitRay", "loginBitRay"], "params": ["ls", "param", "page", "lp", "ssl", "eters", "server", "details", "cmp", "par", "manager", "ps", "fps", "options", "parts", "ns", "parser", "reports", "phrase", "radius", "bis", "vs", "Parameters", "photos", "settings", "results", "posts", "api", "parse", "properties", "config", "license", "ip", "Par", "pi", "base", "eps", "cache", "mm", "ams", "ops", "ctx", "pm", "php", "rules", "words", "json", "pro", "utils", "services", "http", "p", "ds"], "httpclient": ["ttpserver", "webserver", "httpsclient", "httpsapi", " httphttp", "phpapi", "htmlclient", "ttpClient", "httpsconnection", "htmlresponse", "webClient", "httpClient", "webclient", " httpapi", "httpconnection", "ttphttp", "httpsresponse", "httphttp", " httpserver", "httpsClient", "phpclient", " httpClient", "phpconnection", "httpserver", "htmlClient", "httpapi", "phpClient", "webhttp", " httpconnection", "ttpclient", "htmlconnection"], "httppost": ["httpport", " httplost", " httplort", "httpoint", "httpperost", "httphort", "httphost", "httppeost", " httpoint", " httposter", "httport", " httppeood", "httpood", "httppsoint", " httppeost", "httppeoint", "httcppood", "httcpposter", " httppood", " httploster", "httcppost", " httppoint", " httpprost", "httphoster", "httpprost", " httpost", "httplpost", "httppsost", " httprost", "httploster", "httppsoster", "httplost", "httprost", " httpposter", " httppeoster", "httppoint", "httpposter", "httppood", "httcppoint", "httphpost", "httposter", "httpppost", "httpost", " httppeoint", "httppeoster", " httpport", "httplort", " httpppost", "httppeood", " httplpost", "httppsrost"], "formparams": ["formparam", "formedblock", "Formparams", "FORMams", "formedams", "Formsettings", "handargs", "fauthors", "feedparam", "formams", "feedsettings", "feedparams", "feedams", "handParameters", "handams", "headparam", "formargs", " formblock", "formauthors", "fams", "fparams", " formams", " formparam", "Formparam", "FORMparams", " formnames", " formsettings", "FORMblock", " formargs", "formnames", "formedparam", "FORMparam", "FormParameters", "headnames", " formauthors", "Formargs", "formedparams", "formsettings", "formParameters", "handparams", "Formams", "formedauthors", "Formnames", "headams", " formParameters", "fparam", "headparams", "formblock"], "entity": ["page", " entities", "url", "ities", "e", "resource", "server", "html", "body", "connection", "form", "Entity", "event", "data", "output", "ec", "entry", "document", "model", "result", "translation", "ent", "type", "el", "xml", "api", "article", "db", "et", "object", "email", "file", " Entity", "service", "environment", "json", "response", "query", "content", "collection", "person"], "httpresponse": ["phpresponse", "phpresp", "htmlclient", "htmlresponse", " httpresp", "hyperclient", "Httpresponse", "hyperserver", "httpresp", " httpserver", "phpserver", "htmlserver", "httpserver", "hyperresponse", "Httpserver", "Httpresp"], "it": ["ort", " It", "ins", "ct", "ait", "IT", "It", "st", "init", "ul", "iti", "si", "you", "not", "in", "ati", "entry", "iv", "set", "index", "itted", "sort", "and", "end", "the", "i", "ist", "mit", "l", "edit", "ip", "lit", "slice", "pit", "ind", "which", "ic", "start", "I", "op", "ite", "cont", "or", "iz", "quit", "its", "rit"], "escookie": ["Escaddy", " escaddy", "Escerve", "ascinel", "descenter", "estaddy", "escinel", " esccookie", "ascake", "escake", "ascaddy", "sccel", " enookie", "estenter", "scale", " encookie", "escenter", "cookie", "ecookie", "esccookie", "eccookie", "scake", "scookie", "Escenter", "ascale", "esccel", "desccel", "Escinel", "ascookie", "descake", "caddy", "escoding", "Esccel", "ascerve", "escaddy", "escale", "Escookie", "asccel", "estookie", "descaddy", "cerve", "ecoding", "ecaddy", "escerve", "descookie", "estcel", " escoding", "cinel", " enoding", "descale", " enaddy"]}}
{"id1": "12097948", "id2": "659316", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 0, "substitutes": {"systemID": [" systemName", "sysName", "classURI", "SystemRI", " systemURL", "SystemID", "SystemIDs", "sysID", "classId", "classIDS", " systemRI", " systemId", "sysIDs", "systemRI", " systemIDs", "sysURI", "sysId", "SystemURL", "sysRI", "systemId", "SystemId", "systemURL", "SystemIDS", "classID", "systemName", " systemURI", "systemURI", "SystemName", "SystemURI", "systemIDS", "sysURL", "systemIDs", " systemIDS"], "id": ["ID", "ide", "uri", "kid", "resource", "one", "image", "style", "init", "like", "data", "info", "mid", "sid", "part", "in", "entry", "it", "f", "aid", "Id", "pid", "end", "error", "type", "and", "key", "code", "rid", "xml", "element", "i", "is", "create", "uid", "modified", "source", "ip", "ad", "base", "ids", "address", "layout", "string", "file", "start", "name", "path", "ident", "value", "did", "http", "oid"], "loader": ["loaded", "log", "resource", "module", "system", "loc", "lock", "init", "acl", "parser", "rar", "loading", "folder", "impl", "cl", "container", "class", "builder", "driver", "reader", "library", "l", "er", "Loader", "user", "cache", "load", "file", "handler", "up", "layer", "pool", "path", "lc", "buffer", "util", "lang"], "url": ["ur", "ls", "uri", "fr", "resource", "ll", "image", "server", "ssl", "b", "loc", "rc", "il", "event", "io", "this", "link", "impl", "f", "rule", "URL", "coll", "job", "download", "xml", "source", "pull", "api", "src", "rl", "client", "l", "stream", "lr", "base", "r", "address", "string", "file", "name", "service", "sl", "location", "Url", "path", "buffer", "http", "feed", "lib"], "inStream": ["innstream", " inReader", "InStream", "INSteam", "inSteam", "inputSteam", "conString", "innSocket", "INStreamer", " inStreamer", "conStreamer", "inReader", "outReader", "INStream", "innSteam", "instream", "innStream", "inputReader", " inSteam", "inSocket", "outStream", "inputStream", "conStream", "inString", "InSteam", "outSteam", "Instream", "conSteam", "inStreamer", "InSocket", "outstream", "INString", " inString", "inputstream", " instream", "outSocket"], "constraints": ["containts", "Constaint", "contions", "Constrains", "constaints", "constains", "containt", "constaint", "Constraint", "concomplaint", "concomplions", "Constions", "Constraints", "constraint", "Constaints", "constrains", "contains", "concomplains", "constrions", "Constains", "constions", "Constrions", "concomplaints"]}}
{"id1": "14168494", "id2": "5061606", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferClass", "copyfile", " copyfile", " copyClass", " copiedClass", "transferfile", " copiedFile", "copyFiles", "copyClass", " copiedFiles", " copiedfile", "transferFiles", "transferFile"], "dest": [" Dest", "txt", "resource", "null", "st", "Dest", "loc", "destroy", "data", "later", "this", "output", "d", "done", "comb", "out", " destination", "temp", "source", "class", "dir", "true", "tmp", "target", "desc", "file", "obj", "dist", "sup", "name", "wb", "path", "transfer", "orig"], "src": ["url", "ssl", "rob", "copy", "master", "st", "loc", "Dest", "rc", "sync", "sb", "inst", "split", "rb", "storage", "cb", "s", "sq", "download", "sin", "source", "config", "tmp", "filename", "sub", "stream", "target", "slice", "sc", "sit", "bin", "file", "dist", "sup", "upload", "gb", "sl", "sel", "img", "ds"], "srcChannel": ["destChannel", "inputChannel", " srcCh", "rcButton", "distStream", " srcButton", "rcCh", "rcChan", "sourceChannel", "srcCh", "srcChan", "distChan", "rcConnection", "srcButton", "distCh", "rcSection", "sourceButton", "inputchannel", "destchannel", "distChannel", " srcchannel", "sourcechannel", "inputConnection", "rcchannel", "destConnection", "srcStream", "rcChannel", "srcchannel", "srcConnection", "sourceChan", "srcSection", "inputSection", " srcSection", " srcConnection", " srcChan", "destChan", "rcStream", " srcStream"], "dstChannel": ["dstsStream", "ddestStream", " dstchannel", "drdChan", "dstchannel", "dsrcVideo", "ddestVideo", "drdchannel", "ddestchannel", " drdchannel", " dstStream", "ddestChannel", "drcVideo", "ddestContext", "dstChan", "dstConnection", "drcchannel", " dstsChannel", "dstsChannel", " dstsConnection", "dDestConnection", "dDestchannel", "dstContext", "dDestStream", "dstschannel", "drcContext", "DstChannel", "DstVideo", "DdestChannel", "DdestVideo", "ddestChan", "dsrcChannel", " drdContext", " dstConnection", " dstschannel", "dstVideo", "drcChan", " dstContext", "drdChannel", " dstsStream", "dsrcchannel", "drcChannel", "dDestChannel", "dstStream", "ddestConnection", "Ddestchannel", " dstChan", " drdChan", "dstsConnection", " drdChannel", "Dstchannel", "drdContext"]}}
{"id1": "5125848", "id2": "13063241", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"combineJs": ["combineJS", "CombineJS", "combinjs", "combinatejs", "combinedJS", "Combinejs", "CombineJs", "combinedJs", "combinJs", "combinScript", "combinateJS", "CombineScript", "combinedScript", "combinateJs", "combinejs", "CombinateJS", "Combinatejs", "combineScript", "CombinateJs", "combinJS", "combinateScript", "CombinateScript", "combinedjs"], "base": ["prefix", "proxy", "page", "log", "uri", "resource", "image", "server", "build", "b", "info", "data", "relative", "store", "part", "f", "area", "site", "ref", "out", "home", "Base", "builder", "source", "config", "api", "db", "cache", "address", "string", "file", "bas", "absolute", "root", "bot", "based", "http"], "linkJs": ["likejs", "likeJS", " linkScript", "linkJS", "loadJS", "linkedJS", "loadScript", "likeLinks", "likeJs", "linkedjs", " linkJS", "linkLinks", " linkjs", "linkedJs", "linkScript", " linkLinks", "loadJs", "linkjs", "linkedScript", "loadjs", "linkedLinks"], "newFiles": ["addLinks", "oldfiles", "addFiles", "addResources", " newResources", "oldLinks", "newResources", " newLinks", "addfiles", "newfiles", "newLinks", "oldFiles", "oldResources", " newfiles"], "dir": [" db", "log", "direction", "http", "uri", "module", " Dir", "b", "build", "loc", "lock", "DIR", "relative", "md", "session", "in", "folder", " directory", "zip", "dep", "editor", "d", " download", "container", "out", "wd", "home", "download", " director", "plugin", " manager", "source", " dep", "directory", "src", "keep", "work", " repo", "db", "object", "local", "cache", " block", "id", "div", "ir", "file", "dist", "root", "domain", " module", " d", "or", "Dir", " folder", "manager", "lib"], "name": [" app", " zip", " info", " abs", " id", " resource", " source", " manager", " root", " parent", " init", " repo", " build", " bundle", " cache", " relative", " suffix", " prefix", " head", " module", "Dir", " folder", " title", " dest"], "minDir": ["mindir", "initManager", " minMin", "miniFile", "minMin", "minDirectory", "minDriver", "versionDirectory", " mindir", "initFolder", "minManager", "initDirectory", " minFolder", "miniDest", "blockdir", "versionFolder", " minDest", " minJar", "versionManager", "blockDriver", " minDriver", "MinDir", "MinFile", " minFile", "tempJar", "miniDir", "minJar", "MinDest", "MinDb", "minDb", "blockDir", "initDir", "MinJar", "minFolder", "versionDir", "MinMin", "tempDir", "blockFile", "miniDb", "minFile", "Mindir", "minDest", " minManager", " minDb", " minDirectory", "miniDriver", "tempMin", "minidir", "tempdir"], "combineFile": ["combinateReader", "CombinateWriter", "joinateWriter", "CombineWriter", "combinerSourceFile", "combinateDir", "combinateFile", "combineSourceFile", "combicateSourceFile", "combinateLog", "combinerFile", "joinateReader", "combicateWriter", "CombinateLog", "combinedReader", "CombineLog", "CombineSourceFile", "CombinateSourceFile", "combicateFile", "combineLog", "CombinateFile", "joineDir", "comboseReader", "joinateFile", "comboseDir", "comboseWriter", "combinerWriter", "combinedDir", "combineReader", "joineFile", "CombineFile", "combicateLog", "joineReader", "combinerLog", "joinateDir", "comboseFile", "combinedWriter", "combinateWriter", "combineDir", "joineWriter", "combinedFile", "combinateSourceFile"], "concatFile": ["ConcatDir", "conateDir", "ConcatsFiles", "concFiles", "ConcatsWriter", "concStream", "concatsFiles", "concatsWriter", "conatefile", "Concatfile", "ConcatFiles", "concentDir", "concatsDir", "concatFiles", "concatStream", "concatsStream", "concFile", "concatDir", "ConcatWriter", "concDir", "concatsFile", "ConcatsDir", "concentStream", "Concatsfile", "ConcatStream", "conateFile", "concatsfile", "conateFiles", "concWriter", "concentWriter", "concentFile", "concfile", "ConcatFile", "ConcatsFile", "concatfile", "ConcatsStream"], "combineWriter": ["combinateReader", "mixinerWriter", "CombineWriter", "combinerReader", "ComboseReader", "combineRW", "mixinerReader", "combinateFile", "mixinerRW", "ComboseFile", "mixineRW", "combideWriter", "comboseWalker", "comboseRW", "combiseReader", "combinerRW", "ComboseWriter", "combideRW", "mixinerWalker", "comboseReader", "comboseWrite", "combideWalker", "combinateWrite", "mixineReader", "combiseWriter", "combinerWalker", "combideReader", "comboseWriter", "combinerWriter", "mixineWriter", "combineReader", "CombineFile", "CombineReader", "combiseWrite", "mixineWalker", "combineWrite", "combineWalker", "comboseFile", "CombineWrite", "combiseFile", "combinateWriter", "ComboseWrite"], "concatWriter": ["convertDriver", "concatDriver", "concReader", "concilWrite", "syncatWriter", "concilDriver", "convertWrite", "ConcatWrite", "ConcatsWriter", "concatsWriter", "syncWriter", "ConcatDriver", "concatReader", "concatsWrite", "syncatWrite", "ConcatsWrite", "concWrite", "syncReader", "concatWrite", "syncWrite", "ConcatsDriver", "concilWriter", "concFile", "ConcatWriter", "concilFile", "syncFile", "convertReader", "concatsFile", "concWriter", "concatsDriver", "syncatReader", "convertFile", "syncatFile", "ConcatFile", "convertWriter", "ConcatsFile", "concatsReader"], "fails": [" fils", "foralls", "ifils", "dfailed", "Falls", "Fils", "failed", " frors", "infaults", "Fls", " fls", "ifails", "dfailing", "forails", "Fakes", "fakes", " fakes", " failing", "dfails", "fils", "tils", " failed", "frors", "Faults", "ifls", "Fails", "infails", "infils", "trors", "ifakes", "dfils", "failing", "Frors", "Failing", "falls", "tls", "tails", "forils", "infalls", "Failed", "fls", "foraults", "faults"], "link": ["ink", "uri", " lang", "e", "image", "message", "Link", "style", "connection", "loc", "links", " comment", "info", " tag", " resource", " target", " anchor", "dd", "follow", "block", " source", " config", " site", " entry", " http", "linked", "comment", "add", "parse", " Link", "li", " inline", "l", " location", "address", "match", " node", "load", " document", "bug", " module", " page", "line", " item", "open", " html"], "path": ["attribute", "text", "uri", "script", "loc", "info", "data", "ath", "step", "PATH", "entry", "route", "input", "attr", "href", "key", "type", "wd", "code", "source", "class", "src", "filename", "Path", "point", "node", "id", "string", "file", "pattern", "location", "pointer", "content", "value"], "url": ["page", "log", "uri", "ssl", "resource", "image", "server", "html", "build", "b", "connection", "loc", "data", "channel", "f", "result", "route", "str", "URL", "www", "key", "download", "xml", "source", "pull", "api", "stream", "l", "web", "r", "address", "string", "file", "loader", "sl", "host", "Url", "location", "http", "ri", "open", "browser"], "inputStream": ["inputChannel", "inputWriter", "InputFile", "outputStreamer", "outputstream", "inputFile", "inputStreamer", "downReader", "inputReader", " inputWriter", "outputFile", "InputWriter", "Inputstream", "outputWriter", "InputStreamer", "outputReader", "InputReader", "downStream", " inputFile", "downFile", "outputChannel", "InputChannel", "inputstream", " inputstream", "downStreamer", "InputStream", " inputChannel"], "jsFile": ["javascriptDir", "scriptSource", "jsStream", " jsWriter", " jsLog", "jsonFile", "jsReader", "JsLog", "jsDir", "JsWriter", "javascriptStream", "javascriptfile", " jsReader", "jsLog", "javascriptFile", " jsfile", "scriptFile", "javascriptPath", "jsonSource", "javascriptSource", "jsPath", "jsSource", "scriptDir", "JsFile", "Jsfile", "jsWriter", "jsfile", "javascriptWriter", "scriptPath", "javascriptLog", "javascriptReader", "JsStream", " jsStream", "JsReader", "jsonPath", "jsonDir"], "fileName": ["FileNumber", " fileNumber", "fileSize", "resourceSize", "FileName", "resourceName", " fileSize", "filePath", "fileNumber", " filePath", "FileSize", "resourceNumber", "resourcePath", "FilePath"], "outputStream": ["inputSteam", " outputReader", "Outputstream", "inputWriter", " outputSteam", "outputstream", "inputFile", "resourceSteam", "OutputReader", "responseStream", "outputFile", "responseSteam", "outputWriter", " outputWriter", "resourcestream", "OutputWriter", "outputReader", " outputFile", "responseWriter", "OutputStream", "resourceReader", "OutputSteam", "outputSteam", "OutputFile", "resourceStream", "responseReader", " outputstream"], "first": ["replace", "default", "one", "count", "st", "prev", "each", "before", "last", "required", "primary", "all", "now", "result", "it", "second", "stack", "split", "error", "only", "then", "th", "top", "must", "self", "same", "user", "found", "alpha", "success", "initial", "start", "other", "third", "left", "full", "next", "root", "auto", "current", "First", "always", "again", "use", "p", "right"], "reader": ["writer", "report", "e", "resource", "server", "image", "rc", "io", "info", "data", "parser", "reading", "dd", "in", "entry", "f", "Reader", "input", "reads", "read", "h", "xml", "builder", "source", "driver", " Reader", "config", "stream", "er", "inner", "r", "object", "handler", "file", "loader", "context", "buffer", "feed"], "jsCompressor": ["jsExpressor", "jsCompress", "jsRepress", " jsCompression", "jsReporter", " jsComporter", "jsCompression", "jsRepression", " jsCompress", "jsComporter", "jsRepressor", "jsExpression", "jsExpress", "jsExporter"], "s": ["ls", "m", "ions", "gets", "g", "n", "ss", "en", "os", "ps", "ns", "sys", "es", "groups", "ings", "comments", "sets", "lines", "fs", "ens", "objects", "ws", "is", "ing", "l", "scripts", "qs", "states", "ses", "S", "v", "xs", "t", "ts", "ments", "types", "words", "gs", "abs", "strings"], "s1": ["esIP", "esB", "s81", "etsPre", "qsIP", "ys2", "s01", "ys1", "ets1", "es81", "qs1", "es1", "ings01", "sAP", "es01", "ats2", "ings2", "etsAP", "qs2", "es2", "atsPre", "sPre", "ys01", "sIP", "ysB", "ings1", "ingsB", "qs81", "sB", "esAP", "ats1", "esPre", "ets2", "atsAP"], "i": ["m", "u", "z", "e", "j", "ifier", "b", "si", "f", "o", "d", "is", "ing", "a", "l", "ip", "pi", "xi", "id", "v", "c", "ic", "t", "w", "I", "phi", "ii", "ui", "x", "bi", "qi", "q", "p", "ik"], "s2": ["qs12", "ls1", "s12", "ingsSecond", "sets2", "ets1", "ls62", "qs1", "es1", "lsSecond", "s82", "es62", "ings2", "qs2", "es2", "ets82", "ls2", "etsSecond", "es12", "sets1", "s62", "setsCloud", "ings1", "es82", "sCloud", "sSecond", "sets82", "qsSecond", "esCloud", "etsCloud", "ets62", "esSecond", "ings12", "ets2"], "i1": ["a4", "s9", "iOne", "lOne", "sFirst", "pi2", "i9", "pi1", "sOne", "pi4", "eOne", "a1", "e2", "i0", "pi9", "s0", "e0", "i2", "iFirst", "l2", "l1", "pi0", "eFirst", "e1", "i4", "piFirst", "s4", "l0", "a9", "a2"]}}
{"id1": "17683082", "id2": "21491791", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "label": 0, "substitutes": {"IOException": ["IOError", " IOError", "IPException", " URIError", "IPception", "IOception", " IOception", " URIception", " URIException", "IPError"], "url": ["page", "log", "uri", "ssl", "resource", "image", "server", "build", "manager", "loc", "this", "link", "socket", "channel", "impl", "URL", "ref", "job", "conn", "source", "config", "access", "client", "web", "l", "base", "user", "address", "cache", "file", "service", "sl", "host", "bug", "path", "location", "Url", "http", "feed"], "connection": ["uri", "resource", "server", "version", "link", "socket", "channel", "Connection", "application", "index", "reader", "config", "directory", "client", "position", "handler", "file", "loader", "relation", "service", "function", "location", "response", "context", "wrapper", "collection", "manager", "database"], "ns": ["ls", "prefix", "cn", "scope", "n", "ss", "os", "ps", "pos", "NS", "str", "lines", "nc", "ms", "fs", "conn", "ws", "db", "object", "names", "obj", "params", " namespace", "net", "domain", "cs", "space", "ds"]}}
{"id1": "3683344", "id2": "3252116", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "label": 1, "substitutes": {"genRandomGUID": [" genRandGUID", " genRandGID", " genRandomGID", " genRandomUID", " genRandomIGUID", " genRandUID", " genRandomGUuid", " genRandomGuid", " genRandUUID", " genRandomUUID", " genRandGIP", " genRandomGUIP", " genRandomGIP", " genRandUIP", " genRandomIGuid", " genRandomUuid", " genRandomUIP", " genRandomIGIP", " genRandGuid", " genRandomGUUID", " genRandomIGID", " genRandUuid"], "secure": ["proxy", "ssl", "server", "debug", "protect", "remote", "depth", "sys", "random", "allow", "session", "weak", " insecure", "sensitive", "zip", "smart", "str", "encrypted", "sec", "password", "forced", "timeout", "require", "config", "client", "seed", "stable", "https", "security", " Secure", "safe", "deep", "host", "ssh", "fast", "Secure", "close", "active", "force", "q", "secret", "exclusive"], "valueBeforeMD5": ["valueBeforemd3", "valueBeforeMC3", "valueBeforeMP3", "valueBeforeMD85", "valueAfterMD85", "valueAfterMS1", "valueBeforeMS5", "valueBeforeMT20", "valueBeforeMT55", "valueBeforeSHA3", "valueBeforeMP5", "valueBeforeMT05", "valueBeforeMT3", "valueBeforeMT5", "valueAfterMC3", "valueBeforeMC5", "valueAfterMD1", "valueAfterMC8", "valueBeforeMP2", "valueBeforeAMD20", "valueBeforeMD8", "valueBeforeMR85", "valueBeforeMS3", "valueAfterMD20", "valueBeforeMR5", "valueBeforemd85", "valueAfterMS2", "valueBeforeM1", "valueBeforeSHA1", "valueBeforeMP55", "valueBeforeMD3", "valueBeforeMR8", "valueBeforeMC8", "valueBeforemd8", "valueAfterMS5", "valueBeforeSHA5", "valueBeforeMR3", "valueBeforeMD05", "valueBeforeM2", "valueAfterMD2", "valueBeforeAMD05", "valueBeforeMS2", "valueAfterMS3", "valueBeforeSHA2", "valueBeforeMT2", "valueAfterMC5", "valueBeforeAMD5", "valueBeforemd5", "valueBeforeMD1", "valueBeforeMS1", "valueBeforeMC85", "valueBeforeMD20", "valueBeforeM5", "valueBeforeAMD3", "valueBeforeM3", "valueAfterMD05", "valueAfterMD8", "valueBeforeMD2", "valueBeforeMD55", "valueAfterMD3", "valueAfterMD55", "valueAfterMC85"], "valueAfterMD5": ["valueBeforeMP3", "valueAfterMF05", "valueBeforeMP1", "valueAfterDM3", "valueAfterDM512", "valueAfterMP1", "valueAfterAST2", "valueAfterAST5", "valueBeforeAST3", "valueAfterDF5", "valueAfterHTML512", "valueBeforeMP05", "valueAfterMC5", "valueAfterM5", "valueBeforeMD1", "valueAfterMCql", "valueAfterMD3", "valueBeforeAST2", "valueAfterM2", "valueBeforeVM5", "valueBeforeMPTE", "valueAfterAST512", "valueAfterHTML5", "valueAfterMC3", "valueBeforeMC5", "valueAfterAST3", "valueAfterMD1", "valueBeforeAST5", "valueBeforeMD512", "valueBeforeMP2", "valueAfterMDql", "valueAfterVM3", "valueBeforeMD3", "valueAfterDF005", "valueAfterMC1", "valueAfterMPTE", "valueAfterMT5", "valueAfterGM5", "valueAfterMFTE", "valueAfterVM5", "valueAfterM3", "valueBeforeMC3", "valueAfterMF3", "valueBeforeMP5", "valueAfterMDody", "valueAfterMF5", "valueAfterAMD5", "valueAfterMT3", "valueAfterMD005", "valueBeforeMCql", "valueAfterAMD3", "valueAfterDMody", "valueBeforeMD05", "valueAfterHTML3", "valueAfterMD2", "valueAfterMP05", "valueAfterMTql", "valueBeforeMDTE", "valueBeforeVM3", "valueAfterAMD005", "valueAfterGM2", "valueAfterMD05", "valueBeforeAST005", "valueAfterHTMLTE", "valueAfterGM3", "valueAfterMDTE", "valueAfterDM5", "valueAfterASTody", "valueAfterHTML05", "valueBeforeAST512", "valueAfterVM005", "valueAfterHTMLody", "valueAfterMP3", "valueAfterAST005", "valueAfterM1", "valueAfterMP005", "valueBeforeMDql", "valueBeforeASTody", "valueAfterMD512", "valueBeforeMDody", "valueBeforeMD005", "valueAfterDF3", "valueAfterMC2", "valueAfterGM005", "valueAfterMP2", "valueAfterMP5", "valueBeforeMD2", "valueBeforeVM005"], "md5": ["md05", " MD05", "cmd5", "mandkey", " md05", "MD512", "md53", " md53", " md25", "MD5", " md512", "cmd1", " MD53", "amd2", " md2", "cmd65", " MD5", " mdkey", "md3", " md3", "md2", "md1", "amd25", "mand1", "md65", "md25", "amd5", "mdkey", "mand512", " md65", "mand2", " MD3", "mand3", "MD2", " md1", "mand65", "cmd05", "mand5", "cmd53", "cmd512", "cmdkey", "MD25", "amd512", "md512", "cmd3", "cmd2"], "sbValueBeforeMD5": ["sbValueBeforeND525", "sbValueBeforeND5", "sbValueBeforeMC5", "sbValueBeforeMS2", "sbValueBeforeMM5", "sbValuebeforeND3", "sbValueBeforeMT55", "sbValueBeforeMC25", "sbValueBetweenmd5", "sbValueBehindMD25", "sbValueBehindMD3", "sbValueWithoutMD5", "sbValueBeforeMD25", "sbValueBeforemd2", "sbValueBeforeMF3", "sbValueBeforeMF5", "sbValueBeforeAMD1", "sbValueBeforeMP55", "sbValueBeforeMR5", "sbValueAfterMP3", "sbValuebeforeND5", "sbValueBehindMD525", "sbValueBeforeND85", "sbValueAfterMP512", "sbValueBeforeND25", "sbValueBeforeMM005", "sbValueBeforeMT005", "sbValueBeforeMD35", "sbValueAfterMD1", "sbValueBetweenMD305", "sbValueBeforeMP512", "sbValueInsideAMD5", "sbValueBeforeMS1", "sbValueBeforeMR3", "sbValueInsideMD5", "sbValueBeforeMD305", "sbValueAfterMP5", "sbValueBeforeAMD2", "sbValueBeforeND2", "sbValueBeforeAMD305", "sbValueBeforeMT3", "sbValueBeforeMM3", "sbValueBeforeMG25", "sbValueBeforeMP25", "sbValueAfterMD3", "sbValueInsideAMD3", "sbValueBetweenMD5", "sbValueBeforeMT5", "sbValueBehindND5", "sbValueAfterMD512", "sbValueBeforeMD2", "sbValueBehindND525", "sbValueBehindND25", "sbValueWithoutMD35", "sbValuebeforeMD85", "sbValueAfterMP005", "sbValueBeforeMF35", "sbValueBetweenmd2", "sbValueBeforemd3", "sbValueBeforeMP05", "sbValueBeforeAMD05", "sbValueInsideAMD25", "sbValueBeforeMP5", "sbValuebeforeMD2", "sbValuebeforeND85", "sbValueInsideAMD05", "sbValueBehindMD5", "sbValueBeforemd305", "sbValueBeforeMD55", "sbValueBeforeMS85", "sbValueAfterMD5", "sbValueBeforeAMD3", "sbValueWithoutMF35", "sbValueBehindND3", "sbValueBeforeMD85", "sbValueBeforeMD525", "sbValueBeforeMF25", "sbValueBeforeMS3", "sbValueBeforeMC35", "sbValueBeforeMR25", "sbValuebeforeND2", "sbValueBetweenmd305", "sbValueBeforeMR525", "sbValueBeforeMS512", "sbValueBeforeMG3", "sbValueWithoutMF3", "sbValueBeforeMP1", "sbValueBeforeMP85", "sbValueAfterMD005", "sbValueBeforeMC3", "sbValueWithoutMF5", "sbValueWithoutMD3", "sbValueBeforeMP305", "sbValueBeforeMP3", "sbValueBeforeMD1", "sbValueBeforeAMD25", "sbValueWithoutMF25", "sbValueBeforeMD3", "sbValueBeforeMS5", "sbValueWithoutMD25", "sbValueBeforemd5", "sbValueBetweenMD2", "sbValuebeforeMD5", "sbValueBeforemd25", "sbValueBeforeND3", "sbValueBeforemd05", "sbValueBeforeMG35", "sbValueBetweenmd3", "sbValueAfterMP1", "sbValuebeforeMD3", "sbValueInsideMD3", "sbValueAfterMD55", "sbValueBeforeMP005", "sbValueBeforeAMD5", "sbValueBeforeMM55", "sbValueAfterMP55", "sbValueBeforeMD512", "sbValueBeforeMD05", "sbValueBeforeMP2", "sbValueInsideMD25", "sbValueBeforeMP525", "sbValueBetweenMD3", "sbValueBeforeAMD512", "sbValueBeforeMD005", "sbValueInsideMD05", "sbValueBeforeMG5"], "time": ["TIME", "delay", "money", "clock", "length", "count", "tz", "speed", "race", "etime", "version", "depth", "random", "duration", "times", "port", "year", "mode", "hour", "timer", "error", "date", "timeout", "type", "temp", "size", "ime", "seed", "work", "month", "id", "counter", "cost", "start", "age", "name", "host", "Time", "value", "q", "sleep", "rate"], "rand": ["pick", "rss", "delay", "raid", "nd", "core", "ro", "length", "count", "dr", "rc", "rh", "version", "depth", "mid", "random", "bit", "reg", "rage", "winner", "range", "year", "risk", "rule", "index", "error", "type", "ng", "win", "max", "seed", "rr", "round", "r", "id", "alpha", "dist", "name", "re", "root", "order", "pattern", "bug", "clean", "rank", "q", "Rand", "serial", "rate", "right"], "array": ["sample", "arrow", "air", "arr", "module", "image", "integer", "view", "range", "all", "now", "area", "archive", "index", "batch", "error", "row", "our", "element", "instance", "multi", "record", "section", "pair", "expression", "a", "number", "feature", "table", "r", "object", "address", "cache", "string", "Array", "app", "list", "angle", "vector", "bug", "function", "value", "ray", "collection", "database"], "strTemp": [" strTem", "brTemp", "arrTest", "arrTemp", "brVar", "crTemp", "drTem", "crTemplate", "crTem", "strVar", "stringtemp", "drVar", "arrBase", "objFake", "strTemplate", " strTest", "strTest", "stringFake", "strFake", "objTem", "drtemp", "strTem", "crtemp", " strtemp", "brTest", " strBase", "Strtemp", " strTemplate", "objtemp", "arrtemp", "drTemp", "stringTemp", "objTemp", "strBase", "StrBase", " strVar", "brtemp", "brTem", "drTemplate", "strtemp", "stringTem", "StrTemp", "arrTem", " strFake"], "i": ["k", "p", "u", "z", "uri", "e", "j", "b", "n", "io", "info", "si", "ie", "in", "field", "f", "o", "index", "d", "ci", "h", "key", "end", "ji", "abi", "multi", "y", "li", "di", "l", "ip", "pi", "xi", "hi", "eni", "slice", "yi", "id", "ti", "v", "gi", "c", "start", "ix", "I", "ai", "phi", "ii", "ui", "x", "mu", "ri"]}}
{"id1": "14054923", "id2": "8932510", "code1": "    protected Document getRawResults(String urlString, Map args) throws Exception {\n        int count = 0;\n        Iterator keys = args.keySet().iterator();\n        while (keys.hasNext()) {\n            String sep = count++ == 0 ? \"?\" : \"&\";\n            String name = (String) keys.next();\n            if (args.get(name) != null) {\n                urlString += sep + name + \"=\" + args.get(name);\n            }\n        }\n        URL url = new URL(urlString);\n        URLConnection conn = url.openConnection();\n        conn.connect();\n        SAXBuilder builder = new SAXBuilder();\n        return builder.build(conn.getInputStream());\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"getRawResults": ["getFullResults", "processRawResponse", "processrawResources", "getRowResult", "getFullResponse", "processrawResults", "processRawResults", "getRowResponse", "getRowResources", "getRowResults", "getRawResources", "getRawResult", "getrawResponse", "processRawResources", "processrawResponse", "getFullResult", "getFullResources", "processRawResult", "getrawResources", "getrawResults", "processrawResult", "getRawResponse", "getrawResult"], "urlString": ["httpString", "urlText", "urlStr", "stringString", "resourceArray", "updateText", " urlName", "urlName", " urlstring", " urlText", " urlStream", "stringArray", "fileString", "resourceName", "updateStr", "updateString", " urlArray", "fileName", "urlstring", "httpArray", "resourceString", "stringstring", "resourcestring", "updatestring", "httpStr", "fileArray", "urlStream", "stringStream", "urlArray", "httpText", "httpstring", " urlStr", "httpStream", "filestring"], "count": ["Count", "array", "message", "col", "call", "length", "parent", "offset", "cmp", "force", "num", "weight", "more", "last", "part", "group", "loop", "second", "coll", "sum", "index", "key", "code", "i", "size", "number", "base", "found", "id", "cache", "counter", "match", "start", "list", "current", "head", "seq", "p"], "keys": ["kes", "fields", "values", "ins", "rows", "n", "users", "links", "obs", "os", "ps", "ns", "lists", "cats", "headers", "es", "bs", "groups", "vs", "index", "lines", "key", "ms", "s", "ips", "results", "drivers", "iter", "vals", "qs", "states", "files", "ids", "names", "errors", "ers", "list", "xs", "locks", "ops", "builders", "blocks", "writers", "events", "Keys", "opens", "vers", "items", "ks", "ors"], "sep": [" seg", "semp", "semps", "psep", "seg", "sepse", "SEpse", " sepse", "sempe", "SEp", " seps", "SEg", "sef", "pseg", "seps", "semf", "sempse", "psepe", "psef", "sepe", "SEps", "semg", " sef", " sepe"], "name": ["ame", "NAME", "prefix", "cap", "ex", "common", "default", "resource", "call", "parent", "n", "connection", "none", "info", "data", "known", "child", "session", "old", "part", "alias", "search", "var", "field", "f", "no", "member", "entry", "str", "block", "named", "attr", "key", "type", "pass", "time", "api", "Name", "size", "client", "ip", "base", "min", "object", "id", "address", "names", "string", "file", "layer", "path", "line", "word", "value", "ext", "active", "label", "request", "space"], "url": ["ls", "page", "fl", "uri", "ssl", "ll", "resource", "server", "uc", "build", "b", "connection", "loc", "org", "blog", "channel", "f", "impl", "www", "URL", "key", "client", "l", "web", "base", "user", "r", "object", "address", "c", "obj", "sl", "host", "layer", "path", "Url", "http", "open", "browser"], "conn": ["conv", "rt", "ct", "ssl", "cn", "server", "n", "connection", "loc", "rc", "cp", "act", "socket", "channel", "Connection", "connect", "nt", "coll", "ch", "nc", "cb", "out", "cur", "Conn", "connected", "client", "cli", "l", " connection", "db", "ann", "util", "con", "c", "err", "dc", "net", "ctx", "cf", "path", "close", "enc", "http", "open"], "builder": ["writer", "default", "e", "server", "build", "b", "event", "outer", "Builder", "parser", "sb", "building", "entry", "creator", "result", "now", "pb", "job", "bean", "row", "instance", "driver", "reader", "config", "client", "l", "slave", "inner", "r", "object", "loader", "builders", "layer", "runner", "wrapper", "response", "or", "buffer", "bridge", "http", "oder"]}}
{"id1": "19739421", "id2": "23370621", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": [" UnknownOptionsError", "UnknownOperationError", "UnknownParameterException", " UnknownOptionsception", " UnknownOptionsException", "UnknownOptionsError", "UnknownOperationException", "UnknownOptionsException", " UnknownOptionError", "UnknownOptionception", "UnknownParameterError", "UnknownOperationception", "UnknownOptionError", "UnknownOptionsception", " UnknownOptionception", "UnknownParameterception"], "cmdLineParser": ["cmdSiteparser", "cmdLinearser", "cmdSiteParser", " cmdLineMaster", "cmdLineJar", " cmdLinearser", "cmdLinMaster", "mdLineParser", "cmdStringMaster", "mdLineHelper", "cmdBlockParser", "cmdStringBuilder", "cmdServiceJar", "mdlinearser", "mdLParser", "cmdStringJar", "cmdlineReader", "cmdStringWriter", "cmdLineWriter", "commandlineMaster", "cmdLMaster", "cmdLineReader", "cmdEntryarser", "cmdLBuilder", "cmdLJar", "mdLineReader", "cmdBlockBuilder", "cmdSiteWriter", "cmdLHelper", "commandlineReader", "cmdlinearser", "cmdFileJar", "cmdEntryMaster", "cmdlineWriter", "mdLineWriter", "cmdBlockarser", "cmdlineJar", "cmdStringHelper", "cmdLineRunner", "cmdStringarser", "commandLineMaster", "cmdServicearser", "cmdlineparser", "cmdBlockparser", "mdLineBuilder", "cmdServiceMaster", "cmdFileReader", "mdLinearser", "cmdBlockMaster", "cmdLinReader", "mdLHelper", "cmdLineMaster", "cmdStringParser", "commandLineParser", "commandLineJar", "cmdByteMaster", "mdlineParser", " cmdLMaster", "cmdlineMaster", " cmdLineJar", "cmdStringRunner", "cmdByteJar", "mdLineJar", "cmdFileRunner", "mdlineparser", " cmdLJar", "mdLarser", "mdlineBuilder", "commandlineParser", "cmdStringReader", "cmdFileMaster", "cmdByteParser", "mdlineMaster", "mdLReader", "cmdLineparser", "cmdEntryParser", "cmdLinParser", "cmdLineBuilder", "cmdBlockWriter", " cmdLParser", "cmdFileParser", "mdLJar", "cmdlineParser", "mdlineJar", "cmdLparser", "cmdStringparser", "commandLineReader", " cmdLarser", "mdLineMaster", "cmdEntryJar", "cmdLinJar", "mdLineparser", "cmdlineBuilder", "cmdFilearser", "cmdBlockJar", "mdlineWriter", "cmdLineHelper", "mdLRunner", "cmdLarser", "cmdLReader", "cmdlineHelper", "mdLineRunner", "commandlineJar", "cmdSiteJar", "cmdLParser", "cmdByteWriter", "cmdLRunner", "cmdServiceParser"], "formatOption": [" formatElement", "lengthVariable", "lengthOption", "FormatOption", "FormatOpt", "printfElement", "printfOperation", "formatOpt", "formatParameter", "FormatOperation", "FormatElement", "formatOperation", "printfOption", " formatParameter", "lengthOpt", "typeOpt", "formatElement", " formatOpt", "lengthParameter", "typeParameter", "printfOpt", " formatOperation", "formatVariable", " formatVariable", "typeOption", "typeVariable"], "outputEncodingOption": ["outputEncasingOpt", "outputEncasingParameter", "outputEncodingOperation", "outputEncordingOption", "outputCasingParameter", "outputEncitingOperation", "outputEncordingOptions", "outputCasingOpt", "outputCodingOptions", "outputEncoderParameter", "outputEncordingOpt", "outputEncodingParameter", "outputEncitingOpt", "outputCodingOpt", "outputEncodingOpt", "outputCodingOperation", "outputCasingOperation", "outputEncordingOperation", "outputEncasingOperation", "outputEncoderOperation", "outputEncoderOption", "outputEncordingParameter", "outputEncodingOptions", "outputCodingParameter", "outputCodingOption", "outputEncitingOptions", "outputEncasingOptions", "outputEncoderOpt", "outputEncasingOption", "outputCasingOptions", "outputEncitingOption", "outputCasingOption"], "inputEncodingOption": ["inputChodingOpt", "inputChachingOption", "inputEncodedOption", "inputEncoderOperation", "inputChachingOperation", "inputEncasingOpt", "inputEncoderOption", "inputChodingOperation", "inputEncodingFunction", "inputEncasingOption", "inputEncodingOperation", "inputEncoderOpt", "inputEncasingFunction", "inputEncodedFunction", "inputChodingFunction", "inputEncodingOpt", "inputChachingOpt", "inputChasingOperation", "inputEncachingOperation", "inputEncoderFunction", "inputChasingFunction", "inputChodingOption", "inputChasingOption", "inputEncachingOpt", "inputEncodedOperation", "inputEncachingOption", "inputEncasingOperation"], "format": ["filter", "at", "prefix", "attribute", "writer", "unit", "html", "style", "term", "form", "letter", "atter", "version", "scale", "title", "output", "f", "template", "sort", "type", "plugin", "cat", "api", "config", "quality", "size", "filename", "license", "target", "command", "transform", "place", "feature", "language", "string", "layout", "file", "alpha", "Format", "option", "name", "service", "printf", "pattern", "host", "ant", "value", "pretty", "export"], "outputEncoding": ["outputOctoding", "inputEncryption", "outputCompasing", "inputChasing", "outputEntryption", "outputChaping", "outputChoder", "outputChaching", "outputOctoring", "outputencoder", "outputencoding", " outputEntining", "outputOctasing", "outputDecoding", "inputChryption", "outputCompoding", "outputEngording", "outputEncaping", "inputChoding", "inputChoring", "outputDecording", "inputEncoring", "inputEncoder", "outputencaching", " outputEncoder", "outputChining", "outputChryption", "outputSequoding", "outputCompoder", "outputEngoder", " outputEncining", "outputEntoding", "outputEncording", "outputEncoder", "outputEntoder", " outputEncaping", "outputEntasing", "outputEncoring", "outputEntining", " outputEntoding", " outputEncaching", "outputencording", "outputEnaping", "outputEngaching", "outputSequoder", "outputEncryption", "outputSequryption", " outputEngaching", "outputCompording", "outputChoding", " outputEngoding", " outputEncasing", "outputEnasing", "outputEncaching", "inputChoder", "outputEnining", "inputEncasing", "outputEncasing", " outputEntasing", "outputDecoder", " outputEngoder", " outputEncording", " outputEngording", "outputEngoding", "outputChoring", "outputChording", "outputChasing", " outputEntaping", "inputChording", "outputSequasing", "outputDecasing", "inputEncording", "outputOctoder", "outputEncining", "outputEntaping", "outputEnoding"], "inputEncoding": ["inputEnoder", "inputExplasing", " inputDecoder", "inputEnacing", "variableExplasting", "inputChoding", "variableExplode", "variableEncode", "inputExploding", "inputEnording", "inputEngoding", "inputChacing", "inputEncasting", "inputChasting", "inputEngoder", "inputDecacing", " inputDecording", "inputChasing", "variableExplasing", "inputChode", "inputEnasting", "inputEngasing", "inputEncoder", "inputEncacing", "outputEncasing", "inputDecoding", "inputEncode", "outputChoder", "outputChasing", "inputExplode", "inputExplasting", " inputDecacing", "inputChording", "outputChoding", "inputEngapping", " inputDecoding", "inputEncording", "outputChapping", "inputDecording", "inputEnasing", "inputEnode", "outputEncoder", "inputEncapping", "inputChoder", "variableExploding", "inputDecoder", "variableEncasting", "variableEncasing", "inputEnoding", " inputEncording", "inputEncasing", "outputEncapping", "inputChapping", " inputEncacing", "inputEnapping", " inputEncoder", "variableEncoding"], "remainingArgs": ["remainArgs", "remendingArg", "RemingLong", "RemingParts", "regainingGS", "remangingGS", "remainedGS", "remangingLong", "remainArg", "remangingParts", "resainargs", "remainParameters", "resainedLong", "resainedArg", "remingParts", "remainedArray", "remangingArgs", "RemangingParts", "remainsArg", "remainLong", "RemingArgs", "remainedParameters", "RemangingAr", "remainedParts", "remainingArg", "remainingLong", "RemainingLong", "remainargs", "remainedargs", "remainsAr", "remainingArray", "RemainingArg", "regainedGS", "resainArray", "remainAr", "regainingArg", "RemainingParts", "remainedArg", "resainingLong", "remainedLong", "resainingArray", "remainingAr", "regainingParameters", "remainingParts", "resainArgs", "remainingargs", "removingParts", "remangingArg", "remingArgs", "remainingParameters", "remainsArgs", "remainedArgs", "RemangingArg", "remangingAr", "regainedArg", "remingLong", "remendingArray", "remainGS", "remangingParameters", "remendingargs", "regainingArgs", "remainsParts", "removingArgs", "resainArg", "RemainingGS", "removingGS", "resainingArgs", "resainingParts", "RemainingArgs", "resainingArg", "remainingGS", "regainedArgs", "removingLong", "regainedParameters", "RemangingArgs", "remingGS", "resainedArgs", "remendingArgs", "resainedParts", "remainParts", "resainingargs", "RemingGS", "remainArray", "RemainingAr"], "inputFile": [" inputfile", "InputFile", "localDirectory", "localFile", "InputDir", " inputDir", "sourceDirectory", "InputLine", "sourceLine", "inputSourceFile", "InputSourceFile", "sourceFile", "inputStream", "sourcefile", "inputPath", " inputPath", " inputDirectory", " inputStream", "localDir", "inputDirectory", "inputDir", "localSourceFile", "InputDirectory", "inputfile", "sourcePath", "inputLine", " inputLine", "sourceDir", "sourceStream", "InputPath", " inputSourceFile", "InputStream", "Inputfile"], "outputFile": ["OutputPath", "outputStream", "examplefile", "exampleFile", " outputFolder", "operationfile", "operationHeader", "outputMessage", " outputPath", "operationFolder", "OutputFolder", " outputMessage", " outputfile", "OutputHeader", "exampleFolder", "productionfile", "outputPath", "OutputStream", "productionMessage", "outputFolder", "productionFile", " outputStream", "operationFile", " outputHeader", "OutputFile", "exampleStream", "OutputMessage", "productionPath", "Outputfile", "outputfile", "outputHeader"], "out": ["prefix", "page", "gen", "log", "writer", "ln", "flow", "write", "server", "parent", "copy", "debug", "lock", "io", "outer", "info", "session", "raw", "group", "output", "in", "sum", "Out", "error", "temp", "builder", "client", "co", "dump", "ger", "outs", "over", "cache", "screen", "history", "err", "obj", "println", "list", "up", "pre", "OUT", "auto", "line", "word", "again", "manager", "post"]}}
{"id1": "17161805", "id2": "17190057", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "label": 1, "substitutes": {"encode": ["encoder", "enccod", "enoder", "ensode", "Enoding", "enscode", "encod", "Encod", "Enode", "Encode", "enccode", "enoding", "enode", "ensoder", "encoding", "reode", "recode", "recod", "Enoder", "reoding", "enscod"], "plaintext": ["batstring", "longtext", "bodyform", "forestring", "plainText", " plainText", "bodycontent", "bodyText", " plainform", "battext", "plaincontent", "longcontent", "batTEXT", " plaincontent", "plainstring", "plainform", " plainTEXT", " plainstring", "foretext", "foreTEXT", "longform", "longText", "foreText", "plainTEXT", "bodytext", "batText"], "md": ["mad", "m", "rm", "hd", " MD", "mp", "sha", "cmd", "um", "dd", "gd", "f", "rpm", "mc", "mag", "d", "od", "mb", "me", "wd", "ms", "code", "amd", "meta", "dm", "bd", "metadata", "pd", "MD", "di", "ad", "mac", "ind", "mand", "po", "mm", "sm", "ma", "pm", "grad", "cd", "mod", "dh", "df"], "raw": ["shared", "array", "original", "pack", " Raw", "remote", "micro", "RAW", "dec", "pure", "all", "ode", "input", "hex", "feed", "missing", "out", "row", "instance", "ack", "rew", "stream", " hex", "internal", "local", "ghost", "load", "alpha", "initial", "Raw", "binary", "blocks", "clean", "unknown", "unsigned", "buffer", "orig", "serial", "enc", "custom", "block"]}}
{"id1": "23008590", "id2": "21488868", "code1": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"run": ["java", "running", "install", "report", "server", "apply", "build", "Run", "init", "info", "output", "Main", "launch", "test", "process", "work", "login", " Run", "exec", "load", "submit", "start", "up", "update", "execute", " deploy"], "url": ["ur", "page", "proxy", "uri", "ssl", "resource", "image", "server", "loc", "il", "blog", "f", "str", "URL", "www", "bel", "download", "i", "source", "api", "config", "article", "l", "web", "lr", "base", "r", "id", "address", "string", "file", "name", "loader", "service", "sl", "host", "path", "Url", "location", "keeper", "hub", "update", "http", "feed", "browser"], "is": ["ls", "uri", "image", "isi", "os", "lis", "il", "io", "info", "ie", "in", "it", "es", "bis", "iv", "IS", "out", "s", "fs", "ios", "i", "iter", "api", "src", "ar", "stream", "ip", "r", "id", "address", "iss", "ir", "err", "ais", "ris", "Is", "app", "has", "ai", "ini", "as", "ui", "or", "iterator", "http", "was", "ri", "its", "browser"], "writer": ["page", "widget", "ee", "wr", "write", "server", "parent", "null", "letter", "data", "writing", "parser", "ner", "journal", "written", "writ", "winner", "in", "creator", "zip", "editor", "Writer", "feed", "key", "out", "wer", "player", "ws", "temp", "maker", "builder", "source", "driver", "war", "riter", "work", "er", "worker", "walker", "r", "string", "handler", "file", "wire", "w", "writers", "layer", "word", "ler", "director"], "buffer": ["wave", "border", "buf", "page", "padding", "resource", "length", "b", "data", "Buffer", "sequence", "phrase", "result", "stack", "batch", "read", "bytes", "row", "player", "source", "iter", "memory", "buff", "seed", "base", "queue", "slice", "position", "cache", "counter", "string", "character", "bin", "address", "binary", "vector", "layer", "uffer", "transfer", "feed", "block", "char"], "reader": ["e", "rx", "rer", "ser", "dr", "io", "ner", "reading", "rar", "parser", "in", "f", "Reader", "input", "editor", "read", "row", "i", "iter", "source", "bird", "stream", "er", "worker", "rr", "r", "handler", "ir", "loader", "per", "ler", "iterator", "oder", "ri"], "n": ["k", "m", "u", "z", "e", "j", "count", "b", "en", "num", "nr", "ns", "ner", "not", "pos", "no", "f", "sn", "o", "nt", "d", "nc", "nl", "h", "out", "s", "ng", "i", "y", "ne", "l", "nin", "len", "number", "r", "na", "c", "dn", "t", "x", "nor", "nb", "N", "p", "nn"], "updatePage": ["downloadVersion", "updateSite", "updateVersion", "updatedUrl", "UpdatePage", " updateUrl", "updatedPage", "updateLine", "updatedLine", "downloadpage", "currentLine", "updateUrl", "updateServer", "updatepage", "downloadLine", "currentPage", "workSite", "currentSite", " updateVersion", "UpdateFile", "currentpage", " updateFile", " updatepage", "currentUrl", "downloadUrl", " updateLine", "UpdateVersion", "updatedServer", " updateServer", " updateSite", "updatedVersion", "workPage", "updatedFile", "workLine", "updateFile", "UpdateUrl", "currentServer", "updatedpage", "downloadPage", "Updatepage"], "pos1": ["Pos4", "position4", "posOne", "POSOne", " posOne", " pos0", "POS3", "Pos1", "Pos2", "POS1", "position2", "position0", "position3", "positionOne", "pos0", "POS0", "position1", "Pos3"], "pos2": ["pos5", "po5", "index22", "pos22", "POS22", "position2", "positionSecond", "indexSecond", "index3", "position3", "POS2", "po22", "index1", "posSecond", " posSecond", "index5", "POS5", "POS4", "po4", "index4", "po2", "position1", "index2"], "pos3": ["position03", "pos03", "position43", "Pos43", "pose1", "Pos1", "Pos2", "Pos03", "position2", "pose43", "position3", "pose2", "pos43", "pose3", " pos03", "position1", "Pos3"], "pos4": ["posfour", "position4", "posefour", " pos7", "pose4", "pose1", " posfour", "po1", "position2", "index3", "position3", "pose04", "index7", "pofour", "position7", "pos04", "po4", "pos7", "index4", "index2", "po04", " pos04"], "currentVersion": ["initialPackage", "currentRelease", "updateVersion", " currentPage", "initialPage", "updatePackage", "updateVer", "updateRelease", "currentPatch", "currentVer", "CurrentVer", " currentPackage", "currentPage", "initialVersion", " currentName", "currentName", "CurrentVersion", " currentPatch", "CurrentPackage", "currentUrl", "currentPackage", "reportedName", " currentRelease", "reportedPatch", "reportedVersion", "CurrentPage", " currentUrl", "initialVer", "CurrentName", "CurrentPatch", "reportedUrl", "CurrentRelease", "CurrentUrl"], "downloadURL": ["installUrl", "updateUrl", "updateLocation", " downloadUrl", " downloadLocation", "updateURL", "downloadLocation", "downloadUrl", "installLocation", "installURL"]}}
{"id1": "22560224", "id2": "20073619", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 0, "substitutes": {"hashStringMD5": [" hashStringMD6", " hashStringM5", " hashStringUTF4", " hashFileMK6", " hashFileMK5", " hashStringMD4", " hashFileMD4", " hashFileMK8", " hashFileMD8", " hashFileMK4", " hashFileMD6", " hashStringMK4", " hashStringMK6", " hashFileMD5", " hashStringM8", " hashStringMD8", " hashStringM6", " hashStringUTF6", " hashStringUTF8", " hashStringUTF5", " hashStringM4", " hashStringMK8", " hashStringMK5"], "string": ["text", "array", "writer", "uri", "message", "STR", "ring", "null", "script", "letter", "data", "version", "operator", "sequence", "result", "input", "str", "map", "password", "bytes", "date", "source", "section", "filename", "number", "slice", "object", "address", "file", "name", "list", "service", "binary", "word", "content", "buffer", "strings", "p", "database"], "md": ["m", "rm", "hd", " MD", "mp", "cmd", "data", "um", "dig", "dd", "km", "gd", "f", "rpm", "hash", "mc", "mag", "d", "vd", "od", "me", "ms", "mb", "meta", "hm", "amd", "mg", "dm", "wd", "bd", "cm", "metadata", "bf", "pd", "MD", "gm", "ad", "mac", "nm", "mand", "mm", "sm", "am", "pm", "vm", "df"], "byteData": ["letterData", "hardLength", "ByteString", "hardDATA", "largeData", "ByteData", "blockData", " byteArray", " byteBytes", "wordInfo", " byteDATA", "byteBytes", "ByteDATA", "bitdata", "bitData", "byteInfo", "lineBytes", " byteInfo", "wordArray", "wordData", "blockString", " byteString", "letterDATA", "bytePart", "bitBytes", "byteSeries", " bytedata", "Bytedata", "largeSeries", "letterLength", "byteDATA", "ByteInfo", "bitInfo", "wordPart", "BytePart", "lineInfo", "lineData", "blockArray", " bytePart", "ByteArray", "hardData", "blockdata", "byteString", "linedata", "harddata", " byteSeries", "largeArray", "byteLength", " byteLength", "largeDATA", "ByteSeries", "byteArray", "letterdata", "bytedata"], "sb": ["ls", "buf", "ssl", "sf", "b", "fb", "bp", "bh", "kB", "usb", "xb", "bc", "BP", "pb", "SB", "rb", "mb", "cb", "Buff", "sq", "bf", "BG", "bm", "src", "ruby", "buff", "sg", "db", "abb", " SB", "sc", "BB", "gb", "obb", "buffer", "SF", "ab", "nb", "eb", "bs", "Bs", "bb", "bps"], "i": ["k", "m", "u", "uri", "e", "j", "b", "g", "n", "fi", "ori", "io", "info", "si", "ie", "in", "field", "f", "it", "o", "index", "d", "ci", "iu", "h", "s", "oi", "ji", "sp", "abi", "is", "multi", "y", "li", "di", "l", "mi", "ip", "pi", "hi", "eni", "xi", "slice", "yi", "id", "ti", "v", "gi", "c", "ri", "w", "I", "ai", "phi", "ix", "ini", "ii", "ui", "bi", "x", "qi", "lc", "p"], "hexString": [" hexstring", "octBuffer", "hexBuffer", "nullText", "exText", "formstring", " hexText", "hexstring", "nullString", "nullstring", "exStr", " hexStr", "nullBuffer", "shortArray", "exArray", "shortString", "hexStr", "hexArray", " hexArray", "formArray", "octStr", "shortstring", "octString", "shortBuffer", "exBuffer", "hexText", "octArray", " hexBuffer", "formStr", "exString", "formString", "exstring", "octstring"], "hex": ["text", "ex", "he", "closure", "http", "pack", "length", "cmp", "form", "num", "xf", "rh", "quad", "nexus", "bit", "sync", "hello", "alph", "escape", "raw", "shape", "cross", "hash", "str", "exp", "digit", "sum", "h", "temp", "iter", "kh", "xxxxxxxx", "pex", "buff", "ip", "oct", "coord", "lit", "ctr", "brew", "id", "sex", "character", "hess", " Hex", "alpha", "cube", "cf", "xa", "x", "rex", "utf", "shift", "wh", "char"]}}
{"id1": "14598566", "id2": "17947246", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"copyFileByNIO": ["copyFilebynIO", "copyFileByNio", "copyFilebynIF", "copyFilebyNIF", "copyFileByMIF", "copyFileBynio", "copyFileByMio", "copyFileByFileIP", "copyFilebynIP", "copyFileBynIP", "copyFileByMIO", "copyFilebyNIO", "copyFileBynIF", "copyFileByFileio", "copyFilebynio", "copyFileByFileIO", "copyFileByMIP", "copyFilebyNIP", "copyFileByNIP", "copyFileByNIF", "copyFileByFileIF", "copyFileBynIO", "copyFilebyNio"], "in": ["at", "m", "ex", "ins", "url", "resource", "image", "In", "copy", "b", "connection", "io", "data", "inc", "part", "input", "din", "index", "IN", "inn", "h", "i", "source", "reader", "login", "inner", "base", "min", "id", "ac", "bin", "file", "c", "name", "diff", "ini", "x", "or", "buffer", "again"], "out": ["at", "to", "prefix", "ex", "writer", "resource", "image", "copy", "dest", "b", "n", "connection", "io", "data", "project", "inc", "external", "part", "output", "o", "Out", "conn", "source", "client", "target", "outs", "object", "cache", "string", "v", "exec", "c", "file", "name", "w", "OUT", "path", "buffer", "again", "p", "ext"], "sourceChannel": ["sinServer", "ourceStream", "targetConnection", "ourceChannel", "sinChannel", "ourcechannel", " sourcechannel", "innerServer", "innerChan", "srcChan", "targetChannel", "sinStream", " sourceStream", "sourcechannel", "targetChan", "SourceConnection", " sourceConnection", "Sourcechannel", "targetchannel", "innerChannel", "SourceStream", "srcConnection", " sourceServer", "srcChannel", "ourceQueue", "ourceChan", " sourceQueue", "sinChan", "SourceChan", "SourceChannel", "innerStream", "sourceConnection", "srcQueue", "sourceServer", "sourceQueue", "sourceChan", "sourceStream", " sourceChan", "ourceConnection"], "destinationChannel": ["destinationChan", "destinatorContext", "DestinationConnection", "DestinatorContext", "destionChan", "destinationContext", "destinatorStream", "destionChannel", "DestinatorChannel", "destinateStream", "destinateConnection", "DestinatorChan", "DestinationChannel", "destributionConnection", "destinationConnection", "destinatedStream", "DestinationChan", "destinatorChannel", "DestinatorConnection", "destinatedChan", "destionClient", "destributionContext", "destinationClient", "destinatorConnection", "destroyingChannel", "DestinationStream", "destributionStream", "destroyingStream", "DestinatorClient", "destinationStream", "destinatedChannel", "destionConnection", "destinatorClient", "destinatorChan", "destinatedContext", "destributionClient", "DestinatorStream", "destinateChannel", "DestinationClient", "destroyingConnection", "destributionChannel", "DestinationContext", "destributionChan"]}}
{"id1": "17724879", "id2": "7087108", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getDigest": ["getSignests", "getdigHash", "getSignHash", "createdigHash", "createDigester", "getSignester", "getdigests", "createDigests", "getMDHash", "getdigester", "getMDest", "getDigester", "createdigest", "createdigests", "createdigester", "getMDests", "getDigests", "getMDester", "getSignest", "getdigest", "createDigHash", "createDigest", "getDigHash"], "attribute": ["prefix", "att", "component", "subject", "uri", "resource", "image", "message", "connection", "event", "data", "username", "individual", "entry", "document", "application", "definition", "audio", "route", "set", "attr", "type", "ribute", "element", "instance", "plugin", "class", "metadata", "api", "config", "directory", "client", "pair", "expression", "feature", "node", "variable", "object", "address", "character", "name", "property", "entity", "reference", "device", "function", "layer", "operation", "value", "ident", "argument", "manager", "Attribute"], "digestAlgorithm": ["digESTAlg", "digesterAlgebra", "digestalger", "digestElg", "digestElger", "digestAlgorith", "digestalgo", "digesterAlgo", "digestAlg", "digESTAlgo", "digesterAlgorith", "digESTAlgorithm", "digestAlgo", "digestalg", "digestalgorith", "digestAlgebra", "digestalgorithm", "digestElgo", "digestALgorithm", "digestALgebra", "digesterAlgorithm", "digestALgorith", "digestElgorithm", "digestALgo", "digestAlger", "digESTAlger", "digestalgebra"], "digest": ["labest", "DigEST", " digEST", "dger", "bigester", "dest", "bigger", "bigest", "Digester", "signger", "digEST", "Digest", " digested", "diguration", "longester", "Digtest", "digtest", "multipluration", "multiplEST", "labEST", "digger", "multiplest", "signest", " diguration", "multiplester", " digester", "longEST", "Digested", "digester", " digtest", "signester", "dester", "biggest", "labtest", "dgest", "digested", "labester", "diggest", "Diguration", "longest", "signgest", "longested"], "md": ["ds", "own", "m", "wd", "rm", "doc", "mad", "hd", "sd", " MD", "der", "module", "nd", "mp", "cmd", "mr", "mo", "um", "mid", "dd", "ht", "editor", "mc", "mag", "d", "od", "mb", "ms", "dev", "ng", "nm", "amd", "plugin", "dm", "bd", "meta", "metadata", "cm", "pd", "MD", "di", "mn", "mi", "db", "ad", "mac", "my", "id", "po", "mm", "ma", "sm", "app", "ml", "ld", "cb", "pm", "kg", "arm", "mt", "cd", "ui", "mod", "manager", "df"]}}
{"id1": "22338097", "id2": "19206412", "code1": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"createMD5": [" createSHA5", "createMD2", "createSHA5", " createMD512", " createSHA256", "createSHA2", "createMD256", "createMAC256", "createSHA256", "createmd512", "createmd256", " createMD256", "createmd5", "createMD512", " createSHA512", "createmd2", "createMAC5", "createMAC2", "createMAC512", " createSHA2", "createSHA512", " createMD2"], "pwd": ["cpassword", "cwd", " pWD", "cWD", " pwm", "Pwd", "hwm", "Ppassword", "hWD", "Pw", "pwm", "pWD", "hwd", "PWD", " ppassword", "cw", "Pwm", "ppassword", "pw", " pw", "hw"], "md": ["m", "rm", "hd", " MD", "mp", "cmd", "mo", "um", "dig", "dd", "gd", "py", "mc", "mag", "d", "vd", "od", "mb", "meta", "hm", "wd", "amd", "mg", "dm", "bd", "pkg", "cm", "metadata", "bf", "MD", "tmp", "di", "ad", "de", "mac", "ind", "mand", "po", "mm", "am", "mk", "pm", "mt", "cd", "mod", "df"], "pd": ["fd", "std", "ppa", "pe", "hd", "sd", "np", "lp", "pins", "xd", "pat", "cp", "ps", "pg", "sv", "dd", "gd", "py", "pb", "vd", "d", "pid", "od", "wd", "PD", "dl", "bd", "ped", "wp", "pi", "da", "po", "pc", "td", "ld", "pm", "cd", "dp", "ppo", "pp", "p", "tp", "ds"], "app": ["bb", "cap", "page", "pad", "array", "pack", "arr", "append", "ask", "apply", "html", "b", "g", "conf", "mp", "form", "cmp", "ce", "cell", "fb", "data", "msg", "allow", "bc", "ang", "sb", "application", "apps", "py", "acc", "ch", "ape", "test", "container", "s", "instance", "api", "keep", "buff", "ip", "db", "mac", "cache", "string", "amp", "ac", "ap", "fac", "host", "sp", "aa", "buffer", "APP", "ab", "App", "pp", "p"], "i": ["u", "z", "uri", "e", "j", "b", "n", "fi", "ori", "io", "info", "data", "si", "f", "ni", "o", "index", "d", "ci", "end", "oi", "s", "key", "ji", "abi", "multi", "li", "di", "l", "hi", "pi", "ip", "xi", "inner", "slice", "id", "uli", "ti", "v", "gi", "c", "t", "ri", "I", "zi", "ai", "ix", "chi", "ii", "ui", "x", "bi", "ini", "mu", "qi", "p"], "s2": [" s12", "dstwo", "sl182", "p3", "s12", "sestwo", "ses2", " s6", "ptwo", "p12", "ses6", " salt", "salt", " s1", "stwo", "ds2", "sl1", "ds6", " s182", "pass1", " s3", "p182", "s3", "pass12", "p1", "pass2", "passtwo", "palt", "p2", "s6", "s182", " stwo", "s1", "sl2"]}}
{"id1": "19934218", "id2": "8490710", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "label": 0, "substitutes": {"doCrypt": [" doMac", "murDec", "DoMac", " runMac", "DoCrypt", " runExt", " runDec", "murExt", "murCrypt", "DoDec", " doExt", " runCrypt", "DoExt", " doDec", "murMac"], "text": ["font", "crypt", "url", "txt", "message", "image", " Text", "length", "struct", "connection", "letter", "EXT", "data", "this", "in", "input", "str", "editor", "hex", "password", "key", "code", "source", "class", "config", "seed", "TEXT", "object", "token", "string", "obj", "name", "binary", "pattern", "context", "path", "word", "content", "buffer", "ext", "value", "format", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedEncodingError", "UnsupportedEncodedEx", "UnsupportedEncoderError", "UnsupportedEncoderException", "UnsupportedEncodedException", "UnsupportedEncasingError", "UnsupportedEncoderEx", "UnsupportedEncodingEx", "UnsupportedEncasingException", "UnsupportedEncasingEx", "UnsupportedEncodedError"], "md": ["mad", "m", "rm", "hd", "sd", " MD", "Cmd", "message", " Md", "mp", "body", "cmd", "dr", "sha", "method", "data", "mo", "dig", "dd", "gd", "mode", "hash", "map", "mc", "valid", "d", "mag", "vd", "od", "ms", "meta", "me", "mb", "code", "amd", "mg", "dm", "bd", "wd", "metadata", "bf", "bm", "pd", "MD", "hm", "mn", "ad", "mac", "nm", "mand", "ud", "mm", "ma", "def", "am", "ld", "pm", "mt", "mod", "df"], "sha1hash": ["shaoneh", "sha6hash", "sha2hex", "sha2h", "SHA2Hash", "SHA1hash", "SHA2hex", "sha256sha", "sha1hex", "shaonesha", "shaonehash", "SHA2hash", "md1hex", "sha1Hash", "sha2hash", "md1h", "sha2Hash", "SHA2sum", "sha5h", "md1hash", "SHA1h", "sha5hex", "sha0sum", "sha2sum", "SHA1sha", "sha1sum", "SHA2h", "SHA1Hash", "sha256hex", "md6hash", "sha0sha", "sha6hex", "sha1h", "SHA1sum", "md6hex", "sha256h", "sha5Hash", "sha256sum", "sha5hash", "sha6h", "sha0hash", "sha6sha", "sha0hex", "md6sha", "sha1sha", "md6h", "sha5sha", "sha256hash", "SHA2sha", "md1sha", "sha2sha", "shaonehex", "sha256Hash", "SHA1hex"]}}
{"id1": "659316", "id2": "2736184", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"argv": ["Argve", "Argb", " argve", " argver", " argl", "interV", "argsv", "argV", "argumentc", "Argver", "Argf", "Argl", "paramb", "argumentv", "argumentve", "Argc", "argver", "interc", "argsc", " argb", " argc", "interv", " argV", "argf", " argf", "paramV", "interl", "paramv", "argve", "argb", "argsl", "Argv", "argl", "argumentver", "argsf", "paraml", "ArgV", "argc"], "sources": ["tources", "fides", "psides", "sences", "tides", "sesores", "vesores", "sides", "sesigs", "vesences", "sigs", "statources", "fource", "statigs", "tresources", "fors", "sesources", "vesigs", " sides", "issource", "issides", "psources", "fources", "statores", "psresources", "issors", "psource", "fresources", "sresources", "sors", " sors", "issources", "sesences", "vesources", "sores", "tource", "statences"], "targets": [" taxets", "targends", "taxels", " tokets", "tangets", "taxes", "tangels", " targencies", " targens", "Tangens", "targels", "tokets", "targencies", "tagnencies", " tokencies", "tigens", " targes", "tokens", "tanget", "toket", "tagnets", "tamplets", "tampens", "tampels", "targens", " targends", "tigets", "tagnens", "Targlets", "tanges", "tangens", "tiges", " tokens", "targes", " taxes", "taxends", "Tanglets", " taxens", "Targens", "tangencies", "Tangels", " toket", "taxens", "tangends", "Targets", "tampets", "taxets", "Targels", "tagnet", "tokencies", "taxlets", "tigends", "tanglets", "Tangets", "targlets", " taxends"], "srclen": ["srploen", " srplength", "srselen", " srclength", "srplen", "rscelens", "srCLen", "srclength", "rscln", "srClens", "srCLoen", " srploen", "srceln", " srcloen", "rsclens", "srcloen", "srctoen", "srCLeno", "srclens", "srcln", "srctength", "srCln", "srcteno", "srClen", "rscelEN", "srcelens", "srseln", "srClEN", "srpleno", "srcelEN", " srcleno", "srcten", "srplength", " srplen", "srselEN", "srCLength", " srpleno", "rsceln", "rsclen", "srcleno", "rsclEN", "rscelen", "srcelen", "srselens", "srclEN"], "source": ["proxy", "component", "url", "ssl", "uri", "resource", "image", "unit", "parent", "dest", "copy", "scope", "view", "rc", "remote", "event", "single", "link", "channel", "in", "model", "Source", "input", "ources", "out", "s", "type", "create", "driver", "src", "reader", "size", "client", "config", "stream", "seed", "self", "slice", "id", "cache", "ource", "start", "service", "sl", "SOURCE", "get", "path", "current", "secure", "force", "use"], "tgt": ["ptnt", " tgz", "tgh", "bitgt", "ptarg", " tgs", " tkt", "hret", "larg", " tbuster", "rgs", "ptgt", "hgt", "lret", " targ", "tnt", "Tch", " tch", "biticket", "Tgt", "tgs", " ticket", "lgt", "Tgh", "lnt", "tch", " tnt", "tkt", "bitarg", "Tgs", "ticket", "rgt", " tret", "targ", "Ticket", "rch", "ptbuster", "hnt", "tbuster", "hgz", "lbuster", "rkt", "tret", "Tkt", "lgz", " tgh", "bitgh", "Targ", "tgz"], "target": ["to", "component", "url", "unit", "resource", "image", "core", "parent", "dest", "master", "null", "view", "connection", "rel", "manager", "remote", "event", "io", "project", "mount", "session", "child", "port", "external", "director", "channel", "output", "member", "it", "result", "cross", "route", "archive", "nt", "out", "conn", "download", "plugin", "driver", "client", "slave", "Target", "point", "base", "object", "match", "arget", "handler", "service", "goal", "next", "path", "current", "tail", "force", "open"], "deletes": ["delises", "Deletes", "kesleted", "downgrades", " deleted", "exgrades", "kesouts", "disles", "kesises", "desletes", "delouts", "downletes", "delletes", "disists", " delete", "delleted", "deises", "downlete", "downdates", "exdates", "exletes", "degrades", "desles", "deouts", "deires", "delete", " deouts", "exlete", "deists", " degrades", "Deists", "disires", "dedates", "Deires", "desires", "desists", "disletes", " deises", "Deles", "kesletes", "deles", "deleted", " dedates"], "del": ["fl", "delay", "install", "ll", "se", "copy", "null", "rel", "lock", "ul", " delete", "data", "dec", "syn", "model", "fail", "d", "coll", "nl", "remove", "el", "download", "dl", "pull", "add", "dir", "delete", "base", "de", "local", "change", "neg", "skip", "id", "err", "file", "name", "Delete", "def", "up", "sel", "diff", "down", "get", "clean", "Del", "bl", "update", " Del"]}}
{"id1": "12579075", "id2": "10212189", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFromSystemperties", "loadFormsystemProperty", "loadFromLocalproperty", "loadFormsystemproperty", "loadFromSysProperty", "loadFromsystemperties", "loadFromsystemString", "loadFromSysString", "loadFromLocalperties", "loadFormsystemString", "loadFormSystemperties", "loadFormSystemString", "loadFormSystemproperty", "loadFromSystemproperty", "loadFromSysproperty", "loadFormsystemperties", "loadFromLocalProperty", "loadFromSystemString", "loadFromsystemProperty", "loadFromsystemproperty", "loadFormSystemProperty", "loadFromSysperties", "loadFromLocalString"], "propertyName": ["propertyPath", "propString", "PropertyName", "propName", "propStr", " propertyPath", "fileString", "PropertyPath", " propertyValue", "PropertyStr", "fileName", "propPart", " propertyNames", "propNames", " propertyStr", "propertyPart", "propValue", "propertyStr", "propPath", " propertyString", "propertyNames", "filePart", "propertyString", "PropertyValue", "fileNames", " propertyPart", "propertyValue"], "urlStr": ["urlText", "uriName", " urlName", "urlSt", "urlName", " urlText", " urlString", "uristr", "UrlStr", "httpstr", " urlWr", "urlWr", "Urlstr", "URLStr", " urlSt", "urlstr", "URLString", "UrlString", "UrlSt", " urlstr", "uriStr", "resourceString", "UrlText", "URLWr", "uriWr", "URLName", "httpName", "UrlName", "httpStr", "UrlWr", "URLstr", "URLSt", "httpText", "resourceStr", "resourceSt", "urlString"], "in": ["m", "p", "ins", "ssl", "resource", "image", "In", "n", "init", "data", "session", "inc", "socket", "part", "f", "gin", "input", "din", "IN", "inn", "out", "conn", "cin", "i", "source", "is", "reader", "src", "client", "nin", "l", "stream", "login", "a", "inner", "min", "r", "id", "ac", "bin", "file", "c", "err", "con", "ic", "fac", "cf", "ini", "as", "again", "serv", "doc", "isin"], "xmlDoc": ["domDocument", " xmlStr", "xmlDom", "externalDoc", "jsonDocument", " xmlDom", "officeDom", "domStr", "webDocument", "domUrl", " xmlDocument", "externalDocument", "officeStr", "xmlConfig", "xmlStr", " xmlConfig", "xmlDocument", "webDoc", "domDoc", "officeDoc", "externalStr", "jsonDoc", "mlConfig", "mlUrl", "jsonDom", "mlStr", "webStr", "jsonStr", "mlDocument", "webUrl", "mlDoc", "xmlUrl", "officeDocument", "externalConfig"], "url": ["ls", "uri", "ssl", "ll", "image", "server", "fr", "resource", "b", "connection", "io", "data", "socket", "f", "inst", "input", "str", "URL", "www", "bel", "inf", "el", "download", "instance", "source", "src", "config", "reader", "client", "l", "stream", "web", "base", "user", "id", "string", "gl", "file", "sl", "Url", "buffer", "http", "feed", "open", "browser"]}}
{"id1": "12242903", "id2": "15351863", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"hashKey": ["hashSecret", "buildkey", "HashSecret", "Hashkey", "hashkey", "buildKey", "HashKEY", "shakey", "shaSecret", "shaKey", "buildSecret", "hashKEY", "shaKEY", "HashKey", "buildKEY"], "key": ["k", "crypt", "prefix", "text", "keys", "message", "cert", "parent", "connection", "Key", "data", "this", "sync", "check", "input", "block", "hex", "sum", "password", "type", "code", "temp", "source", "pair", "seed", "number", "base", "sign", "mac", "user", "object", "id", "cache", "token", "string", "address", "name", "mix", "x", "value", "word", "chain", "use", "secret", "KEY"], "hashed": ["hsashing", "bhashed", "hhed", "Hhed", " hoded", "hsashed", "hhashing", "hhashed", "Hotted", "hoded", "shotted", "Hashed", "hhash", "bhash", "Hashing", "shashed", "ahashed", "bhotted", "hsasha", " hhed", "Hasha", "bhashing", "shhed", "Hoded", "hhasha", "hasha", "ahash", "ahashing", "shash", "shoded", "hsash", "hotted", "hashing", "shashing", "ahhed", "Hash"], "md5": [" md50", "md62", "md50", "MD3", " mddown", "amd3", "mand50", "MD512", " md512", "base4", "MD5", "amd2", " md2", "md3", " md3", "base62", "md2", "amddown", "MD62", "md4", "base2", " md62", "amd5", "mddown", "mand512", "MD4", "MD2", "MDdown", "mand5", "base5", " md4", "mand4", "md512", "MD50"], "hash": ["ash", "array", "log", "url", "message", "image", "length", "copy", "count", "html", "sha", "num", "rh", "dot", "carry", "search", "f", "her", "result", "check", "hex", "sum", "shadow", "h", "code", "abi", "print", "size", "base", "mac", "hed", "id", "cache", "string", "v", "Hash", "json", "value", "throw"]}}
{"id1": "14001795", "id2": "13362846", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverwarPath", "copyOverwarfile", "copyoverwarfile", "copyoverwarFile", "copyOverWarfile", "copyOverwarPath", "copyOverWarPath", "copyOverWARPath", "copyoverWarfile", "copyOverWebfile", "copyOverWebFiles", "copyOverWebFile", "copyOverWARfile", "copyOverWARFiles", "copyOverWarFiles", "copyoverwarFiles", "copyOverWebPath", "copyoverWarFiles", "copyoverWarPath", "copyOverwarFile", "copyoverWarFile", "copyOverWARFile", "copyOverwarFiles"], "dir": ["fd", "doc", "log", "direction", "http", "url", "parent", "build", "dr", "loc", "manager", "lock", "DIR", "data", "md", "store", "part", "folder", "group", " directory", "zip", "d", "coll", "draft", "wd", "cur", "download", "handle", "plugin", "pkg", "class", "config", "directory", "keep", "work", "di", "db", "r", "local", "cache", "desc", "ir", "handler", "file", "dist", "window", "dc", "def", "direct", "up", "dn", "clean", "Dir", "director", "feed", "lib", "df"], "ff": ["fd", "buf", "uf", "fl", "lf", "flow", "sf", "ffe", "fed", "fox", "fb", "ph", "fff", "xff", "dd", "fp", "now", "cpp", "cl", "eff", "cb", "rf", "bf", "uff", "bd", "ffff", "upp", " buff", "TF", "buff", "iff", "ft", "fw", "fx", "fam", "eph", "fold", "FF", "aff", "cf", "ef", "fe", "pp", "feed", "bb", "df"], "files": ["ls", "keys", "fl", "rows", "users", "ps", "jobs", "data", "ums", "sections", "apps", "bs", "groups", "features", "fa", "plugins", "split", "classes", "lines", "balls", "fs", "s", "flows", "objects", "results", "images", "pages", "names", "models", "file", "locks", "iles", "blocks", "Files", "events", "fe", "items"], "f": ["fd", "fn", "fl", " file", "fr", "lf", "e", "sf", "n", "flat", "info", "fb", "part", "fa", "d", "feed", "fs", "tf", "rf", "inf", "bf", "i", "filename", "l", "of", " fa", "v", "handler", "c", "file", "fold", "name", "fc", "t", "fen", "aff", "cf", "F", "x", "fe", "fp", "p"], "newFile": ["existingLine", "NewFolder", " newLine", "NewFile", "NewFiles", "nextFile", "oldFile", "updateLine", "newFolder", "oldFiles", " newDir", "newfile", "smallfile", "smallFile", "newF", "updatefile", "existingF", "nextFiles", " newFolder", " newfile", "andfile", "nextFolder", " newFiles", "andFile", "NewF", "NewDir", "nextDir", "newLine", "existingfile", "smallDir", "oldDir", " newF", "andDir", "newFiles", "newDir", "updateFile", "oldF", "updateF", "existingFile"], "fi": ["ifa", "fr", "lf", "fin", "sf", "ico", "isi", "ffe", "wi", "uci", "sci", "info", "Fi", "shi", "fb", "si", "ife", "py", "flo", "fa", "fs", "abi", "i", "ifi", "pi", "xi", "fw", "cci", "afe", "fine", "FI", "fc", "fy", "zi", "cf", "ini", "ii", "bi", "afi", "fe", "fp", "qi"], "fo": ["ato", "wo", "FO", "uf", "sf", "ico", "ki", "os", "xf", "io", "info", "shi", "mo", "si", "tto", "osa", "ni", "obi", "flo", "so", "fa", "o", "olo", "ko", "bo", "inf", "ho", "di", "zo", "co", "fw", "po", "afe", "oo", "cf", "lo", "afi", "fe", "obo", "ofi"]}}
{"id1": "11840277", "id2": "23677142", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"clearTables": ["clearContows", "cacheTableations", "clearContaches", "clearStaces", "clearTemings", "clearTows", "clearTableows", "clearContaces", "clearStables", "clearStaches", "cacheTations", "cacheTableables", "cacheTables", "clearTemations", "cacheTings", "createTables", "clearTemables", "clearContables", "clearBows", "createTaches", "clearTings", "clearTemows", "createStaces", "clearBings", "clearBables", "clearBations", "createTows", "clearTations", "clearStows", "clearBaches", "clearTaches", "cacheTows", "cacheTableows", "clearBaces", "clearTableations", "clearTableings", "clearTaces", "createStables", "createTaces", "clearTableables", "createStows", "cacheTableings", "createStaches"], "conn": ["sth", "bb", "log", "ct", "ssl", "cn", "col", "server", "Connect", "conf", "n", "connection", "loc", "cp", "act", "pg", "cmp", "lock", "rc", "ns", "org", "session", "sql", "jc", "oss", "Connection", "cond", "connect", "mc", "nt", "coll", "ch", "nc", "ci", "h", "wd", "cb", "Conn", "cc", "error", "cat", "cm", "oci", "config", "client", "co", "di", "db", "ann", "cache", "ac", "exec", "con", "c", "obj", "dc", "dn", "ob", "ou", "ctx", "ai", "pub", "path", "mt", "cf", "state", "lc", "ca", "close", "enc", "p", "open"], "stmt": ["strMT", "stnt", "actmn", "emt", " stmn", "tm", " str", " stbm", "stprint", " stager", "ctm", " stgr", "Stmi", "ssmn", "dm", "playtx", "actnt", "tct", "stbm", "stmc", "stql", "estmt", "stmn", "Stmd", "ftmt", " stlt", "putlt", "STmc", "puttor", "stager", "ftlt", "ldager", "est", "Stmc", "ctgr", "ctql", "ftbm", "dr", "stswd", "ctmt", "stap", " stma", "stsmt", "STmt", "stwd", "ssmt", "actmi", "ftmn", "Stmn", "playtor", "STprint", "stct", "STmn", "stwt", "stmm", "StMT", "STlt", "putma", "estmm", "putager", " stmi", "stlt", "stgr", "STMT", "putwt", " stmc", "eprint", " stql", "putmn", "ewd", " stct", "Stlt", "Stm", " stm", "strlt", "istmt", "strml", "STmd", "putmt", "playwt", "putm", "Stgr", "strmt", "ssbm", " stwt", "stmd", "str", "Stct", "dmt", "STst", "putMT", "stst", "tmt", "istgr", "ldma", "stMT", "playmt", "ctr", " stmd", "Stnt", "stmi", " stap", "stml", "ldmt", "Sttor", "sttx", " stnt", "puttx", "Stwt", "dql", "STgr", "stsst", "putap", "actmt", "tnt", "istmn", "Stml", "Stap", "ldmn", "putmm", "sswt", "sttor", "putml", "estwt", "STbm", "STwd", "putbm", "stsprint", " stml", "Stmt", "ctmd", "Sttx", "stma", "estm", "Stmm", "stm", "istMT"]}}
{"id1": "13333160", "id2": "17729554", "code1": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"run": ["running", "uri", "module", "report", "apply", "Run", "Test", "loop", "Main", "evaluate", "man", "read", "test", "process", "config", "work", "edit", "exec", "submit", "Process", "runner", "render", "update", "execute", "doc"], "xmlIn": ["mlOut", "phpSource", "xmlSource", "mlin", "inputIns", " xmlSource", "jsonSource", " xmlOut", "jsonReader", "phpOut", "inputOut", " xmlin", "jsonIn", "inputIn", "xmlOut", " xmlIns", "xmlReader", "inputin", "mlIn", "mlIns", "phpReader", "jsonOut", "xmlIns", " xmlReader", "phpIn", "xmlin"], "out": ["prefix", "page", "res", "log", "writer", "ex", "write", "report", "resource", "server", "parent", "dest", "connection", "io", "project", "external", "output", "in", "result", "Out", "timeout", "temp", "builder", "source", "client", "dump", "outs", "table", "cache", "string", "bin", "err", "file", "window", "name", "list", "up", "w", "OUT", "buffer", "again", "doc"], "dom": ["m", "p", "fr", "frame", "url", "nav", "html", "dr", "form", "DOM", "parser", "document", "result", "browser", "valid", "d", "ch", "h", "live", "home", "ver", "xml", "dm", "builder", "cm", "db", "tree", "base", "node", "Dom", "div", "c", "up", "host", "domain", "bot", "bug", "hub", "om", "http", "doc", "img", "df", "com"], "f": ["fd", "m", "u", "fr", "e", "sf", "g", "conf", "fb", "fm", "fa", "o", "d", "Factory", "h", "fs", "s", "inf", "framework", "bf", "tf", "rf", "i", "raf", "l", "fx", "v", "c", "def", "af", "t", "aff", "fc", "w", "fab", "full", "cf", "function", "fac", "F", "x", "fe", "http", "fp", "p", "df"], "b": ["bb", "m", "e", "build", "body", "fb", "bt", "Builder", "xb", "lb", "bc", "sb", "d", "rb", "h", "bel", "s", "bf", "B", "builder", "bd", "library", "l", "db", "base", "bar", "r", "abb", "ib", "ba", "orb", "v", "br", "c", "gb", "be", "ob", "lib", "ab", "abs", "bs", "p"], "root": ["rec", "component", "rss", "writer", "default", "core", "html", "parent", "null", "ver", "Document", "Supported", "r", "div", "string", " DOM", "false", "owner", "right", "m", "page", "Node", "e", "ax", "Element", "leaf", "this", "parser", "Valid", "result", "ow", "h", "element", "xml", "builder", "parse", "article", " Dom", "tree", "legal", " rooted", "found", "c", "path", " correct", "allowed", "Root", "url", "master", "ok", "loc", "attr", " empty", "transform", "node", "obj", "cover", "doc", "nav", "DOM", "child", "allow", "document", "valid", "container", "home", "rew", "Doc", " Document", "Dom", " node", " Root", "af", "host", "supported", "author", " allowed", "head", "p"], "att": ["at", " attribute", "art", "attribute", "text", "annot", "ct", "arr", "struct", "html", "Info", "_", "rs", "attach", "av", "ATT", "ht", "str", "tt", "acc", "nt", "attr", "aj", "utt", " Att", "cat", "ack", "aut", "nat", "Attributes", "apt", "lit", "ann", "alt", "mat", " ax", "ac", "obj", "name", "app", "ott", "t", "atts", "adj", "ai", "ant", "Att", "Attribute", " html"], "menu": ["m", "page", " menus", "u", "uri", "nav", "module", "server", "resource", "parent", "image", "view", "item", "ul", "info", "group", "site", "us", "container", "uni", "plugin", "i", "theme", "cu", "config", "gui", "li", "license", "command", "user", "queue", "wiki", "cache", "video", "layout", "gi", "v", "list", "ui", "query", "Menu", "cal", "manager", "doc", "category"], "id": ["ID", "prop", "tag", "data", "version", "info", "mid", "sid", "title", "alias", "pid", "href", "key", "end", "rid", "code", "class", "action", "target", "ids", "start", "name", "option", "path", "oid", "category"], "zout": ["azout", "Zout", " zconn", "zOUT", " zunk", "gzOUT", "zeagain", "gzin", " zin", " zzip", "zenin", "zhouter", "jobject", "zenunk", "gzagain", "gzout", "jio", "zeninner", "zenout", "ezio", "Zagain", "ezOut", "zipin", " zOut", "azzip", "zipio", "azagain", "zeconn", "zhout", " zdiff", "zeout", "azOut", "zagain", "zhagain", "ZOut", "zinner", "ezagain", "ldout", "zenagain", " zagain", "ldOUT", "zenouter", "zconn", "zipOut", "zeOut", "ZOUT", "ezdiff", "zhinner", "zenOut", "zio", "zOut", "jin", "ldOut", "ezobject", "jout", "zipOUT", "zdiff", "zipagain", "zunk", "zipout", "zouter", "azOUT", "Zin", "ezouter", "Zobject", "ldagain", "zin", "ezinner", "zenzip", "ezout", "ezunk", "ezin", "Zio", "zobject", "ezconn", "zendiff", "zzip", " zio"], "content": ["default", "image", "const", "parent", "null", "script", "data", "search", "password", "fill", "conn", "temp", "column", "cache", "string", "exec", "file", "gray", "context", "update", "page", "text", "resource", "message", "server", "connection", "empty", "music", "version", "model", "status", "children", "code", "handle", "xml", "config", "expression", " Content", "path", "word", "lc", "x", "ca", "url", "complete", "prev", "ontent", "job", "Content", "process", "time", "create", "section", "size", "character", "location", "wrapper", "value", "activity", "example", "body", "ce", "child", "title", "output", "document", "gc", "cm", "header", "media", "work", "address", "language", "load", "help", "continue", "left", "host", "full", "response", "cont", "current", "request", "ext"], "signal": ["signature", " signig", " signals", "ignale", "seature", "SIGNig", "mental", "signals", "ignal", "mentaled", "SIGNature", "Signig", "Signale", "signaled", "ignAL", "SIGNal", " signAL", "mentature", "signig", "seig", "Signature", "sealed", "mentig", "SIGNale", "ignig", "Signaled", "signAL", " signature", "seal", "ignaled", "SignAL", "ignature", " signaled", "Signals", "Signal", "signale", "ignals"], "n": ["norm", "k", "m", "fn", "un", "u", "z", "e", "j", "g", "nr", "en", "num", "none", "ns", "not", "ni", "all", "sn", "o", "index", "d", "inn", "nl", "h", "s", "ng", "conn", "i", "y", "size", "ne", "l", "len", "eni", "node", "r", "v", "c", "adj", "net", "t", "x", "nor", "nb", "N", "p", "nn"], "entry": ["enter", "e", "module", "server", "se", "system", "letter", "cell", "event", "info", "data", "je", "this", "child", "parser", "channel", "in", "no", "her", "zip", "archive", "nt", "ent", "row", "Entry", "element", "ries", "add", "record", "reader", "cel", " Entry", "inner", "de", "r", "string", "file", "obj", "per", "next", "auto", "or", "lc", "feed", "ry"], "pout": ["patchin", " pn", "patchout", "prwriter", "prout", "ppout", " pin", "cpconn", "cpout", " pOut", "ppio", "Pin", "Pout", "Pouter", "prin", "patchio", "POut", "lpout", "pwriter", "pint", "pagain", "ppnet", "lpio", "cpio", "zin", " pnet", "pn", " pwriter", " pconn", " pouter", "Pn", "lpin", "pOut", "Pwriter", "print", "zOut", "cpagain", "lpnet", " pint", "pconn", "ppin", "ppconn", "Pint", "pin", "pouter", "pio", "pnet", "Pio", " pio", " pagain", "patchn", "zouter", "ppagain"]}}
{"id1": "9954926", "id2": "22135199", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"simulate": ["animure", "imulate", "Simulator", "Simure", "animulation", "imulation", "animulate", "imure", "simulation", "Simulate", "simure", "imulator", "animulator", "simulator", "Simulation"], "out": ["ex", "writer", "flow", "report", "parent", "null", "view", "data", "part", "in", "exp", "o", "conn", "temp", "cli", "outs", "cache", "string", "err", "list", "net", "pre", "page", "resource", "server", "info", "group", "result", "error", "key", "dump", "point", "object", "con", "w", "down", "word", "post", "prefix", "gen", "log", "exit", "plain", "io", "outer", "sys", "store", "Out", "flush", "comment", "co", "db", "user", "bin", "obj", "up", "buffer", "again", "write", "copy", "lock", "session", "external", "raw", "output", "now", "client", "tmp", "base", "table", "window", "name", "full", "OUT", "pool", "state", "line", "lib"], "file": ["book", "page", "pe", "log", "FILE", "url", "report", "resource", "message", "le", "ile", "unit", "b", "connection", "data", "socket", "port", "output", "in", "f", "rule", "feed", "source", "filename", "stream", "l", "files", "base", "queue", "cache", "address", "handler", "name", "loader", "full", "File", "path", "buffer", "fe", "collection", "line", "fp"], "obtainUserReputationRequest": ["obtainUserAnnutationRequest", "obtainUserReputedGrant", "obtainUserRepositoryResponse", "obtainUserRepurationResponse", "obtainUserComputationInfo", "obtainUserAnnigrationQuery", "obtainUserReputableResponse", "obtainUserRelutationGrant", "obtainUserRepurationRequest", "obtainUserComputationEntry", "obtainUserRepulationInput", "obtainUserReputedResponse", "obtainUserReputionGrant", "obtainUserRelutationrequest", "obtainUserRepigrationInfo", "obtainUserRelentionrequest", "obtainUserRelutationResponse", "obtainUserReputedrequest", "obtainUserReputionrequest", "obtainUserReputationGrant", "obtainUserComputationInput", "obtainUserAnnutationGrant", "obtainUserRepigrationQuery", "obtainUserReputeResponse", "obtainUserReputableRequest", "obtainUserRelentionRequest", "obtainUserRepigrationRequest", "obtainUserRepulationResponse", "obtainUserRepentionGrant", "obtainUserReputationEntry", "obtainUserReputeEntry", "obtainUserReputedRequest", "obtainUserRepigrationGrant", "obtainUserComputationrequest", "obtainUserAnnigrationResponse", "obtainUserAnnigrationRequest", "obtainUserComputeResponse", "obtainUserRepentionRequest", "obtainUserComputeEntry", "obtainUserComputerequest", "obtainUserRepigrationResponse", "obtainUserRepositoryrequest", "obtainUserRepurityInput", "obtainUserComputeInfo", "obtainUserReputeGrant", "obtainUserComputationResponse", "obtainUserReputationQuery", "obtainUserAnnutationResponse", "obtainUserRepulationEntry", "obtainUserRelentionGrant", "obtainUserReputionResponse", "obtainUserRepositoryRequest", "obtainUserRepentionrequest", "obtainUserRelentionResponse", "obtainUserReputationInfo", "obtainUserReputerequest", "obtainUserReputationrequest", "obtainUserReputationInput", "obtainUserComputeRequest", "obtainUserComputeInput", "obtainUserAnnutationQuery", "obtainUserReputablerequest", "obtainUserRepigrationrequest", "obtainUserRepurationQuery", "obtainUserReputeQuery", "obtainUserReputeInfo", "obtainUserRepurationGrant", "obtainUserRepentionResponse", "obtainUserRepulationRequest", "obtainUserReputeInput", "obtainUserAnnigrationGrant", "obtainUserReputionRequest", "obtainUserReputeRequest", "obtainUserRepositoryInfo", "obtainUserRepurityResponse", "obtainUserRelutationRequest", "obtainUserComputationRequest", "obtainUserRepurityRequest", "obtainUserRepurityEntry"], "obtainUserReputationResponse": ["obtainUserRepositoryRequest", "obtainUserReputationResp", "obtainUserExpositoryResp", "obtainUserExputationResponse", "obtainUserRepositoryResponse", "obtainUserRepurationResponse", "obtainUserReputeResponse", "obtainUserExputationResp", "obtainUserExpositoryResponse", "obtainUserRepurationResp", "obtainUserExputationRequest", "obtainUserExpositoryRequest", "obtainUserReputeResp", "obtainUserRepurationRequest", "obtainUserReputeRequest", "obtainUserRepositoryResp"], "rateUserRequest": ["rateUsageReturn", "rateuserrequest", " rateuserrequest", "rateFileCommand", "RateFileResponse", "rateMachinerequest", "rateMachineRequest", "rateUQUEST", "rateUserFunction", "gradeLineError", "rateFileQUEST", " rateUserQUEST", "issueCustomerForce", "rateUError", "ratedFileCommand", "rateLineGrant", "ratedUserrequest", "RateFileQUEST", "rateFileVersion", "rateWordCustomer", "gradeUserRequest", "rateCustomerForce", "RateUserQUEST", "rateMachineResult", "RateFilerequest", "rateHumanVersion", "rateUQuery", "rateLineResponse", " rateClientRequest", "rateHumanResult", " rateClientGrant", "rateServiceQuery", "rateUserResult", "rateWordError", "rateUserReturn", " rateuserRequest", "gradeUserCustomer", "rateClientGrant", "rateMachineVersion", "rateUResponse", "ratedUsageForce", "rateWordQuery", "rateApplicationRequest", "rateUsageQUEST", "rateUserGrant", "RateUserRequest", "issueUserRequest", "rateHumanrequest", "rateServiceFunction", "rateUCommand", "gradeUserError", "ratedUserFunction", "issueCustomerReturn", "rateUsageUser", "rateLineError", "rateUserQUEST", "rateuserQUEST", "ratedUsageRequest", "issueCustomerRequest", "rateFilerequest", "ratePostrequest", " rateUserGrant", "rateUserError", "ratePostRequest", "rateFileRequest", " rateuserResponse", " rateClientrequest", "featureMachinerequest", "ratedFileRequest", "rateUsageQuery", "ratedUserQUEST", "issueCustomerQUEST", " rateuserQUEST", "featureMachineVersion", "ratedUserCommand", "rateUForce", "rateUsageRequest", "rateFileResponse", "rateUserForce", "rateUserrequest", "issueUserReturn", " rateUserQuery", " rateApplicationRequest", "featureMachineResult", "rateServiceCommand", "ratedUsagerequest", "rateCustomerReturn", "rateApplicationResponse", "rateUSERQUEST", "rateUserUser", "rateUserQuery", " rateApplicationQuery", "rateUsageGrant", "featureUserRequest", "rateFileQuery", "rateuserResponse", "featureMachineRequest", "rateUsageForce", "rateuserRequest", "rateLinerequest", "rateUsagerequest", "rateFileResult", "rateCustomerQUEST", " rateApplicationResponse", "rateClientRequest", "gradeLinerequest", "rateLineCustomer", "rateUsRequest", "rateUsReturn", "ratedUserRequest", "featureUserResult", "rateWordrequest", " rateApplicationUser", " rateUserUser", "rateUsForce", "ratedUsageQUEST", "ratedUsageQuery", "rateApplicationQuery", "rateUSERRequest", "rateLineRequest", "issueUserQUEST", " rateUserrequest", "ratedFileFunction", "rateUserCommand", "ratedFileQuery", "gradeLineRequest", "ratePostQUEST", "rateLineQUEST", "issueUserForce", "RateFileRequest", "rateUSERrequest", "rateLineQuery", "rateUSERForce", "gradeUserrequest", "rateClientrequest", "rateFileFunction", "ratedUserForce", "featureUserVersion", "rateUserCustomer", "rateWordRequest", "rateURequest", "RateUserrequest", "RateUserResponse", "ratedUserQuery", "rateUsQUEST", "rateUrequest", "rateUsageResponse", "rateHumanRequest", "rateApplicationUser", "rateFileUser", "rateServiceRequest", "ratePostResponse", "gradeLineCustomer", "rateUFunction", "rateUCustomer", "featureUserrequest", "rateUserVersion", "rateCustomerRequest"], "rateUserResponse": ["rateuserData", "rateFileStatus", "rateCustomerReference", "rateUsersResource", " rateUserReference", "rateUsersResp", "rateUserResource", "RateTimeStatus", "RateUserResource", " rateApplicationData", "rateCustomerResource", " rateFileResult", "rateUserResult", "RateUserStatus", "RateTimeResp", "RateTimeResponse", "rateUserReply", " rateUresponse", "rateApplicationReference", "rateUResponse", "RateUserRequest", "rateApplicationResp", "rateTimeResp", "rateClientResponse", "rateuserresponse", "rateFileresponse", " rateUResponse", "rateCustomerResp", "rateUresponse", "rateUserData", "rateuserReference", " rateApplicationReference", "rateCustomCustomer", " rateApplicationResp", " rateFileResp", "rateUsersResult", "rateApplicationData", "rateTimeCustomer", "rateFileResponse", " rateUserResult", "rateCustomResponse", " rateFileResponse", "rateuserReply", "rateUserReference", "rateUsersStatus", "rateClientStatus", "rateApplicationResponse", "rateTimeResponse", "rateuserResult", "rateuserResp", "rateuserResponse", "rateFileResult", "rateUsersRequest", "RateTimeCustomer", " rateApplicationResponse", "rateCustomResp", "rateUserResp", "rateCustomStatus", " rateUResp", "rateuserStatus", " rateUserReply", "rateTimeStatus", "RateUserResp", "RateUserCustomer", "rateUserStatus", "rateCustomerResponse", " rateUserresponse", "rateFileReply", " rateUserStatus", "rateClientCustomer", "rateUserCustomer", "RateUserResponse", "rateUResp", " rateFileStatus", "rateCustomerData", "rateUsersResponse", "rateFileResp", "rateClientResp", " rateUserData", " rateUserResp", "rateUReply", "rateUserresponse", " rateUReply", "rateCustomerRequest"], "fis": ["Fis", "FIs", " fiss", "sfiss", "sfris", "Fris", "fris", "sfIs", "Fiss", "bis", " fris", "bIs", "biss", "fIs", "bris", "fiss", "sfis", " fIs"], "br": ["buf", "res", "bro", "wr", "fr", "arr", "fin", "b", "body", "dr", " tr", "io", "bp", "bc", "result", "Reader", "str", "rb", "ch", "ref", " bio", "brush", "BR", "pr", "reader", "lr", "ber", "tr", "r", "cr", "err", "bed", " fr", "ob", "gr", "sp", "hr", "bl", "ler", "buffer", "Br", "bridge", "bs", "sw", "browser"], "call": ["text", "doc", "calling", "url", "play", "flow", "message", "e", "ell", "body", "cod", "loc", "cell", "info", "data", "msg", "phone", "output", "f", "result", "charge", "input", "str", "fax", "check", "ck", "cl", "claim", "called", "type", "code", "xml", "cat", "comment", "cu", "ack", "roll", "push", "create", "contact", "co", "work", "user", "sc", "address", "string", "load", "c", "Line", "name", "response", "query", "voice", "invoke", "buffer", "Call", "throw", "line", "use", "request", "callback"]}}
{"id1": "17791385", "id2": "17716716", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFile", " copyStream", "CopyFiles", " copyFiles", "copyfile", " copyfile", "CopyStream", "transferfile", "copyFiles", "Copyfile", "transferStream", "copyStream", "transferFiles", "transferFile"], "src": ["ls", "ins", "txt", "uri", "url", "image", "resource", "dest", "b", "st", "loc", "rc", "back", "sb", "inst", "input", "rb", "s", "inf", "ipl", "sin", "source", "config", "filename", "stream", "files", "sc", "sit", "file", "obj", "upload", "dist", "sup", "sl", "sel", "http", "img"], "dst": ["Dlt", "ddest", "ddfd", "Ddest", "dft", "stdest", " dlt", "ddst", "ststs", "dfd", "dsts", "ddsp", "pdft", "fdft", " dsts", "ddft", "fdsp", "stst", "Dst", "fdst", "stlt", "fdfd", "dlt", "pdst", "pdfd", "pdsp", "Dsts", " ddest", "dsp"], "in": ["m", "ln", "ins", "url", "In", "n", "init", "data", "inc", "socket", "gin", "f", "oin", "impl", "input", "din", "IN", "lin", "inn", "h", "conn", "cin", "i", "is", "sin", "win", "rin", "reader", "kin", "inside", "nin", "pull", "login", "inner", "r", "id", "bin", "err", "con", "file", "pin", "ini", "as", "again"], "out": ["at", "ex", "writer", "server", "plain", "copy", "parent", "null", "n", "io", "outer", "off", "sync", "inc", "raw", "part", "output", "f", "exp", "o", "Out", "s", "conn", "temp", "i", "client", "self", "outs", "cache", "exec", "bin", "err", "file", "obj", "other", "up", "net", "w", "OUT", "x", "ext", "again", "line", "post"], "buf": ["fd", "cap", "uf", "pad", "fl", "length", "uc", "b", "count", "cmd", "loc", "rc", "off", "fb", "data", "bh", "raw", "bc", "bag", "rb", "batch", "bytes", "cb", "val", "cur", "bf", "cat", "bd", "buff", "ff", "base", "queue", "br", "v", "lim", "c", "bin", "ctx", "vec", "wb", "bl", "buffer", "seq", "bb"], "len": ["fd", "cap", "ln", "fl", "lf", "ll", "fin", "le", "length", "count", "n", "en", "data", "rev", "part", "no", "pos", "all", "f", "nt", "split", "lin", "cl", "Len", "end", "val", "el", "i", "size", "li", "l", "base", "ind", "bin", "c", "err", "lim", "name", "sl", "ix", "lc", "lt", "line"]}}
{"id1": "6418781", "id2": "18433984", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"client": ["console", "image", "parent", "cloud", "socket", "cl", "conn", "class", "cli", "queue", "cache", "pc", "patch", "file", "net", "front", "secure", "quit", "resource", "server", "call", "cp", "connection", "remote", "cell", "cart", "and", "plugin", "i", "builder", "config", "command", "con", "c", "handler", "close", "util", "url", "end", "ci", "out", "api", "co", "web", "hard", "app", "clean", "force", "manager", "http", "open", "p", "ssl", "google", "ce", "project", "session", "connect", "cm", "contact", "Client", "base", "company", "grid", "host", "contract", "request"], "names": ["Names", "keys", "people", "letters", "modules", "users", "ns", "data", "headers", "apps", "terms", "groups", "named", "devices", "objects", "results", "works", "tools", "nets", "files", "resources", "ids", "versions", "ames", "list", "blocks", "ans", "types", "words", "members", "paces", "services", "nam", "strings", "items"], "name": ["NAME", "ame", "e", "one", "parent", "n", "_", "connection", "an", "info", "data", "part", "member", "f", "str", "named", "family", "key", "out", "type", "pass", "action", "api", "Name", "size", "a", "l", "filename", "base", "user", "company", "id", "string", "v", "file", "am", "path", "x", "word", "nam", "common"], "ftpFiles": ["ctfiles", "ftnFiles", "fttpFile", "fttpKeys", "fttpFiles", "ftfKeys", "fdtpFiles", "ftpiles", "fdtpTokens", "ftpTokens", "ftartTokens", "fdtpfiles", "ctfKeys", "ctpFiles", "ftpointFile", "ftartFiles", "ctpFile", "fdpTokens", "ctpKeys", "ftnFile", "ftartfiles", "fttpTokens", "fdpFiles", "ftpKeys", "ftfFiles", "ftpointKeys", "ftnfiles", "ftfiles", "ftpfiles", "ctfFile", "fdpfiles", "fttpiles", "ftfFile", "ctpiles", "ftpointFiles", "fdpFile", "ftnTokens", "ftartFile", "fdtpFile", "fttpfiles", "ctfFiles", "ftpointiles"], "ftpFile": ["lfpfile", "lfpEntry", "ftapDir", "lfpFile", " ftlFiles", "lfapfile", "ftpaBlock", "lflFiles", "flFile", "lfapFile", " ftpBlock", "ftlDirectory", "lfpDir", "ftPFiles", "ftPEntry", "ftlFile", "ftfPath", "ftlFiles", " ftlUrl", "ftapFiles", "lfpPath", "ftPFile", "ftpPath", " ftpUrl", "flDirectory", "ftpEntry", "ftpaEntry", "ftfpFile", "ftpaFile", "lflPath", "ftlPath", "ftPPath", "lfapFiles", "ftpaUrl", "ftpDir", "ftapiDir", "flFiles", "lfpFiles", "fpEntry", " ftlFile", "ftpDirectory", "ftfDir", "ftffile", "ftfpFiles", "ftapFile", "ftlEntry", "ftfFiles", "ftlUrl", "ftapiFiles", "ftpfile", "ftfpUrl", "ftapiFile", "ftfEntry", " ftlBlock", "ftpBlock", "ftapifile", "lflFile", "flEntry", "fpFile", "ftfFile", "lfapDir", "ftpaDirectory", "fpFiles", "ftpUrl", "fpDirectory", "ftfpBlock", "ftapfile", "ftpaFiles", "ftfDirectory", "lflEntry", "ftlBlock"]}}
{"id1": "17729554", "id2": "14464131", "code1": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"clonarFichero": ["clonarfichero", "clonarFaichero", "clonarfIChern", "clonarFaichern", "clonarFivehern", "clonarFICher", "clonarFIChero", "clonarFivehero", "clonarfICher", "clonarFicher", "clonarFicchio", "clonarficher", "clonarFiveher", "clonarfICchio", "clonarFaicchio", "clonarfichern", "clonarFivechio", "clonarFIChern", "clonarFichern", "clonarFICchio", "clonarfIChero", "clonarFaicher", "clonarficchio"], "rutaFicheroOrigen": ["rutaFichestOrigense", "rutaFicheroOpener", "rutaFichestOrigen", "rutaFicherOriginalener", "rutaFicherOrigens", "rutaFichestOriginened", "rutaFicheroOrigense", "rutaFichestOriginen", "rutaFicheroOpEN", "rutaFicheroOriginaleni", "rutaFicheroOrigener", "rutaFicheroOrigened", "rutaFicheroOpen", "rutaFicheroOpened", "rutaFicheroOrigininen", "rutaFicheroOriginalena", "rutaFicherOriginalEN", "rutaFicheroExtena", "rutaFicherOriginalen", "rutaFicheroOriginen", "rutaFicherOrigen", "rutaFicherOriginalens", "rutaFicheroOriginalEN", "rutaFicheroOriginened", "rutaFicheroOpens", "rutaFicheroOrigena", "rutaFicheroExteni", "rutaFichestOrigininen", "rutaFicheroOpense", "rutaFicheroOriginalened", "rutaFicheroOriginalinen", "rutaFicheroOriginalens", "rutaFicheroOriginalener", "rutaFicheroExtened", "rutaFicheroOpinen", "rutaFicheroOriginense", "rutaFicherOrigEN", "rutaFicheroOpeni", "rutaFichestOrigened", "rutaFicheroExten", "rutaFicheroOriginalense", "rutaFichestOriginense", "rutaFicheroOriginalen", "rutaFicheroOrigens", "rutaFicheroOpena", "rutaFicheroOrigeni", "rutaFicheroOrigEN", "rutaFicherOrigener"], "rutaFicheroDestino": ["rutaFicherRestina", "rutaFicheroDestario", "rutaFicheroDesino", "rutaFicheroDesario", "rutaFicherodestINO", "rutaFicheroRestario", "rutaFicheroRestino", "rutaFicherRestario", "rutaFicherOrigino", "rutaFicheroCampin", "rutaFicherodestin", "rutaFicheroDestINO", "rutaFicheroDesINO", "rutaFicherDestin", "rutaFicherDestino", "rutaFicheroOrigino", "rutaFicheroRestina", "rutaFicheroDestination", "rutaFicherodestino", "rutaFicheroCampination", "rutaFicheroOrigin", "rutaFicherRestino", "rutaFicherDestination", "rutaFicherodestination", "rutaFicherDestario", "rutaFicheroCampINO", "rutaFicherDestINO", "rutaFicherRestINO", "rutaFicherDestina", "rutaFicheroOrigINO", "rutaFicherOrigINO", "rutaFicherOrigin", "rutaFicheroDestin", "rutaFicherOrigination", "rutaFicheroOrigination", "rutaFicheroDestina", "rutaFicheroCampino", "rutaFicheroDesina", "rutaFicheroOrigina", "rutaFicheroOrigario", "rutaFicheroRestINO"], "salida": ["Salica", "palada", "Salidi", "malida", "salido", "salica", "Salanta", " salidas", "balida", "malanta", "slida", "palanta", "malidi", "Salida", "slidas", " salanda", "palidi", "salanta", "Salada", "saliza", "Salido", "sliza", " salica", "Saliza", "balido", "Salidas", "salidas", "salada", "malada", " salido", "balica", "slanda", " saliza", "palida", "salidi", "salanda", "balanda", "Salanda"], "canalOrigen": ["canalOrigensen", "canalsOrigEN", "canalorigens", "canalsOriginaln", "canalOrigened", "canalsOriginalensen", "canalOriginalain", "canalsOrigened", "canelOriginalun", "canalOriginalen", "canalOriginalens", "canalOriginens", "canelOriginalens", "canelOrigun", "canalSequen", "canalOrden", "canalOriginalun", "canalorigain", "canalorigened", "canalOriginen", "canalOriginaline", "canalOriginun", "canalsOriginalened", "canalSequn", "canalOrign", "canalOriginalensen", "canelOrigine", "canelOrigens", "canalOrigine", "canelOriginalen", "canalsOrigens", "canelOriginaline", "canalOrigEN", "canalorigine", "canelOrigen", "canalsOriginalen", "canalorigensen", "canalOriginaln", "canalSequens", "canalOrdn", "canalsOriginalens", "canalorigun", "canalSequEN", "canalsOrigain", "canalsOriginalEN", "canalorigen", "canalOriginine", "canalOrigun", "canalOrdens", "canalsOrigensen", "canalOrigens", "canalsOrigen", "canalOriginalEN", "canalOrigain", "canalsOrign", "canalOrdEN", "canalOriginalened", "canalsOriginalain"], "canalDestino": ["canaldestination", "canpalDestination", "canpaldestino", "canaldestri", "canalDestination", "canaldestini", "canaldestino", "canpalDestini", "canpalDestINO", "canpaldestINO", "canalCombini", "canalDestINO", "canalCombINO", "canalsDestino", "canaldestINO", "canpalDestino", "canalOrigino", "canalDestini", "canalsdestination", "canalCombino", "canalCombination", "canalsDestination", "canalDestri", "canpaldestination", "canalsdestri", "canalsDestINO", "canalsDestri", "canalOrigini", "canalsdestino", "canpaldestini", "canalsdestINO", "canalOrigination", "canalOrigINO"], "estado": ["Estar", " estados", "iestado", "Estaban", "iestada", "estano", "estaban", " estaban", "istano", "estados", " featados", " Estaid", " featada", "apestato", "istato", "Estado", " Estada", " featado", " estano", "gestada", "iestato", " Estado", "iestaban", "istaban", "gestato", " estato", "estada", "gestaban", "estato", " estaid", "apestada", " estada", "istado", "Estada", "estaid", " estar", "apestano", "istada", "istar", "estar", "gestado", " Estados", " feataid", "apestado"]}}
{"id1": "9449064", "id2": "7499186", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"readExp": ["readExt", "loadEXP", " readEx", "writeExt", "writeExpl", " readExt", "ReadExp", "writeexp", "Readexp", "writeEx", "loadEx", "readExpl", "loadExpl", "readEXP", "loadExt", "readexp", "loadexp", " readExpl", " readEXP", " readexp", "ReadExpl", "loadExp", "ReadEXP", "readEx"], "writeExp": ["writingExp", "readExt", "WriteExp", "writeCom", "WriteExt", "WriteExpl", " writeEx", "writeExt", " writeExt", "writeExpl", "writeexp", "WriteCom", "WriteEx", "writeEx", "writingCom", "readExpl", " writeexp", "Writeexp", "readexp", "writingexp", " writeExpl", "writingEx", "readEx", " writeCom"], "expFile": ["xpDir", " expPlace", "expLine", "ExpSourceFile", "expFiles", "ExpString", "EXPFile", " expFiles", "Expfile", "xpFiles", " experimentFiles", " experimentPlace", "expPlace", "expressLine", "EXPLine", "xpLine", " expDir", "expressSourceFile", "ExpLine", "expDir", "xpString", "ExpDir", "expressfile", " experimentFile", "expfile", "ExpFile", "EXPfile", " expLine", "EXPDir", " expSourceFile", "xpFile", "xpPlace", "expSourceFile", "ExpPlace", "expString", "EXPSourceFile", "xpfile", " experimentLine", "EXPString", "expressPlace", "expressDir", "expressFile", "EXPPlace"], "exp": ["imp", "expr", "rep", "example", "scope", "act", "pl", "form", "project", "serv", "expl", "nz", "model", "f", "inst", "zip", " expand", "spec", "str", "acc", "dj", "test", " expansion", "inf", "ng", "i", "pr", "push", "xp", "asm", "sc", "div", " experiment", "obj", "app", "express", "host", "vec", "prov", "query", "ef", " exam", "x", "jp", "lc", " expanded", "fe", "iz", "plus", "EXP", "p", "ext", "feat", "Exp"], "fi": ["ifa", "sf", "isi", "ffe", "wi", "sci", "fb", "Fi", "info", "si", "osi", "py", "ni", "flo", "fa", "lli", "ci", "ji", "ani", "abi", "i", "li", "ifi", "eni", "xi", "pi", "yi", "FI", "fc", "fy", "zi", "cf", "ini", "ii", "bi", "afi", "fe", "fp", "qi"], "oi": ["oa", "isi", "uci", "ki", "ori", "io", "ski", "shi", "si", "osi", "ahi", "ofi", "avi", "ni", "obi", "ogi", "flo", "asi", "lli", "ci", "oni", "ji", "ani", "abi", "i", "oci", "li", "di", "agi", "eni", "eu", "omi", "ti", "cci", "ilo", "odi", "obb", "ai", "ini", "ii", "ui", "bi", "eye", "oxy", "ois", "oid", "qi", "edi"], "jf": ["jb", "ujfp", "jfs", "jjcf", "pp", "uje", "ujfs", "djf", "pfr", "jarp", "Jfe", "Jfx", "Jf", "xf", "xcf", "JF", "appcf", "djfx", "je", "jtf", "djcf", "jpF", "jpcf", "jpf", "jjf", "Jcf", " jcf", "jjfx", "ujf", " jfs", "pb", "jfm", "appfx", "appf", " je", "jcf", "jF", " jfp", "xtf", "jfr", "pf", "jjfm", " jfr", " jfx", "ff", "jarfr", "jpfx", " jfm", "jarf", "jfx", "zf", " jtf", "zfp", "appfe", "Jb", "ffs", " jp", "jfp", "xfp", "ztf", " jF", "jp", " jb", "jfe", "ffp", "fe", "zcf", "jpb", "djfm", "jarb", " jfe"], "sp": ["osp", "imp", "page", "bsp", "js", "spe", "sf", "se", "vp", "scope", "mp", "cp", "ss", "html", "ps", "sv", "pl", "sci", "esp", "bp", "si", "sb", "fp", "py", "spec", "inst", "so", "str", "ch", "s", "pr", "wp", "Sp", "sc", "SP", "amp", "ap", "sm", "sup", "app", "service", "sl", "ctx", "sk", "cf", "gp", "sh", "op", "jp", "fe", "pp", "ep", "sw", "p", "tp", "space", "serv"], "e": ["pe", "ee", "ev", "se", "en", "ce", "event", "ie", "ec", "es", "ent", "ae", "el", "et", "v", "t", "w", "ctx", "Event", "x", "ef", "events", "fe", "exc", "ep", "ception", "ext"], "fo": ["ato", "wo", "FO", "oooo", "ico", "os", "io", "info", "ooo", "mo", "tto", "ph", "osa", " lo", "py", "f", "so", "flo", "fa", "o", "olo", "ko", "bo", "ao", "jo", "vo", "ho", "co", "zo", "foo", "po", "obj", "la", "lo", "fe", "obo", "yo"], "oo": ["wo", "oooo", "FO", "que", "oa", "va", "ico", "ollo", "os", "io", "loo", "ooo", "mo", "osa", "oe", "so", "flo", "o", "oto", "cro", "ox", "olo", "ko", "bo", "ao", "bean", "aco", "argo", "obe", "oh", "qa", "co", "foo", "oos", "po", "elo", "ilo", "oda", "la", "ou", "lo", "obo", "oid", "OO", "goo"], "ex": ["exit", "js", "res", "ct", "se", "null", "ax", "except", "act", "lex", "event", " exc", "Ex", "six", " Ex", "expl", "nex", "inc", "tx", "es", "fail", "su", "error", "cl", "ignore", "class", "Exception", "pex", "Exc", "sex", "ass", "con", "err", "obj", "ic", "aux", "re", "def", "ix", "used", "x", "EX", "tex", "rex", "exc", "ception", "ext", "com"]}}
{"id1": "18451704", "id2": "5998352", "code1": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"isValidPage": ["IsValidContent", "IsValidpage", "isInvalidBook", "isValidContent", "IsInvalidPage", "isLegalBook", "isAvailablepage", "isInvalidPage", "IsValidBook", "isLegalpage", "isInvalidContent", "isAvailableBook", "isInvalidpage", "IsInvalidBook", "isValidBook", "IsValidPage", "isLegalContent", "isAvailablePage", "isValidpage", "isLegalPage", "IsInvalidpage", "IsInvalidContent", "isAvailableContent"], "page": ["menu", "image", "html", "parent", "view", "pg", "profile", "data", "www", "chart", "class", "pages", "wiki", "cache", "file", "pe", "Page", "e", "message", "server", "resource", "version", "this", "display", "model", "result", "type", "settings", "xml", "plugin", "article", "config", "object", "change", "content", "book", "frame", "channel", "site", "route", "pb", "facebook", "instance", "comment", "section", "user", "account", "platform", "app", "admin", "next", "http", "manager", "block", "filter", "p", "button", "module", "pl", "project", "child", "title", "document", "f", "about", "home", "player", "client", "base", "language", "name", "current", "office", "request"], "panel": ["pan", "filter", "book", "widget", "frame", "menu", "button", "board", "wall", "server", "view", "circle", "info", "data", "pal", "journal", "part", "channel", "group", "conference", "area", "tool", "map", "coll", "bean", "settings", "row", "tab", "player", "el", "plugin", "chart", "plan", "paper", "bar", "table", "plane", "screen", "layout", "flower", "window", " Panel", "list", "Panel", "square", "label", "block", "browser"], "isValid": ["isLegal", " isOpen", "asInvalid", "asValid", "asActive", "hasValid", "isaActive", "isInvalid", "osvalid", "isOpen", "IsLegal", "osVal", "isaValid", "hasInvalid", " isOk", "asLegal", "osInvalid", "hasLegal", "svalid", "isActive", "hasvalid", "sInvalid", "sLegal", "asOpen", " isvalid", "sValid", "itValid", "isOk", "asvalid", "idLegal", " isVal", "asOk", "isvalid", "ISValid", "itInvalid", "IsInvalid", "isaInvalid", "ISvalid", "itvalid", "ISLegal", "idOk", "Isvalid", " isInvalid", " isLegal", "isaOpen", "osValid", "IsValid", "idvalid", "ISVal", "idValid", "ISInvalid", " isActive", "isVal"], "url": ["fl", "uri", "ssl", "resource", "image", "server", "large", "b", "connection", "blog", "channel", "follow", "f", "www", "URL", "bel", "source", "stream", "l", "album", "web", "base", "user", "control", "r", "object", "address", "string", "file", "sl", "layer", "path", "Url", "location", "plug", "http", "feed", "open", "ball", "browser"]}}
{"id1": "19912848", "id2": "12172485", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "1698200", "id2": "15351863", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginBitShares", "loginBandRay", "loginbitShares", "loginbitshare", " loginBitRay", "loginBandshare", " loginBitshare", " loginBitShares", "loginbitShare", "loginBitshare", "loginBandShares", "loginBandShare", "loginbitRay", "loginBitRay"], "params": ["ls", "param", "page", "lp", "ssl", "eters", "server", "details", "cmp", "par", "manager", "ps", "fps", "options", "parts", "ns", "parser", "reports", "phrase", "radius", "bis", "vs", "Parameters", "photos", "settings", "results", "posts", "api", "parse", "properties", "config", "license", "ip", "Par", "pi", "base", "eps", "cache", "mm", "ams", "ops", "ctx", "pm", "php", "rules", "words", "json", "pro", "utils", "services", "http", "p", "ds"], "httpclient": ["ttpserver", "webserver", "httpsclient", "httpsapi", " httphttp", "phpapi", "htmlclient", "ttpClient", "httpsconnection", "htmlresponse", "webClient", "httpClient", "webclient", " httpapi", "httpconnection", "ttphttp", "httpsresponse", "httphttp", " httpserver", "httpsClient", "phpclient", " httpClient", "phpconnection", "httpserver", "htmlClient", "httpapi", "phpClient", "webhttp", " httpconnection", "ttpclient", "htmlconnection"], "httppost": ["httpport", " httplost", " httplort", "httpoint", "httpperost", "httphort", "httphost", "httppeost", " httpoint", " httposter", "httport", " httppeood", "httpood", "httppsoint", " httppeost", "httppeoint", "httcppood", "httcpposter", " httppood", " httploster", "httcppost", " httppoint", " httpprost", "httphoster", "httpprost", " httpost", "httplpost", "httppsost", " httprost", "httploster", "httppsoster", "httplost", "httprost", " httpposter", " httppeoster", "httppoint", "httpposter", "httppood", "httcppoint", "httphpost", "httposter", "httpppost", "httpost", " httppeoint", "httppeoster", " httpport", "httplort", " httpppost", "httppeood", " httplpost", "httppsrost"], "formparams": ["formparam", "formedblock", "Formparams", "FORMams", "formedams", "Formsettings", "handargs", "fauthors", "feedparam", "formams", "feedsettings", "feedparams", "feedams", "handParameters", "handams", "headparam", "formargs", " formblock", "formauthors", "fams", "fparams", " formams", " formparam", "Formparam", "FORMparams", " formnames", " formsettings", "FORMblock", " formargs", "formnames", "formedparam", "FORMparam", "FormParameters", "headnames", " formauthors", "Formargs", "formedparams", "formsettings", "formParameters", "handparams", "Formams", "formedauthors", "Formnames", "headams", " formParameters", "fparam", "headparams", "formblock"], "entity": ["page", " entities", "url", "ities", "e", "resource", "server", "html", "body", "connection", "form", "Entity", "event", "data", "output", "ec", "entry", "document", "model", "result", "translation", "ent", "type", "el", "xml", "api", "article", "db", "et", "object", "email", "file", " Entity", "service", "environment", "json", "response", "query", "content", "collection", "person"], "httpresponse": ["phpresponse", "phpresp", "htmlclient", "htmlresponse", " httpresp", "hyperclient", "Httpresponse", "hyperserver", "httpresp", " httpserver", "phpserver", "htmlserver", "httpserver", "hyperresponse", "Httpserver", "Httpresp"], "it": ["ort", " It", "ins", "ct", "ait", "IT", "It", "st", "init", "ul", "iti", "si", "you", "not", "in", "ati", "entry", "iv", "set", "index", "itted", "sort", "and", "end", "the", "i", "ist", "mit", "l", "edit", "ip", "lit", "slice", "pit", "ind", "which", "ic", "start", "I", "op", "ite", "cont", "or", "iz", "quit", "its", "rit"], "escookie": ["Escaddy", " escaddy", "Escerve", "ascinel", "descenter", "estaddy", "escinel", " esccookie", "ascake", "escake", "ascaddy", "sccel", " enookie", "estenter", "scale", " encookie", "escenter", "cookie", "ecookie", "esccookie", "eccookie", "scake", "scookie", "Escenter", "ascale", "esccel", "desccel", "Escinel", "ascookie", "descake", "caddy", "escoding", "Esccel", "ascerve", "escaddy", "escale", "Escookie", "asccel", "estookie", "descaddy", "cerve", "ecoding", "ecaddy", "escerve", "descookie", "estcel", " escoding", "cinel", " enoding", "descale", " enaddy"]}}
{"id1": "2521141", "id2": "23672408", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["ame", "ize", "rm", "pe", "write", "image", " cp", "cp", "attach", "ge", "link", "sync", "zip", "archive", "paste", "clone", "clip", "type", "download", "ignore", "move", "cat", "Copy", "create", "source", "config", "open", "directory", "delete", "dump", "change", "load", "file", "share", "upload", "diff", "get", "transfer", "update", "opy", "cop"], "from_name": [" from_key", "source_memory", "fromMname", "source_name", " from_Name", "from_path", "fromMfile", "from_key", " from_names", "from_Name", "fromFfilename", "source_filename", "from__memory", "from_names", "from__filename", "fromFpath", "from__path", "fromFmemory", "fromMnames", "from_memory", "to_path", "fromFname", "source_path", "to_filename", "from_filename", "from__name"], "to_name": ["toampath", "toamfile", "to_Name", "to_path", "to_home", "toamname", " to_Name", " to_home", "toamhome", " to_path", "to_filename", "from_path", "from_filename"], "from_file": ["from___filename", "fromapplane", "source_resource", "from_resource", " from_filename", "fromCfilename", " from_folder", "from_files", " from_auto", "source_name", " from__name", "from__file", "from__resource", "from_auto", " from__file", "remote_function", "from___name", " from__filename", "from_lane", "fromCname", "fromappfile", " from_source", "from_folder", " from_files", "remote_file", " from__auto", "source_directory", "source_filename", "from_log", " from_directory", "from___file", "remote_log", "remote_lane", "source_files", "from___auto", "fromappfunction", "from_source", "fromCbrain", "from_function", "from__filename", "from__files", "fromCfile", "from__directory", "source_brain", "from__auto", "source_file", "from_brain", "from_directory", "from_filename", "fromapplog", "from__name"], "to_file": ["into_function", "tojname", "to_dir", "eto_name", "from_files", "into_use", "eto___remote", " to_filename", "tojuse", "to67file", "to64function", " to_queue", "to64file", "intojfunction", "tojfile", "to_class", "to64use", "to__dir", "to_queue", "from_model", "to_server", "to__name", "intojname", "source_filename", "eto_remote", "to_bar", "to___file", "to_use", "from_stream", "toJname", "to___name", "to_load", "source_files", "to_files", "to__file", "toJfile", "eto___file", "to67name", "toJbar", "to_model", " to_model", "eto___name", "intojfile", " to_class", "to__load", " to_files", "into_name", "eto_file", "to64name", "to_remote", "to___remote", "to_binary", "intojuse", "to_stream", "tojfunction", "source_file", "from_dir", "to_function", "from_bar", "toJstream", "to67dir", "from_binary", "into_file", "source_server", "to_filename", "from_load", "to67load"], "parent": ["ppa", "null", "term", "part", "search", "pa", "temp", "directory", "target", "div", "po", "cache", "string", "patch", "file", "ac", "root", "per", "owner", "page", "uri", "unit", "resource", "server", "connection", "Parent", "par", "remote", "port", "inc", "old", "folder", "test", "type", "tree", "point", "handler", "mother", "global", "path", "content", "url", "complete", "loc", "rule", "parents", "out", "api", "memory", "size", "user", "any", "id", "function", "location", "manager", "child", "session", "container", "home", "source", "client", "ip", "address", "name", "am", "full", "host", "pool", "current", "or", "author", "fat", "p"], "dir": ["url", "nav", "module", "build", "dr", "loc", "rel", "manager", "lock", "io", "die", "data", "md", "dec", "part", "folder", "group", "entry", "f", " directory", "dep", "in", "block", "exp", "d", "coll", "dev", "container", "out", "wd", "home", "cur", "ver", "dict", "cat", "class", "iter", "directory", "di", "keep", "db", "user", "tr", "r", "object", "id", "div", "cache", "ir", "file", "name", "dc", "def", "global", "root", "per", "dis", "path", "or", "Dir", "director", "doc"], "from": ["pe", "component", "From", "url", "fr", "one", "e", "server", "se", "without", "view", "connection", "form", "ce", "two", "io", "empty", "this", "link", "part", "range", "entry", "flo", "so", "cor", "ch", "feed", "bean", "conn", "source", "add", "api", "with", "parse", "client", "cm", "stream", "self", "base", "can", "address", "cache", "who", "low", "file", "con", "start", "name", "find", "by", "vol", "when", "left", "per", "ou", "get", "auto", "normal", "or", "ra", "context", "cf", "fe", "http", "cr"], "to": ["proxy", "too", "write", "one", "server", "dest", "connection", "two", "io", "fb", "store", "tto", "session", "sync", "socket", "not", "output", "via", "so", "flo", "about", "o", "storage", "su", "out", "type", "conn", "that", "see", "ver", "api", "top", "TO", "client", "size", "co", "with", "target", "pi", "db", "base", "will", "po", "token", "file", "by", "t", "per", "thro", "op", "until", "auto", "as", "or", "value", "To", "office", "fat", "http", "on"], "buffer": ["border", "wave", "buf", "bb", "page", "padding", "writer", "url", "default", "message", "resource", "server", "length", "b", "null", "data", "duration", "Buffer", "channel", "shape", "document", "batch", "read", "row", "texture", "total", "flush", "iter", "memory", "source", "reader", "header", "comment", "buff", "seed", "number", "queue", "position", "slice", "variable", "address", "character", "window", "binary", "reference", "layer", "uffer", "transfer", "feed", "block"], "bytes_read": ["bytes_load", "bytes_en", "byteslexcurrent", "bytesXcurrent", "bytes_reads", "bytes_current", "gets___allow", "bytes___pass", "gets_pass", "gets_read", "bytes___reads", "byte_read", "bytes___read", "bytesXbefore", "bytesXread", "gets___pass", "gets___reads", "byteslexread", "bytes_before", "byte_load", "bytes_write", "gets_allow", "bytesXload", "byte_before", "bytes___allow", "byteslexbefore", "gets___read", "bytes_allow", "gets_reads", "byte_current", "byteslexload", "bytes_pass", "bytes_found", " bytes_found", " bytes_write", " bytes_en"]}}
{"id1": "693636", "id2": "21016435", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createNewSpot", "createTempCart", "createTempcart", "createNewCart", "createTempShipping", "createCreateShipping", "createEmptyShipping", "createCreatecart", "createCreateCart", " createNewSpot", "createNewcart", "createNewShipping", "createEmptySpot", "createTempSpot", " createEmptyShipping", " createNewShipping", " createNewcart", "createCreateSpot", " createEmptycart", " createNewCart", " createEmptySpot", "createEmptycart"], "SHOPPING_ID": ["SHOPPINGPOIDS", "SHOPPINGPOID", "SHOPPINGINGID", "SHOPPIP_Id", "SHOPPYING_IDS", "SHOPPTING_id", "SHOPPYING_ID", "SHOPPYING_Id", "SHOPPYING_IDs", "SHOPPIP_IDs", "SHOPPIP_ID", "SHOPPIPIDid", "SHOPPIPIDIDs", "SHOPPING_id", "SHOPPINGINGid", "SHOPPINGIDID", "SHOPPINGPOId", "SHOPPINGINGId", "SHOPPIP_id", "SHOPPING_IDS", "SHOPPIP_IDS", "SHOPPTING_ID", "SHOPPINGIDid", "SHOPPIPIDID", "SHOPPIPIDIDS", "SHOPPINGPOIDs", "SHOPPINGIDIDs", "SHOPPINGIDIDS", "SHOPPTING_Id", "SHOPPINGIDId", "SHOPPING_Id", "SHOPPIPIDId", "SHOPPING_IDs"], "con": ["conv", "cons", "ex", "un", "log", "cn", "col", "wan", "uc", "conf", "connection", "loc", "en", "act", "rc", "CON", "Con", "session", "inc", "reg", "bc", "ec", "cond", "connect", "fa", "mc", "ran", "coll", "commit", "ci", "cas", "cur", "row", "conn", "Conn", "cc", "ctrl", "win", "cm", "client", "co", "db", "can", "ann", "cache", "ac", "pc", "c", "exec", "fc", "fac", "ctx", "cf", "pool", "ca", "close", "cr", "pen", "com"], "insert_cart": ["insert_cycle", " insert_pod", " insert_conn", "install_container", "insertencenter", "insert_cat", "insertencycle", "insert_ox", "exec_cart", " insert_ox", "insert_payment", "install_part", " insert_cat", "insertencart", "insert_pod", "insert_part", "insert_container", "exec_payment", " insert_center", "insertencat", "insert_conn", "insert_center", " insert_cycle", "exec_Cart", "install_cart", "insert_Cart"]}}
{"id1": "160739", "id2": "3631989", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": ["createOutputSteam", " createOutputSteam", " createInputSteam", " createIOSteam", " createByteFile", " createInputFile", "createOutputFile", "createInputReader", " createByteSteam", " createInputReader", " createByteStream", " createInputStream", "createInputFile", "createInputStream", " createIOFile", " createIOReader", " createByteReader", " createOutputFile", " createIOStream", "createOutputReader", " createOutputReader", "createInputSteam"], "inFile": ["incFiles", "infile", "insFile", "insfile", "inputFile", "inStream", "outFiles", "insFiles", "insStream", "incfile", "sourceFile", "outStream", "outfile", "sourcefile", "inputStream", "inputfile", "incStream", "incFile", "sourceFiles", "inputFiles", "inFiles", "sourceStream"], "outFile": [" outfile", "infile", "outTime", "workTime", "inputFile", "inTime", "workingStream", "workFile", "outDir", "targetStream", "workfile", "workingDirectory", "workingfile", "outStream", "outfile", "inDir", " outStream", "targetfile", "outDirectory", "targetFile", "workDir", "inputDir", "workingFile", "targetDirectory", "inputTime", "inputfile", " outDirectory"], "k_blockSize": ["k_byteCode", "k_byteLength", "k_lockCode", "k_lockLen", "k_bitCount", "k_BlockLength", "k_lockLength", "k_blockCode", "k_blockLen", "k_BlockSize", "k_BlockCount", "k_lineCount", "k_lockCount", "k_lineInfo", "k_lockSize", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_blockInfo", "k_lineSize", "k_blocksLength", "k_BlockCode", "k_byteLen", "k_byteSize", "k_blockCount", "k_blockLength", "k_byteInfo", "k_bitInfo", "k_byteCount", "k_bitSize"], "byteCount": ["ByteSum", " bytecount", "characterLength", " byteSize", "blockSize", " byteLen", "Bytecount", "characterLen", "ByteSize", "ByteLen", "flushcount", "flushCount", "byteSum", " byteSum", "ByteCount", "blockSum", "flushSize", "byteLen", "blockCount", "characterCount", "ByteLength", "flushLength", "byteLength", " byteLength", "blockLength", "bytecount", "characterSize", "byteSize"], "buf": ["fd", "border", "font", "cap", "cv", "uf", "append", "background", "b", "cmd", "loc", "rc", "fb", "data", "bh", "Buffer", "result", "bag", "rb", "batch", "feed", "bytes", "Buff", "cb", "cas", "alloc", "bf", "flush", "src", "config", "tmp", "buff", "len", "base", "queue", "la", "ucc", "vec", "brace", "ctx", "buffer", "exc", "seq", "feat", "img"], "ofp": ["Ofc", "afp", "OFl", "ofc", "fortp", "ofl", "forc", "afc", "fort", "ofnp", "afnp", "OFnp", "Oftp", "OFt", "Ofnp", "afl", "OFtp", "OFp", "OFc", "oft", "Ofl", "forp", "Ofp", "oftp", "Oft"], "zos": ["rons", "ogl", "kos", "core", "zh", "tz", "osi", "iframe", "owicz", "zag", "zers", "rez", "outs", "los", "gz", "zer", "bitcoin", "dylib", "webkit", "zon", "utils", "bs", "ros", "js", "z", "fits", "iffs", "obs", "ossus", "enos", "ozo", "zona", "zip", "bos", "zes", "oses", "zik", "lol", "bes", "zar", "zb", "ZI", "zx", "oda", "zy", "ops", "zi", "budget", "inos", "css", "ls", "zyk", "modules", "zo", "zen", "ses", "nox", "zig", "cfg", "ZA", "os", "jas", "uz", "zn", "nz", "cos", "robe", "liquid", "lins", "zin", "ws", "oS", "abi", "zl", "hz", "za", "forge", "packs", "obb", "soon"], "osw": ["ossnow", "isy", "osy", "esfw", "issw", "lsx", "eshell", "osws", "osow", "osswd", "oswd", "ishell", "lswo", " osfw", "iswd", "isw", "osshell", "osx", "lsws", "osnow", "osfw", "ossw", "isnow", "esw", " osww", "esd", "bx", "ossfw", "bws", "osww", "bwo", "ossd", "ossy", "oswo", "esow", " osow", "oshell", "isd", "bsws", "ossow", "osssw", "essw", "esww", "eswd", "esy", "osd", "bsx", "bsw", "bswo", "ossww", "esnow", "lsw"], "bw": ["bbz", "lbw", " bwa", "lx", "ebW", "fr", "fbW", "bz", "fsw", "lbz", "bwe", "ebwd", " bws", "bW", "ebw", "fbwe", "Bws", "bbwa", "Bw", "lbwa", "bew", "abw", "bbew", " baw", "abW", "Bwa", "bbwu", "lbsw", "ow", "fwa", "bwh", "fbw", "owa", " bwh", "abwe", "ebwe", "bx", "lbx", "bws", "fbwd", "Bew", "fx", " bew", "fw", "lbwh", "bwu", "owu", "fwh", "baw", "lwa", "bbws", "abwd", "bwa", "bbwh", "lbws", " bwu", "lw", "bwd", "bsw", "oaw", "lbr", "bbw", "bbaw", " bz", "lsw"], "zot": ["Zor", "zor", "jot", "Ziot", "zori", " zor", "azita", "azott", "zeros", "aziot", "ziot", "Zit", "jos", "jit", "zerott", "jori", "azor", "zerita", " zori", "zita", "zerori", "zott", "zerit", "Zita", "zerot", "azit", "Zot", "Zott", " ziot", "azot"], "ifp": ["Iff", "ifb", " ifi", "ipb", "IFb", "Ifi", " ifl", "ipp", "Ifc", " ifb", "ifl", "ipc", "ipl", "ifc", "ifi", "iff", "IFc", "IFl", " ifc", " iff", "IFi", "Ifp", "IFp", "IFf"], "zis": ["jits", "zisi", "jisi", "zIS", "zib", "xits", "zipis", "xais", "xit", " zits", "ziss", "xis", "zipits", "zenis", "zenib", "zeip", "zipip", "zipiss", "xisi", "zip", "Ziss", "zeits", "Zis", "jit", "xIS", "zeis", " zisi", "zits", "zenIS", "Zip", " zais", " zIS", "zais", "Zits", "zenais", " zib", "jis", "zeiss", "xib"], "isr": ["IScr", "irrb", "irrc", "irr", "ISr", "rispr", " issr", "ISsr", "risr", "ISrs", "risrc", "issrs", " isrs", "iscr", "ISrb", "risrb", "isrs", "irpr", " iscr", "ISrc", "isrb", "ISpr", "isssr", "isscr", "ispr", "issr", "isrc"], "br": ["kr", "obl", "bsp", "bro", "fr", "arr", "shr", "b", "body", "mr", "rs", "yr", "bh", "bp", "bc", "obi", "str", "HR", "cro", "rb", "ch", " BR", " Br", "BR", "rib", "lr", "ber", "bar", "tr", "r", "ctr", "div", "err", "ocr", " fr", " dr", "sr", "ibl", "gr", "ob", "sp", "hr", "bl", "Br", "ibr", "img", "browser"], "zit": ["jits", "zipita", "zIT", "zeith", "zenith", " zip", "xit", "zenitter", " zits", "zipits", "zitter", "jith", "jite", "xith", "jIT", "zipip", "zic", "zip", "xic", "zeits", " zi", "zipit", " zith", "jit", "zite", "jic", "zipith", "zenit", "zith", "ji", "zits", " zic", "zipite", "zeit", "zita", "zenits", "xi", "jita", " zite", "zipitter", "jip", "zi", "zeIT", "zipIT", "zeitter", "zeita"]}}
{"id1": "7458833", "id2": "21656668", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFiletoOutputfile", " copyParseFileToMapClass", " copyParseFileTocodefile", " copyParseFileToOutputFile", " copyParseFileToCodeClass", " copyParseFiletoCodeFile", " copyParseFileToCodeFiles", " copyParseFiletoCodefile", " copyParseFileToOutputfile", " copyParseFileToCodefile", " copyParseFileTocodeFiles", " copyParseFiletoCodeFiles", " copyParseFileToMapFiles", " copyParseFiletoOutputFiles", " copyParseFileTocodeFile", " copyParseFileToOutputClass", " copyParseFiletoOutputFile", " copyParseFileToMapFile", " copyParseFiletoOutputClass", " copyParseFiletoCodeClass", " copyParseFileToOutputFiles", " copyParseFileTocodeClass", " copyParseFileToMapfile"], "in": ["ls", "m", "ins", "image", "In", "n", "init", "io", "inc", "socket", "gin", "f", "impl", "oin", "input", "din", "IN", "lin", "inn", "read", "cin", "i", "is", "win", "rin", "reader", "kin", "pull", "inside", "nin", "stream", "login", "inner", "min", "r", "id", "bin", "con", "err", "ic", "up", "pin", "get", "ini", "as", "again"], "out": ["ex", "log", "writer", "one", "image", "server", "plain", "parent", "n", "io", "outer", "this", "sync", "inc", "socket", "output", "exp", "o", "Out", "conn", "i", "source", "client", "work", "inner", "outs", "user", "cache", "exec", "bin", "err", "file", "other", "up", "net", "w", "OUT", "as", "ext", "again", "post"], "buffer": ["wave", "buf", "available", "uf", "padding", "pad", "array", "server", "count", "null", "event", "fb", "data", "duration", "Buffer", "raw", "sequence", "limit", "shape", "channel", "document", "result", "input", "batch", "read", "total", "source", "iter", "buff", "capacity", "number", "base", "queue", "position", "slice", "cache", "address", "string", "binary", "reference", "pause", "layer", "uffer", "feed", "request"], "length": ["distance", "bb", "partial", "url", "count", "style", "view", "offset", "volume", "lock", "weight", "before", "duration", "part", "sequence", "limit", "range", "shape", "index", "end", "type", "row", "code", "ength", "time", "total", "pull", "size", "width", "l", "len", "Length", "number", "point", "slice", "position", "id", "address", "match", "string", "load", "character", "repeat", "start", "ob", "full", "path", "value", "level", "line", "feed", "block"]}}
{"id1": "3584508", "id2": "15797402", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadresource", " copyresource", " downloadUrl", "copyFile", " copyUrl", "copyresource", "copyUrl", "transferUrl", " downloadResource", " copyFile", "transferResource", "transferresource", " downloadFile", "transferFile"], "url": ["ls", "page", "uri", "ssl", "resource", "image", "server", "connection", "loc", "remote", "data", "f", "www", "URL", "ref", "bel", "download", "xml", "source", "src", "stream", "l", "lr", "web", "base", "r", "object", "id", "address", "string", "ource", "file", "loader", "re", "name", "sl", "host", "path", "Url", "http", "feed"], "input": ["request", "ssl", "resource", "image", "connection", "form", "act", "data", "this", "session", "inc", "socket", "in", "f", "audio", "index", "error", "reader", "accept", "out", "inf", "temp", "instance", "i", "source", "xml", "api", "config", "pull", "element", "qa", "progress", "stream", "l", "ack", "parse", "inner", "base", "client", "Input", "cache", "address", "exec", "bin", "file", "load", "upload", "binary", "get", "context", "current", "plus", "buffer", "but", "active", "http", "feed", "bb", "open"], "output": ["log", "writer", "console", "default", "unit", "resource", "write", "image", "flow", "copy", "connection", "outer", "data", "socket", "external", "application", "document", "result", "out", "source", "Output", "config", "network", "stream", "target", "web", "queue", "control", "object", "cache", "address", "file", "other", "binary", "ou", "layer", "environment", "response", "operation", "current", "put", "buffer", "production"], "b": ["buf", "k", "m", "p", "e", "n", "fb", "bit", "lb", "bc", "sb", "f", "bs", "pb", "d", "rb", "batch", "cb", "mb", "h", "bf", "B", "i", "a", "l", "db", "base", "bar", "r", "br", "v", "bin", "c", "file", "be", "ob", "binary", "bi", "x", "buffer", "ab", "abs", "nb", "line", "bb"]}}
{"id1": "16798376", "id2": "7948308", "code1": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 0, "substitutes": {"run": ["running", "server", "call", "debug", "build", "system", "Run", "init", "test", "process", "stop", "create", "config", "client", "work", "worker", "command", " Run", "exec", "start", "up", "runner", "update", "execute", " running"], "ftp": ["ntpa", "ffb", "rtping", "gtP", "rttp", " ftfp", "gtp", "aftp", "bftp", "ftsapi", "afttp", "rtf", "ctb", "ftping", "bfp", "FTapi", "rtpa", " ftP", " ftf", " ftq", "helP", "ftb", " ftw", "ftps", "FTp", "hardc", "fff", "helw", "gtpi", " ftop", " ftpr", "ftspr", "gtw", "bfps", "bfe", "aftfp", "ftop", "aftping", "utp", "ftapi", "ffc", "rtq", "hardp", "ftpa", "hardb", "ftfp", "ftsp", "ftP", "ftper", "utpi", "ftpr", "aftps", "aftf", "gtper", "FTfp", " fttp", "FTpr", "ftpi", "hardf", "aftpa", "fte", "ftsfp", "ctc", " ftapi", "utpa", "gtfp", "gttp", "ffp", " ftpa", "rtp", "heltp", "aftq", "rtps", "ntper", "ftc", "ctp", " ftps", "ftf", "ctf", "gtop", " ftping", "utper", "ftw", "ntp", "fttp", "aftop", "gtpa", "help", "gtps", "ntpi", "ftq", "gte", "afte"]}}
{"id1": "11716816", "id2": "3187685", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"updateFile": ["updateBody", "copyBody", "upFolder", "upDirectory", "importBody", "copyFolder", "copyFile", "upFile", "importFolder", "upBody", "updateFolder", "updateDirectory", "copyDirectory", "importFile", "importDirectory"], "file": ["pe", "log", "FILE", "url", "resource", "e", "image", "parent", "b", "connection", "lock", "io", "info", "data", "single", "this", "socket", "part", "model", "f", "zip", "input", "type", "class", "source", "future", "dir", "filename", "l", "db", "files", "base", "queue", "object", "local", "cache", "load", "handler", "name", "up", "full", "File", "get", "path", "line", "current", "content", "http", "fp"], "IOException": ["Timeoutception", "DownloadProblem", "Downloadception", "TimeoutException", "DownloadException", "TimeoutProblem", "IOception", " IOception", " IOProblem", "IOProblem"], "destFile": ["flatFile", "destFull", "origTable", "destroyDir", "srcPath", " destFolder", "destFiles", "flatDir", "destFolder", "sourceFolder", "destTable", "origFile", " destinationFiles", "srcFiles", "destroyTable", " destinationFile", "destPath", " destFull", "origfile", "DestFile", "destDir", "flatFiles", "sourceFile", "Destfile", "DestPath", " destfile", "origDir", "DestDir", "DestFull", "destroyfile", " destTable", " destFiles", "sourceFiles", "srcFolder", "destfile", "srcFile", " destDir", "DestFiles", " destinationFull", "DestFolder", " destPath", "flatfile", "destroyFile", " destinationDir", "sourceDir"], "in": ["ins", "image", "In", "b", "ax", "connection", "lock", "init", "io", "this", "sync", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "cl", "s", "pass", "conn", "cin", "el", "i", "source", "win", "pull", "reader", "with", "client", "inside", "a", "l", "nin", "login", "work", "inner", "min", "r", "id", "ac", "bin", "con", "c", "err", "re", "up", "pin", "cf", "ini", "as", "again", "on", "p", "isin"], "out": ["at", "to", "ex", "writer", "url", "resource", "call", "In", "b", "n", "connection", "io", "off", "outer", "this", "sync", "outside", "inc", "socket", "channel", "output", "no", "cookie", "exp", "o", "password", "Out", "timeout", "conn", "pass", "i", "client", "nin", "co", "of", "login", "point", "outs", "user", "exec", "bin", "err", "obj", "c", "name", "option", "extra", "up", "net", "w", "OUT", "ou", "again", "lib", "ext"]}}
{"id1": "10728243", "id2": "20660203", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramprint5", "screamble41", "screamble5", "scrambe41", "scramble41", "scramprint411", "screamprint123", "screamprint411", "screamprint41", "screamble123", "scramcy123", "screamprint5", "scramcy411", "scrambe123", "scramprint41", "scramble5", "scramprint123", "scramcy41", "screamble411", "scrambe5", "scramble123", "scrambe411", "scramcy5"], "password": ["crypt", "prefix", "attribute", "padding", "pad", "auth", "username", "project", "sword", "phrase", "channel", "hash", "sudo", "input", "sum", "key", "wd", "wallet", "pass", "config", "filename", "number", "user", "mac", "address", "token", "account", "string", "email", "security", "name", "words", "path", "word", "Password", "dh", "secret", "PASS"], "seed": ["crypt", "prefix", "text", "padding", "pad", "length", "volume", "offset", "username", "random", "phrase", "alias", "zip", "mode", "hash", "sudo", "sum", "shadow", "template", "key", "pass", "source", "driver", "size", "Salt", "pair", "slice", "id", "address", "token", "string", "machine", "name", "device", "pattern", "prime", "state", "finger", "eed", "secret"], "md": ["ds", "mad", "m", "rm", "doc", "hd", " MD", "Cmd", " Md", "nd", "mp", "sha", "cmd", "mo", "mid", "dig", "dd", "part", "km", "ht", "gd", "mode", "mc", "mag", "d", "vd", "od", "meta", "ms", "hm", "nm", "mb", "amd", "mg", "dm", "bd", "wd", "metadata", "bm", "cm", "pd", "MD", "pkg", "di", "mn", "mi", "addr", "ad", "mac", "ind", "mand", "po", "mm", "sm", "ma", "dc", "mem", "am", "ld", "grad", "kg", "pm", "mt", "cd", "diff", "om", "dh", "df"], "passwordHashStage1": ["passwordHashStep2", "passwordHashStage4", "passwordSumStage0", "passwordSumStage3", "passwordHashStep1", "passwordHashPhase2", "passwordHashPhase1", "passwordHashPhaseOne", "passwordSumPhase4", "passwordHashstage4", "passwordSumStage1", "passwordHashStage3", "passwordHashstage1", "passwordSumStage4", "passwordHashstage0", "passwordHashstage3", "passwordSumPhase3", "passwordSumPhase0", "passwordHashstageOne", "passwordHashPhase0", "passwordHashstage2", "passwordHashPhase3", "passwordSumPhase2", "passwordSumPhase1", "passwordSumStage2", "passwordSumPhaseOne", "passwordHashStage0", "passwordSumStageOne", "passwordHashPhase4", "passwordHashStageOne", "passwordHashStep3"], "passwordHashStage2": ["passwordHashStep2", "passwordHashStage4", "passwordHashStep1", "passwordHashPhase2", "passwordHashPhase1", "passwordSumPhaseTwo", "passwordBlockstage4", "passwordHashstage4", "passwordSumStage1", "passwordHashstage1", "passwordHashPhaseTwo", "passwordHashstageTwo", "passwordSumPhase02", "passwordBlockstage2", "passwordBlockstage1", "passwordBlockStage4", "passwordSumStageTwo", "passwordHashstage8", "passwordHashStage8", "passwordBlockstage8", "passwordHashstage2", "passwordHashStep8", "passwordHashPhase8", "passwordHashStageTwo", "passwordSumPhase2", "passwordBlockStage8", "passwordSumPhase1", "passwordSumStage2", "passwordBlockStage2", "passwordSumStage02", "passwordHashstage02", "passwordHashPhase02", "passwordBlockStage1", "passwordHashPhase4", "passwordHashStage02", "passwordHashStep4"], "toBeXord": ["toBEXor", "toBEXords", "toBeCrossORD", "toBeXords", "toBeWorkorder", "tobeYorder", "toBeWorkord", "toBeYors", "toBeYorder", "tobeXorder", "tobeCrossors", "tobeCrossord", "toBeZors", "tobeXord", "toBeXORD", "toBeYord", "toBeWorkORD", "toBEYORD", "toBeZords", "toBeXors", "toBeZorder", "tobeCrossor", "toBeCrossors", "toBEYord", "toBeWorkords", "toBeWorkor", "tobeCrossords", "toBEXORD", "toBeYORD", "toBEYords", "toBeCrossor", "tobeXords", "toBeYords", "toBeZORD", "toBeCrossords", "toBeCrossord", "toBEXord", "toBeYor", "toBeZor", "toBeZord", "toBeXor", "tobeXor", "tobeYors", "tobeXors", "tobeYord", "toBEYor", "toBeWorkors", "toBeXorder", "tobeYor"], "numToXor": ["numToXOr", "numToCrossOr", "numToxorer", "num2Absor", "numToXors", "numToAbsOr", "num2Xorer", "numtoxOR", "num2Xor", "numtoXor", "numToWorkOR", "numtoxorer", "numToAbsorer", "numToxor", "num2AbsOr", "numToWorkor", "numToAbsOR", "numToXOR", "numToxors", "numToCrossorer", "numToAbsor", "numtoxors", "numtoXOR", "num2XOR", "numToAnyOR", "numToAnyorer", "numtoXors", "numToWorkorer", "num2AbsOR", "numToCrossor", "numtoxor", "numtoXorer", "numToCrossOR", "numToCrossors", "num2XOr", "numToAnyOr", "numToWorkors", "numToAnyor", "numToXorer", "num2Absorer", "numToxOR"], "i": ["k", "m", "p", "u", "uri", "z", "e", "j", "b", "n", "off", "info", "io", "si", "part", "in", "f", "it", "o", "index", "d", "ci", "key", "oi", "h", "abi", "multi", "y", "li", "di", "l", "a", "ip", "pi", "xi", "hi", "slice", "r", "id", "ti", "v", "gi", "c", "t", "ix", "I", "ai", "chi", "ii", "qi", "x", "ui", "bi", "ri"]}}
{"id1": "62362", "id2": "5707205", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "3024992", "id2": "13657103", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_writers", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_std_", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter_stds", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_writer_", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2null_", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_nullin"], "baout": ["baouter", "bonash", " baOut", "BAout", "BAOut", "BaOUT", "Baout", "baouts", " baouts", "aeouter", "BAio", "Bain", "aeout", "baio", "bonout", "Baouter", "bain", "bonin", "Baash", "baOut", " bain", "BAash", "BAouter", "BAOUT", "baOUT", "aeOUT", "bonio", "baash", "Baio", "Baouts", "BAouts", "BaOut", "BAin", "aeOut"], "out": ["array", "flow", "write", "copy", "null", "able", "io", "outer", "in", "output", "Writer", "Out", "test", "s", "class", "Output", "reader", "er", "outs", "r", "file", "err", "OUT", "buffer", "line"], "writer": ["ee", "unit", "write", "copy", "null", "letter", "io", "outer", "data", "writing", "writ", "output", "in", "entry", "her", "Writer", "wer", "player", "temp", "rw", "class", "builder", "driver", "reader", "source", "riter", "work", "er", "worker", "r", "wa", "file", "w", "writers", "pointer", "x", "buffer", "RW"]}}
{"id1": "23273706", "id2": "20851065", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getProjectTreeData": ["getProjectPageMeta", "getProjectPageDATA", "getProjecttreeMeta", "getProjectTreeInfo", "getProjecttreeInfo", "getprojecttreeMeta", "getProjectPageData", "getProjectDocumentDATA", "getprojectTreeDATA", "getProjectDocumentMeta", "getProjectDocumentInfo", "getProjectTreeMeta", "getProjecttreeData", "getProjectDocumentData", "getProjecttreeDATA", "getprojecttreeDATA", "getprojectTreeInfo", "getProjectTreeDATA", "getprojecttreeInfo", "getprojectTreeData", "getProjectPageInfo", "getprojectTreeMeta", "getprojecttreeData"], "treeData": [" treeDec", " treeDat", "bodyData", "reeArray", "bodyDat", " treeInfo", "treeText", "reeInfo", "treeInfo", "TreeList", "bodyString", "monkeyDat", "bodyList", "contentDat", "treeString", "TreeData", " treeString", "reeData", "contentInfo", "reeText", "storyDec", "storyDat", "reeList", "reeString", " treeList", "treeList", "reeDat", "storyArray", "monkeyDec", "TreeString", "TreeArray", "monkeyArray", "monkeyData", "storyData", " treeText", "contentData", "treeDec", " treeArray", "treeArray", "TreeInfo", "contentText", "treeDat"], "filename": ["fd", "SourceFile", "prefix", "fn", "ppa", "jpg", "url", "uri", "FILE", "txt", "sheet", "data", "username", "kj", "journal", "title", "folder", "figure", "password", "nil", "kn", "framework", "xml", "dll", "metadata", "directory", "tmp", "fil", "files", "wav", "Filename", "kl", "string", "file", "upload", "name", "dylib", "location", "path", "ername", "whatever", "fp", "database"], "urlString": ["urlStr", "URLURL", " urlstring", "urlUrl", "locationUrl", " urlUrl", "addressURL", "URLStr", "URLString", "locationStr", "urlstring", "locationString", "addressStr", "addressString", " urlURL", "locationstring", "addressstring", "URLstring", "URLUrl", " urlStr", "urlURL"], "urldata": ["urlfata", "urLDdata", "urlfat", "urLDta", " urlddata", "urlddata", "URldata", "urlleddata", "urledATA", "urlledta", "urLDat", "urldat", "urleddata", "URlfata", "URldat", "urledta", " urLDdata", "urlfATA", "urlledata", " urLDta", "urldta", "URlddata", "URlfdata", "urlldata", "urlledATA", "urllATA", "urlfdata", " urldta", " urLDATA", "urLData", "urllat", " urldATA", "urldATA", "urledata", " urLData", "URldATA", "urllata", "urLDATA", "URlfATA", "URlfat"], "factory": ["fFactory", "cflier", "lactory", "conflier", "confiller", "filler", "luild", "lictionary", "confFactory", " filler", " flier", "cFactory", "pFactory", "cactory", "pault", "cfFactory", " fuild", "pactory", "cault", "confactory", "piller", "fuild", "liller", " fault", " fFactory", "ciller", "fault", "cfactory", "flier", "ufictionary", " fictionary", "ufuild", "ufactory", "cfiller", "fictionary", "ufiller"], "parser": ["writer", "lp", "uri", "se", "parent", "b", "manager", "ph", "monkey", "jack", "s", "xml", "instance", "builder", "plugin", "parse", "reader", "library", "driver", "raf", "api", "l", "er", "pdf", "ger", "util", "r", "string", "handler", "loader", "Parser", "up", "t", "fruit", "root", "auto", "json", "utils", "http", "p", "arser"], "u": ["ur", "nu", "uf", "url", "uri", "lu", "b", "ru", "uu", "ul", "io", "universal", "uv", "o", "su", "us", "d", "iu", "s", "uni", "cu", "l", "eu", " ur", "util", "c", "tu", "yu", "U", "ou", "hu", "plug", "ui", "http", "p"], "is": ["p", "gets", "uri", "isl", "lis", "obs", "io", "info", "mis", "ori", "init", "iso", "ie", "in", "it", "es", "bis", "IS", "us", "fs", "s", "iris", "ios", "api", "ar", "ip", "pi", "are", "ib", "iss", "ir", "ais", "ris", "has", "Is", "ob", "ops", "ai", "as", "ui", "or", "isa", "abs", "http", "serv", "ri", "isu", "its"], "os": ["ros", "oa", "dos", "gets", "fits", "obs", "io", "ps", "sys", "osi", "iso", "oss", "aos", "cos", "ose", "pos", "es", "bs", "so", "bis", "o", "bos", "us", "oses", "ms", "fs", "s", "ens", "ios", "Os", "oos", "oes", "ils", "los", "ob", "ops", "ol", "as", "or", "opens", "http", "OS"], "iBufSize": ["iBuffLength", "iBytebufLen", "iBlfLength", "iBlfSize", "iByteufSize", "iBytebufLength", "iByteufsize", "iBufSt", "iLufLength", "iLufSt", "iBufferLength", "iByteufLen", "iByteufLength", "iBytebufSize", "iBuffsize", "iBbufsize", "iBytebufsize", "iLlfSize", "iBuffersize", "iLlfsize", "iBufferSt", "iLlfSt", "iBbufLength", "iBuffSize", "iBbufLen", "iBlfsize", "iBlfSt", "iBbufSize", "iBlfLen", "iBufLen", "iBuffLen", "iBuffSt", "iLufSize", "iLlfLength", "iBufLength", "iLufsize", "iBufferSize", "iBufsize"], "inBuf": ["inBunk", "inBlunk", "inDuff", "inDbuf", "inBaf", "inDaf", "outBbuf", "inBuff", "outBuffbuf", "inBlub", "outBuffub", "inFuff", "inBuffump", "inBump", " inBump", " inBuff", " inFbuf", "outBub", "inFbuf", "inbuf", "inCuff", "outBuf", "outBuffump", "inbub", "inBuffuf", "inPluf", " inCump", " inFaf", " inCunk", " inCbuf", " inFuff", " inCuf", "inbump", "inFuf", " inBbuf", "inBlbuf", "inCaf", "inBuffbuf", "inBbuf", "inBluf", " inFuf", "inBuffub", "inFaf", "inPlump", "inCuf", "outBump", " inBunk", "outBuffuf", "inBub", "inCump", "inDuf", "inBlump", "inPlunk", "inPlbuf", "inCbuf", "inbbuf", "inCunk", " inBaf"], "iNumRead": ["iNumberWritten", "qiNumBuild", "qiValread", "iChanRead", "iValBuild", "iNumread", "pNumWritten", "pNumWrite", "qiValBuild", "inumWritten", "iChanread", "iNumberREAD", "iChanBuild", "iValREAD", " iNumWrite", "iNumberread", " iFatWrite", "iChanREAD", "iValRead", "qiNumread", "qiValREAD", " iFatWritten", "iNumWrite", "inumread", "iNumberWrite", "iLenRead", "inumWrite", "pNumberread", "iNumREAD", "iFatRead", "iNumberRead", "iValread", " iNumWritten", "iNumBuild", "pNumRead", "inumRead", "qiValRead", "iFatWritten", "qiNumREAD", "pNumberWrite", "iNumWritten", "pNumberRead", "iFatWrite", "pNumread", "iLenWritten", " iFatRead", "iLenWrite", "qiNumRead", "iNumberBuild", "pNumberWritten"], "f": ["fd", "m", "fn", "uf", "fr", "e", "j", "sf", "b", "g", "n", "fi", "io", "fa", "o", "d", "feed", "h", "fs", "s", "rf", "l", "ff", "r", "v", "handler", "c", "file", "fc", "t", "full", "F", "fe", "fp", "p", "df"], "inputstream": ["Inputsw", "outputStream", "contentStream", "outputstream", "inputsw", " inputchannel", "contentsystem", "contentstream", "inputchannel", "Inputchannel", "Inputstream", "inputStream", "contentsw", " inputStream", "inputsystem", " inputsw", " inputsystem", "Inputsystem", "InputStream", "outputchannel"], "document": ["m", "page", "doc", "e", "html", "null", "parent", "n", "DOM", "info", "data", "project", "output", "d", "container", "docs", " documents", "xml", "source", "Document", "record", "directory", "media", "l", "tree", "Documents", "node", "object", " documentation", "language", "file", "window", "list", "t", "ocument", "context", "response", "content", "office", "dom", "collection", "director", "p"], "nodelist": ["nozesh", "Nodesh", "anodedelist", "nodsette", "nozename", "nondestate", "nodedette", "nodata", "nonedels", "nodedeme", "nodedemark", "nODlist", "nodedeline", "anodedata", " nodesette", "nonedelist", "nodette", "nodselist", "nonedename", "nondata", "nODestyle", "nodedata", "nozette", "Nodestyle", "nodeestate", "nodeelist", "nodesette", "snodseline", "nODette", "nodedelist", "Nodelist", "snodelist", "nodename", " nodesels", " nodename", "nodeme", "nodestyle", "nondeme", "snodlist", "nodeline", "nodeselist", "NODemark", "nozemark", "snodette", "anodedestate", "nodeeme", "anodedeme", "nonedette", "nODeline", "nodedestyle", "nODesh", "nodedestate", "NODestyle", "NODelist", "nODemark", "snodsette", "nondelist", "nozels", "anodeme", "nodemark", "anodestate", "nodeata", "nodedlist", "Nodemark", "anodelist", "nodlist", " nodels", "nozestyle", "nozelist", "nODelist", "NODesh", " nodeselist", "snodeline", "nodedesh", "nodels", "nodseline", " nodesename", "nodesh", "nodestate", "anodata", "snodselist", "nodesename", " nodette", "nodslist", "snodslist", "nodesels"], "num": ["mon", "norm", "span", "m", "nu", "np", "uri", "unit", "col", "nom", "count", "n", "loc", "init", "nr", "ul", "en", "um", "inc", "part", "pos", "index", "NUM", "sum", "comb", "Num", "uni", "temp", "total", "multi", "max", "len", "tri", "number", "node", "div", "mult", "con", "lim", "dim", "net", "umi", "nam", "mu", "zero", "nb", "dom", "om"], "i": ["m", "uri", "col", "j", "isi", "g", "b", "fi", "ori", "io", "info", "si", "ie", "part", "in", "it", "iv", "o", "index", "d", "ci", "iu", "oi", "ji", "multi", "y", "li", "di", "cli", "mi", "ip", "pi", "hi", "xi", "eni", "l", "slice", "yi", "id", "a", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "phi", "ix", "chi", "ii", "ui", "qi", "mu", "ini", "bi", "x", "p", "ik"]}}
{"id1": "23510383", "id2": "5414088", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": ["deleteModel", " saveproject", " saveApplication", "insertApplication", "insertproject", "deleteProject", "insertModel", "deleteproject", "saveModel", "insertProject", " saveModel", "saveproject", "deleteApplication", "saveApplication"], "file": ["log", "FILE", "resource", "image", "ile", "parent", "complete", "connection", "lock", "data", "single", "project", "part", "folder", "model", "document", "zip", "out", "dir", "directory", "filename", "work", "use", "db", "files", "base", "table", "object", "local", "found", "handler", "full", "File", "path", "picture", "plus", "line", "fp"], "types": ["forms", "fields", "pes", "keys", "ions", "archives", "products", "users", "Types", "links", "jobs", "lists", "options", "parts", "shows", "tags", "relations", "cats", "times", "reports", "plugins", "groups", "features", "classes", "photos", "projects", "settings", "thumbnails", "objects", "tools", "properties", "packages", "ports", "files", "resources", "ids", "pages", "eps", "versions", "names", "models", "stores", "packs", "tests", "Images", "ames", "params", "locks", "ts", "blocks", "words", "boxes", "ypes", "services", "uploads", "strings", "opens", "its", "styles"], "images": ["rooms", "image", "modules", "users", "tags", "reports", "assets", "plugins", "features", "videos", "photos", "ips", "thumbnails", "media", "scripts", "png", "files", "versions", "Images", "actions", "views", "blocks", "boxes", "events", "uploads", "services", "styles"], "trajectories": ["trajections", "traveyors", "transcessions", "traventors", "trajectory", "traveyory", "traventory", "tracessions", "traventions", "transjectory", "transcessories", "transcessors", "traventories", "trajectors", "traveyions", "tracessories", "traveyories", "tracessors", "transjectories", "transjectors", "transcessory", "tracessory", "transjections"], "databasesIncluded": ["databasesInsclusive", "databytesInshibited", "databytesInhibited", "databasesOutclusion", "databasesOutcluded", "databasesinhibited", "databasesOutcluding", "daturesInclusive", "daturesIncluded", "daturesInhibited", "databasesInclusive", "databytesIncluding", "daturesInsclusive", "databasesInscluding", "databytesIncluded", "databytesInscluded", "daturesInclusion", "databasesOuthibited", "databasesOutclusive", "databasesInscluded", "databasesINcluding", "databasesInclusion", "daturesInsclusion", "databytesInsclusion", "databasesInshibited", "databasesIncluding", "databasesincluded", "databasesInhibited", "daturesInscluded", "databytesInscluding", "databasesinclusive", "databasesInsclusion", "databytesInclusion", "databasesINcluded", "databasesinclusion", "daturesInshibited", "databasesINclusion", "databasesINhibited"], "onlyLinks": ["justFiles", "allLink", "OnlyFiles", " onlyLink", "withLink", "justLinks", "OnlyLinks", " onlyFiles", "alllinks", "onlyFiles", "withlinks", " onlylinks", "allLinks", "onlylinks", "justLink", "withLinks", "OnlyLink", "onlyLink"], "index": ["page", "default", "length", "offset", "Index", "num", "weight", "inc", "old", "part", "search", "input", "end", "key", "i", "size", "width", "number", "point", "slice", "position", "ind", "id", "address", "match", "found", "string", "initial", "xxx", "pattern", "ini", "x", "value", "tail", "level", "head"], "name": ["NAME", "url", "default", "message", "image", "resource", "large", "connection", "none", "data", "title", "part", "named", "key", "unique", "home", "temp", "memory", "Name", "size", "filename", "vision", "number", "base", "id", "names", "string", "up", "full", "domain", "path", "stage", "ext"], "format": ["at", "prefix", "text", "unit", "struct", "style", "offset", "term", "form", "letter", "init", "data", "scale", "parser", "external", "status", "template", "date", "temp", "config", "header", "filename", "base", "transform", "position", "language", "string", "layout", "handler", "Format", "pattern", "function", "current", "value", "pretty", "feed", "export"], "count": ["Count", "page", "call", "length", "parent", "build", "num", "depth", "weight", "child", "limit", "sum", "error", "code", "process", "base", "found", "cache", "match", "counter", "age", "list", "path", "content", "level", "force"], "version": ["description", "Version", "vert", "default", "image", "server", "master", "database", "data", "project", "journal", "channel", "output", "application", "draft", "python", "download", "ver", "xml", "config", "section", "vision", "header", "dir", "directory", "target", "feature", "versions", "video", "string", "v", "platform", "latest", "environment", "cover", "release", "content", "update", "manager", "VERSION"], "writer": ["wave", "page", "book", "widget", "wr", "write", "letter", "data", "later", "engine", "writing", "parser", "journal", "written", "director", "output", "writ", "document", "creator", "editor", "Writer", "out", "player", "xml", "temp", "builder", "W", "driver", "reader", "war", "riter", "er", "worker", "walker", "former", "handler", "wire", "w", "writers", "wrapper", "word", "buffer", "author", "manager", "export"], "xmlDir": ["databaseDir", "databaseArea", " xmlPath", " xmlDirectory", "xmlPath", "externalDir", "xmlFile", "xmlArea", "xmlDirectory", "externalFile", "externalDirectory", " xmlFile", "jsonDirectory", "imageFile", "jsonArea", "imageDir", "imageFolder", "imageDirectory", "xmlFolder", "externalFolder", " xmlFolder", "databasePath", "databaseDirectory", " xmlArea", "jsonPath", "jsonDir"], "databases": ["structases", "datogs", " datrooms", "variogs", "arrables", "diabases", " datases", "variabytes", "drogs", "datases", "Databases", "structabytes", "Datables", "diogs", "datrooms", "Datases", "notations", "Databytes", "drabytes", "diations", "datations", "notrooms", "arrabases", "Datrooms", "drabases", "Datations", "diabytes", "databytes", "drations", "arrabytes", "notabases", " datations", "arrases", "structables", "variations", "notases", "variabases", "datables", "structabases"], "t": ["m", "att", "e", "task", "j", "n", "none", "tm", "title", "o", "d", "template", "h", "test", "T", "te", "class", "Type", "i", "y", "target", "token", "string", "v", "c", "ts", "w", "ant", "q", "ty", "p", " T"], "type": ["to", "pe", "attribute", "role", "e", "parent", "null", "style", "like", "info", "data", "single", "link", "TYPE", "part", "group", "field", "definition", "model", "result", "rule", "block", "ype", "set", "o", "template", "error", "test", "key", "class", "Type", "comment", "y", "action", "target", "base", "slice", "id", "match", "string", "token", "language", "option", "other", "op", "function", "value", "state", "ty", "collection", "p", "database", "right"], "currentName": [" currentType", "currentFile", "CurrentPath", "reportedKey", "thisMember", " currentTime", "recentMember", "thisAddress", "thisTime", "CurrentFile", "thisType", "recentTime", "currentAddress", "currentStyle", "thisPath", "recentStyle", "CurrentType", "reportedPath", "reportedAddress", "thisName", " currentNames", " currentMember", "recentName", "currentKey", " currentStyle", "CurrentAddress", "CurrentKey", "currentPath", "futureFile", "thisStyle", "futureName", "reportedName", "CurrentNames", "futurePath", " currentKey", "currentTime", "futureNames", "reportedNames", "CurrentName", "currentNames", "currentType", "reportedType", " currentFile", " currentPath", "currentMember"], "baseCopy": ["aseShare", "binaryCop", "binaryCopy", "BaseName", " baseShare", "baseSource", "baseCop", " basecopy", "BaseCop", " baseSource", "baseName", "aseName", " baseCreate", "baseShare", "basiccopy", " baseCop", "asecopy", "BaseSource", "BaseCreate", "BaseCopy", "basicCopy", " baseName", "BaseShare", "basecopy", "Basecopy", "binarycopy", "basicSource", "baseCreate", "basicCreate", "aseCopy"], "source": ["proxy", "text", "component", "unit", "resource", "image", "core", "server", "parent", "dest", "scope", "view", "connection", "remote", "ie", "channel", "Source", "result", "input", "site", "storage", "ources", "clone", "src", "reader", "size", "config", "client", "stream", "target", "slave", "inner", "base", "section", "slice", "object", "cache", "ource", "option", "service", "reference", "SOURCE", "current", "scene", "manager", "use", "from", "rate"], "destination": ["distination", "destignment", "Destribution", "transignment", "constinations", "externalinator", "constination", "combination", "Destation", "destation", "Destignment", "destinations", "distinator", "transinator", "Destinator", "distignment", "combinator", " destment", "combinations", "externalinated", " destinated", "distribution", "destribution", "transribution", " destinator", "destinated", "Destination", "externalination", "transination", "Destment", "destinator", "Destinated", "externalment", "combation", "destment", "Destinations", "constinator", "constation"], "clefs": ["clebs", "CleFS", "Cleflows", "Clef", "CLEflows", "Clebs", " clef", "cleflows", " clebs", "CLEfs", "clef", "CLEf", "CLEbs", "cleFS", "CLEFS", " cleFS", "Clefs", " cleflows"], "st": ["ost", "sth", "std", "statement", "stru", "est", "fr", "ct", "nd", "struct", "ste", "ss", "bt", "sts", "ST", "sb", "inst", "str", "tt", "sn", "set", "rest", "St", "src", "ist", "sc", "cr", "sa", "sm", "start", "rd", "ld", "sl", "ts", "sp", "ast", "mt", "bl", "ust", "sta"], "rs": [" src", "res", "R", " Rs", "rc", " sr", " sq", " params", " matches", "RS", "Rs", " re", " Result", " obj", " rc", " hits", " RS", "RC", " repl", " ans", " ra", "rd", "Res", " rm", " changes", " success"]}}
{"id1": "2017833", "id2": "20210699", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"hash": ["replace", "crypt", "ash", "message", "html", "build", "sha", "check", "str", "hex", "set", "sum", "h", "create", "add", "print", "parse", "dump", "number", "base", "transform", "string", "Hash", "get", "format", "update", "block"], "text": ["font", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "output", "input", "str", "editor", "hex", "translation", "password", "template", "bytes", "key", "out", "test", "code", "source", "class", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "context", "path", "word", "content", "ext", "format", "buffer", "value", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedencodedWarning", "Unsupportedencodingception", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedencodingWarning", "UnsupportedEncasingWarning", "UnsupportedEncgorithmException", "UnsupportedEncasingException", "UnsupportedEncgorithmception", "UnsupportedEncodingWarning", "UnsupportedEncgorithmWarning", "Unsupportedencodedception", "UnsupportedEncodedWarning"], "md": ["mad", "m", "rm", "hd", " MD", "message", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "gd", "f", "mc", "mag", "d", "vd", "od", "meta", "ms", "hm", "wd", "mb", "amd", "mg", "dm", "bd", "bf", "metadata", "bm", "MD", "ad", "mac", "ind", "nm", "mand", "mm", "ma", "am", "ld", "pm", "mt", "mod", "ds"], "sha1hash": ["sha2h", "sha2hex", "SHA2Hash", "SHA1hash", "sha1hex", "ha1match", "sha4Hash", "shaonehash", "SHA2hash", "ha2match", "ha1hash", "sha1Hash", "sha3hash", "sha2hash", "sha3match", "sha2Hash", "SHA2sum", "sha4hex", "sha5h", "SHA1h", "sha5hex", "sha2sum", "SHA2h", "sha1sum", "SHA1Hash", "shaonematch", "sha1h", "SHA1sum", "ha2hex", "sha3hex", "sha5sum", "sha256h", "sha5Hash", "sha2match", "sha256sum", "sha5hash", "ha1hex", "sha4sum", "ha2hash", "shaonesum", "sha3sum", "sha1match", "sha256hash", "ha2sum", "ha1sum", "shaonehex", "sha256Hash", "sha4hash", "SHA1hex"]}}
{"id1": "20623709", "id2": "20190303", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"split": ["Split", "append", "copy", "build", "cmp", "init", "sync", "part", "archive", "set", "sort", "run", "process", "add", "parse", "delete", "match", "exec", "share", "start", "diff", "transfer", "format", "update", "execute", "open", "join"], "targetDirectory": ["destFile", "targetFolder", "masterPath", "currentFolder", " targetDir", "targetDatabase", "currentRoot", "TargetDatabase", "targetDir", "targetPath", "baseDirectory", "destFolder", " targetRoot", "baseDir", "TargetRoot", "TargetFile", "outputFile", "destDir", "currentDir", "TargetDir", "outputDirectory", "TargetPath", "TargetDirectory", "targetFile", "currentPath", "currentDirectory", "outputDir", " targetPath", "outputFolder", "masterDir", "TargetFolder", "destDirectory", "masterDirectory", "baseDatabase", " targetFolder", "basePath", "masterDatabase", "baseFile", " targetFile", "baseFolder", "targetRoot"], "prefix": ["prot", "padding", "uri", "unit", "resource", "txt", "append", "offset", "username", "FIX", "sequence", "folder", "index", "template", "timeout", "type", "temp", "config", "directory", "filename", "number", "base", "queue", "cache", "string", "patch", " suffix", "name", "resolution", "ix", "fix", "pre", "domain", "root", "pattern", "path", "fixed", "first", "format", "fp", "Pref"], "maxUnitBases": ["maxUnitEases", "maxUnitAliases", "maxUnitChase", "maxUnitBase", "maxunitAliases", "maxUnitEaches", "maxUnitQueases", "maxunitAliasing", "maxunitAliails", "maxUnitQueasing", "maxUnitAliase", "maxUnitAliasing", "maxUnitChues", "maxUnitAliues", "maxUnitAliails", "maxunitBaches", "maxUnitBaches", "maxUnitEails", "maxUnitPlases", "maxunitBues", "maxUnitAliaches", "maxunitBases", "maxUnitPlase", "maxunitAliaches", "maxUnitBails", "maxunitAliase", "maxunitAliues", "maxUnitPlaches", "maxunitBase", "maxUnitBues", "maxunitBasing", "maxUnitEase", "maxUnitChasing", "maxUnitQueues", "maxUnitBasing", "maxUnitPlails", "maxunitBails", "maxUnitChases", "maxUnitQuease"], "maxUnitEntries": ["maxLineEntrations", "maxUnitEnties", "maxUnitEntryry", "maxLineOrdrations", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdines", "maxUnitErries", "maxUnitEntryresses", "maxUnitIntresses", "maxunitEntries", "maxUnitEntryies", "maxUnitInties", "maxunitEnties", "maxLineEntines", "maxUnitEntines", "maxUnitEntryrys", "maxUnitOrdies", "maxunitEntrys", "maxUnitIntries", "maxLineOrdries", "maxLineEntry", "maxUnitCountries", "maxUnitAddries", "maxUnitEntry", "maxunitEntresses", "maxUnitErry", "maxUnitEntrations", "maxunitEntryresses", "maxUnitOrdrys", "maxUnitCountrations", "maxUnitEntresses", "maxUnitEntrys", "maxLineOrdry", "maxLineOrdines", "maxUnitOrdry", "maxUnitErines", "maxUnitAddures", "maxUnitOrdries", "maxUnitErrations", "maxunitEntryries", "maxUnitEntures", "maxLineEntries", "maxUnitOrdresses", "maxunitEntryies", "maxUnitOrdrations", "maxUnitCountry", "maxUnitIntrys", "maxunitEntryrys", "maxUnitEntryries", "maxUnitAddry", "maxUnitCountines"], "fis": ["forisa", "visa", "foris", "forai", " fiss", "foriss", "fisa", "Fris", "fris", "Fisc", "fai", " fIs", "Fiss", " fris", " fisa", "vai", "forIs", "fisc", "forisc", "forris", " fai", "fIs", "fiss", "vis", " fisc", "vIs", "Fis"], "fci": ["hci", "vcos", "efai", " fii", "fai", "dci", "dii", "hcos", "efco", "bis", "bco", "vai", "Fai", "vco", "Fci", "dco", "efcos", "hai", " foci", "bci", " fai", "foci", "bai", "vci", "Foci", "Fii", "Fco", "fii", "doci", "efci", "fcos", "Fis", "hco"], "fos": ["tis", "fo", "fso", "fscos", "Fos", "infos", "ifo", "Foss", "ifcos", "fsios", "infoss", "toss", "fios", " fo", " fcos", "ifios", "fsos", "tos", "infis", "ifos", "foss", "Foes", "foes", " fios", "infoes", "toes", "fcos", "Fis"], "fco": ["hgo", "dcos", "fileico", "Fbo", "Fico", " fro", "fro", "hci", " fgo", "fbo", "dro", "hcos", "filebo", "fileci", "dci", "fgo", "Fci", "dco", "fico", " fico", "fileco", " fbo", "lro", "lgo", " fcos", "lcos", "lco", "Fco", "fcos", "lci", "hco"], "buffer": ["border", "buf", "request", "pad", "writer", "resource", "message", "server", "image", "length", "copy", "null", "offset", "view", "info", "data", "scale", "Buffer", "bc", "channel", "entry", "document", "result", "input", "translation", "batch", "read", "timeout", "texture", "comment", "iter", "memory", "reader", "flush", "size", "header", "source", "buff", "expression", "capacity", "base", "bar", "queue", "position", "cache", "counter", "bin", "window", "loader", "binary", "reference", "device", "pause", "layer", "response", "uffer", "transfer", "context", "zero", "feed", "block", "callback", "rate"], "currentBasesCount": ["currentBasescount", "currentBasesNum", "currentBatchescount", "currentChasesCounter", "currentChasesNum", "currentBatchesCounter", "currentChasesCount", "currentBaseCount", "currentBaseCounter", "currentChasecount", "currentBasesCounter", "currentBasingCounter", "currentBasecount", "currentBasingNum", "currentChasescount", "currentBatchesCount", "currentBaseNum", "currentBatchesNum", "currentChaseCounter", "currentBasingcount", "currentChaseNum", "currentBasingCount", "currentChaseCount"], "currentEntriesCount": ["currentEntursOffset", "currentEntriesOffset", "currentEntursLimit", "currentAddriesOffset", "currentEntriesSize", "currentEnturesOffset", "currentEntrasCount", "currentEntursCount", "currentEntrasLimit", "currentAddriesLimit", "currentAdduresCount", "currentEnturesCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresSize", "currentEntrasSize", "currentAdduresLimit", "currentEntursSize", "currentEnturesSize", "currentEnturesLimit", "currentAddriesSize", "currentEntriesLimit", "currentAddriesCount"], "targetCount": ["targetSum", "patternSize", "targetcount", "patternCount", "TargetSize", "TargetSum", "argetSum", "argetcount", "patterncount", "Targetcount", "patternSum", "argetSize", "TargetCount", "argetCount", "targetSize"], "fastaChannel": ["fastasChannel", "fastasContext", "fastaqBuffer", "fastasContainer", "fastanContext", "fastasConnection", " fastaContext", " fastABuffer", "fastaqConnection", "fastaConnection", "fastasBuffer", "fastAConnection", "fastaqColumn", " fastAColumn", "fastaqChannel", "fastaContainer", "fastanBuffer", "fastABuffer", " fastAConnection", "fastaColumn", "fastAContext", " fastaConnection", "fastAChannel", " fastAChannel", " fastaColumn", "fastAContainer", " fastAContext", " fastAContainer", " fastaContainer", "fastanChannel", "fastasColumn", "fastanContainer", "fastaContext", "fastAColumn"], "totalSeqCount": ["totalSeqCounter", "totalQueqCount", "totalQueQNum", "totalSeuxNum", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQCounter", "totalSeQcount", "totalQueQCounter", "totalQueqcount", "totalQueqNum", "totalSeuxcount", "totalSeuxCount", "totalQueqCounter", "totalSeuxCounter", "totalSeqNum", "totalSeQNum", "totalSeqsCount", "totalSeqsNum", "totalQueQCount", "totalSeqscount"], "totalResiduesCount": ["totalResiduingNum", "totalResiduesSize", "totalResiduescount", "totalResqueuesNum", "totalResiduingCount", "totalResqueuescount", "totalResqueuresNum", "totalResiduationSize", "totalResqueurescount", "totalResiduationNum", "totalResiduresNum", "totalResiduationCount", "totalResiduationcount", "totalResiduingcount", "totalResqueuresSize", "totalResidurescount", "totalResiduresCount", "totalResiduesNum", "totalResqueuesSize", "totalResqueuresCount", "totalResqueuesCount", "totalResiduingSize", "totalResiduresSize"], "prevTime": ["PrevSize", "PrevValue", "commitSize", "commitFile", " prevSize", "PrevTime", "commitValue", " prevFile", "PrevFile", "prevFile", "commitTime", "prevValue", " prevValue", "prevSize"], "fastaFileSize": ["fastaBlockLength", "fastaBlockCount", "fastaPageAddress", "fastABufferAddress", "fastAFileSize", "fastaHeaderLength", "fastasFileSize", "fastAFileLength", "fastaLineCount", "fastAFileAddress", "fastaHeaderAddress", "fastAFileCount", "fastABufferLength", "fastaBlockSize", "fastaFilesLength", "fastaBufferSize", "fastaFileAddress", "fastasFileAddress", "fastaHeaderName", "fastasHeaderSize", "fastaHeaderSize", "fastaPageName", "fastaLineLength", "fastaFileName", "fastaBufferAddress", "fastaBlockAddress", "fastaFilesSize", "fastasHeaderLength", "fastaLineAddress", "fastasHeaderAddress", "fastaLineSize", "fastABufferSize", "fastABufferCount", "fastaFilesName", "fastasFileLength", "fastaBufferCount", "fastaFileLength", "fastaPageSize", "fastasHeaderName", "fastaBufferLength", "fastaFilesAddress", "fastasFileName", "fastaPageLength", "fastaFileCount"], "fastaFileReadOffset": ["fastaFileWriteAmount", "fastaFileRunEntry", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaFileWriteoffset", "fastaFileLoadAmount", "fastaBufferReadOffset", "fastaBufferReadoffset", "fastaFilesWriteLength", "fastaFileStartOff", "fastaFileRunoffset", "fastaFileReadoffset", "fastaFileReadLength", "fastaFileLengthLength", "fastaFilesReadoffset", "fastaFileWriteEntry", "fastaFilesReadOffset", "fastaFileLoadoffset", "fastaBufferReadAmount", "fastaBufferWriteOffset", "fastaFileReadOff", "fastaBufferWriteoffset", "fastaFileWriteOff", "fastaDirectoryReadEntry", "fastaFilesReadLength", "fastaFilesWriteoffset", "fastaDirectoryWriteOff", "fastaFileRunOff", "fastaBufferReadLength", "fastaFileLengthOffset", "fastaFileWriteOffset", "fastaFilereadoffset", "fastaFilereadLength", "fastaFileLoadOffset", "fastaFilesWriteOff", "fastaFileWriteLength", "fastaFileStartoffset", "fastaDirectoryWriteEntry", "fastaFileStartOffset", "fastaFileReadAmount", "fastaDirectoryReadoffset", "fastaDirectoryReadOff", "fastaFilereadOffset", "fastaFileLengthoffset", "fastaFileLoadLength", "fastaFileRunOffset", "fastaFilesReadOff", "fastaFileReadEntry", "fastaFilesWriteOffset", "fastaDirectoryWriteoffset", "fastaFileLengthOff", "fastaFileStartEntry", "fastaBufferWriteAmount", "fastaFileLengthAmount", "fastaFilereadOff", "fastaBufferWriteLength"], "partitionStartOffset": ["partitionsStartRange", "partitionEndOff", "partitionBufferOff", "partitionStartOff", "partitionsStartOrder", "partitionsEndOff", "partitionStopRange", "partitionBufferOrder", "partitionEndRange", "partitionsEndRange", "partitionsStartOffset", "partitionStopOrder", "partitionBufferRange", "partitionEndOrder", "partitionStopOff", "partitionStartOrder", "partitionStartRange", "partitionsEndOffset", "partitionsStartOff", "partitionBufferOffset", "partitionStopOffset", "partitionsEndOrder"], "bufferSize": ["BufferC", " bufferSIZE", "bufferC", "processC", "BufferSIZE", "processSIZE", "queueSize", "bufferType", "BufferSize", "BufferCount", "BufferType", " bufferCount", "bufferSIZE", "bufferCount", "processType", "queueCount", " bufferType", "processSize", " bufferC"], "fastaBuffer": ["fastasChannel", "FastaBuff", " fastABuff", " fastaBuff", "fastasContainer", "fastasPtr", "fastaaPtr", "fastanFile", "FastasPtr", "FastaStream", "fastAQueue", "fastasFile", "FastaBuffer", " fastasChannel", "fastaQueue", " fastABuffer", "fastaFile", " fastaFile", "fastaStream", "fastAFile", "fastaaBuff", "fastasBuffer", "FastasChannel", "fastanPtr", " fastAQueue", "fastanQueue", "fastaPtr", " fastAFile", "fastaceBuff", "fastaceChannel", "fastaContainer", "fastaaBuffer", "FastaPtr", "fastanBuffer", "FastasBuff", "fastABuffer", "fastasStream", "FastasBuffer", "fastAPtr", " fastasFile", " fastasContainer", "fastAChannel", " fastAChannel", "fastanStream", "fastasBuff", "fastaceBuffer", " fastasBuffer", "fastAContainer", "fastasQueue", "FastasStream", "fastaBuff", " fastaContainer", "fastanChannel", "fastABuff", "fastanBuff", "FastaChannel", "fastaaStream", "fastanContainer", "fastacePtr", " fastaQueue"], "fastaReadState": ["fastasReadstate", "fastasReaderState", "fastaReaderstate", "fastasReaderMode", "fastaReadstate", "fastaReadingState", "fastaReaderState", "fastaReadMode", "fastasReadType", "fastaFileMode", "fastasReadMode", "fastaFileState", "fastaReadingType", "fastasReaderType", "fastaReadType", "fastaReaderMode", "fastasReadState", "fastaFileType", "fastaFilestate", "fastaReaderType", "fastasReaderstate", "fastaReadingstate", "fastaReadingMode"], "nBytes": ["nFrames", " nParts", "obytes", "pbytes", "numFrames", "nFiles", " nFiles", "oParts", "pBytes", "numBytes", "NBytes", "oBytes", "NParts", " nbytes", "lenFrames", "lenbytes", "oFiles", "NByte", " nFrames", "pParts", "Nbytes", "lenFiles", "pByte", "nByte", "nbytes", " nByte", "NFiles", "nParts", "numbytes", "lenBytes", "numFiles"]}}
{"id1": "5607440", "id2": "21010945", "code1": "    public void updateShoppingBean(String userId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            connection = DriverManager.getConnection(this.jdbcURL);\n            connection.setAutoCommit(false);\n            String preparedQuery = \"INSERT INTO dbComputerShopping.order(name,product_id,quantity,date,status)VALUES(?,?,?,?,?)\";\n            preparedStatement1 = connection.prepareStatement(preparedQuery);\n            Date date = new Date();\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            String orderDate = format.format(date);\n            Iterator iterator = this.cart.iterator();\n            Object[] shoppingInfo = null;\n            while (iterator.hasNext()) {\n                shoppingInfo = (Object[]) iterator.next();\n                ProductBean product = (ProductBean) shoppingInfo[0];\n                int quantity = (Integer) shoppingInfo[1];\n                preparedStatement1.setString(1, userId);\n                preparedStatement1.setInt(2, product.getId());\n                preparedStatement1.setInt(3, quantity);\n                preparedStatement1.setString(4, orderDate);\n                preparedStatement1.setString(5, \"confirmed\");\n                preparedStatement1.executeUpdate();\n            }\n            Object[] cartInfo = null;\n            preparedQuery = \"UPDATE components SET quantity=quantity-? WHERE comp_id=?\";\n            preparedStatement2 = connection.prepareStatement(preparedQuery);\n            for (Iterator i = this.cart.iterator(); i.hasNext(); ) {\n                cartInfo = (Object[]) i.next();\n                ProductBean product = (ProductBean) cartInfo[0];\n                int quantity = (Integer) cartInfo[1];\n                ProductListBean productList = new ProductListBean(jdbcURL);\n                ArrayList components = productList.getComponents(product.getId());\n                for (Iterator j = components.iterator(); j.hasNext(); ) {\n                    ComponentBean component = (ComponentBean) j.next();\n                    preparedStatement2.setInt(1, quantity);\n                    preparedStatement2.setInt(2, component.getId());\n                    preparedStatement2.executeUpdate();\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n            }\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement1.close();\n            } catch (SQLException ex) {\n            }\n            try {\n                preparedStatement2.close();\n            } catch (SQLException ex) {\n            }\n        }\n    }\n", "code2": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "label": 0, "substitutes": {"updateShoppingBean": ["updateShoppingBoans", "updateShoppingBoan", "updateShoppingBEAN", "updateShippingBean", "updateShoppingBAN", "updateShoppingBEan", "updateShoppingBEaning", "updateShoppingBeans", "updateShoppingBeAN", "updateShippingBeaning", "updateShoppingBEans", "updateShoppingBoAN", "updateShippingBaning", "updateShippingBan", "updateShoppingBans", "updateShippingBans", "updateShoppingBaning", "updateShoppingBoaning", "updateShoppingBeaning", "updateShippingBAN", "updateShippingBeans", "updateShippingBeAN", "updateShoppingBan"], "userId": ["UserPath", " userType", "clientId", " userID", "UserData", "clientType", "clientName", "UserType", "userName", " userName", "UserID", "UserName", "userData", "clientPath", " userPath", "clientID", "userPath", "userID", "clientData", "userType", " userData", "UserId"], "connection": ["statement", "management", "log", "writer", "subject", "resource", "server", "general", "communication", "lock", "data", "session", "engine", "sql", "bc", "channel", "Connection", "application", "document", "connect", "result", "ion", "index", "graph", "container", "conn", "connected", "class", "driver", "config", "section", "client", "directory", "BC", "db", "table", "cache", "con", "c", "machine", "handler", "name", "relation", "service", "function", "pool", "condition", "context", "query", " Connection", "state", "collection", "manager", "database"], "preparedStatement1": ["preparedTransaction0", "preparedDatabase2", "preparedStat3", "prefixedStruct1", "preasterStatement01", "preparedSessionB", "preparedCommentone", "preparedQueryl", "preculatedEvent01", "preculatedEvent1", "preuredStatement4", "prefixedStatement9", "preparedstatement1001", "preparedDocument4", "preparedState0", "preparedStatement01", "preparedQuery4", "prearedStatementB", "preparedStruct0", "preasterStatement1001", "preasterObjectone", "preparedCommentl", "prearedSessionB", "preparedStatement9", "preppedStatement3", "preparedStatementB", "preparedComment1001", "preparedStatement17", "preparedState01", "prearedStatement2", "preparedObject1001", "preparedDatabase1", "preasterObject1001", "preparedStat31", "preparedComment3", "preparedDatabase17", "preparedState9", "preparedStatement1001", "preparedState1", "preparedSession1", "preparedTransaction31", "preparedContext1", "preppedStatementl", "preparedObject01", "preparedDatabase4", "preparedDatabasen", "preakedQuery1", "preparedStatement0", "preparedSession0", "preparedDocument0", "prearedSession1", "preparedMaterial2", "preparedMaterial1", "preparedDocumentone", "preuredStatement31", "preakedStatement2", "prefixedStatement1", "preparedTransaction9", "preculatedStatement1", "preparedSession2", "preferredQuery2", "preparedStatone", "preparedState31", "preparedComment1", "prearedSession2", "preparedQuery3", "preparedContext31", "preferredStatement17", "preakedStatement1", "preakedStatement4", "preasterStatementone", "preasterObject1", "preparedEvent01", "preppedStat3", "preparedStatementn", "preuredStatementone", "prefixedStruct31", "preparedEvent1", "preparedStruct9", "preuredStatement1", "preakedQuery2", "preparedQuery0", "preakedQuery4", "preuredStat1", "preferredQuery1", "prefixedStruct0", "preparedStatement31", "preasterStatement1", "preparedStatementl", "preparedObjectone", "preuredStat4", "preparedDocument2", "prefixedStatement0", "preparedDocument31", "preuredStatone", "preparedstatementone", "preferredQuery17", "preakedQueryn", "preferredStatement1", "preppedStatement1", "prearedSession0", "prearedStatement1", "preparedTransaction1", "preparedStatement4", "preparedStat4", "preparedDocumentB", "preculatedStatement01", "prefixedStatement31", "preparedStat1", "preasterObject01", "preppedStat1", "preferredStatement2", "preparedMaterial17", "preppedStatl", "preparedQueryB", "preparedQuery1", "preparedContext4", "preparedObject1", "preparedDocument1", "preparedStatement3", "preparedstatement01", "preparedQuery17", "preparedDocumentn", "preparedStruct1", "preparedContextone", "preparedStatl", "preakedStatementn", "preparedStatementone", "preparedQuery2", "prefixedStruct9", "preparedComment01", "prearedStatement0", "preparedStruct31", "preparedQueryn", "preparedstatement1", "preuredStat31"], "preparedStatement2": ["preparedScope404", "preparedSession1", "preparedStatement404", "preuredStatement2", "preparedConfiguration0", "preuredStatement404", "preparedConditiontwo", "preparedstatement2", "preparedCondition8", "preparedStatement8", "preuredStatement8", "preparedstatement8", "preuredStatementtwo", "preparedStatement52", "preparedstatement404", "preparedStatement0", "preparedSession0", "prearedSession52", "preuredstatement8", "preparedConfiguration52", "preparedCondition2", "prearedSession1", "prearedStatement52", "preparedConfiguration1", "preparedScopetwo", "preparedSession52", "preparedstatementtwo", "preparedResult0", "preparedSession2", "prearedStatement2", "prearedStatement0", "preparedResult52", "preparedConfiguration2", "preuredstatement2", "prearedSession0", "prearedStatement1", "prearedSession2", "preparedResult1", "preparedScope8", "preuredstatement404", "preparedStatementtwo", "preuredstatementtwo", "preparedScope2", "preparedResult2", "preparedCondition404"], "preparedQuery": ["prevertedInfo", "Preparedquery", "perppedquery", "prearedInfo", "preparedBody", "peraredStatement", "previsedQu", "previsedBody", "PrearedInfo", "prearedStatement", "PreppedQu", "preppedBody", "previsedQuery", "PreparedFunction", "prevertedBody", "PrearedQu", "PrearedFunction", "preplannedStatement", "perparedCommand", "previsedStatement", "PreparedQu", "PreppedQuery", "prearedQu", "preppedQu", "preculatedQuery", "precedQuery", "prearedFunction", "peraredQuery", "preparedquery", "preppedQuery", "perparedQuery", "preparedFunction", "PreppedStatement", "preculatedInfo", "prearedQuery", "PreparedQuery", "Preppedquery", "perppedQuery", "preparedQu", "perparedStatement", "prevertedQu", "perparedBody", "preculatedFunction", "preppedStatement", "preparedStatement", "precedCommand", "prearedCommand", "preparedCommand", "prevertedQuery", "peraredCommand", "preplannedquery", "previsedquery", "preplannedQuery", "perppedBody", "precedquery", "preplannedCommand", "peraredquery", "prevertedquery", "perparedquery", "prevertedStatement", "preparedInfo", "preculatedQu", "precedStatement", "PreparedInfo", "perppedStatement", "PrearedQuery", "prearedquery", "preppedquery", "PreparedStatement", "prevertedFunction"], "date": ["log", "message", "resource", "module", "complete", "style", "form", "event", "tag", "data", "version", "duration", "model", "status", "document", "year", "set", "d", "dat", "index", "type", "time", "open", "record", "use", "month", "db", "number", "change", "day", "ate", "string", "match", "file", "Date", "start", "name", "age", "order", "grade", "bug", "update", "stage", "dt", "rate"], "format": ["at", "filter", "replace", "prefix", "writer", "prep", "unit", "report", "struct", "html", "style", "term", "form", "letter", "atter", "dot", "info", "data", "method", "scale", "parser", "cut", "part", "wrap", "str", "set", "split", "sort", "and", " formatted", "type", "handle", "process", "time", "class", "add", "parse", "print", "point", "transform", "table", "string", "handler", "Format", "name", "printf", "pattern", "function", " Format", "value", " fmt", "pretty", " formatting", "export", "join"], "orderDate": ["OrderTime", "orderTime", "orderDat", "serverTime", " orderName", " orderDay", " orderData", "OrderName", "OrderDate", "OrderData", "OrderDay", "Orderdate", "serverData", "orderData", "requestDat", " orderdate", "orderdate", "requestDate", "requestDay", "serverdate", "requestName", "orderDay", "orderName", "serverDate", "OrderDat", " orderTime", " orderDat"], "iterator": ["river", "enter", "writer", "uri", "server", "ater", "append", "atio", "init", "ski", "started", "outer", "later", "step", "parser", "engine", "random", "ie", "you", "sequence", "series", "oper", "entry", "loop", "creator", "it", "timer", "set", "finder", "storage", "done", "interstitial", "gener", "instance", "selection", "iter", "driver", "reader", "metadata", "header", "ter", "er", "stream", "consider", "inner", "Iterator", "walker", "former", "slice", "ators", "starter", "holder", "adder", "start", "loader", "Iter", "inter", "ator", "vector", "context", "until", "runner", "pointer", "ident", "wrapper", "runners", "path", "collection", "database", "processor", "choice"], "shoppingInfo": ["shoutingINFO", "shoppingId", "swoppingArea", "hoppingInf", "shoppingINFO", "shillingMeta", "shopingObj", "shippingInf", "shppingId", "shippingINFO", "shashingId", "shoppinginfo", "swopingArea", "swopingInf", "hillingInfo", "ShippingInf", "shoutingInf", "shippingInfo", "shillingINFO", "shppingObj", "shopingArea", "swoppingObj", "ShippingInfo", "shoppingInf", "shppinginfo", "shillingId", "swoppingInfo", "shppingInf", "hillingData", "hoppinginfo", "ShippingINFO", "shppingMeta", "hoppingInfo", "shashingInf", "shopingInfo", "shopingMeta", "hoppingData", "hillingId", "shillinginfo", "hillingMeta", "shoppingObj", "shoppingArea", "shillingObj", "hillinginfo", "shashinginfo", "swopingObj", "shoppingMeta", "shopingData", "shillingData", "shppingInfo", "shppingData", "shillingInfo", "shppingArea", "shashingInfo", "ShoppingInf", "shoppingData", "hoppingMeta", "shopingInf", "shoutingInfo", "swoppingInf", "swopingInfo", "hillingInf", "shillingArea", "ShoppingInfo", "ShoppingINFO", "shillingInf", "hoppingId"], "product": ["filter", "pe", "attribute", "resource", "module", "processor", "image", "copy", "parent", "products", "data", "version", "project", "child", "cart", "output", "model", "creator", "result", "input", "collection", "Product", "type", "band", "process", "plugin", "class", "source", "payment", "config", "client", "contact", "target", "user", "feature", "company", "object", "position", "seller", "property", "service", "relation", "per", "order", "production", "pp", "p"], "quantity": ["necessification", "compification", "commentITY", "necessifier", "quantifier", "quantality", "necessation", "aquance", "commentifier", "primifier", "authoricity", "commentity", "compity", "mentifier", "mentITY", "aquicity", "compality", "mentity", "primality", "compance", "quantITY", "primification", "quantance", "primity", "quanticity", "quantification", "necessity", "authority", "aquity", "primation", "compation", "commentality", "quantation", "authorality", "compicity", "primITY", "authorance", "aquality", "compifier", "mentality"], "cartInfo": ["frontObj", " cartSize", "carInfo", "frontStyle", " cartObj", "contactInfo", " cartData", "contactInf", "cartObj", "cartInf", "cartMeta", "frontInf", "productSize", "productData", " cartStyle", "cartStyle", "productObj", "carObj", "carSize", "contactData", "carStyle", "carMeta", "frontInfo", " cartInf", "productInfo", "frontMeta", "cartData", "cartSize", "productInf", "contactList", " cartMeta", "carInf", "cartList", " cartList"], "i": ["p", "uri", "e", "n", "init", "ori", "io", "info", "si", "ie", "ati", "it", "f", "index", "ci", "iu", "oi", "ani", "abi", "is", "api", "multi", "ami", "li", "di", "l", "cli", "ip", "pi", "hi", "xi", "vi", "id", "v", "c", "ic", "list", "ri", "I", "ai", "phi", "ini", "ii", "ui", "bi", "chi", "qi"], "productList": ["configCollection", "cartlist", "cartArray", " productSet", "pageList", "pageArray", " productArray", "configList", " productGroup", "configSet", "productGroup", "resourcelist", "pagelist", "productSet", "productCollection", " productlist", "configlist", "resourceList", "resourceSet", "productlist", "productArray", "resourceCollection", "pageGroup", "cartGroup", "cartList", " productCollection"], "components": ["productarts", " complements", "comlements", "comonents", "comonent", "complements", "depositories", "suppositories", "pategories", "compositories", "ponents", " compositories", " compenses", "comenses", "comients", "commositories", "parts", "carts", "supplements", "commients", "pproducts", "suppenses", "supponents", "commonent", "conents", "compategories", "comparts", "deponents", "depients", "deponent", "cproducts", "categories", "compproducts", "productonents", "comositories", "compenses", "compients", "productproducts", "commonents", "productategories"], "j": ["ij", "k", "Insert", "js", "url", "z", "b", "n", "_", "this", "Query", "sql", "jc", "ie", "f", "all", "area", "jj", "o", "index", "ji", "J", "jo", " ii", "add", "config", "l", "er", "bj", "r", "id", "v", "Config", "obj", "other", "adj", "Select", "query", "jp", "update", "where", "p", "database"]}}
{"id1": "17190057", "id2": "13414771", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encode": ["Enode", "uncode", "unode", "Encode", "enccode", "encescape", "enode", "Enescape", "enescape", "unescape"], "input": ["crypt", "prefix", "text", "array", "ssl", "image", "null", "form", "empty", "data", "this", "raw", "output", "in", "audio", "result", "str", "hex", "password", "inf", "temp", "instance", "i", "source", "reader", "config", "stream", "Input", "address", "string", "amp", "alpha", "def", "xxx", "binary", "pattern", "context", "plus", "buffer", "format", "addin", "secure", "request", "img"], "NoSuchAlgorithmException": ["NoSuchAlgoement", "NoSuchEdgorithmement", "NoSuchAlryptionException", "NoSuchAlodingError", "NoSuchAlgorithmError", "NoSuchAlgorithmWarning", "NoSuchAlodingement", "NoSuchEdgorithmWarning", "NoSuchEdryptionWarning", "NoSuchEdryptionement", "NoSuchAlryptionError", "NoSuchAlgoError", "NoSuchEdgorithmException", "NoSuchAlgoWarning", "NoSuchEdgorithmError", "NoSuchAlodingWarning", "NoSuchAlryptionement", "NoSuchAlgoException", "NoSuchAlodingException", "NoSuchEdryptionError", "NoSuchEdryptionException", "NoSuchAlryptionWarning", "NoSuchAlgorithmement"], "md": ["mad", "m", "doc", "hd", " MD", "message", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "zip", "hash", "mc", "mag", "d", "sum", "od", "meta", "ms", "key", "mb", "code", "amd", "me", "dm", "bd", "wd", "metadata", "pd", "MD", "mi", "db", "ad", "mac", "nm", "mand", "mm", "ma", "dc", "pm", "mt", "cd", "mod", "df"]}}
{"id1": "18748516", "id2": "20619879", "code1": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "write", "append", " clipboard", "cmp", "sync", "all", " copying", " copied", "zip", "paste", "split", "clone", "clip", "download", "move", "Copy", "dump", " Copy", "change", "file", "diff", "transfer", "put", "Cop", "p", "cop"], "fromFile": ["fromFilename", "addressfile", " fromPlace", "FromFilename", "sourceDirectory", " fromDirectory", " fromfile", "Fromfile", "sourcePlace", "fromDirectory", "sourceFile", "addressDirectory", "sourcefile", "fromPlace", "fromfile", "sourceFilename", "FromFile", "addressFilename", "FromDirectory", "addressFile", "FromPlace"], "toFile": ["ToString", "throughFILE", " toString", "toString", "outputPlace", "ToFilename", "toFILE", "Tofile", "throughPlace", "throughFile", "throughfile", "tofile", "targetPlace", "ToFile", "outputFILE", "toPlace", "targetfile", "targetString", "targetFilename", " toFilename", " tofile", "targetFile", "targetFILE", "toFilename", "outputfile"], "inputFile": [" inputfile", "inputPage", "currentFile", "InputFile", " inputLibrary", "inputPlace", "InputPage", "InputStyle", "outPage", "inputLibrary", "inputStyle", "outStream", "currentPlace", "inputStream", "outStyle", " inputStream", "fromPlace", "fromfile", "inputfile", "currentfile", "outFile", "fromLibrary", "currentLibrary", " inputPage", " inputStyle", "InputStream", " inputPlace"], "outputFile": ["OutputPath", "targetFolder", "inputFolder", "targetStyle", "targetDir", "targetPath", "OutputFolder", "OutputStyle", " outputfile", "outputStyle", "outputPath", "targetfile", "targetFile", "outputDir", "OutputDir", "outputFolder", "inputfile", "OutputFile", " outputDir", " outputStyle", "Outputfile", "outputfile", "inputPath"], "in": ["into", "ln", "ins", "image", "In", "connection", "init", "inc", "socket", "f", "gin", "input", "din", "IN", "lin", "inn", "s", "cin", "sin", "i", "win", "rin", "reader", "source", "issue", "inside", "nin", "l", "a", "login", "inner", "min", "r", "pull", "con", "bin", "file", "ic", "up", "pin", "get", "ini", "again", "isin"], "out": ["at", "to", "ex", "writer", "write", "one", "image", "plain", "null", "b", "parent", "n", "off", "io", "outer", "sync", "outside", "inc", "raw", "output", "o", "Out", "error", "s", "i", "client", "outs", "over", "cache", "v", "exec", "file", "other", "up", "w", "net", "OUT", "as", "again", "line", "lib"], "c": ["k", "m", "u", "ct", "esc", "e", "col", "uc", "C", "b", "count", "n", "rc", "ce", "ec", "f", "o", "d", "index", "ch", "cl", "nc", "ci", "code", "cc", "i", "cu", "cm", "l", "r", "oc", "id", "xc", "sc", "ac", "v", "pc", "character", "dc", "fc", "t", "cf", "x", "cy", "lc", "pointer", "current", "enc", "cr", "p", "char"]}}
{"id1": "2668853", "id2": "3745402", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFiletoStream", "decodeFileAsfile", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeString2File", "decodeFileTofile", "decodeFileAsStream", "decodeStringToFile", "decodeStringTofile", "decodeString2file", "decodeStringToStream", "decodeString2Files", "decodeFileToFiles", "decodeFiletoFile", "decodeFiletoFiles", "decodeFileAsFiles", "decodeFile2file", "decodeFile2Files", "decodeStringToFiles", "decodeFiletofile"], "infile": ["infp", " infiles", "inputfiles", "inputFile", "outfp", "outfilename", "inFile", " inFile", "minfp", "inputfp", "infiles", "infilename", "inputfilename", "minfilename", "minFile", "inputfile", "outfiles", "outFile", "minfile", " infilename"], "outfile": ["infp", " outfilename", "Outfull", " outfull", "outputfilename", " outfolder", "outputfolder", "outputfp", "outfp", " outFile", "outfilename", "outputFile", "Outfolder", " outfp", "outfolder", "infilename", "outputfull", "infolder", "outFile", "Outfile", "outfull", "OutFile", "outputfile"], "in": ["m", "ex", "ins", "e", "image", "In", "b", "init", "data", "this", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "cin", "i", "is", "win", "source", "reader", "rin", "inside", "a", "nin", "login", "inner", "min", "r", "ac", "bin", "err", "con", "ic", "re", "up", "pin", "ini", "as", "again"], "out": ["to", "exit", "ex", "writer", "write", "image", "copy", "In", "b", "lock", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "exp", "o", "Out", "error", "s", "conn", "home", "pass", "client", "co", "target", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "other", "up", "net", "OUT", "op", "as", "ext", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "pad", "url", "resource", "server", "length", "null", "b", "offset", "data", "Buffer", "limit", "shape", "result", "input", "split", "batch", "bytes", "row", "flush", "iter", "memory", "reader", "source", "size", "buff", "seed", "base", "queue", "slice", "address", "bin", "binary", "reference", "pause", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["k", " receive", " r", "count", " find", "reading", "fill", "pass", "ad", "send", "r", "exec", "start", "find", " send", " Read", "inc", "limit", "input", " check", "index", "Read", " write", " use", "add", "parse", "iter", " request", "skip", " reader", "x", "feed", " load", "play", "length", "sync", "check", "reads", " ride", "seek", "run", "tell", "end", "size", " reach", "ind", "id", " get", "wait", "next", " copy", " parse", "use", "open", "write", "se", "copy", " connect", "lex", "allow", "ride", "connect", "READ", "reader", "work", "load", "select", "get", "current", "sleep", " sleep", "line"], "success": ["warning", "danger", "default", "rolling", "successfully", "good", "null", "complete", "ok", "correct", "failed", "cess", "successful", "data", "func", "winner", " Success", "follow", "status", "selected", "result", "fail", "valid", "yes", "done", "error", "job", "accept", " succeed", " successful", "pass", "results", "Success", "roll", "true", " succ", "found", "initial", "safe", "continue", "rolled", "ceed", "full", "first", "response", "fast", "content", "ccess", "again", "zero", "value", "better", "construct"]}}
{"id1": "364438", "id2": "19134229", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "17475530", "id2": "5632808", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinkstoPicture", "testAddLinkToFile", "testAddLinkToPicture", "testAddLinksToLink", "testAddLinksToPicture", "testAddLinkstoFile", "testAddLinkFromImage", "testAddLinkFromLink", "testAddLinkToLink", "testAddLinkstoLink", "testAddLinkstoImage", "testAddLinkOfImage", "testAddLinkOfLink", "testAddLinkFromFile", "testAddLinksToImage", "testAddLinkOfFile", "testAddLinkOfPicture", "testAddLinktoFile", "testAddLinktoImage", "testAddLinkFromPicture", "testAddLinktoPicture", "testAddLinksToFile", "testAddLinktoLink"], "in": ["at", "m", "ex", "ins", "ssl", "url", "resource", "image", "uri", "In", "copy", "ax", "n", "connection", "data", "version", "inc", "socket", "f", "gin", "input", "exp", "din", "IN", "index", "inn", "val", "out", "conn", "pass", "el", "cin", "xml", "is", "source", "win", "i", "reader", "with", "rin", "nin", "work", "stream", "login", "min", "r", "id", "token", "ac", "exec", "bin", "file", "con", "err", "name", "diff", "pin", "get", "ini", "as", "path", "or", "again", "serv", "doc", "isin"]}}
{"id1": "12847055", "id2": "18696387", "code1": "        public MobileAgentProperties(Class declaringClass, String propertyFile) throws IOException {\n            this.defaults = (MobileAgent) AnnotationElement.getAnyAnnotation(declaringClass, MobileAgent.class);\n            URL url = getClass().getClassLoader().getResource(propertyFile);\n            if (url != null) {\n                props.load(url.openStream());\n                log.info(\"MobileAgent parameters loaded from file \" + url);\n            }\n        }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"declaringClass": ["claringLine", "claringPackage", "DecliningText", "declaringText", "DecliningClass", "declaredPackage", "DeclaringPackage", "declosingText", "decliningClass", "declaringPackage", "decliningFile", "declosingPackage", "DecliningFile", "DecliningPackage", "claredFile", "claredLine", "declacingPackage", "declacingLine", "declosingFile", "DeclaringText", "decliningLine", "DeclaringClass", "declaredLine", "declosingClass", "declacingFile", "decliningText", "declaredFile", "decliningPackage", "claringFile", "DeclaringFile", "declaringLine", "claredPackage", "declacingClass", "declaredText", "claredClass", "declaringFile", "declaredClass", "claringClass"], "propertyFile": ["PropertyString", "propertiesString", "propertyFILE", "PropertyName", "propertiesFiles", "sectionFILE", "sectionFile", "sectionfile", " propertyfile", " propertyName", "propertyFiles", "PropertyFile", "propertiesName", " propertyFILE", "propertyfile", " propertyFiles", "PropertyFILE", "propertyName", " propertyString", "Propertyfile", "propertiesFile", "propertyString", "PropertyFiles", "sectionFiles"], "defaults": ["defaultp", "configies", "preds", "configSettings", "urlSettings", "defaulties", "predies", "urlies", "urlp", "predSettings", "predp", "defaultSettings", "configp", "urls", "configs"], "url": ["ur", "ls", "page", "fl", "uri", "ssl", "resource", "image", "server", "fr", "ll", "html", "b", "connection", "loc", "rel", "org", "blog", "f", "zip", "www", "URL", "coll", "ref", "cl", "bel", "element", "xml", "class", "source", "api", "config", "src", "rl", "pull", "l", "stream", "base", "user", "found", "id", "address", "string", "gl", "ource", "file", "loader", "service", "ob", "sl", "location", "Url", " URL", "path", "or", "buffer", "http", "feed", "bb", "browser"]}}
{"id1": "7087108", "id2": "19687456", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"doGet": ["processGet", "doPut", " doDownload", "processDownload", "didDownload", "doDownload", " doGET", " doPut", "processPut", "didGet", "doGET", "didPut", "didGET", "processGET"], "request": ["forward", "req", "subject", "url", "uri", "report", "resource", "server", "message", "parent", "complete", "view", "connection", "event", "method", "data", "info", "project", "child", "version", "this", "external", "application", "model", "result", "input", "route", "Request", "error", "type", "xml", "instance", "builder", "QUEST", "create", "reader", "config", "client", "web", "target", "self", "user", "object", "string", "name", "host", "context", "query", "json", "current", "buffer", "condition", "http", "use"], "response": ["wave", "resp", "page", "writer", "respond", "report", "resource", "server", "message", "example", "image", "view", "Response", "connection", "body", "remote", "method", "version", "output", "application", "document", "status", "result", "site", "model", "reply", "out", "results", "client", "object", "cache", "service", "reference", "json", "content", "collection", "http"], "path": ["filter", "text", "p", "url", "uri", "message", "image", "resource", "info", "data", "ath", "method", "output", "folder", "PATH", "route", "index", "key", "out", "dir", "config", "directory", "filename", "Path", "base", "point", "object", "id", "cache", "string", "name", "pattern", "location", "content", "value", "format", "http"], "file": ["to", "pe", "log", "url", "FILE", "resource", "uri", "image", "le", "b", "connection", "lock", "info", "data", "child", "socket", "part", "folder", "f", "it", "zip", "rule", "route", "feed", "h", "out", "class", "source", "dir", "directory", "filename", "l", "use", "work", "files", "base", "object", "local", "handler", "name", "up", "full", "File", "function", "fe", "http", "fp", "lib"], "in": ["ins", "resource", "In", "copy", "b", "ax", "thin", "init", "data", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "lin", "inn", "out", "s", "cin", "i", "is", "source", "kin", "reader", "rin", "win", "nin", "stream", "login", "inner", "r", "id", "ac", "bin", "c", "con", "binary", "pin", "ini", "as", "serv", "isin"]}}
{"id1": "17724879", "id2": "5551393", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "label": 1, "substitutes": {"getDigest": ["getSignests", "getdigHash", "getSignHash", "createdigHash", "createDigester", "getSignester", "getdigests", "createDigests", "getMDHash", "getdigester", "getMDest", "getDigester", "createdigest", "createdigests", "createdigester", "getMDests", "getDigests", "getMDester", "getSignest", "getdigest", "createDigHash", "createDigest", "getDigHash"], "attribute": ["prefix", "att", "component", "subject", "uri", "resource", "image", "message", "connection", "event", "data", "username", "individual", "entry", "document", "application", "definition", "audio", "route", "set", "attr", "type", "ribute", "element", "instance", "plugin", "class", "metadata", "api", "config", "directory", "client", "pair", "expression", "feature", "node", "variable", "object", "address", "character", "name", "property", "entity", "reference", "device", "function", "layer", "operation", "value", "ident", "argument", "manager", "Attribute"], "digestAlgorithm": ["digESTAlg", "digesterAlgebra", "digestalger", "digestElg", "digestElger", "digestAlgorith", "digestalgo", "digesterAlgo", "digestAlg", "digESTAlgo", "digesterAlgorith", "digESTAlgorithm", "digestAlgo", "digestalg", "digestalgorith", "digestAlgebra", "digestalgorithm", "digestElgo", "digestALgorithm", "digestALgebra", "digesterAlgorithm", "digestALgorith", "digestElgorithm", "digestALgo", "digestAlger", "digESTAlger", "digestalgebra"], "digest": ["labest", "DigEST", " digEST", "dger", "bigester", "dest", "bigger", "bigest", "Digester", "signger", "digEST", "Digest", " digested", "diguration", "longester", "Digtest", "digtest", "multipluration", "multiplEST", "labEST", "digger", "multiplest", "signest", " diguration", "multiplester", " digester", "longEST", "Digested", "digester", " digtest", "signester", "dester", "biggest", "labtest", "dgest", "digested", "labester", "diggest", "Diguration", "longest", "signgest", "longested"], "md": ["ds", "own", "m", "wd", "rm", "doc", "mad", "hd", "sd", " MD", "der", "module", "nd", "mp", "cmd", "mr", "mo", "um", "mid", "dd", "ht", "editor", "mc", "mag", "d", "od", "mb", "ms", "dev", "ng", "nm", "amd", "plugin", "dm", "bd", "meta", "metadata", "cm", "pd", "MD", "di", "mn", "mi", "db", "ad", "mac", "my", "id", "po", "mm", "ma", "sm", "app", "ml", "ld", "cb", "pm", "kg", "arm", "mt", "cd", "ui", "mod", "manager", "df"]}}
{"id1": "14567939", "id2": "5138455", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": ["Basehash", "BaseFile", " chainFile", " generateSecret", " chainhash", "baseFile", "BaseHash", "BaseSecret", " generatehash", "baseSecret", " generateFile", " generateHash", " chainSecret", "basehash", " chainHash"], "name": ["ame", "NAME", "prefix", "resource", "image", "parent", "style", "n", "data", "hello", "part", "alias", "member", "definition", "hash", "named", "key", "type", "class", "create", "Name", "base", "user", "object", "id", "address", "names", "account", "string", "file", "host", "path", "normal", "word", "secret"], "password": ["crypt", "prefix", "text", "padding", "attribute", "auth", "priv", "profile", "data", "username", "sword", "phrase", "hash", "input", "paste", "key", "wallet", "wd", "pass", "code", "source", "seed", "token", "string", "account", "stroke", "security", "device", "pattern", "diff", "words", "path", "word", "value", "Password", "secret", "PASS"], "digest": ["Diger", "Digusher", "mdester", "DigEST", "Digger", "modest", "modester", "signger", "Digester", "mdEST", "digEST", "Digest", " digested", "Digr", "mdr", "decr", "signusher", "signest", "digger", " diger", "signer", " digusher", "moder", " digester", " digger", "Digested", "digester", "decester", "signester", "decest", "diger", "digested", "mdest", "decEST", "digusher", "digr", "modested"]}}
{"id1": "16590954", "id2": "7458833", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"createJAR": [" createJJar", "createJPAR", "createPHAP", "createJARS", " createPHJar", "createJPJar", "createPHAR", "createAMARS", "createJPARS", "createAMAR", " createPHARS", " createJARS", " createJAP", " createPHAR", "createPHJar", "createAMAP", "createJAP", "createJJar", "createAMJar", "createPHARS", " createPHAP", "createJPAP"], "fileString": ["FileStream", "basestring", "FileString", "FileArray", "fileStream", " fileStr", "FileStr", "fileText", " fileName", " fileText", "loadName", "fileStr", "resourceText", "modelString", " fileFile", "modelStream", "modelStr", "fileName", "lineArray", " filestring", "resourceString", "FileText", "modelText", " fileArray", "baseString", "FileFile", "loadstring", "fileFile", "loadString", "Filestring", "baseStr", "fileArray", "FileName", "loadText", "resourceStr", "baseFile", "resourceStream", "lineString", "lineName", "filestring", "linestring"], "ext": ["prot", "text", "req", "ex", "url", "txt", "append", "xt", "ax", "Ext", "EXT", "info", "data", "version", "external", "dep", "zip", "str", "exp", "end", "type", "code", "class", "config", "filename", " Ext", "v", "desc", "dist", "name", "app", "exe", "extra", "path", "x", "content", "format", "enc"], "file": ["wave", "page", "pe", "log", "FILE", "url", "resource", "unit", "ile", "le", "module", "parent", "b", "build", "force", "flat", "single", "socket", "part", "folder", "model", "f", "it", "zip", "output", "h", "test", "let", "jar", "class", "source", "filename", "l", "work", "use", "db", "files", "base", "place", "ger", "queue", "bar", "local", "cache", "change", "name", "up", "binary", "per", "File", "full", "get", "line", "path", "buffer", "fe", "http", "fp", "doc"], "i": ["uri", "j", "ori", "si", "limit", "f", "ni", "it", "index", "ci", "iu", "key", "uni", "abi", "mini", "multi", "li", "di", "l", "mi", "hi", "pi", "ip", "xi", "eni", "slice", "ind", "yi", "v", "c", "I", "ai", "phi", "ini", "ii", "ui", "x", "qi", "p"], "dir": ["prefix", "doc", "direction", "url", "uri", "module", "rel", "loc", "DIR", "info", "data", "folder", "output", " directory", "zip", "area", "str", "coll", "type", "cur", "jar", "pkg", "class", "config", "directory", "filename", "src", "tmp", "db", "base", "id", "div", "string", "ir", "dist", "name", "domain", "path", "Dir", "format", "manager", "lib"], "jarFile": ["javaDir", "jarFolder", " jarFolder", "javafile", "reportSourceFile", "tarF", " jarFiles", " jarLine", "archiveFile", "jarDir", " jarSourceFile", "reportF", " jarfile", "jarF", "sessionfile", "jarSourceFile", "sessionLine", "javaFolder", "archiveFolder", "archiveFiles", "reportfile", " jarDir", "javaF", "tarfile", "archiveDir", "javaFile", "sessionFile", "jarLine", "tarFile", "tarSourceFile", "jarFiles", "javaFiles", "tarLine", "sessionSourceFile", "javaSourceFile", "jarfile", "reportFile"], "fstrm": ["fstrM", "fsrm", "fstrum", "fstrmd", "Fsrmd", "Fsrm", "fbrum", " fstrM", "fbrcm", " fsrm", "fsrmd", "fbrM", "fstrcm", "Fstrm", "fsrcm", "fsrum", "fbrm", "fgrm", "FstrM", "Fstrmd", "fstcm", "fstmd", "fstum", "FsrM", "fstm", " fstrum", "Fsrcm", "fstM", " fstrcm", "fgrmd", "fgrM", " fsrcm", "Fstrcm", " fsrum", "fsrM", "fgrcm", " fsrM"], "in": ["to", "m", "into", "ins", "image", "In", "n", "init", "io", "sync", "inc", "socket", "part", "f", "gin", "input", "din", "IN", "inn", "read", "conn", "s", "rin", "pull", "is", "reader", "inside", "nin", "stream", "l", "login", "inner", "min", "r", "id", "ac", "bin", "c", "up", "binary", "pin", "or", "again", "p"], "out": ["to", "m", "writer", "flow", "resource", "image", "server", "call", "plain", "null", "b", "connection", "init", "off", "io", "outer", "this", "sync", "outside", "inc", "part", "channel", "output", "group", "all", "exp", "Out", "conn", "source", "client", "self", "inner", "outs", "user", "v", "bin", "c", "err", "up", "net", "OUT", "pool", "plus", "again", "line", "doc"], "temp": ["doc", "writer", "unit", " Temp", "server", "dest", "build", "form", "porary", "single", "store", "Temp", "output", "folder", "wrap", "f", "it", "zip", "input", "controller", "archive", "storage", "template", "test", "key", "home", "source", "iter", "api", "Output", "tmp", "config", "directory", "db", "dump", "base", "local", "cache", "pipe", "export", "v", "c", " tmp", "w", "full", "fake", "get", "path", "clean", "or", "buffer", " temporary", "emp", "tem", "p"], "fstrm2": ["fhrms02", "fstrp0", "fhrms1", "fhrm1", "fstrmr2", "fstrmr002", "fstm0", "fhrm02", "fstrms0", "fhrms002", "fstrM0", "fstM1", "fstrm1", "fstm1", "fstrms02", "fstrM1", "fstrms002", "fstrM02", "fhrm002", "fstM2", "fstM0", "fstrms1", "fstrmr1", "fstm2", "fstrm0", "fstrM2", "fhrms2", "fstrmr02", "fhrm2", "fstrM002", "fstrms2", "fstrm002", "fstrp2", "fstrm02", "fstrp1"], "ostrm": ["ophrm", "obrm", "obrt", "oscmr", "oodrem", "oodrob", "otherrm", "ophrt", "obsrm", "ostm", "obmr", "ostrom", "ostrem", "obsrt", "ooprm", "otherrom", "ostrt", "oscrm", "oodrt", "oscrt", "odm", "oopmr", "istrt", "istrom", "istmr", "obrom", "oodrm", "ooprt", "odmr", "odrt", "ophmr", "istrm", "ostrob", "othermr", "otherrt", "oscm", "ophm", "odrm", "ooprom", "obsrem", "obsrob", "ostmr"], "docFile": ["docF", "documentF", " docFiles", " docF", " docDir", "documentFile", "docDir", "docFiles", "DocFiles", "documentDir", "documentFiles", "DocF", "DocDir", "DocFile"]}}
{"id1": "8062076", "id2": "10281203", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 1, "substitutes": {"updateUser": ["UpdateAccount", "UPDATEAccount", "changeRole", "UPDATERole", "UPDATEPerson", "updateAccount", "changeAccount", "UPDATEUser", "UpdatePerson", "updateRole", "changePerson", "updatePerson", "UpdateRole", "changeUser", "UpdateUser"], "portalUserBean": ["portalUserDeane", "portalGroupBean", "portalFileBans", "portalFileBan", "portalUserBoAN", "portalUserBeann", "portalClientBEAN", "portalClientBEam", "portalUserPeAN", "portalUserEans", "portalGroupBEann", "portalUserPlan", "portalUserBoan", "portalUserBam", "portalClientBeAN", "portalUserPlAN", "portalUserBan", "portalUserBegan", "portalUserEane", "portalUserDeAN", "portalUserBegAN", "portalClientBEan", "portalUserDean", "portalUserPeean", "portalFileBein", "portalClientBeans", "portalFileBane", "portalUserPlane", "portalUserBEans", "portalClientBeane", "portalUserPeans", "portalUserBegans", "portalUserBEane", "portalGroupBEan", "portalClientBean", "portalClientBEane", "portalGroupBeAN", "portalUserEAN", "portalFileBeAN", "portalUserPeane", "portalFileBean", "portalUserEin", "portalGroupBEans", "portalUserBeam", "portalUserBEan", "portalUserBeAN", "portalClientBEans", "portalUserBegann", "portalUserBin", "portalUserEan", "portalFileBAN", "portalFileBin", "portalGroupBeans", "portalUserPlean", "portalUserBoam", "portalUserBeans", "portalUserBeane", "portalUserBein", "portalUserBEann", "portalUserBEam", "portalUserBoin", "portalUserPean", "portalUserBeean", "portalUserBane", "portalUserBoans", "portalClientBeam", "portalUserBAN", "portalUserBoane", "portalUserDeans", "portalGroupBeann", "portalUserBann", "portalUserBEAN", "portalFileBeean", "portalFileBeane", "portalFileBeans", "portalUserBans", "portalGroupBEAN"], "authSession": ["httpsession", "AuthConn", "uthConn", "authClient", "AuthSession", " authClient", "Authsession", "authStream", "uthClient", "AuthConnection", "AuthClient", " authsession", "uthsession", "httpSession", "AuthStream", "authsession", " authStream", "authConnection", "uthSession", " authConnection", "httpConnection", "authConn", " authConn", "httpStream"], "dbDyn": ["dbDoneien", "dbdyl", "cbDYN", "dbCyn", "dbIsyn", "bbFyn", "libDys", "dbDoynam", "dbNgn", "dbCodahn", "DbCSyn", "dbDynam", "dbdynam", "dbDefyn", "DbCyn", "DbSyn", "DbDYN", "dbCSyn", "dbCym", "dbDoneYN", "dbPyr", "dbWYN", "dbBahn", "dbDefSyn", "dbDefys", "libDyn", "dbBynam", "dbdYN", "DbSyl", "dbWSyn", "DbDyn", "dbPahn", "dbSyn", "dbNyl", "dbDsyn", "dbIyn", "DbDynam", "dbPSyn", "libDym", "cbDien", " dbDsyn", "dbSYN", "dbDym", "dbDahn", "bbFSyn", "dbdSyn", "cbDyn", "DbDSyn", "DbPahn", " dbDoynam", "dbBYN", "dbdyn", " dbDyr", "dbDyr", "dbFsyn", "dbNYN", "dbCynam", " dbByr", "dbWsyn", "dbDoneyn", "bbDYN", "dbDoyn", "dbBsyn", "dbCys", "dbDys", "bbFYN", "DbSgn", "dbSgn", "DbPSyn", "dbCodyn", "dbCYN", "dbDefym", "dbPyn", "dbDYN", "dbdgn", "dbDoyan", "dbDSyn", "dbDgn", " dbBynam", "dbFSyn", "dbBien", "dbByn", "dbDien", "DbPyr", " dbByn", "bbFsyn", " dbDynam", "libDSyn", "dbDyan", "DbCynam", "bbDSyn", " dbDoyn", "cbBynam", "dbFynam", "dbIynam", "dbFyr", "DbDyl", "dbCodSyn", "dbNyn", "cbByn", "cbBYN", " dbDosyn", "DbDyr", "DbPyn", "dbDoneynam", " dbDyan", "dbFYN", "dbDyl", "cbDynam", "cbBien", "dbFyn", "dbByr", "dbWyn", "bbDsyn", "dbDosyn", "dbSyl", "dbFyan", "dbBSyn", "DbDahn", " dbBsyn", "bbDyn", "dbDoyr", " dbDoyan", "DbCYN", "dbCodyr", "DbDgn", "DbSYN", "dbIyan"], "ps": ["css", "ls", "ppa", "proxy", "pe", "res", "js", "http", "pes", "ins", "details", "als", "mp", "ss", "pl", "os", "pg", "rs", "PS", "ns", "this", "aps", "cop", "pos", "pse", "py", "hs", "vs", "pb", "pa", "lines", "ips", "ms", "s", "fs", "PD", "ws", "Ps", "pr", "posts", "properties", "les", "qs", "pps", "ports", "ras", "eps", "ils", "po", "pc", "ops", "pre", "sp", "ts", "ons", "per", "as", "gs", "jp", "cs", "ups", "where", "pers", "fe", "pp", "bs", "its", "p", "ks", "post", "ds"], "sql": ["ls", "fn", "description", "sol", "statement", "log", "ln", "url", "ssl", "ll", "sf", "html", "details", " SQL", "general", "rel", "lock", "os", "sv", "acl", "msg", "sys", "session", "sync", "shell", "csv", "sb", "spec", "zip", "str", "su", "nl", "job", "s", "conn", "sq", "dl", "pr", "comment", "l", "seed", "sg", "db", "util", "eps", "id", "string", "params", "select", "repl", "ob", "printf", "sl", "function", "query", "setup", "serial", "http", "fp", "SQL", "ql", "join"], "idList": ["dateInfo", "dateList", "idSet", "userSet", "IdSet", "IdTree", "IdList", "idTree", "userlist", "addresslist", "idlist", "addressLIST", "Idlist", "IdLIST", "addressList", "IdInfo", "idColl", " idColl", "dateTree", "userList", "idLIST", " idInfo", "dateColl", "idInfo", " idTree", "userLIST", "IdColl", "addressSet"], "num": ["mon", "norm", "nu", "fn", "sol", "gen", "np", "unit", "one", "nom", "miss", "count", "uu", "n", "loc", "form", "init", "nr", "off", "um", "inc", "no", "pos", "du", "loop", "result", "sn", "hex", "sum", "NUM", "index", "su", "Num", "numbered", "uni", "temp", "i", "nov", "multi", "size", "mn", "len", "number", "coord", "oct", "node", "div", "mult", "con", "lim", "ord", "begin", "dim", "umi", "gru", "non", "zero", "nb", "nam", "dom", "lang", "nn"], "i1": [" i81", " i11", " i0", "ci1", "ii1", "I0", "I81", "xi4", "I1", "xi11", "I5", " i5", "xi1", "ci5", "i11", "i0", "i5", "ii11", "ci0", " i4", "i81", "xi81", "ii4", "ii81", "i4", "ci81"]}}
{"id1": "23398710", "id2": "23611770", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 0, "substitutes": {"getUser": ["getPerson", "createProfile", "newProfile", "newAccount", "createAccount", "newUser", "newPerson", "createPerson", "getProfile", " getProfile", "getAccount", " getAccount", " getPerson", "createUser"], "get": ["p", "url", "resource", "call", "build", "g", "view", "body", "got", "remote", "google", "init", "like", "method", "ge", "this", "single", "GET", "model", "it", "status", "check", "Get", "set", "read", "handle", "i", "consumer", "create", "api", "parse", "pull", "cli", "sign", "send", "object", "token", "show", "give", "cache", "c", "v", "start", "service", "find", "entity", "json", "query", "invoke", "put", "update", "http", "request", "open", "post"], "client": ["p", "console", "url", "ssl", "resource", "server", "call", "copy", "connection", "manager", "io", "method", "this", "session", "channel", "output", "result", "connect", "conn", "i", "consumer", "api", "bird", "cli", "web", "contact", "Client", "send", "control", "https", "con", "handler", "app", "service", "per", "php", "secure", "http", "request", "open"], "response": ["wave", "resp", "page", "writer", "subject", "respond", "uri", "resource", "message", "server", "image", "report", "view", "Response", "connection", "body", "successful", "data", "version", "serv", "output", "application", "status", "document", "result", "site", "reply", "index", "error", "results", "api", "tree", "send", "queue", "object", "handler", "success", "service", "relation", "full", "json", "generation", "collection", "http", "feed", "request", "offer", "received"], "statusCode": ["StatusC", "statusC", "successCode", " statusType", "statuscode", "responseCode", "statusType", "StatusType", "responseType", " statusC", " statuscode", "Statuscode", "StatusCode", "successcode", "successC", "successType"], "sBuf": ["sBbuff", " sBuff", "sPluf", " sFbuf", " sBlu", "sQbuf", "sBBumb", " sFlu", "sBerumb", "sAbuf", "sBeruf", "sFumb", " sFumb", "sFlu", " sAbuf", "sQumb", "sBerlu", "sBbuf", "sBlu", " sFuf", "sBBuff", "sPlbuf", "sBuff", "sFuff", " sAbuff", " sBbuff", " sBBuf", " sBBbuf", "sBerbuf", "sAuf", "sAbuff", "sFbuf", "sAuff", " sBumb", " sAuff", "sQuf", "sPllu", "sFuf", "sFbuff", "sBBbuf", "sBumb", "sBBbuff", "sBBuf", "sPlumb", " sBBumb", " sBbuf", " sAuf"], "linea": ["Lineha", " lineA", "idea", "ideA", " lineha", "lineA", "linva", "linas", " lineas", "Lineas", "lineha", "Linea", " lineva", "ideva", "linha", "linA", "lineas", "lineva", "Lineva", "ideas", "LineA", "lina"], "reader": ["writer", "e", "server", "rx", "rer", "ser", "io", "data", "ner", "reading", "rar", "parser", "f", "result", "Reader", "input", "editor", "upper", "read", "row", "player", "i", "builder", "iter", "driver", "bird", "stream", "er", "l", "rr", "worker", "inner", "r", "handler", "loader", "per", "cher", "layer", "keeper", "ler", "pointer", "buffer", "wrapper", "oder", "line", "feed", "ri", "right"], "salida": [" salicka", "bilicka", "salara", "salido", " salidas", "saticka", "milida", "slida", "bilara", "salicka", "bilido", "milidas", "Salara", "Salida", "slidas", " salanda", "satara", "satida", "Salido", "satido", "Salidas", "salidas", "slara", "milanda", " salido", "milido", "slanda", "salanda", "Salanda", " salara", "bilida"], "user_firstname": ["user_thirdname", "user_fullname", "user_realnames", "user_lastName", "user_headame", "user_firstName", "user_realname", "user_lastame", "user_fullName", "user_firstame", "user_thirdphone", "user_realame", "user_fullame", "user_firstphone", "user_lastnames", "user_realName", "user_fullnames", "user_firstnames", "user_headname", "user_headphone", "user_lastphone", "user_thirdame"], "user_lastname": ["user_fullname", "user_pastName", "user_lastName", "user_lastword", "user_firstword", "user_lastame", "user_pastaddress", "user_fullName", "user_firstame", "user_fullame", "user_longname", "user_longaddress", "user_longame", "user_fulladdress", "user_pastame", "user_lastnames", "user_fullnames", "user_firstnames", "user_pastname", "user_fullword", "user_longName", "user_lastaddress"]}}
{"id1": "14053882", "id2": "8164056", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", " enrypt", " enryption", " encryptipher", " encode", "encryption", "enccode", " encryptrypt", " encryptcode", "encipher", " encryptryption", " enipher", "decipher", "decryption", "deccode"], "plaintext": ["givenstring", "batstring", "encryptedstruct", "plainstruct", "protectedText", "plainText", " plainText", "encryptedcontent", "givensource", "batsource", "giventext", "protectedcontent", "battext", "plaincontent", "plainfont", "encryptedText", "batfont", " plainsource", " plaincontent", " plainfont", "plainstring", "encryptedtext", " plainstring", " plainstruct", "protectedtext", "plainsource", "givenfont", "protectedstruct"], "md": ["mad", "m", "hd", " MD", "Cmd", "mp", "dr", "cmd", "sha", "pg", "material", "data", "mo", "ph", "dig", "dd", "mc", "mag", "d", "od", "mage", "meta", "mb", "hm", "ms", "code", "amd", "mg", "dm", "bd", "wd", "cm", "metadata", "pkg", "pd", "MD", "ad", "da", "mac", "nm", "mand", "po", "mm", "ma", "sm", "dc", "am", "cb", "pm", "kg", "mt", "cd", "mu", "mod", "dh", "alg", "df"], "raw": ["wave", "buf", "text", "partial", "shared", "array", "auth", "original", "pack", "image", "null", "sha", "rc", "empty", "data", "RAW", "dec", "pure", "input", "hex", "row", "instance", "ack", "rew", "stream", " RAW", "string", "load", "initial", "Raw", "binary", "full", "clean", "response", "unknown", "unsigned", "wrapper", "buffer", "json", "serial", "enc", "feed", "block"], "hash": ["secret", "ash", "log", "auth", "array", "url", "message", "image", "html", "length", "sha", "rh", "version", "data", "her", "hex", "sum", "index", "password", "href", "h", "key", "kh", "header", "ashes", "base", "mac", "id", "cache", "ha", "Hash", "sh", "response", "buffer", "block"]}}
{"id1": "8973505", "id2": "21013026", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "label": 0, "substitutes": {"writeFileType": ["writeFilesHeader", "createFileType", "writeFileHeader", "writeFILEHeader", "writeFILETypes", "writeFILEtype", "writeFiletype", "writeFilesTypes", "createFileHeader", "createFilestype", "writeFilestype", "writeFileTypes", "writePageTypes", "writePagetype", "writePageType", "createFiletype", "createFilesTypes", "createFilesHeader", "createFileTypes", "writeFilesType", "createFilesType", "writeFILEType", "writePageHeader"], "uriFile": ["URIfile", "urifile", "URIFilename", "riFiles", "uifile", "URIUrl", "uriFiles", "filenameFile", "uiFiles", "filenameFilename", "uiUrl", "URIFiles", "uriFilename", "riUrl", "filenamefile", "uiFile", "rifile", "URIFile", "riFile", "riFilename", "filenameFiles", "uriUrl"], "outputfile": ["resourcefiles", "unitfile", "outputfilename", "outputstring", "resourcefilename", "Outputfull", "inputfiles", "unitstring", " outputdir", "inputFile", "unitfilename", "outputfiles", "outputFile", "inputdir", "inputstring", " outputFile", " outputfull", "inputfull", "resourcestring", "inputfilename", "outputfull", "inputfile", "resourcefile", "unitfiles", "outputdir", "OutputFile", "Outputdir", "Outputfile"], "num": ["span", "nu", "unit", "col", "length", "count", "master", "offset", "n", "term", "amount", "inc", "limit", "no", "loop", "index", "NUM", "split", "sum", "batch", "Num", "multi", "len", "number", "coord", "mult", "con", "dim", "initial", "name", "umi", "zero", "nb", "nam", "common"], "writer": ["ee", "widget", "wr", "report", "wan", "null", "data", "writing", "socket", "written", "part", "entry", "Writer", "temp", "r", "wa", "wire", "root", "per", "wb", "wave", "page", "unit", "e", "we", "message", "wt", "server", "style", "editor", "index", "key", "type", "rw", "xml", "element", "builder", "width", "er", "worker", "walker", "object", "handler", "loader", "w", "writers", "layer", "format", "feed", "book", "master", "io", "outer", "later", "writ", "creator", "out", "wl", "function", "wrapper", "ler", "buffer", "manager", "write", "lock", "method", "session", "engine", "journal", "external", "output", "document", "ws", "source", "driver", "header", "riter", "inner", "window", "service", "office", "author"], "uri": ["component", "term", "verb", "sequence", "directory", "cli", "eni", "feature", "wiki", "token", "string", "file", "URI", "origin", "iri", "reference", "context", "ui", "query", "nor", "unit", "resource", "message", "connection", "remote", "link", "winner", "folder", "nil", "uni", "plugin", "i", "element", "metadata", "theme", "gi", "handler", "umi", "oid", "qi", "database", "prefix", "attribute", "course", "doi", "du", "route", "pi", "node", "id", "binary", "location", "picture", "hub", "collection", "http", "direction", "ori", "username", " URI", "range", "document", "href", "uid", "source", "multi", "filename", "di", "li", "mi", "base", "address", "ilo", "ri"], "counter": ["enter", "book", "page", "Counter", "server", "clock", "parent", "count", "master", "offset", "nr", "race", "info", "outer", "step", "parser", "ner", "hello", "sequence", "cookie", "loop", "entry", "creator", "meter", "result", "timer", "controller", "second", "index", "coll", "batch", "ver", "time", "instance", "i", "comment", "iter", "record", "trace", "keep", "ter", "expression", "worker", "number", "inner", "handler", "repeat", "cpu", "loader", "name", "continue", "computer", "reference", "inter", "vector", "condition", "runner", "current", "currency", "pointer", "lc", "collection", "keeper", "processor"], "reader": ["e", "rx", "rer", "riter", "io", "ner", "reading", "parser", "rar", "in", "Reader", "editor", "finder", "upper", "read", "row", "iter", "driver", "bird", "ruby", "l", "er", "rr", "lr", "inner", "stream", "ger", "worker", "r", "handler", "ir", "loader", "per", "layer", "keeper", "ler", "buffer", "oder", "feed", "ri"], "url": ["ls", "page", "text", "ssl", "resource", "image", "server", "connection", "io", "link", "blog", "channel", "www", "URL", "download", "plugin", "source", "config", "client", "li", "stream", "l", "web", "base", "user", "id", "address", "string", "file", "sl", "path", "Url", "http", "feed", "ri", "browser"], "myConnection": ["myconnection", "MyConnector", "someConnect", "MyConnection", "someReader", "myConnect", "yourConnector", " myConnector", "myConnector", "yourConn", "MyConnect", "MyConn", " myConnect", " myconnection", " myConn", "someConnection", "yourConnection", "someConn", "Myconnection", "yourconnection", "MyReader", "myConn"], "myReader": [" myRead", "myWriter", "MyWriter", "yourWriter", " myParser", "yourReader", "yourRead", "yourParser", "myParser", "myRead", "MyReader", "MyRead", "MyParser", " myWriter"], "line": ["page", "text", "pe", "LINE", "log", "lf", "message", "frame", "le", "style", "letter", "cell", "data", "link", "part", "no", "range", "entry", "du", "rule", "block", "lin", "cl", "lines", "end", "key", "inline", "row", "el", "code", "error", "element", "column", "pass", "source", "comment", "parse", "header", "l", "use", "base", "user", "point", "id", "look", "day", "string", "file", "Line", "liner", "name", "response", "word", "lc", "non", "note", "feed", "ri"], "linecount": ["Linenumber", "pagecount", "pageindex", "lineCount", " linesize", "Linecache", "linecache", " linecache", "lettercount", "lineindex", "rowcount", "pagenumber", "Linesize", "lettersize", "linenumber", "linesize", "LineCount", " lineindex", "linelen", " lineCount", " linelen", "rowcache", "rowlen", "pageCount", " linelength", "linelength", "letterlength", "Lineindex", " linenumber", "letterlen", "rowsize", "rowlength", "Linecount"], "hasOWL": [" hasOWDL", "hasODL", " hasEWl", "hasEWLA", " hasOWLA", " hasOWLM", "hasOULA", "HasOWLL", "hasEWDL", " hasEWLM", "HasEWLL", "HasEWLA", "hasOWl", "hasEWl", "hasOWSLL", "hasEFLM", "hasODLA", "hasBYL", "hasEFl", "hasOUL", "hasOULL", " hasEWL", "hasBYl", " hasOWl", "hasOWLM", " hasEWLA", " hasEWDL", "HasOWLA", "HasEWLM", " hasEWLL", "hasODLL", "hasOWSL", "hasBYDL", " hasOWLL", "hasOWSDL", "hasEWLM", "HasEWL", "hasOWSl", "hasODLM", "hasEWL", "hasEWLL", "HasOWL", "hasEFL", "hasOWLA", "hasOWLL", "hasOWDL", "hasODl", "HasOWLM", "hasBYLL", "hasEFLA", "hasOULM"], "hasRDFS": ["hasGRUFs", "hasGRDFS", "hasGRDFs", "hasXDFE", "hasRNFS", "hasXDFS", "hasCDPS", "hasRdfU", "hasCDFES", "hasRDFs", "hasRUFSU", "hasRDPAST", "hasXDPU", "hasRdfS", "hasRDPU", "hasXDPS", "hasRDFU", "hasRNFs", "hasRdfE", "hasCDPE", "hasRDPES", "hasRNFU", "hasRUFs", "hasRDFES", "hasXDPE", "hasRFs", "hasRUFS", "hasXDFs", "hasCDPs", "hasRNFE", "hasRTFE", "hasGRDFAST", "hasRUFAST", "hasRTFS", "hasRdfs", "hasRDPSU", "hasRFSU", "hasRDPS", "hasGRUFAST", "hasRFAST", "hasRDFSU", "hasRDFE", "hasCDFS", "hasCDFs", "hasGRUFS", "hasXDPs", "hasRDPE", "hasCDFE", "hasGRDFSU", "hasRTFs", "hasGRUFSU", "hasXDFU", "hasRTFES", "hasRFE", "hasRFES", "hasCDPES", "hasRDFAST", "hasRFS", "hasRDPs"], "hasRDF": ["hasUDF", "HasRRdf", "hasRUF", "hasDDF", " hasRRMF", "yesDOW", "yesRMF", "HasRdf", "hasRRDEF", "hasMRDEF", "hasUMF", " hasRMF", "yesRDP", "HasRRDF", "hasURMF", "hasSRdf", "hasRRdf", "hasROW", "hasRMF", "hasNRMF", "hasNRFD", "hasNRUF", "hasRRMF", "hasMRDP", "hasUOW", "hasRFD", "hasDMF", "yesDDF", "hasUDP", " hasRRFD", "hasRDEF", "yesDDP", "hasSRDF", " hasRFD", "yesDMF", "yesROW", "yesRDF", " hasRRUF", "HasRDP", "hasMRdf", "hasNRDF", "hasRRUF", "hasSRDEF", "hasRRDP", "HasRRDP", "hasURDF", "hasDDP", " hasRRDF", "HasRDEF", "HasRDF", "hasMRDF", "hasRRFD", "hasRRDF", "hasSRDP", " hasRUF", "hasDOW", "hasURFD", "hasURUF", "HasRRDEF", "hasRdf", "hasRDP"]}}
{"id1": "339517", "id2": "19096138", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getClassFile": ["getSourceCode", "getCodeFile", "createCodeFile", "createClassFile", "getClassFiles", "createCodeCode", "createCodeFiles", "getSourceLoader", "createClassLoader", "createClassCode", "createCodeLoader", "getCacheFiles", "getSourceFile", "getCodeCode", "getClassLoader", "getCacheCode", "getCodeFiles", "getCacheLoader", "createClassFiles", "getSourceFiles", "getCacheFile", "getClassCode", "getCodeLoader"], "name": ["ame", "NAME", "prefix", "uri", "default", "resource", "parent", "n", "connection", "info", "data", "this", "part", "definition", "str", "named", "key", "type", "pass", "i", "class", "source", "Name", "config", "size", "filename", "base", "object", "id", "address", "names", "string", "file", "loader", "path", "request"], "url": ["ls", "page", "uri", "ssl", "resource", "ll", "server", "image", "b", "connection", "io", "this", "f", "rule", "URL", "el", "instance", "i", "class", "source", "reader", "config", "rl", "l", "base", "resources", "user", "r", "found", "id", "string", "file", "loader", "service", "sl", "host", "Url", "http", "feed", "open"], "in": ["ex", "ins", "ssl", "resource", "image", "In", "b", "ax", "n", "init", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "lin", "inas", "inn", "read", "out", "s", "i", "is", "win", "source", "reader", "rin", "inside", "nin", "stream", "login", "inner", "r", "id", "token", "ac", "bin", "con", "err", "ini", "as", "again", "isin"]}}
{"id1": "6299111", "id2": "17116123", "code1": "    public static String retrieveQ(String urlToRetrieve) throws MalformedURLException, IOException {\n        URL url = new URL(urlToRetrieve);\n        URLConnection uc = url.openConnection();\n        InputStream is = uc.getInputStream();\n        BufferedReader in = new BufferedReader(new InputStreamReader(is));\n        StringBuilder output = new StringBuilder(16384);\n        String str;\n        boolean first = true;\n        while ((str = in.readLine()) != null) {\n            if (!first) output.append(\"\\n\");\n            first = false;\n            output.append(str);\n        }\n        in.close();\n        System.err.println(((HttpURLConnection) uc).getResponseMessage());\n        return output.toString();\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"retrieveQ": ["refetchUE", "retireQ", "retrievingText", "refrieveURL", "retireText", "retrievingQ", "retetchUE", "refrieveQ", "retrieveURL", "refetchQ", "retrieveText", "retetchQ", "retrievingURL", "refrieveText", "refetchURL", "retetchURL", "retireUE", "retetchText", "retrievingUE", "refrieveUE", "refetchText", "retireURL", "retrieveUE"], "urlToRetrieve": ["urltoRetrive", "urlToRetry", "urltoRetrieve", "urlToRerip", "urlTOretquire", "urlToReire", "urlTOretire", "urlTOretrieve", "urlToRetrive", "urlToretquire", "urlToResrip", "urltoRerieve", "urlToRequire", "urlToReprip", "urlTORetquire", "urltoRery", "urlToRetrip", "urlToResry", "urlToRery", "urlToRerieve", "urlToretire", "urlToResrive", "urlToretrive", "urlTORetrive", "urlToRerive", "urlTORetrieve", "urlTOretrive", "urltoRerive", "urltoRetrip", "urltoRetry", "urltoRerip", "urlToResrieve", "urlTORetire", "urlToRetquire", "urlToReprieve", "urlToRepry", "urlToRetire", "urlToretrieve", "urlToReprive"], "url": ["ur", "ls", "page", "uri", "ssl", "resource", "ll", "server", "build", "connection", "loc", "ul", "this", "blog", "bc", "f", "impl", "URL", "www", "bel", "cur", "conn", "config", "stream", "web", "l", "base", "r", "ir", "c", "sl", "plug", "path", "Url", "lc", "q", "http", "bb", "open"], "uc": ["UC", "uri", "uu", "connection", "loc", "rc", "tc", "uci", "ul", "usc", "um", "bc", "unc", "soc", "connect", "mc", "nc", "ci", "cas", "auc", "cur", "conn", "cc", "ws", "irc", "cu", "ub", "cca", "cms", "client", "cus", "cli", "web", "oc", "sc", "xc", "ac", "exec", "con", "c", "pc", "cci", "fc", "up", "uca", "ucc", "context", "lc", "http", "com"], "is": ["ins", "uri", "isi", "isl", "os", "init", "iso", "bis", "IS", "us", "inn", "isc", "ci", "out", "s", "conn", "ios", "i", "api", "src", "ip", "inner", "iss", "ir", "ais", "ris", "has", "Is", "ai", "as", "ui", "isa", "was", "ri", "isin", "isu", "its"], "in": ["into", "ins", "In", "b", "connection", "rc", "init", "io", "inc", "f", "impl", "it", "input", "din", "IN", "inn", "lin", "out", "s", "conn", "i", "kin", "reader", "src", "inside", "nin", "stream", "login", "inner", "r", "con", "c", "bin", "ir", "ic", "ai", "ini", "as", "arin", "again", "isin"], "output": ["prefix", "page", "text", "fn", "exit", "console", "unit", "message", "resource", "write", "plain", "null", "summary", "letter", "outer", "data", "later", "writing", "external", "bc", "written", "application", "document", "result", "input", "sort", "done", "out", "Output", "config", "foo", "web", "cli", "queue", "object", "string", "exec", "information", "ilo", "continue", "binary", "ou", "pre", "next", "response", "operation", "put", "office", "again", "value", "fp"], "str": ["Str", "text", "stri", "fr", "arr", "STR", "e", "st", "dr", "data", "step", "f", "spec", "result", "input", "coll", "out", "type", "cur", "code", "pass", "i", "pr", "iter", "l", "len", "tr", "r", "id", "div", "string", "br", "err", "start", "name", "sr", "sl", "next", "sp", "path", "lc", "enc", "line", "cr", "char"], "first": ["one", "parent", "null", "count", "st", "prev", "empty", "before", "last", "follow", "primary", "all", "now", "second", "error", "only", "then", "th", "top", "true", "self", "must", "same", "found", "string", "given", "leading", "seen", "alpha", "start", "initial", "success", "third", "left", "full", "next", "used", "fast", "First", "always", "again", "use", "right"]}}
{"id1": "18489832", "id2": "10728243", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"downLoadZippedFile": [" doLoadZaggedFiles", " doLoadZedFiles", " doLoadZippedFiles", " doLoadzippedFiles", " doLoadZaggedContent", " doLoadZippingDir", " doLoadzippingContent", " doLoadZippingFile", " doLoadZaggedDir", " doLoadzippedFile", " doLoadzippingFile", " doLoadZippingContent", " doLoadZaggedFile", " doLoadzippingFiles", " doLoadzippedContent", " doLoadZedDir", " doLoadZippedFile", " doLoadZedContent", " doLoadzippedDir", " doLoadzippingDir", " doLoadZippingFiles", " doLoadZedFile", " doLoadZippedContent", " doLoadZippedDir"], "url": ["ur", "proxy", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "b", "connection", "event", "store", "link", "f", "zip", "route", "URL", "download", "i", "source", "pull", "config", "client", "l", "web", "lr", "base", "r", "file", "c", "loader", "sl", "bug", "Url", "or", "update", "http", "lib", "open"], "destDir": ["destFile", " destFile", " destFolder", "tempFile", "destdir", "destFolder", "tmpdir", "tempFolder", " destdir", "tmpDirectory", " destDIR", "tmpDIR", "outputFile", "DestFile", "outputDirectory", " destDirectory", "DestDir", "tempDIR", "tempDir", "outputDIR", "outputDir", "outputFolder", "DestDIR", "destDIR", "destDirectory", "outputdir", "tmpDir", "DestFolder"], "urlConnection": ["urlNetwork", "webConnect", "URLChannel", "urlConnect", "URLconnection", "webChannel", "httpNetwork", "httpFactory", "URLConnect", "webconnection", "downloadNetwork", "webConnection", "URLConnection", "fileConn", "fileFactory", "urlConn", "urlChannel", "urlconnection", "downloadFactory", " urlConnect", " urlChannel", "httpConnection", "fileNetwork", "fileConnection", "downloadConnection", "urlFactory", "downloadConn", " urlconnection", "httpConn"], "tmpFile": ["destFile", "mpfile", "mpFile", " tmpFolder", " tmpPath", "partfile", "mpPath", "tempPath", "tmpFolder", "destWorld", "zipFiles", "tmpfile", "TempPath", "tempFile", "tmpFiles", "destFolder", "tempFiles", "tempEntry", " tmpFiles", "partFolder", "tmpPath", "partFile", "mpDir", "TempWorld", "destPath", "tmpLine", "Tempfile", "tempLine", "partDir", " tmpLine", " tmpfile", "tmpEntry", " tmpDir", "mpFolder", "zipFile", "tempfile", "zipfile", " tmpWorld", "tempDir", "destEntry", "zipLine", "mpFiles", "tmpWorld", "destfile", "tmpDir", "TempFile", " tmpEntry"], "in": ["ex", "ins", "In", "copy", "ax", "n", "connection", "en", "init", "info", "data", "sync", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "Out", "conn", "cin", "i", "is", "win", "source", "reader", "kin", "rin", "pull", "nin", "l", "a", "login", "work", "inner", "min", "r", "id", "token", "ac", "bin", "err", "con", "c", "file", "up", "pin", "ini", "as", "arin", "again"], "out": ["at", "ex", "writer", "one", "server", "call", "copy", "In", "null", "n", "connection", "cmd", "init", "io", "off", "outer", "this", "sync", "inc", "socket", "output", "no", "check", "o", "index", "IN", "Out", "conn", "download", "i", "source", "client", "nin", "co", "login", "inner", "point", "outs", "min", "exec", "bin", "file", "err", "obj", "name", "up", "OUT", "op", "again", "line", "ext"], "localURL": ["externalAPI", "LocalCL", "LocalAPI", "LocalUrl", " localFile", "localFile", "externalCL", "localAPI", "remoteURI", " localCL", "externalURL", "localCL", "externalUrl", "remoteURL", " localAPI", "localURI", "remoteUrl", " localURI", "remoteFile", "LocalURL", "localUrl", " localUrl", "baseFile", "baseURI", "baseURL", "baseUrl"]}}
{"id1": "3745402", "id2": "20920051", "code1": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createCipher": [" createScrypt", "createCSecret", "createIntegSecret", "createIntegrypt", "createScipher", "createcrypt", " createCrypt", "createcipher", "createCursor", "createCrypt", "createIntegursor", " createScipher", " createScursor", "createcursor", " createCSecret", "createScrypt", "createScursor", "createScSecret", " createScSecret", "createcSecret", "createIntegipher", " createCursor"], "passwd": [" passphrase", "PassWD", "failWD", " passpassword", "passWD", "passwordword", "password", "passphrase", "passwordwd", "failpassword", "failword", "passwordpassword", "Passwd", " password", "passpassword", "Passpassword", " passWD", "Passphrase", "passwordphrase", "failwd", "Password"], "mode": ["prefix", "Mode", "direction", "delay", "mask", "message", "module", "role", "server", "core", "cmd", "MODE", "method", "version", "depth", "phrase", "range", "password", "phase", "type", "code", "time", "source", "driver", "dir", "seed", "slave", "command", "slice", "mac", "address", "language", "mm", "name", "domain", "path", "mod", "level", "manager"], "keySpec": ["secretCS", "signConfig", "KeyCS", "keyspec", "KeySpec", "signSpec", " keyConfig", " keySet", " keyspec", "keyCS", "keyConfig", "secretSpec", "keySet", "secretFactory", "Keyspec", "signspec", "KeyFactory", "KeyConfig", " keyCS", "secretSet", "KeySet"], "keyFactory": ["keyFamily", "KeyService", "kFamily", " keyService", "keyService", "kFactory", "KeyFamily", "KeySpec", " keyFamily", "secretService", "secretSpec", "secretFactory", "KeyFactory", "kSpec", "kService"], "key": ["k", "secret", "pe", "text", "keys", "ssl", "message", "cert", "core", "ki", "Key", "ce", "data", "phrase", "hash", "sum", "password", "type", " secret", "code", "pass", "temp", "source", "config", "pair", "seed", "sign", "user", "base", "mac", "id", "cache", "file", "c", "ke", "name", "sk", "pub", "state", "enc", "p", "KEY"], "md": ["m", "hd", " MD", "message", "mp", "sha", "cmd", "dr", "material", "msg", "dig", "dd", "f", "mc", "mag", "d", "vd", "mb", "meta", "amd", "dm", "bd", "cm", "metadata", "MD", "db", "ad", "mac", "mand", "mm", "ma", "sm", "dc", "pm", "mt", "cd", "dh", "df"], "digest": ["mdester", "demeter", " digEST", "DigEST", " digeter", "Digester", "signeter", "mdEST", "digEST", " digested", "Digest", "mdested", "demested", "signest", "demest", " digester", "digend", "signested", "digeter", "Digested", " digend", "digester", "signester", "demester", "digested", "mdest", "mdend", "Digend"], "salt": ["ssalt", "psALT", "isodium", "psodium", "sesSalt", "ssecret", "psalt", "isalt", "secretALT", " sALT", "ssALT", "SALT", "isALT", " sodium", "isSalt", "sesodium", "sesalt", "sesALT", "sort", "Ssecret", "sipher", "dsort", "dsALT", "dsodium", "Salt", "sALT", "sSalt", "Sipher", "secretalt", "Sodium", "psort", "sssecret", " sort", "dsalt", "secretipher", "SSalt", "sodium", "secretsecret", "ssipher"], "i": ["at", "k", "m", "u", "uri", "z", "e", "j", "b", "n", "init", "info", "si", "in", "f", "it", "o", "index", "d", "ci", "oi", "s", "y", "li", "di", "l", "hi", "pi", "ip", "xi", "ind", "id", "uli", "ti", "v", "gi", "c", "t", "ri", "I", "ai", "ix", "ii", "ui", "x", "mu", "qi", "bi", "p"], "paramSpec": [" paramSpe", "paramSpe", " paramConfig", "aramConfig", "paramsConfig", "paramspec", " parameterSpe", "parspec", " parameterSel", "paramCS", "parCS", "paramsCS", "Paramspec", "ParamConfig", "parSpec", "aramSel", "parConfig", "paramsSpec", "paramSel", "aramSpe", "paramsspec", " parameterConfig", "paramConfig", " paramSel", " parameterSpec", "aramSpec", "ParamSpec", "ParamCS"], "cipher": ["cairo", "encoder", "crypt", "coursor", "conursor", "encipher", "Cipher", "Crypt", "encursor", "corypt", "Cistor", "coipher", "coder", "pipher", " cairo", "Coder", "encairo", "cistor", "pistor", "encrypt", "conuster", "Cursor", "pairo", "prypt", " cursor", "custer", "encuster", "cursor", "conrypt", "couster", "Cairo", "conipher", " coder", "encistor"]}}
{"id1": "8132219", "id2": "5138455", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", " copyStream", "CopyFiles", " copyFiles", "copyfile", " copyfile", "CopyStream", "transferfile", "copyFiles", "Copyfile", "transferStream", "copyStream", "transferFiles", "transferFile"], "inFile": ["InFile", "INSourceFile", "binfile", "infile", "inPlace", "inSourceFile", "INfile", "inputPlace", "inFilename", "inputFile", " inFilename", " inSourceFile", "binFile", "outFiles", "binPlace", "outfile", "INFilename", "Infile", "InFilename", "binFiles", "INFile", "InSourceFile", "inputfile", "inputFiles", "inFiles", "outPlace", " infile"], "outFile": ["againPlace", "outputFiles", "againFile", " outfile", " outFilename", " outPlace", "infile", "inFilename", "outputPlace", "outFiles", "outputFile", "outfile", "outFilename", "againfile", "outputFilename", "againFilename", " outFiles", "inFiles", "outPlace", "outputfile"], "in": ["m", "ins", "url", "image", "In", "n", "connection", "like", "io", "data", "inc", "part", "f", "input", "din", "IN", "inn", "index", "is", "i", "source", "rin", "reader", "config", "a", "work", "inner", "base", "id", "bin", "c", "file", "ic", "name", "pin", "ini", "as", "x", "again"], "out": ["to", "prefix", "ex", "log", "writer", "default", "write", "image", "resource", "plain", "copy", "null", "b", "call", "n", "io", "dot", "data", "version", "external", "part", "output", "o", "Out", "conn", "Output", "client", "outs", "user", "cache", "string", "v", "bin", "c", "file", "obj", "exec", "name", "w", "OUT", "x", "buffer", "line", "p", "ext"], "inChannel": ["outchannel", "inputChan", "inputChannel", "inConnection", "iniStream", "sinSocket", "INSocket", "INChannel", "sinChannel", " inchannel", "inLanguage", "inStream", "inChan", "INStream", "INFlow", "inchannel", "inFlow", "inputchannel", "INchannel", "winStream", "inSocket", "iniChannel", "winLanguage", " inChan", " inSocket", "outStream", " inFlow", "inputStream", "sinFlow", "winChannel", "inichannel", "iniLanguage", "outLanguage", "outChan", " inConnection", "INConnection", "sinChan", "INChan", "outConnection", "winchannel"], "outChannel": ["outchannel", "againchannel", "outContext", "inConnection", " outPath", "OutChan", " outContext", "againChannel", " outChan", "inChan", "inPath", "newChannel", "OutChannel", "OutConnection", "OutContext", "inchannel", "newChan", "newStream", "Outchannel", " outchannel", "againChan", "outStream", " outStream", "againPath", "outputChan", "outChan", "outPath", "outConnection", "OutStream", "newContext", " outConnection", "outputChannel", "outputchannel"]}}
{"id1": "2396191", "id2": "21656668", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromStringFast", "getLinksFromSSLFast", "getLinksFromUrlSlow", "getLinksFromURLSafe", "getLinksfromUrlSafe", "getLinksfromURLFast", "getLinksFromStringfast", "getLinksfromUrlfast", "getLinksfromUrlFast", "getLinksFromSSLfast", "getLinksFromURLfast", "getLinksfromUrlSlow", "getLinksFromUrlFast", "getLinksfromURLSafe", "getLinksfromURLSlow", "getLinksFromStringSlow", "getLinksFromURLSlow", "getLinksFromSSLSlow", "getLinksFromUrlfast", "getLinksFromStringSafe", "getLinksfromURLfast", "getLinksFromSSLSafe", "getLinksFromUrlSafe"], "p_url": [" p_path", "p_resource", "p_link", "p64page", "p__resource", "pfline", "pamurl", "pkurl", "p_page", "tp_root", "p9url", "p24file", " p_resource", "tp_link", "p25url", "p_service", "pfpath", "p9resource", "p6root", "e_url", "p9service", "x_domain", "e_layer", "p_layer", "tp_url", " p_line", "p__path", "p_path", "piproot", "tp24file", "p6url", "p64line", "p__name", "pe_line", "pffile", "p_html", "ekurl", " p_page", "p24link", "pipurl", "pamhtml", "pxconfig", "p6line", "eklink", "p_line", "tp24root", "pkhtml", "p9domain", "pfpage", "p64path", "pamlayer", "x_resource", "pklayer", "p_config", "p_root", "p_domain", "pe_url", "pe_root", "p64url", "p__url", "pfurl", "eklayer", "p25html", "pxroot", "p_name", "pxurl", "pfroot", "pxline", "pe_config", "pipfile", " p_name", "p24root", "p_file", "p25layer", "p25link", "pflink", "e_link", "tp24url", "ekhtml", "piplink", "pklink", "e_html", "pamlink", "p24url", "p6config", "x_service", "tp_file", "tp24link"], "x_url": ["x_log", "p_host", "x_host", "x_ssl", " x_resource", "x_resource", " x_log", "p_loc", "x_loc", "p_conn", " x_ssl"], "x_conn": ["wx_conv", "x_conv", "wx_cat", "p_client", "x___db", "p_db", "wx_con", "wx_conn", "p_con", "x_client", "x_cat", "x___client", "x___con", "x_db", "x___conn", "p_conn", "x_con"], "x_is_reader": ["x_ismlstream", "x_ismlmanager", "x_is_stream", "x_ismlreader", "x_is_resource", "x_is_manager", "x_is_pointer", "x_ismldraft", "x_is_draft", "x_is_writer"], "x_reader": ["cross_url", "x8parser", "cross8parser", "x24reader", "X_stream", "cross_parser", "x8root", "X_parser", "cross8url", "x8reader", "x67parser", "cross_reader", "x24parser", "x_parser", "x24result", "X_reader", "x67root", "x67url", "cross_root", "x24stream", "cross8reader", "cross8root", "X_result", "x67reader", "x8url", "x_stream"], "x_line": ["xx_lin", "xx_comment", "ex_page", "xingline", "x_lin", "p_line", "ex_record", "x24line", "p_link", "ex_cell", "x24comment", "x_record", "ex_line", "x__url", "x__line", "p_page", "x__link", "x__page", "xingpage", "xx_link", "x24link", "xingcell", "xx_line", "x_comment", "x24lin", "x_cell", "xingrecord"], "e": ["m", "pe", "ee", "he", "ev", "esi", "le", "se", "b", "g", "body", "n", "en", "ce", "event", "ue", "ge", "je", "engine", "ie", "ec", "ele", "entry", "f", "oe", "es", "edge", "o", "d", "ace", "ae", "end", "me", "error", "el", "code", "element", "te", "ze", "y", "driver", "ne", "l", "er", "E", "eu", "eps", "r", "eur", "match", "exec", "v", "file", "c", "re", "entity", "t", "eve", "ente", "ea", " E", "fe", "eb", "line", "p"], "x_match": ["x_member", "x___match", "x5info", " x_tag", "xjurl", "p__matched", "x___matched", "p_match", "x__pattern", "x_slice", "extJpattern", "ext_pattern", "p__match", "ax_link", "p_matched", "ext_match", "ax_info", " x_date", "x_check", "xJsearch", "p_pattern", "x_tag", "xJmatch", " x__slice", " x__replace", "ax_match", "xamslice", "x_pattern", "xldate", "ax5case", "e___match", "xamcase", "ax5match", "xlmember", "x_date", "e_check", "xlgroup", "xJpattern", "xlpattern", " x_case", "e___check", "x5link", "x__replace", "xJmember", "xjmatch", "e_match", " x__match", "x__matched", "x__case", "x_search", "xlsearch", "xjpattern", "e_matched", "ext_member", "xammatch", "ax5link", "extJmatch", "xltag", "x_matched", "ext_search", "x_case", "x___check", "xjmatched", "x5case", "xamreplace", "e___matched", "p__url", "e___meet", " x_replace", "x5match", "x___meet", "ax_case", "x_group", "x__match", " x__case", "p__pattern", "ax5info", "extJmember", "x__url", " x_group", "x__slice", "xlmatch", "x_replace", "x_info", "x_meet", " x_slice", "extJsearch", "e_meet"], "x_dir": ["x_file", "x6file", "x6group", "x_group", "xnetdir", "xneturl", " x_file", " x_group", "x6dir", "xnetfile", "xnetgroup", "x6url"], "x_root": ["xml_alias", "x7root", "xml_root", "xml_path", "xml_directory", "x_path", "x_directory", "x_alias", "x7directory", "x7path", "x7alias"], "x_links": ["x67ids", " x_points", "x67links", "x_points", "x67points", "x67lines", "x_lines", "x_ids", " x_lines", " x_ids"], "x_texts": ["x_urls", "x_loges", "x_pathls", "x_paths", "x_logs", "x_textes", "x_urlches", "x_textls", "x_pathches", "x_logls", "x_urlls", "x_textches", "x_pathes", "x_logches", "x_urles"], "x_buf": ["x_uf", "x__cb", "x1buf", "ex__tmp", "x__buffer", "x__buf", "y__bag", "x_rc", "y_rc", "X_buffer", "x_buffer", "X_buf", "x_cb", "ex__buff", "ex__buf", "ex_buf", "x__buff", "y__rc", "x___buf", "X_buff", "x__uf", "x___rc", "x_wb", "x1tmp", "ex_tmp", "x__bag", "y_bag", "y_buf", "x1buff", "x64buf", "ex__cb", "y__buf", "x__wb", "x_tmp", "X_wb", "x64rc", "x_bag", "y_uf", "x__rc", "x_buff", "y__uf", "x___bag", "x___uf", "x64uf", "x1cb", "x64bag", "x__tmp", "ex_cb", "ex_buff"], "x_matches": ["x_Matches", "x_matchoms", "x_batches", "x_mathes", "x_patches", "x_morches", "x_matchchers", "x_locched", "x_morhes", "x__matchers", "x__matches", "xKtextoms", "x_patcher", "x_locting", "x_bathes", "x_texthes", "x_matchcher", "x_batchers", "x__mathes", "x_textings", "xKmathes", "x_Mathes", "xKmatings", "x_attched", "x_textches", "x_batures", "x_matures", "x_attcks", "x_atthes", "x_matoms", "x__matures", "x_patched", "x_matchings", "x_calings", "x_calhes", "xKtexthes", "xKtextings", "x_calches", "x_matchting", "x_matched", "x_matings", "x_loches", "x_matting", "x_textoms", "x_matcher", "x_patcks", "x_matcks", "x_Matchers", "x_Matures", "x_morched", "x_matchhes", "x_matchches", "x_attches", "x_morting", "x_caloms", "x_matchched", "x_locches", "xKmatoms", "x_patchers", "x_matchers", "x_matchcks", "x_pathes", "xKmatches", "x_Matcher", "xKtextches"], "x_page": ["x_file", "ex_page", "x67loc", "tx_feed", "X_path", "x67link", "tx_line", "xerlink", "x_path", "tx_page", "x_feed", "tx_link", "X_url", "ex_link", "ex_loc", "x67file", "ex_file", "x67page", "x_loc", "X_page", "xerfeed", "xerpage", "X_line", "xerline"], "x_link": ["ex_page", "ex_url", " x_loc", " x_target", "ex_line", "xpubline", "xpubtarget", "x_target", "ex_link", "x_loc", "xpublink", "xpubloc"], "i": ["k", "p", "u", "uri", "z", "j", "count", "b", "n", "ori", "io", "info", "si", "ie", "in", "f", "it", "iv", "o", "index", "ci", "key", "oi", "iu", "ji", "multi", "y", "li", "a", "di", "hi", "pi", "xi", "eni", "r", "id", "ti", "v", "gi", "c", "ix", "I", "ai", "phi", "zi", "ini", "ii", "ui", "x", "chi", "qi", "bi", "ri"]}}
{"id1": "17729554", "id2": "8801182", "code1": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"clonarFichero": ["clonarfichero", "clonarFaichero", "clonarfIChern", "clonarFaichern", "clonarFivehern", "clonarFICher", "clonarFIChero", "clonarFivehero", "clonarfICher", "clonarFicher", "clonarFicchio", "clonarficher", "clonarFiveher", "clonarfICchio", "clonarFaicchio", "clonarfichern", "clonarFivechio", "clonarFIChern", "clonarFichern", "clonarFICchio", "clonarfIChero", "clonarFaicher", "clonarficchio"], "rutaFicheroOrigen": ["rutaFichestOrigense", "rutaFicheroOpener", "rutaFichestOrigen", "rutaFicherOriginalener", "rutaFicherOrigens", "rutaFichestOriginened", "rutaFicheroOrigense", "rutaFichestOriginen", "rutaFicheroOpEN", "rutaFicheroOriginaleni", "rutaFicheroOrigener", "rutaFicheroOrigened", "rutaFicheroOpen", "rutaFicheroOpened", "rutaFicheroOrigininen", "rutaFicheroOriginalena", "rutaFicherOriginalEN", "rutaFicheroExtena", "rutaFicherOriginalen", "rutaFicheroOriginen", "rutaFicherOrigen", "rutaFicherOriginalens", "rutaFicheroOriginalEN", "rutaFicheroOriginened", "rutaFicheroOpens", "rutaFicheroOrigena", "rutaFicheroExteni", "rutaFichestOrigininen", "rutaFicheroOpense", "rutaFicheroOriginalened", "rutaFicheroOriginalinen", "rutaFicheroOriginalens", "rutaFicheroOriginalener", "rutaFicheroExtened", "rutaFicheroOpinen", "rutaFicheroOriginense", "rutaFicherOrigEN", "rutaFicheroOpeni", "rutaFichestOrigened", "rutaFicheroExten", "rutaFicheroOriginalense", "rutaFichestOriginense", "rutaFicheroOriginalen", "rutaFicheroOrigens", "rutaFicheroOpena", "rutaFicheroOrigeni", "rutaFicheroOrigEN", "rutaFicherOrigener"], "rutaFicheroDestino": ["rutaFicherRestina", "rutaFicheroDestario", "rutaFicheroDesino", "rutaFicheroDesario", "rutaFicherodestINO", "rutaFicheroRestario", "rutaFicheroRestino", "rutaFicherRestario", "rutaFicherOrigino", "rutaFicheroCampin", "rutaFicherodestin", "rutaFicheroDestINO", "rutaFicheroDesINO", "rutaFicherDestin", "rutaFicherDestino", "rutaFicheroOrigino", "rutaFicheroRestina", "rutaFicheroDestination", "rutaFicherodestino", "rutaFicheroCampination", "rutaFicheroOrigin", "rutaFicherRestino", "rutaFicherDestination", "rutaFicherodestination", "rutaFicherDestario", "rutaFicheroCampINO", "rutaFicherDestINO", "rutaFicherRestINO", "rutaFicherDestina", "rutaFicheroOrigINO", "rutaFicherOrigINO", "rutaFicherOrigin", "rutaFicheroDestin", "rutaFicherOrigination", "rutaFicheroOrigination", "rutaFicheroDestina", "rutaFicheroCampino", "rutaFicheroDesina", "rutaFicheroOrigina", "rutaFicheroOrigario", "rutaFicheroRestINO"], "salida": ["Salica", "palada", "Salidi", "malida", "salido", "salica", "Salanta", " salidas", "balida", "malanta", "slida", "palanta", "malidi", "Salida", "slidas", " salanda", "palidi", "salanta", "Salada", "saliza", "Salido", "sliza", " salica", "Saliza", "balido", "Salidas", "salidas", "salada", "malada", " salido", "balica", "slanda", " saliza", "palida", "salidi", "salanda", "balanda", "Salanda"], "canalOrigen": ["canalOrigensen", "canalsOrigEN", "canalorigens", "canalsOriginaln", "canalOrigened", "canalsOriginalensen", "canalOriginalain", "canalsOrigened", "canelOriginalun", "canalOriginalen", "canalOriginalens", "canalOriginens", "canelOriginalens", "canelOrigun", "canalSequen", "canalOrden", "canalOriginalun", "canalorigain", "canalorigened", "canalOriginen", "canalOriginaline", "canalOriginun", "canalsOriginalened", "canalSequn", "canalOrign", "canalOriginalensen", "canelOrigine", "canelOrigens", "canalOrigine", "canelOriginalen", "canalsOrigens", "canelOriginaline", "canalOrigEN", "canalorigine", "canelOrigen", "canalsOriginalen", "canalorigensen", "canalOriginaln", "canalSequens", "canalOrdn", "canalsOriginalens", "canalorigun", "canalSequEN", "canalsOrigain", "canalsOriginalEN", "canalorigen", "canalOriginine", "canalOrigun", "canalOrdens", "canalsOrigensen", "canalOrigens", "canalsOrigen", "canalOriginalEN", "canalOrigain", "canalsOrign", "canalOrdEN", "canalOriginalened", "canalsOriginalain"], "canalDestino": ["canaldestination", "canpalDestination", "canpaldestino", "canaldestri", "canalDestination", "canaldestini", "canaldestino", "canpalDestini", "canpalDestINO", "canpaldestINO", "canalCombini", "canalDestINO", "canalCombINO", "canalsDestino", "canaldestINO", "canpalDestino", "canalOrigino", "canalDestini", "canalsdestination", "canalCombino", "canalCombination", "canalsDestination", "canalDestri", "canpaldestination", "canalsdestri", "canalsDestINO", "canalsDestri", "canalOrigini", "canalsdestino", "canpaldestini", "canalsdestINO", "canalOrigination", "canalOrigINO"], "estado": ["Estar", " estados", "iestado", "Estaban", "iestada", "estano", "estaban", " estaban", "istano", "estados", " featados", " Estaid", " featada", "apestato", "istato", "Estado", " Estada", " featado", " estano", "gestada", "iestato", " Estado", "iestaban", "istaban", "gestato", " estato", "estada", "gestaban", "estato", " estaid", "apestada", " estada", "istado", "Estada", "estaid", " estar", "apestano", "istada", "istar", "estar", "gestado", " Estados", " feataid", "apestado"]}}
{"id1": "22441244", "id2": "8953394", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "label": 0, "substitutes": {"send": ["text", "sent", "message", "write", "append", "build", "set", "reply", "end", "add", "create", "parse", "delete", "export", "address", "exec", "submit", "start", "Send", "get", "transfer", "mail", "execute", "from", "open", "post"], "hsession": ["hsess", "hmessions", "hessions", "HSession", "opensessions", "hmsession", "hsSession", "opensess", "hhessions", "HSSession", "hsort", "hhort", "hesess", "hSession", "hmession", "hhSession", "hesort", "hessession", "hssession", "hmSession", "hsessions", "opensSession", "opensort", "hhession", "hesession", "opensession", "openssession", "HSsession", "hhsession", "HSessions", "hession", "hhess"], "session": ["proxy", "Session", "message", "resource", "server", "parent", "connection", "event", "project", "port", "chat", "application", "document", "site", "class", "ession", "client", "cache", "security", "essions", "host", "sl", "context", "response", "mail", "state", "manager"], "repositoryName": ["reposositoryAddress", "repoositoryEmail", "repositoryPath", "repoositoryPath", "repoitoryAddress", "reposessionName", "repoitoryEmail", "reposicleAddress", "reposicationAddress", "repoositoryFamily", "repositiveNAME", "reposessionNAME", "repositoryNAME", "reposicationFamily", "repositoryAddress", "repoositoryNAME", "repositoryFamily", "repoositoryAddress", "repoitoryName", "repositiveName", "reposicleName", "repositiveEmail", "repositivePath", "reposicleEmail", "reposessionPath", "reposositoryPath", "reposositoryNAME", "reposositoryFamily", "reposicationEmail", "reposicationName", "repoositoryName", "reposositoryEmail", "repoitoryPath", "reposicleFamily", "reposessionEmail", "repoitoryNAME", "reposositoryName", "repoitoryFamily", "repositoryEmail"], "ideIdint": ["IDEIdInt", "ideidn", "IDEIdn", "ideNamenumber", "IDEIdints", "ideInn", "IDEidn", "IDENameInt", "IDEidints", "ideTimeout", "IDEIdint", "ideAuthInt", "ideInint", "ideAuthint", "ideIdInt", "ideIdints", "IDEIdout", "IDENamenumber", "ideIdn", "ideNameInt", "ideNameint", "ideInfonumber", "ideInInt", "ideInfoInt", "IDEIdnumber", "ideIdout", "ideTimeInt", "ideInfoout", "ideIdnumber", "IDENameout", "ideNameout", "IDENameint", "IDEidint", "ideAuthn", "ideInints", "ideidInt", "ideTimeint", "ideAuthints", "ideidints", "ideTimenumber", "IDEidInt", "ideInfoint", "ideidint"], "to": ["prefix", "mobile", "uri", "message", "summary", "options", "phone", "title", "site", "about", "reply", "tel", "template", "settings", "source", "TO", "top", "client", "with", "contact", "sub", "target", "company", "address", "token", "account", "po", "name", "by", "location", "response", "mail", "office", "To", "from"], "cc": ["ct", "cn", "uc", "rc", "tc", "ce", "phone", "ec", "ck", "password", "cl", "nc", "ci", "cb", "code", "cca", "comment", "client", "contact", "cus", "company", "sc", "CC", "ac", "account", "address", "c", "card", "dc", "cf", "lc", "cs", "ca", "cr", "from"], "bcc": ["bbrc", "pce", "bce", "pcc", "pck", "bc", " brc", " bc", " bck", "bbc", "abcc", "bbcc", " bce", "abck", "abce", "pc", "frc", "abc", "fcc", "fc", "brc", "fck", "bck", "bbck"], "subject": ["prefix", "description", "uri", "message", "reason", "method", "username", "phone", "title", "Subject", "reply", "template", "comment", "header", "filename", "sub", "object", "host", "response", "mail", "state", "author", "format", "content", "ject", "head", "request"], "body": ["text", "description", "url", "message", "resource", "money", "plain", "html", "length", "style", "view", "connection", "summary", "reason", "lock", "foot", "empty", "data", "shell", "part", "how", "zip", "password", "template", "code", "pass", "comment", "source", "bound", "header", "media", "tree", "pod", "base", "inner", "object", "string", "name", "left", "function", "response", "normal", "wrapper", "content", "line", "secret", "Body"], "attachments": ["embedings", "Attachments", "attachings", "embedents", "attachents", "embedment", "messments", "Attachents", "messings", "Attachings", "Attachment", "embedments", "messents", "messment"], "isHtml": ["isWhtml", "isWhhtml", "isPhail", "isChail", "isHive", "isWhive", "isHattp", "isCail", "isHttp", " isWhive", " isChhtml", "isChtml", "isHaail", "isHahtml", "isHatml", "isChhtml", " isWhhtml", " isHive", "isCive", "isPhttp", "isPhtml", "isHail", " isChtml", " isHhtml", "isPhhtml", " isChail", " isWhtml", "isChive", "isHhtml", "isChttp", " isWhail", " isChttp", "isWhail", " isHttp", " isHail", "isCtml"], "charset": ["chearspace", "chARSeting", "chanset", "chasets", "chasET", "Charseting", "chARSet", "cheansetter", "chansET", "Charsetting", "cheansetting", "chARSetting", "chasetting", "charsets", "chansetter", "chashesET", "chacksete", "chaseset", "chacksetting", "cheanspace", "chaspace", "chasesetting", "charspace", "chaseseting", "chanspace", "chansete", "chansetting", "CharsET", "charsetting", "chearsete", "cheanset", "cheansET", "Charset", "chearsetting", "chacksET", "charsete", "chearsET", "chasetter", "chasesET", "charsetter", "chARSET", "cheansete", "chaseting", "chashesetter", "chARSets", "chashespace", "chaset", "chasheset", "chearset", "chARSete", "charsET", "charseting", "chearsetter", "Charsets", "chackset"], "headers": [" recipients", "users", "options", " messages", "status", "groups", "comments", "classes", "lines", "settings", " emails", "metadata", "properties", "header", "files", "names", "mails", "errors", " cookies", "ers", "params", "types", "writers", "authors", "content", "strings"], "priority": [" severity", "prefix", "length", " recipients", "quote", "reason", "phone", "title", "status", "mode", "comments", "reply", "template", "date", "code", "comment", "theme", "class", "queue", "language", "security", "state", "level", "author", "lang", " title", "secret"], "email": ["enter", "business", "text", "url", "ssl", "default", "message", "e", "server", "install", "html", "example", "core", "view", "letter", "en", "lex", "event", "info", "data", "username", "international", "engine", "online", "external", "output", "model", "document", "oe", "result", "fax", "zip", "password", "template", "test", "el", "element", "xml", "create", "article", "print", "contact", "base", "object", "address", "account", "ilo", "liner", "name", "Email", "service", "entity", "em", "generic", "pm", "auto", "response", "mail", "office", "note", "update", "line", "export", "ext", "gmail"], "user": ["User", "mobile", "people", "role", "e", "USER", "resource", "connection", "users", "info", "data", "username", "profile", "member", "model", "creator", "me", "type", "plugin", "uid", "consumer", "client", "er", "ip", "object", "id", "token", "account", "string", "character", "name", "unknown", "author", "use", "friend", "person"], "identity": ["authentication", "ethnicifier", "ethnicentity", "authentity", "Identity", "identITY", "ethnicity", "authorITY", "idonymous", "authentization", "authentITY", "personITY", "electricITY", "authorication", "IDENTITY", "authorifier", "idententity", "personity", "installonymous", "entityity", "identization", "IDENTities", "electricity", "IDENTentity", "Identities", "entityifier", "installITY", "authentifier", "idITY", "publicity", "identication", "IdentITY", "publicITY", "authentonymous", "installity", "authoronymous", "Idententity", "IDENTity", "entityonymous", "authority", "personentity", "identonymous", "idization", "electricentity", "idifier", "entityization", "publiciciary", "electriconymous", "identifier", "ethnicITY", "installentity", "ethnicication", "authorities", "identiciary", "identities", "authoriciary", "idication", "personifier", "ethniciciary", "publicentity", "authorentity", "idity"], "_returnPath": ["_returnPart", "_replyNode", " _returnUrl", "_replyPath", " _returnName", "_addpath", "_successText", "_resultPath", "_resultName", "_responsePath", "_returnMid", " _backTo", "_backHalf", "_correctPath", " _backPath", "_returnHalf", "_returnUrl", "_addType", "_backTo", "_displayNode", "_displayPath", "_replyPart", "_returnName", "_returnId", "_resultTo", "_backpath", " _backName", "_backType", "_displayPart", "_correctId", "_returnDirectory", "_inputUrl", "_resultHalf", "_relationDirectory", " _returnPart", "_successId", "_backName", "_backPath", "_relationText", "_relationId", "_relationPath", "_returnNode", "_responseType", "_returnpath", "_correctDirectory", "_displayUrl", "_backUrl", " _returnTo", "_inputPath", "_correctText", " _backHalf", " _backUrl", "_successPath", "_backPart", "_displayMid", "_responsepath", "_returnText", "_replyUrl", "_returnType", "_addPath", "_returnTo", " _returnHalf", "_inputNode", "_inputMid", "_successDirectory", " _backPart", "_replyMid"], "_from": ["placeowner", "placeto", "_source", "existingfrom", "workfrom", "blockfrom", "existingto", "blockto", " _source", " _owner", "existingfor", " _who", "workto", "existingowner", " _error", "_for", "_error", "worksource", "placefrom", "_with", "_owner", "_From", " _for", "blockFrom", "workwho", " _From", "_who", "blockerror", "placefor", " _with"], "_replyTo": ["_replyPoint", "_returnUrl", "_reasonTo", " _replyFrom", "_respondTo", "_respondAddress", " _returnUrl", "_respondUrl", "_commentTo", "_replyOf", "_returnAddress", " _returnFrom", "_closeTO", " _replyUrl", "_respondPoint", "_respondFrom", "_reasonUrl", "_returnPoint", "_commentOf", "_addTo", "_returnOf", "_replyAddress", "_addFrom", "_replyUrl", " _returnTO", "_returnTo", "_reasonFrom", "_commentTO", "_addPoint", "_addAddress", "_returnTO", "_closeFrom", "_commentFrom", " _replyTO", "_replyFrom", "_reasonTO", "_respondTO", "_closeTo", "_replyTO", "_closeOf", " _returnTo", "_returnFrom"], "_to": ["Jabout", "_about", " _about", "Jtarget", "Jfrom", "Jto", " _target", "_target"], "_cc": ["_cd", "_ce", " _ce", " _cd", "_cf", " _cf"], "_bcc": [" _bc", "_rbcc", "_abce", "_sbcs", "_bc", "_rbcs", "_rbc", "_bce", "_abcs", " _abc", " _bce", "_abcc", "_abc", "_rbce", "_bcs", "_sbc", " _abce", "_sbce", " _abcc", "_sbcc", " _bcs", " _abcs"]}}
{"id1": "5551393", "id2": "17111859", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD4", " getMD256", "getSHA256", "getmd4", "getmd512", "getmd256", "getMD256", " getM4", "getSHA5", "getM256", "getM512", "getmd5", "getMD512", " getMD512", " getM512", "getSHA512", " getM256", " getMD4", "getSHA4", "getM4", " getM5", "getM5"], "source": ["proxy", "text", "url", "unit", "message", "resource", "length", "dest", "style", "info", "data", "output", "Source", "result", "input", "bytes", "template", "code", "temp", "src", "config", "size", "seed", "target", "base", "slice", "object", "address", "string", "ource", "file", "security", "sm", "start", "name", "service", "SOURCE", "expected", "content", "buffer", "secure"], "tmp": ["buf", "array", "txt", "default", "copy", "dest", "b", "mp", "body", "cmp", "html", "data", "part", "Temp", "output", "var", "sb", "py", "stuff", "result", "zip", "tt", "cpp", "storage", "rb", "test", "nm", "meta", "cb", "code", "vt", "temp", "bf", "ignore", "metadata", "src", "foo", "cache", "obj", "params", "binary", "vm", "current", "buffer", "emp", "fp"], "md": ["mad", "m", "rm", "hd", "sd", " MD", "nd", "mp", "cmd", "mo", "dd", "gd", "rpm", "zip", "editor", "mc", "mag", "d", "vd", "od", "mb", "nm", "meta", "wd", "ms", "bf", "mg", "dm", "bd", "amd", "cm", "pd", "MD", "di", "mn", "mi", "ad", "mac", "ind", "mand", "mm", "ma", "oda", "ld", "mmm", "pm", "mt", "cd", "mu", "mod"]}}
{"id1": "5138455", "id2": "7908169", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"save": ["pack", "Save", "append", "write", "apply", "copy", "store", "output", "zip", "split", "clone", "run", "download", "process", "xml", "Copy", "create", "parse", "dump", "files", "load", "file", "upload", "transfer", "put", "post"], "bytes": ["ls", "buf", "values", "pins", "Bytes", "os", "data", "parts", "es", "zip", "rb", "lines", "ips", "s", "objects", "tes", "vals", "files", "resources", "outs", "slice", "frames", "bits", "address", "codes", "gb", "binary", "blocks", "words", "pointer", "buffer", "services", "bs", "its", "boot", "bps"], "outputFile": ["outputFiles", "responseDir", "referencePath", " outputF", "outputJar", "referenceFile", "targetDir", "inputFile", " outputPath", "OutputDirectory", " outputDirectory", "responseFile", "targetJar", "referenceDir", "responseJar", " outputfile", "outputDirectory", "outputPath", "referencefile", "OutputF", "targetfile", "targetFile", "inputDirectory", "inputDir", " outputFiles", "OutputFiles", " outputJar", "outputDir", "inputfile", "responsefile", "OutputFile", "inputFiles", " outputDir", "outputF", "inputF", "outputfile", "inputPath"], "in": ["m", "ins", "url", "ssl", "image", "In", "copy", "b", "n", "connection", "init", "info", "data", "inc", "part", "f", "input", "din", "IN", "inas", "inn", "s", "pass", "conn", "cin", "i", "is", "win", "source", "reader", "rin", "sin", "inside", "a", "work", "nin", "login", "inner", "base", "r", "id", "token", "exec", "bin", "con", "err", "c", "file", "up", "pin", "ini", "as", "again", "isin"], "out": ["at", "ex", "writer", "write", "image", "server", "call", "copy", "In", "b", "null", "n", "connection", "parent", "init", "io", "outer", "this", "sync", "outside", "inc", "socket", "output", "f", "exp", "o", "Out", "error", "conn", "temp", "i", "client", "a", "inner", "outs", "user", "object", "cache", "exec", "bin", "file", "err", "obj", "up", "w", "post", "OUT", "op", "as", "x", "again", "ext"]}}
{"id1": "21063400", "id2": "19784131", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public static String getMD5Hash(String original) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            StringReader sr = null;\n            int crypt_byte = 0;\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(original.getBytes());\n            byte[] digest = md.digest();\n            sr = new StringReader(new String(digest, \"ISO8859_1\"));\n            while ((crypt_byte = sr.read()) != -1) {\n                String hexString = Integer.toHexString(crypt_byte);\n                if (crypt_byte < 16) {\n                    hexString = \"0\" + hexString;\n                }\n                sb.append(hexString);\n            }\n        } catch (NoSuchAlgorithmException nsae) {\n        } catch (IOException ioe) {\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"doImageProcess": [" doImageFile", "doimageProcess", "doFileFile", "doThumbnailProcess", " doimageProcess", "doimageprocess", "doimageFile", "doThumbnailFile", " doimageprocess", "doImageprocess", " doimageFile", "doThumbnailprocess", " doImageprocess", "doFileProcess", "doFileprocess", "doImageFile"], "request": ["req", "writer", "url", "resource", "image", "server", "message", "report", "method", "data", "application", "model", "result", "input", "Request", "type", "xml", "instance", "reader", "config", "client", "header", "stream", "object", "name", "path", "query"], "response": ["wave", "resp", " Response", "page", "description", "writer", "respond", "default", "report", "message", "server", "image", "resource", "example", "complete", "view", "Response", "connection", "body", "version", "more", "session", "output", "application", "document", "status", "result", "site", "model", "reply", "index", "error", "out", "results", "api", "client", "queue", "object", "video", "cache", "success", "service", "host", "next", "full", "json", "location", "pool", "collection", "http", "feed", "ception", "onse"], "imgSize": ["ifSize", "imgC", "largeSize", "bgWidth", " imgLength", "dimSize", "imgLen", "augLen", "imagesize", "bgLength", "hrType", " imgWidth", "refSize", "imgHeight", "bgScale", "augWidth", "ifName", "imgWidth", "imagsize", "imgLength", "imHeight", "dimsize", " imgFamily", "ifLen", "imageLength", "imageSize", "dimHeight", "imageName", "refLength", "augSize", "imageLen", "imSize", " imgLen", "imageScale", "hrSize", "imLength", " imgName", "dimLength", "imgsize", "largeType", "bgLen", "imgScale", "bgSize", "imagType", "imgType", "imagC", "ifsize", "refHeight", "refsize", "hrsize", "augFamily", "imgFamily", "bgFamily", "imagSize", "largesize", " imgScale", "largeC", "imsize", " imgsize", "imgName", "hrC"], "imageInputStream": [" imageOutputSteam", "imageInstream", " imageOutputView", "imageReadFile", "imageStreamStream", "imageContentSteam", " imageInputFile", "imageInString", "pictureUploadFile", "imageInputSteam", "imageReadLength", "pictureUploadStream", "imageUploadstream", "imageReadstream", " imageOutputFile", "imageFilestream", "fileInputString", "imageFileString", "imageReadString", "imageInputFile", "imageInputView", "imageOutputView", "pictureInputstream", "imageInputstream", "pictureInputSteam", "fileReadStream", "fileInputstream", "imageUploadView", "photoReadSteam", "photoInputStream", "photoInputFile", "pictureUploadstream", "pictureInputStream", "pictureUploadSteam", "imageOutputFile", "imageReadStream", "fileInputLength", "fileInputStream", "photoReadStream", "photoInputSteam", "imageContentView", "pictureInputFile", "imageUploadStream", "imageUploadSteam", "imageOutputSteam", "fileReadString", " imageInputView", " imageOutputStream", "imageStreamFile", " imageInputSteam", "imageInLength", "imageStreamSteam", "imageInputString", "imageContentStream", "imageInStream", "fileReadstream", "imageContentFile", "photoReadstream", "imageStreamstream", "imageFileLength", "photoReadFile", "fileReadLength", "imageUploadFile", "imageFileStream", "imageReadSteam", "photoInputstream", "imageOutputstream", "imageOutputStream", "imageInputLength"], "imageBytes": ["imgBytes", "fileBlocks", "ImageBlocks", "audioBytes", "viewbytes", " imageUrl", "ImageData", "fileBytes", "viewBytes", "Imagebytes", "imageUrl", "fileData", "pictureData", "imageByte", "imgByte", "imgData", "audioBuffer", "viewData", "audiobytes", " imagebytes", "imagebytes", "imageBlocks", "ImageBytes", "imgBuffer", " imageData", "imageData", "audioByte", "filebytes", "picturebytes", "imgUrl", "viewUrl", " imageBuffer", "pictureBlocks", "imageBuffer", "imgbytes", "pictureBytes", " imageByte"]}}
{"id1": "2017833", "id2": "15202804", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"hash": ["replace", "crypt", "ash", "message", "html", "build", "sha", "check", "str", "hex", "set", "sum", "h", "create", "add", "print", "parse", "dump", "number", "base", "transform", "string", "Hash", "get", "format", "update", "block"], "text": ["font", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "output", "input", "str", "editor", "hex", "translation", "password", "template", "bytes", "key", "out", "test", "code", "source", "class", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "context", "path", "word", "content", "ext", "format", "buffer", "value", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedencodedWarning", "Unsupportedencodingception", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedencodingWarning", "UnsupportedEncasingWarning", "UnsupportedEncgorithmException", "UnsupportedEncasingException", "UnsupportedEncgorithmception", "UnsupportedEncodingWarning", "UnsupportedEncgorithmWarning", "Unsupportedencodedception", "UnsupportedEncodedWarning"], "md": ["mad", "m", "rm", "hd", " MD", "message", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "gd", "f", "mc", "mag", "d", "vd", "od", "meta", "ms", "hm", "wd", "mb", "amd", "mg", "dm", "bd", "bf", "metadata", "bm", "MD", "ad", "mac", "ind", "nm", "mand", "mm", "ma", "am", "ld", "pm", "mt", "mod", "ds"], "sha1hash": ["sha2h", "sha2hex", "SHA2Hash", "SHA1hash", "sha1hex", "ha1match", "sha4Hash", "shaonehash", "SHA2hash", "ha2match", "ha1hash", "sha1Hash", "sha3hash", "sha2hash", "sha3match", "sha2Hash", "SHA2sum", "sha4hex", "sha5h", "SHA1h", "sha5hex", "sha2sum", "SHA2h", "sha1sum", "SHA1Hash", "shaonematch", "sha1h", "SHA1sum", "ha2hex", "sha3hex", "sha5sum", "sha256h", "sha5Hash", "sha2match", "sha256sum", "sha5hash", "ha1hex", "sha4sum", "ha2hash", "shaonesum", "sha3sum", "sha1match", "sha256hash", "ha2sum", "ha1sum", "shaonehex", "sha256Hash", "sha4hash", "SHA1hex"]}}
{"id1": "7872659", "id2": "732800", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieindexFiles"], "completePath": ["execpath", "completeMusic", " completeRoot", " CompleteDir", "CompleteFile", "flatPath", "CompleteHome", " completeFile", "completeLoader", "correctPoint", " CompleteHome", "successpath", "donepath", "CompleteDir", " completePoint", "successPath", " completeMusic", "successCh", "itepath", "completeCh", "doneLoader", "progressVol", " CompletePath", " completeCh", " completepath", "completeVol", "completepath", "execPath", "doneVol", "iteMusic", "flatPoint", " completeDir", "completePoint", " completeHome", "progressPath", "flatRoot", "execLoader", " CompleteFile", "completeDir", "itePath", "flatCorp", "iteCh", "completeHome", "execVol", "correctPath", "donePath", "correctRoot", "completeFile", "progresspath", "completeRoot", "successMusic", "progressLoader", "correctCorp", "completeCorp", "CompletePath", " completeCorp"], "masterFile": ["MasterFile", "MasterFilename", "masterPath", "MasterName", "masterName", " masterFilename", "cachePath", "masterFILE", "configName", "masterFilename", "cacheFile", "MasterPath", "mastersPath", "mastersFile", "MasterFILE", "cacheFILE", " masterName", "configFilename", "MasterFiles", "mastersFILE", " masterPath", "cacheFiles", "configFile", "masterFiles", "configPath", "mastersFiles"], "CustRatingFileName": ["CustRateFileSize", "CustRatingFilesName", "CustRatingFullDesc", "CustIndexFilePath", "CustRateFilePath", "CustRatingFileDesc", "CustIndexFileVersion", "CustRatingFileVersion", "CustRatingLinePath", "CustRatingClassType", "CustRatingFullPath", "CustRateFilenameSize", "CustRatingLineVersion", "CustRatingClassVersion", "CustIndexFileType", "CustRatingFilesDesc", "CustIndexFilesVersion", "CustRatingLineType", "CustRatingFullSize", "CustRatingFilenameSize", "CustRatingFileSize", "CustRateFileName", "CustRatingLineName", "CustIndexFilesType", "CustRatingClassPath", "CustRateFileDesc", "CustRatingFilesType", "CustIndexFilesPath", "CustRateFilenameDesc", "CustRateFilenameName", "CustIndexFilesName", "CustRatingFilesVersion", "CustRatingFilenamePath", "CustRatingFilesSize", "CustRatingFilenameDesc", "CustRatingFilesPath", "CustRatingFileType", "CustIndexFileName", "CustRatingClassName", "CustRatingFilePath", "CustRateFilenamePath", "CustRatingFilenameName", "CustRatingFullName"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFileName", "MovieIndexFilesUrl", "MovieEditFName", "MovieIndexFILEName", "MovieIndexClassname", "MovieIndexFileSize", "MovieIndexFilesSize", "MovieIndexPlaceName", "MovieEditFname", "MovieIndexFilesName", "MovieIndexFilesname", "MovieIndexFileHandle", "MovieIndexFolderName", "MovieIndexFILEFile", "MovieEditFileName", "MovieEditFileSize", "MovieIndexFolderVersion", "MovieIndexFILEVersion", "MovieConfigFolderName", "MovieIndexFolderFile", "MovieEditFileUrl", "MovieIndexFilename", "MovieIndexClassSize", "MovieIndexFileVersion", "MovieIndexFileUrl", "MovieIndexPlaceVersion", "MovieIndexPlaceHandle", "MovieIndexFILEHandle", "MovieIndexClassUrl", "MovieEditFSize", "MovieIndexClassName", "MovieEditFilename", "MovieIndexFname", "MovieConfigFileHandle", "MovieConfigFileFile", "MovieIndexFUrl", "MovieIndexFSize", "MovieConfigFolderHandle", "MovieIndexFolderHandle", "MovieConfigFolderVersion", "MovieEditFUrl", "MovieIndexFileFile", "MovieConfigFileVersion", "MovieIndexFName", "MovieConfigFolderFile"], "inFile": ["InFile", "incC", "infile", "inputFile", " inSourceFile", "inputSourceFile", "incfile", "outfile", "Infile", "outSourceFile", "InSourceFile", "inputfile", "incSourceFile", "incFile", "InF", "outFile", "outC", " inF", "inF", "inSourceFile", "inputF", " infile"], "inC": ["innerC", "InFile", "outCI", "outF", " inCL", " inCC", "inputCC", "inCL", "inputFile", "outCC", "InCI", "innerCC", "inCC", "InCC", "inCI", "inB", "innerFile", "InB", "InCL", " inB", "innerCI", "InF", "outFile", "outC", "outCL", " inF", "outB", "InC", "inputC", "inF", "inputF"], "outFile1": ["outPlace1", "outputFileId", "outputfile1", "againCFirst", "againC2", "againC1", "outputfile2", "outfileId", "outCFirst", "outPath3", "againFile3", "outF2", "outFiles2", "outputFile1", "outPlaceName", "outFileFirst", "outFileId", "outFileName", "outfileName", "againFile2", "againFile1", "outPath1", "outPathFirst", "outfile2", "outFiles1", "outputFileName", "outFiles3", "outFilesFirst", "outF1", "outPlaceId", "outFId", "outPath2", "againC3", "againFileFirst", "outputfileName", "outputFile2", "outFile3", "outputfileId", "outfile1", "outPlace2", "outC3", "outFName"], "outC1": ["outCF81", "outB2", "againB2", "outFOne", "outC81", "outC8", "againC2", "newc81", "againC1", "newc1", "outCFFirst", "newC81", "newCOne", "againB1", "outCFirst", "outDOne", "outD81", "outF2", "outD8", "outB8", "newcFirst", "outcOne", "outCF1", "outBOne", "outc1", "outDFirst", "againBOne", "newC1", "againB8", "outF1", "newCFirst", "outD2", "outB1", "outcFirst", "outCOne", "againCOne", "againC8", "newcOne", "outCFOne", "outF8", "outc81", "outD1"], "outFile2": ["outLine6", "againLine6", "outDirectory5", "outDirectory4", "againFile6", "outputfile2", "outFile6", "outChannelTwo", "outputFile5", "outDirectoryTwo", "outFiles4", "outFileTwo", "outputFile4", "outFiles2", "outChannel1", "outfile4", "outputfile5", "outLineTwo", "againLine2", "againFile2", "outputFileTwo", "againFile1", "outfile2", "outFiles1", "outputfileTwo", "outChannel6", "outFiles6", "outputfile4", "outfile5", "outFile4", "outputFile2", "outFilesTwo", "outFiles5", "outLine2", "outLine1", "outDirectory2", "outfileTwo", "outChannel2", "againLineTwo", "againFileTwo", "againLine1", "outFile5"], "outC2": ["outB2", "againB2", "outCache2", "againBTwo", "againC2", "againC1", "againB1", "OutF4", "outCache4", "outF2", "againC4", "outFileTwo", "outB4", "OutC2", "outFTwo", "outCTwo", "outCacheII", "OutC1", "outF1", "outC4", "outBTwo", "OutC4", "outFII", "OutFII", "outFile4", "outFileII", "outB1", "againB4", "againCTwo", "outF4", "OutF2", "OutF1", "outCache1", "outCII", "OutCII"], "fileSize": ["FileSIZE", " fileSIZE", "resourceAddress", " fileAddress", "FileMode", "resourceSIZE", "fileSIZE", " fileLength", "imageLength", " fileMode", "fileMode", "fileLength", "imageSIZE", "bufferMode", "FileSize", "fileAddress", "FileAddress", "FileLength", "resourceSize", "bufferSize", "imageSize", "bufferLength"], "totalNoDataRows": ["totalNoDataCows", "totalNoDataCOWS", "totalNoDataLows", "totalNoDataChues", "totalNoPageRrows", "totalNoPageLows", "totalNoDataROWS", "totalNoDataChows", "totalNoDataLrows", "totalNoPageLues", "totalNoPageRues", "totalNoDataCues", "totalNoDataChrows", "totalNoPageROWS", "totalNoDataRues", "totalNoPageLrows", "totalNoDataLOWS", "totalNoDataRrows", "totalNoPageRows", "totalNoDataCrows", "totalNoDataChOWS", "totalNoDataLues", "totalNoPageLOWS"], "mappedBuffer": ["Machedbuffer", "mppedChannel", "machedBuff", "mappingBuff", "mashedChannel", "Mappedbuffer", "mappedURL", "MappedBuff", "MappingBuff", "mappedChannel", "machedFile", "MachedBuffer", "mapedFile", "MappedURL", "mapedStream", "machedStream", "mippedStream", "MappedStream", "machedBuffer", "mapedURL", "mppedBuffer", "mappedStream", "mappingChannel", "mippedBuffer", "mappingStream", "mashedFile", "mappedBuff", "mashedBuff", "mappingbuffer", "mappedbuffer", "mashedBuffer", "machedbuffer", "mappingFile", "MachedStream", "mppedStream", "MachedURL", "MachedFile", "MappedBuffer", "mactedBuff", "MappingFile", "mppedBuff", "MappingChannel", "mappingBuffer", "MappedFile", "mapedBuffer", "mippedBuff", "machedURL", "MappedChannel", "mactedbuffer", "mappedFile", "mippedURL", "machedChannel", "MachedBuff", "mapedBuff", "MachedChannel", "mactedStream", "mactedBuffer", "MappingBuffer"], "startIndex": ["StartInfo", "startOffset", "useindex", "endPosition", " startPosition", "startInfo", " startCode", " startindex", "endInfo", "StartPosition", "startRow", " startOffset", "startingIndex", "StartIndex", "StartOffset", "useInfo", "startingSection", "startindex", "usePosition", "startPoint", "endSection", " startPoint", "endIndex", "stopIndex", "stopCode", " startSection", "useIndex", " startInfo", "endindex", "startSection", "startCode", "endRow", "endCode", "initindex", "startingPosition", "stopindex", "stopRow", "Startindex", "startPosition", "initInfo", "initIndex", " startRow", "endPoint", "startingPoint", "initOffset"], "count": ["Count", "col", "call", "length", "depth", "weight", "child", "more", "allow", "old", "part", "follow", "limit", "group", "loop", "all", "coll", "sum", "index", "key", "type", "test", "code", "time", "total", "i", "add", "max", "size", "thread", "keep", "self", "len", "number", "ind", "id", "found", "counter", "cache", "c", "start", "name", "find", "other", "list", "order", "pool", "first", "current", "close", "force"], "currentMovie": ["currentPicture", "parentMovie", "thisMovie", "thisPicture", "currentmovie", " currentImage", " currentFilm", "currentImage", " currentmovie", "reportedMusic", "currentlyMusic", "validMovie", "defaultMusic", "parentmovie", "reportedTheme", "defaultMovie", " currentMusic", "defaultFilm", "reportedmovie", "currentlyMovie", "validFilm", "currentFilm", " currentPicture", "currentlyPicture", "CurrentTheme", "defaultImage", "currentMusic", "currentTheme", "thisFilm", "CurrentFilm", "Currentmovie", "reportedImage", "reportedPicture", "parentFilm", "CurrentMovie", "parentPicture", "reportedFilm", "reportedMovie", "validmovie", "thismovie", "validTheme"], "movieName": ["voiceId", "MovieInfo", "filmFamily", "movieInfo", "voiceInfo", "voiceName", "filmNumber", "Moviename", "movieNumber", "MovieId", "voicename", "movieId", "moneyName", " moviename", "moviename", "MovieFamily", "moneyFamily", " movieFamily", "movieFamily", "camFamily", "MovieName", "camname", "moneyNumber", " movieInfo", "MovieNumber", "filmname", " movieId", "filmName", "camName"], "customer": ["CustomER", "mixER", " customeri", " customers", "customers", " customER", "Customer", "ustomeri", "customER", "ustomor", "Customers", "mixor", "ustomers", "ustomER", "mixers", "customor", "mixer", "Customor", "Customeri", "ustomer", "customeri"], "rating": ["setting", "attribute", "padding", "writer", "url", "resource", "rolling", "ring", "rate", "rc", "info", "data", "ranking", "writing", "reading", "rage", "range", "packing", "missing", "error", "score", "type", "comment", "reader", "ing", "ruby", "rr", "number", "feature", "r", "id", "string", "rated", "RC", "alpha", "rates", "Rating", "rank", "value", "http", "radius", "rice", "including"], "outBuf1": ["outKuf3", "outBafOne", "outDuff3", "outBum01", "outBuf91", "outBuff3", "outFuf91", "outKbuffOne", "outBiff01", "outBaf1", "outCuffOne", "outCuff0", "outBummerCloud", "outKbuff1", "outKbuf3", "outBbuf1", "outBbuf01", "outBum91", "outFafOne", "outBuff2", "outFuf01", "outCufOne", "outBuff0", "outFbuf1", "outBbuff8", "outFbuf91", "outBufOne", "outBummerOne", "outBufn", "outDufn", "outBiffOne", "outKuf2", "outBuff11", "outCuf1", "outBaf3", "outFafCloud", "outBumOne", "outBbuf91", "outCuf0", "outBaf0", "outBuf3", "outKuf1", "outBalth3", "outBaft3", "outFufCloud", "outBalth1", "outBafCloud", "outBum1", "outDuff1", "outBbufOne", "outBiff91", "outBuf11", "outBbuffOne", "outBbuff1", "outBummer1", "outBbuf3", "outDuff11", "outFuf1", "outBbuff3", "outCuff1", "outFufOne", "outKbuf1", "outBbuff0", "outKbuff3", "outKbuff8", "outBuf8", "outBbuf2", "outBaft11", "outBuff8", "outBuf01", "outBuff1", "outBbuf11", "outBaftn", "outBaf8", "outBiff1", "outBuf0", "outDuf11", "outBbufn", "outFbuf01", "outBuffOne", "outFaf1", "outDuffn", "outBaft1", "outBufCloud", "outKufOne", "outDuf3", "outBuffCloud", "outBalth2", "outKuf8", "outKbuf2", "outFbufOne", "outBuffn", "outDuf1"], "outBuf2": ["outBbufTwo", "outBbufferB", "outBum8", "outFbuff2", "outWBuf4", "outBuber8", "outBuff4", "outBbuf1", "outBum20", "outFuf8", "outBuff12", "outWBuff4", "outFuf20", "outFbuff4", "outBbuff20", "outBuff2", "outBuff0", "outBbuff8", "outWBufTwo", "outWBuf8", "outFufTwo", "outBuber82", "outBbuf12", "outFuf2", "outBbuff82", "outFufB", "outBoffTwo", "outBbuffer12", "outWBuff0", "outFbuff82", "outBait8", "outBait4", "outFbuff8", "outBuffB", "outBoff2", "outBuf82", "outBoff8", "outBait0", "outBbuffer4", "outBait200", "outBuf200", "outWBuf0", "outBbufB", "outBbuffTwo", "outWBuf2", "outFuf4", "outFbuff20", "outBuber20", "outWBuff2", "outWBuff8", "outBuf12", "outFbufB", "outFbuf12", "outFbuf2", "outBbuff2", "outWBbuff200", "outFbuff1", "outBbuff1", "outBuffTwo", "outFuf1", "outWBbuffTwo", "outBufTwo", "outFuf12", "outFbuffTwo", "outBbuf4", "outWBbuff2", "outBbuff0", "outBum2", "outBuf8", "outBbuf2", "outBuff8", "outFuf82", "outBaitTwo", "outBuff1", "outBbuff4", "outBuf0", "outWBbuff8", "outBufB", "outBoff200", "outBuf20", "outWBuf200", "outBbuff200", "outFbuf4", "outBbuffer2", "outBum82", "outBuber2", "outBuf4", "outBait2"], "endOfIndexFile": ["endOfClientTime", "endofLinkFiles", "endOfLinkfile", "endofindexFolder", "endOfImageFile", "endofIndexFile", "endOfDataTime", "endOfindexTime", "endOfIndexDir", "end\n", "endOfImageFiles", "endofLinkFile", "endOfindexFolder", "endOfClientDir", "endofindexTime", "endOfLinkFiles", "endOfindexDir", "endOfIndexfile", "endofLinkTime", "endOfImageTime", "endOfDataFile", "endOfIndexTime", "endOfLinkFile", "endOfClientFile", "endOfIndexFolder", "endofIndexFiles", "endOfDatafile", "endOfIndexFiles", "endOfDataDir", "Endfile", "endOfLinkDir", "endOfindexFiles", " end\n", "endedfile", "End\n", "endOfindexFile", "endfile", "endofIndexFolder", "endofLinkDir", "endOfLinkTime", "endofIndexTime", "endOfindexfile", "endofIndexDir", " endfile", "endofindexFile", "endOfImageFolder", "ended\n", "endOfClientFiles", "endofindexFiles"]}}
{"id1": "1188100", "id2": "13565787", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 0, "substitutes": {"test": [" testing", "report", "write", "server", "call", "example", "debug", "build", "method", "Test", "check", "fail", " example", " evaluate", "run", "error", "out", "create", "print", " Test", "show", "tests", "start", "testing", "execute"], "s": ["ls", "js", "ssl", "south", "e", "server", "b", "g", "ss", "n", "os", "ps", "rs", "stats", "sv", "ns", "si", "session", "sync", "in", "sb", "f", "es", "bis", "o", "d", "us", "storage", "sets", "lines", "h", "fs", "out", "ms", "settings", "ws", "i", "is", "source", "sym", "l", "stream", "states", "outs", "ils", "ses", "S", "less", "service", "w", "ts", "ops", "sl", "ans", "as", "gs", "state", "cs", "abs", "services", "opens", "bs", "its", "p", "ks", "ds"], "input": ["rss", "ssl", "flow", "image", "copy", "null", "io", "data", "reading", "raw", "output", "in", "audio", "o", "storage", "read", "out", "temp", "instance", "i", "source", "xml", "driver", "reader", "qa", "a", "stream", "Input", "r", "up", "w", "php", "response", "buffer", "feed", "request"], "writer": ["WR", "book", "wr", "write", "wan", "null", "letter", "io", "outer", "data", "writing", "raw", "written", "writ", "output", "editor", "str", "o", "storage", "Writer", "key", "out", "xml", "temp", "rw", "source", "builder", "reader", "riter", "work", "er", "worker", "walker", "r", "string", "wa", "w", "per", "wb", "writers", "layer", "wrapper", "keeper", "ler", "word", "buffer", "office", "pointer"]}}
{"id1": "21824901", "id2": "23452437", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"copyExternalResource": ["copyInternResources", "copyApplicationSourceFile", "copyExternalSourceFile", " copyInternalResources", " copyInternalResource", "copyApplicationResources", "copyInternalResources", "copyApplicationResource", "copyExternalURL", "copyInternSourceFile", "copyExternalResources", " copyExternalResources", " copyExternalURL", "copyInternalURL", "copyInternURL", "copyInternResource", "copyInternalSourceFile", "copyApplicationURL", "copyInternalResource", " copyInternalURL", " copyExternalSourceFile", " copyInternalSourceFile"], "sourceFile": ["destPage", "SourceFile", "inputPage", "srcPath", "sourceDirectory", "inputFile", "srcDirectory", "Sourcefile", " sourceDirectory", "sourcePage", "srcfile", " sourceStream", "inputStream", "sourcefile", "SourcePath", "inputfile", " sourcePage", " sourcefile", "destfile", "SourceDirectory", "srcFile", "sourcePath", "destStream", " sourcePath", "sourceStream"], "destFile": [" destPoint", "distDirectory", "DestPoint", "sourcePoint", "parentFile", "destFiles", "distFile", "DestDirectory", "targetDir", "destPoint", "parentFiles", "srcDirectory", "parentfile", "srcDir", "srcFiles", "parentDir", "distfile", "distDir", "srcfile", "DestFile", "destDir", "Destfile", "sourcefile", " destDirectory", " destfile", "DestDir", "targetfile", "targetFile", "targetDirectory", " destFiles", "destDirectory", "sourceFiles", "destfile", "srcFile", " destDir", "DestFiles", "sourceDir"], "source": ["proxy", "url", "uri", "unit", "resource", "image", "core", "server", "parent", "dest", "null", "scope", "connection", "ce", "this", "si", "session", "sync", "link", "channel", "output", "status", "Source", "result", "input", "sin", "class", "api", "src", "reader", "size", "client", "config", "stream", "target", "slave", "inner", "slice", "table", "object", "id", "cache", "ource", "file", "start", "service", "reference", "SOURCE", "context", "get", "pointer", "current", "plus", "use", "from"], "destination": ["declruction", "Destribution", "constination", "constribution", "destruction", "Destinator", "dependination", "dependinated", "declinator", " destinated", " destribution", "destribution", "declinated", " destinator", "destinated", "Destination", "declination", "dependruction", "origruction", "dependinator", "construction", " destruction", "destinator", "Destinated", "Destruction", "originator", "origination", "originated", "constinator"]}}
{"id1": "12242903", "id2": "1966310", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "label": 0, "substitutes": {"hashKey": ["hashSecret", "buildkey", "HashSecret", "Hashkey", "hashkey", "buildKey", "HashKEY", "shakey", "shaSecret", "shaKey", "buildSecret", "hashKEY", "shaKEY", "HashKey", "buildKEY"], "key": ["k", "crypt", "prefix", "text", "keys", "message", "cert", "parent", "connection", "Key", "data", "this", "sync", "check", "input", "block", "hex", "sum", "password", "type", "code", "temp", "source", "pair", "seed", "number", "base", "sign", "mac", "user", "object", "id", "cache", "token", "string", "address", "name", "mix", "x", "value", "word", "chain", "use", "secret", "KEY"], "hashed": ["hsashing", "bhashed", "hhed", "Hhed", " hoded", "hsashed", "hhashing", "hhashed", "Hotted", "hoded", "shotted", "Hashed", "hhash", "bhash", "Hashing", "shashed", "ahashed", "bhotted", "hsasha", " hhed", "Hasha", "bhashing", "shhed", "Hoded", "hhasha", "hasha", "ahash", "ahashing", "shash", "shoded", "hsash", "hotted", "hashing", "shashing", "ahhed", "Hash"], "md5": [" md50", "md62", "md50", "MD3", " mddown", "amd3", "mand50", "MD512", " md512", "base4", "MD5", "amd2", " md2", "md3", " md3", "base62", "md2", "amddown", "MD62", "md4", "base2", " md62", "amd5", "mddown", "mand512", "MD4", "MD2", "MDdown", "mand5", "base5", " md4", "mand4", "md512", "MD50"], "hash": ["ash", "array", "log", "url", "message", "image", "length", "copy", "count", "html", "sha", "num", "rh", "dot", "carry", "search", "f", "her", "result", "check", "hex", "sum", "shadow", "h", "code", "abi", "print", "size", "base", "mac", "hed", "id", "cache", "string", "v", "Hash", "json", "value", "throw"]}}
{"id1": "442381", "id2": "16969205", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doBuildCheck", "doversioncheck", " doVersionWork", "doversionTest", "doVersioncheck", " doReleaseCheck", "doReleaseWork", "doVersionTest", "doVERSIONcheck", " doBuildWork", "doBuildTest", "doVERSIONTest", "doReleasecheck", "doVERSIONWork", " doReleaseTest", "doVERSIONCheck", " doReleasecheck", "doBuildcheck", " doVersioncheck", " doBuildcheck", "doversionCheck", "doReleaseTest", "doVersionWork", " doBuildTest", "doBuildWork", "doReleaseCheck", "doBuildCheck", " doVersionTest"], "view": ["page", "widget", "request", "e", "image", "server", "html", "style", "body", "form", "lock", "event", "cell", "this", "session", "port", "display", "model", "input", "accept", "out", "row", "el", "see", "comment", "reader", "config", "gui", "client", "l", "use", "self", "edit", "can", "VIEW", "object", "screen", "div", "cache", "show", "v", "layout", "change", "window", "vis", "gu", "app", "full", "views", "sel", "ui", "buffer", "update", "q", "http", "box", "block", "View"], "url": ["log", "uri", "ssl", "resource", "ll", "server", "image", "build", "connection", "socket", "blog", "channel", "f", "zip", "input", "URL", "bel", "source", "client", "l", "stream", "web", "base", "user", "address", "string", "file", "loader", "service", "ob", "sl", "host", "lib", "path", "Url", "buffer", "hub", "http", "bb", "open", "browser"], "in": ["ins", "resource", "In", "b", "n", "init", "data", "socket", "inc", "gin", "input", "bis", "din", "IN", "lin", "inn", "out", "s", "cin", "i", "is", "win", "source", "reader", "sin", "rin", "nin", "stream", "login", "inner", "ac", "file", "con", "binary", "ini", "as", "buffer", "isin"], "bin": ["border", "log", "ln", "fin", "b", "body", "lock", "init", "data", "socket", "part", "oin", "gin", "input", "din", "IN", "lin", "run", "inn", "inline", "out", "abi", "cin", "sin", "kin", "win", "reader", "record", "ruby", "inner", "bn", "file", "con", "loader", "binary", "lib", "pin", "bot", "bi", "buffer", "spin", "nb", "bb", "browser"], "line": ["page", "text", "LINE", "pe", "log", "lf", "e", "message", "unit", "le", "b", "style", "letter", "cell", "data", "ge", "link", "nl", "part", "no", "entry", "definition", "model", "rule", "site", "str", "valid", "split", "lin", "cl", "lines", "end", "key", "inline", "row", "el", "code", "job", "band", "home", "i", "source", "comment", "parse", "pass", "l", "ip", "base", "object", "look", "id", "day", "string", "load", "file", "Line", "name", "up", "layer", "lo", "word", "lc", "non", "ine", "block"], "develBuild": ["deployRun", "DEVELBuilt", "desvelRelease", "deVELBuilt", "desvelRun", "deelRun", "desvelBuilder", "DEVELbuild", "deVELbuild", "deployBuilder", "dewardBuilt", "desvenRelease", "develRun", "desvenBuilder", "devenBuilt", "develBuilder", "desvelBuilt", "deviousbuild", "dewardbuild", "desvelBuild", "desvenbuild", "deelBuilder", "deployBuild", "DEvelBuilder", "deelRelease", "dewardBuilder", "deVELBuilder", "devenbuild", "devenBuilder", "desvenBuild", "develRelease", "dellRun", "deviousBuilt", "deVELRun", "DEvelBuild", "deelBuild", "desvelbuild", "DEVELBuild", "devenRun", "devenBuild", "dellBuild", "DEvelbuild", "develbuild", "dellBuilder", "deployBuilt", "dewardBuild", "DEVELBuilder", "desvenRun", "develBuilt", "devenRelease", "DEvelBuilt", "deploybuild", "deVELBuild", "deviousBuild", "dellRelease", "desvenBuilt"], "stableBuild": ["validBuilder", "compatiblebuild", "stablebuild", "secureBuilder", "compatibleBuild", "prettyBuild", "latestbuild", "validbuild", "prettyBuilder", "compatibleBuilder", "staticBuilder", " stableBuilder", " stablebuild", "latestBuild", "baseVersion", "staticbuild", "stableVersion", " stableVersion", "prettyVersion", "prettybuild", "baseBuild", "staticBuild", "stableBuilder", "validBuild", "latestBuilder", "baseBuilder", "securebuild", "basebuild", "secureBuild"]}}
{"id1": "14819747", "id2": "20568568", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"debug": ["enabled", "doc", "log", "DEBUG", "console", "play", "module", "details", "build", "remote", " debugger", " debugging", "tag", " DEBUG", "depth", "store", "die", "reg", "display", "enable", "status", "error", "dev", "date", "test", "plugin", "progress", "trace", "comment", "config", " Debug", "print", "develop", "github", "dump", "Debug", "db", "ger", "quiet", "export", "cache", "show", "file", "err", "development", "admin", "help", "root", "bug", "production", "real", "active"], "prologFile": ["PrologModule", " problogFull", "Prologfile", " prologfile", "deflogSourceFile", "prologPath", " proLogHeader", "prolexModule", "defLogFILE", "problogDir", " proLogFiles", "problogFull", "proconfigFile", "procatFile", "prologSource", "ProLogString", "prolangSourceFile", "proLogFILE", "problogHeader", "proLogfile", "rologPath", "roLogPath", " problogfile", "ProLogModule", "prolangfile", "procatPath", "prollPath", "prollFile", "proLogFiles", "propathFile", "prologHeader", "procatfile", "rologfile", "problogfile", "deflogFILE", "defblogFile", "problogStream", "probaseFiles", "prologSourceFile", "PrologFile", "proconfigModule", "proLogHeader", "rologFile", "rologSource", "prologFull", "proLogFull", "proLogStream", "procatSource", "prolexfile", "prollfile", " problogFile", "proLogSource", "probaseFile", "prologDir", " proLogFile", "proconfigString", "defLogPath", "proLogFile", "defblogDir", "proflowSourceFile", "prolexString", " proLogStream", "propathfile", "deflogDir", " prologSourceFile", "defblogfile", "roLogFile", "probaseStream", "prolangFile", " prologFiles", "deflogPath", "prologStream", "prolexFile", "proLogModule", "proversionPath", "propathDir", "problogFile", " prologStream", "prologModule", "proflowDir", " prologHeader", " problogSourceFile", "ProLogFile", "proflowfile", "proconfigPath", "prologString", "ProLogfile", " prologFull", "proversionSourceFile", "proconfigSourceFile", "problogSourceFile", "problogFiles", "probaseHeader", "proversionFILE", "prollSource", "prologFILE", "proversionFile", "prolangFull", "proLogString", "defLogSourceFile", "defblogSourceFile", "roLogfile", "proconfigfile", "proLogSourceFile", "proLogPath", "deflogfile", "deflogFile", "propathSourceFile", "prologFiles", "proflowFile", "PrologString", "prologfile", "proconfigFILE", "defLogFile", "roLogSource"], "targetFile": [" targetDirectory", "Targetfile", "targetDir", "targetPath", "sourceDirectory", " targetFiles", " targetfile", "TargetFile", "targetFiles", "outputFile", "sourceFile", "TargetDir", "sourcefile", "TargetPath", "outputPath", "TargetDirectory", "targetfile", "TargetFiles", "targetDirectory", "outputDir", "sourceFiles", "sourcePath", "sourceDir", "outputfile"], "source": ["proxy", "text", "description", "uri", "unit", "resource", "message", "style", "scope", "view", "term", "body", "data", "options", "session", "model", "Source", "result", "input", "str", "zip", "stack", "template", "type", "i", "class", "comment", "src", "config", "parse", "target", "slice", "position", "id", "language", "string", "ource", "file", "name", "service", "sl", "SOURCE", "json", "content", "buffer", "format", "use"], "myParser": [" myReader", "MyProgram", "yourProgram", "yourReader", "yourParser", "yourJar", " myJar", "MyJar", "myReader", "myJar", "MyReader", "MyParser"], "myProgram": ["Myprogram", "MYprogram", "MyPlan", "yourprogram", "MYProgram", "yourMath", " myprogram", "theMath", "yourParser", "theParser", "MYParser", "yourPlan", "myprogram", "theProgram", "myMath", "yourProgram", "MyProgram", "myPlan", "theprogram", " myPlan", " myMath", "MyParser"], "myVisitor": ["myAuditors", "myVisitable", "myVisititable", "myVisulator", "myVisiter", " myVisitable", "mySignitor", "myvisit", "myAuditable", "myVISIT", "MyVisitor", " myVisIT", "MyVisiter", "mySigniter", "myExitor", "myvisIT", "Myvisitors", "myVisitit", "mySignulator", "myvisitable", "myVISitor", " myvisitable", "MyVisulator", "myExitors", " myvisit", " myvisitor", " myvisitors", "myVisititor", "myVISitable", "myAudit", " myVisitors", "Myvisulator", "MyVisitors", "myExulator", "myVisititors", "myDesignitable", "myDesignIT", "myVISit", "myvisulator", "myExiter", "mySignitors", "myVisit", "Myvisiter", "myDesignitor", "myDesignit", " myVisit", "Myvisitor", "myvisitors", "myVisIT", "myvisitor", " myvisIT", "myvisiter", "myAuditor", "myVisitors"], "adapterLayer": ["adptionFactory", "adaptersLayer", "acapterBuffer", "adviceLanguage", "adptionBuffer", "admissionLayer", "admissionContainer", "adapterContainer", "acaptersContainer", "adaptersBuffer", "adviceInfo", "acapterInfo", "admissionLanguage", "acapterLayer", "acapterLanguage", "adapterInfo", "adviceLayer", "adapterBuffer", "adviceBuffer", "acaptersInfo", "adaptersInfo", "adapterFactory", "adaptersLanguage", "adviceContainer", "acaptersLanguage", "acaptersBuffer", "adptionLayer", "adptionInfo", "adviceFactory", "acaptersFactory", "adaptersContainer", "adaptersFactory", "acapterFactory", "acapterContainer", "acaptersLayer", "adapterLanguage"], "classLoader": ["ClassLoader", "classPath", "staticLoader", "classDir", "staticloader", "ClassPath", " classPath", "staticDir", "Classloader", "classloader", " classDir", "ClassDir", " classloader", "staticPath"], "adapterWriter": ["admissionWriter", "attaptersWrite", "admissionWrite", "adaptersWrite", "adaptersWriter", "attaptersReader", "adAdapterWrite", "adAdapterwriter", "attapterReader", "admissionReader", "admissionwriter", "adapterswriter", "attapterWriter", "attapterwriter", "adapterReader", "adAdapterWriter", "attapterWrite", "adapterwriter", "adapterWrite", "attapterswriter", "adAdapterReader", "adaptersReader", "attaptersWriter"], "annotationGenerator": ["annotationgencer", "annnotationGenator", "annotationGator", "annotationGenerators", "annotationGcer", "annnotationGenercer", "annnotationGenators", "annnotationGenerator", "annotationGencer", "annnotationGenerators", "annnotationGeneroder", "annnotationGencer", "annotationgenators", "annnotationGenoder", "annotationgenator", "annotationGators", "annotationGoder", "annotationGenator", "annotationGenators", "annotationgenoder", "annotationGenercer", "annotationGenoder", "annotationGeneroder"], "out": ["prefix", "page", "gen", "log", "array", "flow", "server", "parent", "copy", "n", "cmd", "lock", "io", "outer", "store", "sys", "sync", "raw", "output", "in", "group", "Out", "error", "conn", "code", "temp", "print", "cli", "dump", "point", "outs", "user", "bar", "cache", "v", "err", "obj", "list", "up", "net", "pre", "OUT", "down", "diff", "query", "state", "chain", "again", "line", "post"]}}
{"id1": "3683344", "id2": "21425787", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandGUID", " genRandGID", " genRandomGID", " genRandomUID", " genRandomIGUID", " genRandUID", " genRandomGUuid", " genRandomGuid", " genRandUUID", " genRandomUUID", " genRandGIP", " genRandomGUIP", " genRandomGIP", " genRandUIP", " genRandomIGuid", " genRandomUuid", " genRandomUIP", " genRandomIGIP", " genRandGuid", " genRandomGUUID", " genRandomIGID", " genRandUuid"], "secure": ["proxy", "ssl", "server", "debug", "protect", "remote", "depth", "sys", "random", "allow", "session", "weak", " insecure", "sensitive", "zip", "smart", "str", "encrypted", "sec", "password", "forced", "timeout", "require", "config", "client", "seed", "stable", "https", "security", " Secure", "safe", "deep", "host", "ssh", "fast", "Secure", "close", "active", "force", "q", "secret", "exclusive"], "valueBeforeMD5": ["valueBeforemd3", "valueBeforeMC3", "valueBeforeMP3", "valueBeforeMD85", "valueAfterMD85", "valueAfterMS1", "valueBeforeMS5", "valueBeforeMT20", "valueBeforeMT55", "valueBeforeSHA3", "valueBeforeMP5", "valueBeforeMT05", "valueBeforeMT3", "valueBeforeMT5", "valueAfterMC3", "valueBeforeMC5", "valueAfterMD1", "valueAfterMC8", "valueBeforeMP2", "valueBeforeAMD20", "valueBeforeMD8", "valueBeforeMR85", "valueBeforeMS3", "valueAfterMD20", "valueBeforeMR5", "valueBeforemd85", "valueAfterMS2", "valueBeforeM1", "valueBeforeSHA1", "valueBeforeMP55", "valueBeforeMD3", "valueBeforeMR8", "valueBeforeMC8", "valueBeforemd8", "valueAfterMS5", "valueBeforeSHA5", "valueBeforeMR3", "valueBeforeMD05", "valueBeforeM2", "valueAfterMD2", "valueBeforeAMD05", "valueBeforeMS2", "valueAfterMS3", "valueBeforeSHA2", "valueBeforeMT2", "valueAfterMC5", "valueBeforeAMD5", "valueBeforemd5", "valueBeforeMD1", "valueBeforeMS1", "valueBeforeMC85", "valueBeforeMD20", "valueBeforeM5", "valueBeforeAMD3", "valueBeforeM3", "valueAfterMD05", "valueAfterMD8", "valueBeforeMD2", "valueBeforeMD55", "valueAfterMD3", "valueAfterMD55", "valueAfterMC85"], "valueAfterMD5": ["valueBeforeMP3", "valueAfterMF05", "valueBeforeMP1", "valueAfterDM3", "valueAfterDM512", "valueAfterMP1", "valueAfterAST2", "valueAfterAST5", "valueBeforeAST3", "valueAfterDF5", "valueAfterHTML512", "valueBeforeMP05", "valueAfterMC5", "valueAfterM5", "valueBeforeMD1", "valueAfterMCql", "valueAfterMD3", "valueBeforeAST2", "valueAfterM2", "valueBeforeVM5", "valueBeforeMPTE", "valueAfterAST512", "valueAfterHTML5", "valueAfterMC3", "valueBeforeMC5", "valueAfterAST3", "valueAfterMD1", "valueBeforeAST5", "valueBeforeMD512", "valueBeforeMP2", "valueAfterMDql", "valueAfterVM3", "valueBeforeMD3", "valueAfterDF005", "valueAfterMC1", "valueAfterMPTE", "valueAfterMT5", "valueAfterGM5", "valueAfterMFTE", "valueAfterVM5", "valueAfterM3", "valueBeforeMC3", "valueAfterMF3", "valueBeforeMP5", "valueAfterMDody", "valueAfterMF5", "valueAfterAMD5", "valueAfterMT3", "valueAfterMD005", "valueBeforeMCql", "valueAfterAMD3", "valueAfterDMody", "valueBeforeMD05", "valueAfterHTML3", "valueAfterMD2", "valueAfterMP05", "valueAfterMTql", "valueBeforeMDTE", "valueBeforeVM3", "valueAfterAMD005", "valueAfterGM2", "valueAfterMD05", "valueBeforeAST005", "valueAfterHTMLTE", "valueAfterGM3", "valueAfterMDTE", "valueAfterDM5", "valueAfterASTody", "valueAfterHTML05", "valueBeforeAST512", "valueAfterVM005", "valueAfterHTMLody", "valueAfterMP3", "valueAfterAST005", "valueAfterM1", "valueAfterMP005", "valueBeforeMDql", "valueBeforeASTody", "valueAfterMD512", "valueBeforeMDody", "valueBeforeMD005", "valueAfterDF3", "valueAfterMC2", "valueAfterGM005", "valueAfterMP2", "valueAfterMP5", "valueBeforeMD2", "valueBeforeVM005"], "md5": ["md05", " MD05", "cmd5", "mandkey", " md05", "MD512", "md53", " md53", " md25", "MD5", " md512", "cmd1", " MD53", "amd2", " md2", "cmd65", " MD5", " mdkey", "md3", " md3", "md2", "md1", "amd25", "mand1", "md65", "md25", "amd5", "mdkey", "mand512", " md65", "mand2", " MD3", "mand3", "MD2", " md1", "mand65", "cmd05", "mand5", "cmd53", "cmd512", "cmdkey", "MD25", "amd512", "md512", "cmd3", "cmd2"], "sbValueBeforeMD5": ["sbValueBeforeND525", "sbValueBeforeND5", "sbValueBeforeMC5", "sbValueBeforeMS2", "sbValueBeforeMM5", "sbValuebeforeND3", "sbValueBeforeMT55", "sbValueBeforeMC25", "sbValueBetweenmd5", "sbValueBehindMD25", "sbValueBehindMD3", "sbValueWithoutMD5", "sbValueBeforeMD25", "sbValueBeforemd2", "sbValueBeforeMF3", "sbValueBeforeMF5", "sbValueBeforeAMD1", "sbValueBeforeMP55", "sbValueBeforeMR5", "sbValueAfterMP3", "sbValuebeforeND5", "sbValueBehindMD525", "sbValueBeforeND85", "sbValueAfterMP512", "sbValueBeforeND25", "sbValueBeforeMM005", "sbValueBeforeMT005", "sbValueBeforeMD35", "sbValueAfterMD1", "sbValueBetweenMD305", "sbValueBeforeMP512", "sbValueInsideAMD5", "sbValueBeforeMS1", "sbValueBeforeMR3", "sbValueInsideMD5", "sbValueBeforeMD305", "sbValueAfterMP5", "sbValueBeforeAMD2", "sbValueBeforeND2", "sbValueBeforeAMD305", "sbValueBeforeMT3", "sbValueBeforeMM3", "sbValueBeforeMG25", "sbValueBeforeMP25", "sbValueAfterMD3", "sbValueInsideAMD3", "sbValueBetweenMD5", "sbValueBeforeMT5", "sbValueBehindND5", "sbValueAfterMD512", "sbValueBeforeMD2", "sbValueBehindND525", "sbValueBehindND25", "sbValueWithoutMD35", "sbValuebeforeMD85", "sbValueAfterMP005", "sbValueBeforeMF35", "sbValueBetweenmd2", "sbValueBeforemd3", "sbValueBeforeMP05", "sbValueBeforeAMD05", "sbValueInsideAMD25", "sbValueBeforeMP5", "sbValuebeforeMD2", "sbValuebeforeND85", "sbValueInsideAMD05", "sbValueBehindMD5", "sbValueBeforemd305", "sbValueBeforeMD55", "sbValueBeforeMS85", "sbValueAfterMD5", "sbValueBeforeAMD3", "sbValueWithoutMF35", "sbValueBehindND3", "sbValueBeforeMD85", "sbValueBeforeMD525", "sbValueBeforeMF25", "sbValueBeforeMS3", "sbValueBeforeMC35", "sbValueBeforeMR25", "sbValuebeforeND2", "sbValueBetweenmd305", "sbValueBeforeMR525", "sbValueBeforeMS512", "sbValueBeforeMG3", "sbValueWithoutMF3", "sbValueBeforeMP1", "sbValueBeforeMP85", "sbValueAfterMD005", "sbValueBeforeMC3", "sbValueWithoutMF5", "sbValueWithoutMD3", "sbValueBeforeMP305", "sbValueBeforeMP3", "sbValueBeforeMD1", "sbValueBeforeAMD25", "sbValueWithoutMF25", "sbValueBeforeMD3", "sbValueBeforeMS5", "sbValueWithoutMD25", "sbValueBeforemd5", "sbValueBetweenMD2", "sbValuebeforeMD5", "sbValueBeforemd25", "sbValueBeforeND3", "sbValueBeforemd05", "sbValueBeforeMG35", "sbValueBetweenmd3", "sbValueAfterMP1", "sbValuebeforeMD3", "sbValueInsideMD3", "sbValueAfterMD55", "sbValueBeforeMP005", "sbValueBeforeAMD5", "sbValueBeforeMM55", "sbValueAfterMP55", "sbValueBeforeMD512", "sbValueBeforeMD05", "sbValueBeforeMP2", "sbValueInsideMD25", "sbValueBeforeMP525", "sbValueBetweenMD3", "sbValueBeforeAMD512", "sbValueBeforeMD005", "sbValueInsideMD05", "sbValueBeforeMG5"], "time": ["TIME", "delay", "money", "clock", "length", "count", "tz", "speed", "race", "etime", "version", "depth", "random", "duration", "times", "port", "year", "mode", "hour", "timer", "error", "date", "timeout", "type", "temp", "size", "ime", "seed", "work", "month", "id", "counter", "cost", "start", "age", "name", "host", "Time", "value", "q", "sleep", "rate"], "rand": ["pick", "rss", "delay", "raid", "nd", "core", "ro", "length", "count", "dr", "rc", "rh", "version", "depth", "mid", "random", "bit", "reg", "rage", "winner", "range", "year", "risk", "rule", "index", "error", "type", "ng", "win", "max", "seed", "rr", "round", "r", "id", "alpha", "dist", "name", "re", "root", "order", "pattern", "bug", "clean", "rank", "q", "Rand", "serial", "rate", "right"], "array": ["sample", "arrow", "air", "arr", "module", "image", "integer", "view", "range", "all", "now", "area", "archive", "index", "batch", "error", "row", "our", "element", "instance", "multi", "record", "section", "pair", "expression", "a", "number", "feature", "table", "r", "object", "address", "cache", "string", "Array", "app", "list", "angle", "vector", "bug", "function", "value", "ray", "collection", "database"], "strTemp": [" strTem", "brTemp", "arrTest", "arrTemp", "brVar", "crTemp", "drTem", "crTemplate", "crTem", "strVar", "stringtemp", "drVar", "arrBase", "objFake", "strTemplate", " strTest", "strTest", "stringFake", "strFake", "objTem", "drtemp", "strTem", "crtemp", " strtemp", "brTest", " strBase", "Strtemp", " strTemplate", "objtemp", "arrtemp", "drTemp", "stringTemp", "objTemp", "strBase", "StrBase", " strVar", "brtemp", "brTem", "drTemplate", "strtemp", "stringTem", "StrTemp", "arrTem", " strFake"], "i": ["k", "p", "u", "z", "uri", "e", "j", "b", "n", "io", "info", "si", "ie", "in", "field", "f", "o", "index", "d", "ci", "h", "key", "end", "ji", "abi", "multi", "y", "li", "di", "l", "ip", "pi", "xi", "hi", "eni", "slice", "yi", "id", "ti", "v", "gi", "c", "start", "ix", "I", "ai", "phi", "ii", "ui", "x", "mu", "ri"]}}
{"id1": "6470716", "id2": "8778962", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"st": ["ost", "sth", "std", "Str", "est", "fr", "ct", "const", "sf", "struct", "ste", "sts", "stress", "ST", "sb", "f", "inst", "pt", "str", "tt", "www", "d", "cl", "s", "code", "rest", "St", "class", "src", "ist", "ft", "r", "sc", "id", "string", "stage", "start", "t", "ast", "ld", "put", "ust", "fe", "sta"], "url": ["ur", "ls", "page", "log", "fl", "uri", "ssl", "ll", "fr", "server", "image", "html", "build", "b", "connection", "loc", "pl", "ul", "org", "link", "blog", "f", "impl", "zip", "tool", "www", "URL", "coll", "cl", "bel", "download", "source", "l", "stream", "web", "base", "user", "id", "address", "string", "gl", "file", "err", "ob", "sl", "host", "bug", "path", "Url", "or", "hub", "http", "feed", "bb", "open"], "fis": [" fils", "zips", "lris", "flIs", "zIS", "FIs", "flils", " fiss", "liss", "Fips", "fi", " fIS", "lis", "flos", "Fos", "Fris", "flris", "fris", " fi", "Fiss", "bis", "bos", " fris", " fips", "FIS", "fils", "biss", "lils", "fIs", "fiss", "flis", "fli", "afiss", "fliss", "fips", "zris", "fIS", "afIs", "afis", "bi", "afos", "Fis"], "zis": ["zisi", "zips", "zIS", " zisa", "zbis", "zeisa", "zipis", " zits", "ziss", "zois", "zipits", "qiss", "zenis", " ziss", " zois", "zipiss", "Zais", "ezis", "qis", "zipbis", "ezIS", "Ziss", "Zis", " zi", "qbis", "ezisa", "zeIS", "zeis", " zisi", "zits", "zipois", " zais", " zIS", "zipisi", " zbis", "zais", "zeips", "zipi", " zips", "Zits", "zi", "zenais", "zenois", "zisa", "ezips", "zipais", "zenisi", "qi"], "entry": ["enter", "pe", "fr", "e", "image", "se", "rc", "cell", "info", "ge", "je", "si", "session", "inc", "ie", "part", "in", "spec", "zip", "result", "archive", "exp", "nt", "index", "ace", "sec", "ent", "country", "key", "row", "Entry", "element", "cat", "sea", "comment", "ries", "cel", "record", "reader", "parse", "li", "inner", "de", "r", "object", "address", "match", "file", "obj", "dc", "la", "extra", "next", "auto", "or", "lc", "ident", "line", "feed", "ry"], "count": ["Count", "log", "default", "write", "length", "parent", "_", "offset", "en", "depth", "child", "allow", "more", "part", "limit", "check", "index", "sum", "read", "end", "val", "type", "code", "i", "add", "max", "size", "use", "len", "number", "base", "ind", "id", "cache", "counter", "skip", "load", "file", "c", "start", "name", "list", "current", "buffer", "line", "feed"], "data": ["DATA", "buf", "text", "message", "image", "length", "body", "empty", "info", "raw", "result", "area", "input", "block", "str", "d", "dat", "batch", "read", "bytes", "error", "code", "results", "i", "reader", "size", "a", "len", "number", "cache", "string", "load", "start", "alpha", "content", "buffer", "value", "zero", "shift", "feed", "p"], "fos": ["flnos", "efoses", "fol", "fOS", "Fnos", "Fos", "flos", "znos", "dfosh", "efosh", "foses", "zOS", "zos", "flOS", "fosh", "zol", "flol", "fnos", "dfoses", "fosi", "froses", "frosh", "efosi", "dfos", "frosi", "Fol", "dfosi", "efos", "FOS", "fros"], "dest": ["prop", "std", "exit", "des", "writer", "default", "txt", "south", "const", "style", "Dest", "cdn", "loc", "die", "outer", "later", "sync", "output", "zip", "result", "sum", "dat", "done", "comb", "dev", "end", "out", "test", "home", "temp", "rest", "source", "src", "tmp", "di", "stream", "target", "flash", "inner", "coord", "de", "transform", "slice", "trans", "desc", "dist", "sup", "dc", "wb", "cont", "wh", "img"]}}
{"id1": "7149578", "id2": "8754809", "code1": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"parseContent": ["seDescription", "parserData", "seContents", "parserContent", "parseDescription", " parseDescription", "seContent", "parseContents", "parserDescription", "seData", " parseContents", "parserContents", " parseData", "parseData"], "streamLimiter": [" streamLimitter", "streamGrabiler", "streamlimizer", "urllimited", "streamlimitation", "streamGrabiser", "streamLimitter", "streamLimitite", "streamLimitation", " streamLimite", "streamLimititter", "streamGrabitter", "streamLimitited", "streamlimer", "streamlimite", "streamLimer", " streamLimiser", "urlLimitation", " streamLimititor", "streamlimited", " streamLimititter", "urlLimiter", "streamVisizer", "streamlimitor", "streamLimizer", "streamGrabiter", "streamLimititer", "urllimiter", "streamLimited", "urlLimite", "urlLimited", "streamLimiser", "streamLimititor", "streamLimitor", "urllimite", " streamLimitite", " streamLimiler", "streamViser", " streamLimer", "streamVisiter", "streamLimiler", "streamLimite", "streamVisitter", "urllimitation", "streamlimitter", " streamLimititer", " streamLimizer", "streamlimiter", "streamLimititation", " streamLimitor"], "forcedLang": [" sourceFlamp", " requestedLang", " sourceLevelang", " requestedFlph", " requestedLamp", " sourceLamp", " requestedFlamp", " sourceSang", " requestedFliang", " requestedLph", " sourceLph", " sourceLeveliang", " sourceFlang", " sourceFliang", " sourceSiang", " sourceLevelamp", " sourceFlph", " sourceSph", " requestedLiang", " requestedFlang", " sourceLiang", " sourceLang", " sourceSamp", " sourceLevelph"], "charset": ["charARSeter", "chanset", "Charspace", "chARSet", "chARSett", " Chansets", "chansset", "chapterset", "chaseter", "chaseset", "chARSset", "chaspace", "chararsets", "charspace", "ChasET", "cheARSet", "Chasets", "chararsett", "chasesets", "Chanset", "chearsets", "charsetter", "chacterseter", "chararseter", "charARSET", "chararsset", "charansetting", "cheaset", "hasesets", "chARSets", "chARSetter", "chapsets", "Charsets", "hasespace", "chARSeter", "chardsET", "chearsett", "Charsetting", "charansett", "ChARSett", " Chanset", "chaptersett", "charsetting", "Chansetter", "chactersetting", "chansett", "Charset", "chasetter", "chaptersets", "chearseter", "ChARSets", "ChansET", "charARSett", "charARSets", "cheARSetter", "chapset", "Chansets", "charsET", "cheARSett", "charseter", "chansets", "harspace", "chasets", "chasett", "charARSet", "charsets", "chansetter", "charsset", "chaptersET", " Charsets", " Charset", "chARSpace", "charARSetting", "Chaspace", "chararsET", "chapseter", "cheasets", "cheARSets", "chansetting", "chearsetting", "chasesET", " ChansET", "chardsetting", " Chansett", "chARSET", "chacterset", " Charsett", "charARSset", "harsets", "chasespace", "Charsetter", "chearset", " CharsET", "charsett", "chaptersetting", "Chaset", "haseset", "chapsetting", "chasET", "hasesET", "chansET", "chasetting", "chARSetting", "chardsset", "cheARSetting", "cheasetting", "chardset", "cheaseter", "chanseter", "harsET", "chararset", "chactersET", "chanspace", "CharsET", "harset", "charansET", "Charsett", "chaset", "chararsetting", "ChARSetting", "charanset", "chearsetter", "ChARSet"], "sourceDocument": ["SourceFile", "sourceDocuments", " sourceDoc", " sourcedocument", "SourceDoc", "siteDoc", "SourceContent", " sourceFile", "inputContent", "searchFile", "sourceDirectory", "srcDirectory", "siteContent", "sourcedocument", " sourceDirectory", "SourceDocument", "inputDocument", "sourceDoc", "sourceFile", "searchdocument", "siteDirectory", "siteDocument", "inputDirectory", "siteDocuments", "srcContent", "sourceContent", " sourceContent", " sourceDocuments", "searchDocument", "srcdocument", "SourceDocuments", "searchDocuments", "Sourcedocument", "srcDocument", "inputdocument"], "fieldValueItem": [" fieldValue2", "fieldTextItem", "fieldvalueElement", "fieldFamilyPart", "fieldNameItems", "fieldContentElement", "servervalueitem", "fieldName2", "fieldTypeElement", "fieldFamilyParser", "fieldTypeItem", " fieldNameElement", "stringValue1", "fieldKeyItem", "servervalueAct", "stringNameElement", "fieldContentItems", "fieldItemParser", "stringValueItem", "fieldPathIt", "fieldContent1", "fieldvalue2", "FieldFamilyPart", "fieldValueItems", "fieldValueFile", "fieldNamePart", "fieldValueIt", "fieldValue2", "fieldItemItems", "fieldTypeSource", "fieldPathitem", "fieldValueSource", "fieldProcessItem", "memberProcessItem", "memberValueElement", "fieldType2", "FieldFamilyItem", "fieldProcessitem", "servervalueIt", "fieldValueElement", "stringValueItems", "fieldValueitem", "fieldTypeIt", " fieldValueItems", "fieldvalueAct", "FieldValuePart", "fieldvalueIt", "FieldFamilyParser", "fieldTextElement", "memberProcessFile", "fieldNameParser", "fieldNameitem", "stringName1", "fieldType1", "fieldValueAct", "memberValueFile", "fieldItemPart", "fieldvalueItems", "FieldValueItem", "fieldTypeitem", "fieldvalueItem", "fieldValuePart", "FieldNameItem", "memberProcessElement", "memberValueItem", "fieldProcessFile", "fieldValueParser", "fieldPathAct", "fieldvalueitem", "stringValueElement", "fieldNameFile", "FieldNameSource", "FieldValueParser", "fieldNameElement", " fieldNameItems", "fieldContentItem", "FieldValueSource", " fieldName2", "FieldValueItems", "fieldFamilyItem", "fieldKeySource", "fieldNameSource", "memberValueitem", "fieldTypeAct", "fieldValue1", "servervalueItem", "FieldNameItems", "fieldProcessElement", "memberProcessitem", "fieldTypeItems", "stringNameItem", "fieldFamilyItems", "serverValueAct", "fieldItemItem", "serverValueitem", " fieldNameItem", " fieldValueElement", "FieldFamilyItems", "fieldPathItem", "fieldNameItem", "fieldName1", "fieldTextitem", "serverValueItem", "fieldKeyItems", "fieldTextFile", "serverValueIt", "stringNameItems"], "charsetWasNull": ["charsetISEmpty", "charsetWasNULL", "charsetISnull", "charsetwasEmpty", "charsetwasnull", "charsetWereNULL", "charsettingIsConstruct", "charsettingWasConstruct", "charsetIsnull", "charsetISNull", "charsettingIsEmpty", "charsettingWasNone", "charsetsWasNull", "charsetISNULL", "charsetWasFound", "charsettingWasNull", "charsetWasNone", "charsetPreviouslyNone", "charsetwasNULL", "charsetIsEmpty", "charsetWasnull", "charsetIsNull", "charsettingIsNone", "charsettingIsNULL", "charsetPreviouslyNull", "charsetIsFound", "charsettingIsNull", "charsetWasEmpty", "charsetPreviouslyConstruct", "charsettingIsnull", "charsettWasNull", "charsettingWasEmpty", "charsettWasNULL", "charsettWasFound", "charsetWasConstruct", "charsetWereNull", "charsetIsNone", "charsettingWasnull", "charsetwasNull", "charsetPreviouslyNULL", "charsetsWasnull", "charsetIsNULL", "charsetWereFound", "charsettingWasNULL", "charsetIsConstruct", "charsetsWasNULL"], "writer": ["WR", "text", "widget", "wr", "write", "build", "wrote", "outer", "data", "later", "writing", "parser", "engine", "external", "written", "writ", "output", "wrap", "document", "creator", "editor", "Writer", "out", "type", "xml", "temp", "rw", "source", "builder", "driver", "reader", "rew", "ws", "riter", "worker", "walker", "former", "r", "string", "wa", "handler", "wire", "loader", "w", "wb", "writers", "words", "wrapper", "word", "value", "buffer", "format", "ler", "pointer", "office", "author", "director"], "htmlProvider": ["apiReader", "contentManager", "HTMLLocation", "tmlider", "externalider", "HTMLProv", "tmlProvider", " htmlReader", "tmlManager", "phpProvider", "phpManager", "httpProv", " htmlider", "tmlProv", "htmlPool", "HTMLReader", "htmlFactory", "HTMLContext", "phpFactory", "contentProvider", "htmlManager", "htmlider", "tmlReader", " htmlPool", "phpProv", " htmlContext", " htmlFactory", "HTMLManager", "htmlReader", "tmlFactory", "tmlContext", "browserProvider", "httpider", " htmlLocation", "apiProv", "htmlLocation", "contentProv", "HTMLProvider", "tmlLocation", "browserPool", "tmlPool", "externalProvider", "httpProvider", "contentReader", " htmlProv", "htmlProv", "apiProvider", "browserider", " htmlManager", "htmlContext"], "contentType": ["characterName", "characterType", "nextBody", "ContentBody", "contentName", "Contenttype", "ContentTy", "modelTime", " contenttype", "changetype", "characterTypes", "changeTime", "nextName", " contentTypes", "characterTy", "nextType", "contentTyp", "ContentTypes", "ContentName", "contentTime", "modelType", "contentTy", "contenttype", "modelTyp", " contentTyp", " contentTy", " contentName", "changeTyp", " contentBody", "ContentType", "changeType", "modeltype", "contentTypes", " contentTime", "nexttype", "contentBody"], "contentTypeCharset": ["contentTypeChardsets", "contentTypeCasets", "contentTypeClarsette", "contentTypeCharsSet", "contentTypeChardset", "contentTypeChARSET", "contentTypeCaset", "contentTypeCurarset", "contentTypeCarsSet", "contentTypeChapesET", "contentTypeCurARSets", "contentTypeChARSets", "contentTypeChasET", "contentTypeChangett", "contentTypeCurarsET", "contentTypeCangets", "contentTypeCasetter", "contentTypeCurARSet", "contentTypeChansetting", "contentTypeCharsET", "contentTypeCurARSetting", "contentTypeClarsetting", "contentTypeCurARSET", "contentTypeChARSant", "contentTypeCasett", "contentTypeChasetter", "contentTypeChapterset", "contentTypeChansets", "contentTypeChapesets", "contentTypeEARSET", "contentTypeClarsets", "contentTypeChARSetting", "contentTypeEarsant", "contentTypeCurarsetting", "contentTypeChardsant", "contentTypeCarsett", "contentTypeChasette", "contentTypeChapesette", "contentTypeCangSet", "contentTypeCangetter", "contentTypeEarset", "contentTypeEARSet", "contentTypeChapeset", "contentTypeChansET", "contentTypeChaset", "contentTypeChaptersSet", "contentTypeChaptersets", "contentTypeChARSett", "contentTypeChangets", "contentTypeChanset", "contentTypeChaptersetter", "contentTypeChasetting", "contentTypeClarset", "contentTypeChansett", "contentTypeCarsets", "contentTypeChansant", "contentTypeCharsetter", "contentTypeChangetter", "contentTypeCharsetting", "contentTypeChangSet", "contentTypeEarsets", "contentTypeCarsetter", "contentTypeEARSets", "contentTypeChasets", "contentTypeCharsant", "contentTypeChARSet", "contentTypeCharsett", "contentTypeCharsets", "contentTypeChasant", "contentTypeCharsette", "contentTypeChapesant", "contentTypeChasett", "contentTypeEARSant", "contentTypeChardsetting", "contentTypeChapesetting", "contentTypeChARSSet", "contentTypeCurarsets", "contentTypeCarset", "contentTypeEarsET", "contentTypeChARSetter", "contentTypeChanget", "contentTypeCanget"]}}
{"id1": "11477906", "id2": "2642914", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadDefaultParameters", "loaddefaultsettings", "getdefaultConfiguration", "loadDefaultsettings", "getDefaultConfiguration", "loadGlobalParameters", "getDefaultSettings", "getdefaultParameters", "getDefaultParameters", "getdefaultsettings", "loadApplicationSettings", "loadGlobalsettings", "loaddefaultConfiguration", "loadApplicationsettings", "loadGlobalConfiguration", "loadDefaultConfiguration", "loadApplicationParameters", "loaddefaultSettings", "loadGlobalSettings", "getDefaultsettings", "loadApplicationConfiguration", "loaddefaultParameters", "getdefaultSettings"], "configFileName": ["ConfigFileUrl", "configFileString", "configModuleString", "ConfigModuleString", "configFilesLocation", "fileFileName", "configFilesName", "configModuleName", "configPlaceUrl", "ConfigFileString", "ConfigModuleLocation", "configFullLocation", "fileFileTime", "fileFILEType", "configFilenameTime", "configFilenameName", "configModuleUrl", "fileFileType", "configPlaceName", "fileFILELocation", "configFILEName", "configFilesType", "configFileTime", "configFileType", "configFILELocation", "configFilenameType", "ConfigModuleName", "configFileUrl", "ConfigFileLocation", "configPlaceString", "ConfigModuleUrl", "configModuleLocation", "fileFILETime", "configPlaceLocation", "configFilenameLocation", "fileFileLocation", "fileFILEName", "configFILEType", "configFullUrl", "ConfigFileName", "configFILETime", "configFileLocation", "configFullString", "configFullName", "configFilesTime"], "in": ["m", "log", "ins", "url", "ssl", "resource", "In", "n", "init", "data", "this", "inc", "socket", "it", "f", "input", "din", "IN", "inn", "read", "conn", "pass", "cin", "is", "i", "source", "pull", "reader", "config", "inside", "nin", "stream", "work", "login", "a", "inner", "base", "r", "id", "pc", "con", "err", "bin", "up", "diff", "pin", "ini", "as", "plus", "again"], "out": ["to", "prefix", "ex", "log", "writer", " file", "default", "write", "image", "server", "one", "copy", "null", "parent", "view", "connection", "able", "io", "off", "data", "back", "version", "this", "sync", "socket", "inc", "output", "it", "all", "f", "exp", "o", "set", "d", "password", "Out", "and", "error", "timeout", "conn", "s", "instance", "config", "client", "point", "outs", "user", " back", "object", "string", "exec", "bin", "err", "obj", "file", "c", "name", "up", "net", "ou", "OUT", "t", " output", "again", "lib", "ext"]}}
{"id1": "18339787", "id2": "8917658", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyAll(URL url, Writer out) {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new BufferedInputStream(url.openStream()));\n            copyAll(in, out);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            close(in);\n        }\n    }\n", "label": 0, "substitutes": {"reload": ["overload", "reloading", "preload", "refload", "reffill", "preloading", "prefill", "overresh", "overloading", "refresh", "preresh", "refloading", "reresh", "overfill", "refill"], "currentDate": ["currentDay", " currentTime", "newUpdate", " currentDay", "reportedTime", "currentUpdate", "newDay", "CurrentTime", " currentName", "newDate", "currentName", " currentUpdate", "reportedDate", "currentKey", "newKey", "CurrentKey", "CurrentDate", "CurrentDay", "reportedName", "CurrentUpdate", " currentKey", "currentTime", "reportedDay", "CurrentName"], "xpath": ["exPath", " xparent", " xstream", "Xath", "lexstream", "expath", "axpath", " xPath", "XPath", " xcase", "Xp", "lexparent", "xPath", "lexpath", "xcase", "axath", "xstream", "exp", "Xstream", "txstream", " xath", "Xcase", "xp", "xparent", "xprop", "lexPath", "Xpath", "exstream", "txpath", " xp", "exparent", " xprop", "Xprop", "xath", "axPath", "exprop", "exath", "txPath", "axcase"], "docBuilderFactory": ["docbuilderFactor", "projectBuilder2", "projectBuilderInterface", "projectBuilderFactory", "docBuilderFactor", "docManagerInterface", "docBuildService", "documentBuildService", "docbuilderFactory", "docManagerFactory", "docBuilderF", "docBuilderInterface", "docBuilder2", "projectbuilder2", "docbuilderService", "projectbuilderInterface", "documentBuilderF", "projectbuilderFactor", "docBuild2", "docBuildFactory", "projectBuilderFactor", "documentBuilderService", "docManager2", "docBuildFactor", "docbuilder2", "docBuildF", "docBuilderService", "docbuilderInterface", "documentBuilderFactory", "projectbuilderFactory", "documentBuildF", "documentBuildFactory", "docManagerFactor", "docbuilderF", "docBuildInterface"], "docBuilder": ["docFactory", "documentFactory", "fileBook", "documentParser", "documentBuilder", "xmlParser", "documentBuild", "documentbuilder", "docParser", "Docbuilder", "documentBook", " docBuild", "docbuilder", "fileBuilder", " docBook", " docFactory", "DocParser", "xmlbuilder", "docBook", "fileFactory", "DocBuild", "xmlBuilder", "DocBuilder", "fileBuild", "docBuild", "xmlBuild"], "conn": ["conv", "log", "ssl", "ct", "cn", "server", "uc", "conf", "cp", "connection", "loc", "lock", "body", "cmd", "session", "socket", "channel", "Connection", "connect", "URL", "nt", "coll", "ch", "nc", "ci", "cb", "out", "Conn", "cm", "api", "config", "client", "cli", "l", "db", "ann", "exec", "con", "c", "loader", "ctx", "path", "Url", "lc", "enc", "http", "serv"], "url": ["ls", "log", "ssl", "uri", "ll", "resource", "server", "fr", "image", "build", "connection", "org", "data", "blog", "channel", "f", "impl", "www", "URL", "str", "coll", "bel", "download", "config", "client", "l", "web", "db", "base", "string", "gl", "file", "err", "loader", "ob", "sl", "host", "path", "Url", "http", "feed", "serv"], "xml": ["page", "doc", "rss", "log", "writer", "arr", "txt", "image", "wt", "html", "example", "event", "apache", "data", "model", "document", "zip", "input", "graph", "date", "children", "el", "element", "temp", "wl", "parse", "config", "reader", "atom", "stream", "tree", "node", "email", "layout", "address", "file", "ml", "root", "php", "context", "json", "path", "response", "x", "content", "office", "events", "update", "dom", "http", "feed", "request"], "exchangeRateDate": ["expirePricePrice", "exchangeRateFile", "excurrencyRateDuration", "exchangeRateTime", "exchangeRatingPrice", "exchangeWeightPrice", "exchangeFactorTime", "expireRateDate", "exchangeTimeFile", "excurrencyRateFile", "exchangePricePrice", "exchangePriceKey", "exchangePriceDate", "exchangeRateDuration", "exchangeWeightDate", "exchangeRatingFormat", "exchangeRatingDate", "expirePriceFormat", "exchangePriceFormat", "excurrencyRateTime", "exchangeTimeDate", "exchangeRatingKey", "exchangeTimeDuration", "expirePriceDate", "excurrencyTimeDate", "exchangeTimeTime", "excurrencyTimeDuration", "expireRateKey", "expirePriceKey", "exchangeRateKey", "exchangeWeightKey", "exchangeRateFormat", "excurrencyTimeFile", "excurrencyTimeTime", "expireRatePrice", "expireRateFormat", "exchangeWeightFormat", "exchangeFactorFile", "excurrencyRateDate", "exchangeFactorDate", "exchangeFactorDuration", "exchangeRatePrice"], "currenciesNode": ["curcurrencyPath", "currenciesBlock", "curcurrencyNode", "contractrenciesDocument", "curportsNode", "courrenciesnode", "curatorsNode", "comrenciesNode", "comrenciesPath", "currenciesPath", "cururrenciesnode", "currenciesRoot", "curatorsArray", "courrenciesContainer", "contracturrenciesBlock", "cururrenciesContainer", "comportsBlock", "curportsPath", "currenciesnode", "contracturrenciesRoot", "comportsPath", "contracturrenciesNode", "currenciesArray", "cururrenciesBlock", "corenciesNode", "curitiesnode", "curatorsnode", "currenciesContainer", "curlationsElement", "curriesRoot", "curlationsBlock", "contractrenciesNode", "contracturrenciesDocument", "curitiesArray", "curportsElement", "currenciesElement", "curportsBlock", "corenciesnode", "curitiesContainer", "courrenciesNode", "cururrenciesArray", "curcurrencyBlock", "curatorsContainer", "curitiesNode", "curlationsPath", "curratesRoot", "curriesNode", "curratesDocument", "currenciesDocument", "contractrenciesBlock", "comrenciesElement", "curriesDocument", "corenciesArray", "cururrenciesDocument", "cururrenciesRoot", "comportsElement", "comportsNode", "curriesBlock", "comrenciesBlock", "contractrenciesRoot", "curlationsNode", "corenciesContainer", "courrenciesArray", "curcurrencyElement", "curratesNode", "curratesBlock", "cururrenciesNode"], "currencies": ["locales", "chcoins", "curacters", "charrencies", "scherency", "urversions", "urums", "curums", " currency", " curversions", "churrency", "peracters", " curacters", " curums", "cururrency", "curversions", "scherencies", "curales", "curcoins", "locurrency", "cururrencies", "charrency", "perversions", "carrencies", "uracters", "carcoins", "perrencies", " curries", "chales", "chrencies", "scheurrencies", "perums", "loccoins", "carurrency", "scheries", "urrencies", " cururrencies", "charurrencies", "carales", "charries", "locrencies", "curries", "currency"], "i": ["m", "u", "z", "uri", "e", "j", "b", "g", "n", "fi", "io", "info", "si", "in", "f", "it", "o", "index", "ci", "iu", "oi", "ji", "end", "abi", "multi", "y", "li", "di", "l", "ip", "pi", "xi", "hi", "eni", "slice", "r", "yi", "id", "ti", "v", "gi", "c", "start", "t", "ri", "I", "ai", "phi", "chi", "ii", "ui", "x", "mu", "qi", "bi", "lc", "q", "p"]}}
{"id1": "364438", "id2": "8417584", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private String getResultFromHttpUrl(String href) {\n        String result = null;\n        try {\n            URL url = new URL(href);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Object o = conn.getContent();\n            log.debug(\"Opened \" + href + \" and got class \" + o.getClass().getName());\n            StringBuffer version = new StringBuffer();\n            String inputLine;\n            DataInputStream dis = new DataInputStream(conn.getInputStream());\n            while ((inputLine = dis.readLine()) != null) {\n                version.append(inputLine + \"\\n\");\n            }\n            result = version.toString();\n            log.debug(\"Read from URL:\\n\" + result);\n            dis.close();\n        } catch (Exception e) {\n            log.debug(\"Caught exception \" + e + \" whilst attempting to query URL \" + href);\n            e.printStackTrace();\n        } finally {\n            return result;\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "5872038", "id2": "20886320", "code1": "    public void parse() throws ParserConfigurationException, SAXException, IOException {\n        DefaultHttpClient httpclient = initialise();\n        HttpResponse result = httpclient.execute(new HttpGet(urlString));\n        SAXParserFactory spf = SAXParserFactory.newInstance();\n        if (spf != null) {\n            SAXParser sp = spf.newSAXParser();\n            sp.parse(result.getEntity().getContent(), this);\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"parse": ["save", " load", "pack", "report", " scrape", " parsing", "se", "apply", "build", "write", " process", "scan", " serve", "arse", "parser", " service", " explode", " assemble", "set", "split", "read", "handle", "process", "xml", "create", "print", "delete", " parser", "transform", "send", "exec", "load", "patch", "Parser", " analyse", "format", "execute", "throw", "eval", "feed", "request", "post"], "SAXException": ["SAXYEX", "IAFXWarning", "IAXWarning", "SAXEX", "SAXXWarning", "SAXWarning", "SAFXWarning", "SAXYWarning", "SAFXException", "SAXXException", "SAXXEX", "IAXException", "IAXEX", "SAXYException", "SAFXEX", "IAFXEX", "IAFXException"], "IOException": [" IOExcept", "APIception", "APIException", "SecurityException", "SecurityExcept", "Securityception", "IOExcept", "IOception", " IOception", "APIExcept"], "httpclient": ["HttpClient", "httpsclient", "httpsapi", "Httpapi", "httpsconnection", "httpClient", " httpapi", "httpconnection", " httpserver", "httpsClient", "Httpclient", "httpsserver", " httpClient", "httpserver", "httpapi", " httpconnection", "Httpserver", "Httpconnection"], "result": ["page", "res", "url", "default", "resource", "report", "message", "server", "rc", "data", "this", "session", "output", "status", "document", "out", "results", "instance", "source", "api", "record", "client", "Result", "r", "found", "match", "err", "obj", "product", "success", "sr", "ret", "json", "response", "plus", "http", "request"], "spf": ["spfs", "prf", " spcf", "SPfp", "spfp", "Spfp", "SPsf", "scsf", "prcf", "espfc", " spF", "spfc", "SPcf", "SPf", "spF", "prF", "SPfx", "scf", "sccf", " spfx", "espf", "spsf", "SpF", "spcf", "scfp", "Spcf", "spfx", " spfs", "Spf", "espfs", "espfx", "SPfc", " spfp", "prfp", " spsf", " spfc", "SPfs"], "sp": ["span", "pe", "bsp", "sf", "se", "html", "ss", "par", "pl", "ps", "esp", "bp", "asp", "si", "spl", "parser", "pt", "f", "inst", "so", "str", "pr", "sw", "wp", "Sp", "sc", "SP", "br", "pc", "ap", "obj", "app", "service", "sr", "sl", "op", "gp", "sh", "pp", "serv", "p", "tp"]}}
{"id1": "8973505", "id2": "20855053", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "label": 1, "substitutes": {"writeFileType": ["writeFilesHeader", "createFileType", "writeFileHeader", "writeFILEHeader", "writeFILETypes", "writeFILEtype", "writeFiletype", "writeFilesTypes", "createFileHeader", "createFilestype", "writeFilestype", "writeFileTypes", "writePageTypes", "writePagetype", "writePageType", "createFiletype", "createFilesTypes", "createFilesHeader", "createFileTypes", "writeFilesType", "createFilesType", "writeFILEType", "writePageHeader"], "uriFile": ["URIfile", "urifile", "URIFilename", "riFiles", "uifile", "URIUrl", "uriFiles", "filenameFile", "uiFiles", "filenameFilename", "uiUrl", "URIFiles", "uriFilename", "riUrl", "filenamefile", "uiFile", "rifile", "URIFile", "riFile", "riFilename", "filenameFiles", "uriUrl"], "outputfile": ["resourcefiles", "unitfile", "outputfilename", "outputstring", "resourcefilename", "Outputfull", "inputfiles", "unitstring", " outputdir", "inputFile", "unitfilename", "outputfiles", "outputFile", "inputdir", "inputstring", " outputFile", " outputfull", "inputfull", "resourcestring", "inputfilename", "outputfull", "inputfile", "resourcefile", "unitfiles", "outputdir", "OutputFile", "Outputdir", "Outputfile"], "num": ["span", "nu", "unit", "col", "length", "count", "master", "offset", "n", "term", "amount", "inc", "limit", "no", "loop", "index", "NUM", "split", "sum", "batch", "Num", "multi", "len", "number", "coord", "mult", "con", "dim", "initial", "name", "umi", "zero", "nb", "nam", "common"], "writer": ["ee", "widget", "wr", "report", "wan", "null", "data", "writing", "socket", "written", "part", "entry", "Writer", "temp", "r", "wa", "wire", "root", "per", "wb", "wave", "page", "unit", "e", "we", "message", "wt", "server", "style", "editor", "index", "key", "type", "rw", "xml", "element", "builder", "width", "er", "worker", "walker", "object", "handler", "loader", "w", "writers", "layer", "format", "feed", "book", "master", "io", "outer", "later", "writ", "creator", "out", "wl", "function", "wrapper", "ler", "buffer", "manager", "write", "lock", "method", "session", "engine", "journal", "external", "output", "document", "ws", "source", "driver", "header", "riter", "inner", "window", "service", "office", "author"], "uri": ["component", "term", "verb", "sequence", "directory", "cli", "eni", "feature", "wiki", "token", "string", "file", "URI", "origin", "iri", "reference", "context", "ui", "query", "nor", "unit", "resource", "message", "connection", "remote", "link", "winner", "folder", "nil", "uni", "plugin", "i", "element", "metadata", "theme", "gi", "handler", "umi", "oid", "qi", "database", "prefix", "attribute", "course", "doi", "du", "route", "pi", "node", "id", "binary", "location", "picture", "hub", "collection", "http", "direction", "ori", "username", " URI", "range", "document", "href", "uid", "source", "multi", "filename", "di", "li", "mi", "base", "address", "ilo", "ri"], "counter": ["enter", "book", "page", "Counter", "server", "clock", "parent", "count", "master", "offset", "nr", "race", "info", "outer", "step", "parser", "ner", "hello", "sequence", "cookie", "loop", "entry", "creator", "meter", "result", "timer", "controller", "second", "index", "coll", "batch", "ver", "time", "instance", "i", "comment", "iter", "record", "trace", "keep", "ter", "expression", "worker", "number", "inner", "handler", "repeat", "cpu", "loader", "name", "continue", "computer", "reference", "inter", "vector", "condition", "runner", "current", "currency", "pointer", "lc", "collection", "keeper", "processor"], "reader": ["e", "rx", "rer", "riter", "io", "ner", "reading", "parser", "rar", "in", "Reader", "editor", "finder", "upper", "read", "row", "iter", "driver", "bird", "ruby", "l", "er", "rr", "lr", "inner", "stream", "ger", "worker", "r", "handler", "ir", "loader", "per", "layer", "keeper", "ler", "buffer", "oder", "feed", "ri"], "url": ["ls", "page", "text", "ssl", "resource", "image", "server", "connection", "io", "link", "blog", "channel", "www", "URL", "download", "plugin", "source", "config", "client", "li", "stream", "l", "web", "base", "user", "id", "address", "string", "file", "sl", "path", "Url", "http", "feed", "ri", "browser"], "myConnection": ["myconnection", "MyConnector", "someConnect", "MyConnection", "someReader", "myConnect", "yourConnector", " myConnector", "myConnector", "yourConn", "MyConnect", "MyConn", " myConnect", " myconnection", " myConn", "someConnection", "yourConnection", "someConn", "Myconnection", "yourconnection", "MyReader", "myConn"], "myReader": [" myRead", "myWriter", "MyWriter", "yourWriter", " myParser", "yourReader", "yourRead", "yourParser", "myParser", "myRead", "MyReader", "MyRead", "MyParser", " myWriter"], "line": ["page", "text", "pe", "LINE", "log", "lf", "message", "frame", "le", "style", "letter", "cell", "data", "link", "part", "no", "range", "entry", "du", "rule", "block", "lin", "cl", "lines", "end", "key", "inline", "row", "el", "code", "error", "element", "column", "pass", "source", "comment", "parse", "header", "l", "use", "base", "user", "point", "id", "look", "day", "string", "file", "Line", "liner", "name", "response", "word", "lc", "non", "note", "feed", "ri"], "linecount": ["Linenumber", "pagecount", "pageindex", "lineCount", " linesize", "Linecache", "linecache", " linecache", "lettercount", "lineindex", "rowcount", "pagenumber", "Linesize", "lettersize", "linenumber", "linesize", "LineCount", " lineindex", "linelen", " lineCount", " linelen", "rowcache", "rowlen", "pageCount", " linelength", "linelength", "letterlength", "Lineindex", " linenumber", "letterlen", "rowsize", "rowlength", "Linecount"], "hasOWL": [" hasOWDL", "hasODL", " hasEWl", "hasEWLA", " hasOWLA", " hasOWLM", "hasOULA", "HasOWLL", "hasEWDL", " hasEWLM", "HasEWLL", "HasEWLA", "hasOWl", "hasEWl", "hasOWSLL", "hasEFLM", "hasODLA", "hasBYL", "hasEFl", "hasOUL", "hasOULL", " hasEWL", "hasBYl", " hasOWl", "hasOWLM", " hasEWLA", " hasEWDL", "HasOWLA", "HasEWLM", " hasEWLL", "hasODLL", "hasOWSL", "hasBYDL", " hasOWLL", "hasOWSDL", "hasEWLM", "HasEWL", "hasOWSl", "hasODLM", "hasEWL", "hasEWLL", "HasOWL", "hasEFL", "hasOWLA", "hasOWLL", "hasOWDL", "hasODl", "HasOWLM", "hasBYLL", "hasEFLA", "hasOULM"], "hasRDFS": ["hasGRUFs", "hasGRDFS", "hasGRDFs", "hasXDFE", "hasRNFS", "hasXDFS", "hasCDPS", "hasRdfU", "hasCDFES", "hasRDFs", "hasRUFSU", "hasRDPAST", "hasXDPU", "hasRdfS", "hasRDPU", "hasXDPS", "hasRDFU", "hasRNFs", "hasRdfE", "hasCDPE", "hasRDPES", "hasRNFU", "hasRUFs", "hasRDFES", "hasXDPE", "hasRFs", "hasRUFS", "hasXDFs", "hasCDPs", "hasRNFE", "hasRTFE", "hasGRDFAST", "hasRUFAST", "hasRTFS", "hasRdfs", "hasRDPSU", "hasRFSU", "hasRDPS", "hasGRUFAST", "hasRFAST", "hasRDFSU", "hasRDFE", "hasCDFS", "hasCDFs", "hasGRUFS", "hasXDPs", "hasRDPE", "hasCDFE", "hasGRDFSU", "hasRTFs", "hasGRUFSU", "hasXDFU", "hasRTFES", "hasRFE", "hasRFES", "hasCDPES", "hasRDFAST", "hasRFS", "hasRDPs"], "hasRDF": ["hasUDF", "HasRRdf", "hasRUF", "hasDDF", " hasRRMF", "yesDOW", "yesRMF", "HasRdf", "hasRRDEF", "hasMRDEF", "hasUMF", " hasRMF", "yesRDP", "HasRRDF", "hasURMF", "hasSRdf", "hasRRdf", "hasROW", "hasRMF", "hasNRMF", "hasNRFD", "hasNRUF", "hasRRMF", "hasMRDP", "hasUOW", "hasRFD", "hasDMF", "yesDDF", "hasUDP", " hasRRFD", "hasRDEF", "yesDDP", "hasSRDF", " hasRFD", "yesDMF", "yesROW", "yesRDF", " hasRRUF", "HasRDP", "hasMRdf", "hasNRDF", "hasRRUF", "hasSRDEF", "hasRRDP", "HasRRDP", "hasURDF", "hasDDP", " hasRRDF", "HasRDEF", "HasRDF", "hasMRDF", "hasRRFD", "hasRRDF", "hasSRDP", " hasRUF", "hasDOW", "hasURFD", "hasURUF", "HasRRDEF", "hasRdf", "hasRDP"]}}
{"id1": "8216539", "id2": "3184073", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentAsStr", "getFileContentasStr", "getFileContentasText", "getFilecontentAsStream", "getFilecontentAsText", "getFileContentFromStream", "getFilecontentInStream", "getFileContentInText", "getFilecontentAsStr", "getFilecontentInString", "getFileContentFromText", "getFileContentFromStr", "getFileContentInStream", "getFileContentInString", "getFileContentAsStream", "getFilecontentInText", "getFileContentInStr", "getFileContentFromString", "getFilecontentInStr", "getFileContentAsText", "getFileContentasStream", "getFileContentasString", "getFilecontentAsString"], "filePath": ["singleLocation", "FileUrl", "baseLocation", " fileStr", "basepath", "FileStr", "singleUrl", "Filepath", "fileStr", "baseName", "resourceName", "singlePath", "resourcepath", "fileUrl", "fileName", "filepath", " fileUrl", "singlepath", "FilePath", "baseStr", "basePath", "FileName", "fileLocation", " filepath", "resourceLocation", "FileLocation", "resourcePath", "baseUrl"], "encoding": ["casing", "equlocking", "Enclocking", "cryption", "Encryption", "decoding", "coded", "Encging", "languageoding", "Encasing", "languageging", "languagepling", "equging", "Encpling", "languagelocking", "encpling", "encryption", "equoding", "decoded", "encging", "enclocking", "Encoded", "encoded", "decryption", "encasing", "equpling", "coding", "Encoding", "decasing"], "testURL": ["appUrl", " testUrl", "shorturl", "testingurl", "shortURL", "shortUrl", "testingRL", " testRL", "testUrl", "fileURL", "testRL", "testingUrl", "testingUR", "shortTL", "fileUrl", "appUR", "fileURI", "testUR", "testingURI", "testurl", " testTL", "testingURL", "testingTL", "fileRL", "testTL", " testURI", "TestUrl", "TestURL", "appURL", "testURI", "TestUR", "Testurl", "appurl", " testurl"], "input": ["ink", "text", "url", "ssl", "flow", "resource", "image", "parent", "null", "connection", "form", "act", "rc", "init", "acl", "data", "this", "socket", "raw", "inc", "output", "in", "entry", "audio", "result", "error", "out", "type", "inf", "conn", "through", "temp", "xml", "i", "source", "instance", "api", "reader", "config", "client", "qa", "pull", "stream", "inside", "ack", "inner", "Input", "element", "ac", "exec", "bin", "file", "upload", "dc", "binary", "ou", "op", "get", "path", "wrapper", "current", "active", "but", "enc", "http", "feed", "img"], "sw": ["writer", "wr", "iw", "we", "rx", "sf", "wt", "aw", "en", "rc", "sv", "io", "sb", "wrap", "fp", "now", " SW", "sn", "ow", "ew", "ws", "rw", "wx", "nw", "rew", "SW", "stream", "work", "wp", "web", "WS", "Sw", "ib", "sc", "cr", "sa", "sm", "ww", "sl", "w", "sk", "wb", "sh", "wrapper", "tw", "hw"]}}
{"id1": "13563706", "id2": "14317425", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "handleGET", "handleget", "doget", "didget", "doPut", "handlePut", " doget", " doGET", " doPut", "didGet", "didPut", "doGET", "didGET"], "request": ["attribute", "req", "p", "url", "frame", "resource", "report", "server", "message", "image", "complete", "view", "Response", "connection", "remote", "event", "method", "data", "info", "application", "model", "document", "result", "input", "Request", "type", "xml", "instance", "create", "QUEST", "config", "client", "user", "queue", "object", "string", "query", "current", "buffer"], "response": ["resp", " Response", "description", "res", "writer", "subject", "respond", "report", "resource", "server", "message", "image", "view", "Response", "connection", "body", "reason", "output", "model", "application", "status", "result", "site", "document", "reply", "index", "error", "results", "api", "client", "header", "object", "wa", "re", "service", "location", "pool", "json", "query", "collection", "http", "feed", "onse"], "selectedPage": [" selectedHour", "namedpage", "selectedLine", "selectionFile", " selectedAction", "namedPage", "namedFile", "selectedButton", "lectedpage", "lectedFile", " selectedItem", "lectedLine", "selectionpage", "namedLine", "selectedpage", " selectedLine", "lectedSite", "lectedAction", "electedPage", " selectedFile", "electedLine", "selectedFile", "selectionItem", " selectedButton", "lectedPage", "electedpage", "lectedItem", "selectionAction", "namedSite", " selectedSite", "selectionButton", "electedButton", "lectedButton", "lectedHour", "selectedAction", " selectedpage", "selectedSite", "selectionPage", "selectedItem", "selectionLine", "selectionHour", "selectedHour"], "page": ["menu", "image", "parent", "html", "view", "pg", "profile", "row", "queue", "cache", "po", "per", "pp", "photo", "Page", "unit", "resource", "message", "server", "connection", "port", "display", "model", "result", "type", "plugin", "record", "article", "point", "change", "layout", "handler", "age", "proxy", "url", "channel", "site", "route", "rule", "me", "instance", "section", "user", "node", "account", "location", "block", "peer", "module", "pl", "item", "ge", "project", "je", "child", "phone", "document", "f", "client", "ice", "ip", "number", "position", "address", "language", " Page", "sp", "pool", "office", "fe", "p"], "portalRequest": ["portortalRequest", "PortortalUser", "portpalResponse", "portelQuery", "portelCommand", "portalAccess", "PortortalEvent", "portALEvent", "portugalEvent", "portallResponse", "portalResponse", "portugalUser", "portALUser", "portortalServer", " portialRequest", "portialQuery", "portbalQuery", "portallingPage", "portalPage", "PortortalAccess", "PortortalCommand", "portortalUser", " portialResponse", "portugalServer", "portialRequest", "PortalEvent", " portialQuery", "portALRequest", "portelRequest", "PortortalResponse", "portalEvent", "portpalRequest", "portALResponse", " portalQuery", "portbalResponse", "PortalOrder", "PortalCommand", "portailRequest", "portbalRequest", "PortalAccess", "portelResponse", "portugalResponse", "portallingResponse", "PortortalServer", "portallUser", "portailOrder", "portugalOrder", " portalResponse", " portalPage", "portialPage", "portallingRequest", "portalUser", " portialPage", "portpalPage", "portalServer", "portallingAccess", "portailUser", "PortortalRequest", "portallServer", "portortalOrder", "portelPage", "portortalPage", "PortalRequest", "portortalResponse", "portallRequest", "portalQuery", "PortalResponse", "PortortalOrder", "portortalEvent", "portbalPage", "portialResponse", "PortalUser", "portallingCommand", "PortalServer", "PortortalPage", "portugalRequest", "portalOrder", "portailResponse", "portortalCommand", "portortalAccess", "portpalAccess", "portalCommand", "PortalPage"], "pageProp": ["projectProp", "pluginPro", "projectProperty", "PageProp", "parentProperty", "pageObj", "pagePro", "agePro", "projectprop", "parentProp", "peerStr", "pluginProperty", "pluginprop", "PagePro", "parentObj", "pageprop", "resourceProperty", "resourceProp", " pageProperty", " pageObj", "PageProperty", "ageProperty", "pageProperty", "Pageprop", "ageprop", "PageStr", "peerProp", "resourcePro", "pluginProp", "pageStr", "ageProp", "projectPro", "peerProperty", "PageObj", " pagePro", "parentPro", " pageStr", "peerPro", "resourceprop"], "possiblePage": ["possibilityPage", "possibleItem", "puredPage", "permanentpage", "PossiblyPage", "possiblyGroup", "pablePages", "PossiblyItem", "PossibilityLine", "patchingGroup", "patchingpage", "possiblyLine", "Possiblepage", "patchedPage", "permanentLine", "PossibleGroup", "patchedOrder", "possiblePages", "possibleGroup", "patchingPage", "puredGroup", "possibleLine", "PossibleOrder", "possiblyPage", "PossiblyLine", "possiblyItem", "pablepage", "PossiblePages", "puredpage", "patchingItem", "possiblyPages", "possiblepage", "PossibilityPage", "PossibleLine", "possiblyOrder", "patchedpage", "permanentPage", "PossibilityPages", "possibilityPages", "PossiblePage", "Possiblypage", "puredItem", "possibilityLine", "pableLine", "possibilitypage", "PossibleItem", "PossiblyOrder", "pablePage", "patchedLine", "Possibilitypage", "PossiblyGroup", "permanentOrder", "possiblypage", "possibleOrder"], "property": ["prop", "prefix", "attribute", "p", "Property", "resource", "integer", "maximum", "uration", "term", "notation", "profile", "data", "project", "operator", "duration", "f", "result", "set", "key", "type", "binding", "class", "future", "config", "properties", "section", "header", "expression", "perties", "number", "feature", "table", "variable", "object", "address", "language", "string", "character", " Property", "name", "entity", "t", "binary", "layer", "function", "value", "label"], "referer": ["diffrer", "fere", "Referen", "referers", "refiner", " refre", "referen", "rerer", "reere", "redrer", "Referer", "redber", "Refeline", "Refender", "Refere", "affere", "Refre", "Refiner", "defrer", "afferen", "defere", "reiner", "deferer", "ferers", "rere", "refre", "reerer", "rederer", "differer", " referers", " refrer", " refender", "redeline", " refeline", "frer", "refber", "refeline", "affrer", "refender", "refere", "Referers", "defender", "afferer", "diffiner", "Refber", " referen", "diffender", " refere", "defber", "Refrer", " refiner", "refrer", "ferer", " refber"], "e": ["ee", "esi", "message", "one", "se", "null", "event", "this", "ie", "ele", "f", "es", "o", "d", "ae", "error", "me", "type", "see", "element", "i", "a", "er", "E", "de", "eme", "err", "ea", "or", "ed", "fe", "exc", "p", "ception"]}}
{"id1": "23532405", "id2": "1357662", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"persist": ["Persists", " Persists", "persists", "plister", "Persistence", "persister", "Persister", " Persister", "plists", "plist", "persistence", " Persist", " Persistence", "plistence", "Persist"], "ffConfigurable": ["ffConfure", "ffGur", "FFConfurable", "ffconfigural", "ffConfuring", "ffConfigural", "ffLogural", "ffFure", "FFConfuring", "FFConfurred", "ffSegurred", "ffConfured", "FFConfural", "uffConfiguring", "ffFuring", "ffFurable", "ffConfurer", "ffLogurer", "uffConfigure", "FFConfurer", "ffConfigur", "ffLogured", "effConfural", "FFConfiguring", "FFConfur", "FFConfigurer", "ffLoguring", "ffSegural", "ffConfiguring", "FFConfigurable", "ffPlurer", "ffConfigurred", "ffGurable", "ffLogure", "uffLogured", "effConfurable", "effConfigural", "uffConfigurable", "ffSegurable", "ffConfigure", "ffConfigured", "ffConfural", "FFConfigural", "ffconfigurer", "effConfured", "effConfurer", "uffConfigured", "uffLogurable", "ffSegurer", "uffLogure", "ffconfigurable", "ffLogurable", "ffConfur", "ffSegured", "ffPluring", "ffFured", "effConfigurer", "effConfigured", "ffGuring", "ffConfurred", "FFConfigurred", "ffGurer", "effConfigurable", "uffLoguring", "ffConfurable", "FFConfigur", "ffPlur", "ffPlurable", "ffConfigurer", "ffconfigurred"], "relativePath": ["relativePoint", " relativePoint", "ativeUrl", " relativeFile", "absoluteName", " relativeLocation", "absoluteUrl", " relativeUrl", "ativePath", "protectedPoint", "absoluteLocation", "relativeUrl", "absolutePoint", " relativeName", "absolutePath", "relativeLocation", "protectedpath", "relativeName", "ativeName", "protectedPath", " relativepath", "relativepath", "relativeFile", "ativeLocation", "absoluteFile", "absolutepath", "protectedFile"], "file": ["pe", "log", "url", "unit", "e", "image", "ile", "sf", "FILE", "module", "b", "parent", "le", "form", "il", "io", "data", "single", "store", "part", "in", "folder", "model", "f", "it", "zip", "out", "type", "el", "temp", "class", "source", "config", "dir", "directory", "filename", "l", "use", "self", "db", "files", "base", "work", "stream", "place", "object", "local", "cache", " File", "show", "handler", "name", "full", "File", "php", "cf", "path", "get", "location", "fe", "http", "fp"], "is": ["gets", "does", "isi", "ps", "io", "info", "mis", "ics", "si", "nis", "iso", "oss", "in", "es", "bis", "IS", "us", "ms", "fs", "out", "iris", "ws", "ios", "i", "api", "ip", "iss", "ais", "ir", "ris", "Is", "ai", "as", "ii", "ui", "isa", "was"], "os": ["oa", "ori", "io", "obs", "ies", "rs", "osi", "iso", "oss", "aos", "cos", "ows", "o", "bos", "us", "uns", "oses", "ips", "fs", "s", "ens", "ms", "oS", "ios", "Os", "oes", "oos", "outs", "ils", "los", "ais", "ops", "ou", " bos", "ol", "as", "oid", "OS"]}}
{"id1": "6756635", "id2": "18693224", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"MD5": ["MP512", "MD512", " MD512", "SHA5", "SHA4", "MD8", "MP5", "MP4", "SHA8", "MP8", "MD4", " MD8", "SHA512", " MD4"], "text": ["font", "prefix", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "this", "in", "output", "input", "str", "editor", "hex", "password", "template", "bytes", "key", "test", "code", "class", "source", "config", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "path", "word", "content", "ext", "format", "buffer", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedEncodedATION", "UnsupportedEncagingception", "Unsupportedencodingception", "UnsupportedEncodingATION", "UnsupportedencodingATION", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingATION", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedEncasingException", "UnsupportedencodedATION", "UnsupportedEncagingException", "Unsupportedencodedception", "UnsupportedEncagingATION"], "md": ["m", "rm", "hd", " MD", "Cmd", "message", "mp", "body", "cmd", "sha", "pg", "method", "data", "mo", "dig", "dd", "rpm", "mode", "hash", "mc", "valid", "d", "mag", "vd", "od", "ms", "meta", "me", "mb", "code", "amd", "mg", "dm", "bd", "wd", "metadata", "cm", "bf", "pd", "MD", "docker", "di", "ad", "mac", "nm", "mand", "match", "mm", "ma", "ld", "pm", "mt", "cd", "mod", "manager", "df"], "md5hash": ["md25Hash", " md5sum", "md8hash", "md5version", " md5hex", "md4Hash", "mand53Hash", " md6hash", "md6Hash", "md4sum", "md6kh", "md53version", "mddownsum", "md5Hash", "mddownHash", "md2sum", "mddownkh", "md2html", "mand5version", "md5hex", "mand5hash", "md6hash", "md6hex", "md8hex", "md25version", "md8Hash", "mddownhash", "md2version", "md25html", "md4hash", "md8sum", "md53hash", " md6hex", " md6Hash", " md6sum", "md2hash", " md5kh", "md25hash", "mand5Hash", "md53Hash", "mand5html", "md5sum", "mand53version", "md2kh", "md4hex", " md5Hash", "mand53hash", "md6sum", " md6kh", "mand53html", "md5kh", "md53html", "md2Hash", "md5html"]}}
{"id1": "17999474", "id2": "22977189", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipasFile", "getZipAtPlace", "getZipAsDir", "getTempAsDir", "getTempAsFile", "getZipAsPlace", "getZipAtFile", "getTempAsPlace", "getZipasDir", "getTempAsfile", "getZipAtDir", "getZipAtfile", "getZipasPlace", "getZipAsfile", "getZipasfile"], "digOb": [" digob", "signObj", "ditObject", " digObject", "dimOb", "dimOl", "DigOl", "signObject", " digOl", "ditOB", "digob", "dimObject", "signOb", "DigOb", "Digob", " digObj", "digOB", "signob", "ditOb", "dimObj", "signOB", "digObject", "digOl", "DigObject", "digObj", "DigObj", "ditob", " digOB"], "folderName": ["foldName", "foldPath", "filePath", "foldername", " foldername", "packagePath", " folderDir", "FolderInfo", "foldname", "FolderDir", "fileName", "packagename", "Foldername", "fileInfo", "filename", "FolderPath", "folderDir", "packageDir", "folderInfo", "folderPath", " folderPath", "foldInfo", "packageName", "FolderName"], "tmpFolder": ["mpfolder", "tmpManager", " temporaryDirectory", " temporaryFolder", "tempFolder", " temporaryManager", "mpDir", "tempfolder", "tmpDirectory", " tmpDir", "mpFolder", "tmpfolder", "tempDir", " temporaryfolder", "tempDirectory", " tmpDirectory", " tmpfolder", " tmpManager", "tmpDir", "mpDirectory", "tempManager"], "zip": ["proxy", "url", "z", "flow", "pack", "install", "copy", "lock", "lex", "ce", "io", "flat", "ress", "ie", "zone", "folder", "wrap", "f", "py", "fp", "archive", "bag", " zipper", "job", "clip", "download", "ignore", "temp", "pkg", "jar", "source", "ulp", "ze", "xml", "tmp", "seed", "ip", "Zip", "slice", " ZIP", "pipe", "file", "gz", "upload", "ipped", "sl", "lib", "cf", "json", "feed", "p", "cop"], "out": ["page", "gen", "log", "writer", "ex", "url", "z", "flow", "write", "plain", "copy", "null", "parent", "connection", "os", "io", "info", "this", "child", "sync", "socket", "output", "in", "f", "result", "o", "Out", "conn", "download", "temp", "is", "source", "flush", "client", "cli", "a", "base", "outs", "user", "object", "cache", "file", "obj", "err", "gz", "upload", "loader", "OUT", "path", "again", "line", "box"]}}
{"id1": "23246123", "id2": "19810820", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createButtonGroup", "createMessageArea", " createButtonGroup", " createDialogPanel", " createHelpArea", "createButtonArea", " createDialogarea", "createEditorarea", "createControlarea", "createControlArea", "createButtonarea", "createHelpGroup", "createMessagePanel", "createHelpArea", " createButtonarea", "createEditorGroup", " createDialogGroup", "createEditorArea", "createDialogPanel", "createHelpPanel", "createDialogGroup", "createHelparea", " createButtonArea", " createHelparea", "createControlPanel", "createMessagearea", " createHelpPanel", "createDialogarea"], "parent": ["page", "component", "menu", "message", "image", "resource", "null", "g", "connection", "panel", "Parent", "this", "child", "parser", "port", " scene", "document", "parents", "cl", "clip", "container", "instance", "builder", "class", "client", "section", " sup", "self", "object", "c", "sup", "root", "ctx", "host", "context", "wrapper", "current", "comp", " child", "p"], "composite": ["Complexiting", "comvalitive", "compositionites", "complexiting", "comppositionited", "comPOSitable", "Complexite", "compositionitive", "comppositor", "compositor", "comPOSite", "comppositionitor", "Composites", "comppositionite", "compposite", "complexitable", "composites", "comPOSited", "complexites", "compposites", "composited", "Compositable", "compositionitable", "comosited", "complexitor", "compositing", "compositionite", "comppositable", "Compositing", "comositable", "comvalitor", "comvalites", "comPOSites", "comosites", "compositionited", "compposited", "compositable", "Composite", "compositionitor", "comPOSiting", "compositive", "comppositive", "comppositionites", "complexitive", "Complexites", "comosite", "comvalite", "complexite", "comppositionitable", "comppositionitive", "compositioniting", "Complexitable"], "content": ["activity", "page", "component", "ez", "message", "report", "image", "server", "html", "resource", "copy", "complete", "connection", "cell", "version", "child", "title", "output", "folder", "application", "document", "model", "container", "Content", "conn", "code", "plugin", "xml", "comment", "cm", "create", "config", "section", "header", "client", "media", "cms", "source", "control", "object", "scroll", "address", "load", "exec", "file", "app", "loader", "host", "context", "layer", "json", "cont", "format", "feed"], "ncol": ["nblock", "numcolumn", " ncolumn", "pCol", "Ncol", "numCol", "nbcolumn", "pcol", " nblock", "Nblock", "numrow", " nCol", "nCol", "nbcol", "numcol", "nbCol", "pblock", "ncolumn", "nbrow", "Ncolumn", "nrow", "NCol", "pcolumn", " nrow"], "layout": ["font", "widget", "padding", "closure", "nav", "flow", "board", "image", "build", "offset", "view", "lock", "flat", "data", " layouts", "scale", "mount", "follow", "group", "shape", "model", "figure", "draw", "entry", "zip", "shadow", "translation", "split", "nl", " Layout", "container", "inline", "xml", "config", "section", "l", "edit", "Layout", "base", "design", "control", "position", "scroll", "address", "holder", "alpha", "list", "grid", "lay", "layer", "location", "ui", "lc", "where", "feed", "block", "join"], "numColumns": ["numcolumnes", "nbcolumnes", "numColumnows", "nbColumnes", "numControln", "numcolumnn", "nbColumns", "nbcolumnn", "numControls", "numColn", "nbColumnows", "nbcolumnows", "numColumnn", "numColows", "nbcolumns", "numColes", "numControles", "numControlows", "numcolumnows", "numCols", "numcolumns", "nbColumnn", "numColumnes"], "browser": ["css", "river", "page", "roller", "Browser", "book", "js", "vert", "report", "image", "server", "mobile", "ssl", "uri", "html", "nav", "remote", "google", "fox", "io", "session", "cart", "iframe", "cookie", "fire", "editor", "proxy", "finder", "shadow", "coll", "facebook", "graph", "test", "ver", "plugin", "jar", "comment", "theme", "driver", "chrome", "config", "agent", "client", "flash", "web", "ger", "design", "sim", "feature", "bar", "br", "http", "window", "platform", "loader", "binary", "root", "host", "webkit", "bot", "runner", "front", "box", "manager", "feed", "lib", "open", "img"], "text": ["font", "writer", "txt", "vert", "message", "image", "report", " Text", "struct", "unit", "connection", "letter", "term", "atter", "form", "off", "info", "data", "port", "title", "output", "entry", "it", "editor", "str", "input", "test", "plugin", "element", "comment", "source", "driver", "config", "client", "pdf", "inner", "user", "TEXT", "object", "string", "desc", "name", "select", "service", "binary", "context", "path", "ext", "format", "abs", "label", "feed", "ut", "Text"], "url": ["ur", "page", "ssl", "uri", "resource", "server", "image", "connection", "rel", "io", "f", "zip", "www", "URL", "ref", "bel", "download", "source", "pull", "api", "config", "l", "web", "lr", "base", "user", "id", "address", "string", "gl", "file", "re", "service", "sl", "host", "path", "Url", "http", "feed", "open"], "in": ["rec", "p", "ins", "fr", "resource", "image", "In", "b", "dr", "rc", "init", "data", "on", "inc", "f", "gin", "it", "input", "str", "o", "din", "IN", "d", "inn", "lin", "rb", "out", "s", "conn", "el", "pass", "xml", "i", "rin", "is", "reader", "ar", "nin", "l", "er", "login", "stream", "inner", "a", "min", "br", "bin", "err", "c", "ic", "re", "w", "pin", "ini", "x", "or", "arin", "again", "serv", "ri"], "r": ["kr", "ur", "rt", "m", "p", "res", "rss", "fr", "R", "rx", "ro", "rob", "b", "ru", "dr", "nr", "rc", "mr", "rs", "rel", "rh", "ner", "rar", "f", "vr", "o", "d", "rb", "h", "out", "rg", "rf", "rw", "i", "pr", "reader", "rl", "ar", "l", "er", "rr", "lr", "br", "ir", "err", "c", "re", "sr", "gr", "hr", "or", "cr", "ri", "right"], "sb": ["buf", "kb", "sth", "ls", "bsp", "lp", "ssl", "rob", "sf", "b", "sv", "fb", "bp", "bh", "si", "usb", "xb", "lb", "bc", "sn", "pb", "SB", "storage", "rb", "nl", "lab", "cb", "mb", "s", "bf", "bm", "src", "library", "erb", "ruby", "sg", "db", "lr", "ib", "bj", " SB", "abb", "sa", "sm", "gb", "ob", "sr", "binary", "obb", "sp", "wb", "buffer", "abs", "ab", "eb", "bs", "bb"], "line": ["page", "LINE", "pe", "lf", "col", "message", "le", "se", "b", "n", "letter", "cell", "data", "ge", "part", "entry", "f", "str", "split", "lin", "cl", "lines", "nl", "key", "end", "row", "el", "code", "inline", "pass", "i", "comment", "source", "cle", "record", "header", "li", "ne", "l", "base", "object", "id", "string", "character", "stroke", "obj", "Line", "name", "sl", "lc", "block", "char"], "e": ["ve", "ale", "pe", "ee", "ev", "esi", "one", "se", "le", "en", "ce", "ue", "ge", "je", "ie", "ec", "ele", "f", "oe", "es", "ise", "o", "d", "ae", "error", "me", "i", "te", "ze", "ime", "ne", "er", "E", "de", "err", "ke", "be", "ite", "ea", "or", "ef", "fe", "exc", "p", "ception"]}}
{"id1": "11484416", "id2": "947406", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": [" moveFiles", "moveDirectory", "MoveDirectory", "MoveFiles", " movedFiles", "MovePath", " movedFile", "moveFiles", " movePath", " moveDirectory", "MoveFile", " movedPath", "movePath", " movedDirectory"], "orig": ["buf", "proxy", "original", "array", "raid", "frame", "image", "copy", "dest", "build", "prev", "loc", "init", "remote", "ori", "info", "org", "old", "folder", "f", "impl", "archive", "coll", "rb", "comb", "home", "temp", "source", "iter", "src", "tmp", "raf", "base", "coord", "ctr", "internal", "transform", "id", "bin", "file", "obj", "bas", "origin", "exe", "Orig", "ext", "real", "imag", "img"], "target": ["replace", "prot", "to", "original", "resource", "copy", "dest", "build", "master", "parent", "remote", "manager", "project", "this", "external", "f", "it", "result", "archive", "nt", "template", "eth", "temp", "source", "tmp", "Target", "base", "object", "match", "arget", "platform", "origin", "t", "reference", " Target", "next", "ret", "path", "auto", "current", "format", "force", "compatible", "join"], "buffer": ["wave", "buf", "bb", "request", "padding", "url", "frame", "message", "resource", "write", "length", "copy", "b", "null", "data", "Buffer", "raw", "sequence", "result", "input", "stack", "batch", "read", "bytes", "code", "source", "iter", "header", "buff", "base", "queue", "position", "slice", "cache", "address", "bin", "file", "repeat", "reference", "binary", "layer", "transfer", "uffer", "content", "feed", "block"], "bread": ["circ", "rows", "bat", "meal", "good", "length", "wake", "ffe", "raft", "num", "fall", "fed", "die", "piece", "rub", "cake", "hello", "bc", "food", "loop", "zip", "robe", "str", "inn", "batch", "key", "broken", "fe", "abi", "width", "rib", "web", "beat", "design", "fred", "bn", "brew", "div", "fee", "cook", "fif", "knife", "buck", "fle", "fine", "fen", "wen", "ble", "zero", "sleep", "eb", "grain", "feed", "bb", "bare", "four", "choice", "bee"], "fis": [" fils", "ufils", "lfis", "ufis", "ufiss", " fiss", "lfIs", "hos", "fisa", "qiss", "fxos", "fxisa", "qis", "ufos", " fisa", "fxIs", "fils", "fxis", "his", "qils", "fIs", "fiss", "lfiss", "qos", "afiss", "afIs", "hIs", "afis", "lfos", "afos", " fIs", "hisa"], "fos": ["fois", "Fors", "infors", "infois", " fros", "fose", "fens", " fens", "gros", "flos", "Fos", "flois", "fors", "foses", "faos", "infos", "infaos", "Foss", "gis", "flaos", "Fois", " foses", " fose", "Fens", "flose", "flens", " foss", "Faos", "Foses", "floses", "Fros", "gos", "Fose", "foss", "goss", "flors", "fros", "Fis"]}}
{"id1": "8801436", "id2": "11933797", "code1": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copy": ["save", "ize", "rm", "write", " transfer", " cp", "image", "cp", "attach", "ge", "link", "sync", " copying", "zip", "cross", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "ignore", "Copy", "create", "source", "open", "delete", " Copy", "change", "load", "share", "upload", "transfer", "Cop", "update", "opy", "cop"], "from_file": ["from67files", " from_folder", "from_files", " from_auto", " from_connection", "from_auto", " from_money", " from_File", "from2file", "from_parent", "from_File", " from_class", "from67file", " from_single", "from_folder", " from_files", "from67auto", "fromffiles", " from_function", "from_money", "fromfsingle", "fromingfile", " from_directory", "from_class", "source_cache", "to_files", "from_source", "from_connection", "to_File", "from_user", "from2File", "fromingclass", "from_function", "from2source", "to_source", "from_cache", "to_user", "from_single", "from67directory", "from2files", "fromffolder", "fromffile", "source_file", "from_directory", "fromingmoney", "source_parent"], "to_file": ["to_resource", "tothefile", "from_files", "to_image", "to_global", "tothesource", "To_mail", "to_name", " to_resource", "from_folder", "from_model", "To_resource", "to_folder", " to_directory", "to_get", " to_get", "from_name", "To_directory", "To_file", "to_directory", "to_files", "toPname", "to_mail", "to_model", " to_string", "to_string", "to_source", "toPfile", "from_image", "to_path", "tothefolder", "to_letter", " to_folder", " to_source", "totheglobal", " to_path", "toPfiles", " to_letter", "to_filename", "from_filename", " to_global"], "parent": ["ppa", "null", "term", "data", "part", "search", "pa", "directory", "div", "po", "ac", "cache", "patch", "file", "root", "page", "uri", "unit", "resource", "connection", "par", "Parent", "remote", "parser", "port", "inc", "old", "folder", "and", "test", "type", "key", "tree", "point", "handler", "layer", "path", "content", "ca", "partial", "url", "loc", "anc", "pt", "rule", "parents", "pr", "api", "memory", "section", "size", "any", "id", "function", "location", "pointer", "manager", "child", "session", "it", "pid", "container", "home", "source", "client", "ip", "address", "name", "host", "pool", "current", "fat", "p"], "dir": ["fd", "url", "nav", "build", "dr", "loc", "rel", "manager", "die", "data", "dec", "part", "folder", "group", "entry", "f", " directory", "block", "d", "coll", "dev", "container", "out", "wd", "home", "cur", "dict", "ver", "pkg", "iter", "config", "directory", "di", "keep", "db", "tree", "base", "user", "object", "id", "cache", "po", "div", "ir", "file", "name", "dc", "def", "root", "per", "dis", "path", "or", "Dir", "mod", "director", "doc"], "from": ["pe", "component", "un", "From", "url", "without", "one", "e", "se", "connection", "form", "ce", "io", "empty", "data", "this", "link", "on", "part", "in", "range", "flo", "so", "o", "ch", "hand", "bean", "out", "conn", "code", "source", "add", "parse", "with", "api", "client", "stream", "self", "base", "can", "address", "po", "who", "low", "file", "con", "start", "name", "find", "vol", "by", "up", "left", "per", "get", "auto", "normal", "or", "path", "clean", "query", "http", "cr"], "to": ["page", "too", "url", "one", "server", "b", "connection", "two", "io", "store", "tto", "session", "sync", "this", "socket", "not", "output", "via", "tom", "so", "tool", "flo", "o", "about", "key", "out", "type", "see", "temp", "ver", "source", "made", "TO", "top", "api", "size", "co", "with", "target", "pi", "db", "will", "cache", "po", "token", "file", "name", "be", "by", "t", "per", "thro", "op", "until", "auto", "or", "value", "office", "To", "fat", "http", "on"], "buffer": ["border", "buf", "available", "page", "padding", "default", "message", "resource", "server", "length", "null", "offset", "data", "duration", "Buffer", "channel", "shape", "document", "result", "batch", "read", "row", "texture", "total", "flush", "iter", "memory", "reader", "comment", "header", "buff", "seed", "capacity", "number", "base", "queue", "position", "slice", "variable", "address", "character", "device", "binary", "reference", "layer", "pool", "uffer", "value", "transfer", "block"], "bytes_read": ["bytes_load", "bytes0pass", "es_read", "bytes___found", "keys_found", "bytes___written", "bytes0read", "bytes___read", "bytes0received", "keys___found", "bytes_received", "keys___written", "bytes_write", "keys___read", " bytes_pass", "es_load", " bytes_received", "bytes0write", "es_used", "bytes_allow", "keys_read", "bytes_pass", "keys_written", "bytes_used", "bytes_written", "bytes_found", " bytes_write", "es_allow"]}}
{"id1": "21063400", "id2": "14794404", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "label": 0, "substitutes": {"doImageProcess": [" doImageFile", "doimageProcess", "doFileFile", "doThumbnailProcess", " doimageProcess", "doimageprocess", "doimageFile", "doThumbnailFile", " doimageprocess", "doImageprocess", " doimageFile", "doThumbnailprocess", " doImageprocess", "doFileProcess", "doFileprocess", "doImageFile"], "request": ["req", "writer", "url", "resource", "image", "server", "message", "report", "method", "data", "application", "model", "result", "input", "Request", "type", "xml", "instance", "reader", "config", "client", "header", "stream", "object", "name", "path", "query"], "response": ["wave", "resp", " Response", "page", "description", "writer", "respond", "default", "report", "message", "server", "image", "resource", "example", "complete", "view", "Response", "connection", "body", "version", "more", "session", "output", "application", "document", "status", "result", "site", "model", "reply", "index", "error", "out", "results", "api", "client", "queue", "object", "video", "cache", "success", "service", "host", "next", "full", "json", "location", "pool", "collection", "http", "feed", "ception", "onse"], "imgSize": ["ifSize", "imgC", "largeSize", "bgWidth", " imgLength", "dimSize", "imgLen", "augLen", "imagesize", "bgLength", "hrType", " imgWidth", "refSize", "imgHeight", "bgScale", "augWidth", "ifName", "imgWidth", "imagsize", "imgLength", "imHeight", "dimsize", " imgFamily", "ifLen", "imageLength", "imageSize", "dimHeight", "imageName", "refLength", "augSize", "imageLen", "imSize", " imgLen", "imageScale", "hrSize", "imLength", " imgName", "dimLength", "imgsize", "largeType", "bgLen", "imgScale", "bgSize", "imagType", "imgType", "imagC", "ifsize", "refHeight", "refsize", "hrsize", "augFamily", "imgFamily", "bgFamily", "imagSize", "largesize", " imgScale", "largeC", "imsize", " imgsize", "imgName", "hrC"], "imageInputStream": [" imageOutputSteam", "imageInstream", " imageOutputView", "imageReadFile", "imageStreamStream", "imageContentSteam", " imageInputFile", "imageInString", "pictureUploadFile", "imageInputSteam", "imageReadLength", "pictureUploadStream", "imageUploadstream", "imageReadstream", " imageOutputFile", "imageFilestream", "fileInputString", "imageFileString", "imageReadString", "imageInputFile", "imageInputView", "imageOutputView", "pictureInputstream", "imageInputstream", "pictureInputSteam", "fileReadStream", "fileInputstream", "imageUploadView", "photoReadSteam", "photoInputStream", "photoInputFile", "pictureUploadstream", "pictureInputStream", "pictureUploadSteam", "imageOutputFile", "imageReadStream", "fileInputLength", "fileInputStream", "photoReadStream", "photoInputSteam", "imageContentView", "pictureInputFile", "imageUploadStream", "imageUploadSteam", "imageOutputSteam", "fileReadString", " imageInputView", " imageOutputStream", "imageStreamFile", " imageInputSteam", "imageInLength", "imageStreamSteam", "imageInputString", "imageContentStream", "imageInStream", "fileReadstream", "imageContentFile", "photoReadstream", "imageStreamstream", "imageFileLength", "photoReadFile", "fileReadLength", "imageUploadFile", "imageFileStream", "imageReadSteam", "photoInputstream", "imageOutputstream", "imageOutputStream", "imageInputLength"], "imageBytes": ["imgBytes", "fileBlocks", "ImageBlocks", "audioBytes", "viewbytes", " imageUrl", "ImageData", "fileBytes", "viewBytes", "Imagebytes", "imageUrl", "fileData", "pictureData", "imageByte", "imgByte", "imgData", "audioBuffer", "viewData", "audiobytes", " imagebytes", "imagebytes", "imageBlocks", "ImageBytes", "imgBuffer", " imageData", "imageData", "audioByte", "filebytes", "picturebytes", "imgUrl", "viewUrl", " imageBuffer", "pictureBlocks", "imageBuffer", "imgbytes", "pictureBytes", " imageByte"]}}
{"id1": "9826240", "id2": "20365090", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "label": 0, "substitutes": {"checkHashBack": ["checkSumBACK", " checkhashback", " checkHashFront", "checkhashBACK", " checkhashBACK", "checkKeyBACK", "checkSumFront", "checkHashBACK", "checkKeyFront", " checkHashback", " checkhashBack", "checkhashBack", "checkHashback", " checkHashBACK", "checkhashFront", " checkhashFront", "checkhashback", "checkSumBack", "checkKeyback", "checkHashFront", "checkSumback", "checkKeyBack"], "facade": ["fade", "Facide", "humase", "factade", "facase", "factce", "Facades", "factase", " facades", "Facace", "Facade", "Facede", "Facce", "facades", " facce", " facoke", "face", "humade", " facase", "facoke", "facide", "facse", "fase", "humce", "Facse", " facede", "facace", "facce", "factide", "Facale", "foke", " facide", "Facase", "Facoke", "facale", "fades", "fse", "facede", "factoke", " facace", "factse", "humede", "fale", " facale"], "req": ["resp", "rec", "rt", "res", "crit", "fr", "url", "resource", "ru", "view", "cmp", "requ", "form", "info", "sem", "required", "f", "pb", "rb", "ref", "Request", "prof", "cb", "cur", "rf", "sq", "xml", "temp", "require", "pkg", "pr", "wx", "pull", "rr", "base", "util", "r", "cache", "exec", "err", "obj", "app", "def", "gr", "w", "ctx", "proc", "qq", "response", "query", "pro", "jp", "q", "http", "fp", "request"], "txtTransactionID": ["textTransactionType", "textTaskInfo", "txtOperationId", "txtTaskID", "txtOrderID", "txtTaskType", "txtOperationInfo", "txtOperationType", "txtTransactionId", "txtJobID", "txtTransactionName", "txtOrderType", "textTransactionID", "txtOrderId", "textTaskId", "textTransactionId", "textTransactionIP", "txtTaskName", "txtTransactionInfo", "textTaskIP", "txtTaskIP", "textTaskName", "textTransactionName", "txtJobIP", "txtTransactionIP", "txtJobId", "txtJobInfo", "txtOperationID", "textTransactionInfo", "textTaskID", "txtOperationName", "txtTransactionType", "txtOperationIP", "txtTaskInfo", "txtOrderName", "txtTaskId", "textTaskType"], "txtOrderTotal": ["xtOrderTotal", "txtEventNum", "txtEventTotal", "txtOrderNum", "xtOrderToken", "txtBlockToken", "txtBlockInfo", "xtOrderLast", "txtEventInfo", "txtRequestLast", "xtRequestInfo", "xtOrderInfo", "xtOrderNum", "txtAddressInfo", "txtEventToken", "xtBlockInfo", "xtRequestLast", "xtBlockNum", "xtOrdertotal", "txtBlockNum", "txtRequesttotal", "txtOrderToken", "xtBlockToken", "xtBlockTotal", "txtAddressTotal", "xtRequestTotal", "txtAddressLast", "txtJobtotal", "txtJobNum", "txtOrderInfo", "txtOrderLast", "txtBlockTotal", "txtRequestTotal", "txtJobTotal", "txtAddresstotal", "xtRequesttotal", "txtOrdertotal", "txtRequestInfo", "txtJobInfo", "txtJobToken", "txtJobLast"], "txtShopId": ["txtSessionName", "txtShopName", "txtOrderID", "txtFactoryId", "txtJobID", "txtSessionID", "txtJobName", "txtFactoryID", "txtOrderId", "textShopName", "textJobId", "txtFactoryName", "textShopInfo", "txtSessionId", "textJobInfo", "textShopId", "txtJobId", "txtJobInfo", "txtShopInfo", "txtShopID", "txtOrderInfo", "textShopID", "txtOrderName", "textJobID", "textJobName", "txtFactoryInfo", "txtSessionInfo"], "txtArtCurrency": ["txtartCulture", "txtARTSccurrency", "txtArtLCcurrency", "txtArtccurrency", "txtArtScurrencies", "txtArtLCurrencies", "txtArtCcurrency", "txtartcurrency", "txtartcerc", "txtARTSculture", "txtARTScurrency", "txtArtAccurrency", "txtartCurrency", "txtArtcurrency", "txtARTCurrency", "txtArtculture", "txtARTCulture", "txtArtCustomurrency", "txtArtCurrencies", "txtartCerc", "txtARTScurrencies", "txtArtSccurrency", "txtArtCustomerc", "txtArtScurrency", "txtArtcerc", "txtartCcurrency", "txtArtAcurrency", "txtArtAculture", "txtArtcurrencies", "txtartculture", "txtArtLCurrency", "txtArtCerc", "txtArtCustomcurrency", "txtArtAcerc", "txtArtCulture", "txtArtLCulture", "txtArtCustomulture", "txtartccurrency", "txtARTCcurrency", "txtARTCurrencies", "txtArtSculture"], "txtHashBack": ["txtMessageRest", "txtHashReturn", "txtCheckback", "textSumBack", "textHashFront", "txtHashBACK", "txtSHABack", "xtMessageRest", "xtSumback", "txtMessageback", "txtBlockReturn", "txtStyleBack", "txtSumSave", "textSumback", "textSumFront", "txtBlockFront", "txtHandleBack", "xtHashBack", "txtSHAReturn", "xtSumBACK", "txtHandleRest", "xtHashSave", "txtBlockback", "txtBlockRest", "txtHandleback", "textHashback", "txtSumBack", "textSumReturn", "txtHashback", "txtSumReturn", "txtStyleSave", "xtMessageback", "txtHashSave", "xtMessageBack", "txtMessageBack", "xtHashReturn", "txtHashRest", "xtHashBACK", "txtMessageReturn", "txtCheckSave", "txtStyleback", "txtSHAFront", "textHashBack", "xtHashback", "xtSumBack", "txtSumBACK", "txtSumFront", "txtHashFront", "xtMessageReturn", "txtBlockBack", "txtSHAback", "textHashReturn", "txtCheckBACK", "txtHandleReturn", "xtHashRest", "xtSumSave", "txtSumback", "txtCheckBack", "txtStyleBACK"], "hashSeed": ["hashPresees", "hashSlees", "HashSlees", "hashSeriesees", "hashSeeds", "hashRee", "hashSees", " hashSeeds", "hashSlql", " hashReeds", " hashRead", " hashReed", "hashSleeds", "hashSee", " hashSee", "hashSleed", "HashSees", "HashSql", "HashSeeds", "hashSql", "hashReed", "hashSlee", "hashPreseed", "hashSeriesql", "hashSerieseeds", "HashSleeds", "HashSlql", " hashRee", "hashPreseeds", " hashSead", "HashSleed", "hashSerieseed", "hashPresql", "hashSead", "hashReeds", "hashRead", "HashSeed", "hashSlead"], "securityValue": [" securityString", " securityFile", "securityKey", "SecurityValue", " securityKey", "secureValue", "SecurityKey", "secureFile", " securityValues", "secureValues", "secureKey", "securityFile", "SecurityValues", "SecurityFile", "securityValues", "securityString", "SecurityString", "secureString"], "digest": [" Digest", "Digusher", "defested", " Digested", " digEST", "DigEST", "sendHash", "logester", "Digence", "Digester", " Digge", "Digest", "digEST", " digested", "logest", "hashed", "digence", "diged", "signest", " digence", "DigHash", " digusher", "digestro", "digge", " Digester", "defester", " digester", "signested", "logence", "Digested", "hashHash", "digester", "signEST", "signester", "defge", " DigEST", " digestro", "digested", "Diged", "digusher", "Digge", "defest", "digHash", " Digestro", "sendEST", "sendest", "sended", "hashest", "hashEST", "Digestro", "logusher"], "array": ["sample", "arrow", "arr", "message", "image", "integer", "data", "allow", "range", "audio", "area", "archive", "storage", "batch", "error", "row", "our", "element", "instance", "record", "section", "pair", "number", "feature", "object", "address", "cache", "string", "Array", "list", "binary", "angle", "order", "environment", "function", "value", "buffer", "ray", "collection", "database"], "sb": ["buf", "kb", "bsp", "ssl", "sf", "sv", "osc", "fb", "bt", "bh", "si", "usb", "xb", "lb", "bc", "sn", "pb", "SB", "su", "rb", "cb", "mb", "s", "sq", "bf", "bm", "src", "bg", "sg", "db", "ib", "abb", "bj", "zb", "string", "BB", "sa", "orb", "gb", "sup", "ob", "sl", "obb", "wb", "buffer", "nb", "eb", "bs", "bb", "nn"], "j": ["ij", "k", "m", "js", "u", "z", "e", "length", "g", "n", "jc", "part", "f", "jj", "o", "ja", "d", "index", "ch", "dj", "uj", "key", "aj", "ji", "J", "jo", "i", "pr", "y", "oj", "section", "li", "l", "bj", "ind", "br", "v", "c", "obj", "dy", "ix", "ii", "jl", "x", "jp", "p"], "b": ["k", "p", "e", "body", "fb", "bp", "lb", "bc", "f", "d", "rb", "job", "cb", "mb", "code", "bf", "B", "i", "bd", "a", "l", "db", "bar", "ib", "ba", "string", "br", "bin", "c", "orb", "be", "ob", "binary", "wb", "bug", "bi", "x", "ab", "nb", "eb", "bs", "bb"], "hash": ["ash", "auth", "url", "report", "message", "image", "html", "build", "math", "sha", "lock", "height", "rh", "ph", "search", "result", "hex", "sum", "password", "error", "h", "key", "handle", "kh", "memory", "hh", "oh", "header", "ruby", "flash", "gh", "db", "number", "mac", "hed", "dash", "address", "cache", "history", "match", "confirmed", "ha", "Hash", "ssh", "sh", "json", "cover", "value", "dh", "block"]}}
{"id1": "62362", "id2": "15768167", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "11562173", "id2": "12766394", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkFileStream", " checkOutputChannel", "checkOutputStream", "checkOutputSteam", "checkOutputChannel", "checkIOStream", " checkInputSteam", "checkFileSteam", "checkIOstream", "checkFileChannel", " checkInputChannel", " checkOutputstream", " checkInputstream", "checkOutputstream", " checkOutputSteam", "checkIOChannel", "checkIOSteam", "checkInputSteam", "checkFilestream", " checkOutputStream", "checkInputChannel", "checkInputstream"], "in": ["into", "ins", "image", "In", "connection", "io", "data", "inc", "input", "din", "IN", "inn", "index", "is", "source", "ack", "reader", "src", "login", "inner", "min", "bin", "c", "con", "ic", "up", "ini", "as", "x", "plus", "comp", "again", "p", "isin"], "cmp": ["conv", "asc", "prefix", "np", "roc", "mp", "omp", "cp", "rc", "pixel", "loc", "prev", "cho", "spec", "cpp", "coll", "ch", "index", "sort", "ci", "cb", "clip", "code", "cc", "ctrl", "comment", "upp", "config", "co", "cache", "match", "pc", "amp", "c", "mom", "sup", "up", "ctx", "pre", "diff", "proc", "op", "lc", "comp", "cs", "cup", "fp", "p", "cop", "com"], "all": ["asc", "partial", "array", "default", "one", "call", "parent", "null", "except", "best", "none", "acl", "each", "allow", "not", "valid", "coll", "All", "sum", "cl", "and", "only", "process", "total", "al", "l", "a", "ann", "any", "local", "match", "ALL", "alpha", "list", "am", "global", "full", "both", "auto", "always", "p"], "stream": ["null", "speed", "Stream", "form", "this", "steam", "port", "raw", "socket", "channel", "output", "model", "impl", "document", "result", "input", "stack", "coll", "feed", "test", "temp", "instance", "progress", "source", "ack", "roll", "ream", "client", "reader", "self", "track", "src", "user", "round", "transform", "object", "trans", "string", "v", "platform", "up", "per", "host", "context", "pool", "response", "cont", "wrapper", "comp", "iterator", "sw"], "out": ["prefix", "array", "image", "copy", "null", "parent", "b", "io", "outer", "data", "project", "this", "sync", "inc", "part", "not", "output", "result", "block", "exp", "o", "index", "sum", "Out", "comment", "point", "outs", "user", "v", "bin", "c", "obj", "name", "list", "other", "option", "full", "OUT", "up", "extra", "response", "x", "again", "p"], "i": ["k", "u", "uri", "e", "j", "b", "n", "fi", "init", "io", "info", "si", "f", "it", "index", "d", "end", "key", "type", "ci", "oi", "ji", "h", "abi", "multi", "li", "di", "l", "mi", "hi", "pi", "xi", "slice", "r", "ind", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "ix", "strength", "ini", "ii", "ui", "x", "bi", "qi", "lc", "p"]}}
{"id1": "9647576", "id2": "11704429", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"Reserve": ["Serve", "Resolve", "Resend", " Reserves", "Send", "Reserves", "Serves", " Resolve", "Rerves", "Rerve", "Rolve", " Resend", "Rend", "Solve"], "stbookings": ["stbookies", "ssbooksalls", "stbooksalls", "stBookifications", "stbookalls", "ssbooksifications", "stauthorings", "stbookifications", "ssbookalls", "ssbooksings", "stbooksings", "stbooksifications", "stauthorifications", "stauthoralls", "stbooksies", "ssbookings", "stBookalls", "stauthories", "stBookings", "ssbookifications", "stBookies", "ssbooksies", "ssbookies"], "stchartwl": ["STchartowl", "STchartls", "stconfigls", "stplotwl", "stplotml", "STconfigml", "st_ml", "st_wl", "STchartml", "stplotls", "STconfigls", "STchartwl", "stconfigwl", "STconfigowl", "stconfigowl", "stchartowl", "stchartml", "stchartls", "st_owl", "STconfigwl", "stconfigml", "st_ls", "stplotowl"], "sp": ["osp", "span", "page", "text", "bsp", "spe", "sf", "html", "scope", "script", "mp", "ss", "ps", "pl", "profile", "esp", "bp", "spl", "si", "session", "ig", "ipp", "yp", "inst", "str", " esp", "type", " SP", "rap", " sc", "xml", "pr", "source", "isp", " Sp", "Sp", "ip", "sg", "sc", "email", "SP", "amp", "ap", "name", "service", "sil", "sl", "arp", "pace", "sk", "spr", "op", "jp", "pp", "p", "tp", "space"], "userbooksql": ["userbooksil", "userreadskl", "userpagesqs", "usersbookQL", "otherbookqs", "userordersqs", "userreadsil", "useraveskel", "userbookqs", "userordersQL", "userbookearch", "userbookskl", "otherbookql", "userreadskel", " userbooksil", "usersbookql", "userbookprintf", "userlocksQL", "userreadsearch", "userbanksil", "otherbooksQL", "userpagesql", "userlocksearch", "userlocksql", "usersbooksprintf", " useravesil", "userbankskl", "userpagesQL", "useraveskl", "usersbooksearch", "usersbooksQL", " useravesql", "otherbooksqs", "userbookQL", "userbookssql", "useravesql", "useravesil", "usersbookprintf", "usersbookearch", "userbooksprintf", "otherbooksql", "usersbooksql", "userbanksql", "userbankskel", "otherbookssql", " userbookskel", " useraveskl", "userbooksqs", "userordersql", "userbookql", "userbooksearch", "userlocksprintf", "userbookskel", "userreadsprintf", " userbookskl", "userpagessql", " useraveskel", "otherbookQL", "userorderssql", "userbooksQL", "userreadsql", "userreadsQL"], "agentbooksql": ["agentstylessql", "agentgroupsQL", "userpagesci", "agentpluginsci", "agentpagesci", "userbooksil", "userbooksqu", "agentpluginsql", "agentstylesqu", "agentbooksQL", "agentgroupsql", "agentBooksil", "userbooksli", "agentgroupssql", "userpagesli", "agentgroupsli", "agentpagessql", "agentpagesli", "agentbooksli", "agentbookssql", "agentpluginssql", "agentBooksqu", "agentbookli", "userbooksci", "agentpagesQL", "agentpagesql", "userpagesql", "agentstylesql", "userpagesQL", "agentbooksci", "agentbookQL", "userbookssql", "agentpluginsQL", "agentstylesil", "agentbookql", "userpagessql", "agentBooksql", "agentBookssql", "agentbooksil", "userbooksQL", "agentbooksqu"], "bookingid": ["booksingsid", "bookingsurl", "booksingsurl", "bookingsname", "bookillingurl", "booksingurl", "bookingname", "booksingsinfo", "bookingurl", "booksinginfo", "bookINGid", "bookingsid", "bookingsinfo", "booksingname", "bookillingid", "bookINGinfo", "bookinginfo", "bookillinginfo", "booksingid", "bookINGname", "booksingsname", "bookillingname", "bookINGurl"], "currentcoach": ["currentpoase", "currentlycoaching", "currentloach", " currentloach", "currentgoach", "currentchoam", "currentgoac", "currentchoase", "currentpoam", "currentCOac", " currentcoached", "currentchoach", "currentpoaching", "currentlycoac", "currentboache", " currentpoase", "currentloached", "currentpoach", "currentcoached", "currentpoached", "currentpoah", "currentlypoaching", "currentpoac", "currentcoase", "currentboach", "currentnoach", "currentcoac", "currentgoaching", "currentlypoach", "currentlycoache", "currentCOach", "currentpoache", "currentloah", "currentgoache", " currentloache", " currentcoam", " currentpoam", "currentCOase", "currentloache", "currentnoaching", " currentloached", "currentchoac", "currentnoache", " currentcoah", " currentcoase", "currentboached", " currentloah", "currentlypoac", " currentpoac", "currentcoaching", "currentCOam", " currentcoac", "currentcoah", "currentlypoache", "currentnoac", " currentcoache", "currentcoache", "currentcoam", "currentlycoach", " currentpoach", "currentboah"], "currentseat": ["Currentcomponent", " currentcourse", "currentsex", "Currentseat", "currentseason", "activecourse", "currentslave", "Currentcourse", "activecomponent", "currentcomponent", "currentlyslave", "currentlyseason", " currentslave", "currentticket", "Currentseason", "Currentsex", "currentlysex", "Currentticket", " currentseason", "Currentslave", " currentcomponent", " currentticket", "activeticket", "currentcourse", "currentlyseat", " currentsex", "activeseat"], "tickpos": ["crosspos", "ickPOS", "tickpointer", "trialPOS", "ickpose", "stickpos", "stickposition", "ickerpos", "ickerpointer", "tickposition", "helloposition", "tickpo", "trialpos", "helloPos", "ickposition", "ickerposition", " tickpo", "trialPos", " tickPos", "hellopos", " tickPOS", "tickPos", "ickPos", "ickpos", "hellopointer", "helloPOS", "ickpointer", "crossPos", "stickPos", "crosspo", " tickpose", "tickpose", " tickposition", "trialpose", "ickpo", "tickPOS", "ickerPos"], "chartavailupdsql": ["chartavailupsssql", "chartavailupcssql", "chartavailupdsqs", "chartavailupcsqs", "chartavailupdatessql", "chartavailupdssql", "chartavailumpssqs", "chartavailupssql", "chartavailumpssql", "chartavailupdatesqs", "chartavailumpdssql", "chartavailumpsssql", "chartavailumpdsql", "chartavailupssqs", "chartavailupdatesql", "chartavailupcsql", "chartavailumpdsqs"]}}
{"id1": "17786231", "id2": "21642215", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": [" downloadStream", "downloadStream", "copyfile", "copyFile", "transferfile", "copyFiles", "transferFile", "copyStream", "transferStream", " downloadFiles", "downloadFiles", " downloadfile", "transferFiles", "downloadfile"], "downloadUrl": ["updateurl", "outputLine", "outputurl", "updateLine", "transferFile", "downloadURL", "transferurl", "updateUrl", "downloadLine", "transferURL", "outputUrl", "updateURL", " downloadURL", "downloadurl", "outputURL", " downloadLine", " downloadurl", "updateFile", "transferUrl"], "destinationFile": ["destporaryFiles", "destigrationFILE", "destoutputString", "DestinatingFILE", "destoutputImage", "destinatedFILE", "destinatedFile", "destigrationFile", "destporaryString", "destinatingFile", "DestinationFile", "DestinatingString", "destinatingFilename", "destinatingImage", "destporaryImage", "destigrationFiles", "DestinatingFiles", "destigrationFilename", "DestinationFILE", "DestinatingFilename", "DestinatingFile", "DestinationString", "DestinatingImage", "destinatingString", "destoutputFile", "destinatingFILE", "destinatedFilename", "destporaryFile", "destinationImage", "destinationFILE", "destinationFilename", "destoutputFiles", "destinationString", "DestinationImage", "destinatingFiles", "DestinationFiles", "DestinationFilename", "destinationFiles", "destinatedFiles"], "client": ["proxy", "url", "uri", "resource", "server", "call", "parent", "connection", "force", "remote", "ce", "method", "project", "session", "channel", "application", "connect", "cl", "conn", "plugin", "api", "config", "bird", "cli", "contact", "self", "Client", "queue", "cache", "https", "con", "c", "handler", "app", "service", "per", "cher", "get", "query", "http", "request"], "httpGet": ["HttpCreate", "ttpCall", "httpCall", "ttpSend", " httpSend", "ttpCreate", "resourcePut", "httpSend", "ttpGet", "HttpCall", "resourceCall", "httpPut", "resourceget", "HttpGet", " httpPut", "Httpget", "resourceGet", "HttpPut", " httpCall", " httpget", "httpCreate", "httpget", " httpCreate", "HttpSend"], "outputFile": ["outputFiles", "referencePath", "writeFile", "referenceFile", "targetDir", "writeStream", "inputFile", " outputPath", " outputDirectory", "targetFiles", " outputfile", "outputDirectory", "outfile", "outStream", "writePath", "outputPath", "referencefile", "targetFile", "inputDirectory", "inputDir", " outputFiles", "referenceStream", "targetDirectory", "outputDir", "outPath", "outFile", "inputFiles", " outputDir", "writefile", "outputfile"], "outputStream": ["inputSteam", "inputWriter", "outputStreamer", " outputSteam", " outputForm", "logWriter", "inputFile", "outputForm", "responseFile", "inputStreamer", "inputForm", "responseStream", "responseSteam", "outputWriter", " outputWriter", "logSteam", "logStream", "OutputWriter", " outputStreamer", "responseWriter", "OutputForm", "OutputStream", "OutputSteam", "outputSteam", "logStreamer", "OutputFile"], "response": ["resp", "respond", "report", "resource", "message", "image", "server", "Response", "connection", "body", "event", "data", "version", "session", "output", "application", "status", "document", "result", "reply", "error", "api", "queue", "object", "handler", "success", "relation", "json", "query", "generation", "collection", "http", "feed", "request", "ception", "received"], "entity": ["pe", "component", "attribute", "ity", "url", "unit", "resource", "e", "image", "server", "message", "volume", "body", "connection", "Entity", "item", "ce", "event", "data", "ie", "channel", "output", "model", "document", "entry", "result", "status", "application", "coll", "translation", "ent", "el", "xml", "instance", "element", "issue", "metadata", "source", "api", "media", "comment", "agent", " identity", "node", "object", "id", "cache", "email", "file", "machine", "service", "environment", "json", "content", "state", "collection"], "inputStream": ["downloadLength", "inputChannel", "inputSteam", " inputSteam", "InputLength", "childSteam", "audioSteam", "InputFile", "InputChannel", "outputStreamer", "outputstream", "selectFile", "inputFile", "childStream", "audiostream", "inputStreamer", "audioStream", "downloadSteam", "selectSteam", "inputLength", " inputStreamer", "Inputstream", "InputStreamer", "downloadstream", "childChannel", "audioStreamer", " inputFile", "childStreamer", " inputLength", " inputBuffer", "selectStream", "downloadStream", "outputSteam", "InputBuffer", "InputSteam", "inputBuffer", "outputChannel", "outputBuffer", "inputstream", " inputstream", "selectStreamer", "InputStream", " inputChannel"], "callback": ["proxy", "closure", "url", "CB", "message", "resource", "call", "connection", "Callback", "cell", "event", "fb", "back", "data", "sync", "func", "result", "batch", "clone", "cb", "band", "code", "cc", "plugin", "consumer", "future", "config", "ff", "backs", "cache", "handler", "loader", "behavior", "function", "wrapper", "state", "buffer", "collection", "processor"], "copiedLength": ["copiedlength", "copippedLength", "copodedWidth", "copyiedWidth", "copedBytes", "copodedSize", "copyingLength", "copyingCount", "copedSize", "copiedCount", "copyiedSize", "copyippedWidth", "copedLength", "copyinglength", "copixedBytes", "copiedBytes", "copyiedCount", "copyippedLength", "copodedLength", "copyingWidth", "copyiedLength", "copixedCount", "copyedLength", "copodedlength", "copyingSize", "copyiedlength", "copyiedBytes", "copippedlength", "copyingBytes", "copixedSize", "copixedLength", "copiedSize", "copedCount", "copyippedlength", "copippedWidth", "copippedSize", "copiedWidth", "copyedBytes", "copyedSize", "copyippedSize", "copyedCount"], "percentage": ["Percentance", "percentile", "Percentade", " percentages", "milade", " Percentages", " Percentance", "percentaged", " Percentile", "percentages", "milance", " percentance", "percentance", " percentade", " percentaged", "Percentaged", "milage", "Percentages", " Percentage", "Percentile", "percentade", " percentile", "milaged", "Percentage"]}}
{"id1": "19944975", "id2": "11562173", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveReport", "WriteConfiguration", "writeReport", " writeReport", " writeSection", "writeSection", "saveConfiguration", "WriteConfig", "WriteSection", "saveSection", " writeConfig", "saveConfig", "writeConfig", "WriteReport"], "out": ["at", "m", "prefix", "res", "ex", "writer", "report", "resource", "write", "plain", "server", "parent", "scope", "connection", "init", "io", "this", "project", "sync", "external", "output", "exp", "o", "inas", "IN", "password", "Out", "key", "conn", "xml", "temp", "flush", "reader", "config", "client", "filename", "dump", "inner", "base", "outs", "user", "object", "string", "exec", "file", "obj", "c", "err", "name", "list", "window", "w", "OUT", "path", "pool", "again", "line", "lib", "ext"], "url": ["page", "uri", "ssl", "resource", "ll", "server", "image", "b", "connection", "rel", "io", "org", "data", "channel", "f", "URL", "conn", "xml", "source", "api", "config", "stream", "l", "web", "base", "r", "object", "address", "string", "file", "service", "ob", "sl", "path", "Url", "location", "http", "feed", "open"], "in": ["ins", "ssl", "resource", "In", "copy", "b", "n", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "xml", "cin", "i", "is", "rin", "source", "reader", "win", "kin", "inside", "nin", "stream", "a", "login", "cms", "inner", "min", "r", "id", "ac", "bin", "c", "err", "file", "pin", "ini", "as", "again", "serv", "isin"]}}
{"id1": "14001795", "id2": "12246545", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyoverwarPath", "copyOverwarfile", "copyoverwarfile", "copyoverwarFile", "copyOverWarfile", "copyOverwarPath", "copyOverWarPath", "copyOverWARPath", "copyoverWarfile", "copyOverWebfile", "copyOverWebFiles", "copyOverWebFile", "copyOverWARfile", "copyOverWARFiles", "copyOverWarFiles", "copyoverwarFiles", "copyOverWebPath", "copyoverWarFiles", "copyoverWarPath", "copyOverwarFile", "copyoverWarFile", "copyOverWARFile", "copyOverwarFiles"], "dir": ["fd", "doc", "log", "direction", "http", "url", "parent", "build", "dr", "loc", "manager", "lock", "DIR", "data", "md", "store", "part", "folder", "group", " directory", "zip", "d", "coll", "draft", "wd", "cur", "download", "handle", "plugin", "pkg", "class", "config", "directory", "keep", "work", "di", "db", "r", "local", "cache", "desc", "ir", "handler", "file", "dist", "window", "dc", "def", "direct", "up", "dn", "clean", "Dir", "director", "feed", "lib", "df"], "ff": ["fd", "buf", "uf", "fl", "lf", "flow", "sf", "ffe", "fed", "fox", "fb", "ph", "fff", "xff", "dd", "fp", "now", "cpp", "cl", "eff", "cb", "rf", "bf", "uff", "bd", "ffff", "upp", " buff", "TF", "buff", "iff", "ft", "fw", "fx", "fam", "eph", "fold", "FF", "aff", "cf", "ef", "fe", "pp", "feed", "bb", "df"], "files": ["ls", "keys", "fl", "rows", "users", "ps", "jobs", "data", "ums", "sections", "apps", "bs", "groups", "features", "fa", "plugins", "split", "classes", "lines", "balls", "fs", "s", "flows", "objects", "results", "images", "pages", "names", "models", "file", "locks", "iles", "blocks", "Files", "events", "fe", "items"], "f": ["fd", "fn", "fl", " file", "fr", "lf", "e", "sf", "n", "flat", "info", "fb", "part", "fa", "d", "feed", "fs", "tf", "rf", "inf", "bf", "i", "filename", "l", "of", " fa", "v", "handler", "c", "file", "fold", "name", "fc", "t", "fen", "aff", "cf", "F", "x", "fe", "fp", "p"], "newFile": ["existingLine", "NewFolder", " newLine", "NewFile", "NewFiles", "nextFile", "oldFile", "updateLine", "newFolder", "oldFiles", " newDir", "newfile", "smallfile", "smallFile", "newF", "updatefile", "existingF", "nextFiles", " newFolder", " newfile", "andfile", "nextFolder", " newFiles", "andFile", "NewF", "NewDir", "nextDir", "newLine", "existingfile", "smallDir", "oldDir", " newF", "andDir", "newFiles", "newDir", "updateFile", "oldF", "updateF", "existingFile"], "fi": ["ifa", "fr", "lf", "fin", "sf", "ico", "isi", "ffe", "wi", "uci", "sci", "info", "Fi", "shi", "fb", "si", "ife", "py", "flo", "fa", "fs", "abi", "i", "ifi", "pi", "xi", "fw", "cci", "afe", "fine", "FI", "fc", "fy", "zi", "cf", "ini", "ii", "bi", "afi", "fe", "fp", "qi"], "fo": ["ato", "wo", "FO", "uf", "sf", "ico", "ki", "os", "xf", "io", "info", "shi", "mo", "si", "tto", "osa", "ni", "obi", "flo", "so", "fa", "o", "olo", "ko", "bo", "inf", "ho", "di", "zo", "co", "fw", "po", "afe", "oo", "cf", "lo", "afi", "fe", "obo", "ofi"]}}
{"id1": "7764011", "id2": "10158738", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvvieweString", "readScalarpvvieweDocument", "readScalarpvViewerdocument", "readScalarpvViewersdocument", "readScalarpvviewerString", "readScalarpvviewedDocument", "readScalarpvviewersString", "readScalarpvviewedData", "readScalarpvViewersDocument", "readScalarpvViewerString", "readScalarpvViewerDocument", "readScalarpvviewedocument", "readScalarpvViewersString", "readScalarpvviewerData", "readScalarpvvieweData", "readScalarpvviewerdocument", "readScalarpvviewersdocument", "readScalarpvviewersData", "readScalarpvvieweddocument", "readScalarpvviewersDocument", "readScalarpvViewersData", "readScalarpvViewerData", "readScalarpvviewedString"], "url": ["page", "uri", "ssl", "resource", "image", "server", "connection", "remote", "io", "data", "link", "entry", "input", "URL", "href", "job", "bel", "xml", "source", "reader", "config", "filename", "stream", "l", "base", "user", "object", "address", "string", "file", "name", "service", "sl", "host", "path", "Url", "location", "buffer", "http"], "xmlData": ["rssdata", " xmlString", "xmlString", "wsDATA", "xfData", "mlCode", "xmlCode", "xfText", "rssData", "xmlPart", "textDATA", "wsString", "parseData", "xmlDATA", "phpDATA", "parsedata", "parseText", "textData", " xmlCode", "mlContent", " xmldata", "mldata", "mlText", "phpPart", "xmlText", "rssString", "rssDATA", "xfDATA", "textPart", "phpContent", "wsData", "xmlContent", "textContent", " xmlText", "parseCode", "phpData", "mlData", "xmldata", " xmlContent", "wsdata", "mlDATA", " xmlDATA", "xfContent", " xmlPart"], "in": ["rec", "m", "ins", "ssl", "In", "b", "connection", "data", "this", "inc", "socket", "f", "input", "din", "IN", "lin", "inn", "h", "out", "s", "i", "kin", "win", "source", "reader", "a", "stream", "l", "login", "nin", "inner", "min", "r", "bin", "c", "file", "con", "ini", "buffer", "again", "serv", "doc"], "line": ["one", "letter", "data", "single", "part", "phrase", "entry", "split", "cl", "row", "pass", "l", "string", "file", "non", "on", "page", "pe", "text", "unit", "message", "e", "cell", "link", "no", "error", "el", "code", "plugin", "parse", "point", "object", "c", "word", "lc", "content", "LINE", "log", "none", "sync", "rule", "str", "lin", "lines", "end", "job", "comment", "section", "user", "character", "Line", "sl", "value", "chain", "block", "lf", "write", "le", "item", "range", "edge", "strip", "nl", "inline", "ip", "base", "name", "auto", "ine"], "cont": ["resp", "text", "CONT", "circ", "ct", "const", " continuous", "parent", "count", "complete", "dest", "prev", "form", "cell", "cart", "expl", "feat", "collect", "cond", "result", "cor", "str", "acc", "coll", "contin", "sect", "ent", " Cont", "comb", "ci", "out", " CONT", "rest", " cur", "progress", "multi", "keep", " cond", "ctr", "tr", "det", "match", "mult", "err", "Cont", "continue", "left", "full", "clean", "content", "lc", "comp", "ident", "close", "contract", "feed", "ont", "ext", "char", "com"], "readAdp": ["ReadAxps", " readads", "loadADp", "readEllp", "readAdr", "readEdps", " readAdr", "readAxps", "readADp", "readadps", " readAbpi", " readAbr", "readADb", "readAxP", "readEdpi", "readEllpi", "loadAdp", " readadpi", "readAblp", "ReadAxpi", "readAds", "readads", "readPromp", "loadAdpi", "readAdc", " readAdP", "readAdb", "loadADb", " readAds", "ReadAdc", "readAbb", "loadADpi", "readEdc", "readAbr", "readAxpi", "readadP", "readAdP", "readAxp", "readadpi", "readPromlp", "readPromb", "readADlp", "readAdlp", "loadAdlp", "readadp", "readAdps", " readAbp", "loadADlp", "readElllp", "readAdpi", " readAdpi", "readADs", "ReadAdp", "readadc", "readAxs", "readAxc", "readADr", "readAbpi", " readAblp", "loadAdb", "ReadAxp", " readAdlp", "readEllr", "readADpi", "readADP", "ReadAdpi", " readadp", "readAbp", "readPrompi", "ReadAdps", "ReadAxc", "readEdp", " readadP"], "scalarpvviewerData_Adaptor": ["scalarpvviewerDataLocalAdaptors", "scalarpvviewerData_Uploadive", "scalarpvviewerDataLocaladaptor", "scalarpvviewerDataerAdaptors", "scalarpvviewerData_Connectors", "scalarpvviewerDataeradapter", "scalarpvviewerData_Selectors", "scalarpvviewerData_Collectutor", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Creative", "scalarpvviewerDataLocalAdaptator", "scalarpvviewerData_Uploadator", "scalarpvviewerData_Collector", "scalarpvviewerData_adaptator", "scalarpvviewerData_adaptive", "scalarpvviewerDataeradaptors", "scalarpvviewerData_Adaptractor", "scalarpvviewerDataLocaladaptOR", "scalarpvviewerData_adaptractor", "scalarpvviewerDataeradaptator", "scalarpvviewerDataLocaladaptator", "scalarpvviewerData_Adaptator", "scalarpvviewerDataeradaptor", "scalarpvviewerData_Creator", "scalarpvviewerData_Creators", "scalarpvviewerData_Connectutor", "scalarpvviewerData_Adaptors", "scalarpvviewerData_adaptors", "scalarpvviewerDataerAdaptutor", "scalarpvviewerData_Collectator", "scalarpvviewerData_Collectractor", "scalarpvviewerData_Creatutor", "scalarpvviewerData_Adaptive", "scalarpvviewerData_adapter", "scalarpvviewerData_Uploador", "scalarpvviewerData_Creater", "scalarpvviewerData_Selectator", "scalarpvviewerData_CollectOR", "scalarpvviewerData_Adaptutor", "scalarpvviewerDataerAdaptator", "scalarpvviewerData_Selector", "scalarpvviewerData_adaptor", "scalarpvviewerData_Collectors", "scalarpvviewerDataerAdaptractor", "scalarpvviewerData_adaptOR", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Uploadors", "scalarpvviewerDataLocalAdaptOR", "scalarpvviewerDataerAdaptor", "scalarpvviewerData_adaptutor", "scalarpvviewerDataerAdapter", "scalarpvviewerDataeradaptutor", "scalarpvviewerData_Connector", "scalarpvviewerData_Connectator", "scalarpvviewerDataLocalAdaptor", "scalarpvviewerData_Creatator", "scalarpvviewerData_Connecter", "scalarpvviewerData_Selecter", "scalarpvviewerData_Adapter", "scalarpvviewerDataeradaptractor", "scalarpvviewerDataLocaladaptors"], "params_font": ["params_layout", "paramsinglarge", " params_layout", "ams_large", "pins_text", "ams_font", " params_Font", "params_password", "paramsingpen", "ams_fat", "ams_pen", "params_theme", "params_pen", "paramsingfont", "pins_password", "paramsingfat", "params_chart", "params_shadow", "pins_font", "ams_chart", "params_Font", "pins_fat", "params_fat", "params_text", "ams_theme", "params_large", " params_shadow"], "font_size": ["font\u00b7number", "text_size", " font_handle", "font\u00b7size", "font_type", "font_scale", "fontBlocktype", "fontBlockalign", "text_Size", "font_align", "font_Size", " font_number", "text_align", "font_handle", "font\u00b7handle", " font_scale", "text_type", "fontBlocksize", " font_Size", "font_number", "fontBlockSize"], "style": [" size", "css", "font", "padding", "pad", "length", "count", "offset", "Style", "letter", "thin", "height", "profile", "depth", "weight", "scale", "margin", "shape", " Style", "family", "shadow", "type", "class", "theme", "size", "width", "position", "layout", "name", "color", "pattern", "grade", "order", "level", "estyle", "format", "force", "styles"], "font_Family": ["style_Style", " font_fam", "fontNamefamily", "style_Family", "font_Format", "fontNameFamily", "font_family", "style_family", " font_family", "fontingfamily", "fontingStyle", "fontingFamily", " font_Format", "fontNameStyle", "font_fam", "font_Style"], "globalFont": ["globalfont", "parentFont", "Globalfont", "globalFontSize", " globalfont", "generalFontSize", "localText", "GlobalFont", " globalText", " globalFontSize", "GlobalFontSize", "localFont", "generalText", "globalText", "parentFontSize", "parentfont", "GlobalText", "generalFont", "parentText", "localFontSize"], "params_pts": ["params_erts", "params_tds", "params__ptm", "params_ptp", "params_rtn", "params_PTp", "params_ptn", "params_fontss", "params__pts", "params_PTe", "params_fontn", "params_eptss", "params_erta", "params__cts", "params_pta", "params_pte", "params__ctn", "params_rts", "params_erte", "params_PTm", "params_fonts", "params_ctm", "params_PTa", "params_eptn", "params_tde", "params_PTs", "params__ptn", "params_rtm", "params_fontp", "params__ctm", "params_epts", "params_PTss", "params_ctn", "params_PTn", "params_ptm", "params_tda", "params_cts", "params_eptp", "params_ptss"], "params_data": ["params\n", "Parameters\n", "paramsname", "Parametersname", " params\n", "paramname", "param\n", " paramsname"]}}
{"id1": "11334468", "id2": "12883117", "code1": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 1, "substitutes": {"wordFrequency": ["WordFitness", "wordTrequency", "wordFeedrequency", "wordFitness", "wordFidelity", "WordFrequency", "WordFraction", "wordFraction", "wordFeedraction", "wordFeeditness", "WordWraction", "WordWrequency", "wordTraction", "wordTitness", "wordWrequency", "wordFeedidelity", "wordWitness", "wordWraction", "wordWidelity", "wordTidelity", "WordWidelity", "WordFidelity", "WordWitness"], "word": ["prefix", "text", "writer", "message", "term", "letter", "tag", "Word", "old", "part", "sword", "search", "phrase", "rule", "input", "str", "password", "key", "out", "code", "W", "wp", "number", "token", "string", "language", "name", "ww", "w", "pattern", "words", "query", "first", "line", "nn"], "replWebQuery": ["replWaveQu", "replWebUrl", "replWebRequest", "ReplWebUrl", "replCoreRequest", "replWebquery", "replWaveQuery", "replwebUrl", "replaceWebquery", "replacewebExp", "replWordquery", "replwebExp", "replwebquery", "Replwebquery", "replwebQuery", "replwebQu", "replacewebRequest", "replWavequery", "replaceWebExp", "replacewebQuery", "replaceWebRequest", "replacewebquery", "ReplwebUrl", "replWaveUrl", "replWebExp", "replWebQu", "replWordRequest", "ReplwebQuery", "replwebRequest", "replCoreQuery", "replCorequery", "ReplWebQu", "replWordExp", "ReplwebQu", "ReplWebQuery", "ReplWebquery", "replWordQuery", "replaceWebQuery", "replCoreExp"], "url": ["ls", "page", "log", "uri", "ssl", "e", "ll", "resource", "server", "image", "b", "connection", "org", "data", "link", "socket", "channel", "f", "impl", "zip", "www", "URL", "str", "conn", "xml", "source", "l", "web", "base", "r", "object", "address", "string", "file", "service", "sl", "path", "Url", "location", "buffer", "hub", "http", "feed", "bb", "open", "browser"], "content": ["text", "description", "resource", "message", "image", "body", "data", "raw", "output", "entry", "result", "input", "str", "read", "Content", "out", "xml", "source", "comment", "reader", "media", "stream", "string", "response", "cont", "buffer", "line", "feed"], "in": ["ins", "e", "image", "server", "In", "b", "connection", "io", "data", "this", "inc", "f", "gin", "input", "din", "IN", "inn", "out", "s", "conn", "i", "rin", "source", "reader", "client", "nin", "stream", "l", "login", "inner", "user", "r", "bin", "file", "c", "con", "ini", "as", "again", "line", "serv", "isin"], "inputLine": ["outputBlock", "Inputline", "outputLine", "inputBlock", "InputFile", "InputBlock", "inputL", "inputFile", "InputLine", "outputFile", "inputStream", " inputline", "outputL", " inputStream", "feedline", " inputFile", "outputline", "feedStream", "feedL", "InputL", " inputBlock", "inputline", "feedLine", " inputL", "InputStream"], "fr": ["kr", "ur", "rt", "fl", " r", "arr", "fin", "frac", "fre", "dr", "rs", "fb", "range", "f", "Fr", "vr", "fp", "fm", "str", "elt", "result", "el", "pr", "rl", "len", "rr", "lr", "fx", "feature", "tr", "FR", "adr", "br", "fee", "err", "dist", "fer", " dr", "sr", "fc", "aa", "ler", "fe", "cr", "rf", "ire", " result"]}}
{"id1": "19944975", "id2": "9261777", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveReport", "WriteConfiguration", "writeReport", " writeReport", " writeSection", "writeSection", "saveConfiguration", "WriteConfig", "WriteSection", "saveSection", " writeConfig", "saveConfig", "writeConfig", "WriteReport"], "out": ["at", "m", "prefix", "res", "ex", "writer", "report", "resource", "write", "plain", "server", "parent", "scope", "connection", "init", "io", "this", "project", "sync", "external", "output", "exp", "o", "inas", "IN", "password", "Out", "key", "conn", "xml", "temp", "flush", "reader", "config", "client", "filename", "dump", "inner", "base", "outs", "user", "object", "string", "exec", "file", "obj", "c", "err", "name", "list", "window", "w", "OUT", "path", "pool", "again", "line", "lib", "ext"], "url": ["page", "uri", "ssl", "resource", "ll", "server", "image", "b", "connection", "rel", "io", "org", "data", "channel", "f", "URL", "conn", "xml", "source", "api", "config", "stream", "l", "web", "base", "r", "object", "address", "string", "file", "service", "ob", "sl", "path", "Url", "location", "http", "feed", "open"], "in": ["ins", "ssl", "resource", "In", "copy", "b", "n", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "xml", "cin", "i", "is", "rin", "source", "reader", "win", "kin", "inside", "nin", "stream", "a", "login", "cms", "inner", "min", "r", "id", "ac", "bin", "c", "err", "file", "pin", "ini", "as", "again", "serv", "isin"]}}
{"id1": "11484416", "id2": "2642914", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"moveFile": [" moveFiles", "moveDirectory", "MoveDirectory", "MoveFiles", " movedFiles", "MovePath", " movedFile", "moveFiles", " movePath", " moveDirectory", "MoveFile", " movedPath", "movePath", " movedDirectory"], "orig": ["buf", "proxy", "original", "array", "raid", "frame", "image", "copy", "dest", "build", "prev", "loc", "init", "remote", "ori", "info", "org", "old", "folder", "f", "impl", "archive", "coll", "rb", "comb", "home", "temp", "source", "iter", "src", "tmp", "raf", "base", "coord", "ctr", "internal", "transform", "id", "bin", "file", "obj", "bas", "origin", "exe", "Orig", "ext", "real", "imag", "img"], "target": ["replace", "prot", "to", "original", "resource", "copy", "dest", "build", "master", "parent", "remote", "manager", "project", "this", "external", "f", "it", "result", "archive", "nt", "template", "eth", "temp", "source", "tmp", "Target", "base", "object", "match", "arget", "platform", "origin", "t", "reference", " Target", "next", "ret", "path", "auto", "current", "format", "force", "compatible", "join"], "buffer": ["wave", "buf", "bb", "request", "padding", "url", "frame", "message", "resource", "write", "length", "copy", "b", "null", "data", "Buffer", "raw", "sequence", "result", "input", "stack", "batch", "read", "bytes", "code", "source", "iter", "header", "buff", "base", "queue", "position", "slice", "cache", "address", "bin", "file", "repeat", "reference", "binary", "layer", "transfer", "uffer", "content", "feed", "block"], "bread": ["circ", "rows", "bat", "meal", "good", "length", "wake", "ffe", "raft", "num", "fall", "fed", "die", "piece", "rub", "cake", "hello", "bc", "food", "loop", "zip", "robe", "str", "inn", "batch", "key", "broken", "fe", "abi", "width", "rib", "web", "beat", "design", "fred", "bn", "brew", "div", "fee", "cook", "fif", "knife", "buck", "fle", "fine", "fen", "wen", "ble", "zero", "sleep", "eb", "grain", "feed", "bb", "bare", "four", "choice", "bee"], "fis": [" fils", "ufils", "lfis", "ufis", "ufiss", " fiss", "lfIs", "hos", "fisa", "qiss", "fxos", "fxisa", "qis", "ufos", " fisa", "fxIs", "fils", "fxis", "his", "qils", "fIs", "fiss", "lfiss", "qos", "afiss", "afIs", "hIs", "afis", "lfos", "afos", " fIs", "hisa"], "fos": ["fois", "Fors", "infors", "infois", " fros", "fose", "fens", " fens", "gros", "flos", "Fos", "flois", "fors", "foses", "faos", "infos", "infaos", "Foss", "gis", "flaos", "Fois", " foses", " fose", "Fens", "flose", "flens", " foss", "Faos", "Foses", "floses", "Fros", "gos", "Fose", "foss", "goss", "flors", "fros", "Fis"]}}
{"id1": "2668853", "id2": "8625346", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFiletoStream", "decodeFileAsfile", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeString2File", "decodeFileTofile", "decodeFileAsStream", "decodeStringToFile", "decodeStringTofile", "decodeString2file", "decodeStringToStream", "decodeString2Files", "decodeFileToFiles", "decodeFiletoFile", "decodeFiletoFiles", "decodeFileAsFiles", "decodeFile2file", "decodeFile2Files", "decodeStringToFiles", "decodeFiletofile"], "infile": ["infp", " infiles", "inputfiles", "inputFile", "outfp", "outfilename", "inFile", " inFile", "minfp", "inputfp", "infiles", "infilename", "inputfilename", "minfilename", "minFile", "inputfile", "outfiles", "outFile", "minfile", " infilename"], "outfile": ["infp", " outfilename", "Outfull", " outfull", "outputfilename", " outfolder", "outputfolder", "outputfp", "outfp", " outFile", "outfilename", "outputFile", "Outfolder", " outfp", "outfolder", "infilename", "outputfull", "infolder", "outFile", "Outfile", "outfull", "OutFile", "outputfile"], "in": ["m", "ex", "ins", "e", "image", "In", "b", "init", "data", "this", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "cin", "i", "is", "win", "source", "reader", "rin", "inside", "a", "nin", "login", "inner", "min", "r", "ac", "bin", "err", "con", "ic", "re", "up", "pin", "ini", "as", "again"], "out": ["to", "exit", "ex", "writer", "write", "image", "copy", "In", "b", "lock", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "exp", "o", "Out", "error", "s", "conn", "home", "pass", "client", "co", "target", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "other", "up", "net", "OUT", "op", "as", "ext", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "pad", "url", "resource", "server", "length", "null", "b", "offset", "data", "Buffer", "limit", "shape", "result", "input", "split", "batch", "bytes", "row", "flush", "iter", "memory", "reader", "source", "size", "buff", "seed", "base", "queue", "slice", "address", "bin", "binary", "reference", "pause", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["k", " receive", " r", "count", " find", "reading", "fill", "pass", "ad", "send", "r", "exec", "start", "find", " send", " Read", "inc", "limit", "input", " check", "index", "Read", " write", " use", "add", "parse", "iter", " request", "skip", " reader", "x", "feed", " load", "play", "length", "sync", "check", "reads", " ride", "seek", "run", "tell", "end", "size", " reach", "ind", "id", " get", "wait", "next", " copy", " parse", "use", "open", "write", "se", "copy", " connect", "lex", "allow", "ride", "connect", "READ", "reader", "work", "load", "select", "get", "current", "sleep", " sleep", "line"], "success": ["warning", "danger", "default", "rolling", "successfully", "good", "null", "complete", "ok", "correct", "failed", "cess", "successful", "data", "func", "winner", " Success", "follow", "status", "selected", "result", "fail", "valid", "yes", "done", "error", "job", "accept", " succeed", " successful", "pass", "results", "Success", "roll", "true", " succ", "found", "initial", "safe", "continue", "rolled", "ceed", "full", "first", "response", "fast", "content", "ccess", "again", "zero", "value", "better", "construct"]}}
{"id1": "6871529", "id2": "7458833", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"readUrlFile": ["openUrlStream", "readFileFile", "readFileStream", "readURLfile", "readurlStream", "readurlFiles", "readUrlStream", "readURLStream", "openURLFile", "openURLFiles", "openUrlfile", "readUrlFiles", "openUrlFiles", "readurlFile", "readFileFiles", "readurlfile", "openURLfile", "readURLFile", "readUrlfile", "readFilefile", "openURLStream", "openUrlFile", "readURLFiles"], "fullUrl": ["rawUrl", "shorturl", "completeURL", "FullPath", "shortURL", "rawURL", "shortUrl", "FullPage", "shortPath", "fullurl", "rawPage", "FullURL", "Fullurl", "fullURL", " fullurl", " fullPage", " fullURL", "completeurl", " fullPath", "completeUrl", " fullUr", "fullUr", "rawurl", "fullPage", "completeUr", "FullUr", "completePage", "fullPath", "FullUrl"], "out": ["log", "writer", "report", "write", "image", "server", "parent", "resource", "connection", "io", "data", "inc", "raw", "output", "result", "o", "IN", "Out", "temp", "i", "source", "flush", "reader", "client", "filename", "login", "inner", "outs", "user", "cache", "string", "bin", "err", "file", "obj", "name", "w", "OUT", "content", "buffer", "again", "line"], "url": ["ls", "page", "log", "uri", "ssl", "ll", "image", "server", "resource", "b", "connection", "io", "blog", "f", "zip", "www", "URL", "bel", "xml", "source", "rl", "l", "stream", "web", "base", "user", "string", "file", "service", "up", "sl", "Url", "buffer", "http", "feed", "bb", "open", "ball", "browser"], "encoding": ["enasing", "encoder", "casing", "caching", "coded", "enoded", "Encasing", "coder", "encaching", "code", "encode", "Encode", "enoding", "enaching", "Encoded", "encoded", " encoder", "Encoder", "encasing", "coding", " encode", "Encaching", "Encoding", " encasing"], "in": ["rec", "ins", "resource", "In", "b", "body", "n", "connection", "io", "data", "inc", "part", "f", "input", "str", "din", "IN", "inn", "s", "xml", "i", "source", "win", "rin", "reader", "client", "a", "stream", "nin", "login", "inner", "r", "bin", "con", "c", "err", "file", "ini", "serv", "doc"]}}
{"id1": "20028790", "id2": "19206412", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBindingIdDefault", "setBundleIdName", "setBindingInfoPart", "setBundleDirName", "setBundleIdDefault", "setBindingInfoName", "setBundleInformationList", "setBindingIdList", "setBundleInfoList", "setBindingInfoList", "setBundleInformationName", "setBundleDirPart", "setBundleInfoDefault", "setBundleDirDefault", "setBindingInfoDefault", "setBundleIdPart", "setBundleInfoPart", "setBundleDirList", "setBundleInformationPart", "setBindingIdPart", "setBundleInformationDefault", "setBindingIdName", "setBundleIdList"], "location": ["description", "uri", "localhost", "resource", "message", "server", "loc", "remote", "database", "data", "link", "station", "folder", "area", "site", "Location", "URL", "href", "type", "xml", "selection", "library", "directory", "filename", "LOC", "l", "point", "base", "node", "position", "address", "language", "string", "layout", "file", "loader", "region", "path", "content"], "list": ["array", "we", "parent", "data", "lists", "later", "part", "sequence", "group", "range", "entry", "all", "result", "LIST", "set", "stack", "batch", "cl", "coll", "the", "see", "i", "record", "li", "keep", "l", "listed", "cli", "tree", "pair", "table", "queue", "object", "string", "load", "mentioned", "detail", "name", "chain", "there", "collection"], "url": ["uri", "fr", "resource", "ssl", "server", "b", "connection", "loc", "io", "org", "data", "socket", "f", "URL", "bel", "jar", "source", "reader", "l", "stream", "lr", "base", "user", "r", "address", "string", "orb", "file", "err", "service", "sl", "plug", "Url", "buffer", "http", "bb", "open", "browser"], "br": ["buf", "res", "bro", "fr", "arr", "b", "body", "dr", "mr", "io", "yr", "data", "bh", "bc", "result", "str", "rb", "ch", "brush", "handle", "BR", "jar", "i", "reader", "ar", "stream", "er", "ber", "bar", "tr", "r", "err", "obj", "ob", "gr", "sr", "sp", "hr", "bl", "ler", "Br", "bridge", "cr", "bb", "img", "browser"], "line": ["page", "LINE", "text", "log", "lf", "e", "le", "b", "style", "connection", "letter", "lock", "cell", "data", "link", "sync", "shell", "part", "entry", "status", "result", "zip", "rule", "str", "split", "lin", "strip", "cl", "lines", "nl", "job", "inline", "row", "band", "code", "pass", "phase", "error", "source", "parse", "section", "header", "l", "license", "lr", "look", "string", "character", "file", "Line", "name", "up", "response", "lo", "word", "lc", "non", "block"], "pos1": ["pos2", "Pos0", "indexOne", "pos3", "POSN", "posOne", "POSOne", " posOne", "POS3", "Pos1", "Pos2", "POS1", "PosOne", "position2", "position0", " posN", "position3", "posN", "index0", "positionOne", " pos2", "index1", "part3", "part2", "pos0", "PosN", " pos3", "part1", "position1", "index2", "Pos3"], "bundleSymbolicName": ["bundleSymbolicKey", "bundleSyMBicalName", "bundleSymbriticalName", "bundleSymbicInfo", "bundleSymbillyName", "bundleSymbicallyname", "bundleSyMBolicName", "bundleSymbicModule", "bundleSymbicallyWord", "bundleSysembolicname", "bundleSymbillyInfo", "bundleSymbicalModule", "bundleSymbolicModule", "bundleSymbriticalWord", "bundleSymbuousWord", "bundleSyMBicalPart", "bundleSymbicalPath", "bundleSysembuousUrl", "bundleSymbicallyUrl", "bundleSymbicName", "bundleSyembolicInfo", "bundleSyembicKey", "bundleSymbuousUrl", "bundleSymbularPart", "bundleSymbicalKey", "bundleSysembolicUrl", "bundleSymbicalInfo", "bundleSymbuousName", "bundleSymbularPath", "bundleSymbuousname", "bundleSymbillyModule", "bundleSymbularString", "bundleSymbigiousName", "bundleSymbolicString", "bundleSymbicKey", "bundleSymbolicInfo", "bundleSyMBolicString", "bundleSymbolicUrl", "bundleSymbicallyName", "bundleSymbillyKey", "bundleSyembicModule", "bundleSymbularName", "bundleSymbriticalUrl", "bundleSymbicalString", "bundleSyembicName", "bundleSysembuousWord", "bundleSyMBicalPath", "bundleSyembolicName", "bundleSymbigiousPath", "bundleSymbigiousPart", "bundleSyembolicKey", "bundleSymbolicname", "bundleSymbigiousString", "bundleSymbolicPath", "bundleSyembicInfo", "bundleSysembolicWord", "bundleSyMBolicPart", "bundleSyembolicModule", "bundleSymbolicWord", "bundleSymbolicPart", "bundleSysembuousname", "bundleSyMBicalString", "bundleSymbicalName", "bundleSysembolicName", "bundleSymbicalPart", "bundleSymbriticalname", "bundleSyMBolicPath", "bundleSysembuousName"], "bundleName": ["rbundleType", "baffleInfo", "BundleName", "BendorInfo", "BpackageName", "bridgeDesc", "BundleDesc", "babiname", "bpluginName", "rbpluginname", "bendorID", "boodleID", "rbundleName", "bendorname", "BundleInfo", "bpluginInfo", "bblName", "BundleID", "bafflename", "bridgeInfo", "bpackageInfo", "bendorName", "bundleID", "bpackageName", "rbpluginName", "bblID", "BpackageDesc", "babiInfo", "BendorID", "bblname", "bendorInfo", "bundleType", "baffleType", "Bendorname", "bendorType", "rbundleInfo", "bpackageDesc", "BpackageInfo", "babiName", "Bpackagename", "Bundlename", "boodleInfo", "bundlename", "bpluginname", "bundleInfo", "boodlename", "bridgeName", "rbpluginType", "rbpluginInfo", "rbundlename", "BendorName", "bpluginType", "baffleName", "bundleDesc", "boodleName", "bridgename", "babiDesc", "bpackagename", "bblInfo"], "info": ["filter", "available", "fo", "image", "b", "Info", "off", "data", "link", "child", "part", "alias", "entry", "f", "py", "result", "check", "zip", "archive", "index", "error", "INFO", "end", "type", "key", "inf", "ignore", "tf", "i", "comment", "api", "parse", "li", "of", "base", "fw", "object", "id", "string", "gi", "handler", "file", "obj", "start", "name", "def", "extra", "by", "next", "diff", "bug", "op"]}}
{"id1": "20623709", "id2": "4686922", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"split": ["Split", "append", "copy", "build", "cmp", "init", "sync", "part", "archive", "set", "sort", "run", "process", "add", "parse", "delete", "match", "exec", "share", "start", "diff", "transfer", "format", "update", "execute", "open", "join"], "targetDirectory": ["destFile", "targetFolder", "masterPath", "currentFolder", " targetDir", "targetDatabase", "currentRoot", "TargetDatabase", "targetDir", "targetPath", "baseDirectory", "destFolder", " targetRoot", "baseDir", "TargetRoot", "TargetFile", "outputFile", "destDir", "currentDir", "TargetDir", "outputDirectory", "TargetPath", "TargetDirectory", "targetFile", "currentPath", "currentDirectory", "outputDir", " targetPath", "outputFolder", "masterDir", "TargetFolder", "destDirectory", "masterDirectory", "baseDatabase", " targetFolder", "basePath", "masterDatabase", "baseFile", " targetFile", "baseFolder", "targetRoot"], "prefix": ["prot", "padding", "uri", "unit", "resource", "txt", "append", "offset", "username", "FIX", "sequence", "folder", "index", "template", "timeout", "type", "temp", "config", "directory", "filename", "number", "base", "queue", "cache", "string", "patch", " suffix", "name", "resolution", "ix", "fix", "pre", "domain", "root", "pattern", "path", "fixed", "first", "format", "fp", "Pref"], "maxUnitBases": ["maxUnitEases", "maxUnitAliases", "maxUnitChase", "maxUnitBase", "maxunitAliases", "maxUnitEaches", "maxUnitQueases", "maxunitAliasing", "maxunitAliails", "maxUnitQueasing", "maxUnitAliase", "maxUnitAliasing", "maxUnitChues", "maxUnitAliues", "maxUnitAliails", "maxunitBaches", "maxUnitBaches", "maxUnitEails", "maxUnitPlases", "maxunitBues", "maxUnitAliaches", "maxunitBases", "maxUnitPlase", "maxunitAliaches", "maxUnitBails", "maxunitAliase", "maxunitAliues", "maxUnitPlaches", "maxunitBase", "maxUnitBues", "maxunitBasing", "maxUnitEase", "maxUnitChasing", "maxUnitQueues", "maxUnitBasing", "maxUnitPlails", "maxunitBails", "maxUnitChases", "maxUnitQuease"], "maxUnitEntries": ["maxLineEntrations", "maxUnitEnties", "maxUnitEntryry", "maxLineOrdrations", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdines", "maxUnitErries", "maxUnitEntryresses", "maxUnitIntresses", "maxunitEntries", "maxUnitEntryies", "maxUnitInties", "maxunitEnties", "maxLineEntines", "maxUnitEntines", "maxUnitEntryrys", "maxUnitOrdies", "maxunitEntrys", "maxUnitIntries", "maxLineOrdries", "maxLineEntry", "maxUnitCountries", "maxUnitAddries", "maxUnitEntry", "maxunitEntresses", "maxUnitErry", "maxUnitEntrations", "maxunitEntryresses", "maxUnitOrdrys", "maxUnitCountrations", "maxUnitEntresses", "maxUnitEntrys", "maxLineOrdry", "maxLineOrdines", "maxUnitOrdry", "maxUnitErines", "maxUnitAddures", "maxUnitOrdries", "maxUnitErrations", "maxunitEntryries", "maxUnitEntures", "maxLineEntries", "maxUnitOrdresses", "maxunitEntryies", "maxUnitOrdrations", "maxUnitCountry", "maxUnitIntrys", "maxunitEntryrys", "maxUnitEntryries", "maxUnitAddry", "maxUnitCountines"], "fis": ["forisa", "visa", "foris", "forai", " fiss", "foriss", "fisa", "Fris", "fris", "Fisc", "fai", " fIs", "Fiss", " fris", " fisa", "vai", "forIs", "fisc", "forisc", "forris", " fai", "fIs", "fiss", "vis", " fisc", "vIs", "Fis"], "fci": ["hci", "vcos", "efai", " fii", "fai", "dci", "dii", "hcos", "efco", "bis", "bco", "vai", "Fai", "vco", "Fci", "dco", "efcos", "hai", " foci", "bci", " fai", "foci", "bai", "vci", "Foci", "Fii", "Fco", "fii", "doci", "efci", "fcos", "Fis", "hco"], "fos": ["tis", "fo", "fso", "fscos", "Fos", "infos", "ifo", "Foss", "ifcos", "fsios", "infoss", "toss", "fios", " fo", " fcos", "ifios", "fsos", "tos", "infis", "ifos", "foss", "Foes", "foes", " fios", "infoes", "toes", "fcos", "Fis"], "fco": ["hgo", "dcos", "fileico", "Fbo", "Fico", " fro", "fro", "hci", " fgo", "fbo", "dro", "hcos", "filebo", "fileci", "dci", "fgo", "Fci", "dco", "fico", " fico", "fileco", " fbo", "lro", "lgo", " fcos", "lcos", "lco", "Fco", "fcos", "lci", "hco"], "buffer": ["border", "buf", "request", "pad", "writer", "resource", "message", "server", "image", "length", "copy", "null", "offset", "view", "info", "data", "scale", "Buffer", "bc", "channel", "entry", "document", "result", "input", "translation", "batch", "read", "timeout", "texture", "comment", "iter", "memory", "reader", "flush", "size", "header", "source", "buff", "expression", "capacity", "base", "bar", "queue", "position", "cache", "counter", "bin", "window", "loader", "binary", "reference", "device", "pause", "layer", "response", "uffer", "transfer", "context", "zero", "feed", "block", "callback", "rate"], "currentBasesCount": ["currentBasescount", "currentBasesNum", "currentBatchescount", "currentChasesCounter", "currentChasesNum", "currentBatchesCounter", "currentChasesCount", "currentBaseCount", "currentBaseCounter", "currentChasecount", "currentBasesCounter", "currentBasingCounter", "currentBasecount", "currentBasingNum", "currentChasescount", "currentBatchesCount", "currentBaseNum", "currentBatchesNum", "currentChaseCounter", "currentBasingcount", "currentChaseNum", "currentBasingCount", "currentChaseCount"], "currentEntriesCount": ["currentEntursOffset", "currentEntriesOffset", "currentEntursLimit", "currentAddriesOffset", "currentEntriesSize", "currentEnturesOffset", "currentEntrasCount", "currentEntursCount", "currentEntrasLimit", "currentAddriesLimit", "currentAdduresCount", "currentEnturesCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresSize", "currentEntrasSize", "currentAdduresLimit", "currentEntursSize", "currentEnturesSize", "currentEnturesLimit", "currentAddriesSize", "currentEntriesLimit", "currentAddriesCount"], "targetCount": ["targetSum", "patternSize", "targetcount", "patternCount", "TargetSize", "TargetSum", "argetSum", "argetcount", "patterncount", "Targetcount", "patternSum", "argetSize", "TargetCount", "argetCount", "targetSize"], "fastaChannel": ["fastasChannel", "fastasContext", "fastaqBuffer", "fastasContainer", "fastanContext", "fastasConnection", " fastaContext", " fastABuffer", "fastaqConnection", "fastaConnection", "fastasBuffer", "fastAConnection", "fastaqColumn", " fastAColumn", "fastaqChannel", "fastaContainer", "fastanBuffer", "fastABuffer", " fastAConnection", "fastaColumn", "fastAContext", " fastaConnection", "fastAChannel", " fastAChannel", " fastaColumn", "fastAContainer", " fastAContext", " fastAContainer", " fastaContainer", "fastanChannel", "fastasColumn", "fastanContainer", "fastaContext", "fastAColumn"], "totalSeqCount": ["totalSeqCounter", "totalQueqCount", "totalQueQNum", "totalSeuxNum", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQCounter", "totalSeQcount", "totalQueQCounter", "totalQueqcount", "totalQueqNum", "totalSeuxcount", "totalSeuxCount", "totalQueqCounter", "totalSeuxCounter", "totalSeqNum", "totalSeQNum", "totalSeqsCount", "totalSeqsNum", "totalQueQCount", "totalSeqscount"], "totalResiduesCount": ["totalResiduingNum", "totalResiduesSize", "totalResiduescount", "totalResqueuesNum", "totalResiduingCount", "totalResqueuescount", "totalResqueuresNum", "totalResiduationSize", "totalResqueurescount", "totalResiduationNum", "totalResiduresNum", "totalResiduationCount", "totalResiduationcount", "totalResiduingcount", "totalResqueuresSize", "totalResidurescount", "totalResiduresCount", "totalResiduesNum", "totalResqueuesSize", "totalResqueuresCount", "totalResqueuesCount", "totalResiduingSize", "totalResiduresSize"], "prevTime": ["PrevSize", "PrevValue", "commitSize", "commitFile", " prevSize", "PrevTime", "commitValue", " prevFile", "PrevFile", "prevFile", "commitTime", "prevValue", " prevValue", "prevSize"], "fastaFileSize": ["fastaBlockLength", "fastaBlockCount", "fastaPageAddress", "fastABufferAddress", "fastAFileSize", "fastaHeaderLength", "fastasFileSize", "fastAFileLength", "fastaLineCount", "fastAFileAddress", "fastaHeaderAddress", "fastAFileCount", "fastABufferLength", "fastaBlockSize", "fastaFilesLength", "fastaBufferSize", "fastaFileAddress", "fastasFileAddress", "fastaHeaderName", "fastasHeaderSize", "fastaHeaderSize", "fastaPageName", "fastaLineLength", "fastaFileName", "fastaBufferAddress", "fastaBlockAddress", "fastaFilesSize", "fastasHeaderLength", "fastaLineAddress", "fastasHeaderAddress", "fastaLineSize", "fastABufferSize", "fastABufferCount", "fastaFilesName", "fastasFileLength", "fastaBufferCount", "fastaFileLength", "fastaPageSize", "fastasHeaderName", "fastaBufferLength", "fastaFilesAddress", "fastasFileName", "fastaPageLength", "fastaFileCount"], "fastaFileReadOffset": ["fastaFileWriteAmount", "fastaFileRunEntry", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaFileWriteoffset", "fastaFileLoadAmount", "fastaBufferReadOffset", "fastaBufferReadoffset", "fastaFilesWriteLength", "fastaFileStartOff", "fastaFileRunoffset", "fastaFileReadoffset", "fastaFileReadLength", "fastaFileLengthLength", "fastaFilesReadoffset", "fastaFileWriteEntry", "fastaFilesReadOffset", "fastaFileLoadoffset", "fastaBufferReadAmount", "fastaBufferWriteOffset", "fastaFileReadOff", "fastaBufferWriteoffset", "fastaFileWriteOff", "fastaDirectoryReadEntry", "fastaFilesReadLength", "fastaFilesWriteoffset", "fastaDirectoryWriteOff", "fastaFileRunOff", "fastaBufferReadLength", "fastaFileLengthOffset", "fastaFileWriteOffset", "fastaFilereadoffset", "fastaFilereadLength", "fastaFileLoadOffset", "fastaFilesWriteOff", "fastaFileWriteLength", "fastaFileStartoffset", "fastaDirectoryWriteEntry", "fastaFileStartOffset", "fastaFileReadAmount", "fastaDirectoryReadoffset", "fastaDirectoryReadOff", "fastaFilereadOffset", "fastaFileLengthoffset", "fastaFileLoadLength", "fastaFileRunOffset", "fastaFilesReadOff", "fastaFileReadEntry", "fastaFilesWriteOffset", "fastaDirectoryWriteoffset", "fastaFileLengthOff", "fastaFileStartEntry", "fastaBufferWriteAmount", "fastaFileLengthAmount", "fastaFilereadOff", "fastaBufferWriteLength"], "partitionStartOffset": ["partitionsStartRange", "partitionEndOff", "partitionBufferOff", "partitionStartOff", "partitionsStartOrder", "partitionsEndOff", "partitionStopRange", "partitionBufferOrder", "partitionEndRange", "partitionsEndRange", "partitionsStartOffset", "partitionStopOrder", "partitionBufferRange", "partitionEndOrder", "partitionStopOff", "partitionStartOrder", "partitionStartRange", "partitionsEndOffset", "partitionsStartOff", "partitionBufferOffset", "partitionStopOffset", "partitionsEndOrder"], "bufferSize": ["BufferC", " bufferSIZE", "bufferC", "processC", "BufferSIZE", "processSIZE", "queueSize", "bufferType", "BufferSize", "BufferCount", "BufferType", " bufferCount", "bufferSIZE", "bufferCount", "processType", "queueCount", " bufferType", "processSize", " bufferC"], "fastaBuffer": ["fastasChannel", "FastaBuff", " fastABuff", " fastaBuff", "fastasContainer", "fastasPtr", "fastaaPtr", "fastanFile", "FastasPtr", "FastaStream", "fastAQueue", "fastasFile", "FastaBuffer", " fastasChannel", "fastaQueue", " fastABuffer", "fastaFile", " fastaFile", "fastaStream", "fastAFile", "fastaaBuff", "fastasBuffer", "FastasChannel", "fastanPtr", " fastAQueue", "fastanQueue", "fastaPtr", " fastAFile", "fastaceBuff", "fastaceChannel", "fastaContainer", "fastaaBuffer", "FastaPtr", "fastanBuffer", "FastasBuff", "fastABuffer", "fastasStream", "FastasBuffer", "fastAPtr", " fastasFile", " fastasContainer", "fastAChannel", " fastAChannel", "fastanStream", "fastasBuff", "fastaceBuffer", " fastasBuffer", "fastAContainer", "fastasQueue", "FastasStream", "fastaBuff", " fastaContainer", "fastanChannel", "fastABuff", "fastanBuff", "FastaChannel", "fastaaStream", "fastanContainer", "fastacePtr", " fastaQueue"], "fastaReadState": ["fastasReadstate", "fastasReaderState", "fastaReaderstate", "fastasReaderMode", "fastaReadstate", "fastaReadingState", "fastaReaderState", "fastaReadMode", "fastasReadType", "fastaFileMode", "fastasReadMode", "fastaFileState", "fastaReadingType", "fastasReaderType", "fastaReadType", "fastaReaderMode", "fastasReadState", "fastaFileType", "fastaFilestate", "fastaReaderType", "fastasReaderstate", "fastaReadingstate", "fastaReadingMode"], "nBytes": ["nFrames", " nParts", "obytes", "pbytes", "numFrames", "nFiles", " nFiles", "oParts", "pBytes", "numBytes", "NBytes", "oBytes", "NParts", " nbytes", "lenFrames", "lenbytes", "oFiles", "NByte", " nFrames", "pParts", "Nbytes", "lenFiles", "pByte", "nByte", "nbytes", " nByte", "NFiles", "nParts", "numbytes", "lenBytes", "numFiles"]}}
{"id1": "3024992", "id2": "12766394", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter_writers", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_null_", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter2nullIn", "testCopy_readerToWriter_std_", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter_stds", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_writer_", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2null_", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_nullin"], "baout": ["baouter", "bonash", " baOut", "BAout", "BAOut", "BaOUT", "Baout", "baouts", " baouts", "aeouter", "BAio", "Bain", "aeout", "baio", "bonout", "Baouter", "bain", "bonin", "Baash", "baOut", " bain", "BAash", "BAouter", "BAOUT", "baOUT", "aeOUT", "bonio", "baash", "Baio", "Baouts", "BAouts", "BaOut", "BAin", "aeOut"], "out": ["array", "flow", "write", "copy", "null", "able", "io", "outer", "in", "output", "Writer", "Out", "test", "s", "class", "Output", "reader", "er", "outs", "r", "file", "err", "OUT", "buffer", "line"], "writer": ["ee", "unit", "write", "copy", "null", "letter", "io", "outer", "data", "writing", "writ", "output", "in", "entry", "her", "Writer", "wer", "player", "temp", "rw", "class", "builder", "driver", "reader", "source", "riter", "work", "er", "worker", "r", "wa", "file", "w", "writers", "pointer", "x", "buffer", "RW"]}}
{"id1": "14001795", "id2": "18613870", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverwarPath", "copyOverwarfile", "copyoverwarfile", "copyoverwarFile", "copyOverWarfile", "copyOverwarPath", "copyOverWarPath", "copyOverWARPath", "copyoverWarfile", "copyOverWebfile", "copyOverWebFiles", "copyOverWebFile", "copyOverWARfile", "copyOverWARFiles", "copyOverWarFiles", "copyoverwarFiles", "copyOverWebPath", "copyoverWarFiles", "copyoverWarPath", "copyOverwarFile", "copyoverWarFile", "copyOverWARFile", "copyOverwarFiles"], "dir": ["fd", "doc", "log", "direction", "http", "url", "parent", "build", "dr", "loc", "manager", "lock", "DIR", "data", "md", "store", "part", "folder", "group", " directory", "zip", "d", "coll", "draft", "wd", "cur", "download", "handle", "plugin", "pkg", "class", "config", "directory", "keep", "work", "di", "db", "r", "local", "cache", "desc", "ir", "handler", "file", "dist", "window", "dc", "def", "direct", "up", "dn", "clean", "Dir", "director", "feed", "lib", "df"], "ff": ["fd", "buf", "uf", "fl", "lf", "flow", "sf", "ffe", "fed", "fox", "fb", "ph", "fff", "xff", "dd", "fp", "now", "cpp", "cl", "eff", "cb", "rf", "bf", "uff", "bd", "ffff", "upp", " buff", "TF", "buff", "iff", "ft", "fw", "fx", "fam", "eph", "fold", "FF", "aff", "cf", "ef", "fe", "pp", "feed", "bb", "df"], "files": ["ls", "keys", "fl", "rows", "users", "ps", "jobs", "data", "ums", "sections", "apps", "bs", "groups", "features", "fa", "plugins", "split", "classes", "lines", "balls", "fs", "s", "flows", "objects", "results", "images", "pages", "names", "models", "file", "locks", "iles", "blocks", "Files", "events", "fe", "items"], "f": ["fd", "fn", "fl", " file", "fr", "lf", "e", "sf", "n", "flat", "info", "fb", "part", "fa", "d", "feed", "fs", "tf", "rf", "inf", "bf", "i", "filename", "l", "of", " fa", "v", "handler", "c", "file", "fold", "name", "fc", "t", "fen", "aff", "cf", "F", "x", "fe", "fp", "p"], "newFile": ["existingLine", "NewFolder", " newLine", "NewFile", "NewFiles", "nextFile", "oldFile", "updateLine", "newFolder", "oldFiles", " newDir", "newfile", "smallfile", "smallFile", "newF", "updatefile", "existingF", "nextFiles", " newFolder", " newfile", "andfile", "nextFolder", " newFiles", "andFile", "NewF", "NewDir", "nextDir", "newLine", "existingfile", "smallDir", "oldDir", " newF", "andDir", "newFiles", "newDir", "updateFile", "oldF", "updateF", "existingFile"], "fi": ["ifa", "fr", "lf", "fin", "sf", "ico", "isi", "ffe", "wi", "uci", "sci", "info", "Fi", "shi", "fb", "si", "ife", "py", "flo", "fa", "fs", "abi", "i", "ifi", "pi", "xi", "fw", "cci", "afe", "fine", "FI", "fc", "fy", "zi", "cf", "ini", "ii", "bi", "afi", "fe", "fp", "qi"], "fo": ["ato", "wo", "FO", "uf", "sf", "ico", "ki", "os", "xf", "io", "info", "shi", "mo", "si", "tto", "osa", "ni", "obi", "flo", "so", "fa", "o", "olo", "ko", "bo", "inf", "ho", "di", "zo", "co", "fw", "po", "afe", "oo", "cf", "lo", "afi", "fe", "obo", "ofi"]}}
{"id1": "19113613", "id2": "22022715", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 0, "substitutes": {"copy": ["replace", "save", "rm", "write", " cp", "cp", "sync", "zip", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "Copy", "create", "delete", "change", "load", "share", "upload", "get", "ssh", "transfer", "Cop", "put", "update", "p", "opy", "cop"], "in": ["ins", "url", "image", "In", "n", "connection", "init", "thin", "data", "this", "project", "inc", "old", "part", "f", "input", "din", "IN", "inn", "lin", "index", "plugin", "cin", "i", "kin", "win", "reader", "sin", "config", "inside", "client", "work", "a", "login", "inner", "base", "min", "id", "token", "bin", "c", "ic", "name", "diff", "pin", "get", "ini", "as", "again", "update", "on"], "out": ["at", "page", "ex", "vert", "one", "image", "resource", "call", "parent", "b", "null", "n", "connection", "remote", "init", "io", "off", "outer", "dot", "project", "this", "version", "outside", "inc", "external", "part", "output", "no", "group", "input", "block", "o", "Out", "conn", "with", "client", "self", "work", "base", "outs", "point", "user", "object", "app", "cache", "exec", "bin", "c", "v", "err", "obj", "option", "name", "net", "goal", "OUT", "up", "root", "other", "path", "x", "again", "line", "p", "ext"], "source": ["prefix", "proxy", "pe", "component", "attribute", "direction", "subject", "secret", "url", "uri", "unit", "resource", "parent", "dest", "scope", "view", "ce", "username", "project", "status", "Source", "site", "route", "family", "missing", "type", "sin", "iter", "class", "src", "size", "base", "feature", "alt", "internal", "position", "id", "ource", "name", "origin", "service", "reference", "SOURCE", "format", "secure", "force", "use", "from"], "target": ["prefix", "component", "direction", "url", "resource", "parent", "master", "dest", "null", "project", "output", "alias", "site", "route", "about", "template", "home", "cat", "top", "config", "src", "Target", "alt", "base", "point", "wrong", "address", "token", "arget", "detail", "name", "origin", "service", "reference", "root", "pattern", "host", "next", "goal", "path", "current", "value", "tail", "format", "force"], "files": ["ls", "keys", "ions", "ins", "links", "users", "obs", "jobs", "data", "assets", "f", "sections", "apps", "groups", "plugins", "features", "classes", "lines", "fs", "s", "children", "flows", "objects", "results", "docs", "tools", "images", "filename", "ports", "pages", "resources", "names", "models", "cells", "iles", "blocks", "Files", "items"], "file": ["page", "FILE", "url", "e", "resource", "ile", "uri", "parent", "le", "b", "unit", "letter", "item", "data", "single", "child", "part", "folder", "entry", "f", "it", "feed", "live", "el", "fe", "future", "dir", "directory", "filename", "l", "base", "object", "id", "local", "string", "load", "name", "entity", "binary", "per", "File", "layer", "path", "function", "current", " File", "line", "fp", "lib"], "inCh": ["InChan", "INChannel", "inCH", "InChannel", "INCH", "inch", "inChan", "outCH", " inch", "InCH", " inChan", " inCH", "outch", "Inch", "InCh", "outChan", "outChannel", " inChannel", "INChan", "inChannel", "INCh"], "outCh": ["Outch", "OutChan", "OutCH", "inCH", " outChannel", "inch", " outch", "inChan", "outCH", "OutChannel", "outputCh", "outch", "outputChan", "outChan", " outCH", "outChannel", "outputCH", "inChannel", "OutCh", "outputch"]}}
{"id1": "3046085", "id2": "4398382", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "label": 1, "substitutes": {"s": ["m", "sample", "text", "south", "e", "b", "g", "n", "ss", "data", "parts", "ns", "in", "sb", "f", "es", "str", "sets", "i", "is", "source", "a", "speech", "r", "ses", "S", "joined", "string", "v", "sound", "params", "name", "t", "w", "path", "gs", "content", "services", "strings", "p"], "tokenizer": ["tooliner", "loginer", "okenzer", "statator", "statizers", " tokenizers", "Tokenizable", "initialization", "tokenizers", "toolizer", "generized", "Tokenener", "tokenzer", "tokenner", "tokeniner", "optimizable", "generiser", " tokenener", "okener", "normalize", "tokenizable", " tokenized", "okeniner", "tuner", "initialize", "okenizers", "generizer", " tokenner", "widgetizer", "tokeniser", "logize", " tokenize", "okenator", "okeniser", " tokeniser", "logizable", "okenner", "widgetiser", " tokenizable", "finizable", "toolize", " tokener", "tokenener", "finer", "optimizer", "okenizable", "okenener", " tokenister", "optimiser", "tokener", " tokenization", "normaliner", "tokenization", "initialiner", "tunner", "tunizer", "statiter", "Tokener", "normalizable", "tunzer", "Tokeniser", "Tokenized", "initializer", "okenize", "finizer", "normalizer", "tokenator", "initializable", "initialiser", "okeniter", "tokeniter", "tokenister", "statizer", " tokenator", "Tokenister", "optiminer", "Tokenizer", "okenizer", "Tokeniner", "tokenized", "Tokenize", "widgetizable", "okenization", "okenister", "widgetiner", "generize", "finize", "logizer", " tokenzer", " tokeniter", "toolizable", "tokenize", "Tokenizers"], "title": ["art", "prefix", "description", "text", "url", "resource", "summary", "tag", "profile", "data", "music", "username", "audio", "editor", "meta", "type", "song", "source", "metadata", "theme", "media", "filename", "license", "album", "genre", "company", "string", "Title", "name", "owner", "bot", "layer", "author", "format", "label", "team"], "artist": ["art", "prefix", "photo", "image", "master", "tag", "music", "piece", "username", "winner", "season", "alias", "audio", "creator", "archive", "player", "song", " artists", "chart", "theme", "metadata", "source", "media", "Artist", "filename", "target", "album", "track", "genre", "video", "patch", "layer", "episode", "cover", "voice", "author"], "location": ["description", "mobile", "photo", "url", "message", "image", "length", "loc", "tag", "motion", "audio", "area", "Location", "time", "gallery", "theme", "media", "album", "position", "address", "layout", "language", "region", "layer", "path", "content", "level", "lang"], "rating": ["description", "padding", "tracking", "style", "training", "fps", "ranking", "weight", "random", "season", "audio", "breaking", "score", "live", "sharing", "rising", "media", "album", "genre", "scoring", "boarding", "repeat", "alpha", "resolution", "rank", "playing", "rate", "game"], "overplay": ["overload", "opledge", "oplay", "offplay", "reload", "overlay", "offlay", "reledge", "overledge", "opplay", "offload", "offledge", "opload", "replay", "relay"], "temp": ["font", "prefix", "partial", "original", "txt", "unit", "message", "style", "body", "loc", "tc", "flat", "tag", "music", "data", "empty", "part", "Temp", "sequence", "pt", "str", "template", "test", "type", "source", "tmp", "media", "track", "base", "stable", "cache", "layout", "string", "name", "list", " tmp", "fake", "path", "current", "content", "format", " temporary", "testing", "emp", "stage"], "tags": ["notes", "fields", "tracks", "archives", "products", "modules", "users", "stats", "relations", "reports", "dates", "assets", "bots", "terms", "plugins", "sections", "features", "comments", "videos", "stars", "thumbnails", "images", "properties", "Tags", "packages", "files", "resources", "ids", "names", "tests", "bugs", "types", "words", "authors", "events", "phones", "strings", "styles"], "bytes": ["notes", "values", "keys", "gets", "Bytes", "body", "letters", "data", "parts", "es", "comments", "videos", "lines", "ips", "seconds", "objects", "tes", "size", "les", "pieces", "units", "files", "outs", "pages", "bits", "articles", "fee", "errors", "codes", "params", "blocks", "words", "strings", "balls", "bps"], "hasher": ["haer", "hadest", "hahers", "haveher", " hashers", "Hashers", "haveumper", "hadher", "haser", "hadumper", "Hashed", "Hasher", "haveest", "hanest", "hadhandler", "hashumper", "hashed", "hashhandler", "havehandler", "hasumper", "hashr", " hasest", "hashers", "hasest", "Hasest", "hashher", "hashandler", " haser", "haest", "hanher", " hashed", "haher", "havehr", " hashr", "hanhr", "haner", "hashest", "Haser", "hahed", "haveer"]}}
{"id1": "10383721", "id2": "11334468", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processENTriers", "processENTris", "processEllrings", "processDistriers", "runENTris", "processEntriers", "processENTrys", "runEntriers", "processENTrings", "processEntrings", "runEntris", "processEntris", "runENTrys", "runENTriers", "runEntrys", "processDistrys", "runEntrings", "processEllriers", "processEllrys", "processDistrings", "processDistris", "processEllris", "runENTrings"], "urlStr": ["httpString", "httpSTR", "urlSt", " urlString", "UrlStr", "resourcestr", "httpstr", "fileStr", "uriString", "Urlstr", "URLStr", "URLString", "urlstr", " urlSt", "filestr", " urlstr", "fileSTR", " urlSTR", "uriStr", "resourceString", "urlSTR", "URLSTR", "httpStr", "resourceSTR", "URLSt", "uriSTR", "resourceStr", "UrlSTR", "urlString", "uriSt"], "currentFlag": [" currentBit", "nextTag", "reportedField", "activeFlag", "CurrentTag", "Currentflag", " currentField", "nextFlag", "currentText", "CurrentFLAG", "reportedFlag", "CurrentField", "nextflag", "activeTag", "currentTag", "CurrentFlag", "nextFLAG", "currentflag", "currentField", "activeFLAG", "currentBit", "CurrentBit", "reportedText", "activeflag", "reportedBit", "currentFLAG", "CurrentText", " currentText"], "key": ["k", "prefix", "text", "keys", "kid", "message", "lease", "parent", "scope", "lock", "Key", "here", "ey", "method", "data", "empty", "msg", "step", "ie", "part", "search", "field", "entry", "rule", "check", "str", "exp", "hash", "ace", "type", "section", "seed", "point", "base", "mac", "sign", "id", "cache", "match", "string", "fee", "name", "list", "service", "fix", "full", "function", "path", "query", "roy", "or", "value", "secret", "KEY", "ry"], "postList": ["POSTGroup", "POSTlist", " postCollection", "postlist", "postGroup", " postGroup", "PostCollection", "PostGroup", "POSTList", "PostList", "postCollection", "Postlist", "POSTCollection", " postlist"], "url": ["ur", "page", "text", "proxy", "log", "uri", "ssl", "resource", "image", "server", "build", "loc", "org", "data", "link", "socket", "director", "channel", "entry", "www", "URL", "conn", "client", "l", "web", "base", "address", "cache", "string", "file", "service", "sl", "host", "path", "Url", "location", "http", "feed"], "connection": ["to", "proxy", "writer", "uri", "resource", "server", "communication", "b", "body", "remote", "io", "version", "socket", "director", "channel", "Connection", "application", "document", "creator", "connect", "URL", "password", "out", "conn", "connected", "config", "client", "section", "directory", "l", "number", "position", "object", "character", "con", "c", "handler", "machine", "relation", "function", "response", "wrapper", "condition", " Connection", "collection", "http", "open", "database"], "reader": ["writer", "resource", "server", "body", "io", "data", "parser", "reading", "channel", "entry", "f", "document", "Reader", "input", "editor", "read", "row", "xml", "iter", "driver", "client", "stream", "er", "r", "handler", "file", "loader", "per", "ler", "buffer", "oder", "feed"], "builder": ["writer", "default", "image", "build", "b", "manager", "info", "Builder", "parser", "building", "document", "entry", "result", "creator", "editor", "bean", "row", "xml", "driver", "config", "client", "er", "db", "base", "r", "loader", "builders", "bug", "runner", "wrapper", "or", "buffer", "bridge", "http", "keeper", "database"], "doc": ["text", "gen", "writer", "resource", "html", "build", "body", "dr", "info", "data", "project", "md", "parser", "document", "f", "str", "d", "coll", "graph", "docs", "xml", "doctor", "dir", "Doc", "db", "tree", "base", "ger", "node", "r", "div", "file", "app", "dc", "lib", "bug", "context", "git", "open", "df"], "root": ["rec", "component", "rss", "writer", "default", "parent", "null", "scope", "html", "data", "entry", "ver", "r", "div", "string", "bot", "query", "front", "owner", "right", "page", "server", "remote", "empty", "leaf", "back", "parser", "result", "error", "element", "xml", "record", "article", "tree", "loader", "path", "Root", "master", "outer", "sys", "creator", "archive", "comment", "ree", "top", "section", "db", "user", "node", "cover", "first", "zero", "http", "manager", "director", "rt", "nav", "n", "body", "project", "child", "rup", "document", "valid", "container", "home", "rew", "inner", "name", "author", "head", "roots", "box"], "grNamespace": ["grNamespaces", "grMembersche", "grnamespaced", "grnamespaces", "grMemberspace", "GrNamespaces", "grnamesche", "Grnamespaces", "GrNamescape", "Grnamescape", "GrNamesche", "grnamespace", "Grnamespe", "grMemberspaced", "GrNamespaced", "grNamesche", "grMemberspaces", "Grnamespace", "grNamescape", "grNamespe", "grnamespe", "GrNamespe", "GrNamespace", "grnamescape", "grNamespaced"], "namespace": ["Namescape", " Namespec", "membersternal", "namesspace", "technpace", "namespaced", " namespaced", "kesase", "memberspace", " namescore", " Namespace", " Namespaces", "inasternal", " Namespaced", " namesace", "Namesception", "New", "namesase", "kespace", "Namesace", "_", "inasace", "this", "namepace", "xml", "add", "inasspace", " namespaces", "Namespace", "Namespaced", " namesase", "inaspace", "Namescore", "feed", "workspect", "worksception", "nameception", "s", "namespaces", "Namesase", "namesception", "namepaces", "Namespec", " namesternal", "membersspace", "Namesspace", "namescape", "namespec", "technspace", "http", "workspace", "namespect", "kespaced", " namesception", "memberscape", "namesternal", "memberscore", "namesace", " namescape", "Namespaces", " namespect", "nameternal", "Namespect", "namescore", " namespec", "workspaces", "Namesternal", "membersace", " namesspace", "memberspaces", "namecape"], "newflag": ["nextflag", " newstyle", "nextStatus", "lnStatus", "newFlag", "newstyle", "nextFlag", " newFlag", "lnstyle", " newStatus", "nextstyle", "newStatus", "lnFlag", "lnflag"], "title": ["text", "description", "subject", "message", "resource", "itle", "html", "details", "body", "term", "summary", "version", "itles", "template", "type", "Content", "header", "filename", "license", "Title", "name", "format", "author", "label", "published"], "subTitle": ["ubtitle", "ubDescription", "subDescription", "subtitle", "ubName", "SubTitle", "SubName", "SubDescription", "Subtitle", " subtitle", " subDescription", "subName", "ubTitle", " subName"], "entryList": ["entrylist", "elementlist", " entrylist", " entryChain", "tryChain", " entryLIST", "elementQueue", "tryQueue", " entryQueue", "zipL", " entryL", "entryQueue", "zipList", "entryChain", "zipLIST", "elementChain", "elementList", "postLIST", "tryList", "ziplist", "entryL", "entryLIST", "postlist", "trylist", "postL"], "sdf": ["Sfd", "Sdf", "ssdf", "ssde", "psdf", " sde", "psdd", "pscf", "ascf", "rsdd", "scf", "asdd", " sdd", "rsde", " scf", "ssfd", "asdf", "sde", "asde", "sdd", "ssdd", "rsdf", "Sde", "rsfd", "psde", "Sdd", "sfd"], "e": ["ve", "m", "enter", "ee", "esi", "one", "j", "se", "le", "n", "en", "Element", "ce", "event", "ge", "je", "ie", "ec", "pse", "entry", "f", "oe", "edge", "ele", "o", "d", "ae", "end", "me", "el", "element", " pe", " ie", "te", "ze", " entity", "y", "i", "ne", "l", "er", "E", "eu", "node", "r", "de", "c", "be", "entity", "t", "ente", " event", "ea", "ed", " me", " E", "eb", "line", "p", " element"], "post": ["ost", "page", "text", "default", "install", "one", "server", "copy", "POST", "style", "system", "form", "project", "child", "link", "part", "entry", "draw", "result", "check", "Post", "cross", "archive", "set", "valid", "index", "read", "the", "row", "home", "pass", "posts", "comment", "add", "create", "article", "push", "record", "posted", "wp", "edit", "pod", "user", "node", "tax", "object", "load", "patch", "upload", "list", "maybe", "pre", "next", "op", "get", "author", "mod", "head", "feed", "p"], "content": ["page", "text", "description", "resource", "message", "image", "script", "body", "summary", "data", "version", "output", "status", "archive", "comments", "draft", "template", "Content", "code", "source", "header", "media", "size", "language", "file", "name", "path", "value"]}}
{"id1": "4602568", "id2": "17792212", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"storeImage": ["processVideo", " storeVideo", " transferImage", " transferVideo", "storeIcon", "processMedia", "storeVideo", " storeIcon", "processIcon", "storeMedia", " storeMedia", " transferIcon", " transferMedia", "processImage"], "inStream": [" inReader", "inSteam", "inputSteam", " inPath", "inReader", "INStream", "inputCh", " inVideo", "inPath", "instream", "inputReader", " inSteam", "INPath", "winStream", "winVideo", "inCh", "inputStream", " inCh", "inputVideo", "INstream", "inVideo", "winReader", "inputstream", " instream", "winSteam", "inputPath", "INCh"], "fileName": ["FILENode", "FILEPath", "httpPath", " filePart", "FILEName", "filePath", " filePath", "fileNode", "resourcename", " fileNames", "FileNames", "httpPart", "resourceName", "imageName", "FilePart", "FILEInstance", "resourceNode", " fileInstance", "fileInfo", "filename", "imageNames", " fileNode", " fileInfo", "httpname", "Filename", "httpName", "FileInfo", "FilePath", "FileInstance", " filename", "FILEInfo", "imagePath", "FILEname", "FileName", "filePart", "imagename", "resourceInfo", "fileNames", "fileInstance"], "resize": ["resized", " Resizes", "Resize", " resizer", "Resizer", "resizer", " resizes", "Resizes", " Resized", "resizes", " resized", "Resized", " Resizer", " Resize"], "rightNow": ["dayToday", "rightThen", "thirdNow", "thirdNOW", "dayNow", "Rightnow", "straightAccount", "dayCurrent", "RightToday", "thirdThen", "rightAccount", "thirdnow", " rightToday", "RightCurrent", " rightCurrent", "RightAccount", "rightToday", " rightAccount", "rightCurrent", "rightNOW", "rightnow", "straightToday", " rightnow", "straightnow", "thirdToday", "RightNOW", "thirdCurrent", "straightNow", "RightNow", "dayNOW", " rightThen", " rightNOW"], "dayNamedFolderName": ["dayNestedDirectoryName", "dayNamedFoldername", "dayNamedAreaPath", "dayNamedAreaSize", "dayNamedDirectoryName", "dayNamedFilePath", "dayNamedfolderPath", "dayNnamedFolderSize", "dayNestedFolderSize", "dayNnamedFolderName", "dayNestedFolderName", "dayNamingFolderSize", "dayNamedFileName", "dayNamedFileInfo", "dayNestedDirectoryname", "dayNamedDirKey", "dayNamedDirectoryname", "dayNamedfoldername", "dayNamingFolderKey", "dayNamedfolderInfo", "dayNamedFileKey", "dayNamedFolderInfo", "dayNamedFolderKey", "dayNamingFolderName", "dayNamedDirInfo", "dayNamedfolderName", "dayNamedDirectoryPath", "dayNnamedFolderPath", "dayNestedDirectorySize", "dayNamedDirectorySize", "dayNamedAreaName", "dayNamedFolderPath", "dayNamedFileSize", "dayNestedDirectoryPath", "dayNamedAreaname", "dayNamedDirName", "dayNamedfolderSize", "dayNamingFolderInfo", "dayNnamedFolderInfo", "dayNamedFolderSize", "dayNestedFolderPath", "dayNamedDirSize", "dayNestedFoldername"], "uploadDirRoot": ["UploadDirRoot", " uploadDirroot", "inputDirHome", "uploaddirHome", "inputDirPath", "uploadDirectoryName", "UploadFolderPath", "UploadDirBase", "uploadDirectoryRoot", "uploadDirName", "uploadFolderRoot", "uploadDirectoryPath", "uploadBasePath", "uploadFileHome", "uploadDbRoot", "uploadDirPath", "uploadDirectoryHome", "uploadDbPath", " uploadFileroot", "inputDirectoryName", " uploadFileRoot", "uploadFolderBase", "uploadBaseRoot", "uploaddirroot", "uploadDirectoryBase", "inputDirectoryPath", "UploadDirPath", "uploadFolderroot", "uploadFileName", "uploadFilePath", "uploadDbHome", "uploadDbName", "inputDirRoot", "uploadFileroot", "inputDirectoryRoot", "UploadDirroot", " uploadDirHome", "UploadFolderRoot", "uploaddirRoot", "uploadDirectoryroot", "inputDirectoryHome", "UploadFolderBase", "inputDirName", "uploadDirHome", "UploadFolderroot", "uploadDirBase", "uploadBaseroot", "uploadBaseBase", "uploadDirroot", "uploadFolderPath", " uploadFileHome", "uploadFileRoot"], "file": ["book", "pe", "page", "log", "http", "url", "flow", "e", "image", "ile", "unit", "parent", "FILE", "b", "view", "connection", "force", "child", "part", "folder", "entry", "f", "model", "document", "rule", "zip", "out", "home", "class", "comment", "dir", "directory", "work", "files", "base", "user", "object", "local", "handler", "name", "service", "up", "lib", "per", "File", "full", "function", "path", "auto", "fe", "line", "fp", "p"], "extension": ["Extend", "extversion", "extend", "exion", "exdivision", "extion", "intion", "exension", "EXTversion", "exversion", "interion", "EXTdivision", "xtension", "interversion", "EXTion", "extdivision", "interdivision", "xtend", "intION", "extION", "xtION", "Extion", "Extension", "xtion", "intension", "intend", "EXTension", "ExtION", "interension"], "outFileName": ["outFolderSystem", "outPathType", " outFileLine", "outFullPath", "outLineLine", "outFieldLine", "OutFileName", "outFullName", "outPlacePath", "outLineLocation", "outfileSize", " outFilePath", "outFilePath", "outPathname", "outFileLength", "inFileInfo", "inLineInfo", "outFolderLine", "outDirLine", " outPlaceLine", "outLineName", "outFolderInfo", "outFilePart", " outFileLocation", "inFilePart", "outFullPart", "outPlacename", " outFileAddress", "outLineSize", "outFileLine", "outPlaceAddress", "OutFileInfo", "outDirName", " outPlaceLocation", "outLineKey", "outFilename", "outLineLength", "outDirKey", "outDirInfo", "OutFilePath", "inFileLine", " outFilename", "inFilePath", "OutDirPath", "outPlaceLocation", "OutDirName", "outPlaceLine", "outPathPath", "outFileAddress", "outFieldSystem", "outFieldName", "outLineInfo", "inFileKey", " outPlacePath", "outFileInfo", "inLineLine", "outfileName", " outFileType", "outfilePath", "outPlaceSystem", "outfileLocation", "outPlaceType", "inFileName", "outFileSize", " outPlaceName", "inLinePart", "outFileLocation", "outPathName", "outfileInfo", "outDirLength", "outFolderPath", "outFieldAddress", "outLineType", " outFileSize", "OutDirInfo", "outfileLength", "outLinename", " outPlaceType", "inLineKey", "outFolderAddress", "outFullKey", "outDirPath", " outPlaceSize", "outFileKey", "outDirPart", "outPlaceName", "outPlaceSize", "outFileType", " outPlacename", "outLinePath", "OutDirLength", " outPlaceAddress", " outFileSystem", "inLinePath", "outFolderName", "outLinePart", "inLineName", "OutFileLength", "outFileSystem", " outPlaceSystem"], "outPathAndName": ["outNameOrPath", "outNameOrName", "outpathOrNames", "outNameAndName", "outPathOrRam", "outpathOrPath", "outPathANDRam", "outpathOrName", "outPathAndPath", "outPathANDPath", "outPathAndAddress", "outNameAndAddress", "outPathAndname", "outPathAndTime", "outPathOrNames", "outPathANDname", "outPathAndNames", "outNameAndPath", "outPathANDAddress", "outNameOrRam", "outpathAndPath", "outpathAndTime", "outPathOrName", "outPathandPath", "outPathANDTime", "outPathOrPath", "outPathOrname", "outPathANDNames", "outpathAndNames", "outPathANDName", "outPathandNames", "outpathAndname", "outNameAndRam", "outPathAndRam", "outNameOrAddress", "outpathAndName", "outPathOrAddress", "outPathOrTime", "outPathandName"], "uploadedFile": ["uploadchedFile", "UploadedFile", "uploadatedFolder", "uploadendedF", "UploadpedFolder", "uploadratedF", "uploadratedFile", "processedfile", "uploadatedfile", "uploadedImage", "processchedfile", "UploadedFiles", "uploadpedImage", "uploadendedPath", "UploadpedFiles", "uploadratedPath", "uploadedPath", "processedF", "uploadratedfile", "uploadizedFiles", "uploadedfile", "uploadchedPath", "uploadedFull", "uploadededFull", "processchedPath", "uploadizedFile", "Uploadpedfile", "uploadenedFiles", "uploadendedFile", "uploadenedFolder", "uploadededFile", "UploadpedFull", "Uploadedfile", "processchedFile", "uploadendedfile", "uploadizedFull", "UploadedFull", "uploadatedFiles", "uploadpedFile", "processedFile", "uploadedF", "uploadedFiles", "uploadpedfile", "uploadatedFile", "uploadchedF", "uploadpedFolder", "processchedF", "uploadpedFiles", "processedPath", "UploadpedImage", "uploadenedFile", "UploadpedFile", "uploadedFolder", "UploadedImage", "uploadededFiles", "UploadedFolder", "uploadchedfile", "uploadededImage", "uploadpedFull", "uploadizedImage", "uploadenedfile"], "outStream": ["tempBuffer", "inSteam", "url", "Bytes", " outSteam", "_", "tempFile", "inBuffer", " outFile", " outBuffer", "URL", "inFile", "Directory", "s", "tempStream", "Copy", "Type", "outSteam", "New", "outFile", "Url", "outBuffer", "tempSteam", "format"]}}
{"id1": "1769771", "id2": "755203", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "CopyFiles", " copyFiles", "copyfile", "CopyChannel", " copyfile", "copyChannel", "transferfile", "transferChannel", " copyChannel", "copyFiles", "Copyfile", "transferFiles", "transferFile"], "in": ["m", "ex", "ins", "url", "image", "In", "lock", "io", "data", "inc", "f", "input", "IN", "inn", "lin", "index", "i", "source", "win", "reader", "config", "l", "work", "login", "inner", "base", "min", "id", "bin", "file", "c", "name", "diff", "pin", "query", "again"], "out": ["prefix", "ex", "writer", "default", "write", "image", "server", "plain", "call", "resource", "b", "n", "io", "off", "dot", "external", "output", "o", "Out", "conn", "target", "base", "outs", "point", "user", "cache", "string", "v", "exec", "file", "c", "name", "extra", "up", "w", "OUT", "x", "again", "p", "ext"], "inChannel": ["outClient", "outchannel", "inputChan", "inputChannel", "InStream", " inStream", "InChan", "INChannel", "insChannel", " inchannel", "inClient", "InChannel", "insChan", "inStream", "inChan", "binStream", "INStream", "inchannel", "binClient", "binchannel", "binChannel", "insStream", "winStream", "INchannel", "inputchannel", " inChan", "binChan", "outStream", "inputStream", "insClient", "winChannel", " inClient", "InClient", "outChan", "winChan", "Inchannel", "INChan", "winchannel"], "outChannel": ["outchannel", "inputChan", "inputChannel", "nChan", "nManager", "outputStream", "inConnection", "OutChan", " outManager", "outCh", "inStream", "inController", "inChan", " outChan", "outManager", "nStream", "OutConnection", "OutChannel", "inchannel", "inputchannel", "Outchannel", " outchannel", "inCh", "outputCh", "inputController", "outStream", "nChannel", "inManager", " outStream", "outputChan", "outChan", " outCh", "outController", "outputController", "outConnection", " outConnection", "outputChannel", "outputchannel"]}}
{"id1": "13757855", "id2": "19276022", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"process": ["resource", "processing", "call", "build", "view", "cess", "project", "output", "evaluate", "run", "handle", "code", "create", "parse", "construct", "transform", "load", "exec", "submit", "Process", "proc", "path", "update", "request", "processor"], "tpl": ["tper", " tml", "atml", " tplug", "lpl", " tfc", "tmyl", " tplates", "qtpl", "temPL", "tsl", "tple", "Tpp", "itplates", "lPL", "pcl", "stplate", "ttemplate", " tplate", "Ttemplate", "tPL", "Tml", "pPL", "Tpl", "Tcl", " tbl", " tPL", "templ", "tipl", "tbl", "stPL", "itPL", "latyl", "tpp", "Tipl", "qtyl", "qtple", "stpl", "tcp", "Tsl", "itplate", "tml", "tplug", "stpp", "qtfc", "tmpl", "fplate", "tplate", "Tfc", "latple", "Tplate", "atplug", " tper", " tsl", "TPL", "fpl", "qtcp", " tipl", "fml", "tmple", "templates", "Tbl", "Tper", "tyl", " ttemplate", "tplates", "atpl", "qtbl", "lple", "latpl", "tfc", "Tple", "lplate", "pipl", "ppl", " tcl", "fplug", "itpl", " tple", "latcp", "lper", "lcl", "psl", "temtemplate", " tpp", "tcl", "tmcp", "lml", "Tplates", "atplate"], "model": ["param", "m", "log", "module", "message", "copy", "Model", "conf", "body", "data", "project", "document", "result", "graph", "xml", "config", "media", "command", "node", "language", "models", "params", "json", "location", "where", "doc"], "packageName": ["contextname", "packageNames", "groupUrl", " packagename", "groupname", "groupName", "Packagename", "contextName", "packagename", "PackageNames", "projectname", "groupKey", "packageInfo", " packageNames", "moduleUrl", "packageUrl", "moduleName", "packageKey", "projectKey", "moduleKey", "projectName", "contextInfo", "projectUrl", "PackageName", "PackageInfo", "modulename", "contextNames", " packageInfo"], "outFileName": ["outDirCopy", "outDirNames", " outFileLine", " outFullType", " outDirTime", "outFullPath", "outLineLine", "outFileOnce", "outFileMode", "OUTBufferNames", "OUTBufferHalf", "inFileCopy", "outBufferHalf", "outDirname", "OutFileName", "outFullName", "outStreamInfo", "OutDirNames", " outFilePath", "outFilePath", "outFilenameEnd", "outFilenameHalf", "outDirLine", "outFilenameNames", "outFilenameMode", "difffileOnce", "outfileMode", "outLineName", "outfileTime", "OUTFileNames", " outDirLine", "OutFilename", "difffileName", " outDirPath", "OUTBufferName", "outfileHalf", "outfileCopy", "outFullLine", "outLineTime", "outFileTime", "outFileLine", "outDirName", "inDirEnd", "outFullTime", "inDirCopy", "outFilename", "OUTBufferMode", "outDirEnd", "outBufferName", "outDirInfo", "diffFileTime", "diffFileInfo", "outFilenamePath", "outFileHalf", "outStreamType", "outFileNames", "inFilePath", "outFilesTime", "OutDirName", "outStreamName", "difffileTime", "outfileOnce", "inDirName", "diffFileName", "outLineInfo", "diffFileOnce", "outBufferNames", "outFileInfo", "outfileName", "outDirTime", "outFullInfo", "outBufferMode", "outfilePath", " outFileType", "outFileCopy", " outFileInfo", "inFileName", "outLineOnce", "outRuleType", "outfileInfo", " outFullInfo", "outFilesPath", "outLineNames", "OUTFileName", "outLinename", "outFullNames", "outDirPath", "outRuleInfo", " outFileTime", "outDirOnce", "outFullname", "difffileInfo", "outFileType", "inFileEnd", "outFilesLine", "inDirPath", "OutFileNames", "OutFileLine", "OUTFileMode", "outFullType", "outFilenameCopy", "OutDirLine", " outDirName", "outFilenameName", "outfileEnd", "outFileEnd", "OUTFileHalf", "outfileNames", "OutDirname", "outRuleName", " outFullName", "outFilesName"], "xsltParam": ["xldParam", "xsldVal", "xslicMode", "xsltMode", "xltparam", "xslpparam", "xldVal", "xslpParam", "xltMode", "xldMode", "xsltparam", "xslpMode", "xsltVal", "xltVal", "xsldMode", "xslicVal", "xltParam", "xslicparam", "xsldParam", "xsldparam", "xslpVal", "xslicParam", "xldparam"], "artifact": ["ARTifact", "artifacts", "adverturation", "Artfact", "Artifact", "aratifact", "Artribution", "ARTifacts", "artfact", "Artifacts", "aratifest", " artifacts", "advertribution", "aratifacts", "arturation", "artifest", " artribution", "ARTifest", "Arturation", "aratfact", " arturation", "artribution", "advertifacts", "ARTfact", "Artifest", "advertifact"], "destinationPath": ["destinatorPath", "restificationpath", "destinationAuth", "destinatingText", "destinationContext", "destificationPath", "tempinatedpath", "destinatedPath", "distributionPath", "destinatorString", "destationLocation", "combinationName", "distinationCry", "destinatingpath", "destinatedpath", "distinatorPath", "tempinatedHalf", "destinationsPath", "destinerContext", "destinerDir", "destiningpath", "destinatingPoint", "destinatedCase", "desturationName", "destinatorName", "combinationHandler", "destinationDir", "distinationKey", "destinatorHalf", "destributionPath", "destributionCase", "destificationpath", "destignmentCase", "combinatorpath", "constinatorpath", "constinationPath", "destributionpath", " destificationLog", "DestificationName", "destinationKey", "destificationAuth", "constinationsPath", "combinatorPath", "DestificationPart", "destinationLocation", "destinationPoint", "restificationLocation", "destinatingName", "DestinatingPath", "destinatorHandler", "destensionPoint", "destinatingPath", "destinationName", "destinatePoint", " destificationAuth", "distinatorCase", "destignmentCry", "constinationpath", "destplingAuth", "destinateLocation", "distinationpath", "destinatorPoint", "destiningContext", "destationpath", "destiningDir", "restinationPoint", " destificationDir", "destinatePart", "destributionCry", "restinationpath", "destinateHalf", "DestinationPoint", "destinatorStep", "tempinationHalf", "destinatePath", "restinationPath", "desturationpath", "destinationsName", "destinatorUrl", "destignmentPath", "destinationCase", "constinationsPoint", "restinatorString", "datinationLocation", "restinatorHalf", "destificationPart", "destinatedStep", "destinationTime", "destinateHandler", "destinationsPoint", "destificationPoint", "datinatePath", "distinationStep", "destributionName", "restinatorPath", "destinationString", "destinationFile", "destificationLocation", "destcreationPath", "combinatorName", "restificationPoint", "tempinatedDir", "destificationLog", "desticationName", "destinateName", "destinerPath", "destplingWidth", "destinatorTime", "DestinatingPoint", "distinationPath", "destplingPath", "datinationPath", "distinatorKey", "destplingDir", "restinatorPoint", "destinatedString", "destinatedHalf", "desticationFile", "destinationPart", "destinateString", "destinateTime", "constinatorPath", "constinatorContext", "destiationPath", "distributionDir", " destificationPath", "desticationKey", "desticationStep", "DestinatingText", "constinationWidth", "destinatorCase", "desturationHandler", "datinateLocation", "destiningPoint", "constinationContext", "destinatorWidth", "destcreationUrl", "desticationPart", "constinatorWidth", "destignmentName", "constinationspath", "destiningName", "destationTime", "constinationDir", "destinatorLocation", "destinatedPoint", "restinationLocation", "destinationText", "constinatorDir", "destinatorFile", "destiationDir", "destinationHandler", " destinationAuth", "distinationName", "destiningPath", "combinationPath", "desticationPath", "destinatepath", "restinationString", "combinatorHandler", "destiationAuth", "destinatorKey", "destiationLog", "destinationUrl", "DestinationText", "destinationCry", "destplingLog", "destationPath", "datinateTime", "destinatingLocation", "distinatorCry", "destinatedDir", " destinationLog", "distinatorStep", "tempinatedPath", "tempinationDir", "destinationStep", "destinationWidth", "tempinationPath", "DestinationPart", "destensionPath", "destinatorContext", "destinatedKey", "DestinationName", "destensionText", "destificationName", "DestinatingName", "tempinationpath", "constinationsName", "destensionName", "distributionpath", "distributionCase", "destplingUrl", "destinatedFile", "constinationPoint", "DestificationPath", "datinationTime", "desturationPath", "destinatorCry", "destinatorDir", "destinationpath", "distinationDir", "distinatorName", "restinationHalf", "destinateText", "constinatorUrl", "datinationpath", "datinatepath", "destificationDir", "constinationUrl", "distinatorFile", "destcreationWidth", "destinerpath", "destinationspath", "destinateDir", "destinationHalf", "restificationPath", "distinationFile", "destinatorpath", "destributionDir", "distinationCase", "destinationLog", " destinationDir", "combinationpath", "DestinationPath", "constinationName"], "in": ["ex", "ins", "image", "In", "n", "connection", "data", "inc", "input", "din", "IN", "d", "i", "source", "reader", "config", "min", "r", "cache", "con", "bin", "c", "name", "t", "x", "doc"], "out": ["prefix", "page", "ex", "gen", "writer", "log", "write", "server", "parent", "copy", "connection", "manager", "lock", "io", "outer", "version", "sys", "store", "msg", "session", "part", "output", "group", "all", "result", "str", "o", "index", "Out", "error", "key", "conn", "temp", "comment", "source", "Output", "with", "client", "cli", "ne", "dump", "point", "user", "outs", "cache", "free", "string", "exec", "bin", "err", "file", "obj", "name", "list", "up", "lib", "w", "OUT", "full", "path", "pool", "state", "again", "line", "doc", "post"], "root": ["values", "include", "Root", "url", " roots", "module", "parent", "_", "modules", "options", "index", "graph", "meta", "results", "instance", "xml", "cat", "tree", "resources", "transform", "node", "r", "id", "cache", "history", "params", "loader", "pattern", "json", "query", "path", "format", "collection", "roots", " result"]}}
{"id1": "9261777", "id2": "13783549", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"source": ["sample", "prefix", "text", "proxy", "shared", "original", "url", "uri", "unit", "resource", "image", "se", "parent", "dest", "style", "view", "scope", "null", "copy", "flat", "empty", "info", "data", "options", "single", "project", "session", "in", "spec", "Source", "zip", "result", "site", "rule", "input", "strip", "index", "sort", "missing", "template", "element", "sin", "comment", "parse", "src", "config", "size", "seed", "target", "inner", "base", "slice", "id", "address", "token", "string", "ource", "file", "start", "name", "service", "sl", "SOURCE", "path", "query", "secure", "force", "use", "request"], "destination": ["distination", "destignment", "dependipping", "databaseination", " destension", "domination", " destinating", "destinate", "Destignment", "distipping", "homeinator", "destinations", "dominations", "Destinator", "dependination", "dependension", "homeignment", "domuration", "coordinator", "distinated", " destignment", "Destinate", " destinated", "databaseinations", " destinator", "destinated", "homeination", "Destination", "databaseinated", "destipping", "coordinating", "coordinate", "homeinated", "Destinating", "Desturation", "desturation", "databaseuration", "destinator", "Destinated", " destinate", "coordination", "dominated", "destension", "Destinations", "dependinated", " destipping", "distension", "destinating"], "is": ["ins", "esi", "se", "isl", "isi", "act", "obs", "ori", "io", "info", "mis", "init", "lis", "nis", "ics", "osi", "iso", "ie", "oss", "cos", "in", "zip", "bs", "es", "bis", "IS", "us", "isc", "ci", "out", "fs", "s", "iris", "ens", "ios", "i", "sin", "api", "src", "ar", "ip", "eni", "ib", "id", "iss", "ir", "ais", "ris", "ic", "Is", "sis", "ob", "ops", "ai", "get", "as", "ui", "or", "isa", "was", "ii", "abs", "close", "ois", "are", "serv", "ri"], "os": ["ls", "ros", "oa", "js", "dos", "nos", "ss", "acs", "obs", "ot", "io", "ies", "ori", "sys", "osi", "socket", "oss", "cos", "aos", "ose", "pos", "oise", "es", "so", "vs", "o", "bos", "us", "ow", "oses", "out", "s", "ens", "fs", "oS", "ios", "i", "ends", "Os", "oes", "mos", "los", "ais", "ob", "ops", "ou", "op", "ol", "as", "or", "bs", "boot", "ks", "OS", "ds"], "buffer": ["border", "wave", "buf", "page", "padding", "pad", "writer", "url", "image", "server", "copy", "b", "null", "data", "Buffer", "sequence", "limit", "channel", "result", "batch", "read", "bytes", "iter", "flush", "reader", "header", "size", "buff", "seed", "number", "base", "slice", "position", "queue", "address", "string", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "length": ["distance", "partial", "of", "url", "power", "count", "ring", "quote", "offset", "style", "volume", "lock", "data", "depth", "weight", "last", "duration", "part", "sequence", "limit", "shape", "range", "index", "split", "strip", "end", "key", "type", "row", "code", "division", "total", "reader", "section", "size", "width", "l", "len", "Length", "number", "point", "slice", "position", "object", "id", "address", "lower", "string", "character", "match", "load", "start", "age", "ob", "left", "full", "get", "value", "level", "line", "feed", "block"]}}
{"id1": "13421722", "id2": "7843322", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public void run(IAction action) {\n        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();\n        Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE);\n        GraphicalViewer viewer = new ScrollingGraphicalViewer();\n        viewer.createControl(shell);\n        viewer.setEditDomain(new DefaultEditDomain(null));\n        viewer.setRootEditPart(new ScalableFreeformRootEditPart());\n        viewer.setEditPartFactory(new TableEditPartFactory());\n        viewer.setContents(getContents());\n        viewer.flush();\n        int printMode = new PrintModeDialog(shell).open();\n        if (printMode == -1) return;\n        PrintDialog dialog = new PrintDialog(shell, SWT.NULL);\n        PrinterData data = dialog.open();\n        if (data != null) {\n            PrintGraphicalViewerOperation op = new PrintGraphicalViewerOperation(new Printer(data), viewer);\n            op.setPrintMode(printMode);\n            op.run(selectedFile.getName());\n        }\n    }\n", "label": 0, "substitutes": {"getFileSize": [" getFileBytes", "getfileLength", "getFilesInfo", "getByteLength", "getfileInfo", " getfileLength", " getfileSize", "getByteBytes", "getFilesSize", "getByteSize", "getFileInfo", " getFileInfo", "getFilesBytes", " getfileInfo", "getfileBytes", " getfileBytes", "getFileBytes", "getFilesLength", " getFileLength", "getFileLength", "getByteInfo", "getfileSize"], "address": ["prefix", "attribute", "array", "uri", "localhost", "report", "resource", "server", "message", "offset", "data", "port", "output", "route", "str", "type", "Address", "code", "source", "addr", "config", "size", "network", "target", "ip", "number", "base", "point", "position", "object", "email", "string", "name", "reference", "host", "location", "path", "content", "format", "request"], "url": ["ur", "page", "proxy", "log", "uri", "ssl", "resource", "image", "server", "e", "ll", "html", "build", "loc", "io", "org", "session", "socket", "channel", "f", "impl", "result", "www", "URL", "str", "job", "conn", "xml", "api", "config", "client", "l", "web", "lr", "base", "user", "object", "found", "string", "orb", "file", "service", "ob", "sl", "host", "bug", "path", "Url", "location", "http", "feed", "lib"], "connection": ["to", "proxy", "uri", "resource", "server", "communication", "event", "io", "info", "version", "session", "socket", "bc", "channel", "Connection", "application", "entry", "connect", "out", "conn", "connected", "config", "section", "client", "control", "object", "position", "character", "handler", "c", "con", "service", "relation", "reference", "environment", "context", "function", "response", "wrapper", "or", "current", "condition", "collection", "http", "use", "request", "open", "database"]}}
{"id1": "1443205", "id2": "17202158", "code1": "    private void redirect(TargetApp app, HttpServletRequest request, HttpServletResponse response) throws IOException {\n        URL url = new URL(app.getUrl() + request.getRequestURI());\n        s_log.debug(\"Redirecting to \" + url);\n        URLConnection urlConnection = url.openConnection();\n        Map<String, List<String>> fields = urlConnection.getHeaderFields();\n        for (String key : fields.keySet()) {\n            StringBuffer values = new StringBuffer();\n            boolean comma = false;\n            for (String value : fields.get(key)) {\n                if (comma) {\n                    values.append(\", \");\n                }\n                values.append(value);\n                comma = true;\n            }\n            if (key != null) {\n                response.setHeader(key, values.toString());\n            } else {\n                response.setStatus(Integer.parseInt(values.toString().split(\" \")[1]));\n            }\n        }\n        InputStream in = urlConnection.getInputStream();\n        try {\n            ServletOutputStream out = response.getOutputStream();\n            byte[] buff = new byte[1024];\n            int len;\n            while ((len = in.read(buff)) != -1) {\n                out.write(buff, 0, len);\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "label": 0, "substitutes": {"redirect": ["redicate", "rewirection", "Redicate", "redrict", "rewicate", "Redrict", "rewirect", "Redirect", "redirection", "Redirection", " Redrict", " Redirect", " Redicate", "rewrict", " Redirection"], "app": ["page", "auth", "install", "Application", "resource", "server", "build", "form", "project", "session", "application", "apps", "model", "ace", "container", "framework", "plugin", "instance", "api", "config", "client", "web", "self", "ip", "db", "base", "admin", "service", "host", "context", "APP", "App", "pp", "http", "browser"], "request": ["rec", "page", "req", "resource", "message", "server", "report", "complete", "view", "connection", "requ", "remote", "event", "method", "data", "info", "version", "child", "session", "application", "model", "result", "input", "Request", "xml", "instance", "create", "record", "config", "client", "web", "self", "user", "queue", "position", "object", "query", "buffer"], "response": ["wave", "resp", "page", "description", "req", "res", "proxy", "respond", "uri", "report", "resource", "server", "message", "image", "view", "Response", "connection", "body", "respons", "session", "output", "application", "status", "model", "result", "document", "site", "fire", "reply", "index", "error", "client", "object", "cache", "success", "re", "service", "host", "full", "function", "json", "pool", "collection", "http", "feed", "onse", "serv"], "url": ["ls", "proxy", "page", "log", "ssl", "uri", "resource", "ll", "server", "image", "b", "connection", "loc", "link", "f", "impl", "zip", "www", "URL", "bel", "api", "config", "client", "web", "l", "db", "base", "object", "address", "file", "service", "sl", "host", "location", "Url", "path", "http", "bb"], "urlConnection": ["webConnect", "stringConn", "stringClosure", "urlConnect", "sslConnection", "sslconnection", "URLconnection", "httpClosure", "httpClient", "sslConnect", "URLConnect", " urlConstruction", "webconnection", "stringClient", "urlClient", "webConnection", "controlconnection", "URLConnection", "controlConnect", "stringConnection", "urlClosure", " urlConn", "urlConn", "controlConstruction", "urlconnection", " urlConnect", " urlClient", " urlClosure", "httpConnection", "urlConstruction", "sslConstruction", " urlconnection", "controlConnection", "httpConn"], "fields": ["forms", "maps", "players", "keys", "rows", "details", "owners", "users", "data", "lists", "forces", "relations", "headers", "field", "ums", "loads", "plugins", "groups", "features", "comments", "classes", "lines", "ips", "balls", "objects", "drivers", "holders", "properties", "qs", "pps", "files", "states", "ids", "frames", "models", "cells", "locks", "rules", "checks", "views", "types", "limits", "events", "members", "phones", "services", "strings", "flows", "guards", "styles"], "key": ["k", "prefix", "keys", "uri", "default", "col", "money", "length", "count", "letter", "reason", "Key", "data", "version", "link", "step", "part", "title", "field", "entry", "cookie", "zip", "rule", "check", "index", "ace", "date", "val", "type", "row", "code", "element", "i", "source", "section", "header", "foo", "ip", "base", "feature", "point", "tax", "variable", "id", "match", "string", "patch", "alpha", "name", "service", "property", "pattern", "order", "host", "path", "query", "word", "cy", "q", "label", "KEY"], "values": ["forms", "maps", "keys", "ins", "rows", "gets", "als", "ps", "options", "data", "lists", "ones", "headers", "es", "groups", "bs", "vs", "iv", "bytes", "lines", "settings", "s", "objects", "results", "ends", "properties", "vals", "ports", "states", "files", "pages", "frames", "versions", "v", "errors", "codes", "params", "cells", "ops", "rules", "views", "blocks", "words", "Values", "boxes", "events", "limits", "services", "strings", "items", "its", "ks", "roots", "changes"], "value": ["attribute", "default", "message", "write", "resource", "null", "style", "letter", "item", "Value", "data", "version", "search", "field", "entry", "member", "end", "val", "element", "source", "comment", "variable", "object", "language", "string", "v", "name", "option", "property", "service", "reference", "VALUE", "current", "format"], "comma": ["ucma", "conma", "oma", "COMment", "compada", "omma", "Comma", "lampa", "comenta", " comment", "ucbo", " commas", "COMada", "conntax", "Coma", "COMmas", "cyntax", "coma", "lamenta", "compment", "cyma", "comment", " comada", "lamma", "comada", "conpa", "compa", "Combo", "conenta", "lamntax", "ucpa", "combo", "ompa", "compmas", "ombo", "COMma", "uca", "cyenta", "cypa", "Compa", "compma", "commas", "comntax"], "in": ["ex", "ins", "In", "b", "init", "data", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "read", "s", "i", "is", "win", "reader", "client", "inside", "nin", "a", "login", "inner", "min", "r", "id", "ac", "bin", "c", "con", "err", "ic", "file", "pin", "ini", "as", "again", "serv", "isin"], "out": ["ex", "res", "exit", "ins", "copy", "b", "io", "off", "data", "sync", "inc", "raw", "output", "exp", "o", "sum", "Out", "conn", "inner", "outs", "user", "exec", "bin", "err", "obj", "extra", "up", "net", "w", "OUT", "down", "again", "serv", "ext"], "buff": ["buf", "uf", "text", "pad", "pack", "txt", "length", "b", "cp", "cmd", "cod", "lock", "cell", "fb", "data", "back", "ph", "cond", "sb", "f", "now", "bag", "rb", "ch", "batch", "comb", "cb", "mb", "Buff", "bf", "uff", "flush", "boot", "grab", "ff", "load", "gb", "ob", "fab", "bl", "qq", "buffer", "fe", "pp", "feed", "bb", "char"], "len": ["cap", "fl", "ln", "lf", "fin", "le", "length", "count", "n", "en", "num", "off", "data", "rev", "pos", "limit", "all", "str", "coll", "lin", "read", "Len", "end", "val", "type", "el", "iter", "size", "li", "l", "db", "min", "ind", "id", "lim", "bin", "err", "pre", "ler", "line"]}}
{"id1": "19520541", "id2": "9846843", "code1": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"getDirectoryListing": ["getFileListving", "getDirectoryServing", "getFilelistving", "getFileListening", "getDirectorylistening", "getFilelistings", "getFileListning", "getDirectoryServings", "getFileListing", "getDirectoryListning", "getDirectoryServning", "getDirectoryServening", "getDirectorylistving", "getFilelistening", "getDirectoryListving", "getFileListings", "getDirectoryLISTving", "getFilelisting", "getDirectoryLISTing", "getDirectoryLISTings", "getDirectoryLISTening", "getDirectorylisting", "getDirectorylistning", "getDirectoryListening", "getFilelistning", "getDirectorylistings", "getDirectoryListings"], "url": ["ll", "image", "html", "null", "org", "socket", "entry", "www", "rl", "l", "string", "err", "page", "uri", "resource", "e", "server", "connection", "rel", "link", "zip", "URL", "key", "el", "parse", "config", "lr", "object", "email", "https", "loader", "layer", "path", "feed", "proxy", "log", "build", "loc", "il", "io", "ul", "rule", "route", "str", "pull", "web", "user", "id", "obj", "ob", "sl", "location", " URL", "Url", "buffer", "http", "ur", "ssl", "b", "pl", "f", "ref", "source", "client", "filename", "contact", "base", "address", "name", "service", "host", "full", "request"], "CancelledOperationException": ["CanceleOperationFailure", "CancelledConnectionFailure", "CancelledObjectFailure", "CanceleConnectionExcept", "CanceleConnectionFailure", "CancelledIOException", "CancelledOperationFailure", "CanceleOperationException", "CancelledConnectionExcept", "CancelledConnectionException", "CancelledObjectExcept", "CancelledIOFailure", "CancelledObjectException", "CanceleOperationExcept", "CancelledIOExcept", "CancelledOperationExcept", "CanceleConnectionException"], "file": ["page", "pe", "log", "http", "uri", "FILE", "resource", "message", "image", "play", "plain", "html", "unit", "body", "connection", "letter", "parent", "build", "io", "info", "data", "part", "f", "fp", "zip", "key", "home", "code", "source", "dir", "filename", "l", "use", "base", "id", "address", "email", "string", "name", "binary", "full", "File", "path", "content", "line", "feed", "lib"], "userInfo": ["UserInfo", "userId", "userinfo", "keyData", " userId", "UserInf", " userInf", "UserData", "passInf", " userinfo", "passinfo", "passInfo", "userName", " userName", "customInfo", "keyId", "UserName", "customName", "userData", "customInf", "keyInfo", "passId", " userData", "userInf", "Userinfo", "UserId"], "urlConnection": ["baseStream", "stringConn", "urlConnect", "urlContainer", "baseConn", "httpFlow", "URLconnection", "httpConnect", "urlSocket", "URLContainer", "userFlow", "URLConnect", "baseConnection", "stringConnect", "userSocket", "userContainer", "httpConn", "userConn", "URLConnection", "urlFlow", "fileConn", " urlContainer", "stringConnection", "userCode", " urlSocket", " urlConn", "urlCode", "urlConn", "httpCode", " urlFlow", "urlconnection", "stringStream", " urlConnect", "userConnection", " urlCode", "userconnection", "fileConnect", "httpConnection", "fileConnection", " urlconnection", "fileSocket", "userConnect", "httpStream", "baseConnect"], "encode": ["decode", "Enge", "enge", "encge", "eecode", "ensee", "encodes", "eencode", "encsee", "Envert", "Enode", "enccodes", "decvert", "eesee", "Encode", "enccode", "envert", "enode", "decge", "eensee", "eenode", "eeode", "encvert", "eencodes", "deccode", "eecodes"], "urlStream": ["fileReader", "urlHandler", "xmlSteam", "controlChannel", "fileStream", "xmlStream", "httpClient", "controlReader", "xmlHandler", "userReader", "userChannel", "resultSteam", "urlClient", "userSteam", "urlSteam", "fileSteam", "resultClient", "xmlConnection", "httpHandler", "urlReader", "fileChannel", "resultStream", "controlSteam", "controlStream", "urlChannel", "userStream", " urlClient", "httpConnection", "resultConnection", "httpSteam", " urlSteam", " urlHandler", "httpStream"]}}
{"id1": "13644375", "id2": "15904772", "code1": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"get": ["uri", "resource", "e", "call", "build", "remote", "method", "GET", "status", "Get", "set", "read", "end", "download", "handle", "i", "pull", "create", "api", "print", "parse", "client", "with", "cli", "delete", "base", "send", "show", "exec", "patch", "load", "gi", "start", "find", "service", "select", "json", "query", "transfer", "invoke", "put", "update", "http", "use", "request", "open", "post"], "url": ["uri", "resource", "server", "connection", "method", "data", "route", "str", "URL", "href", "type", "download", "xml", "i", "source", "api", "l", "base", "object", "id", "address", "email", "string", "file", "name", "service", "sl", "host", "path", "Url", "location", "json", "http", "feed", "request"], "response": ["wave", "resp", "page", "respond", "resource", "message", "server", "report", "body", "Response", "connection", "method", "data", "output", "application", "status", "document", "result", "reply", "error", "out", "api", "tree", "object", "success", "full", "json", "http", "feed", "request", "onse", "received"], "entity": ["page", "pe", "ale", "ity", " entities", "e", "resource", "image", "server", "null", "body", "connection", "Entity", "item", "ce", "event", "info", "data", "output", "model", "document", "result", "translation", "ent", "error", "el", "xml", "instance", "element", "source", "action", "api", "node", "object", "file", "environment", "json", "query", "content", "collection", "http", "person"]}}
{"id1": "6988216", "id2": "3731077", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runRawQuery", " runSimpleFilter", "runRawFilter", "runSimpleQuery", "runRawSearch", " runBasicFilter", "runSimpleConnect", " runClientSearch", " runBasicConnect", "runRawQuery", " runClientConnect", "runRawConnect", " runSimpleConnect", " runSimpleSearch", " runRawFilter", " runBasicSearch", " runRawSearch", " runSimpleQuery", "runSimpleSearch", "runSimpleFilter", " runClientFilter", " runBasicQuery", " runClientQuery", " runRawConnect"], "dummySource": ["puddyClient", "pummySourceFile", "dundleConfig", "dummySite", "puddySource", "puddyContent", "dummySourceFile", "dumbSource", "duddySource", "dellyContent", "daddyType", "dummyClient", "pummyContent", "pummyType", " dumbContent", "pummyClient", "duddyType", "dellyType", "puddySourceFile", " dumbOrigin", "duddySourceFile", "pummySite", "dummyType", "dundleSource", "pummyService", " dummyOrigin", "dumbOrigin", "daddySite", "daddySource", "daddyContent", "dandySource", "dellySource", "duddyContent", " dumbSource", "daddyService", " dummyConfig", "duddySite", " dumbConfig", "dummyOrigin", "daddySourceFile", "dumbConfig", "puddySite", "dandySite", "dandySourceFile", "dumbContent", "puddyService", "dandyClient", "duddyConfig", "daddyClient", "dellyService", "puddyType", "duddyClient", "duddyOrigin", "dundleContent", "dundleOrigin", "pummySource", "dummyService", "dummyConfig", "duddyService"], "os": ["css", "ls", "ros", "oa", "dos", "nos", "ss", "ok", "acs", "obs", "io", "ori", "ns", "ps", "sys", "osi", "iso", "oss", "aos", "cos", "pos", "ose", "es", "ows", "o", "bos", "vs", "us", "ox", "uns", "oses", "ms", "fs", "out", "ols", "ens", "s", "oS", "ios", "i", "is", "conn", "Os", "oos", "object", "oc", "mos", "los", "ops", "ou", "op", "ol", "as", "or", "om", "bs", "ks", "OS", "ds"], "dummyContent": ["dummycontent", "duckySource", "DummySource", "dumperContents", "dellyContent", "DummyReader", "dumpercontent", "dumperOutput", "duddySource", " dummyContents", " dellyOutput", " dummyOutput", "DuckySource", "DuckyReader", "dumpingContents", "dummyContents", " dummycontent", "dummyOutput", "dellycontent", "dumpingContent", "duddyReader", "dumperSource", "duckyBody", "duddyContent", "duckyReader", " dellyContent", " dellycontent", "DummyContent", "dumperBody", "duckyContent", "dellyContents", "dumpingOutput", "DummyBody", "duddyBody", "dellyOutput", "dummyBody", "dumperReader", " dellyContents", "dumperContent", "dummyReader", "dumpingcontent", "DuckyBody", "DuckyContent"], "source": ["proxy", "text", "url", "uri", " Source", "resource", "e", "core", "unit", "parent", "scope", "ser", "connection", "info", "sync", "cos", "search", "channel", "Source", "result", "site", "sn", "storage", "ources", "s", "element", "i", "class", "sin", "src", "reader", " sources", "config", "size", "stream", "target", "seed", "slave", "client", "resources", "node", "object", "sc", "cache", "string", "ource", "service", "sl", "SOURCE", "host", "secure", "use"], "content": ["css", "activity", "sol", "text", "description", "url", "news", "resource", "image", "report", "message", "html", "server", "body", "music", "data", "version", "child", "title", "cos", "output", "model", "document", "result", "input", "comments", "Content", "children", "code", "xml", "comment", "config", "cms", "size", "media", "header", "expression", "target", "transform", "address", "match", "load", "service", "host", "cover", "clean", "response", "cont", "current", "value", "update", "feed"], "qResult": ["iqResults", "kResult", " qResults", "qFilter", "queryReturn", "iqResult", "rresult", "qResponse", "kFilter", "QResult", " qResponse", "queryresult", "queryResponse", "QFilter", "qReturn", "kReturn", "kResults", "kRes", "qRes", "queryResults", "QReturn", "iqResponse", "kresult", "qresult", "kSource", "querySource", "iqresult", "QResults", " qresult", "queryResult", "queryRes", "queryFilter", "qSource", "rResult", "qResults", "rSource", "rRes"], "results": ["values", "res", "ions", "ins", "rows", "details", "users", "successful", "data", "shows", "RESULTS", "reports", "result", "groups", "features", "lines", "children", "s", "docs", "objects", "ries", "qs", "pages", "resources", "ids", "files", "versions", "models", "errors", "tests", "blocks", "response", "events", "members", "Results", "collection", "items", "its", "runs", "vers"], "it": ["ort", " It", "ins", "ait", "It", "IT", "init", "iti", "ited", "info", "ITS", "si", "you", "not", "in", "ati", "entry", "split", "itted", "stat", "and", "ci", "the", "i", "iter", "mit", "l", "edit", "ip", "lit", "slice", "r", "pit", "id", "sit", "which", "v", "ic", "list", "t", "op", "ite", "or", "its", "p", "rit"], "rSrc": ["rPssrc", "rPsrc", " rDssrc", "RSource", "RIsrc", "rPsource", "rIsrec", " rSource", "rEsRC", "rDsRC", "rPsRC", "rSRC", "RSrc", " rEsrc", "rSrec", "rEssrc", " rDsRC", " rSsrc", "rSsrc", "rAsrec", " rEssrc", "rAsource", "rIsource", "rEsrc", "rEsource", "RSrec", " rEsource", " rDsrc", " rDsource", "rAsRC", " rEsRC", "rDssrc", "RSRC", "rAssrc", "RIsRC", "rIsRC", "RIsource", "rSource", "rDsrc", "RIsrec", " rSRC", "rDsource", "rIsrc", "rAsrc"], "rSrcIn": ["rAsrcin", "rSourceIn", "rSRCin", "rCrcin", "rAsrcOut", "rSsrcOut", "rCsrcOut", "rSvcIn", "rSRCOut", "rCsrcIn", "rCrcIns", "rSrcOut", "rSourceOut", "rCRCIns", "rSrcin", "rSvcOut", "rCRCIn", "rCrcIn", "rSrcIns", "rSrcIN", "rAsRCIn", "rSourceIns", "rCsrcin", "rSsrcIN", "rCRCOut", "rCrcOut", "rCrcIN", "rSRCIn", "rAsRCOut", "rSourcein", "rSRCIns", "rSsrcin", "rCsrcIN", "rAsRCin", "rSvcin", "rSRCIN", "rSvcIN", "rAsrcIn", "rSvcIns", "rSsrcIn"], "actualOut": [" actualWin", " actualOUT", "actualout", "publicOUT", "nexpectedOut", " ActualIn", "actualIn", "operatorOUT", "illegalOutput", "nexpectedWin", " ActualOut", "operatorIn", " actualOutput", "realout", "publicOutput", "illegalOut", "nexpectedIn", "assertBridge", " ActualOUT", "eventout", " ActualBridge", "realIn", "actualBridge", "publicOut", "nexpectedout", "actualWin", "publicIn", "operatorout", "eventOUT", "illegalOUT", "actualOUT", "eventOut", "assertOut", "actualOutput", "realWin", "assertIn", "illegalIn", "operatorOut", "realOut", "assertOUT", " actualout", " actualIn", " actualBridge", "eventIn"]}}
{"id1": "822452", "id2": "19912848", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readandrewrite", "readAndRebrites", "readandRewrite", "readAndRebrite", "readAndrewrite", "readandRewwrite", "readAndRewrap", "readAndSwrites", "readAndSwwrite", "readAndrewwrite", "readandrewwrite", "readAndRebwrite", "readAndRewrites", "readAndSwrite", "readAndrewrap", "readandRewrap", "readAndrewrites", "readAndRebrap", "readandrewrap", "readAndSwrap", "readandRewrites", "readAndRewwrite"], "inFile": ["InFile", "infile", "oldFile", " inFiles", "inFilename", "oldFiles", "inputFile", " inFilename", " inSourceFile", "outFiles", "loginFiles", "loginfile", "loginFilename", "outfile", "Infile", "inputFilename", "outFilename", "oldfile", "outSourceFile", "InFiles", "oldFilename", "InSourceFile", "inputfile", "loginFile", "inputFiles", "inFiles", "inSourceFile", " infile"], "outFile": ["outFILE", " outfile", "processPlace", " outDir", "thisFilename", "exFILE", "outputPlace", "offFilename", "newfile", "processFilename", "outDir", "thisFILE", "exFilename", "exFile", "newStream", "thisFile", "outputFile", "offFILE", "outStream", "outfile", "outputFILE", " outStream", "outFilename", "offPlace", "thisfile", "newFile", "OutDir", "offFile", "Outfile", "newDir", "processFile", "OutStream", "outputFilename", "OutFile", "processFILE", "outPlace", "outputfile", "exfile"], "iis": ["ciiss", "IIS", "Iis", "iniris", " iais", " iiss", "iniiss", "iais", "ciais", "ciris", "ciIS", "Iiss", " iIS", "iiIs", " iIs", "iiiss", "iiis", "iris", "iiris", "iiIS", " iris", "iIS", "iniIS", "iniIs", "ciIs", "ciis", "iiss", "iniis", "iIs", "Iais"], "dcmParser": ["DcmInstallation", " dcmReader", "dpmPlugin", "dcmPolicy", "dkmHelper", "dbmParser", "dmcarser", "dmissionParser", " dcmparser", "dmoduleParser", "dhemParser", "dcmPlugin", " dcmLoader", "fpmParser", " dcmPolicy", " dcmHelper", "dpmInstallation", " dpmJar", "dcrPlugin", " dcmLanguage", "dCMparser", "dcmLoader", "dcmReader", "dcrParser", "dmissionReader", "dmcParser", "dkmParser", " dcrParser", "dcmparser", "dhemInstallation", "dkmPlugin", " dpmLanguage", "dmmparser", "dmParser", "dpmHandler", "dmissionPlugin", "dcmPar", "dCMReader", "dmoduleJar", "dcrLoader", "dcrJar", "dmmParser", "dbmPolicy", "dmodulePlugin", "dmReader", "dhemJar", " dcrReader", " dpmPar", " dpmPlugin", "fcmHandler", " dcrLoader", "fpmHandler", "dpmarser", "dmLoader", "dpmPolicy", "dbmHelper", "dcrarser", "dpmparser", "dbmPlugin", "dpmLanguage", "fcmReader", "fpmReader", "dcmarser", " dpmparser", " dcmPar", "dmPlugin", " dpmHelper", "dcmHelper", " dpmPolicy", "dmissionLanguage", "dcrPar", "dpmReader", "dCMHandler", "fpmparser", " dpmReader", " dpmarser", "DcmParser", "dpmParser", "dpmPar", "dkmPolicy", "dcmInstallation", "fcmParser", "DcmJar", " dcmJar", "dCMLoader", "fcmparser", "dmmPlugin", "dpmLoader", "dhemReader", "dmoduleReader", "dpmJar", "dCMParser", "dCMPlugin", "DcmReader", "dmcPar", "dmmLoader", "dpmHelper", "dmcJar", " dcmarser", "dcmHandler", " dpmLoader", " dcrPlugin", " dcmPlugin", "dmoduleparser", "dcrReader", "dcmLanguage", "dcmJar", " dpmParser"], "ds": ["ks", "ls", "Db", "ros", "js", "des", "ads", "DS", "ins", "details", "ss", "dr", "cdn", "df", "ps", "rs", "points", "os", "data", "ns", "parts", "sys", "session", "uds", "sync", "dd", "tx", "gd", "vs", "Ds", "amps", "d", "dat", "asi", "ys", "s", "conn", "ws", "is", "drivers", "tes", "src", "pd", "vals", "di", "qs", "db", "Os", "ras", "da", "eps", "ils", "iss", "dds", "icks", "dc", "xs", "ld", "ts", "ays", "nas", "gs", "cs", "utils", "services", "bs", "ants", "dt"], "pdReader": ["ddLoader", "pdLoader", "dsLoader", "pcLoader", "hdStream", "hdLoader", "pcReader", "hdRead", "ddReader", "hdReader", "dsWriter", "hdWriter", "dsreader", "pbRunner", "xdReader", "hdreader", "pdreader", "dsReader", "dsRead", "pdRunner", "pcRead", "ddRunner", "hdRunner", "pbReader", "pdStream", "pcWriter", "pbLoader", "xdRead", "pdRead", "xdWriter", "ddStream", "pbStream", "xdreader"], "out": ["ex", "writer", "default", "flow", "image", "parent", "null", "term", "data", "part", "in", "her", "exp", "o", "password", "conn", "pass", "temp", "cli", "outs", "over", "cache", "exec", "file", "err", "list", "net", "lib", "img", "page", "connection", "dot", "inc", "group", "model", "result", "key", "code", "builder", "point", "object", "w", "down", "layer", "word", "oder", "to", "gen", "url", "io", "outer", "store", "later", "sys", "sync", "Out", "dev", "s", "co", "login", "db", "user", "obj", "up", "device", "order", "diff", "again", "manager", "director", "at", "array", "ssl", "write", "copy", "lock", "child", "session", "external", "output", " in", "with", "client", "inner", "base", "name", "full", "OUT", "auto", "as", "line", "doc", "ext"], "dcmEncParam": ["dcmDecParam", "dcmEstPar", "dcmDecPart", "dcmEnType", "dcmElParameter", "dcmSecParam", "dcmEstParam", "dcmDecPar", "dcmElPar", "dcmDecParameter", "dcmArchParam", "dcmSecPart", "dcmEnParameter", "dcmEncArg", "dcmArchParameter", "dcmEncType", "dcmEnArg", "dcmEstType", "dcmSecType", "dcmEnPar", "dcmEncParameter", "dcmSecPar", "dcmArchArg", "dcmElParam", "dcmEstParameter", "dcmEncPart", "dcmElType", "dcmDecType", "dcmDecArg", "dcmEncPar", "dcmEnPart", "dcmEnParam"], "pdWriter": ["htWriter", "ddReader", "dsOutput", "hdWrite", "hdReader", "hdOutput", "htWriting", "pdWrite", "dsWriter", "ddWrite", "hdWriter", "dsReader", "dsWrite", "PDWriter", "dpWriter", "dpWriting", "PDReader", "PDWrite", "dpReader", "pdWriting", "ddWriter", "pdOutput", "ddOutput", "dpWrite", "htWrite", "htReader", "PDWriting"]}}
{"id1": "23161545", "id2": "8665321", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomGCUID", "getRandomGCuid", "getRandomIGid", "getRandomGid", "getRandUID", "getRandomUID", "getRandGid", "getRandomGID", "getRandomGuid", "getRandomIGID", "getRandomUUID", "getRandomUuid", "getRandomGCid", "getRandUuid", "getRandGUID", "getRandomIGuid", "getRandUid", "getRandUUID", "getRandGuid", "getRandomUid", "getRandGID", "getRandomGCID", "getRandomIGUID"], "secure": ["proxy", "ssl", "server", "debug", "protect", "remote", "ce", "depth", "pure", "random", "allow", "weak", "session", " insecure", "external", "sensitive", "zip", "smart", "encrypted", "sec", "timeout", "require", "config", "seed", "stable", "https", "security", "safe", "confirmed", "deep", "service", "secondary", "sr", "host", "unsigned", "Secure", "active", "force", "use", "secret", "exclusive"], "md5": ["MD500", "MDql", "MD3", " MD500", " MD2", "cmd5", "MD512", " md512", "MD5", "md11", " md2", " md500", " MD5", "md3", " md3", "md2", " md11", "mdql", " MD3", "MD2", " mdql", "md500", "MD11", " MD11", "cmd512", "cmdql", "md512", "cmd3"], "sbValueBeforeMD5": ["sbValueAfterMS65", "sbValueAfterMS20", "sbValueBeforeMC5", "sbValueAfterMD95", "sbValuebeforeMD1", "sbValueBeforeDER005", "sbValueBeforeD5", "sbValueBeforeMS375", "sbValueBeforeDER3", "sbValueGivenmd512", "sbValueBeforeMS25", "sbValuebeforeMD005", "sbValueBeforeMI1", "sbValueBeforeMD25", "sbValueBeforeMS20", "sbValueBeforeMI7", "sbValueBeforeMS95", "sbValueBeforeSHA1", "sbValueBeforeMI3", "sbValueBeforeAMD1", "sbValueBeforeMD375", "sbValueBeforeMR5", "sbValueAfterMP3", "sbValueAfterMP7", "sbValueBeforemd95", "sbValueBeforeMS65", "sbValuebeforeMD20", "sbValueAfterMD1", "sbValueBeforeDER55", "sbValueBeforemd375", "sbValueBeforeAMD20", "sbValueBeforeMS1", "sbValueBeforeMR3", "sbValueBeforeSD005", "sbValueGivenmd5", "sbValueAfterMP5", "sbValueBeforeMD75", "sbValueBeforeDER5", "sbValueBeforeMS0", "sbValueAfterMD3", "sbValueBeforeDER20", "sbValueBeforeMS75", "sbValuebeforeSD20", "sbValueBeforeMC512", "sbValueAfterMS3", "sbValueBeforeMP7", "sbValueGivenMD512", "sbValueBeforemd512", "sbValueAfterMS25", "sbValueBeforeMS7", "sbValueBeforemd3", "sbValueBeforeSD1", "sbValueAfterMD25", "sbValueBeforeMD7", "sbValueBeforeD3", "sbValueBeforeSHA5", "sbValueBeforeMAC55", "sbValueBeforeMI20", "sbValueBeforeMP5", "sbValueAfterMD7", "sbValueAfterMS1", "sbValueBeforeSHA005", "sbValueBeforeMD55", "sbValueBeforeDER0", "sbValuebeforeSD1", "sbValueAfterMD5", "sbValueBeforeAMD3", "sbValueAfterMS75", "sbValueBeforeMR95", "sbValueBeforeMS3", "sbValueBeforeMAC0", "sbValueBeforeMD20", "sbValueGivenmd3", "sbValueBeforeMR25", "sbValueAfterMD20", "sbValueBeforeMS512", "sbValueAfterMS95", "sbValueBeforeSD5", "sbValueGivenMD375", "sbValueBeforeMP1", "sbValueBeforeMC3", "sbValuebeforeSD5", "sbValueBeforeMD1", "sbValueBeforeMI5", "sbValueBeforeMP3", "sbValueBeforeMAC5", "sbValueBeforeD75", "sbValueBeforeMD3", "sbValueGivenmd375", "sbValueBeforeSD20", "sbValueBeforeDER1", "sbValueBeforeMS5", "sbValueBeforemd75", "sbValueAfterMS5", "sbValueAfterMD65", "sbValueAfterMD0", "sbValueBeforemd5", "sbValueBeforeD65", "sbValueBeforeMS55", "sbValueGivenMD5", "sbValueBeforeMD95", "sbValuebeforeMD5", "sbValueBeforemd65", "sbValueBeforemd25", "sbValueBeforeMD0", "sbValueAfterMS55", "sbValueAfterMP1", "sbValueAfterMD55", "sbValueBeforeSHA20", "sbValueBeforeAMD5", "sbValueAfterMS0", "sbValueBeforeMD512", "sbValueBeforeMAC3", "sbValueBeforeMC375", "sbValuebeforeSD005", "sbValueBeforeMD005", "sbValueAfterMD75", "sbValueBeforeMD65", "sbValueGivenMD3"], "time": ["TIME", "delay", "money", "clock", "length", "count", "tz", "speed", "offset", "loc", "race", "etime", "event", "version", "depth", "random", "duration", "times", "year", "mode", "hour", "timer", "error", "date", "timeout", "type", "size", "ime", "work", "seed", "tim", "user", "slice", "id", "counter", "cost", "start", "name", "host", "Time", "value", "rate"], "rand": ["pick", "gen", "res", "raid", "delay", "ro", "count", "rc", "rol", "rh", "version", "depth", "mid", "random", "bit", "reg", "rage", "winner", "range", "chance", "year", "risk", "rule", "index", "error", "type", "ng", "win", "max", "seed", "rr", "min", "round", "r", "id", "alpha", "root", "order", "bot", "clean", "rank", "q", "Rand", "serial", "lang", "cr", "rate", "right"], "valueBeforeMD5": ["valueBeforeMD53", "valueBeforeMP3", "valueBeforemd3", "valueBeforeMC3", "valueAfterAMD2", "valueBeforeMD85", "valueAfterMD53", "valueBeforeMP53", "valueBeforeMP5", "valueInsideMD5", "valueBeforeMC5", "valueAfterAMD5", "valueInsideMD2", "valueBeforeMP2", "valueBeforemd85", "valueAfterAMD3", "valueInsideMD3", "valueBeforeMD3", "valueAfterMD2", "valueBeforeMC2", "valueBeforeAMD2", "valueBeforeAMD5", "valueBeforeAMD53", "valueInsideMD85", "valueBeforemd5", "valueBeforeMC85", "valueBeforeAMD3", "valueBeforeMD2", "valueAfterAMD53", "valueAfterMD3", "valueBeforemd2"], "array": ["sample", "arrow", "air", "arr", "message", "image", "integer", "view", "data", "allow", "range", "shape", "audio", "area", "result", "archive", "storage", "batch", "error", "row", "our", "element", "instance", "api", "record", "section", "pair", "expression", "number", "feature", "any", "object", "address", "cache", "string", "Array", "app", "list", "binary", "angle", "vector", "function", "value", "ray", "collection", "database"], "sb": ["buf", "kb", "sth", "bsp", "lp", "rob", "sf", "sv", "fb", "bt", "bh", "bp", "si", "usb", "xb", "lb", "bc", "pb", "SB", "rb", "lab", "cb", "mb", "s", "sbm", "sq", "bf", "bm", "src", "stab", "ruby", "sg", "lr", "ib", "bj", " SB", "abb", "zb", "orb", "BB", "sa", "gb", "ob", "binary", "sl", "obb", "wb", "bl", "buffer", "ab", "nb", "eb", "bs", "bb", "nn"], "j": ["ij", "k", "js", "z", "e", "length", "g", "n", "num", "ie", "part", "f", "jj", "o", "ja", "d", "ch", "index", "job", "uj", "key", "out", "ji", "J", "code", "aj", "jo", "end", "i", "pr", "y", "li", "l", "bj", "br", "v", "c", "obj", "dy", "adj", "jl", "ii", "x", "jp", "q", "p"], "b": ["k", "p", "e", "n", "fb", "bit", "lb", "bc", "f", "pb", "d", "rb", "job", "cb", "mb", "bf", "B", "i", "y", "a", "l", "db", "bar", "ib", "br", "orb", "bin", "c", "BB", "be", "ob", "binary", "bug", "bi", "x", "ab", "nb", "eb", "bs", "bb"], "valueAfterMD5": ["valueBeforeMP3", "valueAfterAMD2", "valueAfterAMD7", "valueBeforeMD7", "valueAfterMP3", "valueBeforeMP5", "valueAfterVM2", "valueAfterAMD5", "valueBeforeMP2", "valueAfterVM3", "valueAfterAMD3", "valueBeforeMD3", "valueAfterMP7", "valueAfterMD2", "valueAfterMP2", "valueAfterMD7", "valueBeforeMP7", "valueAfterMP5", "valueBeforeMD2", "valueAfterVM7", "valueAfterMD3", "valueAfterVM5"]}}
{"id1": "8921716", "id2": "4798332", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"MD5": ["MP512", "MD512", " MD512", "SHA5", "SHA4", "MD8", "MP5", "MP4", "SHA8", "MP8", "MD4", " MD8", "SHA512", " MD4"], "text": ["font", "prefix", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "this", "in", "output", "input", "str", "editor", "hex", "password", "template", "bytes", "key", "test", "code", "class", "source", "config", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "path", "word", "content", "ext", "format", "buffer", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedEncodedATION", "UnsupportedEncagingception", "Unsupportedencodingception", "UnsupportedEncodingATION", "UnsupportedencodingATION", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingATION", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedEncasingException", "UnsupportedencodedATION", "UnsupportedEncagingException", "Unsupportedencodedception", "UnsupportedEncagingATION"], "md": ["m", "rm", "hd", " MD", "Cmd", "message", "mp", "body", "cmd", "sha", "pg", "method", "data", "mo", "dig", "dd", "rpm", "mode", "hash", "mc", "valid", "d", "mag", "vd", "od", "ms", "meta", "me", "mb", "code", "amd", "mg", "dm", "bd", "wd", "metadata", "cm", "bf", "pd", "MD", "docker", "di", "ad", "mac", "nm", "mand", "match", "mm", "ma", "ld", "pm", "mt", "cd", "mod", "manager", "df"], "md5hash": ["md25Hash", " md5sum", "md8hash", "md5version", " md5hex", "md4Hash", "mand53Hash", " md6hash", "md6Hash", "md4sum", "md6kh", "md53version", "mddownsum", "md5Hash", "mddownHash", "md2sum", "mddownkh", "md2html", "mand5version", "md5hex", "mand5hash", "md6hash", "md6hex", "md8hex", "md25version", "md8Hash", "mddownhash", "md2version", "md25html", "md4hash", "md8sum", "md53hash", " md6hex", " md6Hash", " md6sum", "md2hash", " md5kh", "md25hash", "mand5Hash", "md53Hash", "mand5html", "md5sum", "mand53version", "md2kh", "md4hex", " md5Hash", "mand53hash", "md6sum", " md6kh", "mand53html", "md5kh", "md53html", "md2Hash", "md5html"]}}
{"id1": "12380475", "id2": "22801734", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"transport": ["protpoint", "ransports", " transmission", "protports", " transporter", "protmission", "transprocess", "ransmission", "transmission", "protport", "ransport", "transpoint", "ranspoint", " transpoint", "ransporter", " transports", "protporter", "protprocess", "transporter", "ransprocess", " transprocess", "transports"], "file": ["page", "log", "FILE", "url", "resource", "e", "image", "server", "parent", "ile", "connection", "io", "data", "single", "project", "info", "socket", "channel", "folder", "model", "f", "entry", "document", "route", "out", "type", "handle", "source", "class", "comment", "reader", "dir", "directory", "filename", "stream", "use", "db", "base", "user", "queue", "object", "local", "cache", "change", "string", "handler", "name", "service", "full", "File", "path", "line", "auto", "content", "http", "fp"], "files": ["ls", "pes", "keys", "ions", "ins", "books", "users", "sites", "headers", "ums", "f", "bs", "features", "classes", "lines", "balls", "fs", "s", "thumbnails", "objects", "results", "facts", "flows", "images", "dir", "pages", "names", "models", "cells", "iles", "views", "blocks", "Files", "boxes", "ups", "events", "phones", "items", "issues"], "i": ["k", "m", "p", "u", "uri", "e", "col", "j", "b", "n", "io", "info", "si", "f", "it", "ni", "o", "index", "d", "ci", "h", "end", "oi", "key", "abi", "multi", "li", "di", "mi", "ip", "pi", "vi", "xi", "hi", "slice", "id", "ti", "v", "c", "I", "ai", "chi", "ii", "ui", "x", "ini", "ri"], "inChannel": ["InFile", "outchannel", "inputChan", "inputChannel", "InStream", " inStream", "InChan", " inchannel", "InChannel", "inStream", "outMessage", "inChan", "inputCh", "InMessage", "inchannel", " inMessage", "inFile", " inFile", "inCh", " inChan", "inputStream", "outStream", " inCh", "InCh", "Inchannel", "outFile", "inMessage"], "outChannel": ["ioChannel", "outchannel", "inConnection", "outHandler", "OutChan", " outHandler", "inHandler", "inStream", "inChan", " outChan", "ioChan", "ioConnection", "OutChannel", "inchannel", "Outchannel", " outchannel", "ioHandler", "outStream", " outStream", "outChan", "outConnection", "OutStream", " outConnection"]}}
{"id1": "9796161", "id2": "812803", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD4", "getmd4", "getmdHash", "getmd512", "getHTMLHash", " getSHA4", "getHTML4", "getMDHash", "getSHA5", "getmd5", "getMD512", " getMD512", "getSHA512", "getSHAHash", " getSHA512", " getMD4", "getSHA4", "getHTML512", " getSHAHash", " getMDHash", " getSHA5", "getHTML5"], "s": ["ls", "js", "ssl", " ads", "e", "als", "g", "b", "n", "ss", "os", "rs", "ps", "data", "parts", "ns", "si", "sync", "in", "sb", " fails", "f", "es", "input", "str", "ings", "ows", "comments", "sets", "bytes", "lines", "ms", "ips", "ws", "i", "source", "ends", "is", "sym", "a", "l", "self", "scripts", "ses", "S", "string", "v", "c", "tests", "ts", "gs", "cs", "abs", "ates", "services", "strings", "bs", "its", "p", "ds", "styles"], "m": ["rm", "e", "module", "mut", "mr", "md", "um", "tm", "wm", "f", "fm", "mc", "d", "man", "h", "me", "hm", "ms", "nm", "dm", "i", "bm", "cm", "gm", "l", "mi", "im", "mac", "ym", "mand", "v", "mm", "c", "machine", "sm", "am", "t", "pm", "em", "M", "arm", "mu", "vm", "om", "manager", "p"]}}
{"id1": "19747399", "id2": "22411381", "code1": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"setUp": [" setDown", "setups", "startDown", "SetDown", "startUp", "SetUp", "startup", "startups", "setup", "setDown", " setups", "Setups", " setup", "Setup"], "connectionDigestHandler": ["connectionDigesterPath", "connectionDigistPath", "connectionDesterPath", "connectionDigesterHandler", "connectionDesterHandler", "connectionDigistHandler", "connectionDigessBase", "connectionDigessHandler", "connectionDestBase", "connectionDigestPath", "connectionDigistBase", "connectionDesterManager", "connectionDesterBase", "connectionDigessManager", "connectionDigesterManager", "connectionDigestManager", "connectionDestPath", "connectionDigesterBase", "connectionDestHandler", "connectionDigessPath", "connectionDigestBase", "connectionDigistManager", "connectionDestManager"], "url": ["ls", "page", "log", "ssl", "uri", "e", "resource", "server", "image", "ll", "b", "connection", "loc", "link", "blog", "channel", "impl", "f", "result", "tool", "www", "URL", "bel", "conn", "jar", "source", "config", "client", "l", "web", "use", "db", "base", "user", "object", "cache", "address", "string", "service", "ob", "sl", "host", "bug", "location", "Url", "path", "secure", "http", "feed", "open"], "uc": ["fd", "log", "uu", "loc", "aw", "rc", "tc", "org", "username", "bc", "result", "acc", "mc", "ch", "feed", "auc", "cc", "instance", "config", "oc", "https", "name", "ou", "Url", "hub", "cr", "bb"]}}
{"id1": "10504714", "id2": "22411381", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getFromPUri", "getFromURuri", "getfromPUUrl", "getFromURUrl", "getFromPUuri", "getFromUuri", "getFromRuRI", "getFromPUUrl", "getFromRuri", "getfromPUri", "getFromURI", "getFromRuuri", "getfromUuri", "getFromRuUrl", "getfromPURI", "getFromUUrl", "getFromURRI", "getfromUri", "getFromURri", "getFromPURI", "getfromURI", "getfromPUuri", "getfromUUrl"], "url": ["ur", "ls", "page", "proxy", "request", "uri", "ssl", "resource", "ll", "server", "image", "build", "loc", "info", "data", "username", "result", "rule", "route", "str", "URL", "www", "href", "type", "download", "i", "source", "src", "filename", "l", "lr", "base", "id", "email", "address", "string", "language", "file", "name", "sl", "host", "full", "layer", "location", "Url", "path", "buffer", "http", "feed", "ri"], "connection": ["proxy", "writer", "uri", "image", "j", "server", "communication", "b", "io", "socket", "part", "channel", "in", "Connection", "application", "bc", "connect", "ion", "index", "translation", "password", "conn", "connected", "i", "config", "network", "client", "directory", "section", "db", "number", "position", "object", "which", "character", "con", "c", "handler", "service", "relation", "context", "function", "response", "condition", " Connection", "collection", "http", "use", "database"], "bin": ["border", "bon", "ban", "b", "body", "data", "bit", "socket", "bc", "channel", "in", "output", "brain", "input", "bis", "ran", "din", "inn", "bean", "container", "conn", "abi", "plugin", "sin", "win", "src", "ruby", "login", "inner", "base", "bn", "file", "binary", "lib", "pin", "bot", "bi", "buffer", "spin", "bb", "database"], "jaxbContext": ["jaxaText", "jaxfContext", "jjbChannel", "jaxfcontext", "jaxfText", "jaxfbContext", "japbText", "jjbText", "jaxeSupport", "jaxfChannel", "japaContext", "japbContext", "jaxpChannel", "jaxpContext", "jaxbChannel", "jaxeContext", "jaxaSupport", "jaxpText", "japaSupport", "jjfChannel", "jaxbText", "jaxfbText", "japbSupport", "japaText", "jjfContext", "jaxecontext", "japbcontext", "jaxbSupport", "jaxfSupport", "jjfText", "jaxfbChannel", "japacontext", "jaxacontext", "jjbcontext", "jaxeText", "jjfcontext", "jaxbcontext", "jaxaContext", "jaxfbcontext", "jaxpcontext", "jjbContext"], "unmarshaller": ["unmarshallER", "unmarshdalender", "unmarshallser", "unmarshALLiner", "unmarshallsers", "unmarshulleder", "unmarshdaler", "unmarshullender", "unmarshallender", "unmarshALLers", "unmarshallingetter", "unmarshulletter", "unmarshalliner", "unmarshdaleder", "unmarshaler", "unmarshalletter", "unmarshaliner", "unmarshuller", "unmarshalleder", "unmarshALLER", "unmarshalers", "unmarshallers", "unmarshallingender", "unmarshallsER", "unmarshallsiner", "unmarshalER", "unmarshallingeder", "unmarshallinger", "unmarshdaletter", "unmarshALLer"]}}
{"id1": "62362", "id2": "20855053", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "14168494", "id2": "300397", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferClass", "copyfile", " copyfile", " copyClass", " copiedClass", "transferfile", " copiedFile", "copyFiles", "copyClass", " copiedFiles", " copiedfile", "transferFiles", "transferFile"], "dest": [" Dest", "txt", "resource", "null", "st", "Dest", "loc", "destroy", "data", "later", "this", "output", "d", "done", "comb", "out", " destination", "temp", "source", "class", "dir", "true", "tmp", "target", "desc", "file", "obj", "dist", "sup", "name", "wb", "path", "transfer", "orig"], "src": ["url", "ssl", "rob", "copy", "master", "st", "loc", "Dest", "rc", "sync", "sb", "inst", "split", "rb", "storage", "cb", "s", "sq", "download", "sin", "source", "config", "tmp", "filename", "sub", "stream", "target", "slice", "sc", "sit", "bin", "file", "dist", "sup", "upload", "gb", "sl", "sel", "img", "ds"], "srcChannel": ["destChannel", "inputChannel", " srcCh", "rcButton", "distStream", " srcButton", "rcCh", "rcChan", "sourceChannel", "srcCh", "srcChan", "distChan", "rcConnection", "srcButton", "distCh", "rcSection", "sourceButton", "inputchannel", "destchannel", "distChannel", " srcchannel", "sourcechannel", "inputConnection", "rcchannel", "destConnection", "srcStream", "rcChannel", "srcchannel", "srcConnection", "sourceChan", "srcSection", "inputSection", " srcSection", " srcConnection", " srcChan", "destChan", "rcStream", " srcStream"], "dstChannel": ["dstsStream", "ddestStream", " dstchannel", "drdChan", "dstchannel", "dsrcVideo", "ddestVideo", "drdchannel", "ddestchannel", " drdchannel", " dstStream", "ddestChannel", "drcVideo", "ddestContext", "dstChan", "dstConnection", "drcchannel", " dstsChannel", "dstsChannel", " dstsConnection", "dDestConnection", "dDestchannel", "dstContext", "dDestStream", "dstschannel", "drcContext", "DstChannel", "DstVideo", "DdestChannel", "DdestVideo", "ddestChan", "dsrcChannel", " drdContext", " dstConnection", " dstschannel", "dstVideo", "drcChan", " dstContext", "drdChannel", " dstsStream", "dsrcchannel", "drcChannel", "dDestChannel", "dstStream", "ddestConnection", "Ddestchannel", " dstChan", " drdChan", "dstsConnection", " drdChannel", "Dstchannel", "drdContext"]}}
{"id1": "771802", "id2": "1188100", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createOutputSteam", " createOutputSteam", " createInputSteam", " createIOSteam", " createByteFile", " createInputFile", "createOutputFile", "createInputReader", " createByteSteam", " createInputReader", " createByteStream", " createInputStream", "createInputFile", "createInputStream", " createIOFile", " createIOReader", " createByteReader", " createOutputFile", " createIOStream", "createOutputReader", " createOutputReader", "createInputSteam"], "inFile": ["incFiles", "infile", "insFile", "insfile", "inputFile", "inStream", "outFiles", "insFiles", "insStream", "incfile", "sourceFile", "outStream", "outfile", "sourcefile", "inputStream", "inputfile", "incStream", "incFile", "sourceFiles", "inputFiles", "inFiles", "sourceStream"], "outFile": [" outfile", "infile", "outTime", "workTime", "inputFile", "inTime", "workingStream", "workFile", "outDir", "targetStream", "workfile", "workingDirectory", "workingfile", "outStream", "outfile", "inDir", " outStream", "targetfile", "outDirectory", "targetFile", "workDir", "inputDir", "workingFile", "targetDirectory", "inputTime", "inputfile", " outDirectory"], "k_blockSize": ["k_byteCode", "k_byteLength", "k_lockCode", "k_lockLen", "k_bitCount", "k_BlockLength", "k_lockLength", "k_blockCode", "k_blockLen", "k_BlockSize", "k_BlockCount", "k_lineCount", "k_lockCount", "k_lineInfo", "k_lockSize", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_blockInfo", "k_lineSize", "k_blocksLength", "k_BlockCode", "k_byteLen", "k_byteSize", "k_blockCount", "k_blockLength", "k_byteInfo", "k_bitInfo", "k_byteCount", "k_bitSize"], "byteCount": ["ByteSum", " bytecount", "characterLength", " byteSize", "blockSize", " byteLen", "Bytecount", "characterLen", "ByteSize", "ByteLen", "flushcount", "flushCount", "byteSum", " byteSum", "ByteCount", "blockSum", "flushSize", "byteLen", "blockCount", "characterCount", "ByteLength", "flushLength", "byteLength", " byteLength", "blockLength", "bytecount", "characterSize", "byteSize"], "buf": ["fd", "border", "font", "cap", "cv", "uf", "append", "background", "b", "cmd", "loc", "rc", "fb", "data", "bh", "Buffer", "result", "bag", "rb", "batch", "feed", "bytes", "Buff", "cb", "cas", "alloc", "bf", "flush", "src", "config", "tmp", "buff", "len", "base", "queue", "la", "ucc", "vec", "brace", "ctx", "buffer", "exc", "seq", "feat", "img"], "ofp": ["Ofc", "afp", "OFl", "ofc", "fortp", "ofl", "forc", "afc", "fort", "ofnp", "afnp", "OFnp", "Oftp", "OFt", "Ofnp", "afl", "OFtp", "OFp", "OFc", "oft", "Ofl", "forp", "Ofp", "oftp", "Oft"], "zos": ["rons", "ogl", "kos", "core", "zh", "tz", "osi", "iframe", "owicz", "zag", "zers", "rez", "outs", "los", "gz", "zer", "bitcoin", "dylib", "webkit", "zon", "utils", "bs", "ros", "js", "z", "fits", "iffs", "obs", "ossus", "enos", "ozo", "zona", "zip", "bos", "zes", "oses", "zik", "lol", "bes", "zar", "zb", "ZI", "zx", "oda", "zy", "ops", "zi", "budget", "inos", "css", "ls", "zyk", "modules", "zo", "zen", "ses", "nox", "zig", "cfg", "ZA", "os", "jas", "uz", "zn", "nz", "cos", "robe", "liquid", "lins", "zin", "ws", "oS", "abi", "zl", "hz", "za", "forge", "packs", "obb", "soon"], "osw": ["ossnow", "isy", "osy", "esfw", "issw", "lsx", "eshell", "osws", "osow", "osswd", "oswd", "ishell", "lswo", " osfw", "iswd", "isw", "osshell", "osx", "lsws", "osnow", "osfw", "ossw", "isnow", "esw", " osww", "esd", "bx", "ossfw", "bws", "osww", "bwo", "ossd", "ossy", "oswo", "esow", " osow", "oshell", "isd", "bsws", "ossow", "osssw", "essw", "esww", "eswd", "esy", "osd", "bsx", "bsw", "bswo", "ossww", "esnow", "lsw"], "bw": ["bbz", "lbw", " bwa", "lx", "ebW", "fr", "fbW", "bz", "fsw", "lbz", "bwe", "ebwd", " bws", "bW", "ebw", "fbwe", "Bws", "bbwa", "Bw", "lbwa", "bew", "abw", "bbew", " baw", "abW", "Bwa", "bbwu", "lbsw", "ow", "fwa", "bwh", "fbw", "owa", " bwh", "abwe", "ebwe", "bx", "lbx", "bws", "fbwd", "Bew", "fx", " bew", "fw", "lbwh", "bwu", "owu", "fwh", "baw", "lwa", "bbws", "abwd", "bwa", "bbwh", "lbws", " bwu", "lw", "bwd", "bsw", "oaw", "lbr", "bbw", "bbaw", " bz", "lsw"], "zot": ["Zor", "zor", "jot", "Ziot", "zori", " zor", "azita", "azott", "zeros", "aziot", "ziot", "Zit", "jos", "jit", "zerott", "jori", "azor", "zerita", " zori", "zita", "zerori", "zott", "zerit", "Zita", "zerot", "azit", "Zot", "Zott", " ziot", "azot"], "ifp": ["Iff", "ifb", " ifi", "ipb", "IFb", "Ifi", " ifl", "ipp", "Ifc", " ifb", "ifl", "ipc", "ipl", "ifc", "ifi", "iff", "IFc", "IFl", " ifc", " iff", "IFi", "Ifp", "IFp", "IFf"], "zis": ["jits", "zisi", "jisi", "zIS", "zib", "xits", "zipis", "xais", "xit", " zits", "ziss", "xis", "zipits", "zenis", "zenib", "zeip", "zipip", "zipiss", "xisi", "zip", "Ziss", "zeits", "Zis", "jit", "xIS", "zeis", " zisi", "zits", "zenIS", "Zip", " zais", " zIS", "zais", "Zits", "zenais", " zib", "jis", "zeiss", "xib"], "isr": ["IScr", "irrb", "irrc", "irr", "ISr", "rispr", " issr", "ISsr", "risr", "ISrs", "risrc", "issrs", " isrs", "iscr", "ISrb", "risrb", "isrs", "irpr", " iscr", "ISrc", "isrb", "ISpr", "isssr", "isscr", "ispr", "issr", "isrc"], "br": ["kr", "obl", "bsp", "bro", "fr", "arr", "shr", "b", "body", "mr", "rs", "yr", "bh", "bp", "bc", "obi", "str", "HR", "cro", "rb", "ch", " BR", " Br", "BR", "rib", "lr", "ber", "bar", "tr", "r", "ctr", "div", "err", "ocr", " fr", " dr", "sr", "ibl", "gr", "ob", "sp", "hr", "bl", "Br", "ibr", "img", "browser"], "zit": ["jits", "zipita", "zIT", "zeith", "zenith", " zip", "xit", "zenitter", " zits", "zipits", "zitter", "jith", "jite", "xith", "jIT", "zipip", "zic", "zip", "xic", "zeits", " zi", "zipit", " zith", "jit", "zite", "jic", "zipith", "zenit", "zith", "ji", "zits", " zic", "zipite", "zeit", "zita", "zenits", "xi", "jita", " zite", "zipitter", "jip", "zi", "zeIT", "zipIT", "zeitter", "zeita"]}}
{"id1": "3375722", "id2": "8953394", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "label": 1, "substitutes": {"importarSetor": [" importTarsetor", " importTarSetorn", " importTarSetor", " importarStructor", " importarsetor", " importarSetorn", " importarStructutor", " importTarsetori", " importTarsetutor", " importarStructorn", " importarsetori", " importarProcessorn", " importarStructori", " importarsetorn", " importarProcessutor", " importTarsetorn", " importTarSetori", " importarSetutor", " importarProcessor", " importarProcessori", " importarSetori", " importarsetutor", " importTarSetutor"], "pArquivoXLS": ["pArquivaEXls", "pArquivoTXSL", "pArquivoXls", "pArquivaEXLS", "pArquivoTXLS", "pArquivoZXls", "pArquivaXML", "pArquivoYCL", "pArquivoTXCL", "pArquivoEXML", "pArquivoZXSL", "pArquivoYls", "pArquivoYML", "pArquivaXSL", "pArquivaXCL", "pArquivoXSL", "pArquivoEXSL", "pArquivaXls", "pArquivoEXCL", "pArquivoXML", "pArquivoZXLS", "pArquivaEXML", "pArquivoEXls", "pArquivoEXLS", "pArquivaXLS", "pArquivoZXML", "pArquivaEXCL", "pArquivoXCL", "pArquivoTXls", "pArquivaEXSL", "pArquivoYLS", "pArquivoTXML"], "pCabecalhoSetor": ["pCabecalhaSetor", "pCabecalhoSelector", "pCabecalhaSelecte", "pCabecalhaSete", "pCabecalhoSetors", "pCabecalhoSelectors", "pCabecalhoEditors", "pCabecalhaSelector", "pCabecalhoEditeur", "pCabecalhoSelecteur", "pCabecalhoEditor", "pCabecalhoSeteur", "pCabecalhoSelecte", "pCabecalhaSeteur", "pCabecalhaSelecteur", "pCabecalhoSete", "pCabecalhaSelectors", "pCabecalhoEdite", "pCabecalhaSetors"], "pAndamento": ["pAndamentO", "pAndementono", "pOramentos", "pAndmentono", "pOramentono", "pOrementos", "pAndamentos", "pAndietono", "pAndementO", "pAndietos", "pOremento", "pOrementono", "pOramento", "pAndmento", "pAndietO", "pAndemento", "pAndamentono", "pAndmentos", "pAndieto", "pOramentO", "pOrementO", "pAndementos", "pAndmentO"], "iLinha": ["iPlanha", "iFranha", "NumLinha", "iPlanHa", "NumPlanya", "iMalHa", "iMalya", "NumLinya", "iLineno", "iFranHa", "NumLineno", "iLinya", "iLinHa", "iMalha", "iFranya", "iPlanya", "NumPlanha", "NumLinHa", "NumPlaneno", "NumPlanHa", "iFraneno", "iMaleno", "iPlaneno"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialESTination", "stmtLimpezaIniciodestino", "stmtLimpezaInicialDesania", "stmtLimpezaInicialdestino", "stmtLimpezaIniciadestaco", "stmtLimpezaInicialESTaco", "stmtLimpezaInicialCombina", "stmtLimpezaInicioDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialdestin", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestina", "stmtLimpezaInicialDesination", "stmtLimpezaInicialDestination", "stmtLimpezaIniciadestination", "stmtLimpezaInicialdestaco", "stmtLimpezaIniciodestaco", "stmtLimpezaInicialCombino", "stmtLimpezaInicialDesINO", "stmtLimpezaInicioDestINO", "stmtLimpezaIniciodestination", "stmtLimpezaIniciodestania", "stmtLimpezaInicialDestina", "stmtLimpezaInicialESTino", "stmtLimpezaInicioDestania", "stmtLimpezaIniciadestin", "stmtLimpezaInicialDestINO", "stmtLimpezaIniciaDestin", "stmtLimpezaIniciadestino", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialCombINO", "stmtLimpezaInicialESTin", "stmtLimpezaInicialDestaco", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialdestina", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialdestINO", "stmtLimpezaInicioDestination", "stmtLimpezaIniciaDestino", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialDestania", "stmtLimpezaIniciodestina", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialdestania", "stmtLimpezaInicialDestin"], "stmtDestino": ["stmtdestin", "stmtRestINO", "stmrdestinning", "stmpDestino", "stmdestino", "stmtCombINO", "stmtRestinning", "stmtRestin", "stmtCombino", "stmDestin", "stmtdestino", "stmdestinos", "stmpdestINO", "stmpdestorno", "stmtdestinos", "stmpdestaco", "stmpDestorno", "stmtDistINO", "stmpDestaco", "stmrDestinning", "stmtDestINO", "stmrdestINO", "stmtDistaco", "stmtLocationINO", "stmtLocationaco", "stmpDestINO", "stmtDestin", "stmtRestinos", "stmtRestino", "stmtCombin", "stmtdestaco", "stmtDestorno", "stmpdestino", "stmDestino", "stmtDestinos", "stmrdestaco", "stmtDestinning", "stmtdestorno", "stmtDestaco", "stmrDestINO", "stmDestINO", "stmtDistorno", "stmDestinos", "stmtRestaco", "stmtdestINO", "stmtCombinos", "stmrDestaco", "stmtDistino", "stmdestINO", "stmrdestino", "stmtdestinning", "stmdestin", "stmtLocationinning", "stmrDestino", "stmtLocationino"], "arquivo": ["arQUico", " ar\u00e7ivo", " arqiva", "Arqoso", " ar\u00e7icio", "arQUiva", "arqico", " arquiva", " ar\u00e7arius", "arquarius", "arQuivo", "Arquiva", "Arqiva", " ar\u00e7iva", "Arqivo", "arquico", "arqicio", " arqivo", "arQuiva", " arqicio", "arqiva", " arQuiva", "arquoso", " arQuarius", "arqarius", "arQuico", "arquiva", " arquicio", " arQuivo", "arQUoso", " arqarius", "arQuoso", "arqivo", " arquarius", " arQuicio", "arquicio", "Arquoso", "arQUivo", "Arqico", "arqoso", "Arquico", "Arquivo"], "plan1": ["Plan0", "Plan2", "plan2", " Plan0", " plan0", " planName", " plan2", "planOne", " planOne", "PlanName", "plan0", "planName", " Plan1", "product2", "productName", "product0", " Plan2", " PlanOne", "Plan1", "PlanOne", "product1"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTROAD", "QUANTIDADE_DE_REGISTROSAD", "QUANTIDADE_DE_REGISTEROAD", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRASAD", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTERO__", "QUANTIDADE_DE_REGISTRO__", "QUANTIDADE_DE_REGISTEROSAD", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosAD", "QUANTIDADE_DE_REGISTRONS_", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRATES__", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRONS__", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTROsEC", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRYAS_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTROsJ", "QUANTIDADE_DE_REGISTRYOS_", "QUANTIDADE_DE_REGISTRYOSJ", "QUANTIDADE_DE_REGISTRYASJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRosEC", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTROID", "QUANTIDADE_DE_REGISTRES_", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTRON_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRATESJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRATESEC", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRESEC", "QUANTIDADE_DE_REGISTEROID", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTEROSID", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRONID", "QUANTIDADE_DE_REGISTRosID", "QUANTIDADE_DE_REGISTRESJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTROSID"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivator", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstimmator", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstifator", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstifado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimator", "quantidadeDeRegistrosEstimmado"], "vSetor": ["vSetoring", "vSelector", " vSete", "vShipe", "vSelecte", " vSetoring", "vSelectoring", "vSete", "vShipor", "vSetors", "vShiporing", "vSelectors", " vSetors", "vShipors"], "vSubsetor": ["vSubjectors", "vSubscor", "vSubseto", "vSubscriptor", "vSubscr", "vSubsco", "vsubsetor", "vSubjector", "vsubsetr", "vSubscors", "vsubscors", "vSubscripto", "vsubscor", "vsubsco", "vSubjecto", "vSubscriptors", "vSubjectr", "vsubscr", "vSubsetors", "vSubscriptr", "vSubsetr", "vsubsetors", "vsubseto"], "vSegmento": ["vSegMENTo", "vGamentos", "vSegmenta", "vSegMENTos", "vSegamentos", "vSegamento", "vSegmentationor", "vGamentor", "vSegmentationa", "vSegMENTor", "vGmentor", "vGmenta", "vSegamenta", "vGamenta", "vSegmentationo", "vGmento", "vGamento", "vGmentos", "vSegMENTa", "vSegmentationos", "vSegmentos", "vSegmentor", "vSegamentor"], "registroAtual": ["RegistroAtual", "Registroatual", "RegistroGenual", "Registrosatial", "RegistroGenional", "RegistroGenUAL", "RegistroExional", "RegistroGenial", "RegistroatUAL", "RegistrosAtUAL", "Registroatial", "RegistrosAtial", "RegistroAtUAL", "RegistrosatUAL", "RegistroExual", "RegistrosAtual", "Registroational", "RegistrosAtional", "RegistroAtional", "Registrosational", "RegistroExUAL", "Registrosatual", "RegistroExial", "RegistroAtial"], "vPapeisPorSegmento": ["vPapeisPorSegmente", "vPapeisPorSegmentsor", "vPapeisPorSegmentor", "vPapeisPorSegmentos", "vPapeisPorSegmentationos", "vPapeisPorSegamentor", "vPapeisPorFragmento", "vPapeisPorSegamento", "vPapeisPorSegmentationo", "vPapeisPorSegmentatione", "vPapeisPorFragmente", "vPapeisPorFragmentsos", "vPapeisPorSegmentationor", "vPapeisPorFragmentsor", "vPapeisPorFragmentso", "vPapeisPorFragmentos", "vPapeisPorFragmentse", "vPapeisPorSegamente", "vPapeisPorSegmentsos", "vPapeisPorFragmentor", "vPapeisPorSegmentse", "vPapeisPorSegmentso", "vPapeisPorSegamentos"], "sql": ["ls", "sol", "description", "statement", "log", "http", "ln", "url", "ssl", "install", "sf", "html", " SQL", "script", "body", "term", "os", "sv", "acl", "data", "msg", "shell", "csv", "QL", "sb", "spec", "zip", "str", "sn", "nl", "s", "sq", "dl", "pr", "comment", "section", "seed", "sg", "db", "base", "eps", "slice", "id", "layout", "string", "params", "select", "sl", "spr", "json", "query", "setup", "where", "util", "serv", "SQL", "ql"]}}
{"id1": "4982745", "id2": "22320592", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"doJSONRequest": [" doHTTPResponse", "doAPIOperation", "doJSONOperation", " doHTTPRequest", "doAPIRequest", "doHTTPRequest", "doHttpRequest", "doAPIResponse", "doJSONCall", "doHttpResponse", "doAPICall", " doJSONOperation", "doHTTPCall", " doHTTPOperation", "doHttpCall", "doHTTPResponse", "doHTTPOperation", " doHTTPCall", "doHttpOperation", " doJSONCall", "doJSONResponse", " doJSONResponse"], "jsonRequest": ["jsonQuery", "JSONRequest", "JSONResponse", "JSONQuery", "httpQuery", " jsonrequest", "httpResponse", "httprequest", "sonrequest", "sonResponse", "httpRequest", "sonRequest", "JSONrequest", "sonQuery", " jsonQuery", "jsonrequest"], "request": ["proxy", "pe", "req", "p", "friend", "url", "uri", "resource", "message", "server", "call", "e", "parent", "complete", "report", "connection", "event", "method", "child", "hello", "application", "document", "result", "input", "Request", "claim", "type", "xml", "temp", "rest", "builder", "create", "api", "QUEST", "push", "client", "er", "worker", "command", "user", "queue", "r", "object", "question", "upload", "re", "service", "php", "get", "json", "query", "condition", "transfer", "trip", "operation", "q", "head", "http", "post"], "params": ["ls", "param", "padding", "array", "url", "lp", "ssl", "default", "eters", "server", "copy", "details", "manager", "par", "ps", "stats", "rs", "acl", "options", "arms", "parts", "session", "parser", "headers", "phrase", "plugins", "Parameters", "password", "settings", "apter", "results", "xml", "posts", "api", "config", "properties", "parse", "tmp", "ip", "pps", "ras", "resources", "eps", "mac", "cache", "phys", "names", "address", "handler", "mm", "ams", "ctx", "rules", "json", "afi", "services", "http", "p", "database", "ds"], "entity": ["activity", "ale", "pe", "attribute", "component", "ee", "url", "e", "resource", "server", "image", "connection", "Entity", "event", "ue", "data", "ge", "output", "model", "document", "entry", "result", "oe", "ga", "translation", "ent", "type", "el", "element", "instance", "issue", "xml", "api", "client", "node", "object", "address", "cache", "string", "eme", "security", "environment", "json", "query", "content", "om", "person"], "t": ["at", "m", "u", "e", "wt", "g", "tz", "n", "tc", "tl", "ot", "started", "ut", "tm", "duration", "f", "it", "tt", "o", "set", "d", "ent", "ta", "the", "test", "type", "tf", "utt", "s", "h", "T", "time", "i", "tools", "te", "y", "l", "len", "tim", "et", "r", "tick", "ti", "tp", "v", "c", "tu", "ts", "w", "mt", "tw", "ty", "lt", "p", "dt"], "response": ["wave", "resp", " Response", "page", "res", "respond", "message", "resource", "server", "image", "Response", "connection", "body", "successful", "data", "output", "application", "status", "document", "result", "block", "reply", "error", "results", "object", "string", "v", "success", "service", "relation", "full", "generation", "json", "location", "value", "collection", "http", "feed", "ception", "onse"], "responseString": ["errorText", "ResponseString", "errorStr", "ResponseData", "resultStr", " responsestring", "resultText", "errorString", "errorObject", "helloText", "responseData", "resultString", "ResponseText", "ResponseBytes", " responseBytes", "responsestring", "responseStr", "Responsestring", " responseStr", "responseObject", " responseObject", "resourceData", "resourceString", "responseBytes", " responseData", "ResponseObject", "responseText", "helloString", "ResponseStr", " responseText", "resourceStr", "resultData", "resourcestring", "helloBytes"], "jsonResponse": ["JSONResult", "JSONRequest", " jsonEvent", "JSONResp", "xmlresponse", "sonSession", "JSONResponse", "sonApplication", "journalResp", "journalresponse", "jsonRes", "journalResponse", "javascriptPage", " jsonRes", "jsonSession", "xmlError", "jsonResult", "responseResult", "jsonEvent", "responseResp", "xmlResponse", "JSONPage", "javascriptRes", "jsonResp", "jsonresponse", "sonError", "javascriptRequest", "xmlResp", "jsonPage", " jsonSecret", " jsonBlock", "sonResp", "jsonView", "jsonBlock", "sonResponse", "responseView", "JSONView", " jsonResp", "journalApplication", " jsonresponse", "serverError", "sonBlock", "responseResponse", "journalError", "journalRequest", "sonresponse", "xmlBlock", " jsonPage", "JSONRes", "journalSecret", " jsonApplication", "serverResponse", "sonRequest", "xmlSession", "jsonSecret", "sonSecret", "serverresponse", "serverSession", "xmlView", "jsonApplication", "xmlResult", "sonEvent", "xmlEvent", "javascriptResponse"], "jsonError": [" jsonMessage", "sonResult", " jsonerror", "journalResponse", "journalException", "journalerror", "xmlError", "jsonResult", "sonerror", " jsonException", "xmlResponse", "sonError", "sonMessage", "sonResponse", " jsonResult", "journalError", "jsonException", "jsonMessage", "jsonerror", "sonException", "xmlMessage", "xmlResult"]}}
{"id1": "6625074", "id2": "614099", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"SHA1": ["SHA384", "HA256", "sha1", "sha256", " SHA384", "SHAOne", "HA384", "HA1", "SHA256", " SHA256", "shaOne", "sha384", "HAOne", " SHAOne"], "text": ["font", "txt", "message", "image", " Text", "plain", "struct", "letter", "data", "in", "output", "input", "str", "editor", "hex", "translation", "password", "template", "bytes", "test", "out", "code", "class", "source", "config", "TEXT", "object", "token", "string", "obj", "name", "pattern", "context", "path", "transfer", "word", "content", "value", "format", "buffer", "ext", "contract", "Text"], "sha1hash": ["sha6hash", "sha6Hash", "sha2hex", "SHA1hash", "sha1log", "SHA2Hash", "sha_hex", "SHA1cap", "sha81cap", "sha1hex", "sha6log", "SHA2hash", "sha_Hash", "shaOnetext", "sha1Hash", "SHA2log", "shaOnepassword", "sha2hash", "ha1hash", "sha2Hash", "shaOneHash", "sha81hash", "sha256password", "sha2sum", "ha2Hash", "sha1sum", "sha2cap", "SHA1Hash", "SHA2cap", "SHA1password", "sha2log", "shaOnehash", "ha2hex", "sha1text", "sha_sum", "SHA1text", "sha1password", "sha81log", "SHA1log", "sha_hash", "ha1Hash", "ha1hex", "sha256text", "ha2hash", "sha256hash", "ha2sum", "sha1cap", "ha1sum", "sha256Hash", "sha81Hash", "sha6cap"], "md": ["m", "rm", "hd", " MD", "nd", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "f", "rpm", "hash", "editor", "mc", "mag", "d", "vd", "od", "ms", "meta", "hm", "wd", "mb", "amd", "nm", "dm", "bd", "pkg", "metadata", "pd", "MD", "ad", "de", "mac", "mm", "ma", "gb", "sm", "ld", "pm", "cf", "cd", "mt", "df"]}}
{"id1": "2017833", "id2": "20208819", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["replace", "crypt", "ash", "message", "html", "build", "sha", "check", "str", "hex", "set", "sum", "h", "create", "add", "print", "parse", "dump", "number", "base", "transform", "string", "Hash", "get", "format", "update", "block"], "text": ["font", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "output", "input", "str", "editor", "hex", "translation", "password", "template", "bytes", "key", "out", "test", "code", "source", "class", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "context", "path", "word", "content", "ext", "format", "buffer", "value", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedencodedWarning", "Unsupportedencodingception", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedencodingWarning", "UnsupportedEncasingWarning", "UnsupportedEncgorithmException", "UnsupportedEncasingException", "UnsupportedEncgorithmception", "UnsupportedEncodingWarning", "UnsupportedEncgorithmWarning", "Unsupportedencodedception", "UnsupportedEncodedWarning"], "md": ["mad", "m", "rm", "hd", " MD", "message", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "gd", "f", "mc", "mag", "d", "vd", "od", "meta", "ms", "hm", "wd", "mb", "amd", "mg", "dm", "bd", "bf", "metadata", "bm", "MD", "ad", "mac", "ind", "nm", "mand", "mm", "ma", "am", "ld", "pm", "mt", "mod", "ds"], "sha1hash": ["sha2h", "sha2hex", "SHA2Hash", "SHA1hash", "sha1hex", "ha1match", "sha4Hash", "shaonehash", "SHA2hash", "ha2match", "ha1hash", "sha1Hash", "sha3hash", "sha2hash", "sha3match", "sha2Hash", "SHA2sum", "sha4hex", "sha5h", "SHA1h", "sha5hex", "sha2sum", "SHA2h", "sha1sum", "SHA1Hash", "shaonematch", "sha1h", "SHA1sum", "ha2hex", "sha3hex", "sha5sum", "sha256h", "sha5Hash", "sha2match", "sha256sum", "sha5hash", "ha1hex", "sha4sum", "ha2hash", "shaonesum", "sha3sum", "sha1match", "sha256hash", "ha2sum", "ha1sum", "shaonehex", "sha256Hash", "sha4hash", "SHA1hex"]}}
{"id1": "7872659", "id2": "14231545", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieindexFiles"], "completePath": ["execpath", "completeMusic", " completeRoot", " CompleteDir", "CompleteFile", "flatPath", "CompleteHome", " completeFile", "completeLoader", "correctPoint", " CompleteHome", "successpath", "donepath", "CompleteDir", " completePoint", "successPath", " completeMusic", "successCh", "itepath", "completeCh", "doneLoader", "progressVol", " CompletePath", " completeCh", " completepath", "completeVol", "completepath", "execPath", "doneVol", "iteMusic", "flatPoint", " completeDir", "completePoint", " completeHome", "progressPath", "flatRoot", "execLoader", " CompleteFile", "completeDir", "itePath", "flatCorp", "iteCh", "completeHome", "execVol", "correctPath", "donePath", "correctRoot", "completeFile", "progresspath", "completeRoot", "successMusic", "progressLoader", "correctCorp", "completeCorp", "CompletePath", " completeCorp"], "masterFile": ["MasterFile", "MasterFilename", "masterPath", "MasterName", "masterName", " masterFilename", "cachePath", "masterFILE", "configName", "masterFilename", "cacheFile", "MasterPath", "mastersPath", "mastersFile", "MasterFILE", "cacheFILE", " masterName", "configFilename", "MasterFiles", "mastersFILE", " masterPath", "cacheFiles", "configFile", "masterFiles", "configPath", "mastersFiles"], "CustRatingFileName": ["CustRateFileSize", "CustRatingFilesName", "CustRatingFullDesc", "CustIndexFilePath", "CustRateFilePath", "CustRatingFileDesc", "CustIndexFileVersion", "CustRatingFileVersion", "CustRatingLinePath", "CustRatingClassType", "CustRatingFullPath", "CustRateFilenameSize", "CustRatingLineVersion", "CustRatingClassVersion", "CustIndexFileType", "CustRatingFilesDesc", "CustIndexFilesVersion", "CustRatingLineType", "CustRatingFullSize", "CustRatingFilenameSize", "CustRatingFileSize", "CustRateFileName", "CustRatingLineName", "CustIndexFilesType", "CustRatingClassPath", "CustRateFileDesc", "CustRatingFilesType", "CustIndexFilesPath", "CustRateFilenameDesc", "CustRateFilenameName", "CustIndexFilesName", "CustRatingFilesVersion", "CustRatingFilenamePath", "CustRatingFilesSize", "CustRatingFilenameDesc", "CustRatingFilesPath", "CustRatingFileType", "CustIndexFileName", "CustRatingClassName", "CustRatingFilePath", "CustRateFilenamePath", "CustRatingFilenameName", "CustRatingFullName"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFileName", "MovieIndexFilesUrl", "MovieEditFName", "MovieIndexFILEName", "MovieIndexClassname", "MovieIndexFileSize", "MovieIndexFilesSize", "MovieIndexPlaceName", "MovieEditFname", "MovieIndexFilesName", "MovieIndexFilesname", "MovieIndexFileHandle", "MovieIndexFolderName", "MovieIndexFILEFile", "MovieEditFileName", "MovieEditFileSize", "MovieIndexFolderVersion", "MovieIndexFILEVersion", "MovieConfigFolderName", "MovieIndexFolderFile", "MovieEditFileUrl", "MovieIndexFilename", "MovieIndexClassSize", "MovieIndexFileVersion", "MovieIndexFileUrl", "MovieIndexPlaceVersion", "MovieIndexPlaceHandle", "MovieIndexFILEHandle", "MovieIndexClassUrl", "MovieEditFSize", "MovieIndexClassName", "MovieEditFilename", "MovieIndexFname", "MovieConfigFileHandle", "MovieConfigFileFile", "MovieIndexFUrl", "MovieIndexFSize", "MovieConfigFolderHandle", "MovieIndexFolderHandle", "MovieConfigFolderVersion", "MovieEditFUrl", "MovieIndexFileFile", "MovieConfigFileVersion", "MovieIndexFName", "MovieConfigFolderFile"], "inFile": ["InFile", "incC", "infile", "inputFile", " inSourceFile", "inputSourceFile", "incfile", "outfile", "Infile", "outSourceFile", "InSourceFile", "inputfile", "incSourceFile", "incFile", "InF", "outFile", "outC", " inF", "inF", "inSourceFile", "inputF", " infile"], "inC": ["innerC", "InFile", "outCI", "outF", " inCL", " inCC", "inputCC", "inCL", "inputFile", "outCC", "InCI", "innerCC", "inCC", "InCC", "inCI", "inB", "innerFile", "InB", "InCL", " inB", "innerCI", "InF", "outFile", "outC", "outCL", " inF", "outB", "InC", "inputC", "inF", "inputF"], "outFile1": ["outPlace1", "outputFileId", "outputfile1", "againCFirst", "againC2", "againC1", "outputfile2", "outfileId", "outCFirst", "outPath3", "againFile3", "outF2", "outFiles2", "outputFile1", "outPlaceName", "outFileFirst", "outFileId", "outFileName", "outfileName", "againFile2", "againFile1", "outPath1", "outPathFirst", "outfile2", "outFiles1", "outputFileName", "outFiles3", "outFilesFirst", "outF1", "outPlaceId", "outFId", "outPath2", "againC3", "againFileFirst", "outputfileName", "outputFile2", "outFile3", "outputfileId", "outfile1", "outPlace2", "outC3", "outFName"], "outC1": ["outCF81", "outB2", "againB2", "outFOne", "outC81", "outC8", "againC2", "newc81", "againC1", "newc1", "outCFFirst", "newC81", "newCOne", "againB1", "outCFirst", "outDOne", "outD81", "outF2", "outD8", "outB8", "newcFirst", "outcOne", "outCF1", "outBOne", "outc1", "outDFirst", "againBOne", "newC1", "againB8", "outF1", "newCFirst", "outD2", "outB1", "outcFirst", "outCOne", "againCOne", "againC8", "newcOne", "outCFOne", "outF8", "outc81", "outD1"], "outFile2": ["outLine6", "againLine6", "outDirectory5", "outDirectory4", "againFile6", "outputfile2", "outFile6", "outChannelTwo", "outputFile5", "outDirectoryTwo", "outFiles4", "outFileTwo", "outputFile4", "outFiles2", "outChannel1", "outfile4", "outputfile5", "outLineTwo", "againLine2", "againFile2", "outputFileTwo", "againFile1", "outfile2", "outFiles1", "outputfileTwo", "outChannel6", "outFiles6", "outputfile4", "outfile5", "outFile4", "outputFile2", "outFilesTwo", "outFiles5", "outLine2", "outLine1", "outDirectory2", "outfileTwo", "outChannel2", "againLineTwo", "againFileTwo", "againLine1", "outFile5"], "outC2": ["outB2", "againB2", "outCache2", "againBTwo", "againC2", "againC1", "againB1", "OutF4", "outCache4", "outF2", "againC4", "outFileTwo", "outB4", "OutC2", "outFTwo", "outCTwo", "outCacheII", "OutC1", "outF1", "outC4", "outBTwo", "OutC4", "outFII", "OutFII", "outFile4", "outFileII", "outB1", "againB4", "againCTwo", "outF4", "OutF2", "OutF1", "outCache1", "outCII", "OutCII"], "fileSize": ["FileSIZE", " fileSIZE", "resourceAddress", " fileAddress", "FileMode", "resourceSIZE", "fileSIZE", " fileLength", "imageLength", " fileMode", "fileMode", "fileLength", "imageSIZE", "bufferMode", "FileSize", "fileAddress", "FileAddress", "FileLength", "resourceSize", "bufferSize", "imageSize", "bufferLength"], "totalNoDataRows": ["totalNoDataCows", "totalNoDataCOWS", "totalNoDataLows", "totalNoDataChues", "totalNoPageRrows", "totalNoPageLows", "totalNoDataROWS", "totalNoDataChows", "totalNoDataLrows", "totalNoPageLues", "totalNoPageRues", "totalNoDataCues", "totalNoDataChrows", "totalNoPageROWS", "totalNoDataRues", "totalNoPageLrows", "totalNoDataLOWS", "totalNoDataRrows", "totalNoPageRows", "totalNoDataCrows", "totalNoDataChOWS", "totalNoDataLues", "totalNoPageLOWS"], "mappedBuffer": ["Machedbuffer", "mppedChannel", "machedBuff", "mappingBuff", "mashedChannel", "Mappedbuffer", "mappedURL", "MappedBuff", "MappingBuff", "mappedChannel", "machedFile", "MachedBuffer", "mapedFile", "MappedURL", "mapedStream", "machedStream", "mippedStream", "MappedStream", "machedBuffer", "mapedURL", "mppedBuffer", "mappedStream", "mappingChannel", "mippedBuffer", "mappingStream", "mashedFile", "mappedBuff", "mashedBuff", "mappingbuffer", "mappedbuffer", "mashedBuffer", "machedbuffer", "mappingFile", "MachedStream", "mppedStream", "MachedURL", "MachedFile", "MappedBuffer", "mactedBuff", "MappingFile", "mppedBuff", "MappingChannel", "mappingBuffer", "MappedFile", "mapedBuffer", "mippedBuff", "machedURL", "MappedChannel", "mactedbuffer", "mappedFile", "mippedURL", "machedChannel", "MachedBuff", "mapedBuff", "MachedChannel", "mactedStream", "mactedBuffer", "MappingBuffer"], "startIndex": ["StartInfo", "startOffset", "useindex", "endPosition", " startPosition", "startInfo", " startCode", " startindex", "endInfo", "StartPosition", "startRow", " startOffset", "startingIndex", "StartIndex", "StartOffset", "useInfo", "startingSection", "startindex", "usePosition", "startPoint", "endSection", " startPoint", "endIndex", "stopIndex", "stopCode", " startSection", "useIndex", " startInfo", "endindex", "startSection", "startCode", "endRow", "endCode", "initindex", "startingPosition", "stopindex", "stopRow", "Startindex", "startPosition", "initInfo", "initIndex", " startRow", "endPoint", "startingPoint", "initOffset"], "count": ["Count", "col", "call", "length", "depth", "weight", "child", "more", "allow", "old", "part", "follow", "limit", "group", "loop", "all", "coll", "sum", "index", "key", "type", "test", "code", "time", "total", "i", "add", "max", "size", "thread", "keep", "self", "len", "number", "ind", "id", "found", "counter", "cache", "c", "start", "name", "find", "other", "list", "order", "pool", "first", "current", "close", "force"], "currentMovie": ["currentPicture", "parentMovie", "thisMovie", "thisPicture", "currentmovie", " currentImage", " currentFilm", "currentImage", " currentmovie", "reportedMusic", "currentlyMusic", "validMovie", "defaultMusic", "parentmovie", "reportedTheme", "defaultMovie", " currentMusic", "defaultFilm", "reportedmovie", "currentlyMovie", "validFilm", "currentFilm", " currentPicture", "currentlyPicture", "CurrentTheme", "defaultImage", "currentMusic", "currentTheme", "thisFilm", "CurrentFilm", "Currentmovie", "reportedImage", "reportedPicture", "parentFilm", "CurrentMovie", "parentPicture", "reportedFilm", "reportedMovie", "validmovie", "thismovie", "validTheme"], "movieName": ["voiceId", "MovieInfo", "filmFamily", "movieInfo", "voiceInfo", "voiceName", "filmNumber", "Moviename", "movieNumber", "MovieId", "voicename", "movieId", "moneyName", " moviename", "moviename", "MovieFamily", "moneyFamily", " movieFamily", "movieFamily", "camFamily", "MovieName", "camname", "moneyNumber", " movieInfo", "MovieNumber", "filmname", " movieId", "filmName", "camName"], "customer": ["CustomER", "mixER", " customeri", " customers", "customers", " customER", "Customer", "ustomeri", "customER", "ustomor", "Customers", "mixor", "ustomers", "ustomER", "mixers", "customor", "mixer", "Customor", "Customeri", "ustomer", "customeri"], "rating": ["setting", "attribute", "padding", "writer", "url", "resource", "rolling", "ring", "rate", "rc", "info", "data", "ranking", "writing", "reading", "rage", "range", "packing", "missing", "error", "score", "type", "comment", "reader", "ing", "ruby", "rr", "number", "feature", "r", "id", "string", "rated", "RC", "alpha", "rates", "Rating", "rank", "value", "http", "radius", "rice", "including"], "outBuf1": ["outKuf3", "outBafOne", "outDuff3", "outBum01", "outBuf91", "outBuff3", "outFuf91", "outKbuffOne", "outBiff01", "outBaf1", "outCuffOne", "outCuff0", "outBummerCloud", "outKbuff1", "outKbuf3", "outBbuf1", "outBbuf01", "outBum91", "outFafOne", "outBuff2", "outFuf01", "outCufOne", "outBuff0", "outFbuf1", "outBbuff8", "outFbuf91", "outBufOne", "outBummerOne", "outBufn", "outDufn", "outBiffOne", "outKuf2", "outBuff11", "outCuf1", "outBaf3", "outFafCloud", "outBumOne", "outBbuf91", "outCuf0", "outBaf0", "outBuf3", "outKuf1", "outBalth3", "outBaft3", "outFufCloud", "outBalth1", "outBafCloud", "outBum1", "outDuff1", "outBbufOne", "outBiff91", "outBuf11", "outBbuffOne", "outBbuff1", "outBummer1", "outBbuf3", "outDuff11", "outFuf1", "outBbuff3", "outCuff1", "outFufOne", "outKbuf1", "outBbuff0", "outKbuff3", "outKbuff8", "outBuf8", "outBbuf2", "outBaft11", "outBuff8", "outBuf01", "outBuff1", "outBbuf11", "outBaftn", "outBaf8", "outBiff1", "outBuf0", "outDuf11", "outBbufn", "outFbuf01", "outBuffOne", "outFaf1", "outDuffn", "outBaft1", "outBufCloud", "outKufOne", "outDuf3", "outBuffCloud", "outBalth2", "outKuf8", "outKbuf2", "outFbufOne", "outBuffn", "outDuf1"], "outBuf2": ["outBbufTwo", "outBbufferB", "outBum8", "outFbuff2", "outWBuf4", "outBuber8", "outBuff4", "outBbuf1", "outBum20", "outFuf8", "outBuff12", "outWBuff4", "outFuf20", "outFbuff4", "outBbuff20", "outBuff2", "outBuff0", "outBbuff8", "outWBufTwo", "outWBuf8", "outFufTwo", "outBuber82", "outBbuf12", "outFuf2", "outBbuff82", "outFufB", "outBoffTwo", "outBbuffer12", "outWBuff0", "outFbuff82", "outBait8", "outBait4", "outFbuff8", "outBuffB", "outBoff2", "outBuf82", "outBoff8", "outBait0", "outBbuffer4", "outBait200", "outBuf200", "outWBuf0", "outBbufB", "outBbuffTwo", "outWBuf2", "outFuf4", "outFbuff20", "outBuber20", "outWBuff2", "outWBuff8", "outBuf12", "outFbufB", "outFbuf12", "outFbuf2", "outBbuff2", "outWBbuff200", "outFbuff1", "outBbuff1", "outBuffTwo", "outFuf1", "outWBbuffTwo", "outBufTwo", "outFuf12", "outFbuffTwo", "outBbuf4", "outWBbuff2", "outBbuff0", "outBum2", "outBuf8", "outBbuf2", "outBuff8", "outFuf82", "outBaitTwo", "outBuff1", "outBbuff4", "outBuf0", "outWBbuff8", "outBufB", "outBoff200", "outBuf20", "outWBuf200", "outBbuff200", "outFbuf4", "outBbuffer2", "outBum82", "outBuber2", "outBuf4", "outBait2"], "endOfIndexFile": ["endOfClientTime", "endofLinkFiles", "endOfLinkfile", "endofindexFolder", "endOfImageFile", "endofIndexFile", "endOfDataTime", "endOfindexTime", "endOfIndexDir", "end\n", "endOfImageFiles", "endofLinkFile", "endOfindexFolder", "endOfClientDir", "endofindexTime", "endOfLinkFiles", "endOfindexDir", "endOfIndexfile", "endofLinkTime", "endOfImageTime", "endOfDataFile", "endOfIndexTime", "endOfLinkFile", "endOfClientFile", "endOfIndexFolder", "endofIndexFiles", "endOfDatafile", "endOfIndexFiles", "endOfDataDir", "Endfile", "endOfLinkDir", "endOfindexFiles", " end\n", "endedfile", "End\n", "endOfindexFile", "endfile", "endofIndexFolder", "endofLinkDir", "endOfLinkTime", "endofIndexTime", "endOfindexfile", "endofIndexDir", " endfile", "endofindexFile", "endOfImageFolder", "ended\n", "endOfClientFiles", "endofindexFiles"]}}
{"id1": "17522011", "id2": "19667000", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"read": ["include", "play", "default", "resource", "write", "report", "build", "data", "reading", "connect", "check", "reads", "input", "READ", "Read", "run", "feed", "type", "process", "class", "create", "add", "reader", "print", "parse", "work", "resources", "send", "load", "exec", "start", "find", "select", "get", "invoke", "eval", "use", "open", "readable"], "classLoader": ["fileLoader", "ClassLoader", " classPath", "fileDir", "filePath", "classloader", "ClassReader", "classReader", "resourceloader", "ClassPath", "ClassLoading", "fileLoad", "classLoading", "Classloader", "resourceReader", " classLoading", "resourceLoading", "classPath", "ClassLoad", "classDir", " classLoad", "classLoad", "fileloader", " classReader", " classDir", "ClassDir", " classloader", "resourceLoader"], "name": ["NAME", "ame", "prefix", "default", "resource", "image", "large", "parent", "null", "n", "connection", "none", "data", "child", "old", "part", "alias", "search", "no", "str", "named", "key", "type", "home", "pass", "code", "time", "class", "comment", "Name", "size", "filename", "base", "id", "address", "names", "string", "file", "root", "path", "word", "x", "value", "active"], "all": ["at", "partial", "attribute", "array", "one", "call", "apply", "none", "each", "this", "allow", "sync", "not", "part", "f", "named", "All", "batch", "sort", "and", "only", "pass", "alls", "process", "total", "with", "al", "l", "ann", "any", "local", "ALL", "alpha", "app", "list", "am", "global", "left", "full", "both", "auto", "active"], "sm": ["m", "rm", "sam", "spe", "sf", "ss", "sv", "mo", "si", "tm", "wm", "km", "sb", "zip", "SM", "fm", "imm", "sn", "so", "su", "sum", "sy", "nm", "ms", "hm", "bm", "cm", "api", "sym", "source", "gm", "im", "asm", "sim", "ym", "sa", "mm", "Sm", "service", "sr", "sl", "sp", "smith", "sk", "ama", "sh", "em", "vm", "om", "sw", "serv"], "enu": ["enus", "Enou", "anu", "Enun", "enncu", "Encu", " encu", "EnU", "munu", "munun", "venu", "ENus", "Enu", "ENu", "enU", "ennu", "munU", " enus", " ennu", "Ennu", "Enc", "anun", "anus", "ENc", "enou", "ENou", "ennnu", "ennus", "encu", "Enus", "munus", "venc", "enun", "venou", "venus", "enc", "anU"], "url": ["ur", "ls", "page", "uri", "ssl", "resource", "ll", "server", "image", "connection", "loc", "rel", "in", "f", "impl", "zip", "str", "URL", "job", "key", "download", "source", "i", "pull", "li", "l", "web", "base", "r", "id", "address", "string", "file", "loader", "sl", "plug", "layer", "Url", "path", "http", "browser"], "is": ["ls", "p", "js", "ins", "uri", "esi", "image", "isi", "isl", "act", "os", "lis", "ori", "il", "info", "mis", "io", "init", "si", "iso", "ie", "in", "it", "es", "vs", "bis", "IS", "isc", "us", "ignore", "iris", "ios", "i", "api", "cms", "ar", "im", "web", "ip", "inner", "are", "id", "iss", "ir", "ais", "ris", "has", "Is", "app", "ic", "ops", "as", "ii", "was", "isa", "or", "abs", "close", "ois", "http", "serv", "ri", "its"], "s": ["ls", "m", "js", "u", "ions", "ins", "ssl", "rows", "e", "sf", "se", "details", "g", "als", "ss", "n", "os", "sv", "ies", "ps", "rs", "ns", "si", "session", "sb", "f", "spec", "es", "ings", "ows", "o", "comments", "d", "su", "storage", "sets", "lines", "h", "ips", "ms", "ws", "results", "i", "ches", "les", "l", "sg", "outs", "r", "ses", "S", "sc", "string", "c", "sl", "w", "ts", "ments", "ans", "gs", "cs", "abs", "services", "strings", "its", "p", "ks", "ds"]}}
{"id1": "3801655", "id2": "5836744", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"helper": ["workp", "scheper", "workmer", "helpler", "schepherd", "Helper", "harper", "sher", "helppherd", "harpherd", "scheHelper", "heller", "helpherd", "heler", "Heler", "helHelper", "shper", "harler", "worker", "Help", "workper", "shp", "helpper", "shmer", "help", "helmer", "scheler", "helpHelper", "harHelper", "Helmer"], "dataset": ["Dataset", "datrasets", "metasheet", " DatASet", "datasset", "datassets", "Datasets", "datASheet", "DatasET", "metasET", "datAset", " DatasET", "datAsets", "datapsET", "datAsheet", "datastets", "DatASeter", "datapsheet", "datacheet", "datasert", "datastet", " Datasheet", "datASet", "datasets", "DatASet", "datasteter", "datraseter", "datacert", "datrasET", "datacet", "metasert", "datASets", "datapset", " DatASheet", "metaset", " DatASets", " Datasets", " DatASET", "Dataseter", "datapsert", " Dataset", "datassert", "dataseter", "DatASET", "datASeter", "metassert", "DatASets", "datastET", "datasET", "datassET", "datAsET", "metassheet", "datASET", "datasheet", "metassET", "datassheet", "datraset", "metasset", "datacET"], "zip": ["java", "z", "pack", "ssl", "se", "copy", "system", "lock", "flat", "io", "data", "zone", "folder", "py", "f", "wrap", "tar", "loop", "archive", "bag", "split", "out", "code", "jar", "xml", "sea", "plugin", "parse", "dir", "directory", "pkg", "source", "ip", "Zip", "pdf", "slice", "pipe", "handler", "file", "gz", "window", "service", "binary", "sl", "bug", "git", "secure", "p"], "entries": [" entlines", "entents", "entlections", "ntries", "intries", " entities", "ntents", "iterents", "entities", "contry", "itries", "entryents", "itry", "entrees", "entrys", "contries", "entrylements", "contrys", "itents", "infries", "ENTrees", "iterries", "ntry", "ENTries", "contents", "entsries", "deents", "itrys", "inflines", "intlines", "intlements", "intities", "entryries", "entslections", "ENTrants", "ntrys", "delements", "infities", "inflections", "entlements", "deries", "entsrees", "ENTlections", " entlements", "inflements", "infrants", "entrants", "entlines", "entsrants", "infrees", "iterlements"], "performance": ["book", " u", "unit", " writers", "Unit", "stats", "ul", " ratio", "each", "it", " suite", "union", " split", " Units", "its", " unit", " units", "work", "slave", "units", "exec", " group", "U", " output", "runner", "ui", "rank", "util", " Unit", " result"], "index": ["page", "unit", "write", "length", "count", "offset", "Index", "num", "depth", "limit", "pos", "key", "type", "i", "iter", "number", "position", "id", "name", "order", "path", "x", "value", "level", "head"], "entry": ["pe", "install", "uri", "e", "write", "server", "se", "style", "connection", "cell", "info", "data", "child", "si", "ie", "part", "in", "folder", "it", "her", "result", "input", "route", "archive", "nt", "key", "row", "Entry", "element", "xml", "cel", "add", "record", "section", "parse", "stream", "inner", "r", "file", "obj", "service", "pattern", "or", "lc", "office", "feed", "export", "post", "ry"], "temp": ["partial", "original", "txt", "copy", "parent", "dest", "lock", "tc", "flat", "empty", "porary", "data", "single", "store", "io", "session", "part", "Temp", "output", "folder", "wrap", "f", "input", "archive", "valid", "storage", "template", "test", "out", "cel", "config", "iter", "directory", "tmp", "thread", "base", "table", "stable", "local", "cache", "pipe", "layout", "file", "binary", "w", "full", "ctx", "fake", "context", "path", "clean", "office", " temporary", "emp", "tem", "http", "p"], "writer": ["wave", "log", "wr", "write", "server", "io", "outer", "engine", "writing", "written", "output", "editor", "Writer", "feed", "key", "out", "player", "wer", "ws", "rw", "builder", "iter", "driver", "war", "element", "riter", "sw", "er", "worker", "stream", "inner", "r", "holder", "handler", "file", "wire", "loader", "w", "per", "writers", "layer", "wrapper", "ler", "or", "author", "manager"], "reader": ["write", "server", "rer", "ser", "io", "ner", "rar", "reading", "f", "Reader", "input", "editor", "upper", "element", "i", "builder", "iter", "driver", "stream", "er", "ter", "worker", "inner", "rr", "r", "handler", "file", "loader", "per", "wrapper", "ler", "or", "iterator", "oder", "http", "feed", "ri", "ry"], "buffer": ["wave", "buf", "write", "message", "resource", "server", "length", "null", "offset", "data", "Buffer", "sequence", "limit", "channel", "document", "result", "input", "batch", "bytes", "row", "source", "iter", "memory", "flush", "header", "size", "buff", "seed", "capacity", "queue", "position", "slice", "table", "address", "character", "initial", "binary", "device", "reference", "layer", "uffer", "transfer", "feed"], "read": ["save", "available", "book", "text", "k", "play", "default", "write", "report", "se", "length", "build", "count", "view", "g", "copy", "data", "child", "allow", "reading", "sync", "old", "raw", "ride", "connect", "check", "reads", "input", "READ", "Read", "run", "seek", "type", "end", "fill", "download", "process", "pass", "add", "parse", "print", "config", "size", "max", "work", "use", "iter", "ad", "send", "ind", "id", "skip", "load", "exec", "start", "find", "select", "wait", "next", "get", "x", "current", "close", "sleep", "eval", "feed", "open", "readable", "create"], "outfile": [" outfilename", " outf", "infile", " outdata", "instream", "outfilename", "indata", " outFile", "againdir", "logfilename", "outdir", "inFile", "outline", "inline", "inf", "Outline", "againline", "indir", "Outdir", "logdata", "againfile", "logfile", "infilename", "outdata", "outf", " outline", "logFile", "Outf", "outstream", "outFile", "Outstream", "Outfile", "againstream", " outstream"], "line": ["filter", "page", "text", "LINE", "log", "url", "frame", "lf", "le", "style", "letter", "item", "cell", "data", "link", "sync", "on", "range", "status", "str", "end", "split", "lin", "strip", "lines", "error", "inline", "type", "val", "job", "code", "pass", "el", "column", "band", "comment", "row", "parse", "cle", "section", "header", "side", "l", "ip", "object", "look", "string", "file", "Line", "name", "sel", "word", "ine", "block"], "parser": ["book", "angler", "lp", "server", "system", "par", "umper", "data", "test", "type", "plugin", "xml", "class", "builder", "parse", "driver", "plan", "er", "worker", "r", "string", "handler", "params", "loader", "Parser", "pattern", "per", "cher", "function", "pool", "wrapper", "ler", "oder", "manager", "p", "processor", "arser"], "list": ["filter", "array", "lp", "parent", "best", "info", "lists", "data", "part", "group", "member", "all", "right", "result", "map", "set", "LIST", "and", "val", "out", "test", "type", "plan", "li", "l", "er", "listed", "can", "base", "table", "r", "match", "v", "other", "left", "get", "pool", "chain", "collection", "p", "join"], "rule": ["pe", "ee", "style", "rol", "item", "ul", "event", "data", "group", "range", "model", "field", "str", "val", "row", "dict", "plugin", "class", "parse", "record", "rl", "li", "header", "er", "lr", "tree", "base", "table", "r", "match", "ule", "service", "rules", "per", "function", "layer", "Rule", "ri", "rate"], "measure": ["Measures", "speasured", "feasuring", "measured", "measuring", "feasures", "Measured", "Measuring", "speasuring", "feasure", "measures", "Measure", "feasured", "speasures", "speasure"]}}
{"id1": "20751378", "id2": "7908169", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 0, "substitutes": {"hashPassword": ["signPassword", " hashWord", " hashpassword", "signWord", "cryptPass", "signpassword", " hashPass", "cryptPassword", "cryptWord", "cryptpassword", "signPass", "hashPass", "hashpassword", "hashWord"], "password": ["crypt", "prefix", "text", "p", "padding", "description", "auth", "pad", "message", "plain", "sha", " passwords", "data", "username", "sword", "phrase", "input", "encrypted", "key", "wd", "python", "pass", "code", "seed", "number", "command", "user", "mac", "address", "token", "string", "cache", "security", "name", "w", "pattern", "words", "path", "word", "content", "Password", "secret", " Password", "database", "PASS"], "hash": ["html", "tag", "search", "phrase", "her", "sum", "addr", "ruby", "cache", "string", "security", "root", "put", "update", "secret", "text", "ash", "bolt", "message", "call", "style", "height", "rh", "version", "dig", "result", "hex", "index", "error", "key", "h", "code", "handle", "pkg", "oh", "dump", "alt", "match", "ssh", "json", "format", "replace", "log", "url", "uild", "length", "build", "math", "msg", "check", "proof", "memory", "gh", "user", "mac", "id", "square", "value", "array", "auth", "copy", "sha", "kh", "ashes", "work", "number", "base", "hed", "address", "history", "host", "ha", "Hash", "sh", "pool", "mod"], "md": ["mad", "m", "hd", "sd", " MD", "der", "Cmd", "xd", "nd", "sha", "cmd", "ME", "dig", "dd", "km", "gd", "f", "mc", "mag", "d", "vd", "od", "meta", "mb", "ms", "hm", "nm", "amd", "mg", "dm", "bd", "wd", "metadata", "pd", "MD", "mac", "mand", "mm", "sm", "ma", "gb", "am", "pm", "kg", "grad", "mt", "mod", "dh", "df"]}}
{"id1": "1357662", "id2": "3409084", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "label": 0, "substitutes": {"copyFileTo": ["copyfileFrom", " copyfileFrom", "copyChannelFile", " copyFileFrom", "copyfileFile", " copyfileFile", " copyfileTO", "copyfileTo", "copyFilesTO", " copyfileTo", " copyFileFile", "copyChannelTo", "copyfileTO", "copyFileFrom", " copyFileTO", "copyFileFile", "copyChannelFrom", "copyFilesTo", "copyChannelTO", "copyFilesFrom", "copyFilesFile", "copyFileTO"], "destination": ["distination", "Destribution", "distinations", " Destribution", " Destinator", " destinations", "configinator", "distruction", "configination", "destinate", "destruction", "destinations", "distinator", "Destined", "targetinate", "separinator", "Destinator", "sourceination", " Destination", "destined", "configinations", "targetinations", " destribution", "destribution", "sourceinated", "distined", " destinator", "configinated", "Destination", "destinated", " destined", "sourceinations", "separinations", "targetruction", "sourceinator", "separination", " destruction", "destinator", " destinate", "separinated", "distinate", "Destinations", "targetination"], "srcChannel": ["srcContext", "sourceContext", " srcContext", "rcChan", "sourceChannel", "srcChan", "rcConnection", "destchannel", "rcContext", " srcchannel", "sourcechannel", "rcchannel", "destConnection", "rcChannel", "srcConnection", "srcchannel", "sourceChan", "sourceConnection", " srcConnection", " srcChan", "destChan"], "destChannel": ["descChannel", "sourceChannel", "srcChan", " destConnection", "restchannel", "descButton", "srcButton", "destchannel", "DestChan", "sourcechannel", " destchannel", "destConnection", "srcConnection", "srcchannel", "sourceChan", "restChan", "DestChannel", "sourceConnection", "Destchannel", "destButton", "DestConnection", " destButton", "destChan", " destChan", "descchannel", "restChannel"]}}
{"id1": "5760649", "id2": "17729554", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"createFile": ["CreateResource", "saveFolder", "createContent", "CreateFolder", " createContent", "createResource", "saveFile", "CreateFile", "saveResource", " createFolder", "saveContent", "createFolder", " createResource", "CreateContent"], "src": ["SourceFile", "buf", "fn", "rss", "url", "txt", "uri", "resource", "rob", "ssl", "dest", "loc", "rc", "data", "username", "sb", "Source", "input", "rb", "href", "cb", "s", "source", "ruby", "stream", "files", "resources", "slice", "r", "sc", "sit", "string", "load", "file", "obj", "upload", "gb", "name", "sl", "sel", "proc", "path", "content", "secure", "fp", "img"], "filename": ["ame", "SourceFile", "prefix", "fn", "url", "uri", "txt", "FILE", "resource", "sf", "length", "acl", "username", "title", "output", "f", "route", "nil", "s", "dll", "source", "metadata", "directory", "rl", "l", "fil", "files", "which", "Filename", "string", "file", "ames", "name", "loader", "wb", "location", "path", "utf", "fp", "ename", "feat"], "fis": ["fais", " fiss", "cfais", "sfiss", "sfris", " fIS", "cfIS", "Fos", "cfbs", "Fris", "fbs", "fris", "sfos", "cfis", "Fiss", " fris", "Fais", "FIS", "fiss", "cfris", " fais", "fIS", "sfis", "cfos", "Fbs", " fbs", "Fis"], "fos": ["foros", "Fas", "foris", "fOS", "affos", "Fops", "Fos", "affbos", "affios", "sfos", "foras", "bis", "bbos", "fas", "Fbos", "bos", " fas", " fops", " fOS", "fios", "Fios", "affis", "fops", "sfis", "fbos", "forOS", "sfops", "FOS", " fios", "sfios", "bios", "Fis"]}}
{"id1": "21555906", "id2": "14865947", "code1": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["eventPerformed", "eventExecuted", "actionConformed", "actionPerceived", "actionOccformed", "eventExecressed", "eventPerceived", "actionOccceived", "eventExecformed", "actionExecuted", "actionOccuted", "actionConuted", "actionExecformed", "actionConceived", "eventPeruted", "actionExecceived", "actionConressed", "actionPerressed", "actionExecressed", "eventPerressed", "eventExecceived", "actionOccressed", "actionPeruted"], "ae": ["ade", " inst", "pe", "ee", "e", "ava", "Events", " te", "ce", "event", "je", "sem", "gae", " error", "bc", " ace", "ec", " ce", "oe", "es", " events", "fa", "ga", "ace", " je", "AE", " pe", "cm", " ge", " ev", "a", "E", " fa", "de", "change", "c", "au", "dc", "t", "Event", "ai", " event", "ea", "x", "ca", " ec", " a", "fe", "exc"], "toservlet": ["tosServlet", "tosservle", "tosservlet", "tosvet", "topserverlet", "tosservlets", "tosourceler", "topservlets", "toserverlet", "toserveet", "toservler", "tosvlete", "toservlete", "tosservler", "toseservlet", "toseservet", "toseserveurl", "topserverler", "topservle", "tosvlet", "topservler", "tosourcele", "toservle", "tosourcelet", "toserveurl", "toseservlete", "topserverlets", "tosServlete", "toserverler", "topserverle", "tosourcelets", "toseservelete", "tosvurl", "toseservurl", "topservlet", "toservlets", "tosServurl", "toseservelet", "toservet", "toserverle", "toserverlets", "toservelete", "toseserveet", "toservelet", "toservurl", "tosServet"], "servleturl": ["servlurl", "servletsuri", " servletserver", "servlettserver", " servleserver", " servleurl", " servletfile", "servletsurl", "servletturl", "servjectconnection", "ervletserver", "servlefile", "servluri", "servletturi", "servleurl", "servjectserver", "ervletconnection", "servletsconnection", "servjecturl", "servletfile", "servletsfile", "servletserver", "servlserver", "ervletsurl", "ervletsuri", "servleturi", "ervletsserver", "ervleturl", " servleconnection", "servlettconnection", "servleconnection", "servleserver", "servjectfile", "servletsserver", "servlconnection", " servlefile", "ervleturi", "ervletsconnection"], "servletconnection": ["servletsconn", "servbleconnection", " servletconnect", "ervletconn", "serverletcommunication", "serverletconnection", "ervletsconn", "servletsconnect", "serverletsconn", "servlexconn", "servletcon", "servlettconnect", "servletscon", "ervletscon", "servlexcommunication", "servletsurl", "servserverconnection", "servlettconn", "servserverurl", "serverletConnection", "servlesscommunication", "servlettConnection", "ervletconnection", "servleconn", "servletsconnection", "serverletconnect", "serverletscommunication", " servetconn", "servetconnect", " servletConnection", "ervletcon", "servlexpassword", "servlessconnection", "serverletsconnection", "servletconnect", "servletcommunication", "servletpassword", "servetconn", "servleconnect", " servletconn", "ervletsurl", "servserverconn", "servletsConnection", "servlessconn", "servbleconn", "servblecon", " servetconnect", "ervleturl", "servbleurl", "servletscommunication", "serverletpassword", " servleconnection", " servleconnect", "servletspassword", "servlexconnection", "servletconn", "serverletspassword", "servservercon", "servlettconnection", "servetconnection", "servetConnection", "servleconnection", " servetConnection", " servleConnection", "servlesspassword", " servetconnection", "servleConnection", "serverletconn", "serverletsconnect", "servletConnection", " servleconn", "ervletsconnection", "serverletsConnection"], "inputFromClient": ["inputFormclient", "requestFromclient", "inputFormConnection", "requestFromConnection", "inputToClient", "inputFromStream", "inputViaServer", "inputOrCL", "inputfromURL", "inputfromclient", "inputOrClient", "InputFromClient", "outputFromServer", "inputFromServer", "inputFromCL", "inputOrServer", "inputFromConnection", "inputToServer", "InputFromStream", "inputFromURL", "inputViaCL", "inputFormClient", "inputOrURL", "inputToclient", "requestFromServer", "InputFromConnection", "inputfromServer", "outputfromURL", "requestFromRemote", "outputfromClient", "inputfromConnection", "outputfromServer", "inputViaURL", "inputfromClient", "inputfromCL", "InputFormClient", "inputFormStream", "InputFromclient", "requestFromClient", "outputFromCL", "inputToConnection", "InputFormStream", "outputFromClient", "outputfromCL", "inputfromStream", "InputFormConnection", "inputFromclient", "inputToRemote", "outputFromURL", "inputViaClient", "InputFormclient", "inputFromRemote"], "fos": ["fis", "Foos", " faos", "affos", "fols", "Fos", " foos", "affbos", "foos", "foses", "faos", "ifoses", "Fbos", " foses", "Faos", "affis", "Foses", " fols", "ifaos", "ifols", " fis", " fbos", "fbos", "ifos", "affoos", "Fols", "Fis"], "buf": ["bb", "cap", "cv", "uf", "pad", "font", "bu", "uc", "b", "loc", "off", "fb", "data", "bh", "bp", "lb", "feat", "bc", "shape", "bag", "rb", "batch", "uint", "bytes", "comb", "cb", "Buff", "cas", "bf", "bd", "bound", "tmp", "buff", "ff", "queue", "ba", "br", "bin", "la", "vec", "ha", "wb", "pool", "bl", "buffer", "seq", "box", "block"], "bytesread": ["rowsread", "rowsRead", " bytesload", "rowswrite", " byteswrite", "tesrun", " bytesrun", "linesload", "filesread", "linesRead", "bytesrun", "linesrun", "tesread", "Bytesload", "byteswrite", "bytesRead", "teswrite", "linesread", "lineswrite", "fileswrite", "filesRead", "BytesRead", "Byteswrite", " bytesRead", "Bytesread", "filesrun", "rowsrun", "tesload", "bytesload"]}}
{"id1": "62362", "id2": "324679", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "6190356", "id2": "5998352", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForNewMD3", " hashPasswordForNewMD5", " hashPasswordForNewM3", " hashPasswordForOldMC3", " hashPasswordForOldMD512", " hashPasswordForNewM512", " hashPasswordForNewM4", " hashPasswordForOldmd5", " hashPasswordForNewMD4", " hashPasswordForOldmd4", " hashPasswordForOldmd512", " hashPasswordForOldMC5", " hashPasswordForOldMC512", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForNewM5", " hashPasswordForOldMD3", " hashPasswordForOldMD4", " hashPasswordForOldM3", " hashPasswordForOldMC4", " hashPasswordForOldM512", " hashPasswordForOldM4", " hashPasswordForOldmd3"], "password": ["crypt", "secret", "text", "padding", "pad", "array", "auth", "message", " passwords", "data", "username", "sword", "phrase", "result", "hash", "input", "encrypted", "key", "wd", "wallet", "pass", "code", "seed", "address", "token", "string", "account", "name", "pattern", "words", "path", "word", "content", "buffer", "value", "Password", "p", " Password", "PASS"], "md": ["m", "rm", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "um", "dig", "dd", "km", "gd", "f", "managed", "rpm", "mc", "mag", "d", "vd", "od", "mb", "meta", "hm", "wd", "nm", "amd", "dm", "bd", "metadata", "pd", "MD", "di", "mac", "ind", "mand", "mm", "ma", "dc", "am", "pm", "grad", "mt", "cd", "clean", "vm", "mod", "df"], "messageDigest": ["messageModester", "messagedigests", "messageAddse", "MessageDigEST", "MessageDigest", "messageAddester", "messageAddEST", "messageModEST", "messagedigest", " messageModester", " messageModEST", "messageAddests", "MessageModse", "messageDest", "messagedigester", "MessageAddse", "messageDEST", "messageAddest", "MessageDigse", " messageDigester", "messageModest", "MessageModester", " messageModest", "messageModse", "MessageModest", " messageDigEST", "messagedigEST", "messageDigse", "MessageAddester", "MessageAddest", "messagedigse", "messageDigests", "MessageDigester", "messageModests", "messageDigEST", "MessageAddEST", "messageDester", "MessageModEST", " messageDigests", "messageDse", "messageDigester", " messageModests"], "hexString": ["stringSection", "stringService", "crossstring", "stringString", " hexstring", " hexFunction", "crossFunction", "sumstring", "octBuffer", "hexBuffer", "transformStr", " hexFile", "transformString", "tempFile", "hexstring", "hexService", "stringArray", " hexStr", "transformBuffer", "tempString", "hexArray", "hexStr", "hashString", "hashSection", "transformArray", " hexArray", "hashService", "crossStr", "tempStr", "sumString", "sumFile", "tempstring", "octStr", "octString", " hexService", " hexSection", "hexFunction", "octArray", "hexSection", "tempFunction", "hexFile", "hashArray", " hexBuffer", "crossString", "sumStr"], "i": ["k", "m", "p", "u", "uri", "e", "j", "length", "b", "n", "fi", "io", "info", "si", "f", "o", "index", "d", "ci", "h", "oi", "s", "ji", "multi", "li", "a", "l", "di", "ip", "pi", "xi", "slice", "r", "id", "ti", "v", "c", "t", "ix", "I", "ai", "phi", "ii", "ui", "x", "bi", "qi", "ri"], "hex": ["text", "ex", "he", "pack", "default", "hack", "length", "null", "cmp", "letter", "form", "pixel", "none", "rh", "data", "nexus", "bit", "hello", "raw", "cookie", "result", "hash", "str", "exp", "digit", "batch", "shift", "utf", "h", "temp", "pex", "buff", "ip", "oct", "lit", "transform", "cache", "sex", "string", "character", " Hex", "alpha", "binary", "host", "full", "pattern", "json", "path", "comp", "zero", "orig", "serial", "rex", "format", "http", "char"]}}
{"id1": "23035537", "id2": "2807585", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getContent": ["postcontent", "readcontent", "readContent", "postContent", "createBody", "createcontent", "getBody", "readBody", "createContent", "createContents", "getContents", "postBody", "getcontent", "postContents", "readContents"], "userId": ["UserPath", " userOr", " userID", "UserId", "userOr", "userName", " userName", "messageName", "UserID", "UserName", "messageID", "USERName", "USERPath", "messageId", "USEROr", " userPath", "userPath", "userID", "USERId", "UserOr"], "latestMsgId": ["latestUserID", " latestmsgID", " latestmsgid", " latestMsgID", "latestmsgId", "latestChanid", "latestUserId", "lastMsgId", "latestMessageTime", "latestChanTime", "latestMsgID", " latestmsgTime", " latestmsgId", "latestChanId", "latestMessageID", "latestChanID", "lastMessageID", "latestmsgTime", " latestMsgTime", "latestmsgid", "lastMessageid", "latestUserid", "latestmsgID", "lastMsgID", "latestMessageid", "lastMsgid", "latestMessageId", " latestMsgid", "lastMessageId", "latestMsgTime", "latestMsgid"], "targetUrl": ["sourceURL", " targeturl", "targetURL", "TargetUr", "targetPage", "Targeturl", "sourcePage", "TargetPage", "TargetUrl", "sourceUr", "targeturl", " targetURL", "sourceurl", " targetPage", "targetUr", "sourceUrl", " targetUr", "TargetURL"], "url": ["page", "uri", "ssl", "resource", "image", "server", "b", "connection", "data", "link", "channel", "f", "www", "URL", "download", "i", "source", "api", "client", "stream", "l", "base", "user", "r", "id", "address", "string", "file", "window", "sl", "host", "path", "Url", "location", "http", "feed", "browser"], "in": ["wave", "m", "ins", "resource", "image", "In", "b", "ax", "data", "inc", "raw", "socket", "gin", "input", "din", "IN", "inn", "inas", "out", "s", "pass", "xml", "i", "is", "source", "kin", "reader", "record", "a", "stream", "nin", "login", "inner", "r", "string", "load", "bin", "file", "err", "get", "ini", "as", "query", "arin", "again", "serv", "isin"], "list": ["array", "lp", "server", "parent", "view", "item", "info", "data", "lists", "tx", "sequence", "group", "entry", "all", "document", "result", "LIST", "coll", "set", "batch", "cl", "test", "live", "dict", "xml", "i", "parse", "record", "section", "li", "cli", "listed", "l", "tree", "table", "queue", "id", "language", "string", "detail", "la", "pool", "json", "lc", "chain", "collection", "join"], "parser": ["rss", "writer", "lp", "parent", "system", "info", "data", "director", "document", "jack", "player", "xml", "plugin", "class", "builder", "parse", "api", "reader", "paragraph", "a", "er", "worker", "command", "util", "language", "handler", "loader", "Parser", "per", "php", "layer", "json", "ler", "collection", "http", "p", "processor", "arser"], "dao": ["adaos", "idosa", "dala", "adao", "idaba", "dosa", " daba", "daba", "datala", "Dosa", " dala", " dosa", "daos", "datosa", "idaos", "datao", "adosa", "Daba", " daos", "adala", "dataos", "Dao", "Daos", "idao"]}}
{"id1": "11716816", "id2": "14093044", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "label": 0, "substitutes": {"updateFile": ["updateBody", "copyBody", "upFolder", "upDirectory", "importBody", "copyFolder", "copyFile", "upFile", "importFolder", "upBody", "updateFolder", "updateDirectory", "copyDirectory", "importFile", "importDirectory"], "file": ["pe", "log", "FILE", "url", "resource", "e", "image", "parent", "b", "connection", "lock", "io", "info", "data", "single", "this", "socket", "part", "model", "f", "zip", "input", "type", "class", "source", "future", "dir", "filename", "l", "db", "files", "base", "queue", "object", "local", "cache", "load", "handler", "name", "up", "full", "File", "get", "path", "line", "current", "content", "http", "fp"], "IOException": ["Timeoutception", "DownloadProblem", "Downloadception", "TimeoutException", "DownloadException", "TimeoutProblem", "IOception", " IOception", " IOProblem", "IOProblem"], "destFile": ["flatFile", "destFull", "origTable", "destroyDir", "srcPath", " destFolder", "destFiles", "flatDir", "destFolder", "sourceFolder", "destTable", "origFile", " destinationFiles", "srcFiles", "destroyTable", " destinationFile", "destPath", " destFull", "origfile", "DestFile", "destDir", "flatFiles", "sourceFile", "Destfile", "DestPath", " destfile", "origDir", "DestDir", "DestFull", "destroyfile", " destTable", " destFiles", "sourceFiles", "srcFolder", "destfile", "srcFile", " destDir", "DestFiles", " destinationFull", "DestFolder", " destPath", "flatfile", "destroyFile", " destinationDir", "sourceDir"], "in": ["ins", "image", "In", "b", "ax", "connection", "lock", "init", "io", "this", "sync", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "cl", "s", "pass", "conn", "cin", "el", "i", "source", "win", "pull", "reader", "with", "client", "inside", "a", "l", "nin", "login", "work", "inner", "min", "r", "id", "ac", "bin", "con", "c", "err", "re", "up", "pin", "cf", "ini", "as", "again", "on", "p", "isin"], "out": ["at", "to", "ex", "writer", "url", "resource", "call", "In", "b", "n", "connection", "io", "off", "outer", "this", "sync", "outside", "inc", "socket", "channel", "output", "no", "cookie", "exp", "o", "password", "Out", "timeout", "conn", "pass", "i", "client", "nin", "co", "of", "login", "point", "outs", "user", "exec", "bin", "err", "obj", "c", "name", "option", "extra", "up", "net", "w", "OUT", "ou", "again", "lib", "ext"]}}
{"id1": "6371607", "id2": "17974661", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"removeRealm": ["removeScheM", "deleterealM", "removeSchems", "removerealms", "deleterealam", "delRealM", "removeRealam", "removeRelm", "deleteRealam", "removeRealms", "delBroadms", "delRealme", "removeScheme", "removeRelam", "removeBroadms", "removeRelms", "removeBroadM", "delRealm", "delBroadM", "removeSchem", "removeLocalam", "removeLocalms", "removeRealM", "deleterealms", "deleterealm", "removeRealme", "delRealms", "removerealM", "removeLocalM", "removeBroadme", "removerealm", "removeLocalm", "removerealme", "removeBroadm", "removeRelM", "delBroadm", "delBroadme", "deleteRealm", "deleteRealM", "removerealam", "deleteRealms"], "realmIds": ["realmIDes", "realmIDls", "realmRefs", "realmByIdls", "realMIdList", "realmIdids", "realMIdids", "realmRefes", "realmIntos", "realmIdes", "realMByIdls", "realmByIdes", "realMPaths", "realmIdList", "realMPathids", "realMPathos", "realmPaths", "realMByIdes", "realmPathos", "realMIdes", "realmRefls", "realMIdos", "realmInts", "realmRefos", "realmPathids", "realmIDList", "realmIdls", "realmByIdList", "realMIdls", "realMByIdList", "realmIdos", "realmByIds", "realMIds", "realmIntes", "realmIDs", "realmPathes", "realmRefList", "realMByIds", "realmRefids", "realmIntids", "realMPathes"], "psImpl": ["epsImpl", " psExpl", "qsHelper", "epsHelper", "cssImpl", "cssimpl", "csImpl", "dsHelper", " psIter", "psIter", "epsimpl", "dsImpl", " psHelper", "epsExpl", "epsIter", "psHelper", "cssIter", "csimpl", "psimpl", "dsimpl", "qsImpl", "cssExpl", "psExpl", " psimpl", "csHelper", "qsimpl"], "iter": ["enter", "page", "e", "itter", "loc", "init", "outer", "ner", "inc", "ie", "cer", "limit", "in", "loop", "it", "entry", "finder", "index", "coll", "upper", "sort", "end", "el", "gener", "apper", "i", "parse", "reader", "ter", "er", "inner", "former", "walker", "ir", "err", "list", "Iter", "inter", "ator", "izer", "next", "ite", "cher", "ler", "iterator", "line"], "realmId": ["realmcId", "realmRef", "realmaId", " realmnId", " realmOffset", "ironmaInt", "ironmId", "realmID", "ironmaId", "workfid", "realamNum", "workmID", "realmsId", "realamid", "realrmRef", "workfId", "realmcID", "realmeName", "RealmName", "realarmId", " realmnOffset", "realmid", "realfNum", "ironmRef", "realfID", "workmNum", "RealmPath", "realarmName", "realmnId", " realmConfig", "ironmInt", "realmnHash", "RealmID", "realmOffset", "ironmaID", "realmrid", "realdmId", " realmHash", "realmaID", "realmrId", "realmConfig", "realmaInt", "realfId", "realdmHash", "realrmInt", "workfNum", "ironmID", "realmsName", "realmPath", "RealmsPath", "workmid", "realmnOffset", "realmnConfig", "realmHash", "realdmOffset", "workmId", "realmrID", "realmName", "RealmId", "realfid", " realmnConfig", "realmrConfig", "realmInt", "realmePath", "realmrNum", "realmNum", "realmaRef", "realmrHash", "realmcRef", "realamId", "realmcInt", "realdmConfig", "realmeID", "realmrOffset", " realmnHash", "realarmPath", "realrmID", "realrmId", "realmeId", "realamID", "workfID", "RealmsId", "realarmID", "RealmsName", "ironmaRef", "realmsID", "realmsPath", "RealmsID"]}}
{"id1": "2022160", "id2": "9450274", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public void seeURLConnection() throws Exception {\n        URL url = new URL(\"http://wantmeet.iptime.org\");\n        URLConnection uc = url.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n        String s = null;\n        StringBuffer sb = new StringBuffer();\n        while ((s = br.readLine()) != null) {\n            sb.append(s);\n        }\n        br.close();\n        log.debug(\"sb=[\" + sb.toString() + \"]\");\n    }\n", "label": 0, "substitutes": {"write": ["writer", "play", "flow", "cycle", "append", "call", "copy", "wrote", "lex", "data", "store", "writing", "sync", "written", "writ", "output", "connect", "set", "run", "read", "end", "Write", "out", "code", "process", "flush", "create", "add", "size", "dump", "send", "pipe", "exec", "kill", "service", "w", "next", "put", "update", "close", "feed", "export", "open"], "byteBuffers": ["byteChers", "bytesAkers", " byteOrdeners", "byteAkors", "ByteBufflers", "bytesDefatters", "byteChered", " byteBuffinals", "bytesAkelines", "bytesPackERS", " byteBuffiners", "byteOrdeners", "bytebuffings", "byteIntegeners", "byteDefatters", " byteOrdinals", "byteBuilderers", "doubleHeadings", "byteBuffatters", " byteBufferers", "byteBuffinals", "byteInteginals", "byteCornlers", "connectionBuffers", "byteChERS", "doubleBuffered", "bytebuffeners", "connectionBuffERS", "bytebuffered", "byteOffers", "byteHeadERS", "doubleHeadered", "ByteBufferers", "byteBuffERS", "byteAkers", "bytesCornered", "byteIntegERS", "byteWriters", " byteOrderers", " byteOrdlers", "doubleBuffERS", "bytebuffinals", "byteOffors", "wordBuffatters", "bytesDefelines", "wordBuffers", "bytesCornests", "byteCornares", "byteIntegers", "byteDefers", "byteWriterers", "doubleHeaders", "bytebuffelines", "byteBufferatters", "byteWritelines", "byteIntegatters", "bytebufferers", "bytebuffers", "byteWritiners", "doubleBuffings", "byteBuffters", "byteHeadered", "byteBuffererers", "bytesDefers", "connectionbuffERS", "bytesBufferers", " byteOffters", "bytesCornatters", "bytePackapers", "ByteOrderers", " byteBuffors", "byteHeaders", "byteBufferERS", " byteOffors", "bytesBuffizers", "byteWritizers", "byteBuffors", "ByteBuffresses", "ByteOrdERS", "byteBuffresses", " byteBufflers", "byteChings", "byteBuffeners", "bytebuffERS", "connectionbuffers", "wordBuffERS", " byteCompERS", "bytePackerers", " byteBuffares", "byteOrdapers", "byteCompares", "bytesBuffatters", "bytesBuffests", "byteOrders", "ByteOrders", " byteCompers", " byteOrdERS", "byteComplers", "bytesBuffERS", "byteBufferers", "doubleHeadERS", "bytesAkizers", "byteOffters", "byteInfers", "byteCornatters", "bytebuffatters", "byteOrderers", "byteDefelines", "byteCompers", "wordBufferers", "byteBuffings", "bytePackERS", "byteCornERS", "byteBuffapers", "byteCornests", "byteDefERS", "byteInferers", "bytesBuffapers", "byteOrdERS", " byteBuffERS", "bytebufflers", "byteBufferapers", "bytebuffors", " byteBuffters", "byteAkizers", "bytesCorners", "byteBuildERS", "byteHeadings", "bytesPackapers", "ByteBuffERS", "byteBuffered", "byteCorners", "doubleBuffers", " byteCompares", "bytesBuffors", "byteBufflers", "bytebuffizers", " byteComplers", "byteBufferelines", "byteBuffares", "byteBuffiners", " byteOffERS", "bytebuffests", "byteOffERS", "byteOrdlers", "byteCompERS", "byteWritors", "bytesDefERS", "byteAkelines", "byteCornered", "ByteOrdresses", "bytesBuffered", "byteWritlers", " byteOrders", " byteOrdiners", "byteOrdiners", "byteInfatters", " byteOffers", "byteBuffizers", "byteBuildatters", "connectionbufferers", "connectionBufferers", "byteBuffests", " byteBuffeners", "ByteBuffers", "bytebuffters", "bytebuffresses", "byteBuilders", "bytesPackerers", "byteOrdresses", "byteOrdinals", "bytePackers", "byteInfERS", "byteBuffereners", "bytesBuffers", "connectionBuffeners", "bytesAkors", "bytesBuffelines", "byteBuffelines", "byteBufferlers", "bytebuffiners", "byteIntegelines", "connectionbuffeners", "bytesPackers"], "m_initialOutBuffer": ["m_initialInFile", "m_initialInLine", "m_finalOutLine", "m_initialAuthBuffer", "m_InitialOutFile", "m_initialoutCache", "m_initialoutChannel", "m_initialOutChannel", "m_initialClientBuffer", "m_finalOutMessage", "m_initialOutputHeader", "m_initialInBuffer", "m_finalOutCache", "m_InitialOutputBuffer", "m_finalOutFile", "m_initialoutAddress", "m_initialShortFile", "m_originaloutBuffer", "m_initialOutHeader", "m_initialoutBuff", "m_initialOutputLayer", "m_initialOutBuff", "m_initialNewFile", "m_InitialOutLayer", "m_finaloutBuffer", "m_finalOutBuff", "m_initialSocketLayer", "m_initialOutputFile", "m_finalInLine", "m_initialNewMessage", "m_finaloutFile", "m_initialOutMessage", "m_initialOutputBuffer", "m_originalOutBuffer", "m_finalOutBuffer", "m_initialOutLayer", "m_initialoutFile", "m_initialAuthFile", "m_initialShortCache", "m_initialInLayer", "m_initialSocketFile", "m_finaloutBuff", "m_initialNewBuffer", "m_originaloutLine", "m_initialSocketBuffer", "m_originaloutFile", "m_originalOutAddress", "m_InitialOutputFile", "m_initialInCache", "m_finalInFile", "m_originaloutAddress", "m_finalOutChannel", "m_initialClientBuff", "m_initialInChannel", "m_initialOutCache", "m_initialOutLine", "m_initialAuthLine", "m_InitialOutputHeader", "m_initialOutAddress", "m_InitialOutHeader", "m_finalInMessage", "m_initialOutputBuff", "m_initialoutBuffer", "m_initialInMessage", "m_initialNewBuff", "m_originalOutLine", "m_finalInChannel", "m_initialClientFile", "m_initialClientLine", "m_initialOutFile", "m_finalInBuff", "m_initialShortChannel", "m_initialOutputChannel", "m_initialoutLine", "m_initialInAddress", "m_InitialOutBuffer", "m_initialAuthAddress", "m_finalInBuffer", "m_initialOutputMessage", "m_initialInBuff", "m_InitialOutputLayer", "m_initialSocketHeader", "m_initialShortBuffer", "m_originalOutFile", "m_initialInHeader", "m_finalInCache", "m_finaloutChannel"], "buffer": ["console", "writer", "null", "view", "data", "bc", "phrase", "row", "temp", "queue", "cache", "string", "file", "uffer", "wave", "page", "resource", "message", "server", "event", "cell", "back", "shell", "port", "limit", "input", "template", "read", "timeout", "builder", "iter", "config", "er", "worker", "object", "loader", "layer", "feed", "url", "fb", "channel", "batch", "cur", "flush", "comment", "holder", "re", "binary", "transfer", "FFER", "block", "buf", "array", "copy", "engine", "Buffer", "ker", "output", "document", "f", "stack", "source", "reader", "header", "client", "buff", "base", "table", "slice", "address", "window", "pool", "response", "bridge", "callback"], "buffers": ["bufered", "buffERS", "ufors", "affaches", "buffered", "bufering", "buffler", "transformers", "bufresses", " buffators", "phages", "Bufferers", "buferers", "transformERS", "buffators", "Buffars", "transformler", "bufler", "buffages", " buffler", "buffaches", "affering", "phators", " buffering", "buffering", "Buffers", " buffERS", "phers", "Buffered", "bufages", " buffered", "phresses", "transformering", "affers", " buffresses", "ufering", "ufaches", "bufERS", "buffresses", " buffages", "ufers", "bufaches", " bufferers", " buffars", "bufers", "bufars", "bufors", "bufators", "bufferers", "buffars", "buffors", "affors"], "result": ["res", "url", "default", "resource", "report", "message", "complete", "view", "rc", "rate", "event", "info", "data", "successful", "session", "winner", "search", "output", "status", "f", "acc", "valid", "error", "date", "val", "out", "test", "row", "ver", "results", "comment", "future", "driver", "consumer", "true", "flash", "er", "Result", "inner", "user", "r", "cache", "match", "err", "card", "success", "re", "sr", "up", "grade", "diff", "ret", "json", "response", "runner", "function", "or", "cup", "manager", "use", "request"], "encrypted": ["available", "text", "pad", "padding", "image", "body", "channel", "selected", "entry", " data", "temp", "flush", "source", "config", "reader", "flash", "stream", "inner", "internal", "packed", "cache", "loader", "extra", "interrupted", "binary", "layer", "transfer", "secret"]}}
{"id1": "18238468", "id2": "8754809", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"testLoadSource": ["TestLoadFormat", "testLoadSources", "testloadSources", "TestloadSourceFile", "testAddSourceFile", "testReadSourceFile", "testReadFormat", "TestloadSources", "TestLoadSource", "testloadFormat", "TestloadFormat", "testAddFormat", "testReadSources", "TestLoadSourceFile", "TestLoadSources", "testLoadFormat", "testAddSources", "TestloadSource", "testloadSource", "testloadSourceFile", "testReadSource", "testAddSource", "testLoadSourceFile"], "metadata": ["m", "sample", "attribute", "np", "default", "message", "module", "general", "summary", "sheet", "material", "info", "data", "music", "md", "mo", "this", "parser", "journal", "definition", "document", "tt", "map", "template", "meta", "xml", "source", "ami", "reader", "properties", "header", "tmp", "media", "stream", "filename", "pdf", "my", "artist", "params", "loader", "ctx", "generic", "auto", "json", "content", "adata", "iterator", "collection", "manager", "database", "df"], "inputStream": ["streamSteam", "outputStream", "inputSteam", "rawstream", "streamStream", "inputWriter", "InputFile", "outputStreamer", "outputstream", "inputFile", "rawStream", "outputForm", " inputForm", " inputSource", "streamStreamer", "inputStreamer", "inputForm", " inputWriter", "outputFile", "Inputstream", "InputWriter", "outputWriter", "streamstream", "InputSource", "outputSource", " inputFile", "rawStreamer", "InputForm", "inputSource", "outputSteam", "InputSteam", "rawSteam", "inputstream", " inputstream", "InputStream", " inputSteam"], "writer": ["ana", "WR", "text", "widget", "wr", "write", "master", "null", "data", "writing", "external", "written", "writ", "output", "winner", "document", "creator", "her", "editor", "Writer", "key", "out", "settings", "code", "temp", "rw", "builder", "driver", "reader", "riter", "worker", "inner", "usher", "walker", "r", "cache", "string", "handler", "w", "per", "writers", "words", "wrapper", "keeper", "word", "pointer", "buffer", "format", "author", "ler", "director", "RW"], "contents": ["CONTences", "constent", "contENTS", "contentents", "contentacts", "Contacts", "Contents", "CONTented", "Contences", "Content", "constents", "contentences", "Contented", "constENTS", "ContENTS", "contences", "CONTent", "contented", "contacts", "CONTacts", "constented", "content", "CONTents", "contentent", "CONTENTS"]}}
{"id1": "8490710", "id2": "20663364", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 1, "substitutes": {"actualizar": ["actualisias", "actualizeada", "actualizerado", "actualizas", "actualizeas", "actualisiado", "actualizear", " actualizeado", " actualizada", "actualizeado", " actualizeas", "actualizeras", "actualisiar", " actualizear", " actualizado", "actualizerar", " actualizas", "actualizado", "actualisiada", "actualizerada", " actualizeada", "actualizada"], "ClassNotFoundException": ["ClassNotPresentError", "ClassNotFindException", "ClassNotSupportedException", "ClassNotFindES", "ClassNameFoundException", "ClassNameSupportedError", "ClassNotSupportedError", "ClassNameFoundES", "ClassNotSupportedES", "ClassNameSupportedException", "ClassNameSupportedES", "ClassNotFindError", "ClassNotPresentException", "ClassNotPresentES", "ClassNotFoundError", "ClassNameFoundError", "ClassNotFoundES"], "Exception": ["Unknown", "Interface", "Information", "Application", "X", "Null", "Adapter", "except", "Entity", "Element", "Error", "Ex", "Connection", " exception", "Engine", "Throw", "Failure", "Request", "ERROR", "Abstract", "Context", "T", "Warning", "ceptions", "Document", "Fail", "Class", "W", "Default", "E", "Exc", "Except", "Un", "Event", "EX", "F", "Problem", "Transaction", "IO", "ception", "Exp"], "conn": ["ct", "cn", "col", "Connect", "conf", "n", "connection", "loc", "cp", "pg", "en", "rc", "ok", "session", "sql", "reg", "jc", "oss", "Connection", "connect", "sn", "mc", "nt", "coll", "ch", "nc", "ci", "h", "cb", "ens", "Conn", "cc", "cat", "cm", "oci", "config", "client", "cli", "db", "ann", "con", "c", "mm", "dc", "comm", "ob", "ou", "ctx", "pub", "state", "dh", "cs", "ca", "enc", "util", "cr", "p"], "ms": ["MS", "mes", "ls", "m", "res", "js", "keys", "ins", "DS", "details", "mp", "ps", "rs", "os", "ns", "mis", "mo", "md", "sem", "tm", "sql", "ums", "ems", "pse", "es", "mas", "mx", "vs", "mc", "ys", "fs", "s", "ens", "hm", "me", "ws", "mb", "bm", "ims", "is", "cms", "cus", "gm", "mn", "mi", "qs", "mos", "models", "mm", "ma", "ml", "ts", "oms", "em", "pm", "ans", "Ms", "mt", "gs", "ops", "cs", "mod", "bs", "ks", "ds"], "fechaSystem": ["febasSys", "fetchaSystem", "fechtasystem", "fechlasystem", "fetchaSTEM", "febaService", "fechmaSystem", "febasServer", "fekaSystem", "fechetaServer", "fechaServer", "fechmaSTEM", "fechaService", "fekasSTEM", "fechlaSys", "fichlaSys", "fichlasystem", "fechoSystem", "fechasSTEM", "fetchmaSystem", "fechasServer", "fechtaSystem", "fechosystem", "fechasystem", "fekasSys", "fechoSTEM", "febasService", "fetchmaSTEM", "fechaSys", "fetchasystem", "fechassystem", "fichasystem", "fichaSys", "fechaSTEM", "febaSys", "febaSystem", "fechetaService", "fekaSys", "fechmasystem", "fekaSTEM", "fechlaSystem", "fetchmasystem", "fichaSystem", "fechmaServer", "fechetaSystem", "febasSystem", "fechasSys", "fechasService", "fichlaSystem", "fechlaSTEM", "febaServer", "fechasSystem", "fekasSystem", "fechmaSys", "fechetaSys", "fechmaService", "fechtaSys"], "aaaammdd": ["aaaaamtz", "aaaasmtz", "aaaamds", "aaaasmd", "aaaaamds", "aaaaammtz", "aaaamd", "aaaamdd", "aaaamsd", "aaaammtz", "aaammtz", "aaaaammsd", "aaammds", "aaaamtz", "aaammsd", "aaaymmds", "aaaymmdd", "aaaymmsd", "aaaaamsd", "aaaymmd", "aaaaammdd", "aaammd", "aaaaammds", "aaaasmds", "aaaaamdd", "aaaasmdd", "aaaammds", "aaaammd", "aaaaamd", "aaammdd", "aaaaammd", "aaaammsd"], "fzafsis": ["fzhahtics", "fzAFtics", "fzhahsis", "fzafsi", "fzaphtics", "fzhaftics", "fzafs", "fzhafsis", "fzAFsi", "fzahs", "fzaphsi", "fzahsi", "fzaphsis", "fzhahsi", "fzhahs", "fzhafs", "fzAFsis", "fzhafsi", "fzahtics", "fzAFs", "fzaftics", "fzaphs"], "hhmmss": ["HHMMss", "hhhmms", "hhhmmds", "hhmlms", "HHMMs", "hhmms", "hhmmmss", "hhmmmds", "HHmmss", "HHmmms", "hhmdds", "hhmmmess", "HHmms", "hhMMess", "hhmmds", "HHMMds", "hhhmmess", "hhMMs", "hhhmmss", "hhmlss", "hhmmms", "hhmss", "hhMMss", "hhmdess", "hhmdss", "HHMMms", "hhmlds", "hhmls", "hhMMms", "HHmmds", "hhMMds", "hhhmmms", "hhmds", "hhhmmmess", "hhms", "hhhmmmss", "hhmmess", "hhhmmmds"], "sss": ["rsss", "hessns", "hessss", "ussss", "ssp", "ssss", "ssses", "rssp", " ssss", "hesss", "ussses", "ssls", "usss", "ssns", " ssp", "rssss", "rssls", "\u00dfns", "rssses", "rssns", "\u00dfls", " ssses", "ussp", "\u00dfss", "hessls", "\u00dfs"], "ss": ["css", "ls", "rss", "ess", "js", "ssl", "ross", "sf", "struct", "tz", "st", "ps", "sv", "rs", "pg", "ns", "si", "oss", "str", "vs", "su", "SS", "s", "ng", "fs", "settings", "ws", "pass", "sq", "hh", "xx", "pps", "WS", "eps", "ses", "ass", "string", "uss", "hess", "iss", "less", "account", "sl", "ts", "ssh", "\u00df", "cs", "bs", "nn", "ds", "styles"], "fzahsis": ["fzafsi", "fzavtics", "fzajses", "fzeajses", "fzajsi", "fzeafsi", "fzeaftics", "fzavsi", "fzahsi", "fzeajtics", "fzafses", "fzeafses", "fzeajsis", "fzahses", "fzeajsi", "fzajtics", "fzahtics", "fzaftics", "fzajsis", "fzavses", "fzeafsis", "fzavsis"], "afectados": ["rafectados", "afectatos", "AFecadas", "afctados", "afectado", "rafctado", "afemptados", "rafectatos", "afecanos", "AFectantes", "AFecanos", "AFectanos", "afecantes", "afectantes", "afectionado", "AFectados", "afemptatos", "afctadas", "rafectado", "afemptado", "afectionados", "afescantes", "afectanos", "afescados", "AFecados", "afctado", "afescadas", "afecadas", "rafctadas", "afectionatos", "afectionadas", "afectionanos", "afctatos", "afemptadas", "rafectadas", "rafctados", "afecados", "AFecantes", "afescanos", "rafctatos", "afectadas", "AFectadas", "afectionantes"]}}
{"id1": "692738", "id2": "3375724", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["ur", "uri", "ssl", "resource", "ll", "server", "image", "fr", "null", "html", "connection", "loc", "io", "link", "f", "www", "URL", "ref", "href", "bel", "el", "xml", "source", "config", "rl", "filename", "l", "lr", "base", "id", "address", "string", "file", "name", "loader", "service", "ob", "sl", "host", "location", "Url", "path", "buffer", "http", "feed"], "in": ["m", "ex", "ins", "ssl", "resource", "image", "In", "n", "init", "io", "data", "this", "socket", "inc", "part", "f", "gin", "impl", "input", "din", "IN", "inn", "val", "out", "conn", "xml", "i", "is", "source", "rin", "reader", "config", "cms", "inside", "a", "nin", "login", "inner", "min", "r", "id", "token", "con", "file", "err", "c", "bin", "pin", "ini", "as", "or", "again", "serv", "isin"]}}
{"id1": "1362", "id2": "10759917", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["ubblingsort", "bubbleOrder", "ubbleCompare", "ubbleOrder", "ubblingCompare", "ubblesort", "bubblessort", "bubblingOrder", "bubblerOrder", "bubblerCompare", "bubbleCompare", "bubblesCompare", "ubbleSort", "ubblingOrder", "bubblersort", "bubblingsort", "bubblesSort", "bubblingSort", "bubblesort", "bubblerSort", "ubblingSort", "bubblesOrder", "bubblingCompare"], "a": ["at", "m", "p", "array", "u", "oa", "A", "va", "tta", "e", "b", "aw", "an", "empty", "data", "all", "f", "area", "result", "apps", "aaa", "ga", "o", "index", "d", "ae", "aj", "s", "ack", "access", "l", "another", "work", "ad", "ata", "any", "na", "ba", "ac", "sa", "address", "au", "c", "alpha", "ma", "sup", "aux", "list", "am", "la", "ama", "ans", "auto", "as", "something", "ab", "abs", "active", "aa", "img"], "swapped": [" swaped", "rewaped", "waped", "swoped", "rewapping", "Swaped", "rewoped", "flapping", "floped", "rewaps", " swap", "swap", "rewapped", "wapping", "rewap", "swapping", "flap", "Swapped", "flapped", "swaped", " swapping", "wapped", " swaps", "swaps", "wap", "waps", "Swoped", "Swapping", "Swap"], "i": ["k", "m", "p", "u", "uri", "e", "module", "j", "anti", "b", "ki", "fi", "init", "ori", "io", "info", "adi", "si", "ie", "in", "f", "ni", "it", "iv", "index", "d", "ci", "iu", "h", "oi", "key", "uni", "mini", "api", "y", "ami", "multi", "li", "l", "mi", "ip", "pi", "hi", "xi", "di", "eni", "ind", "id", "ti", "v", "gi", "start", "sup", "ix", "I", "ai", "next", "ini", "ui", "ii", "x", "bi", "qi", "ri"], "tmp": ["bb", "m", "pad", "txt", "j", "append", "dest", "b", "mp", "cmp", "prev", "st", "tc", "ie", "part", "f", "stuff", "area", "tt", "opp", "test", "vt", "temp", "addr", "foo", "kk", " ff", "amp", "v", "tv", "obj", "alpha", "sup", "xxx", "t", "angle", "pre", "mmm", "qq", "yy", "x", "front", "nb", "emp", "pp", "p"]}}
{"id1": "21491791", "id2": "23611770", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"run": ["spawn", "running", "log", "unit", "call", "apply", "build", "Run", "func", "loop", "all", "job", "test", "code", "process", "create", "work", "worker", "command", "fork", "exec", "start", "app", "runner", "invoke", "execute"], "input": ["text", "flow", "resource", "image", "view", "connection", "form", "io", "data", "parser", "reading", "raw", "in", "entry", "audio", "storage", "index", "read", "out", "conn", "instance", "source", "driver", "config", "client", "stream", "work", "worker", "inner", "user", "Input", "internal", "control", "address", "file", "initial", "loader", "up", "context", "state", "iterator", "active", "feed", "request", "readable"], "output": ["page", "text", "exit", "log", "console", "unit", "write", "resource", "image", "parent", "connection", "letter", "outer", "data", "later", "writing", "written", "application", "document", "generated", "index", "Writer", "job", "end", "out", "temp", "source", "Output", "config", "network", "filename", "web", "target", "user", "queue", "control", "object", "cache", "file", "writers", "path", "response", "environment", "operation", "put", "office"], "reader": ["book", "request", "peer", "resource", "image", "server", "rer", "view", "system", "io", "parser", "ner", "reading", "in", "entry", "audio", "Reader", "read", "row", "rator", "builder", "source", "driver", "client", "riter", "stream", "er", "worker", "slave", "inner", "r", "handler", "loader", "context", "wrapper", "author", "oder", "manager", "ri", "owner"], "writer": ["wr", "write", "wan", "connection", "outer", "data", "writing", "engine", "ner", "written", "writ", "entry", "creator", "her", "editor", "Writer", "ew", "out", "wer", "player", "maker", "ws", "rw", "builder", "nw", "driver", "war", "riter", "work", "er", "worker", "ter", "inner", "r", "wa", "wire", "w", "wb", "writers", "wrapper", "or", "word", "office", "author", "manager", "request"], "pump": ["camp", "ppumping", "pumping", "pamp", "prump", "Pmp", "mprint", "dumps", "pdump", " pmp", "Pam", "ppumper", "cump", "ppumps", "Pdump", "humper", "cumper", "mumper", "pumps", "Pumper", " pdump", "Pump", " pumper", "pam", "pumper", "pmp", "Pumping", "prumper", "pprint", "Pprint", "humps", " pumping", "dmp", "mump", "hump", "dump", "Pamp", "pram", "Pumps", " pumps", "dumper", " pam", "hprint", " pamp", "prdump", "ppump", "mumps", "cumping"], "counter": ["enter", "page", "Counter", "url", "server", "clock", "const", "master", "count", "parent", "offset", "num", "race", "outer", "version", "step", "ner", "hello", "sequence", "cookie", "loop", "entry", "now", "result", "meter", "timer", "second", "index", "ener", "row", "code", "ver", "instance", "progress", "consumer", "comment", "trace", "center", "rew", "builder", "keep", "ter", "er", "worker", "seed", "number", "ger", "walker", "lr", "r", "inner", "starter", "repeat", "loader", "continue", "inter", "order", "layer", "runner", "current", "currency", "pointer", "author", "zero", "collection", "keeper", "ception", "processor"], "buffer": ["buf", "page", "uf", "text", "url", "message", "resource", "server", "length", "data", "port", "Buffer", "channel", "limit", "entry", "document", "batch", "source", "iter", "header", "buff", "base", "queue", "position", "address", "file", "loader", "reference", "binary", "layer", "uffer"], "off": ["own", "art", "oa", "Off", "flow", "offset", "OFF", "info", "pos", "offs", "now", "area", "fail", "o", "set", "ref", "end", "out", "Offset", "open", "addr", "ff", "of", "opt", "inner", "eno", "less", "low", "ord", "start", "left", "down", "unknown", "ui", "auto", "head", "on", "offer"], "len": ["fd", "lon", "gen", "log", "ln", "fl", "url", "lf", "fin", "ll", "length", "count", "n", "body", "loc", "en", "lock", "lan", "limit", "in", "pos", "all", "elt", "lin", "ref", "Len", "end", "val", "el", "size", "width", "li", "l", "lit", "lim", "den", "bin", "name", "ld", "layer", "ler", "lc", "lt", "line", "on", "lib"], "rd": ["fd", "rt", "red", "rand", "rm", "rss", "raid", "fr", " r", "xd", "nd", "rx", "rob", "ru", "dr", "RR", "nr", "rc", "rs", "rh", "dd", "d", "rb", "rn", "val", "rid", "RD", "rw", "rl", "rr", "db", "lr", "r", "ind", "adr", "ud", "ord", "dra", "rod", "ld", " prod", "hr", "ra", "cr", "rf", "ds"]}}
{"id1": "20623709", "id2": "11704429", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"split": ["Split", "append", "copy", "build", "cmp", "init", "sync", "part", "archive", "set", "sort", "run", "process", "add", "parse", "delete", "match", "exec", "share", "start", "diff", "transfer", "format", "update", "execute", "open", "join"], "targetDirectory": ["destFile", "targetFolder", "masterPath", "currentFolder", " targetDir", "targetDatabase", "currentRoot", "TargetDatabase", "targetDir", "targetPath", "baseDirectory", "destFolder", " targetRoot", "baseDir", "TargetRoot", "TargetFile", "outputFile", "destDir", "currentDir", "TargetDir", "outputDirectory", "TargetPath", "TargetDirectory", "targetFile", "currentPath", "currentDirectory", "outputDir", " targetPath", "outputFolder", "masterDir", "TargetFolder", "destDirectory", "masterDirectory", "baseDatabase", " targetFolder", "basePath", "masterDatabase", "baseFile", " targetFile", "baseFolder", "targetRoot"], "prefix": ["prot", "padding", "uri", "unit", "resource", "txt", "append", "offset", "username", "FIX", "sequence", "folder", "index", "template", "timeout", "type", "temp", "config", "directory", "filename", "number", "base", "queue", "cache", "string", "patch", " suffix", "name", "resolution", "ix", "fix", "pre", "domain", "root", "pattern", "path", "fixed", "first", "format", "fp", "Pref"], "maxUnitBases": ["maxUnitEases", "maxUnitAliases", "maxUnitChase", "maxUnitBase", "maxunitAliases", "maxUnitEaches", "maxUnitQueases", "maxunitAliasing", "maxunitAliails", "maxUnitQueasing", "maxUnitAliase", "maxUnitAliasing", "maxUnitChues", "maxUnitAliues", "maxUnitAliails", "maxunitBaches", "maxUnitBaches", "maxUnitEails", "maxUnitPlases", "maxunitBues", "maxUnitAliaches", "maxunitBases", "maxUnitPlase", "maxunitAliaches", "maxUnitBails", "maxunitAliase", "maxunitAliues", "maxUnitPlaches", "maxunitBase", "maxUnitBues", "maxunitBasing", "maxUnitEase", "maxUnitChasing", "maxUnitQueues", "maxUnitBasing", "maxUnitPlails", "maxunitBails", "maxUnitChases", "maxUnitQuease"], "maxUnitEntries": ["maxLineEntrations", "maxUnitEnties", "maxUnitEntryry", "maxLineOrdrations", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdines", "maxUnitErries", "maxUnitEntryresses", "maxUnitIntresses", "maxunitEntries", "maxUnitEntryies", "maxUnitInties", "maxunitEnties", "maxLineEntines", "maxUnitEntines", "maxUnitEntryrys", "maxUnitOrdies", "maxunitEntrys", "maxUnitIntries", "maxLineOrdries", "maxLineEntry", "maxUnitCountries", "maxUnitAddries", "maxUnitEntry", "maxunitEntresses", "maxUnitErry", "maxUnitEntrations", "maxunitEntryresses", "maxUnitOrdrys", "maxUnitCountrations", "maxUnitEntresses", "maxUnitEntrys", "maxLineOrdry", "maxLineOrdines", "maxUnitOrdry", "maxUnitErines", "maxUnitAddures", "maxUnitOrdries", "maxUnitErrations", "maxunitEntryries", "maxUnitEntures", "maxLineEntries", "maxUnitOrdresses", "maxunitEntryies", "maxUnitOrdrations", "maxUnitCountry", "maxUnitIntrys", "maxunitEntryrys", "maxUnitEntryries", "maxUnitAddry", "maxUnitCountines"], "fis": ["forisa", "visa", "foris", "forai", " fiss", "foriss", "fisa", "Fris", "fris", "Fisc", "fai", " fIs", "Fiss", " fris", " fisa", "vai", "forIs", "fisc", "forisc", "forris", " fai", "fIs", "fiss", "vis", " fisc", "vIs", "Fis"], "fci": ["hci", "vcos", "efai", " fii", "fai", "dci", "dii", "hcos", "efco", "bis", "bco", "vai", "Fai", "vco", "Fci", "dco", "efcos", "hai", " foci", "bci", " fai", "foci", "bai", "vci", "Foci", "Fii", "Fco", "fii", "doci", "efci", "fcos", "Fis", "hco"], "fos": ["tis", "fo", "fso", "fscos", "Fos", "infos", "ifo", "Foss", "ifcos", "fsios", "infoss", "toss", "fios", " fo", " fcos", "ifios", "fsos", "tos", "infis", "ifos", "foss", "Foes", "foes", " fios", "infoes", "toes", "fcos", "Fis"], "fco": ["hgo", "dcos", "fileico", "Fbo", "Fico", " fro", "fro", "hci", " fgo", "fbo", "dro", "hcos", "filebo", "fileci", "dci", "fgo", "Fci", "dco", "fico", " fico", "fileco", " fbo", "lro", "lgo", " fcos", "lcos", "lco", "Fco", "fcos", "lci", "hco"], "buffer": ["border", "buf", "request", "pad", "writer", "resource", "message", "server", "image", "length", "copy", "null", "offset", "view", "info", "data", "scale", "Buffer", "bc", "channel", "entry", "document", "result", "input", "translation", "batch", "read", "timeout", "texture", "comment", "iter", "memory", "reader", "flush", "size", "header", "source", "buff", "expression", "capacity", "base", "bar", "queue", "position", "cache", "counter", "bin", "window", "loader", "binary", "reference", "device", "pause", "layer", "response", "uffer", "transfer", "context", "zero", "feed", "block", "callback", "rate"], "currentBasesCount": ["currentBasescount", "currentBasesNum", "currentBatchescount", "currentChasesCounter", "currentChasesNum", "currentBatchesCounter", "currentChasesCount", "currentBaseCount", "currentBaseCounter", "currentChasecount", "currentBasesCounter", "currentBasingCounter", "currentBasecount", "currentBasingNum", "currentChasescount", "currentBatchesCount", "currentBaseNum", "currentBatchesNum", "currentChaseCounter", "currentBasingcount", "currentChaseNum", "currentBasingCount", "currentChaseCount"], "currentEntriesCount": ["currentEntursOffset", "currentEntriesOffset", "currentEntursLimit", "currentAddriesOffset", "currentEntriesSize", "currentEnturesOffset", "currentEntrasCount", "currentEntursCount", "currentEntrasLimit", "currentAddriesLimit", "currentAdduresCount", "currentEnturesCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresSize", "currentEntrasSize", "currentAdduresLimit", "currentEntursSize", "currentEnturesSize", "currentEnturesLimit", "currentAddriesSize", "currentEntriesLimit", "currentAddriesCount"], "targetCount": ["targetSum", "patternSize", "targetcount", "patternCount", "TargetSize", "TargetSum", "argetSum", "argetcount", "patterncount", "Targetcount", "patternSum", "argetSize", "TargetCount", "argetCount", "targetSize"], "fastaChannel": ["fastasChannel", "fastasContext", "fastaqBuffer", "fastasContainer", "fastanContext", "fastasConnection", " fastaContext", " fastABuffer", "fastaqConnection", "fastaConnection", "fastasBuffer", "fastAConnection", "fastaqColumn", " fastAColumn", "fastaqChannel", "fastaContainer", "fastanBuffer", "fastABuffer", " fastAConnection", "fastaColumn", "fastAContext", " fastaConnection", "fastAChannel", " fastAChannel", " fastaColumn", "fastAContainer", " fastAContext", " fastAContainer", " fastaContainer", "fastanChannel", "fastasColumn", "fastanContainer", "fastaContext", "fastAColumn"], "totalSeqCount": ["totalSeqCounter", "totalQueqCount", "totalQueQNum", "totalSeuxNum", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQCounter", "totalSeQcount", "totalQueQCounter", "totalQueqcount", "totalQueqNum", "totalSeuxcount", "totalSeuxCount", "totalQueqCounter", "totalSeuxCounter", "totalSeqNum", "totalSeQNum", "totalSeqsCount", "totalSeqsNum", "totalQueQCount", "totalSeqscount"], "totalResiduesCount": ["totalResiduingNum", "totalResiduesSize", "totalResiduescount", "totalResqueuesNum", "totalResiduingCount", "totalResqueuescount", "totalResqueuresNum", "totalResiduationSize", "totalResqueurescount", "totalResiduationNum", "totalResiduresNum", "totalResiduationCount", "totalResiduationcount", "totalResiduingcount", "totalResqueuresSize", "totalResidurescount", "totalResiduresCount", "totalResiduesNum", "totalResqueuesSize", "totalResqueuresCount", "totalResqueuesCount", "totalResiduingSize", "totalResiduresSize"], "prevTime": ["PrevSize", "PrevValue", "commitSize", "commitFile", " prevSize", "PrevTime", "commitValue", " prevFile", "PrevFile", "prevFile", "commitTime", "prevValue", " prevValue", "prevSize"], "fastaFileSize": ["fastaBlockLength", "fastaBlockCount", "fastaPageAddress", "fastABufferAddress", "fastAFileSize", "fastaHeaderLength", "fastasFileSize", "fastAFileLength", "fastaLineCount", "fastAFileAddress", "fastaHeaderAddress", "fastAFileCount", "fastABufferLength", "fastaBlockSize", "fastaFilesLength", "fastaBufferSize", "fastaFileAddress", "fastasFileAddress", "fastaHeaderName", "fastasHeaderSize", "fastaHeaderSize", "fastaPageName", "fastaLineLength", "fastaFileName", "fastaBufferAddress", "fastaBlockAddress", "fastaFilesSize", "fastasHeaderLength", "fastaLineAddress", "fastasHeaderAddress", "fastaLineSize", "fastABufferSize", "fastABufferCount", "fastaFilesName", "fastasFileLength", "fastaBufferCount", "fastaFileLength", "fastaPageSize", "fastasHeaderName", "fastaBufferLength", "fastaFilesAddress", "fastasFileName", "fastaPageLength", "fastaFileCount"], "fastaFileReadOffset": ["fastaFileWriteAmount", "fastaFileRunEntry", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaFileWriteoffset", "fastaFileLoadAmount", "fastaBufferReadOffset", "fastaBufferReadoffset", "fastaFilesWriteLength", "fastaFileStartOff", "fastaFileRunoffset", "fastaFileReadoffset", "fastaFileReadLength", "fastaFileLengthLength", "fastaFilesReadoffset", "fastaFileWriteEntry", "fastaFilesReadOffset", "fastaFileLoadoffset", "fastaBufferReadAmount", "fastaBufferWriteOffset", "fastaFileReadOff", "fastaBufferWriteoffset", "fastaFileWriteOff", "fastaDirectoryReadEntry", "fastaFilesReadLength", "fastaFilesWriteoffset", "fastaDirectoryWriteOff", "fastaFileRunOff", "fastaBufferReadLength", "fastaFileLengthOffset", "fastaFileWriteOffset", "fastaFilereadoffset", "fastaFilereadLength", "fastaFileLoadOffset", "fastaFilesWriteOff", "fastaFileWriteLength", "fastaFileStartoffset", "fastaDirectoryWriteEntry", "fastaFileStartOffset", "fastaFileReadAmount", "fastaDirectoryReadoffset", "fastaDirectoryReadOff", "fastaFilereadOffset", "fastaFileLengthoffset", "fastaFileLoadLength", "fastaFileRunOffset", "fastaFilesReadOff", "fastaFileReadEntry", "fastaFilesWriteOffset", "fastaDirectoryWriteoffset", "fastaFileLengthOff", "fastaFileStartEntry", "fastaBufferWriteAmount", "fastaFileLengthAmount", "fastaFilereadOff", "fastaBufferWriteLength"], "partitionStartOffset": ["partitionsStartRange", "partitionEndOff", "partitionBufferOff", "partitionStartOff", "partitionsStartOrder", "partitionsEndOff", "partitionStopRange", "partitionBufferOrder", "partitionEndRange", "partitionsEndRange", "partitionsStartOffset", "partitionStopOrder", "partitionBufferRange", "partitionEndOrder", "partitionStopOff", "partitionStartOrder", "partitionStartRange", "partitionsEndOffset", "partitionsStartOff", "partitionBufferOffset", "partitionStopOffset", "partitionsEndOrder"], "bufferSize": ["BufferC", " bufferSIZE", "bufferC", "processC", "BufferSIZE", "processSIZE", "queueSize", "bufferType", "BufferSize", "BufferCount", "BufferType", " bufferCount", "bufferSIZE", "bufferCount", "processType", "queueCount", " bufferType", "processSize", " bufferC"], "fastaBuffer": ["fastasChannel", "FastaBuff", " fastABuff", " fastaBuff", "fastasContainer", "fastasPtr", "fastaaPtr", "fastanFile", "FastasPtr", "FastaStream", "fastAQueue", "fastasFile", "FastaBuffer", " fastasChannel", "fastaQueue", " fastABuffer", "fastaFile", " fastaFile", "fastaStream", "fastAFile", "fastaaBuff", "fastasBuffer", "FastasChannel", "fastanPtr", " fastAQueue", "fastanQueue", "fastaPtr", " fastAFile", "fastaceBuff", "fastaceChannel", "fastaContainer", "fastaaBuffer", "FastaPtr", "fastanBuffer", "FastasBuff", "fastABuffer", "fastasStream", "FastasBuffer", "fastAPtr", " fastasFile", " fastasContainer", "fastAChannel", " fastAChannel", "fastanStream", "fastasBuff", "fastaceBuffer", " fastasBuffer", "fastAContainer", "fastasQueue", "FastasStream", "fastaBuff", " fastaContainer", "fastanChannel", "fastABuff", "fastanBuff", "FastaChannel", "fastaaStream", "fastanContainer", "fastacePtr", " fastaQueue"], "fastaReadState": ["fastasReadstate", "fastasReaderState", "fastaReaderstate", "fastasReaderMode", "fastaReadstate", "fastaReadingState", "fastaReaderState", "fastaReadMode", "fastasReadType", "fastaFileMode", "fastasReadMode", "fastaFileState", "fastaReadingType", "fastasReaderType", "fastaReadType", "fastaReaderMode", "fastasReadState", "fastaFileType", "fastaFilestate", "fastaReaderType", "fastasReaderstate", "fastaReadingstate", "fastaReadingMode"], "nBytes": ["nFrames", " nParts", "obytes", "pbytes", "numFrames", "nFiles", " nFiles", "oParts", "pBytes", "numBytes", "NBytes", "oBytes", "NParts", " nbytes", "lenFrames", "lenbytes", "oFiles", "NByte", " nFrames", "pParts", "Nbytes", "lenFiles", "pByte", "nByte", "nbytes", " nByte", "NFiles", "nParts", "numbytes", "lenBytes", "numFiles"]}}
{"id1": "19113613", "id2": "8932510", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "write", " cp", "cp", "sync", "zip", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "Copy", "create", "delete", "change", "load", "share", "upload", "get", "ssh", "transfer", "Cop", "put", "update", "p", "opy", "cop"], "in": ["ins", "url", "image", "In", "n", "connection", "init", "thin", "data", "this", "project", "inc", "old", "part", "f", "input", "din", "IN", "inn", "lin", "index", "plugin", "cin", "i", "kin", "win", "reader", "sin", "config", "inside", "client", "work", "a", "login", "inner", "base", "min", "id", "token", "bin", "c", "ic", "name", "diff", "pin", "get", "ini", "as", "again", "update", "on"], "out": ["at", "page", "ex", "vert", "one", "image", "resource", "call", "parent", "b", "null", "n", "connection", "remote", "init", "io", "off", "outer", "dot", "project", "this", "version", "outside", "inc", "external", "part", "output", "no", "group", "input", "block", "o", "Out", "conn", "with", "client", "self", "work", "base", "outs", "point", "user", "object", "app", "cache", "exec", "bin", "c", "v", "err", "obj", "option", "name", "net", "goal", "OUT", "up", "root", "other", "path", "x", "again", "line", "p", "ext"], "source": ["prefix", "proxy", "pe", "component", "attribute", "direction", "subject", "secret", "url", "uri", "unit", "resource", "parent", "dest", "scope", "view", "ce", "username", "project", "status", "Source", "site", "route", "family", "missing", "type", "sin", "iter", "class", "src", "size", "base", "feature", "alt", "internal", "position", "id", "ource", "name", "origin", "service", "reference", "SOURCE", "format", "secure", "force", "use", "from"], "target": ["prefix", "component", "direction", "url", "resource", "parent", "master", "dest", "null", "project", "output", "alias", "site", "route", "about", "template", "home", "cat", "top", "config", "src", "Target", "alt", "base", "point", "wrong", "address", "token", "arget", "detail", "name", "origin", "service", "reference", "root", "pattern", "host", "next", "goal", "path", "current", "value", "tail", "format", "force"], "files": ["ls", "keys", "ions", "ins", "links", "users", "obs", "jobs", "data", "assets", "f", "sections", "apps", "groups", "plugins", "features", "classes", "lines", "fs", "s", "children", "flows", "objects", "results", "docs", "tools", "images", "filename", "ports", "pages", "resources", "names", "models", "cells", "iles", "blocks", "Files", "items"], "file": ["page", "FILE", "url", "e", "resource", "ile", "uri", "parent", "le", "b", "unit", "letter", "item", "data", "single", "child", "part", "folder", "entry", "f", "it", "feed", "live", "el", "fe", "future", "dir", "directory", "filename", "l", "base", "object", "id", "local", "string", "load", "name", "entity", "binary", "per", "File", "layer", "path", "function", "current", " File", "line", "fp", "lib"], "inCh": ["InChan", "INChannel", "inCH", "InChannel", "INCH", "inch", "inChan", "outCH", " inch", "InCH", " inChan", " inCH", "outch", "Inch", "InCh", "outChan", "outChannel", " inChannel", "INChan", "inChannel", "INCh"], "outCh": ["Outch", "OutChan", "OutCH", "inCH", " outChannel", "inch", " outch", "inChan", "outCH", "OutChannel", "outputCh", "outch", "outputChan", "outChan", " outCH", "outChannel", "outputCH", "inChannel", "OutCh", "outputch"]}}
{"id1": "15362793", "id2": "23370621", "code1": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 0, "substitutes": {"ReadURL": ["readString", "ReadUrl", "readUrl", " ReadString", " ReadUrl", "ReadString", "readHTTP", "GetURL", "GetString", "GetUrl", "GetHTTP", "ReadHTTP", "readURL", " ReadHTTP"], "url": ["ur", "page", "uri", "ssl", "ll", "resource", "server", "image", "fr", "connection", "loc", "io", "this", "link", "impl", "str", "URL", "conn", "jar", "source", "api", "config", "web", "l", "base", "user", "address", "string", "file", "err", "service", "sl", "host", "bug", "path", "Url", "or", "secure", "twitter", "http"], "textonly": ["textempty", " textempty", "TextOnly", "Textempty", "Textonly", " textOnly", "extOnly", "extonly", "textOnly", "extempty"], "uconn": ["oucon", " uConn", "ucon", "uopen", "Uconnection", "luconnect", "cuconnection", "Ucon", "Uconn", "ouconnection", "cuopen", "ouconn", "uconnection", "uConn", " ucon", "Uconnect", "cuconn", " uconnection", "luconnection", "Uopen", "UConn", "cuconnect", "uconnect", "luopen", "ouConn", "luconn"], "ucont": ["uccront", "acont", "uscond", "aucont", "ucCont", "cuent", "ucant", "bcront", "unicontent", "uclet", "ucent", "uclontent", "aucent", "bcant", "uuond", "unicront", "aucCont", "uuont", "aucond", "ucontent", "unicant", "uccont", "uclouch", "cuotton", "unicont", "bcnt", "uscCont", "uclont", "bcont", "acent", "cuont", "acnt", "aucnt", "uscont", "ucront", "uccet", "ucouch", "uccouch", "uccontent", "uccnt", "ucet", "uccant", "uuotton", "unicet", "unicouch", "ucnt", "aucotton", "ucotton", "unicnt", "ucond", "uuCont", "cunt", "uscotton", "acotton"]}}
{"id1": "16466743", "id2": "19109981", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getmd5": [" getMD5", "getmn5", " getmd512", " getmd6", "getmd512", " getMD12", "getmetadata12", "getMD5", " getmd12", "getmetadata5", "getMD6", "getMD512", " getMD512", "getMD12", "getmd12", " getMD6", "getmd6", "getmn6", "getmetadata512", "getmn12", "getmn512", "getmetadata6"], "password": ["secret", "crypt", "text", "padding", "prefix", "attribute", "auth", "array", "pad", "message", " passwords", "data", "username", "sword", "phrase", "f", "hash", "input", "encrypted", "key", "wd", "pass", "config", "login", "number", "address", "token", "string", "account", "email", "name", "pattern", "words", "path", "word", "buffer", "Password", "p", " Password", "PASS"], "pwHash": [" pwaHash", "PWMac", "qwSum", "qwDig", "qxHash", " pwSum", " pwDig", "PwBlock", "qxSum", "pwBlock", "pwaDig", "pweHash", "pwhMac", "PWHash", "pwtMac", "pWBlock", "pwaSum", "pwdHash", " pwaSum", "pwtHash", "pwdDig", "pwhSum", " pwahash", "pweDig", "pWSum", "pxDig", "pwdSum", "pwehash", "qxMac", "pWMac", "pwMac", "pwdMac", "pxHash", "pwSum", "qxDig", " pwhash", "pxMac", "pwDig", "pwdhash", "pwtBlock", "qwMac", "pweSum", "pWHash", "PWSum", "PWBlock", "pwtSum", "pwhBlock", "PwMac", "pwhash", " pwaDig", "pwaHash", "pwahash", "qwHash", "pwaMac", "PwHash", "pwhHash", "PwSum", "pxSum"], "md": ["m", "rm", " MD", "Cmd", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "hash", "mc", "mag", "d", "od", "mage", "ms", "mb", "hm", "nm", "meta", "amd", "mg", "dm", "bd", "me", "cm", "metadata", "bm", "pd", "MD", "mi", "db", "ad", "mac", "mand", "mm", "sm", "ma", "dc", "am", "ld", "pm", "kg", "M", "mt", "cd", "mu", "mod"], "b": ["buf", "p", "u", "e", "emb", "fb", "lb", "sb", "f", "bis", "d", "rb", "batch", "bytes", "mb", "cb", "bf", "B", "bd", "a", "buff", "l", "reb", "db", "base", "r", "ib", "ba", "orb", "br", "bin", "gb", "be", "binary", "ob", "wb", "bi", "buffer", "ab", "nb", "eb", "bs", "bb"], "i": ["u", "z", "uri", "e", "j", "n", "io", "info", "data", "si", "f", "it", "ni", "block", "o", "index", "d", "ci", "h", "oi", "s", "ji", "abi", "multi", "li", "a", "l", "di", "ip", "pi", "xi", "base", "vi", "slice", "r", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "zi", "phi", "chi", "ii", "ui", "x", "bi", "mu", "qi", "p"]}}
{"id1": "13644374", "id2": "16825994", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesfromURL", "getBytesViaUrl", "getBytesViaURL", "getbytesFromUrl", "getBytesFormUrl", "getBytesViaString", "getBytesFromURL", "getBytesFormString", "getBytesfromString", "getBytesViaRoute", "getbytesFromString", "getBytesFromString", "getBytesfromUrl", "getbytesFormString", "getbytesFormRoute", "getbytesFormUrl", "getBytesFormRoute", "getBytesFormURL", "getbytesFromRoute", "getBytesFromRoute", "getbytesFormURL", "getBytesfromRoute", "getbytesFromURL"], "url": ["ur", "page", "uri", "resource", "server", "connection", "loc", "method", "data", "result", "route", "str", "URL", "ref", "href", "key", "download", "xml", "i", "source", "api", "l", "base", "address", "email", "string", "name", "service", "sl", "host", "path", "Url", "location", "json", "buffer", "http", "request"], "get": ["gets", "resource", "e", "call", "build", "body", "like", "method", "GET", "Get", "set", "read", "handle", "i", "pull", "create", "api", "parse", "client", "cli", "send", "load", "exec", "start", "find", "service", "json", "query", "put", "update", "execute", "http", "use", "request", "open"], "response": ["wave", "resp", "page", "respond", "resource", "message", "server", "e", "report", "body", "Response", "connection", "method", "data", "output", "application", "f", "status", "result", "document", "reply", "error", "out", "api", "tree", "object", "success", "full", "json", "content", "http", "feed", "request", "onse", "received"], "entity": ["resp", "page", "pe", "ale", "e", "resource", "image", "message", "server", "null", "body", "connection", "Entity", "event", "info", "data", "this", "output", "model", "entry", "document", "result", "translation", "ent", "el", "xml", "instance", "element", "metadata", "api", "action", "node", "object", "file", "security", "environment", "json", "content", "collection", "http", "person"]}}
{"id1": "10391753", "id2": "12744653", "code1": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["decrypt", " enccrypt", "encress", "Encrypt", " encipher", "decress", "Encress", "enccrypt", "encipher", "Enccrypt", "Encipher", "decipher", " encress", "deccrypt"], "text": ["prefix", "crypt", "txt", "message", "image", "plain", "length", "connection", "letter", "data", "output", "input", "str", "hex", "encrypted", "password", "bytes", "key", "test", "out", "code", "source", "class", "config", "TEXT", "object", "token", "string", "name", "pattern", "path", "word", "content", "buffer", "format", "ext", "contract", "Text"], "toEncrypt": ["toRecrypt", " toEncert", "toCCrypt", "toCryption", "toDecrypt", "toRecryption", " toCrypt", "toExeccrypt", "toAcipher", "toEnccrypt", "toCrypt", "toExecript", "toRecript", "toEncert", "toExecryption", " toEncryption", "toDecipher", "toExecrypt", "toExecCrypt", "toEncract", "toDecract", " toDecract", "toDecryption", "toEncrypted", "toDiscipher", " toExeccrypt", " toEncract", "toDecert", "toEncCrypt", "toAcract", "toCrypted", " toEncript", "toExecrypted", "toDecCrypt", " toEnccrypt", " toDecipher", " toEncCrypt", "toAcrypt", " toDecrypt", " toCryption", "toEncryption", "toEncipher", " toExecryption", "toDiscrypt", " toExecript", "toReccrypt", " toEncrypted", "toDiscract", "toCcrypt", "toEncript", " toCrypted", "toAcert", "toDecrypted", "toCript", " toDecert", " toCCrypt", "toDiscert", " toEncipher", " toExecrypt"], "hexString": ["stringString", " hexstring", "hexBuffer", "hashstring", "textUnit", "textString", "hashList", "textstring", "hexUnit", " hexText", "hexstring", "stringArray", "indexArray", "shortArray", "shortString", "hexArray", "hexList", "hashString", " hexArray", "stringUnit", "textArray", "shortBuffer", "hashBuffer", "hexText", " hexUnit", "stringstring", "indexstring", "indexString", "hashArray", " hexBuffer", " hexList", "indexText", "hashText", "shortList"], "dig": ["rand", "est", "gen", " dec", "log", "prep", "ssl", "rob", "fin", "build", "cod", " mod", " comb", "dec", "um", "dd", "ig", "du", "wrap", "her", "draw", "loop", "hash", "Dig", " Dig", "exp", "d", "hex", "comb", "and", "lab", "test", "ng", "add", "driver", "push", "grab", "im", "db", "sign", "de", "div", "neg", "dim", "dc", "find", "del", "mix", "destruct", "pm", "diff", "grad", "get", "cd", "or", "pro", "mod", "define", "fe", "enc", "cr", "rep", "alg"], "pw": ["pws", "pW", "cwh", "pwd", "pye", " pye", "prye", "pow", "prw", "ppye", "pwh", " pow", "Pwd", "cws", "PW", "ppwa", "lpwd", " pW", "Pwh", " paw", " pwa", "Pw", "Pws", "lpow", "ppaw", "cW", "lpw", "Pow", " pwd", "praw", "pwa", "lpW", "paw", "ppw", " pwh", "cw", "prwa", " pws"], "i": ["k", "m", "u", "uri", "z", "e", "j", "length", "b", "n", "io", "data", "si", "in", "f", "it", "o", "d", "index", "ci", "h", "oi", "key", "end", "y", "li", "di", "l", "a", "ip", "pi", "xi", "mi", "ei", "slice", "r", "hi", "id", "ti", "v", "gi", "c", "start", "t", "w", "I", "ai", "ix", "ri", "ini", "ii", "ui", "x", "qi", "bi", "phi", "mu", "chi", "lc", "p"], "digest": ["digestamp", "delestamp", "labest", "DigEST", " digEST", "hashester", " diggest", "Diggest", "Digester", "digEST", "Digest", "hashested", " digested", " digestamp", "digesting", "delEST", "Digestamp", " digesting", "delester", "signest", "codests", "delest", "labests", " digests", " digester", "codest", "signested", "Digested", "debuggest", "digester", "signEST", "signester", "debugested", "digests", "debugest", "labesting", "debugester", "digested", "labester", "hashest", "hashEST", "diggest", "codester", "codesting"], "digestLength": ["digusterStr", "digesterStr", "digestationlength", "digesterLoop", "digusterLine", "diffesterType", "DigestLen", "diffestlength", "DigesterLen", "diffesterLoop", "digstLoop", "digestationType", "digestLoop", "DigestLine", "DigesterStr", "digESTLength", "digestStr", "digESTStr", "digestType", "digesterLen", "DigestStr", "DigesterLength", "digestlength", "diffesterlength", "DigesterLine", "digstType", "DigestLength", "digestLine", "digusterLen", "digestationLength", "diffestLength", "digusterLength", "digesterlength", "digstLength", "digESTLen", "diffesterLength", "digstlength", "diffestLoop", "digestationLoop", "digesterType", "digesterLength", "digesterLine", "diffestType", "digESTLine", "digestLen"]}}
{"id1": "15757836", "id2": "4272289", "code1": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "code2": "    public static int[] sortstring(int[] a1) {\n        int temp;\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        return a1;\n    }\n", "label": 1, "substitutes": {"sort": ["after", "ort", "gen", "array", "cmp", "num", "Sort", "random", "part", "pos", "index", "split", "iter", "parse", "min", "round", "position", "ind", "slice", "tr", "desc", "list", "order", "first", "rank", "comp", "ordered"], "n": ["k", "m", "fn", "u", "z", "e", "cn", "j", "count", "b", "g", "num", "ns", "f", " N", "sn", "o", "nt", "d", "y", "network", "size", "nat", "a", "l", "ne", "len", "number", "r", "c", "net", "w", "x", "nb", "N", "p", "nn"], "mas": ["mes", "ks", "ls", "mad", "forms", "m", "mins", "asa", "arr", "nos", "mask", "master", "astics", "mr", "os", "las", "ns", "parts", "ias", "asia", "lists", "data", "pos", "ums", "faces", "features", "fa", "amps", "pa", "ta", "lab", "ms", "cas", "s", "Las", "images", "ia", "vals", " ma", "a", "ras", "mast", "mat", "ima", "mos", "sa", "mm", "ma", "bas", "ams", "amas", "xs", "la", "alpha", "params", "phi", "ama", "ans", "nas", "as", "mu", "bs", "phas"], "rand": [" random", "pick", "gen", "res", "z", "R", "nd", "rx", "g", "dr", "rc", "init", "rh", "data", "mid", "random", "rar", "reg", "range", "rot", "go", "cur", "ng", "rest", "win", "max", "bird", "seed", "rr", "round", "r", "ind", "err", "dist", "start", "rd", "grad", "clean", "x", "ra", "wind", "Rand", "p", "right"], "i": ["k", "m", "p", "u", "uri", "z", "e", "module", "j", "anti", "b", "fi", "init", "ori", "io", "info", "adi", "si", "ie", "f", "ni", "it", "o", "index", "d", "ci", "iu", "oi", "ji", "mini", "api", "y", "ami", "li", "di", "cli", "mi", "ip", "pi", "xi", "hi", "eni", "vi", "a", "id", "uli", "ti", "gi", "v", "ix", "I", "ai", "phi", "ri", "chi", "ii", "ui", "x", "bi", "ini", "mu", "qi"], "tmp": ["m", "pad", "z", "txt", "j", "xt", "b", "mp", "offset", "cmp", "st", "part", "pos", "f", "stuff", "tt", "nt", "beta", "ref", "ta", "test", "vt", "temp", "mini", "mist", "api", "max", "a", "l", "v", "mm", "c", "amp", "alpha", "start", "sup", "sp", "phi", "diff", "x", "front", "emp", "p"], "t": ["at", "k", "m", "rt", "art", "u", "ct", "z", "e", "j", "wt", "b", " m", "st", "tc", "ot", "bt", "part", "pt", "f", "tt", "o", "nt", "d", "ta", "template", "unt", "test", "type", "out", "tf", "h", "T", "temp", "te", "y", " p", "l", "a", "et", "r", "v", "qt", "c", " b", "w", "ant", "tw", "x", "p"]}}
{"id1": "6009527", "id2": "5299276", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAttment", "doFinishloadAttment", "doFinishLoadInstachment", "doFinishloadAttachment", "doFinishloadAttments", "doFinishLoadAttachachment", "doFinishLoadAttachortion", "doFinishloadAttachments", "doFinishLoadAssments", "doFinishLoadInstment", "doFinishLoadAssachment", "doFinishLoadAssortion", "doFinishLoadAttments", "doFinishLoadAttachments", "doFinishLoadInstments", "doFinishloadAttortion", "doFinishLoadAssment", "doFinishloadAttachachment", "doFinishloadAttachortion", "doFinishLoadInstortion", "doFinishLoadAttortion"], "attachmentId": ["attachmentInfo", "attentionInfo", "attociationId", "ttociationid", "ttociationID", "ttachmentId", "AttachmentType", "attimageId", "adachmentPath", "ttachmentID", "Attachmentid", "adociationID", "attentionid", "attachmentPath", "AttachmentId", "attachmentType", "attlementID", "attlementid", "adachmentID", "attociationid", "attlementType", "attentionID", "adachmentId", "attplementationid", "adociationId", "ttociationId", "attimagePath", "adociationPath", "attachmentID", "adociationInfo", "ttachmentid", "attentionType", "attplementationID", "AttachmentID", "attlementId", "attociationPath", "attimageInfo", "attociationInfo", "adachmentInfo", "attentionPath", "attachmentid", "attentionId", "attplementationId", "attimageID", "attociationID"], "attachment": ["assachment", "instment", "attociation", "instention", "attention", " adaptention", "appention", "instruction", "appment", " attociation", "attachruction", "assment", "instachment", "attment", "appruction", "appachment", "adached", "adment", " attment", "adachment", "attachached", "attachention", "assention", "attruction", " adaptachment", " adaptociation", " adaptment", "assached", "attached", "attachachment", "adention", " attention", "association"], "attachmentUri": ["attachedARI", "attmentIri", "attachmentSuURI", "attachmentUris", "attachedUuri", "attachmentSuris", "attmentIris", "attachmentSuuri", "attachmentERI", "attachmentEuri", "attachmentARI", "attachedURI", "attachmentSuti", "attmentIuri", "attachmentSuRI", "attachmentEri", "attachmentURI", "attachmentIri", "attmentUuri", "attachedUri", "attachedAti", "attachmentUuri", "attachmentCuURI", "attmentUris", "attachmentSuri", "attachmentIURI", "attachmentAuri", "attmentIURI", "attmentUri", "attachmentCuuri", "attachmentIuri", "attachedAri", "attachedAuri", "attachmentUti", "attachmentUURI", "attachmentCuri", "attachmentCuris", "attachmentAri", "attachmentAti", "attmentUURI", "attachmentIris", "attachedUti", "attachmentEti"], "contentUri": ["contentUsRI", "contentUsdi", "resourceUi", " contentURI", "contentFileRI", " contentUdi", "resourceIris", "contentURuri", "contentUuri", " contentUris", "contentUsuri", "contentUsri", "contentUsris", "contentUdi", "resourceUri", "contentSuris", "contentCdi", "contentIris", " contentSuris", " contentSuRI", "contentFileri", "contentCris", "contentCuri", " contentSudi", " contentSuri", "contentSuri", "contentIuri", "contentFileuri", "contentURri", "resourceIi", "contentURI", "contentURris", "resourceIuri", "contentCi", "contentCri", "resourceURI", "contentUi", "contentIi", "contentUris", "contentIri", "resourceIri", "contentFileris", "contentSudi", "contentURi", "contentIRI", "contentCRI", "resourceIRI", "resourceUuri", "resourceUris", "contentSuRI"], "file": ["to", "book", "pe", "log", "url", "unit", "resource", "image", "uri", "le", "copy", "FILE", "b", "view", "able", "letter", "connection", "io", "data", "single", "this", "child", "socket", "folder", "output", "f", "via", "zip", "model", "input", "source", "create", "reader", "filename", "use", "work", "stream", "files", "base", "ger", "object", "local", "cache", "load", "handler", "upload", "name", "entity", "up", "binary", "File", "get", "path", "auto", "picture", "content", "buffer", "line", "fp"], "in": ["m", "ins", "url", "e", "image", "In", "copy", "b", "connection", "init", "io", "data", "this", "sync", "inc", "socket", "f", "gin", "input", "o", "din", "IN", "inn", "s", "conn", "i", "pull", "win", "source", "reader", "a", "nin", "cli", "login", "inner", "r", "id", "ac", "bin", "c", "err", "con", "up", "binary", "pin", "ini", "as", "or", "again"], "out": ["to", "page", "ex", "log", "writer", "resource", "one", "image", "copy", "null", "b", "view", "In", "connection", "lock", "init", "io", "outer", "data", "this", "sync", "inc", "socket", "output", "o", "IN", "Out", "s", "conn", "i", "source", "client", "cli", "nin", "inner", "base", "outs", "cache", "exec", "bin", "err", "by", "up", "net", "OUT", "again", "line", "on", "ext"], "intent": ["Activity", "ink", "activity", "text", "request", "term", "act", "init", "event", "animate", "this", "focus", "anc", "entry", "document", "inst", "it", "effect", "acc", "ent", "android", " Intent", "ani", "xml", "element", "action", "eng", "agent", "impact", "advert", "activate", "contact", "feature", "object", "language", "ents", "activation", "spirit", "entity", "ctx", "context", "ant", "response", "content", "concept", "vent", "anim", "enc", "intention", "category", "feat"]}}
{"id1": "5836744", "id2": "8665321", "code1": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"read": ["include", "write", "resource", "call", "copy", "data", "reading", "connect", "check", "input", "READ", "index", "Read", "error", "run", "download", "process", "source", "create", "add", "reader", "parse", "stream", "send", "load", "exec", "start", "find", "wait", "next", "get", "transfer", "update", "execute", "close", "open", "readable"], "name": ["ame", "NAME", "prefix", "default", "uri", "resource", "image", "e", "parent", "null", "style", "n", "connection", "body", "info", "data", "part", "alias", "no", "f", "str", "named", "index", "end", "key", "type", "code", "time", "source", "class", "action", "Name", "size", "filename", "client", "stream", "base", "object", "id", "address", "names", "string", "file", "start", "root", "host", "path", "word", "content", "x", "value", "from"], "status": ["uses", "exit", "ssl", "server", "complete", "speed", "Status", "stats", "method", "msg", "si", "sync", "sb", "result", "site", "fail", "index", "stat", "score", "error", "gc", "type", "code", "source", "api", "header", "width", "cli", "use", "size", "login", "base", "id", "success", "service", "continue", "wait", "full", "json", "response", "state", "content", "value", "update", "active", "STAT", "stage", "rate"], "url": ["ls", "uri", "ssl", "image", "server", "b", "rel", "data", "blog", "channel", "f", "www", "URL", "bel", "source", "stream", "l", "web", "base", "user", "object", "id", "address", "string", "gl", "file", "obj", "ob", "sl", "host", "plug", "path", "Url", "buffer", "hub", "http", "feed", "open", "ball", "browser"], "in": ["fd", "m", "ins", "ssl", "fr", "resource", "image", "In", "connection", "init", "version", "session", "socket", "inc", "part", "f", "gin", "input", "din", "IN", "index", "inn", "inas", "out", "conn", "el", "pass", "i", "source", "config", "reader", "nin", "stream", "login", "inner", "r", "id", "token", "bin", "binary", "get", "ini", "as", "cf", "buffer", "again", "isin"]}}
{"id1": "2642914", "id2": "23452437", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGarzip", "addFileToTarGarx", "addFileToTarggz", "addFileToTarGsgz", "addFileToTarGszi", "addFileToZipGszip", "addFileToZipGarx", "addFileToTargx", "addFileToTarGarz", "addFileToTarGgz", "addFileToZipGgz", "addFileToZipGz", "addFileToTarGx", "addFileToTargzip", "addFileToTarGux", "addFileToZipGsz", "addFileToTarGzi", "addFileToZipGarz", "addFileToZipGarzi", "addFileToZipGsgz", "addFileToTarGuzi", "addFileToTarGuz", "addFileToTarGargz", "addFileToZipGx", "addFileToTarGzip", "addFileToTarGszip", "addFileToTarGuzip", "addFileToTargzi", "addFileToTargz", "addFileToZipGzip", "addFileToZipGszi", "addFileToZipGarzip", "addFileToTarGarzi", "addFileToZipGzi", "addFileToTarGsz"], "taro": ["too", "thamar", "Toro", "ptabo", "thaco", "tabo", " tro", "stamar", " taco", "tamar", "storo", "ptaco", " tero", "Tro", "fara", "Tamar", "faro", "stoo", "targo", "fargo", "tro", "ptaron", "ataro", "taco", "staco", "taron", "Tero", "tara", "Targo", "ptaro", "lro", " too", "Taro", "atargo", "Toran", " taron", "Tabo", "Too", " tara", "toro", "thoro", "laro", "stro", "stero", "tero", "Taco", "ptargo", " tabo", "Tara", "staro", "toran", "atro", "loran", "largo", "atoran", "faco", " targo", "Taron", "tharo"], "path": ["fn", "text", "log", "url", "uri", "resource", "image", "parent", "loc", "data", "ath", "folder", "PATH", "route", "str", "ref", "key", "type", "source", "dir", "directory", "filename", "Path", "object", "id", "cache", "string", "file", "c", "name", "root", "pattern", "location", "pointer", "from", "p"], "base": ["prefix", "p", "url", "uri", "default", "resource", "server", "core", "parent", "b", "relative", "back", "store", "part", "area", "site", "index", "key", "type", "home", "bf", "Base", "api", "dir", "id", "cache", "address", "string", "ase", "file", "bas", "start", "name", "absolute", "extra", "root", "pre", "buffer", "http", "from"], "f": ["fd", "m", "fn", "fo", "fr", "url", "lf", "e", "j", "sf", "g", "b", "n", "form", "flat", "fb", "this", "fa", "d", "ref", "feed", "h", "tf", "fs", "s", "framework", "bf", "rf", "inf", "i", "raf", "l", "self", "of", "fx", "r", "found", "v", "file", "c", "fold", "fc", "af", "t", "w", "fac", "fen", "aff", "cf", "F", "fe", "fp", "p", "df"], "entryName": ["elementPath", "elementTime", "filePath", " entrySize", "resourcename", "elementType", " entryPath", "EntryTime", "EntryName", "resourceName", "entryTime", "fileType", "elementName", "fileName", "archiveName", " entryType", "archivePath", "entryname", "entrySize", "EntryPath", "archiveSize", " entryTime", "entryPath", "EntryType", " entryname", "resourceSize", "resourcePath", "archivename", "fileTime", "entryType"], "goIn": ["coin", "gaIns", "goOut", "goIns", "gaIn", "coOut", "gain", "loIns", "loIN", "poIN", "coIn", "GoIn", "goIN", "gaIN", "GOIn", "goin", "poin", "GOIN", "GOin", "loin", "GoIN", "GoIns", "poIns", "poIn", "loIn", "GOOut", "poOut", "GOIns", "coIns", "Goin"], "tarEntry": ["TarElement", "Tarentry", " tarentry", " tarFile", "tarEnt", " tarElement", "rarFile", "rarEnt", "zipEnt", " tarInfo", " TarElement", "zipEntry", "rarInfo", "zipInfo", "zipFile", " tarEnt", "tarentry", "tarFile", "TarEntry", "tarElement", " TarEntry", "rarEntry", "tarInfo", " Tarentry"], "children": ["values", "pes", "ins", "Children", "kids", "rows", "scenes", "parent", "loc", "ul", "each", "data", "jobs", "bars", "output", "ools", "all", "ales", "plugins", "parents", "balls", "h", "far", "many", "packages", "sub", "web", "ports", "files", "pages", "well", "which", "name", "other", "when", "iblings", "blocks", "words", "ren", "pool", "current", "content", "members", "opens", "roots", "feed", "father", "open"], "child": ["page", "kid", "server", "parent", "count", "build", "connection", "leaf", "data", "shell", "cloud", "channel", "in", "entry", "ch", "draft", "and", "key", "job", "row", "code", "i", "pull", "cel", "comment", "client", "l", "slave", "id", "c", "file", "name", "root", "per", "layer", "pool", "Child", "or", "feed", "lib", "hel"]}}
{"id1": "13595251", "id2": "18693224", "code1": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"descargarArchivo": ["descargaArtivo", "descargarMassive", "descargarArtive", "descargarMassico", "descargarMassiv", "descargaArchico", "descargarMassivo", "descargaArchivo", "descargarArtico", "descargarArchive", "descargaArtico", "descargaArchive", "descargaArchiv", "descargarArchiv", "descargaArtive", "descargarArchico", "descargarArtiv", "descargaArtiv", "descargarArtivo"], "fis": ["tis", "FIs", "tiss", "infIS", "Fos", "Fris", "Fins", "fris", "afIS", "tins", "infos", "Fiss", "FIS", "tris", "fIs", "affris", "fiss", "affis", "infiss", "fins", "afiss", "fIS", "infis", "afins", "afIs", "afris", "afis", "affIs", "afos", "affiss", "Fis"], "fos": ["feoes", "sfoser", "afoes", "ifores", "Fos", "Fops", " fores", "ifoS", "foses", "sfos", "sfoes", "afoS", " foser", "sfoss", "fores", "foser", " fops", " foses", "feops", "foS", " foss", "Foses", "fops", "feoses", "ifoes", " foS", "ifoser", "foss", "ifos", "Foes", "foes", "afos", "ifoss", " foes", "afores", "feos"], "inChannel": ["outchannel", "inputChan", "inputChannel", "InStream", "inschannel", " inStream", "InChan", "INChannel", "insChannel", " inchannel", "InChannel", "insChan", "inStream", "outVideo", "INStream", "inChan", " inVideo", "inchannel", "INVideo", "inputchannel", "inCh", "inSocket", "insSocket", " inChan", "InVideo", " inCh", "inputVideo", "InCh", "outChan", "InSocket", "Inchannel", "inVideo", "outSocket", "INCh"], "outChannel": ["outchannel", "outputStream", "OutChan", "inStream", " outChan", "OutChannel", " outFile", "inchannel", "Outchannel", " outchannel", "outputFile", "outStream", " outStream", "outputChan", "outChan", "outFile", "OutStream", "OutFile", "outputChannel"]}}
{"id1": "19849797", "id2": "414258", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "copyfile", " copyfile", "transferfile", " copySource", "copyFiles", "clonefile", "copySource", "transferSource", "cloneFiles", "cloneFile", "cloneSource", "transferFiles", "transferFile"], "sourceFile": ["SourceFile", " sourceDir", "ourceFile", "SourceUrl", "ourceDirectory", "sourceDirectory", "sourceFolder", "srcDir", "Sourcefile", "srcfile", " sourceFolder", "ourceUrl", "sourcefile", "ourcefile", "destUrl", "destDirectory", "SourceFolder", "sourceUrl", "srcFolder", " sourcefile", "destfile", "SourceDirectory", "srcFile", "SourceDir", "sourceDir"], "destFile": [" destPoint", "DestPoint", "foreignFiles", "foreignFile", "resultLine", "sourcePoint", "destFiles", "DestDirectory", "targetPath", "targetDir", "destPoint", "srcDirectory", "srcDir", "srcFiles", "foreignPath", "srcLine", "destPath", "resultDir", "srcfile", "targetLine", "resultFile", "targetFiles", "resultfile", "DestFile", "destDir", "Destfile", " destDirectory", " destfile", "DestPath", "DestDir", "targetfile", "targetFile", " destFiles", "destDirectory", "sourceFiles", "foreignfile", "destfile", "srcFile", " destDir", "DestFiles", "destLine", "sourceDir"], "source": ["proxy", "component", "url", "uri", "unit", "resource", "image", "core", "server", "parent", "dest", "null", "scope", "view", "connection", "remote", "ce", "this", "si", "session", "ie", "channel", "output", "status", "Source", "result", "input", "site", "route", "storage", "index", "sin", "iter", "api", "src", "reader", "size", "client", "config", "stream", "target", "slave", "seed", "inner", "slice", "table", "object", "id", "cache", "ource", "file", "start", "service", "reference", "root", "SOURCE", "context", "get", "wrapper", "current", "secure", "scene", "manager", "use", "from"], "destination": ["domation", "distination", "generruction", "Destribution", "constination", "domination", "participinate", "identinated", "distion", "destinate", "Destation", "generinator", "constribution", "distruction", "destation", "destruction", "distinator", "Destinator", "distinated", "Destinate", "participinated", "generinated", "Destion", " destinated", "destion", "participinator", " destribution", "destribution", "identination", " destinator", "destinated", "Destination", " destation", "construction", "identinate", " destruction", "destinator", "Destinated", "Destruction", "dominator", "dominated", "generination", "constinator", " destion", "participination", "identinator"]}}
{"id1": "14878593", "id2": "17557289", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": [" hyperLinkUpdated", "hyperlinkStyle", " hyperLinkUpdate", "hyperlinkUpdated", "hyperflowEvent", "hyperflowStyle", "hyperflowUpdate", " hyperLinkEvent", "hyperLinkStyle", "hyperlinkEvent", " hyperlinkUpdated", " hyperlinkStyle", "hyperimageUpdate", "hyperLinkUpdate", " hyperLinkStyle", "hyperimageEvent", "hyperLinkUpdated", "hyperflowUpdated", "hyperimageUpdated", "hyperimageStyle", " hyperlinkEvent", "hyperLinkEvent"], "e": ["m", "enter", "ee", "u", "ev", "esi", "message", "g", "ce", "event", "data", "this", "ie", "ec", "entry", "f", "it", "es", "o", "ae", "type", "el", "element", "a", "er", "E", "de", "change", "v", "handler", "c", "exec", "t", "Event", "eve", "environment", " event", "ea", "x", "ed", "events", "exc", "p"], "url": ["page", "text", "log", "uri", "ssl", "resource", "image", "server", "large", "view", "connection", "event", "io", "data", "link", "channel", "f", "URL", "download", "plugin", "element", "source", "config", "filename", "l", "base", "object", "email", "address", "string", "video", "file", "service", "absolute", "sl", "host", "layer", "path", "Url", "location", "buffer", "secure", "http", "browser"], "stream": ["log", "ssl", "resource", "image", "view", "Stream", "form", "io", "data", "oper", "engine", "port", "raw", "channel", "output", "f", "input", "draft", "read", "out", "temp", "source", "reader", "driver", "thread", "client", "flash", "sw", "src", "transform", "video", "trans", "string", "handler", "file", "upload", "loader", "sl", "per", "path", "response", "pool", "or", "wrapper", "buffer", "http", "feed"], "writer": ["WR", "text", "widget", "unit", "write", "null", "wrote", "letter", "io", "data", "this", "writing", "engine", "written", "writ", "output", "channel", "entry", "document", "storage", "Writer", "draft", "key", "player", "temp", "xml", "rw", "builder", "source", "driver", "reader", "riter", "worker", "inner", "r", "string", "handler", "service", "w", "writers", "words", "word", "buffer", "format", "office", "author"], "editor": ["font", "text", "widget", "button", "server", "parent", "html", "term", "manager", "edited", "io", "fb", "options", "info", "this", "parser", "ner", "journal", "ie", "part", "external", "title", "document", "creator", "area", "archive", "o", "translation", "attr", "settings", "player", "plugin", "builder", "comment", "driver", "config", "reader", "article", "riter", "paper", "api", "edit", "er", "object", "video", "layout", "flower", "ob", "order", "layer", "auto", "ui", "Editor", "cover", "content", "office", "author", "oder", "director", "open", "owner", "browser"], "name": ["ame", "NAME", "prefix", "default", "uri", "one", "image", "large", "null", "style", "n", "connection", "letter", "none", "info", "data", "username", "version", "title", "part", "alias", "anc", "no", "named", "key", "type", "home", "time", "comment", "action", "source", "Name", "size", "filename", "number", "base", "object", "id", "address", "names", "string", "file", "full", "path", "word", "value", "office", "label"], "dialog": ["plog", "fog", "demogg", "dialoc", "flog", "log", "logue", "dialect", "fogg", "llog", "dialOG", "dialogue", "plOG", "lOG", "dialogs", "dialbot", "videoogged", "dialbox", "palog", "palbox", "navoc", "flogue", "collOG", "llOG", "plob", "flOG", "locogue", "dialogged", "collogs", "llogs", "chobox", "llogue", "navog", "collogue", "navect", "videoog", "dialob", "plogue", "demogged", "fogged", "chooc", "collog", "choect", "videoogg", "paloc", "dialogg", "dembot", "locog", "flogs", "choog", "fbot", "locOG", "palect", "videobot", "demog", "locob", "navbox", "lob"]}}
{"id1": "21491791", "id2": "5436973", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "label": 0, "substitutes": {"run": ["spawn", "running", "log", "unit", "call", "apply", "build", "Run", "func", "loop", "all", "job", "test", "code", "process", "create", "work", "worker", "command", "fork", "exec", "start", "app", "runner", "invoke", "execute"], "input": ["text", "flow", "resource", "image", "view", "connection", "form", "io", "data", "parser", "reading", "raw", "in", "entry", "audio", "storage", "index", "read", "out", "conn", "instance", "source", "driver", "config", "client", "stream", "work", "worker", "inner", "user", "Input", "internal", "control", "address", "file", "initial", "loader", "up", "context", "state", "iterator", "active", "feed", "request", "readable"], "output": ["page", "text", "exit", "log", "console", "unit", "write", "resource", "image", "parent", "connection", "letter", "outer", "data", "later", "writing", "written", "application", "document", "generated", "index", "Writer", "job", "end", "out", "temp", "source", "Output", "config", "network", "filename", "web", "target", "user", "queue", "control", "object", "cache", "file", "writers", "path", "response", "environment", "operation", "put", "office"], "reader": ["book", "request", "peer", "resource", "image", "server", "rer", "view", "system", "io", "parser", "ner", "reading", "in", "entry", "audio", "Reader", "read", "row", "rator", "builder", "source", "driver", "client", "riter", "stream", "er", "worker", "slave", "inner", "r", "handler", "loader", "context", "wrapper", "author", "oder", "manager", "ri", "owner"], "writer": ["wr", "write", "wan", "connection", "outer", "data", "writing", "engine", "ner", "written", "writ", "entry", "creator", "her", "editor", "Writer", "ew", "out", "wer", "player", "maker", "ws", "rw", "builder", "nw", "driver", "war", "riter", "work", "er", "worker", "ter", "inner", "r", "wa", "wire", "w", "wb", "writers", "wrapper", "or", "word", "office", "author", "manager", "request"], "pump": ["camp", "ppumping", "pumping", "pamp", "prump", "Pmp", "mprint", "dumps", "pdump", " pmp", "Pam", "ppumper", "cump", "ppumps", "Pdump", "humper", "cumper", "mumper", "pumps", "Pumper", " pdump", "Pump", " pumper", "pam", "pumper", "pmp", "Pumping", "prumper", "pprint", "Pprint", "humps", " pumping", "dmp", "mump", "hump", "dump", "Pamp", "pram", "Pumps", " pumps", "dumper", " pam", "hprint", " pamp", "prdump", "ppump", "mumps", "cumping"], "counter": ["enter", "page", "Counter", "url", "server", "clock", "const", "master", "count", "parent", "offset", "num", "race", "outer", "version", "step", "ner", "hello", "sequence", "cookie", "loop", "entry", "now", "result", "meter", "timer", "second", "index", "ener", "row", "code", "ver", "instance", "progress", "consumer", "comment", "trace", "center", "rew", "builder", "keep", "ter", "er", "worker", "seed", "number", "ger", "walker", "lr", "r", "inner", "starter", "repeat", "loader", "continue", "inter", "order", "layer", "runner", "current", "currency", "pointer", "author", "zero", "collection", "keeper", "ception", "processor"], "buffer": ["buf", "page", "uf", "text", "url", "message", "resource", "server", "length", "data", "port", "Buffer", "channel", "limit", "entry", "document", "batch", "source", "iter", "header", "buff", "base", "queue", "position", "address", "file", "loader", "reference", "binary", "layer", "uffer"], "off": ["own", "art", "oa", "Off", "flow", "offset", "OFF", "info", "pos", "offs", "now", "area", "fail", "o", "set", "ref", "end", "out", "Offset", "open", "addr", "ff", "of", "opt", "inner", "eno", "less", "low", "ord", "start", "left", "down", "unknown", "ui", "auto", "head", "on", "offer"], "len": ["fd", "lon", "gen", "log", "ln", "fl", "url", "lf", "fin", "ll", "length", "count", "n", "body", "loc", "en", "lock", "lan", "limit", "in", "pos", "all", "elt", "lin", "ref", "Len", "end", "val", "el", "size", "width", "li", "l", "lit", "lim", "den", "bin", "name", "ld", "layer", "ler", "lc", "lt", "line", "on", "lib"], "rd": ["fd", "rt", "red", "rand", "rm", "rss", "raid", "fr", " r", "xd", "nd", "rx", "rob", "ru", "dr", "RR", "nr", "rc", "rs", "rh", "dd", "d", "rb", "rn", "val", "rid", "RD", "rw", "rl", "rr", "db", "lr", "r", "ind", "adr", "ud", "ord", "dra", "rod", "ld", " prod", "hr", "ra", "cr", "rf", "ds"]}}
{"id1": "12055086", "id2": "9479502", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyDeleting": [" copyDeletging", " copyDequeting", " copydeletter", " copydeletging", " copyDeleteing", " copydeleting", " copyDeletting", " copyDeleteter", " copyDeleging", " copydeletting", " copyDeleter", " copydeleging", " copyDeletter", " copyDequeing", " copyDeleteging", " copydeleing", " copyDeleing", " copydeleter", " copyDequeter", " copyDeleteting", " copyDequeging"], "source": ["resource", "image", "e", "copy", "master", "view", "connection", "remote", "ie", "f", "Source", "site", "input", "route", "archive", "storage", "ources", "s", "sin", "iter", "i", "src", "reader", "config", "stream", "target", "inner", "base", "cache", "ource", "file", "service", "SOURCE", "down", "path", "use", "from"], "dest": ["exit", "default", "null", "master", "Dest", "destroy", "thin", "flat", "die", "later", "folder", "result", "comb", "done", " destination", "home", "temp", "class", "src", "dir", "tmp", "target", "opt", "slave", "de", "slice", "pipe", "trans", "desc", "bin", "file", "dist", "destruct", "wb", "path", "content", "orig", "img"], "buf": ["cv", "uf", "pad", "txt", "append", "uc", "b", "cp", "length", "loc", "rc", "cmd", "off", "fb", "data", "bh", "bp", "port", "Buffer", "raw", "bc", "pos", "result", "bag", "rb", "batch", "feed", "bytes", "cb", "code", "bf", "bd", "src", "config", "tmp", "buff", "ff", "len", "base", "queue", "br", "ctx", "vec", "buffer", "seq", "feat", "img"], "in": ["ins", "url", "image", "In", "b", "n", "thin", "init", "tin", "io", "data", "inc", "socket", "gin", "f", "input", "din", "IN", "inn", "read", "conn", "sin", "win", "rin", "i", "src", "is", "inside", "nin", "reader", "stream", "login", "inner", "min", "id", "exec", "bin", "con", "c", "file", "up", "pin", "ini", "plus", "again", "p", "isin"], "out": ["at", "ex", "writer", "image", "parent", "b", "n", "io", "outer", "sync", "inc", "socket", "part", "output", "f", "exp", "o", "Out", "conn", "i", "win", "client", "inner", "outs", "exec", "bin", "file", "err", "obj", "app", "up", "w", "OUT", "down", "pool", "ext", "buffer", "again", "lib", "img"], "count": ["Count", "length", "b", "offset", "n", "parent", "num", "lock", "depth", "weight", "child", "allow", "part", "cond", "limit", "f", "all", "zip", "index", "sum", "coll", "read", "ch", "feed", "val", "type", "key", "code", "handle", "max", "size", "len", "number", "base", "ind", "id", "cache", "c", "start", "name", "pool", "path", "current", "buffer", "close", "use"]}}
{"id1": "6188784", "id2": "4750967", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "to", " transfer", " cp", "cmp", "cp", "lock", "sync", " copying", "zip", "map", "split", "clone", "clip", "download", "move", "Copy", "create", " Copy", "change", "file", "transfer", "Cop", "put", "p", "cop"], "source": ["ins", "unit", "resource", "parent", "connection", "remote", "sync", "ie", "Source", "site", "input", "route", "ources", "i", "iter", "sin", "src", "reader", "stream", "target", "inner", "base", "slice", "id", "cache", "ource", "file", "start", "name", "origin", "up", "SOURCE", "down", "path", "use", "from"], "dest": ["exit", "style", "Dest", "destroy", "flat", "thin", "die", "later", "folder", "result", "d", "done", "comb", "test", " destination", "home", "temp", "src", "dir", "tmp", "target", "delete", "coord", "de", "which", "desc", "bin", "dist", "sup", "dc", "down", "wb", "cont", "orig", "img"], "in": ["into", "m", "include", "ins", "url", "resource", "image", "In", "parent", "n", "connection", "thin", "init", "inc", "socket", "ie", "gin", "f", "it", "input", "din", "IN", "inn", "s", "conn", "cin", "plugin", "i", "win", "sin", "reader", "src", "client", "inside", "nin", "issue", "pull", "login", "work", "inner", "base", "min", "r", "id", "ac", "pc", "bin", "err", "c", "con", "file", "name", "up", "pin", "ini", "as", "plus", "again", "isin"], "out": ["at", "prefix", "ex", "writer", "vert", "write", "one", "plain", "call", "parent", "n", "connection", "io", "outer", "off", "this", "sync", "outside", "socket", "not", "channel", "output", "no", "part", "exp", "o", "password", "Out", "timeout", "conn", "our", "cat", "i", "client", "inner", "outs", "id", "exec", "bin", "file", "err", "obj", "name", "option", "other", "extra", "up", "net", "ou", "OUT", "w", "pool", "down", "buffer", "again", "lib", "ext"], "size": ["ize", "unit", "e", "length", "count", "izes", "offset", "n", "speed", "loc", "en", "empty", "depth", "si", "scale", "sync", "shape", "mode", "SIZE", "sum", "sec", "seek", "small", "bytes", "end", "time", "flush", "add", "max", "width", "ice", "sized", "capacity", "len", "number", "any", "send", "address", "Size", "start", "name", "order", "clear", "x", "content", "transfer", "iz", "close", "export", "open"], "buf": ["cv", "uf", "uc", "b", "cmp", "fb", "data", "Buffer", "bc", "map", "bag", "coll", "BU", "rb", "bytes", "cb", "cas", "bf", "pkg", "bd", "src", "buff", "ff", "len", "fam", "ba", "br", "bin", "la", "ctx", "vec", "ha", "cf", "ra", "buffer", "box", "seq", "feat"]}}
{"id1": "17161805", "id2": "937612", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encode": ["encoder", "enccod", "enoder", "ensode", "Enoding", "enscode", "encod", "Encod", "Enode", "Encode", "enccode", "enoding", "enode", "ensoder", "encoding", "reode", "recode", "recod", "Enoder", "reoding", "enscod"], "plaintext": ["batstring", "longtext", "bodyform", "forestring", "plainText", " plainText", "bodycontent", "bodyText", " plainform", "battext", "plaincontent", "longcontent", "batTEXT", " plaincontent", "plainstring", "plainform", " plainTEXT", " plainstring", "foretext", "foreTEXT", "longform", "longText", "foreText", "plainTEXT", "bodytext", "batText"], "md": ["mad", "m", "rm", "hd", " MD", "mp", "sha", "cmd", "um", "dd", "gd", "f", "rpm", "mc", "mag", "d", "od", "mb", "me", "wd", "ms", "code", "amd", "meta", "dm", "bd", "metadata", "pd", "MD", "di", "ad", "mac", "ind", "mand", "po", "mm", "sm", "ma", "pm", "grad", "cd", "mod", "dh", "df"], "raw": ["shared", "array", "original", "pack", " Raw", "remote", "micro", "RAW", "dec", "pure", "all", "ode", "input", "hex", "feed", "missing", "out", "row", "instance", "ack", "rew", "stream", " hex", "internal", "local", "ghost", "load", "alpha", "initial", "Raw", "binary", "blocks", "clean", "unknown", "unsigned", "buffer", "orig", "serial", "enc", "custom", "block"]}}
{"id1": "3401153", "id2": "149935", "code1": "    private String getHTML(String pageURL, String encoding, String dirPath) throws IOException {\n        StringBuilder pageHTML = new StringBuilder();\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(pageURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\");\n            connection.connect();\n            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding));\n            String line = null;\n            while ((line = br.readLine()) != null) {\n                pageHTML.append(line);\n                pageHTML.append(\"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            connection.disconnect();\n        }\n        if (dirPath != null) {\n            File file = new File(dirPath);\n            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));\n            bufferedWriter.write(pageHTML.toString());\n            bufferedWriter.close();\n        }\n        return pageHTML.toString();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getHTML": ["createURL", "updateHTML", "loadJSON", "createHTML", "updateURL", "createPage", "loadURL", "getJSON", "updateJSON", "updatePage", "getURL", "loadPage", "loadHTML", "getPage", "createJSON"], "pageURL": ["PageUrl", "pagePath", "badurl", "pageurl", "PageURL", "PageURI", "Pageurl", "badUrl", "badURL", "badURI", "pageURI", " pageurl", " pageURI", "PagePath", "basePath", "pageUrl", "baseURI", "baseURL", "baseUrl", " pagePath", " pageUrl"], "encoding": ["enasing", "encoder", "casing", "contoder", "encension", "coded", "enoded", "decoding", "Encension", "Encasing", "enaging", "caging", "encaging", "decoder", "contasing", "enoding", "decension", "contoding", "Encoded", "encoded", "Encoder", "encasing", "coding", "contension", "Encoding", "Encaging", "decasing"], "dirPath": ["dirDir", "directoryDir", "dirLocation", "dirpath", "directoryLocation", "buildPath", "dirLog", "buildLog", "Dirpath", "directorypath", "DirLog", "zipPath", "zipPoint", "DirFile", "zippath", "directoryPoint", " dirLocation", "DirLocation", "buildFile", "DirPath", "zipFile", " dirpath", "folderPoint", "folderFile", "dirFile", "directoryLog", "DirDir", "folderPath", "dirPoint", " dirDir", "directoryPath", "directoryFile", "folderpath"], "pageHTML": ["PageUrl", " pageJSON", "resultURL", "pageHTTP", "PageURL", "codeWriter", "siteHTML", "resultHTML", "rowJSON", "codeUrl", "rowHTML", "siteUrl", "sectionURL", " pageBody", "PageURI", "resultJSON", "resulthtml", " pageWriter", "sectionBody", " pagehtml", "sectionHTML", "rowhtml", "codeHTML", "rowURL", " pageHTTP", "PageJSON", "pageURI", "resultUrl", "Pagehtml", "pageWriter", "PageHTTP", "siteURI", "PageHTML", "pageJSON", " pageURI", "resultWriter", "pageBody", "pageUrl", "PageBody", "sectionHTTP", "siteURL", "codehtml", "pagehtml", " pageUrl"], "connection": ["proxy", "text", "log", "uri", "resource", "server", "communication", "uc", "b", "body", "loc", "manager", "io", "org", "session", "socket", "bc", "director", "channel", "Connection", "application", "connect", "ion", "o", "password", "ci", "union", "timeout", "cb", "conn", "connected", "builder", "config", "section", "client", "directory", "reader", "db", "number", "user", "position", "cache", "string", "character", "handler", "c", "con", "bec", "relation", "ctx", "context", "pool", "response", "function", "or", "condition", "wrapper", "collection", "http", "open", "database"], "url": ["page", "log", "uri", "ssl", "image", "server", "build", "loc", "link", "channel", "Connection", "f", "connect", "URL", "coll", "conn", "builder", "client", "contact", "l", "stream", "web", "base", "user", "address", "string", "sl", "plug", "path", "Url", "location", "function", "update", "http", "feed", "browser"], "br": ["buf", "bro", "fr", "arr", "b", "body", "dr", "mr", "ori", "io", "bh", "ner", "bc", "result", "Reader", "str", "cro", "ch", "rb", "cb", "BR", "pr", "reader", "src", "stream", "lr", "tr", "r", "ctr", "err", " reader", "ocr", "ob", "sr", "hr", "bl", "keeper", "ler", "Br", "bridge", "cr"], "line": ["page", "text", "pe", "LINE", "frame", "lf", "message", "unit", "le", "b", "style", "letter", "cell", "data", "ge", "link", "sync", "entry", "str", "lin", "cl", "lines", "end", "inline", "key", "row", "el", "code", "pass", "column", "comment", "li", "l", "base", "r", "object", "string", "character", "c", "Line", "name", "up", "sl", "response", "word", "lc", "ine", "block", "char"], "e": ["ve", "pe", "ee", "ev", "esi", "one", "se", "en", "force", "ce", "die", "ue", "je", "ie", "ec", "f", "oe", "es", "ise", "o", "ace", "ae", "error", "type", "i", "te", "ze", "Exception", "er", "E", "r", "c", "err", "be", "re", "ea", "or", "x", "fe", "exc", "p", "ception"], "file": ["page", "pe", "book", "log", "writer", "FILE", "resource", "ile", "le", "null", "b", "body", "lock", "io", "data", "socket", "output", "folder", "f", "result", "zip", "feed", "h", "source", "dir", "reader", "filename", "l", "db", "files", "base", "handler", "name", "angle", "per", "File", "path", "buffer", "http", "fp"], "bufferedWriter": [" bufferedReader", "bufferingW", "buffedWriter", "ufaredwriter", "buffenedReader", "buffererW", "buffilledWriting", "bufferingFile", "buffererReader", "BuffererWrite", "buffinedFile", "buffenedFile", "BuffererWriter", "bufferedReader", "bufferedWriting", "BufferedFile", "bufferingReader", "buffererWrite", " bufferingReader", "buffinedWriter", "bufferedwriter", "uferedWriting", "buffaredWriting", "bufferedWrite", "buffenedW", " bufferedFile", " bufferedW", "uferedWriter", "ufaredWriting", "buffilledWriter", "bufferedFile", "buffaredwriter", "BuffererReader", "BufferedWriter", "buffererFile", "buffinedWrite", "bufferingWrite", " bufferingFile", "buffenedWriter", "ufaredWriter", "buffinedReader", "buffaredWriter", "BufferedWrite", " bufferingWriter", "buffilledwriter", "bufferingWriter", "buffererWriter", " bufferingW", "uferedwriter", "buffedWriting", "BufferedReader", "BuffererFile", "buffedwriter", "bufferedW"]}}
{"id1": "23035537", "id2": "19109981", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["postcontent", "readcontent", "readContent", "postContent", "createBody", "createcontent", "getBody", "readBody", "createContent", "createContents", "getContents", "postBody", "getcontent", "postContents", "readContents"], "userId": ["UserPath", " userOr", " userID", "UserId", "userOr", "userName", " userName", "messageName", "UserID", "UserName", "messageID", "USERName", "USERPath", "messageId", "USEROr", " userPath", "userPath", "userID", "USERId", "UserOr"], "latestMsgId": ["latestUserID", " latestmsgID", " latestmsgid", " latestMsgID", "latestmsgId", "latestChanid", "latestUserId", "lastMsgId", "latestMessageTime", "latestChanTime", "latestMsgID", " latestmsgTime", " latestmsgId", "latestChanId", "latestMessageID", "latestChanID", "lastMessageID", "latestmsgTime", " latestMsgTime", "latestmsgid", "lastMessageid", "latestUserid", "latestmsgID", "lastMsgID", "latestMessageid", "lastMsgid", "latestMessageId", " latestMsgid", "lastMessageId", "latestMsgTime", "latestMsgid"], "targetUrl": ["sourceURL", " targeturl", "targetURL", "TargetUr", "targetPage", "Targeturl", "sourcePage", "TargetPage", "TargetUrl", "sourceUr", "targeturl", " targetURL", "sourceurl", " targetPage", "targetUr", "sourceUrl", " targetUr", "TargetURL"], "url": ["page", "uri", "ssl", "resource", "image", "server", "b", "connection", "data", "link", "channel", "f", "www", "URL", "download", "i", "source", "api", "client", "stream", "l", "base", "user", "r", "id", "address", "string", "file", "window", "sl", "host", "path", "Url", "location", "http", "feed", "browser"], "in": ["wave", "m", "ins", "resource", "image", "In", "b", "ax", "data", "inc", "raw", "socket", "gin", "input", "din", "IN", "inn", "inas", "out", "s", "pass", "xml", "i", "is", "source", "kin", "reader", "record", "a", "stream", "nin", "login", "inner", "r", "string", "load", "bin", "file", "err", "get", "ini", "as", "query", "arin", "again", "serv", "isin"], "list": ["array", "lp", "server", "parent", "view", "item", "info", "data", "lists", "tx", "sequence", "group", "entry", "all", "document", "result", "LIST", "coll", "set", "batch", "cl", "test", "live", "dict", "xml", "i", "parse", "record", "section", "li", "cli", "listed", "l", "tree", "table", "queue", "id", "language", "string", "detail", "la", "pool", "json", "lc", "chain", "collection", "join"], "parser": ["rss", "writer", "lp", "parent", "system", "info", "data", "director", "document", "jack", "player", "xml", "plugin", "class", "builder", "parse", "api", "reader", "paragraph", "a", "er", "worker", "command", "util", "language", "handler", "loader", "Parser", "per", "php", "layer", "json", "ler", "collection", "http", "p", "processor", "arser"], "dao": ["adaos", "idosa", "dala", "adao", "idaba", "dosa", " daba", "daba", "datala", "Dosa", " dala", " dosa", "daos", "datosa", "idaos", "datao", "adosa", "Daba", " daos", "adala", "dataos", "Dao", "Daos", "idao"]}}
{"id1": "23215235", "id2": "8801436", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readFile": ["readFiles", "readContent", " readContent", " readFiles", "loadContent", "importZip", "loadZip", "importFiles", "importContent", "importFile", "readZip", "loadFile", " readZip", "loadFiles"], "url": ["page", "uri", "ssl", "resource", "image", "server", "connection", "io", "data", "link", "f", "zip", "input", "str", "URL", "job", "download", "xml", "source", "class", "reader", "config", "client", "filename", "l", "stream", "base", "user", "object", "address", "file", "name", "loader", "service", "sl", "host", "bug", "path", "Url", "location", " URL", "buffer", "http", "feed", "browser"], "IOException": ["IPException", "IOInterface", "TimeoutException", "IPInterface", " IOInterface", "TimeoutInterface"], "ParserConfigurationException": ["InvalidConfigAPE", "ParserDefinitionException", "ParserDefinitionAPE", "ParserConstructionEX", "ParserConstructionException", "ParserConfigEX", "ParserConfigAPE", "InvalidConfigurationEX", "InvalidConfigurationAPE", "ParserConfigurationEX", "ParserConstructionAPE", "ParserConfigException", "InvalidConfigEX", "ParserConfigurationAPE", "InvalidConfigException", "InvalidConfigurationException", "ParserDefinitionEX"], "SAXException": [" SAXception", "SAFEException", "SAXception", " SAXPception", "SAXPception", "SAFEception", "SAXPException", "SAXMception", "SAXMException", " SAXPException"], "zipFileName": ["zipFileDirectory", "zipFolderPath", "zipFolderType", "zipFolderName", "archiveFileDirectory", "zipDirDirectory", "zipFileType", "archiveFileName", "archiveFilePath", "archiveFileType", "archiveFilesType", "zipFilesDirectory", "archiveFilesDirectory", "zipFilesType", "zipFolderDirectory", "zipFilesName", "zipDirName", "zipDirPath", "zipFilePath", "zipFilesPath", "archiveFilesPath", "zipDirType", "archiveFilesName"], "urlConnection": ["URLChannel", "URLconnection", "webChannel", "fileManager", "inputConn", "webconnection", "urlResponse", "inputPool", "urlManager", "httpPool", "webConnection", "URLConnection", "inputConnection", "fileConn", "webResponse", "urlConn", "urlChannel", "urlPool", "URLResponse", "urlconnection", "httpManager", " urlChannel", "filePool", "httpConnection", "inputManager", "fileConnection", " urlconnection", " urlResponse", "httpConn"], "inputStream": ["InputSession", "outputStream", "inputChannel", "urlFeed", "outputContext", "InputFile", "InputChannel", "urlFile", "outputstream", "inputFile", " inputContext", "inputFeed", "urlSession", "InputContext", "inputContext", "Inputstream", " inputFeed", "inputSession", " inputSession", " inputFile", "InputFeed", "urlStream", "inputstream", "outputChannel", " inputstream", "InputStream", " inputChannel"]}}
{"id1": "2381663", "id2": "13362846", "code1": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"malformedGadgetSpecIsCachedAndThrows": ["malformedGadgetSpecIsCachedandThrown", "malformedGadgetSpecIsCachedAndthceptions", "malformedGadgetSpecIsCachedAndethrows", "malformedGadgetSpecIsCachedandthceptions", "malformedGadgetSpecIsCachedandthrown", "malformedGadgetSpecIsCachedandThceptions", "malformedGadgetSpecIsCachedAndethceptions", "malformedGadgetSpecIsCachedAndThrown", "malformedGadgetSpecIsCachedAndthrows", "malformedGadgetSpecIsCachedandThrows", "malformedGadgetSpecIsCachedAndthrown", "malformedGadgetSpecIsCachedandthrows", "malformedGadgetSpecIsCachedAndethrown", "malformedGadgetSpecIsCachedAndThceptions"], "request": ["enter", "proxy", "pe", "req", "e", "report", "message", "call", "resource", "server", "complete", "parent", "event", "method", "data", "output", "application", "result", "input", "Request", "job", "claim", "test", "temp", "instance", "create", "QUEST", "config", "client", "pair", "er", "queue", "r", "re", "press", "context", "response", "query", "condition", "trip", "q", "http", "p"]}}
{"id1": "15799935", "id2": "7545002", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAppensionPart", "saveAttachedBody", "saveAttPartBody", "saveAppachmentBody", "saveAppensionBody", "saveAttensionBody", "saveAttachedPart", "saveAppachmentPart", "saveAttachedbody", "saveAttachmentbody", "saveAttachmentFile", "saveAppensionFile", "saveAttensionFile", "saveAttensionbody", "saveAppachmentbody", "saveAttachmentPart", "saveAttPartFile", "saveAppachmentFile", "saveAttPartPart", "saveAttensionPart", "saveAppensionbody", "saveAttPartbody"], "context": ["text", "component", "subject", "message", "resource", "parent", "view", "connection", "system", "ce", "event", "version", "project", "channel", "definition", "document", "input", "mc", "coll", "translation", "template", "support", "community", "container", "Context", "cca", "driver", "config", "cms", "client", "media", "contact", "reader", "center", "network", "queue", "cache", "present", "c", "service", "kernel", "ctx", "host", "environment", "cf", "current", "state", "concept", "front", "ca", "content", "collection", "manager", "request", "processor"], "part": ["art", "to", "partial", " Part", "component", "message", "image", "parent", "html", "body", "connection", "event", "parts", " parts", "channel", "area", "block", "Parts", "translation", "phase", "type", "comment", "source", "mission", "section", "plan", "media", "PART", "pod", "base", "place", "point", "position", "Part", "object", "po", "patch", "file", "chapter", "upload", "start", "app", "name", "service", "per", "pre", "or", "state", "from", "p"], "localAttachment": ["localArtment", "LocalAttail", "LocalAssachment", "localAssention", "localAssment", "localAssachment", "localAddachment", "localAttention", "localAddrollment", " localAttention", "localAttachrollment", "LocalAssail", "LocalAttention", "localAttachacher", " localExtention", " localAttribution", "localattention", " localPartention", "localattachment", "localPartachment", " localAttrollment", "localExtachment", " localExtacher", "localAddail", "localAttachachment", " localExtachment", "localAvacement", "localAddment", " localAttacement", "localAvacher", "localAttail", "localInstachment", " localAttachachment", "localPartension", "localPartribution", "LocalAttachment", " localAttachrollment", "LocalAssment", "LocalAttment", " localAttacher", " localExtacement", "localInstension", " localPartension", "localattment", "localAttrollment", "localAttension", "localExtacement", " localAttachention", " localAttension", "localAttachention", "localAttachension", " localPartachment", "LocalAssention", "localArtail", "localAvachment", "localInstention", "localExtention", "localAttachacement", "localAttacement", "localAttachribution", "localExtacher", "localattrollment", " localPartribution", " localAttment", "localAttribution", "localAttment", "localInstribution", "localAssail", "localArtention", "localPartention", "localAddention", "localArtachment", "localAttacher", "localAvention"], "accountId": ["feedName", "AccountName", "accInfo", "jobName", "appID", "contractId", "appid", "jobid", "contactId", "contractName", "accid", "accID", "AccountID", " accountID", "accountName", "feedId", " accountid", "jobId", "accountInfo", "jobID", "AccountId", " accountName", "accountid", "contractid", "appId", " accountInfo", "Accountid", "contactid", "feedid", "appInfo", "accountID", "contactName", "accId", "feedID"], "attachmentId": ["attociationType", "addachmentType", "extensionSource", "atachmentID", "addachmentId", "attachedID", "attentionID", "attensionSource", "attentionIndex", "attagramInfo", "attlementName", "attagramId", "attlementId", "adachmentIndex", "addentionId", "attensionId", "attmissionSource", "attachmentid", "atociationID", "attentionUrl", "attachmentSource", "attociationReference", "attensionID", "addentionID", "attmissionID", "extachmentSource", "adentionId", "atociationId", "attmissionId", "attmentName", "attociationName", "attachmentType", "adachmentId", "attptionIndex", "attachmentID", "attptionInfo", "addentionType", "attachedType", "extensionId", "attachedId", "attociationID", "atachmentReference", "attachmentReference", "attachmentInfo", "attentionInfo", "addentionUrl", "attachmentName", "addachmentID", "attagramID", "extachmentId", "attmentId", "atachmentName", "attensionid", "adentionIndex", "atociationReference", "extachmentID", "extensionID", "attmentReference", "attlementReference", "attachedUrl", "attptionID", "adachmentInfo", "attentionId", "attachmentIndex", "extensionid", "adentionID", "attagramIndex", "attociationId", "atachmentId", "attentionSource", "attentionid", "attmissionid", "attlementID", "adachmentID", "adentionInfo", "attmentID", "addachmentUrl", "attentionType", "attachmentUrl", "attociationUrl", "extachmentid", "atociationName", "attptionId"], "in": ["ins", "url", "image", "In", "copy", "init", "info", "data", "inc", "socket", "gin", "f", "it", "input", "din", "IN", "inn", "conn", "pass", "cin", "i", "is", "source", "pull", "reader", "inside", "nin", "a", "login", "inner", "slice", "id", "ac", "load", "bin", "file", "con", "err", "up", "pin", "ini", "as", "or", "plus", "again", "p"], "saveIn": [" saveOut", " saveIN", " savein", "savein", "SaveOut", "savOut", "stageOut", "saveOut", "aveAs", "savin", "aveIN", "writein", "writeOut", "stageAs", "writeIN", "avein", "stageIn", "stageIns", "aveIn", "saveIns", "SaveIns", "savIn", "savAs", " saveIns", "saveIN", "SaveAs", "aveOut", "SaveIn", "writeIn"], "saveAs": [" saveOut", " saveFile", "SaveOut", "copyAs", " saveAS", "writeAS", "copyAS", "openFile", "saveOut", "copyas", "saveAS", "saveas", "createAS", "copyIn", " saveas", "createFile", "writeOut", "openAt", "createAt", "writeAs", "saveFile", "Saveas", " saveAt", "openAs", "saveAt", "createAs", "SaveAs", "SaveAS", "SaveIn", "writeIn", "openAS"], "out": ["at", "to", "page", "ex", "writer", "default", "flow", "image", "copy", "null", "init", "io", "off", "data", "outer", "this", "sync", "inc", "output", "o", "Out", "s", "conn", "temp", "source", "client", "a", "inner", "outs", "cache", "string", "v", "bin", "file", "c", "err", "exec", "name", "other", "up", "OUT", "path", "as", "plus", "again", "line", "ext"], "copySize": ["opensize", "leSIZE", " copysize", "saveLength", "copysize", "openLength", " copyLength", "leLength", "CopyLength", " copySIZE", " copyAddress", "openSize", "byteAddress", "copyLength", "savesize", "saveAddress", "CopySize", "copyAddress", " copyTime", "lesize", "saveSize", "CopyTime", "leSize", "copyTime", "bytesize", "byteLength", "openSIZE", "byteTime", "copySIZE", "byteSize", "Copysize"], "contentUriString": ["contentIiStr", "contentUriStr", "contentUiniByte", "contentIriStr", "contentUristring", "contentUiniStr", "contentIriUnit", "contentIrisUnit", "contentUiniNumber", "contentUiNumber", "contentUioString", "contentUriUnit", "contentUuriStr", "contentUridString", "contentIriNumber", "contentUpiString", "contentUiostring", "contentUriByte", "contentUridStr", "contentIrisstring", "contentIriString", "contentUiString", "contentUrisStr", "contentUiStr", "contentUioStr", "contentUrisstring", "contentIriInt", "contentUiniString", "contentUpiInt", "contentUrisInt", "contentUuriNumber", "contentUiByte", "contentIrisStr", "contentIrisInt", "contentUpistring", "contentIriByte", "contentUrisString", "contentUuriString", "contentUridUnit", "contentIiString", "contentIiNumber", "contentUrisUnit", "contentUriInt", "contentUioInt", "contentUiUnit", "contentUriNumber", "contentIrisString", "contentIiByte", "contentUuriByte", "contentIristring", "contentUpiStr"], "mSize": ["pSize", "pCount", "iSize", "mCount", "pLength", "pName", "cCount", "mName", "mLength", "iName", "cLength", "cName", "cSize", "iLength", "iCount"], "mContentUri": ["mContentIci", "mResourceUri", "mContentOUric", "mResourceIci", "mResourceIris", "mContentOUci", "mContentIric", "mResourceIri", "mContentUrris", "mResourceUci", "mResourceUric", "mContentUrri", "mContentUris", "mContentUric", "mContentOUris", "mResourceUris", "mResourceIric", "mContentIri", "mContentUrci", "mContentOUri", "mContentIris", "mContentUci", "mContentUrric"], "cv": ["conv", "buf", "cap", "que", "core", "vp", "uc", "cp", "loc", "rc", "sv", "um", "av", "uv", "csv", "bc", "vv", "vr", "vs", "mc", "pb", "iv", "coll", "nc", "cb", "auc", "iq", "cc", "nv", "ctrl", "cu", "cm", "keep", "co", "ov", "xc", "sc", "CV", "lv", "cr", "v", "c", "VC", "fc", "GV", "vc", "ctx", "cf", "cd", "cover", "vm", "lc", "content", "cs", "ca", "enc", "fp"], "uri": ["prefix", "proxy", "attribute", "url", "resource", "data", "username", "universal", " URI", "range", "route", "iv", "storage", "href", "ci", " Uri", "uni", "i", "uid", "metadata", "api", "cli", " url", "mi", "pi", "base", "point", " ur", "id", "address", "string", " scheme", "URI", "gb", "iri", "environment", "path", "ui", "query", "qi", "location", "format", "http", "oid", "ri"]}}
{"id1": "4531653", "id2": "8921716", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"md5": [" md512", "mp512", "md6", "mp5", "mp7", "md7", "MD6", "md512", "MD512", "mp6", " md7", " md6", "MD7", "MD5"], "data": ["DATA", "text", "pad", "message", "image", "script", "sha", "body", "method", "this", "in", "output", "input", "str", "hex", "dat", "template", "bytes", "key", "code", "source", "api", "media", "a", "base", "ata", "address", "cache", "string", "alpha", "name", "content", "buffer", "format", "database"], "md": ["m", "hd", " MD", "mp", "cmd", "material", "mo", "dig", "dd", "gd", "editor", "mc", "mag", "d", "od", "mb", "wd", "meta", "nm", "code", "amd", "mg", "dm", "bd", "metadata", "pd", "MD", "docker", "di", "db", "ad", "mac", "mand", "mm", "ma", "sm", "rod", "pm", "grad", "mt", "cd", "mod", "ds"]}}
{"id1": "22338097", "id2": "16719805", "code1": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"createMD5": [" createSHA5", "createMD2", "createSHA5", " createMD512", " createSHA256", "createSHA2", "createMD256", "createMAC256", "createSHA256", "createmd512", "createmd256", " createMD256", "createmd5", "createMD512", " createSHA512", "createmd2", "createMAC5", "createMAC2", "createMAC512", " createSHA2", "createSHA512", " createMD2"], "pwd": ["cpassword", "cwd", " pWD", "cWD", " pwm", "Pwd", "hwm", "Ppassword", "hWD", "Pw", "pwm", "pWD", "hwd", "PWD", " ppassword", "cw", "Pwm", "ppassword", "pw", " pw", "hw"], "md": ["m", "rm", "hd", " MD", "mp", "cmd", "mo", "um", "dig", "dd", "gd", "py", "mc", "mag", "d", "vd", "od", "mb", "meta", "hm", "wd", "amd", "mg", "dm", "bd", "pkg", "cm", "metadata", "bf", "MD", "tmp", "di", "ad", "de", "mac", "ind", "mand", "po", "mm", "am", "mk", "pm", "mt", "cd", "mod", "df"], "pd": ["fd", "std", "ppa", "pe", "hd", "sd", "np", "lp", "pins", "xd", "pat", "cp", "ps", "pg", "sv", "dd", "gd", "py", "pb", "vd", "d", "pid", "od", "wd", "PD", "dl", "bd", "ped", "wp", "pi", "da", "po", "pc", "td", "ld", "pm", "cd", "dp", "ppo", "pp", "p", "tp", "ds"], "app": ["bb", "cap", "page", "pad", "array", "pack", "arr", "append", "ask", "apply", "html", "b", "g", "conf", "mp", "form", "cmp", "ce", "cell", "fb", "data", "msg", "allow", "bc", "ang", "sb", "application", "apps", "py", "acc", "ch", "ape", "test", "container", "s", "instance", "api", "keep", "buff", "ip", "db", "mac", "cache", "string", "amp", "ac", "ap", "fac", "host", "sp", "aa", "buffer", "APP", "ab", "App", "pp", "p"], "i": ["u", "z", "uri", "e", "j", "b", "n", "fi", "ori", "io", "info", "data", "si", "f", "ni", "o", "index", "d", "ci", "end", "oi", "s", "key", "ji", "abi", "multi", "li", "di", "l", "hi", "pi", "ip", "xi", "inner", "slice", "id", "uli", "ti", "v", "gi", "c", "t", "ri", "I", "zi", "ai", "ix", "chi", "ii", "ui", "x", "bi", "ini", "mu", "qi", "p"], "s2": [" s12", "dstwo", "sl182", "p3", "s12", "sestwo", "ses2", " s6", "ptwo", "p12", "ses6", " salt", "salt", " s1", "stwo", "ds2", "sl1", "ds6", " s182", "pass1", " s3", "p182", "s3", "pass12", "p1", "pass2", "passtwo", "palt", "p2", "s6", "s182", " stwo", "s1", "sl2"]}}
{"id1": "18238468", "id2": "23611770", "code1": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"testLoadSource": ["TestLoadFormat", "testLoadSources", "testloadSources", "TestloadSourceFile", "testAddSourceFile", "testReadSourceFile", "testReadFormat", "TestloadSources", "TestLoadSource", "testloadFormat", "TestloadFormat", "testAddFormat", "testReadSources", "TestLoadSourceFile", "TestLoadSources", "testLoadFormat", "testAddSources", "TestloadSource", "testloadSource", "testloadSourceFile", "testReadSource", "testAddSource", "testLoadSourceFile"], "metadata": ["m", "sample", "attribute", "np", "default", "message", "module", "general", "summary", "sheet", "material", "info", "data", "music", "md", "mo", "this", "parser", "journal", "definition", "document", "tt", "map", "template", "meta", "xml", "source", "ami", "reader", "properties", "header", "tmp", "media", "stream", "filename", "pdf", "my", "artist", "params", "loader", "ctx", "generic", "auto", "json", "content", "adata", "iterator", "collection", "manager", "database", "df"], "inputStream": ["streamSteam", "outputStream", "inputSteam", "rawstream", "streamStream", "inputWriter", "InputFile", "outputStreamer", "outputstream", "inputFile", "rawStream", "outputForm", " inputForm", " inputSource", "streamStreamer", "inputStreamer", "inputForm", " inputWriter", "outputFile", "Inputstream", "InputWriter", "outputWriter", "streamstream", "InputSource", "outputSource", " inputFile", "rawStreamer", "InputForm", "inputSource", "outputSteam", "InputSteam", "rawSteam", "inputstream", " inputstream", "InputStream", " inputSteam"], "writer": ["ana", "WR", "text", "widget", "wr", "write", "master", "null", "data", "writing", "external", "written", "writ", "output", "winner", "document", "creator", "her", "editor", "Writer", "key", "out", "settings", "code", "temp", "rw", "builder", "driver", "reader", "riter", "worker", "inner", "usher", "walker", "r", "cache", "string", "handler", "w", "per", "writers", "words", "wrapper", "keeper", "word", "pointer", "buffer", "format", "author", "ler", "director", "RW"], "contents": ["CONTences", "constent", "contENTS", "contentents", "contentacts", "Contacts", "Contents", "CONTented", "Contences", "Content", "constents", "contentences", "Contented", "constENTS", "ContENTS", "contences", "CONTent", "contented", "contacts", "CONTacts", "constented", "content", "CONTents", "contentent", "CONTENTS"]}}
{"id1": "5998352", "id2": "4164833", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["testStandardBee", "testStandardTees", "teststandardMees", "testStandardMee", "testStandardBees", "teststandardTee", "teststandardTeed", "testStandardFee", "testStandardTeed", "teststandardMae", "testStandardMae", "testStandardMeed", "testStandardFees", "teststandardTae", "teststandardMee", "testStandardFae", "testStandardTae", "testStandardFeed", "testStandardBeed", "teststandardTees", "testStandardBae", "teststandardMeed", "testStandardMees"], "reference": ["distance", "forward", "prefix", "Reference", "description", "attribute", "proxy", "url", "uri", "resource", "message", "report", "References", "copy", "server", "length", "connection", "remote", "relative", "version", "single", "hello", "external", "sequence", "output", "primary", "document", "archive", "index", "ref", "test", "type", "code", "see", "memory", "directory", "filename", "pair", "target", "number", "variable", "ference", "address", "string", " Reference", "REF", "c", "name", "re", "relation", "binary", "order", "location", "path", "pointer", "specified", "buffer", "format", "collection", "request", "rice", "database", "compatible"], "source": ["proxy", "text", "writer", "url", "resource", "e", "server", "se", "copy", "parent", "g", "view", "connection", "ce", "io", "ie", "output", "Source", "result", "input", "ref", "code", "temp", "i", "iter", "driver", "reader", "src", "config", "target", "table", "r", "object", "slice", "string", "ource", "service", "SOURCE", "context", "buffer", "fe"], "destination1": ["destinator01", "destribution1", "destinate01", "constinator2", "destarationOne", "destinatorOne", "Destension0", "Destension1", "destination01", "DestinateOnce", "destentionOnce", "constinationOne", "destribution0", "destinations2", "DestinationOnce", "constination01", "destaration0", "DestensionOne", "destentionOne", "destension0", "destination0", "destinate2", "DestinateOne", "destention1", "destinatorOnce", "destinateOne", "Destination1", "destaration1", "DestinationOne", "destinate1", "constination1", "constinatorOne", "destensionOne", "destinator2", "destinateOnce", "Destination0", "destinationOnce", "destinations01", "destinator1", "constinator1", "constinator01", "destributionOne", "Destinate1", "constination2", "destinationsOne", "destension1", "destinations1", "destinationOne"], "destination2": ["coordinate2", "coordinate22", "destignmentSecond", "destribution2", "destationtwo", "destinations02", "descination02", "destication22", "coordination8", "destication8", "destination02", "descination2", "destination22", "Destinationtwo", "desticationSecond", "Destination2", "descinationsSecond", "destinationSecond", "destinateSecond", "coordination2", "destation1", "coordinate8", "descinationSecond", "destination4", "destinating2", "destinate02", "destignment02", "coordination22", "destication2", "destinate8", "descination1", "destinatingtwo", "destinationsSecond", "destinationtwo", "destinations2", "Destination4", "destation4", "destinatetwo", "coordinationSecond", "coordinateSecond", "destinate22", "destinate2", "destination8", "Destination1", "descinations2", "destation2", "destribution8", "descinations02", "destributionSecond", "destinate1", "destribution22", "destignment2", "destinate4", "Destinate1", "destignment1", "descinations1", "Destinate4", "Destinate2", "Destinatetwo", "destinations1", "destinating4", "destinating1"], "tee": ["leee", "teee", "TEee", "eeee", " teec", "ettef", "lepe", " tef", "cee", " teee", "TEe", "TEc", "ceee", "eeffe", "tef", "chef", "cec", " teae", "teffe", "lee", "ceea", "sef", "tepe", "chee", "leec", "seae", "tec", "teec", "see", "eee", "chei", " tei", "etteee", "seee", "tei", " tec", "teae", " tepe", "TEea", "lei", " teffe", "ettee", "leffe", "etteae", "lef", " teea", "eeec", "chepe", "teea"]}}
{"id1": "9413074", "id2": "12236729", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 0, "substitutes": {"getLocation": ["getFile", "newURL", "setLocation", "GetFile", "GetAddress", " getAddress", "findLoc", "newLoc", "getURL", "findURL", "getLoc", "findFile", "GetPath", "setURL", "GetLoc", "newFile", "getPath", "setPath", " getURL", "newLocation", "GetLocation", "setAddress", "GetURL", "findLocation", "getAddress", " getPath"], "clazz": ["Clazz", "cluster", "Cllass", " cluster", "CLuster", "CLazz", "cllass", "Clclass", " clclass", "Cluster", "CLclass", " cllass", "clclass", "CLlass"], "url": ["ll", "image", "html", "null", "org", "entry", "cl", "class", "l", "string", "gl", "context", "browser", "page", "text", "uri", "resource", "server", "connection", "rel", "link", "zip", "URL", "Location", "coll", "code", "i", "config", "lr", "object", "local", "email", "loader", "layer", "path", "feed", "log", "loc", "channel", "impl", "site", "route", "pull", "api", "web", "user", "ob", "sl", "Url", "buffer", "http", "bb", "ssl", "b", "mount", "f", "ref", "href", "jar", "source", "client", "base", "position", "address", "language", "name", "service", "host", "bug", "or"], "location": ["warning", "description", "uri", "resource", "message", "image", "length", "style", "connection", "loc", "data", "via", "result", "site", "area", "route", "Location", "URL", "storage", "translation", "error", "home", "instance", "source", "library", "directory", "filename", "l", "feature", "position", "local", "address", "language", "string", "layout", "property", "region", "layer", "response", "path", "function", "lc", "content", "operation", "where"], "file": ["page", "pe", "log", "FILE", "uri", "resource", "ile", "image", "able", "remote", "il", "io", "child", "folder", "entry", "f", "it", "key", "el", "source", "class", "dir", "filename", "l", "files", "base", "object", "cache", "name", "entity", "per", "File", "full", "get", "path", "fe", "line", "fp", "lib"]}}
{"id1": "8000624", "id2": "841724", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyto", "CopyFile", "copyto", "copyFrom", " transferTo", "copyFile", " copyTo", " transferto", " copyFrom", " transferFile", " transferFrom", " copyFile", "CopyFrom", "Copyto", "copyTo"], "dest": [" Dest", "exit", "txt", "write", "Dest", "destroy", "flat", "die", "data", "later", "output", "folder", "done", "comb", "test", " destination", "them", "temp", "rest", "source", "class", "src", "filename", "tmp", "target", "delete", "opt", "transform", "table", "object", "desc", "bin", "file", "obj", "dist", "sup", "name", "w", "wb", "path", "cont", "content", "orig", "img"], "in": ["wave", "m", "ln", "ins", "image", "In", "b", "ax", "n", "connection", "init", "thin", "inc", "f", "gin", "input", "fa", "vin", "din", "IN", "inn", "lin", "h", "s", "pass", "conn", "cin", "i", "rin", "win", "sin", "reader", "source", "kin", "inside", "nin", "l", "issue", "login", "inner", "r", "id", "pull", "ac", "bin", "con", "re", "up", "pin", "ini", "as", "x", "plus", "again", "lib", "isin"], "out": ["ex", "writer", "url", "vert", "one", "image", "call", "copy", "b", "n", "off", "outer", "io", "data", "this", "sync", "outside", "socket", "inc", "part", "external", "output", "no", "not", "o", "Out", "timeout", "conn", "our", "temp", "i", "client", "nin", "target", "inner", "outs", "user", "object", "cache", "exec", "bin", "err", "file", "name", "app", "other", "up", "w", "net", "OUT", "ou", "pin", "x", "plus", "or", "again", "lib", "ext"], "c": ["m", "u", "ct", "esc", "e", "col", "uc", "C", "n", "rc", "ce", "enc", "arc", "bc", "ec", "f", "o", "d", "ch", "cl", "ci", "cb", "code", "cc", "i", "comment", "cu", "cm", "config", "l", "r", "oc", "xc", "sc", "ac", "v", "pc", "abc", "ic", "dc", "fc", "t", "cf", "x", "cy", "content", "pointer", "lc", "ca", "buffer", "exc", "cr", "p", "char"]}}
{"id1": "937612", "id2": "13516684", "code1": "    public String new2Password(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            String clearPassword = passwd;\n            md.update(clearPassword.getBytes());\n            byte[] digestedPassword = md.digest();\n            return new String(digestedPassword);\n        } catch (java.security.NoSuchAlgorithmException e) {\n            System.out.println(\"MD5 doesn't exist\");\n            System.out.println(e.toString());\n            return null;\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 0, "substitutes": {"new2Password": ["hash3Word", "hash2Secret", "hash4Password", " gen2Password", "hashBasePassword", "hash3Password", "hashBaseSecret", "hash3WD", " gen3WD", "hash4Word", " gen2Secret", "hash2Word", "hashBaseWD", "hash3Secret", "hashBaseWord", "hash2WD", "hash4Secret", " gen2WD", " gen3Secret", " gen2Word", " gen3Password", "hash4WD", " gen3Word", "hash2Password"], "passwd": ["passpass", "PassWD", "asspass", " passpass", "asswd", " passpassword", "passWD", "password", "asspassword", "assword", "Passwd", " password", "passpassword", "Passpass", "Passpassword", " passWD", "assWD", "Password"], "md": ["m", "hd", " MD", "mp", "sha", "cmd", "mo", "dig", "dd", "f", "hash", "editor", "mc", "mag", "d", "vd", "password", "od", "mb", "ms", "meta", "wd", "nm", "amd", "mg", "dm", "bd", "metadata", "pd", "MD", "di", "ad", "mac", "ind", "mand", "po", "mm", "sm", "ma", "am", "ld", "pm", "grad", "mt", "dh", "df"], "clearPassword": ["clearWord", "plainPassword", "plainString", "clearPass", "passPassword", " clearpassword", " clearPass", "plainPass", "passWord", "clearMessage", "hashMessage", "passPass", " clearword", "clearString", " clearMessage", "passString", "password", " clearString", "plainpassword", "hashPassword", " clearWord", "clearpassword", "hashword", "passpassword", "passMessage", "clearword", "hashWord"], "digestedPassword": ["DigestPass", " digestPat", " digestPass", "digestedpassword", "digestingPad", "digustedPass", "diguredPad", "digestingpassword", "digestPad", "digestingPass", "digustedPassword", "digestpassword", "DigestPassword", "digestPat", "diguredpassword", "DigestedPass", "DigestedPassword", "diguredPassword", " digestPassword", "digestedPass", " digestedPass", "DigestPad", "DigestedPad", " digestedPat", "Digestedpassword", "Digestpassword", "digestPass", "diguredPass", "digustedPat", "digashedPassword", "digestingPassword", "digestedPad", "digestedPat", "digashedPass", "digashedPat", "digestPassword"]}}
{"id1": "20011285", "id2": "8046691", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["replace", "save", "rm", "log", "write", " cp", "apply", "cp", "link", "sync", "py", "zip", "paste", "split", "clone", "clip", "type", "download", "move", "cat", "Copy", "create", "delete", "change", "load", "file", "share", "upload", "get", "transfer", "update", "opy", "cop"], "sourceFile": ["SourceFile", "sampleFile", "apiFilename", " sourceTime", "SourceSourceFile", "targetFolder", " sourceDir", "ourceFile", "siteFile", "ourceDirectory", "sampleFILE", "targetDir", "SourceTime", "sourceDirectory", "sourceFolder", "Sourcefile", "targetPage", "slaveFilename", " sourceFiles", "siteFiles", " sourceDirectory", "apiFILE", "sourcePage", "SourcePlace", "sampleFilename", "targetFiles", "ourceTime", " sourceFolder", "sourcePlace", "ourcePlace", "siteFILE", "sourcefile", "ourcefile", "apiFile", "ourceFiles", " sourceBook", "targetFile", " sourcePlace", "sourceBook", "apiFiles", "sourceSourceFile", "SourceFiles", " sourceSourceFile", "sourceFilename", "ourceBook", "targetDirectory", "slaveFILE", "ourceSourceFile", "ourceFolder", "slaveFile", "sourceFiles", "siteFilename", " sourcePage", "slaveFiles", " sourcefile", "sourceFILE", "SourceDirectory", "ourcePage", " sourceFilename", "SourceDir", "sampleFiles", "sourceDir", "SourceBook", " sourceFILE", "sourceTime"], "destinationFile": ["destinatorPath", "dominationPath", "destinationSourceFile", "dominationFiles", "destinatingSourceFile", "desturationSourceFile", "desturationDirectory", " destinationFiles", "dominatorFILE", "dominatorPath", " destinatingFolder", " destinatingFiles", "distinationFolder", "DestinatingFiles", "destinationfile", "destinatedfile", "destinatingFILE", "desturationFile", "destinationFILE", "targetinatedFile", "destinatingPath", "destinatorFiles", "destinatorFILE", "destinationFolder", "targetinationFiles", "distructionfile", "destinatingFile", "DestinationFile", "destinatePath", "distructionFolder", "destuationFile", "DestinationSourceFile", "destinationDirectory", "dominationfile", "destwayFiles", "dominatorFile", "destwayFILE", "destuationFolder", "destinateFile", "dominationFILE", "dominatorFiles", "destinatingFiles", "destinatingDirectory", "destinationFiles", " destinatingfile", "DestinatingDirectory", "destinatedFiles", "distructionFILE", "distructionFile", "destinatorfile", "destinatedFolder", "destwayfile", "destructionfile", "distinationfile", "destuationfile", "destinatingFolder", "destinatefile", "destructionFolder", "destwayFile", "DestinatingFile", "destinatorFile", "destinatorSourceFile", "targetinatedFolder", "destuationFILE", " destinationFolder", "DestinationFiles", "targetinationFile", "destinatorDirectory", "DestinatingSourceFile", "destructionFILE", "destinatedFile", "destinateFiles", "desturationFiles", "targetinationfile", " destinatingFile", "destructionFile", "targetinationFolder", "targetinatedfile", " destinationfile", "distinationFILE", "dominationFile", "destinationPath", "destinateFolder", "DestinationDirectory", "destinatingfile", "targetinatedFiles", "distinationFile", "destinatorFolder", "dominatorfile"], "tmp": ["buf", "bb", "ppa", "page", "rm", "array", "np", "txt", "e", "dest", "mp", "cmp", "st", "flat", "fb", "data", "mo", "csv", "part", "folder", "pos", "py", "zip", "stuff", "apps", "area", "storage", "rb", "split", "dat", "meta", "mb", "tab", "temp", "api", "dir", "media", "ip", "db", "files", "slice", "cache", "po", "v", "handler", "mm", "obj", "upload", "sup", "list", "pty", "amp", "t", "params", "sp", "diff", "current", "vm", "nb", "pp", "p", "tp", "img"], "f": ["fd", "m", "fn", "fo", "uf", "u", "fl", "fr", "lf", "e", "j", "b", "g", "conf", "fi", "xf", "io", "info", "fb", "this", "fa", "o", "d", "fs", "tf", "inf", "rf", "bf", "l", "ff", "fx", "r", "v", "handler", "c", "file", "fc", "t", "af", "full", "cf", "F", "x", "fe", "fp", "p", "df"], "i": ["ij", "m", "u", "uri", "e", "j", "b", "n", "fi", "io", "info", "si", "ie", "in", "o", "d", "index", "ci", "h", "oi", "s", "key", "iu", "ji", "multi", "y", "li", "di", "l", "ip", "pi", "hi", "xi", "vi", "id", "ti", "v", "gi", "c", "start", "name", "ri", "I", "ai", "ix", "ii", "ui", "x", "bi", "qi", "lc", "p"], "source": ["proxy", "component", "uri", "resource", "e", "core", "server", "parent", "scope", "view", "null", "connection", "ce", "io", "back", "ge", "this", "si", "ie", "Source", "site", "input", "result", "storage", "src", "reader", "client", "stream", "target", "slave", "base", "slice", "id", "cache", "ource", "start", "service", "sl", "SOURCE", "grade", "diff", "get", "wrapper", "current", "secure", "force", "use", "from"], "destination": ["estination", "partation", "combination", "Destation", "destinate", "generinator", "destation", "partinated", "Destinator", "Destinate", "generinated", "partinator", "partination", "combinator", "estinator", " destinated", "combinating", " destinator", "destinated", "Destination", "destinating", " destation", "combinate", "combinated", "Destinating", "destinator", "Destinated", "generinate", "estinate", "generination", "estinating"]}}
{"id1": "20588811", "id2": "4501356", "code1": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "code2": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "label": 0, "substitutes": {"run": ["running", "install", "unit", "server", "build", "system", "Run", "loop", "test", "process", "create", "client", "work", "worker", " Run", "exec", "start", "app", " test", "up", "runner", "release", "update", "execute", " running", "sleep"], "time": ["TIME", "message", "image", "money", "clock", "length", "count", "server", "volume", "etime", "info", "micro", "version", "later", "depth", "times", "loop", "now", "mode", "year", "timer", "hour", "date", "timeout", "type", "home", "temp", "size", "ime", "im", "work", "ip", "tim", "cache", "counter", "file", "start", "age", "name", "service", "up", "Time", "current", "value", "content", "sleep", "stage", "request", "space", "rate", "right"], "hostname": ["Hostn", "Hostpath", "portNAME", "addresscode", "addressname", "Hostcode", " hostNAME", "Hostname", "localhostNAME", "portname", "localhostline", " hostn", "hostline", "addresspath", "hostpath", " hostline", "localhostname", " hostpath", "addressn", " hostcode", "portline", "hostNAME", "hostn", "hostcode"], "protocol": ["propocol", "extotype", "protolution", "resourceocol", "resourcename", "protname", "scheocol", "scheolution", "prototype", "scheport", "scheotype", "protport", "Protolution", "tport", "extport", "totype", "tocol", "extname", "extocol", "Protport", "propotype", "Protocol", "tname", "resourceotype", "propport", "Prototype", "resourceport", "propolution"], "port": ["uri", "server", "length", "profile", "version", "method", "username", "phone", "limit", "password", "key", "type", "PORT", "plugin", "Port", "target", "ports", "ip", "point", "user", "table", "address", "file", "name", "service", "host", "pool", "value", "secret"], "path": ["filter", "text", "uri", "resource", "image", "method", "ath", "version", "session", "route", "password", "key", "type", "home", "code", "api", "dir", "config", "Path", "user", "id", "string", "file", "name", "host", "pattern", "location", "format", "secret"], "action": ["filter", "Action", "activity", "auth", "resource", "image", "call", "script", "style", "view", "act", "event", "method", "info", "session", "step", "input", "sort", "error", "type", "plugin", "ack", "agent", "user", "token", "account", "file", "service", "actions", "function", "query", "format", "active", "stage"], "xml": ["text", "description", "log", "ez", "txt", "message", "image", "X", "html", "example", "body", "form", "event", "plex", "info", "tx", "output", "model", "document", "application", "zip", "mx", "www", "code", " XML", "ws", "config", "stream", "work", "files", "email", "string", "file", "name", "ml", "ww", "php", "context", "json", "response", "x", "content", "value", "events", "office", "mail", "update", "http", "feed", "doc", "ql"], "data": ["DATA", "to", "text", "description", "array", "auth", "message", "resource", "image", "one", "complete", "body", "connection", "empty", "info", "method", "session", "output", "entry", "document", "result", "input", "str", "dat", "batch", "key", "download", "results", "i", "api", "record", "media", "stream", "dump", "send", "object", "change", "token", "string", "file", "actions", "next", "post", "function", "json", "response", "content", "format", "update", "http", "feed", "request", "open", "database"], "u": ["ur", "nu", "un", "uri", "lu", "e", "bu", "uc", "uu", "b", "n", "ru", "ul", "ue", "ut", "universal", "uv", "f", "o", "su", "us", "h", "uni", "uid", "i", "cu", "uno", "a", "l", "user", "v", "c", "tu", "up", "ou", "U", "hu", "ui", "p"], "url": ["page", "fl", "ssl", "uri", "resource", "ll", "server", "b", "n", "connection", "channel", "f", "www", "URL", "download", "api", "config", "client", "l", "web", "base", "user", "r", "file", "service", "sl", "host", "Url", "response", "http", "p", "open", "browser"], "conn": ["conv", "oa", "http", "ssl", "cn", "server", "b", "n", "connection", "en", "cp", "act", "rc", "info", "socket", "channel", "ec", "Connection", "f", "connect", "ch", "nc", "h", "cb", "Conn", "api", "client", "cli", "l", "ann", "exec", "con", "c", "obj", "comm", "ob", "net", "ctx", "ai", "enc", "util", "serv", "p", "open"]}}
{"id1": "21491791", "id2": "2834524", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "label": 1, "substitutes": {"run": ["spawn", "running", "log", "unit", "call", "apply", "build", "Run", "func", "loop", "all", "job", "test", "code", "process", "create", "work", "worker", "command", "fork", "exec", "start", "app", "runner", "invoke", "execute"], "input": ["text", "flow", "resource", "image", "view", "connection", "form", "io", "data", "parser", "reading", "raw", "in", "entry", "audio", "storage", "index", "read", "out", "conn", "instance", "source", "driver", "config", "client", "stream", "work", "worker", "inner", "user", "Input", "internal", "control", "address", "file", "initial", "loader", "up", "context", "state", "iterator", "active", "feed", "request", "readable"], "output": ["page", "text", "exit", "log", "console", "unit", "write", "resource", "image", "parent", "connection", "letter", "outer", "data", "later", "writing", "written", "application", "document", "generated", "index", "Writer", "job", "end", "out", "temp", "source", "Output", "config", "network", "filename", "web", "target", "user", "queue", "control", "object", "cache", "file", "writers", "path", "response", "environment", "operation", "put", "office"], "reader": ["book", "request", "peer", "resource", "image", "server", "rer", "view", "system", "io", "parser", "ner", "reading", "in", "entry", "audio", "Reader", "read", "row", "rator", "builder", "source", "driver", "client", "riter", "stream", "er", "worker", "slave", "inner", "r", "handler", "loader", "context", "wrapper", "author", "oder", "manager", "ri", "owner"], "writer": ["wr", "write", "wan", "connection", "outer", "data", "writing", "engine", "ner", "written", "writ", "entry", "creator", "her", "editor", "Writer", "ew", "out", "wer", "player", "maker", "ws", "rw", "builder", "nw", "driver", "war", "riter", "work", "er", "worker", "ter", "inner", "r", "wa", "wire", "w", "wb", "writers", "wrapper", "or", "word", "office", "author", "manager", "request"], "pump": ["camp", "ppumping", "pumping", "pamp", "prump", "Pmp", "mprint", "dumps", "pdump", " pmp", "Pam", "ppumper", "cump", "ppumps", "Pdump", "humper", "cumper", "mumper", "pumps", "Pumper", " pdump", "Pump", " pumper", "pam", "pumper", "pmp", "Pumping", "prumper", "pprint", "Pprint", "humps", " pumping", "dmp", "mump", "hump", "dump", "Pamp", "pram", "Pumps", " pumps", "dumper", " pam", "hprint", " pamp", "prdump", "ppump", "mumps", "cumping"], "counter": ["enter", "page", "Counter", "url", "server", "clock", "const", "master", "count", "parent", "offset", "num", "race", "outer", "version", "step", "ner", "hello", "sequence", "cookie", "loop", "entry", "now", "result", "meter", "timer", "second", "index", "ener", "row", "code", "ver", "instance", "progress", "consumer", "comment", "trace", "center", "rew", "builder", "keep", "ter", "er", "worker", "seed", "number", "ger", "walker", "lr", "r", "inner", "starter", "repeat", "loader", "continue", "inter", "order", "layer", "runner", "current", "currency", "pointer", "author", "zero", "collection", "keeper", "ception", "processor"], "buffer": ["buf", "page", "uf", "text", "url", "message", "resource", "server", "length", "data", "port", "Buffer", "channel", "limit", "entry", "document", "batch", "source", "iter", "header", "buff", "base", "queue", "position", "address", "file", "loader", "reference", "binary", "layer", "uffer"], "off": ["own", "art", "oa", "Off", "flow", "offset", "OFF", "info", "pos", "offs", "now", "area", "fail", "o", "set", "ref", "end", "out", "Offset", "open", "addr", "ff", "of", "opt", "inner", "eno", "less", "low", "ord", "start", "left", "down", "unknown", "ui", "auto", "head", "on", "offer"], "len": ["fd", "lon", "gen", "log", "ln", "fl", "url", "lf", "fin", "ll", "length", "count", "n", "body", "loc", "en", "lock", "lan", "limit", "in", "pos", "all", "elt", "lin", "ref", "Len", "end", "val", "el", "size", "width", "li", "l", "lit", "lim", "den", "bin", "name", "ld", "layer", "ler", "lc", "lt", "line", "on", "lib"], "rd": ["fd", "rt", "red", "rand", "rm", "rss", "raid", "fr", " r", "xd", "nd", "rx", "rob", "ru", "dr", "RR", "nr", "rc", "rs", "rh", "dd", "d", "rb", "rn", "val", "rid", "RD", "rw", "rl", "rr", "db", "lr", "r", "ind", "adr", "ud", "ord", "dra", "rod", "ld", " prod", "hr", "ra", "cr", "rf", "ds"]}}
{"id1": "12085127", "id2": "12236729", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 0, "substitutes": {"navigate": [" Navigation", "ivigating", "avigate", "Navigated", " Navigate", " Navigating", "ajigate", "ajigation", "Navigate", "ivigated", "Navigation", "navigating", "Navigating", "ajigating", "Navig", "avigating", "avigated", "ivigation", "navigation", "navig", "avigation", " Navig", "ajig", "ivigate", "navigated"], "url": ["page", "uri", "resource", "image", "server", "ssl", "ll", "e", "html", "build", "org", "link", "blog", "follow", "entry", "f", "fr", "rule", "route", "str", "URL", "www", "job", "element", "plugin", "i", "source", "api", "article", "config", "client", "l", "web", "base", "user", "r", "object", "position", "address", "id", "account", "gl", "file", "obj", "c", "service", "sl", "host", "bug", "location", "Url", "http", "feed"], "connection": ["page", "proxy", "uri", "unit", "resource", "server", "communication", "b", "loc", "io", "link", "session", "socket", "ie", "bc", "channel", "Connection", "application", "connect", "coll", "ci", "conn", "connected", "i", "client", "l", "position", "which", "character", "con", "c", "handler", "cf", "context", "response", "condition", "or", "lc", "wrapper", "http", "open", "database"], "is": ["ins", "gets", "isl", "isi", "os", "lis", "il", "io", "info", "mis", "iso", "in", "es", "bis", "IS", "us", "isc", "ci", "fs", "s", "iris", "ios", "i", "api", "im", "ip", "ib", "ils", "iss", "ais", "ir", "ris", "Is", "ops", "ai", "ii", "ui", "as", "isa", "was", "cs", "abs", "bs", "its", "isu", "serv"]}}
{"id1": "14764852", "id2": "14785308", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"doRequest": ["DoResponse", "DoRequest", "runQuery", "DoOperation", " doOperation", "DoQuery", "doResponse", " doQuery", "runOperation", " doResponse", "runResponse", "doQuery", "runRequest", "doOperation"], "method": ["METHOD", "text", "subject", "crit", "url", "uri", "ssl", "resource", "message", "module", "view", "connection", "version", "project", "session", "port", "mode", "route", "cl", "attr", "Method", "type", "process", "class", "source", "record", "header", "client", "stream", "sign", "transform", "tr", "object", "name", "host", "path", "content", "format", "head", "http", "request"], "headers": ["workers", "fields", "values", "keys", "breakers", "users", "ppers", "options", "parts", "relations", "agents", "ters", "groups", "parents", "features", "lines", "caps", "settings", "docs", "drivers", "properties", "header", "heads", "vals", "strings", "qs", "files", "resources", "frames", "names", "codes", "params", "ers", "checks", "blocks", "writers", "words", "tails", "types", "authors", "limits", "members", "boxes", "head"], "auth": ["art", "att", "arch", "ssl", "parent", "authent", "act", "lock", "acl", "info", "enc", "port", "stat", "password", "cb", "type", "home", "conn", "pass", "Auth", "aut", "api", "header", "config", "oct", "user", "token", "ac", "guard", "uth", "upload", "anon", "host", "ant", "auto", "author", "secure", "head", "http", "block"], "target": ["proxy", "subject", "url", "uri", "resource", "server", "parent", "connection", "remote", "port", "external", "result", "route", "reply", "template", "href", "source", "client", "ARGET", "Target", "base", "object", "address", "arget", "root", "host", "next", "context", "location", "path", "response", "current", "manager", "request", "owner"], "body": ["secret", "proxy", "text", " Body", "ODY", "log", "url", "message", "resource", "one", "plain", "b", "view", "connection", "reason", "lock", " message", "data", " object", "port", "part", "output", "reply", "storage", "h", "code", " data", "pass", "comment", " payload", "source", "config", "header", "media", "stream", "db", "object", "load", "file", "params", "other", "ob", " bodies", "binary", "full", "response", " response", "odies", "content", "buffer", " content", "query", "block", "Body"], "con": ["conv", "cons", "fn", "un", "crit", "ct", "cn", "col", "uc", "conf", "cp", "connection", "en", "rc", "CON", "Con", "an", "cos", "cond", "ain", "connect", "fa", "ran", "mc", "ch", "cl", "cas", "cur", "conn", "cat", "cm", "client", "co", "can", "ann", "xc", "ac", "exec", "c", "pc", "dc", "fc", "fac", "cf", "clean", "ca", "dom", "enc", "cr", "request", "ocon"], "res": ["cons", "resp", "req", "js", "des", "arr", "details", "rel", "ps", "rs", "os", "data", "parts", "result", "es", "RES", "vs", "pres", "val", "out", "s", "results", "vals", "qs", "r", "err", "obj", "params", "resolution", "re", "Res", "ret", "response", "content", "cs", "pers", "bs", "rep"]}}
{"id1": "16378239", "id2": "16142024", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["Byref", "ofReference", "orref", "orLink", "toLink", "ofExternal", "ofLink", "ByExternal", "toReference", "toExternal", "ByReference", "ByLink", "orReference", "toref", "ofref", "orExternal"], "inputStream": ["outputStream", "inputSteam", "inSteam", "InputFile", "outputString", "InputString", "outputstream", "tempReader", "inputFile", "inReader", "inStream", " inputString", " inputObject", "instream", "inputObject", "inputReader", "outputFile", "Inputstream", "tempStream", "InputObject", "InputReader", "outputObject", "outputSteam", "InputSteam", "tempSteam", "inputstream", "inputString", "tempstream", " inputstream", "InputStream"], "tempFile": [" tempDir", "fakePage", "TempContent", "tmpfile", "tmpContent", "fakeDir", " tempFiles", "tmpFiles", "TempFiles", "fakeFiles", "tempFiles", "tempPage", "fakeStream", " tempContent", "Tempfile", "tempF", "tmpStream", "tempStream", "tempContent", "fakeFile", "fakeF", "tempfile", "tmpF", " tempfile", "tmpPage", "tempDir", " tempPage", "fakefile", " tempStream", "tmpDir", " tempF", "TempFile", "tmpFile"], "out": ["to", "ex", "array", "writer", "url", "resource", "write", "server", "plain", "copy", "null", "image", "connection", "init", "io", "outer", "data", "this", "later", "sync", "part", "output", "in", "f", "result", "o", "Out", " in", "conn", "temp", "instance", "source", "flush", "client", "a", "base", "outs", "user", "object", "exec", "file", "obj", "err", "extra", "OUT", "path", "pool", "again", "line", "ext"]}}
{"id1": "4223002", "id2": "21152728", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getpasswordSHA1", "getPasswordMD1", "getpasswordMD512", "getPasswordMD256", "getPasswordMAC256", "getPasswordMAC5", "getpasswordMD1", "getPasswordMac256", "getPasswordMac1", "getPasswordSHA5", "getPasswordSHA512", "getPasswordMAC1", "getpasswordMD256", "getPasswordMAC512", "getPasswordMac5", "getPasswordMac512", "getpasswordMD5", "getPasswordSHA256", "getpasswordSHA5", "getpasswordSHA512", "getpasswordSHA256", "getPasswordMD512", "getPasswordSHA1"], "algorithm": ["aggorithm", "geest", "gem", " alm", "alrator", "algo", "Alignment", " alger", " alignment", " algo", " alrator", "alest", "alger", "calgorith", "Alm", "calgo", "Alrator", "calgebra", "algebra", "Alest", " alest", "gegorithm", "Alphabet", "Algorith", "alphabet", "agrator", "Alger", "Algorithm", "fgo", "fgebra", "omalgorith", "omalgo", "aggo", "alignment", "calgorithm", "omalgorithm", "algorith", "geger", "Algo", "agignment", "omalphabet", "alm", " algorith", " alphabet", "fgorithm", "fgorith", "Algebra"], "messageDigest": ["messageModester", "MessageDigEST", "MessageDigest", "phrasedigester", "phrasedigest", "phraseDigEST", "messageMDester", "messageDigested", "messageModEST", "messagedigest", " messagedigEST", " messagedigString", "messageMDest", "messageDest", "messagedigester", "messagedigString", "messageDEST", " messageDigString", "messageMDString", "messagedigested", " messageDigester", "messageModest", "messageDigString", "MessageModester", "messageModested", "phraseDigester", "MessageModest", " messageDigEST", "messageModString", "messagedigEST", "MessageModested", "messageDested", " messagedigest", "phraseDigest", "phrasedigested", "phraseDigested", " messagedigester", "MessageDigester", "phrasedigEST", "messageDigEST", "MessageDigested", "messageDester", "MessageModEST", "messageMDEST", "messageDigester"], "hexString": [" hexFunction", "hexLine", "textStream", "hashStr", " hexstring", "hexBuffer", "textString", "textstring", "hexstring", "byteLine", " hexStr", "shortArray", "textLine", "shortString", "hexArray", "hexStr", "hashString", "checkFunction", "hexStream", " hexArray", "shortstring", "textArray", "shortBuffer", "byteStream", "hashBuffer", "hexFunction", "checkStr", " hexStream", "byteString", "checkString", "checkBuffer", "textBuffer", "hashFunction", " hexBuffer", " hexLine", "byteArray"], "i": ["m", "u", "uri", "e", "j", "b", "volume", "n", "fi", "io", "info", "ix", "si", "in", "f", "o", "index", "d", "end", "key", "h", "type", "s", "ci", "oi", "abi", "multi", "li", "a", "l", "di", "hi", "pi", "xi", "mi", "slice", "r", "id", "ti", "v", "gi", "c", "t", "ri", "I", "ai", "phi", "zi", "ii", "ui", "x", "bi", "chi", "mu", "p"]}}
{"id1": "6988216", "id2": "11673907", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runRawQuery", " runSimpleFilter", "runRawFilter", "runSimpleQuery", "runRawSearch", " runBasicFilter", "runSimpleConnect", " runClientSearch", " runBasicConnect", "runRawQuery", " runClientConnect", "runRawConnect", " runSimpleConnect", " runSimpleSearch", " runRawFilter", " runBasicSearch", " runRawSearch", " runSimpleQuery", "runSimpleSearch", "runSimpleFilter", " runClientFilter", " runBasicQuery", " runClientQuery", " runRawConnect"], "dummySource": ["puddyClient", "pummySourceFile", "dundleConfig", "dummySite", "puddySource", "puddyContent", "dummySourceFile", "dumbSource", "duddySource", "dellyContent", "daddyType", "dummyClient", "pummyContent", "pummyType", " dumbContent", "pummyClient", "duddyType", "dellyType", "puddySourceFile", " dumbOrigin", "duddySourceFile", "pummySite", "dummyType", "dundleSource", "pummyService", " dummyOrigin", "dumbOrigin", "daddySite", "daddySource", "daddyContent", "dandySource", "dellySource", "duddyContent", " dumbSource", "daddyService", " dummyConfig", "duddySite", " dumbConfig", "dummyOrigin", "daddySourceFile", "dumbConfig", "puddySite", "dandySite", "dandySourceFile", "dumbContent", "puddyService", "dandyClient", "duddyConfig", "daddyClient", "dellyService", "puddyType", "duddyClient", "duddyOrigin", "dundleContent", "dundleOrigin", "pummySource", "dummyService", "dummyConfig", "duddyService"], "os": ["css", "ls", "ros", "oa", "dos", "nos", "ss", "ok", "acs", "obs", "io", "ori", "ns", "ps", "sys", "osi", "iso", "oss", "aos", "cos", "pos", "ose", "es", "ows", "o", "bos", "vs", "us", "ox", "uns", "oses", "ms", "fs", "out", "ols", "ens", "s", "oS", "ios", "i", "is", "conn", "Os", "oos", "object", "oc", "mos", "los", "ops", "ou", "op", "ol", "as", "or", "om", "bs", "ks", "OS", "ds"], "dummyContent": ["dummycontent", "duckySource", "DummySource", "dumperContents", "dellyContent", "DummyReader", "dumpercontent", "dumperOutput", "duddySource", " dummyContents", " dellyOutput", " dummyOutput", "DuckySource", "DuckyReader", "dumpingContents", "dummyContents", " dummycontent", "dummyOutput", "dellycontent", "dumpingContent", "duddyReader", "dumperSource", "duckyBody", "duddyContent", "duckyReader", " dellyContent", " dellycontent", "DummyContent", "dumperBody", "duckyContent", "dellyContents", "dumpingOutput", "DummyBody", "duddyBody", "dellyOutput", "dummyBody", "dumperReader", " dellyContents", "dumperContent", "dummyReader", "dumpingcontent", "DuckyBody", "DuckyContent"], "source": ["proxy", "text", "url", "uri", " Source", "resource", "e", "core", "unit", "parent", "scope", "ser", "connection", "info", "sync", "cos", "search", "channel", "Source", "result", "site", "sn", "storage", "ources", "s", "element", "i", "class", "sin", "src", "reader", " sources", "config", "size", "stream", "target", "seed", "slave", "client", "resources", "node", "object", "sc", "cache", "string", "ource", "service", "sl", "SOURCE", "host", "secure", "use"], "content": ["css", "activity", "sol", "text", "description", "url", "news", "resource", "image", "report", "message", "html", "server", "body", "music", "data", "version", "child", "title", "cos", "output", "model", "document", "result", "input", "comments", "Content", "children", "code", "xml", "comment", "config", "cms", "size", "media", "header", "expression", "target", "transform", "address", "match", "load", "service", "host", "cover", "clean", "response", "cont", "current", "value", "update", "feed"], "qResult": ["iqResults", "kResult", " qResults", "qFilter", "queryReturn", "iqResult", "rresult", "qResponse", "kFilter", "QResult", " qResponse", "queryresult", "queryResponse", "QFilter", "qReturn", "kReturn", "kResults", "kRes", "qRes", "queryResults", "QReturn", "iqResponse", "kresult", "qresult", "kSource", "querySource", "iqresult", "QResults", " qresult", "queryResult", "queryRes", "queryFilter", "qSource", "rResult", "qResults", "rSource", "rRes"], "results": ["values", "res", "ions", "ins", "rows", "details", "users", "successful", "data", "shows", "RESULTS", "reports", "result", "groups", "features", "lines", "children", "s", "docs", "objects", "ries", "qs", "pages", "resources", "ids", "files", "versions", "models", "errors", "tests", "blocks", "response", "events", "members", "Results", "collection", "items", "its", "runs", "vers"], "it": ["ort", " It", "ins", "ait", "It", "IT", "init", "iti", "ited", "info", "ITS", "si", "you", "not", "in", "ati", "entry", "split", "itted", "stat", "and", "ci", "the", "i", "iter", "mit", "l", "edit", "ip", "lit", "slice", "r", "pit", "id", "sit", "which", "v", "ic", "list", "t", "op", "ite", "or", "its", "p", "rit"], "rSrc": ["rPssrc", "rPsrc", " rDssrc", "RSource", "RIsrc", "rPsource", "rIsrec", " rSource", "rEsRC", "rDsRC", "rPsRC", "rSRC", "RSrc", " rEsrc", "rSrec", "rEssrc", " rDsRC", " rSsrc", "rSsrc", "rAsrec", " rEssrc", "rAsource", "rIsource", "rEsrc", "rEsource", "RSrec", " rEsource", " rDsrc", " rDsource", "rAsRC", " rEsRC", "rDssrc", "RSRC", "rAssrc", "RIsRC", "rIsRC", "RIsource", "rSource", "rDsrc", "RIsrec", " rSRC", "rDsource", "rIsrc", "rAsrc"], "rSrcIn": ["rAsrcin", "rSourceIn", "rSRCin", "rCrcin", "rAsrcOut", "rSsrcOut", "rCsrcOut", "rSvcIn", "rSRCOut", "rCsrcIn", "rCrcIns", "rSrcOut", "rSourceOut", "rCRCIns", "rSrcin", "rSvcOut", "rCRCIn", "rCrcIn", "rSrcIns", "rSrcIN", "rAsRCIn", "rSourceIns", "rCsrcin", "rSsrcIN", "rCRCOut", "rCrcOut", "rCrcIN", "rSRCIn", "rAsRCOut", "rSourcein", "rSRCIns", "rSsrcin", "rCsrcIN", "rAsRCin", "rSvcin", "rSRCIN", "rSvcIN", "rAsrcIn", "rSvcIns", "rSsrcIn"], "actualOut": [" actualWin", " actualOUT", "actualout", "publicOUT", "nexpectedOut", " ActualIn", "actualIn", "operatorOUT", "illegalOutput", "nexpectedWin", " ActualOut", "operatorIn", " actualOutput", "realout", "publicOutput", "illegalOut", "nexpectedIn", "assertBridge", " ActualOUT", "eventout", " ActualBridge", "realIn", "actualBridge", "publicOut", "nexpectedout", "actualWin", "publicIn", "operatorout", "eventOUT", "illegalOUT", "actualOUT", "eventOut", "assertOut", "actualOutput", "realWin", "assertIn", "illegalIn", "operatorOut", "realOut", "assertOUT", " actualout", " actualIn", " actualBridge", "eventIn"]}}
{"id1": "8047989", "id2": "19134229", "code1": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getHashedID": ["getHachedID", "getHashIP", "getHashingUID", "getHashUID", "getShashUID", "getShashedUID", "getHashingID", "getHachedIP", "getShashedIP", "getHashedIP", "getHashedUID", "getHashingId", "getHachedUID", "getHashingIP", "getHashID", "getShashIP", "getHashedId", "getShashedID", "getShashID", "getShashedId", "getHashId", "getShashId", "getHachedId"], "ID": ["DATA", "RI", "NAME", "prefix", "STR", "MAC", "ENT", "AD", "API", "IR", "ED", "INT", "DB", "EXT", "IP", "GET", "IDS", "hash", "Code", "URL", "Id", "IN", "INFO", "Address", "code", "JSON", "Name", "MD", "Path", "SHA", "TEXT", "id", "UID", "string", "URI", "name", "Hash", "IDs", "VERSION", "KEY"], "md5": ["id2", "MD8", "id512", " md8", "cmd25", "id5", "sha512", "sha25", "sha2", "cmd5", "MD512", " md512", " md7", "sha5", " md25", "MD5", " md2", "md7", "md2", "md4", "MD7", "id8", "md25", "md8", "cmd7", "sha7", "MD4", "MD2", " md4", "cmd512", "sha4", "md512"], "digest": ["mdester", "mdse", "longHash", "longse", "Digace", "Digester", "Digest", " digpe", "mdested", "signace", "signest", "codpe", "DigHash", " digests", "codest", "signested", "mdace", "digse", "Digested", "digester", "signester", "Digests", "digests", "codse", "digpe", "mdHash", "digested", "Digse", "mdest", "longests", "Digpe", "digHash", "digace", " digse", "longest", "mdests", "codests"], "bytes": ["ls", "values", "maps", "proxy", "keys", "rows", "Bytes", "details", "body", "letters", "ps", "data", "parts", "ones", "es", "bs", "zip", "vs", "classes", "devices", "lines", "ips", "out", "seconds", "objects", "results", "is", "tes", "pieces", "files", "units", "pages", "ids", "outs", "bits", "base", "address", "id", "string", "errors", "codes", "cells", "binary", "blocks", "words", "content", "services", "strings", "items", "its", "bb", "issues"], "i": ["k", "m", "u", "z", "uri", "e", "j", "b", "n", "fi", "io", "info", "si", "in", "field", "pos", "f", "it", "o", "index", "d", "end", "h", "type", "val", "s", "oi", "ci", "abi", "multi", "li", "l", "di", "hi", "pi", "inner", "xi", "slice", "r", "id", "uli", "ti", "v", "gi", "c", "t", "ri", "I", "ai", "phi", "ii", "ui", "x", "bi", "mu", "qi", "p"]}}
{"id1": "14819747", "id2": "9319440", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 0, "substitutes": {"debug": ["enabled", "doc", "log", "DEBUG", "console", "play", "module", "details", "build", "remote", " debugger", " debugging", "tag", " DEBUG", "depth", "store", "die", "reg", "display", "enable", "status", "error", "dev", "date", "test", "plugin", "progress", "trace", "comment", "config", " Debug", "print", "develop", "github", "dump", "Debug", "db", "ger", "quiet", "export", "cache", "show", "file", "err", "development", "admin", "help", "root", "bug", "production", "real", "active"], "prologFile": ["PrologModule", " problogFull", "Prologfile", " prologfile", "deflogSourceFile", "prologPath", " proLogHeader", "prolexModule", "defLogFILE", "problogDir", " proLogFiles", "problogFull", "proconfigFile", "procatFile", "prologSource", "ProLogString", "prolangSourceFile", "proLogFILE", "problogHeader", "proLogfile", "rologPath", "roLogPath", " problogfile", "ProLogModule", "prolangfile", "procatPath", "prollPath", "prollFile", "proLogFiles", "propathFile", "prologHeader", "procatfile", "rologfile", "problogfile", "deflogFILE", "defblogFile", "problogStream", "probaseFiles", "prologSourceFile", "PrologFile", "proconfigModule", "proLogHeader", "rologFile", "rologSource", "prologFull", "proLogFull", "proLogStream", "procatSource", "prolexfile", "prollfile", " problogFile", "proLogSource", "probaseFile", "prologDir", " proLogFile", "proconfigString", "defLogPath", "proLogFile", "defblogDir", "proflowSourceFile", "prolexString", " proLogStream", "propathfile", "deflogDir", " prologSourceFile", "defblogfile", "roLogFile", "probaseStream", "prolangFile", " prologFiles", "deflogPath", "prologStream", "prolexFile", "proLogModule", "proversionPath", "propathDir", "problogFile", " prologStream", "prologModule", "proflowDir", " prologHeader", " problogSourceFile", "ProLogFile", "proflowfile", "proconfigPath", "prologString", "ProLogfile", " prologFull", "proversionSourceFile", "proconfigSourceFile", "problogSourceFile", "problogFiles", "probaseHeader", "proversionFILE", "prollSource", "prologFILE", "proversionFile", "prolangFull", "proLogString", "defLogSourceFile", "defblogSourceFile", "roLogfile", "proconfigfile", "proLogSourceFile", "proLogPath", "deflogfile", "deflogFile", "propathSourceFile", "prologFiles", "proflowFile", "PrologString", "prologfile", "proconfigFILE", "defLogFile", "roLogSource"], "targetFile": [" targetDirectory", "Targetfile", "targetDir", "targetPath", "sourceDirectory", " targetFiles", " targetfile", "TargetFile", "targetFiles", "outputFile", "sourceFile", "TargetDir", "sourcefile", "TargetPath", "outputPath", "TargetDirectory", "targetfile", "TargetFiles", "targetDirectory", "outputDir", "sourceFiles", "sourcePath", "sourceDir", "outputfile"], "source": ["proxy", "text", "description", "uri", "unit", "resource", "message", "style", "scope", "view", "term", "body", "data", "options", "session", "model", "Source", "result", "input", "str", "zip", "stack", "template", "type", "i", "class", "comment", "src", "config", "parse", "target", "slice", "position", "id", "language", "string", "ource", "file", "name", "service", "sl", "SOURCE", "json", "content", "buffer", "format", "use"], "myParser": [" myReader", "MyProgram", "yourProgram", "yourReader", "yourParser", "yourJar", " myJar", "MyJar", "myReader", "myJar", "MyReader", "MyParser"], "myProgram": ["Myprogram", "MYprogram", "MyPlan", "yourprogram", "MYProgram", "yourMath", " myprogram", "theMath", "yourParser", "theParser", "MYParser", "yourPlan", "myprogram", "theProgram", "myMath", "yourProgram", "MyProgram", "myPlan", "theprogram", " myPlan", " myMath", "MyParser"], "myVisitor": ["myAuditors", "myVisitable", "myVisititable", "myVisulator", "myVisiter", " myVisitable", "mySignitor", "myvisit", "myAuditable", "myVISIT", "MyVisitor", " myVisIT", "MyVisiter", "mySigniter", "myExitor", "myvisIT", "Myvisitors", "myVisitit", "mySignulator", "myvisitable", "myVISitor", " myvisitable", "MyVisulator", "myExitors", " myvisit", " myvisitor", " myvisitors", "myVisititor", "myVISitable", "myAudit", " myVisitors", "Myvisulator", "MyVisitors", "myExulator", "myVisititors", "myDesignitable", "myDesignIT", "myVISit", "myvisulator", "myExiter", "mySignitors", "myVisit", "Myvisiter", "myDesignitor", "myDesignit", " myVisit", "Myvisitor", "myvisitors", "myVisIT", "myvisitor", " myvisIT", "myvisiter", "myAuditor", "myVisitors"], "adapterLayer": ["adptionFactory", "adaptersLayer", "acapterBuffer", "adviceLanguage", "adptionBuffer", "admissionLayer", "admissionContainer", "adapterContainer", "acaptersContainer", "adaptersBuffer", "adviceInfo", "acapterInfo", "admissionLanguage", "acapterLayer", "acapterLanguage", "adapterInfo", "adviceLayer", "adapterBuffer", "adviceBuffer", "acaptersInfo", "adaptersInfo", "adapterFactory", "adaptersLanguage", "adviceContainer", "acaptersLanguage", "acaptersBuffer", "adptionLayer", "adptionInfo", "adviceFactory", "acaptersFactory", "adaptersContainer", "adaptersFactory", "acapterFactory", "acapterContainer", "acaptersLayer", "adapterLanguage"], "classLoader": ["ClassLoader", "classPath", "staticLoader", "classDir", "staticloader", "ClassPath", " classPath", "staticDir", "Classloader", "classloader", " classDir", "ClassDir", " classloader", "staticPath"], "adapterWriter": ["admissionWriter", "attaptersWrite", "admissionWrite", "adaptersWrite", "adaptersWriter", "attaptersReader", "adAdapterWrite", "adAdapterwriter", "attapterReader", "admissionReader", "admissionwriter", "adapterswriter", "attapterWriter", "attapterwriter", "adapterReader", "adAdapterWriter", "attapterWrite", "adapterwriter", "adapterWrite", "attapterswriter", "adAdapterReader", "adaptersReader", "attaptersWriter"], "annotationGenerator": ["annotationgencer", "annnotationGenator", "annotationGator", "annotationGenerators", "annotationGcer", "annnotationGenercer", "annnotationGenators", "annnotationGenerator", "annotationGencer", "annnotationGenerators", "annnotationGeneroder", "annnotationGencer", "annotationgenators", "annnotationGenoder", "annotationgenator", "annotationGators", "annotationGoder", "annotationGenator", "annotationGenators", "annotationgenoder", "annotationGenercer", "annotationGenoder", "annotationGeneroder"], "out": ["prefix", "page", "gen", "log", "array", "flow", "server", "parent", "copy", "n", "cmd", "lock", "io", "outer", "store", "sys", "sync", "raw", "output", "in", "group", "Out", "error", "conn", "code", "temp", "print", "cli", "dump", "point", "outs", "user", "bar", "cache", "v", "err", "obj", "list", "up", "net", "pre", "OUT", "down", "diff", "query", "state", "chain", "again", "line", "post"]}}
