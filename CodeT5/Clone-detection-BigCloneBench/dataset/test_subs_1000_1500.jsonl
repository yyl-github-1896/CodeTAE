{"id1": "1362", "id2": "6988216", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["ubblingOrder", "bubblerOrder", "bubblersort", "bubblingsort", "bubblesort", "ubblesort", "ubbleCompare", "bubblessort", "bubblerCompare", "bubblingOrder", "bubblesSort", "ubbleSort", "bubblingSort", "bubblerSort", "ubblingsort", "bubbleCompare", "ubblingSort", "bubblesOrder", "ubblingCompare", "bubblingCompare", "bubblesCompare", "ubbleOrder", "bubbleOrder"], "a": ["p", "work", "access", "as", "apps", "ab", "result", "another", "empty", "c", "ac", "f", "ba", "all", "s", "at", "e", "ama", "va", "area", "l", "aj", "ans", "an", "data", "aa", "m", "aux", "ad", "oa", "img", "ata", "sa", "ga", "sup", "aw", "tta", "array", "b", "u", "A", "something", "address", "na", "index", "ack", "list", "alpha", "ae", "am", "auto", "abs", "au", "ma", "any", "aaa", "o", "d", "la", "active"], "swapped": [" swaped", "Swaped", "floped", "swapping", " swap", "flap", " swaps", "rewap", "rewapped", "wapping", "rewoped", "swap", "Swap", "Swapped", "wap", "waped", "Swapping", "rewapping", "swoped", "waps", "wapped", "Swoped", " swapping", "flapping", "flapped", "swaps", "swaped", "rewaps", "rewaped"], "i": ["p", "x", "uni", "init", "uri", "ni", "f", "ai", "info", "ii", "gi", "ori", "ix", "e", "d", "ie", "l", "I", "k", "ci", "ind", "m", "ini", "in", "module", "ami", "multi", "ip", "iu", "bi", "io", "si", "next", "sup", "u", "b", "it", "iv", "mini", "ui", "pi", "oi", "api", "li", "index", "j", "h", "ki", "hi", "mi", "di", "qi", "anti", "eni", "y", "xi", "fi", "key", "id", "adi", "v", "start", "ri", "ti"], "tmp": ["p", "x", "pre", "stuff", "mmm", "mp", "opp", "st", "yy", "emp", "f", "bb", "vt", "front", "tc", "pad", "txt", "ie", "area", "angle", "qq", "addr", "amp", "m", "kk", "tv", "prev", "tt", "dest", "foo", "sup", " ff", "b", "obj", "nb", "append", "j", "alpha", "test", "temp", "part", "t", "pp", "xxx", "v", "cmp"]}}
{"id1": "822452", "id2": "4118412", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "6421904", "id2": "15768167", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"addRecord": ["addrecord", " addFile", "createrecord", "createRecord", "appendRec", " addrecord", "addRec", "addFile", "appendRecord", " addRec", "appendrecord", "appendFile", "createFile", "createRec"], "input": ["flow", "text", "source", "form", "buffer", "media", "current", "out", "session", "instance", "load", "config", "this", "back", "http", "Input", "conn", "image", "data", "resource", "storage", "progress", "up", "document", "error", "inf", "null", "exec", "hole", "stream", "raw", "php", "value", "temp", "request", "reader", "xml", "audio", "context", "active"], "temporary": ["timermanent", "tomperature", "destemporary", "transporal", "theporal", "transporary", "theperature", "theemporary", "tempperature", "tomporal", "tmacher", "temmanent", "destporal", "exporary", "typoral", "timperature", "temermanent", "formporal", "mporary", "tememporary", "temolute", "Temmanent", "formmanent", "tmporary", "tempporal", "timporary", "separporary", "timemporary", "thetemp", "mporal", "tacher", "temporal", "tmermanent", "semporal", "theporary", "separporal", "mperature", "emporal", "Temporary", "tmporal", "Temtemp", "tporal", "formtemp", "emporary", "experature", "destporary", "Temperature", "tommanent", "temperature", "timporal", "tomporary", "theermanent", "tytemp", "semmanent", "tmemporary", "temacher", "exolute", "semperature", "transperature", "Temporal", "tymanent", "temptemp", "semporary", "tmperature", "tempporary", "temtemp", "separmanent", "transolute", "typerature", "tporary", "exporal", "tempemporary", "destacher", "tmtemp", "typorary", "formporary", "emperature", "separperature", "timolute"], "tempId": ["Tempid", "inputID", "tmpID", "tempid", "fakeId", " tempid", "tmpPath", "tempID", "TempID", "inputid", "fakeName", " tempName", "tmpid", "inputPath", "TempPath", "fakeid", "poraryId", "TempId", "inputId", "TempName", "poraryid", "tempPath", "tempName", "tmpId"], "length": ["sequence", "text", "style", "filename", "position", "shape", "result", "json", "Length", "path", "load", "download", "len", "driver", "l", "angle", "count", "read", "loc", "data", "duration", "total", "open", "description", "limit", "url", "name", "width", "array", "ext", "capacity", "code", "number", "time", "string", "size", "lock", "range", "write", "full", "distance", "value", "version", "key", "slice", "ob", "id", "type", "section", "audio", "offset", "library", "content", "volume"], "digest": ["fests", "digraph", "Digist", "fest", "Digester", "DigEST", " digraph", "digEST", "digested", " digests", " Digest", "decest", "digist", " Digester", "signested", "generest", "signEST", "decist", "digests", " digEST", "generested", "signester", "Digest", "generEST", "signests", "fraph", " digested", "Digested", "digester", "signraph", " digester", "signest", " DigEST", "fester", "generist", "decEST", "decested"], "output": ["source", "message", "cut", "result", "copy", "out", "config", "control", "console", "socket", "image", "data", "writer", "web", "object", "resource", "other", "binary", "export", "document", "log", "null", "outer", "operation", "letter", "address", "connection", "external", "channel", "plain", "queue", "exit", "write", "Output", "tube", "put", "temp", "office", "response", "unit", "target", "application"], "file": ["work", "source", "message", "buffer", "File", "current", "cache", "ile", "image", "comment", "directory", "url", "base", "log", "name", "pe", "null", "picture", "pool", "code", "zip", "time", "rule", "queue", "let", "temp", "feed", "dir", "type", "http", "uri", "home", "this", "model", "use", "view", "show", "word", "po", "or", "data", "object", "other", "binary", "play", "force", "self", "up", "entity", "live", "future", "auto", "lib", "id", "unit", "user", "plain", "style", "path", "place", "e", "socket", "single", "line", "folder", "resource", "FILE", "document", "string", "php", "get", "p", "local", "create", "filename", "fp", "f", "page", "per", "real", "l", "complete", "open", "class", "it", "server", "fe", "function", "child", "letter", "connection", "lock", "handler", "full"], "parent": ["p", "source", "create", " Parent", "remote", "copy", "cache", "current", "large", "out", "port", "path", "home", "master", "per", "root", "to", "image", "or", "data", "parents", "resource", "location", "pa", "directory", "and", "class", "base", "name", "null", "child", "container", "handler", "full", "block", "Parent", "temp", "part", "key", "dir", "id", "unit", "fat", "type"], "now": ["since", "last", "cmp", "today", "current", "set", "Now", "first", "day", "load", "date", "info", "this", "not", "night", "view", "lim", "max", "ci", "or", "once", "hour", "from", "age", "currently", "cycle", "next", "low", "gen", "post", " NOW", "time", "cur", "size", "comp", "auto", "always", "wait", "NOW", "id", "ct", "ow", "type", "start", "node", "co", "active"]}}
{"id1": "1421557", "id2": "536614", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToFiles", "encodeStringToFile", "encodeFileFromString", "encodeFileToStream", "encodeFileToString", "encodeFileFromStream", "encodeString2String", "encodeFile2File", "encodeFile2String", "encodeFiletoFiles", "encodeStringToStream", "encodeFileToFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeString2Stream", "encodeFile2Stream", "encodeFile2Files", "encodeFiletoFile", "encodeStringToString", "encodeFiletoString", "encodeString2File", "encodeFileFromFiles", "encodeString2Files"], "infile": ["infp", "outFile", "inputFile", "infiles", "InFile", "outfiles", "outfilename", "inputfile", " infilename", "inputfilename", "inFile", "inputfiles", "Infilename", "outfp", "inputfp", "Infiles", "Infile", "infilename", " infiles", " infp"], "outfile": ["infp", "outFile", "newname", "Outfile", " outfp", "outname", "newfile", " outfilename", " outfolder", "outputfp", "Outfolder", " outFile", "Outname", "infolder", "outputfolder", "outfolder", "outfilename", "outputfile", " outname", "outputfilename", "OutFile", "newFile", "newfolder", "outfp", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "image", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "base", "b", "vin", "is", "nin", "min", "ins", "cin", "thin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "source", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "on", "io", "up", "job", "base", "name", "ou", "outer", "exec", "post", "obj", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "fb", "buf", "len", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "input", "count", "sleep", "ind", "close", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", "modified", " succ", "true", "rolling", "respons", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "17791385", "id2": "21488868", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "src": ["ls", "source", "filename", "sb", "uri", "st", "config", "s", "back", "txt", "input", "image", "sin", "inst", "loc", "resource", "img", "dest", "sup", "url", "inf", "b", "files", "obj", "sit", "sel", "sl", "sc", "dist", "rc", "rb", "ins", "upload", "stream", "file", "ipl", "http"], "dst": ["ddft", "fdfd", " dsts", "ddfd", "pdfd", " ddest", "pdsp", "Dst", "fdsp", "dsts", "dsp", "Dsts", "ddest", "Ddest", "stlt", "pdst", "pdft", "stdest", "fdst", "ddsp", "fdft", " dlt", "ststs", "ddst", "dlt", "dft", "Dlt", "stst", "dfd"], "in": ["as", "init", "ln", "gin", "inn", "pin", "inner", "f", "i", "input", "inside", "conn", "sin", "socket", "IN", "data", "m", "ini", "win", "con", "n", "url", "din", "is", "nin", "ins", "h", "cin", "lin", "In", "impl", "inc", "again", "rin", "kin", "file", "pull", "r", "err", "login", "oin", "id", "reader", "bin"], "out": ["x", "copy", "cache", "output", "sync", "client", "net", "at", "f", "s", "w", "ex", "i", "conn", "OUT", "line", "writer", "other", "self", "up", "io", "n", "bin", "null", "outer", "ext", "server", "exec", "post", "obj", "exp", "Out", "raw", "outs", "again", "off", "file", "temp", "parent", "part", "err", "o", "plain", "inc"], "buf": ["bh", "buffer", "uf", "seq", "uc", "length", "br", "bag", "c", "cat", "pad", "buff", "fb", "bb", "bytes", "cmd", "lim", "bl", "count", "ff", "val", "loc", "data", "bf", "bc", "base", "b", "fd", "fl", "rc", "rb", "cur", "queue", "raw", "batch", "off", "vec", "cap", "wb", "ctx", "v", "bin", "cb", "bd"], "len": ["lf", "ln", "length", "c", "f", "all", "lt", "ix", "nt", "i", "lim", "l", "pos", "count", "line", "val", "ind", "data", "n", "base", "name", "lc", "fd", "fin", "fl", "split", "sl", "li", "size", "cl", "el", "ll", "lin", "en", "Len", "cap", "part", "err", "end", "le", "rev", "bin", "no"]}}
{"id1": "21224967", "id2": "17202158", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "label": 0, "substitutes": {"crear": [" crea", " Creas", "generar", " Crear", "genera", "Creare", "Creas", "Crear", " creare", " Crea", " creas", " Creare", "generare", "Crea", "generas"], "result": ["match", "message", "ret", "out", "length", "feature", "mark", "ver", "date", "status", "event", "page", "success", "count", "cash", "default", "found", "record", "comment", "force", "up", "valid", "limit", "currency", "die", "counter", "number", "function", "grade", "res", "db", "Result", "score", "ure", "value", "df", "err", "response", "results", "sign", "diff", "entry", "rate", "type", "user", "error", "order"], "sql": ["fp", "sync", "session", "script", " SQL", "update", "ql", "seed", "cmd", "serv", "conn", "install", "q", "pg", "where", "dl", "comment", "statement", "up", "action", "job", "url", "base", "SQL", "log", "database", "params", "setup", "exec", "printf", "zip", "query", "sl", "string", "fn", "repl", "sq", "plan", "ssl", "join", "db", "select"], "connection": ["p", "relation", "position", "cache", "table", "client", "connected", "session", "c", "union", "config", "environment", "system", "tc", "Connection", "event", "driver", "socket", "conn", "manager", "condition", "loc", "writer", "con", "pg", "proxy", "which", "communication", "statement", "connect", "document", "error", "database", "log", "bc", "graph", "server", "function", "query", "index", "container", "cond", "lock", "engine", "BC", "collection", "Exception", "ctx", "ion", "section", "db", "context", "application"], "ps": ["p", "pre", "eps", "cs", "pt", "ss", "ups", "ppa", "ips", "po", "pse", "ds", "pos", "hs", "conn", "pps", "pg", "proxy", "PS", "vs", "gres", "cop", "pa", "ks", "pc", "os", "pe", "qs", "proc", "params", "Ps", "query", "bs", "pd", "sp", "ins", "cp", "pr", "jp", "gs", "settings", "ns", "pers", "properties", "changes", "pp", "ports", "posts", "ops"]}}
{"id1": "18731843", "id2": "20190303", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"doBody": [" doBytes", "handleFile", "handleBody", "DoResponse", "doBytes", "DoFile", "handleResponse", "doResponse", "DoBody", " doFile", "doFile", "handleBytes", "DoBytes", " doResponse"], "req": ["ref", "rx", "rec", "download", "config", "info", "this", "reg", "rr", "src", "conn", "serv", "qt", "qq", "q", "data", "resource", "proc", "requ", "spec", "obj", "query", "res", "rss", "respond", "fr", "jp", "comp", "def", "request", "r", "err", "crit", "cgi", "reader", "rh", "sem", "Request", "report", "http"], "resp": ["p", "pre", "ref", "ret", "result", "rec", "re", "cache", "download", "bb", "rr", "serv", "pos", "exc", "val", "data", "prot", "Resp", "job", "b", "proc", "Response", "obj", "rep", "res", "api", "sp", "inv", "respond", "jp", "respons", "comp", "html", "request", "part", "err", "response", "r", "rev", "cb", "cmp", "report", "reply"], "bis": ["phis", "uds", "mis", "tis", "ris", "bh", "sb", "bits", "obb", "bb", "fb", "bas", "sis", "ori", "iss", "ubis", "sin", "abi", "bian", "lis", "bid", "bps", "binary", "alis", "bi", "isin", "ses", "pins", "b", "os", "obi", "los", "usb", "is", "oris", "bs", "rots", "obos", "ais", "ios", "atis", "lins", "iris", "nis", "obs", "boot", "bin", "ois", "bes"], "bos": ["phis", "tis", "uds", "bh", "bits", "opus", "bones", "obb", "bris", "bas", "mos", "bo", "oops", "ubis", "antis", "bott", "abi", "obo", "bps", "bi", "ros", "bin", "obi", "os", "oks", "los", "oS", "zos", "oros", "bs", "zo", "fits", "obos", "las", "oos", "ios", "aos", "lol", "lins", "osa", "obs", "osi", "boot", "oses", "ois", "bes", "ops"]}}
{"id1": "17475530", "id2": "8983517", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public User getUser(String userlogin) {\n        UserDAO userDAO = new UserDAO();\n        User user = null;\n        try {\n            user = userDAO.load(userlogin);\n            if (user == null) {\n                URL url = Thread.currentThread().getContextClassLoader().getResource(\"users.cfg\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                String linea = br.readLine();\n                while (linea != null) {\n                    StringTokenizer st = new StringTokenizer(linea, \":\");\n                    if (st.countTokens() == 3) {\n                        String login = st.nextToken();\n                        String password = st.nextToken();\n                        String profile = st.nextToken();\n                        if (login.equals(userlogin)) {\n                            user = new User(login, password, profile);\n                            userDAO.save(user);\n                        }\n                    } else {\n                    }\n                    linea = br.readLine();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return user;\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinkFromImage", "testAddLinkOfPicture", "testAddLinktoImage", "testAddLinksToImage", "testAddLinkOfImage", "testAddLinkFromLink", "testAddLinkFromFile", "testAddLinkstoFile", "testAddLinkOfFile", "testAddLinktoLink", "testAddLinkstoImage", "testAddLinkstoLink", "testAddLinktoPicture", "testAddLinkToPicture", "testAddLinkOfLink", "testAddLinktoFile", "testAddLinkToFile", "testAddLinksToPicture", "testAddLinksToFile", "testAddLinkFromPicture", "testAddLinkstoPicture", "testAddLinkToLink", "testAddLinksToLink"], "in": ["work", "source", "as", "copy", "gin", "token", "out", "inn", "uri", "path", "pin", "ac", "f", "ax", "with", "at", "pass", "ex", "i", "input", "serv", "conn", "image", "socket", "or", "get", "IN", "data", "m", "ini", "win", "resource", "con", "val", "n", "isin", "bin", "url", "din", "name", "is", "exec", "nin", "min", "index", "ins", "connection", "exp", "cin", "stream", "el", "In", "again", "rin", "file", "version", "r", "err", "login", "ssl", "diff", "reader", "id", "inc", "xml", "doc"]}}
{"id1": "19912848", "id2": "6682825", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "18046717", "id2": "18782385", "code1": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 0, "substitutes": {"getFullClassName": ["getFullClassNames", "getFullclassname", "getShortclassNames", "getShortClassName", "getFullClassname", "getFullFullNames", "getFullclassName", "getFullFilename", "getFullFileNames", "getShortClassname", "getFullFullname", "getFullFileName", "getFullclassNames", "getShortClassPath", "getShortclassname", "getShortclassName", "getShortClassNames", "getFullclassPath", "getFullFilePath", "getFullClassPath", "getShortclassPath", "getFullFullName", "getFullFullPath"], "url": ["source", "org", "gl", "uri", "path", "Url", "date", "page", "l", "src", "image", "or", "loc", "loader", "service", "location", "resource", "io", "job", "base", "server", "host", "URL", "address", "sl", "connection", "string", "ur", "lr", "html", "file", "bug", "ssl", "feed", "entry", "user", "jar", "http"], "className": ["typeLine", "objectNames", "classname", "objectname", "ClassPath", "typeNumber", "shortName", "classNumber", "typeName", "classNAME", "ClassCode", "shortNumber", "sectionname", "shortname", " classType", " classNumber", " classname", "sectionName", "ClassName", "classType", "Classname", " classNames", "classPath", "sourceNAME", "sourceName", "sourceNames", "ClassType", "classLine", "sourcename", "fullPath", "fullName", "fullname", " classNAME", " classCode", "classCode", "objectNAME", "fullCode", "shortLine", "objectName", " classPath", " classLine", "classNames", "sectionType", "sectionPath", "typename"], "jis": ["Jis", " jas", "ajris", "ajists", "joris", "Ji", "jetas", "zis", " jais", "jais", "zists", "joiss", "jists", "ajis", " jiss", "zas", " ji", "jetis", "joais", "jetais", "ziss", "ajais", "jris", "ji", "jetris", "zais", "jiss", "jois", " jris", "Jiss", "zi", "ajiss", "jas", "Jais", "zris", " jists"], "zentry": ["zconnection", "gzentry", "jpart", "zerester", " zfile", "zerenter", "jentry", "jpie", " zEntry", "lester", "ezentry", "zoEntry", "zerfile", " zpart", "zenter", " zpie", "gzEntry", "ezpart", "zerentry", "lenter", "zpart", "zoenter", "lentry", "zester", "ezEntry", "zfile", "zpie", "gzconnection", " zester", "ezpie", " zenter", "gzenter", "zoentry", "zoconnection", "lfile", "jEntry", "zEntry", " zconnection"], "name": ["work", "x", "style", "filename", "str", "path", "clean", "inner", "ame", "f", "alias", "info", "s", "NAME", "home", "date", "pass", "ix", "e", "i", "word", "one", "l", "Name", "image", "none", "default", "data", "names", "in", "object", "comment", "old", "n", "up", "class", "base", "search", "code", "number", "address", "api", "string", "connection", "now", "size", "prefix", "named", "file", "value", "space", "part", "key", "entry", "id", "end", "type", "common", "start", "error", "no"], "lastPos": ["firstPart", "nextPart", " lastLen", " lastpos", "lastRes", "fullPos", "finalLen", "fullLen", "finalIndex", "lastLen", " lastRes", "firstPosition", "fullpos", "firstpos", " lastPosition", "nextPos", "lastpos", "lastPart", "nextLen", " lastPart", "nextRes", "fullPosition", "finalRes", "lastIndex", "nextpos", " lastIndex", "firstLen", "lastPosition", "firstPos", "finalPos", "nextIndex"], "pos": ["p", "x", "style", "position", "ps", "pt", "fun", "seq", "length", "push", " position", "len", "ix", "pass", "i", "pointer", "po", "Pos", "count", "none", "line", "val", "loc", "act", "eff", "nos", "pose", "limit", "os", "cos", "spec", "col", "is", "post", "index", "j", "neg", "POS", "size", "cond", "off", "part", "pro", "diff", "unit", "end", "rev", "start", "doc", "offset", "no"]}}
{"id1": "12066447", "id2": "17729554", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"truncate": ["trrenate", "trunational", "trrenator", "truncator", "trunator", "autuncator", "truncation", "autuncational", "autatenation", "autuncation", "trrenation", "truncational", "autatenational", "autuncate", "tratenate", "trrenational", "tratenational", "tratenator", "autatenator", "trunate", "tratenation", "trunation", "autatenate"], "file": ["source", "local", "filename", "File", "fp", "cache", "out", "uri", "current", "path", "f", "info", "this", "model", "page", "ile", "plus", "archive", "e", "one", "per", "l", "image", "single", "line", "or", "get", "data", "folder", "object", "resource", "format", "binary", "FILE", "directory", "io", "class", "url", "base", "log", "name", "document", "it", "files", "function", "zip", "address", "body", "time", "string", "connection", "future", "handler", "stream", "queue", "full", "type", "parent", " File", "db", "http"], "backupRoot": ["BackupPath", "backupsDirectory", "backbaseRoot", "backbackDirectory", "backupDir", "backbasePath", "frontupDir", "backupHome", "frontdownroot", "backbackRoot", "backflowDir", "backdownDirectory", "backdownFolder", "backupDirectory", "backureHome", "BackbackFile", "backUpDir", "frontdownDir", "backUpFolder", "backdownHome", "backupsroot", "BackureDirectory", "backupPath", "BackdownRoot", "backupFile", "backUproot", "BackdownDirectory", "backbackDir", "backdownRoot", "backUpRoot", "frontupFolder", "BackupDirectory", "backureDirectory", "backbackHome", "backdownroot", "backbaseroot", "backupsPath", "BackbackDir", "BackdownPath", "backbackFile", "backflowFile", "backflowRoot", "frontdownRoot", "backflowroot", "BackupHome", "BackupDir", "backupFolder", "frontupRoot", "backdownFile", "backureDir", "Backuproot", "backupsFolder", "backupsDir", "frontdownFolder", "backbaseDirectory", "BackureDir", "BackbackRoot", "backuproot", "BackupFile", "backupsRoot", "backdownDir", "backdownPath", "Backbackroot", "backureRoot", "frontuproot", "Backdownroot", "BackureHome", "BackureRoot", "backbackroot", "BackupRoot"], "df": ["flow", "DF", "md", "fp", "dict", "cf", "f", "fb", "CF", "dm", "de", "ds", "func", "data", "da", " def", "format", "dl", "bf", "pdf", "af", "io", "deb", "fd", "dt", "fs", "fe", "pd", "fn", "fr", "di", "dd", "tf", "dp", "fc", "def", "dn", "sf", "xf", "dq", "db", "d", "raf", "dc"], "date": ["work", "x", "pre", "created", "form", "message", "create", "style", "ate", "days", "re", "output", "str", "out", "fee", "sync", "day", "update", "back", "use", "ale", "input", "dates", "complete", "atom", "data", "m", "updated", "year", "module", "format", "open", "age", "valid", "url", "name", "log", "stage", "pe", "modified", "dt", "code", "ge", "dat", "time", "min", "j", "string", "tag", "dose", "rule", "Date", "D", "value", " Date", "version", "bug", "custom", "diff", "type", "db", "d"], "zipFile": ["sqlModel", "ZipFile", "zipfile", "ressFile", "Zipfile", "ressfile", "zipFiles", "zipSection", "zFiles", "ressModel", " zipFiles", "zipModel", " zipfile", "zFile", "ZipFiles", "zfile", "zModel", "zSection", "ZipEntry", "ressSection", "zipEntry", "sqlFile", "sqlfile", "sqlSection", " zipEntry", "zEntry"], "zos": ["ls", "closure", "dos", "hess", "bos", "z", "chini", "obb", "iffs", "zer", "zl", "gz", "zik", "tz", "robe", "han", "zona", "nz", "cash", "zy", "zb", "proxy", "zzy", "bitcoin", "eros", "ros", "zero", "ses", " sands", "os", "cos", "los", "ZA", "inos", "dylib", "zip", "fits", "zo", "address", "webkit", "uz", "zag", "budget", "zes", "zh", "zn", "exit", "las", "liquid", "rez", "outs", "settings", "zen", "kos", "lins", "ils", "css", "ozo", "zan", "ssl", "asio", "her", "osi", "zi", "zx", "jas", "nox", "js", "forge", "zon", "zar", "bes", "ops"], "fis": ["lids", "rafris", "fliss", "infias", "flids", "fiz", "infiss", "Fiss", "fiss", "lias", "rafis", "rafias", "flias", "flis", " fits", "flris", "vils", "bos", " fiss", "rafiss", " fiz", " fos", "biss", "bisl", "fris", "fisl", "fias", "infits", "Fos", "Fias", "lis", "liss", "Fis", "infis", " fils", "vits", "Fris", "fits", "fils", "vis", "Fisl", "Fisp", " fias", " fisp", "fisp", "infiz", "infils", "fos", " fisl", "flisp", "fids", "bis", "infids", " fris", "viz"], "entry": [" Entry", "style", "the", "uri", "se", "ace", "so", "z", "ry", "cell", "ion", "Entry", "info", "archive", "event", "extra", "e", "ie", "per", "de", "card", "image", "cel", "or", "data", "record", "array", "comment", "and", "next", "si", "ries", "lc", "add", "it", "server", "obj", "ui", "zip", "ge", "address", "term", "letter", "index", "zo", "exp", "element", "auto", "row", "r", "feed", "key", "her", "reader", "offset"], "buffer": ["vector", "sequence", "position", "shape", "cache", "result", "length", "available", "memory", "pad", "buff", "bb", "buf", "page", "seed", "bytes", "uffer", "padding", "border", "FFER", "data", "writer", "binary", "comment", "b", "device", "null", "server", "transfer", "number", "address", "Buffer", "beta", "header", "channel", "queue", "layer", "batch", "reference", "iter", "row", "wave", "feed", "slice", "reader", "flush"], "readed": ["inputED", " ReadED", "inputled", "inted", "intED", "textized", "readled", "textED", "readended", " readable", "readned", " Readed", " Readered", "readable", "bootered", "inputned", " readered", " readED", "bootable", "textended", "inputed", " readended", "texted", " Readned", " Readable", "intended", " readized", "readED", " Readled", " readled", "readered", "readized", "bootED", " readned", "booted", "intized"]}}
{"id1": "693636", "id2": "11082670", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createCreateCart", "createEmptyShipping", " createNewCart", "createEmptycart", " createNewcart", "createNewcart", " createNewShipping", " createNewSpot", "createCreatecart", " createEmptyShipping", " createEmptycart", "createNewShipping", "createTempCart", "createTempcart", "createEmptySpot", "createNewCart", "createCreateSpot", " createEmptySpot", "createNewSpot", "createCreateShipping", "createTempSpot", "createTempShipping"], "SHOPPING_ID": ["SHOPPIPIDID", "SHOPPINGIDid", "SHOPPIP_id", "SHOPPINGIDID", "SHOPPYING_ID", "SHOPPIPIDIDS", "SHOPPIP_IDS", "SHOPPING_IDS", "SHOPPINGINGId", "SHOPPINGINGID", "SHOPPYING_IDs", "SHOPPIP_ID", "SHOPPINGINGid", "SHOPPINGPOIDs", "SHOPPTING_id", "SHOPPIPIDIDs", "SHOPPTING_ID", "SHOPPING_IDs", "SHOPPING_id", "SHOPPINGIDId", "SHOPPTING_Id", "SHOPPIP_IDs", "SHOPPING_Id", "SHOPPINGPOIDS", "SHOPPYING_IDS", "SHOPPIPIDId", "SHOPPYING_Id", "SHOPPINGIDIDS", "SHOPPIPIDid", "SHOPPINGPOId", "SHOPPINGIDIDs", "SHOPPINGPOID", "SHOPPIP_Id"], "con": ["pen", "cache", "uc", "client", "cf", "ctrl", "session", "c", "ac", "com", "reg", "ex", "ca", "conn", "Conn", "ci", "loc", "close", "win", "act", "cas", "ec", "connect", "bc", "pc", "ann", "conv", "log", "col", "fac", "pool", "ran", "exec", "Con", "conf", "cr", "cur", "rc", "connection", "cc", "fa", "cond", "coll", "cons", "wan", "cm", "fc", "en", "un", "cn", "mc", "row", "CON", "ctx", "commit", "inc", "db", "co", "can"], "insert_cart": ["install_cart", "install_part", "insert_conn", "insertencart", " insert_center", "insertencycle", "insert_payment", "insert_cat", " insert_cycle", "insertencenter", "install_container", "insert_center", "insertencat", "exec_payment", "insert_pod", " insert_ox", "exec_cart", "insert_part", "insert_cycle", "exec_Cart", " insert_conn", "insert_container", "insert_Cart", "insert_ox", " insert_pod", " insert_cat"]}}
{"id1": "13122204", "id2": "13362846", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackFile", "UnzipProject", "unpatchProject", "unpackProject", "unzipProject", "unzipFile", "unarchiveProject", "unpackmodel", "unarchiveFile", "Unarchivemodel", "UnzipModel", "UnarchiveProject", "unpatchModel", "UnzipFile", "unarchiveModel", "unarchivemodel", "unzipmodel", "unpatchFile", "unpatchmodel", "UnarchiveModel", "unpackModel", "Unzipmodel", "UnarchiveFile"], "filename": ["source", "File", "fp", "uri", "path", "username", "kl", "download", "f", "model", "title", "il", "fil", "txt", "l", "src", "loc", "folder", "module", "location", "bf", "FILE", "directory", "url", "database", "name", "fd", "files", "fits", "jet", "SourceFile", "string", "fn", "Filename", "file", "utf", "nil"], "tempdir": ["TempDir", "TempDIR", " tempDir", " tempDIR", " temppath", "Tempdirectory", "Tempdir", "tempfolder", "tmpDir", "tmpdirectory", "tempDIR", "tmppath", "tmpdir", "temfolder", "tempDir", " tempfolder", "temdir", " tempdirectory", "tempath", "Tempfolder", "temppath", "temDir", "temdirectory", "tmpfolder", "tmpDIR", "tempdirectory"], "dest": ["source", "flat", "result", "prop", "output", "sync", "st", "session", "inner", "home", "store", " Dest", "nt", "txt", "de", "trans", "src", "rest", "cdn", "default", "loc", "walker", "folder", "done", "builder", "transform", "later", "export", "sup", "tmp", "log", "cont", "proc", "die", "transfer", "ui", "zip", "obj", "gen", "dist", "dat", "comb", "di", "exit", "handler", "usr", "test", "desc", "tar", "file", "temp", "std", "wb", "Dest", "walk", "dir", "opt", "target", "delete", "dc"], "fis": ["fsis", "fliss", "fiss", "filei", "flis", "fileis", " fid", " fiss", "fileisa", "fsbis", "filebis", "liss", "fileid", "lis", "flisa", "fid", "fisa", " fi", "li", "fbis", "fileiss", "fi", "lid", "flbis", "fsisa", "fsiss"], "BUFFER": ["MAFIX", "CUFF", "BUVEN", "MAFER", " BUFF", "SAPER", "TAVER", "BUVER", "MAPER", " BUFER", "SAUCK", "BOFIX", "UPVER", "UPVEN", "BOFFER", "BUFIX", "BOFER", " BUFIX", "TAPER", " BUUCK", "BOPER", "UPFF", "CUUCK", "BUPER", "CUFFER", "CUVEN", "SAFFER", "UPFFER", "BUFF", " BUPER", "TAFFER", "CUPER", "SAVER", "CUVER", " BUVER", " BUVEN", "BUFER", "BUUCK", "TAUCK", "MAFFER"], "zis": [" zas", "dbis", "zins", "jos", "zipis", "zii", "zipisa", " zIS", "xos", "zisa", " zii", "zipin", "xiss", "zIS", "yIS", "xii", "zipins", " zos", "Zisa", "zists", "jists", "yin", "diss", "zas", "xis", "ziss", "zos", "Zas", "jis", "zbis", "zipas", "ji", " zi", " zists", " zins", " ziss", "zipIS", "dii", "xbis", "xists", "xi", "yisa", "dis", " zbis", "Zins", "zin", "zi", "Zis", " zin", "yis", " zisa"], "entry": ["match", "ent", "source", "result", "se", "ace", "ry", "inner", "cat", "Entry", "info", "archive", "e", "ie", "nt", "de", "ident", "enter", "image", "cel", "line", "or", "record", "module", "ce", "la", "valid", "next", "si", "name", "ries", "pe", "ou", "lc", "spec", "ge", "server", "zip", "je", "rc", "li", "connection", "element", "file", "way", "porter", "part", "row", "pack", "feed", "her", "reader", "id", "end", "iterator", "inc", "jo"], "count": ["last", "buffer", "cache", "current", "length", "c", "f", "len", "use", "e", "i", "max", "pos", "line", "val", "read", "ind", "writer", "in", "core", "limit", "next", "base", "name", "log", "b", "allow", "add", "low", "code", "counter", "number", "time", "index", "list", "size", "Count", "cond", "coll", "write", "sum", "_", "weight", "iter", "file", "part", "key", "feed", "id", "end", "type", "start"], "data": ["message", "buffer", "result", "media", "str", "length", "DATA", "load", "shift", "info", "len", "bytes", "input", "pos", "image", "read", "record", "format", "zero", "next", "a", "base", "name", "array", "number", "dat", "body", "index", "size", "alpha", "write", "raw", "batch", "block", "value", "pack", "feed", "id", "reader", "start", "d", "la", "content"], "fos": ["xops", "bos", "foes", "xos", "dfos", "dfops", "afops", "foos", " fops", "dfoos", " fOS", "bops", " foes", "afis", "afOS", "afos", "xoes", " foos", "xoos", "fOS", "bOS", "bis", "fops", "dfoes"]}}
{"id1": "692738", "id2": "23273706", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 0, "substitutes": {"url": ["source", "ref", "filename", "buffer", "uri", "path", "Url", "f", "config", "link", "l", "image", "loc", "loader", "service", "location", "resource", "www", "io", "base", "name", "bel", "null", "server", "host", "URL", "rl", "sl", "address", "string", "connection", "fr", "ur", "el", "ll", "lr", "html", "file", "ssl", "feed", "href", "ob", "id", "xml", "http"], "in": ["source", "as", "init", "inn", "gin", "out", "token", "pin", "inner", "c", "f", "config", "this", "ex", "i", "input", "socket", "serv", "conn", "inside", "image", "val", "or", "IN", "data", "m", "ini", "con", "resource", "n", "io", "isin", "a", "bin", "din", "is", "nin", "min", "ins", "In", "impl", "again", "rin", "file", "part", "err", "r", "login", "ssl", "id", "reader", "inc", "xml", "cms"]}}
{"id1": "350482", "id2": "20100809", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doVersioncheck", "doReleaseWork", "doReleasecheck", "doVersionTest", " doReleaseTest", "doReleaseCheck", " doReleaseCheck", "doversionTest", "doVERSIONTest", " doBuildcheck", "doReleaseTest", "doVersioncheck", " doBuildTest", " doVersionWork", "doversioncheck", "doVERSIONCheck", "doBuildWork", " doReleasecheck", "doBuildCheck", "doVersionWork", "doVERSIONcheck", "doBuildTest", " doBuildWork", "doversionCheck", " doVersionTest", " doBuildCheck", "doVERSIONWork", "doBuildcheck"], "view": ["form", "edit", "style", "app", "buffer", "cache", "widget", "port", "out", "client", "session", "cell", "update", "config", "this", "model", "View", "page", "event", "show", "e", "use", "gui", "input", "l", "image", "screen", "box", "q", "VIEW", "object", "comment", "self", "accept", "window", "display", "server", "change", "sel", "ui", "body", "see", "vis", "div", "lock", "views", "gu", "el", "full", "block", "html", "request", "row", "layout", "reader", "v", "can", "http"], "url": ["source", "buffer", "uri", "browser", "client", "path", "Url", "f", "bb", "input", "l", "socket", "image", "build", "blog", "loader", "web", "service", "resource", "open", "hub", "base", "log", "bel", "server", "host", "URL", "zip", "sl", "address", "string", "connection", "channel", "stream", "ll", "file", "lib", "ssl", "ob", "user", "http"], "in": ["source", "as", "init", "buffer", "gin", "inn", "out", "inner", "ac", "s", "i", "input", "socket", "sin", "IN", "data", "ini", "win", "con", "resource", "binary", "n", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "rin", "file", "login", "reader", "bis", "din"], "bin": ["init", "ln", "buffer", "inn", "gin", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "inline", "IN", "abi", "data", "loader", "win", "record", "con", "binary", "bot", "bi", "log", "b", "bn", "fin", "nb", "body", "lock", "cin", "lin", "spin", "ruby", "file", "kin", "lib", "part", "oin", "reader", "din", "run"], "line": ["text", "source", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "cell", "day", "load", "lo", "home", "model", "page", "pass", "link", "e", "i", "word", "l", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "valid", "base", "name", "log", "b", "lc", "job", "pe", "band", "code", "ge", "split", "letter", "string", "rule", "LINE", "el", "lin", "cl", "layer", "ine", "block", "file", "part", "row", "key", "non", "entry", "end", "le", "unit", "site", "id", "no"], "develBuild": ["deployBuild", "develBuilder", "dewardbuild", "deployBuilt", "DEvelbuild", "dewardBuilder", "desvenRun", "DEvelBuilt", "desvenBuilder", "deviousBuild", "desvelbuild", "desvelBuilder", "deVELRun", "desvelRun", "deVELBuilder", "devenBuild", "develbuild", "desvelBuild", "deVELbuild", "develRun", "desvenRelease", "DEvelBuild", "deployBuilder", "devenBuilder", "develRelease", "desvelBuilt", "deelRelease", "DEVELBuilt", "deployRun", "dellBuild", "dewardBuild", "dewardBuilt", "devenbuild", "DEVELBuilder", "desvenbuild", "dellRun", "DEVELBuild", "DEvelBuilder", "deelBuilder", "dellBuilder", "desvenBuild", "DEVELbuild", "develBuilt", "desvenBuilt", "deviousbuild", "devenBuilt", "deelBuild", "deVELBuild", "devenRun", "deelRun", "dellRelease", "deviousBuilt", "deVELBuilt", "desvelRelease", "devenRelease", "deploybuild"], "stableBuild": ["basebuild", "latestBuilder", "stablebuild", "compatibleBuild", "latestbuild", "prettyBuilder", "stableVersion", "validBuilder", "securebuild", "prettybuild", "latestBuild", "compatibleBuilder", "baseBuild", "secureBuild", "compatiblebuild", "secureBuilder", "stableBuilder", "validBuild", " stablebuild", " stableVersion", "staticbuild", "validbuild", " stableBuilder", "baseVersion", "prettyVersion", "prettyBuild", "staticBuild", "baseBuilder", "staticBuilder"]}}
{"id1": "4716110", "id2": "13516684", "code1": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copiedContent", " copyChannel", "CopyChannel", "copyFiles", "CopyFile", "CopyContent", " copiedFiles", "copyContent", " copyContent", " copiedChannel", "CopyFiles", "copyChannel", " copiedFile", " copyFiles"], "in": ["work", "source", "buffer", "copy", "inn", "inner", "c", "ac", "config", "at", "ex", "i", "input", "image", "or", "IN", "data", "m", "ini", "io", "a", "url", "base", "name", "din", "b", "min", "ins", "connection", "In", "inc", "again", "file", "part", "login", "id", "reader", "diff", "bin"], "out": ["p", "x", "source", "copy", "cache", "output", "client", "c", "f", "point", "at", "w", "ex", "OUT", "conn", "image", "data", "writer", "object", "dest", "n", "io", "up", "base", "name", "server", "exec", "string", "connection", "external", "prefix", "Out", "outs", "file", "part", "o", "user", "v", "target"], "sourceChannel": ["SourceContext", "sourceConnection", "inputMessage", "SourceChan", "ourceChannel", "inputChan", "ourceContext", " sourcechannel", "inputChannel", " sourceMessage", "sourceChan", "SourceConnection", " sourceContext", "targetConnection", " sourceConnection", "SourceSocket", "inputchannel", " sourceStream", "SourceMessage", "sourceSocket", "sourceMessage", "ourceStream", "sourceContext", "targetchannel", " sourceChan", "targetChan", " sourceSocket", "ourceSocket", "sourcechannel", "sourceStream", "targetStream", "SourceChannel", "SourceStream", "Sourcechannel", "targetChannel"], "destinationChannel": ["destinatingChan", "destinationchannel", "DestinationChannel", "destinatingStream", "destributionchannel", " destributionCh", "destinatedChannel", "DestinationManager", "DestinationConnection", "destinateConnection", "destinationCh", "destinationStream", "destinateChannel", "DestinatorChannel", "destinatedCh", "DestinatorManager", "destructionChannel", "destinatedManager", "destructionchannel", "destinatorManager", "destributionCh", " destributionChan", " destinationChan", "destinationChan", "DestinationStream", " destributionChannel", "DestinatorConnection", "destinatedChan", "destinatorConnection", "destinatingchannel", "destinationConnection", "destinatedConnection", "DestinatorChan", "destructionStream", "DestinatorStream", "destinatorChan", "destinatedchannel", "destinatedStream", " destinationCh", "destinationManager", "destinatingChannel", "destinateManager", "Destinationchannel", "DestinationChan", " destinationchannel", "Destinatorchannel", "destributionChannel", "destructionChan", "destinatorCh", "destributionChan", "destinateStream", " destributionchannel", "destinatorchannel", "destinatorChannel", "destinatorStream"]}}
{"id1": "18782385", "id2": "494226", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"saveFile": ["writeFiles", "writeFile", "uploadImage", " saveImage", "saveDirectory", " saveFiles", "uploadFile", "saveImage", "writeDirectory", "uploadDirectory", "writeImage", "uploadFiles", " saveDirectory", "saveFiles"], "window": ["remote", "video", "buffer", "session", "event", "w", "project", "hw", " wizard", "image", "directory", " GUI", "wx", "Window", "time", "GUI", " container", "target", "volume", "client", "browser", " wid", "home", "gui", "view", "visual", "command", "show", "button", "angular", "win", "img", "motion", " video", "microsoft", "layer", "dom", "gallery", " world", "game", "parent", "audio", " Window", "style", "media", "feature", "driver", "wall", "input", "scroll", "screen", "box", "document", "wa", "stage", "youtube", "office", "space", "doc", "flow", "widget", " host", "frame", "system", "console", "manager", " widget", "menu", " dialog", " canvas", "device", "server", "host", "band", "ui", "scope", "machine", " office", "file", "layout", "draw"], "stream": ["output", "out", " app", " temp", "f", "w", " prog", " this", "OU", " bout", " upload", "io", "document", " console", "os", " webcam", " w", " video", "Stream", " form", " buffer", " OUT", " webpage", "file", " streams", " resource"], "outputDoc": ["externalDiv", "updateDocument", " outputDocument", "targetDocument", "outputDocument", "outputDir", "externalDocument", " outputDiv", "OutputDiv", "inputFile", " outputFile", "inputDoc", "inputDir", "OutputDoc", "outputDiv", "inputDocument", "updateDir", "OutputDocument", "externalFile", "updateDoc", "targetFile", "OutputDir", "targetDiv", " outputDir", "OutputFile", "outputFile", "externalDoc", "targetDoc", "updateDiv"], "dtd": ["ddt", "fdTD", "sTD", "slt", "fddd", "ddd", "ddl", " ddt", "fddl", " ddd", "Ddd", " ddl", "sdt", "Dtd", " dTD", "DTD", "fdtd", " dlt", "std", "dTD", "dlt", "Ddl", "Dlt", "Ddt"], "uiElement": ["ouEle", "uiDocument", "ioEl", "uEl", "luEngine", "guiE", "uiEngine", "UIElement", "guiMember", "ouEditor", "UIMember", "ouElement", "uiSource", "uniEntity", "uelement", "apiElement", "cliElement", "uriEntity", "ioElement", "UIEntry", "guiModule", " UIEl", "UIEl", "uiDoc", "uriEl", "volumeObject", "suEngine", "unielement", "luEntity", "apiEntity", "volumeDocument", "uiEntry", "uriObject", "utilDoc", "UIE", "UIModule", "apiEl", "UIDocument", "UIelement", "uniE", "uielement", "utilEl", "UISource", "guiEntity", "suEmail", "volumeEntry", "suEntity", "uriEngine", "ouEl", "cliEl", " UIElement", " UIEle", "luElement", "UIDoc", "cliSource", "urielement", "uiEditor", "ioModule", "luEmail", "UIEle", "guiEl", "guiElement", "uElement", "uiModule", "UIObject", "uiE", "uniEl", "uriEntry", "uniElement", "utilElement", "uiEntity", "uriEmail", "uriElement", "uriE", "cliEntry", "uiEmail", "uiEl", "guielement", "uiObject", "uiMember", "UIEditor", "ioDoc", " UIEditor", "uiEle", "suElement", "apiE", "uSource", "uniMember", "uriDocument", "guiDoc", "clielement"], "currentLFClassName": ["currentLFFilename", "currentLELFCLASSDesc", "currentLDFFileString", "currentLFFileString", "currentLFFunctionDesc", "currentLELFClassDesc", "currentLFFileName", "currentLELFCLASSPath", "currentLFCLASSAlias", "currentLFFileDesc", "currentLFCLASSName", "currentLFClassname", "currentLFclassString", "currentLFCLASSPath", "currentLFClassAlias", "currentLFclassAlias", "currentLFFunctionName", "currentLDFClassName", "currentLDFClassDesc", "currentLFClassPath", "currentLFFunctionAlias", "currentLFFunctionPath", "currentLFCLASSDesc", "currentLDFClassString", "currentLELFClassAlias", "currentLELFClassPath", "currentLFClassString", "currentLDFFilename", "currentLFclassPath", "currentLELFCLASSAlias", "currentLDFClassname", "currentLELFClassName", "currentLDFFileName", "currentLELFCLASSName", "currentLFclassname", "currentLDFFileDesc", "currentLFclassName", "currentLFClassDesc", "currentLFclassDesc"], "systemLFClassName": ["systemLfClassName", "systemLFFullString", "systemLfPackagename", "systemLfClassname", "systemLFPackagename", "systemLfClassCode", "systemLFFullName", "systemLfPackageName", "systemLFclassDesc", "systemLFFullDesc", "systemLFClassString", "systemLFclassName", "systemLFPackageName", "systemLfPackageString", "systemLFPackageCode", "systemLfPackageDesc", "systemLFclassString", "systemLFPackageString", "systemLfClassDesc", "systemLFClassCode", "systemLfPackageCode", "systemLFClassDesc", "systemLfClassString", "systemLFClassname", "systemLFPackageDesc"], "mainWindowElement": ["centralWindowElement", "mainWindowAddress", "mainFlowObject", "mainTimeelement", "mainFlowAddress", "mainHostAddress", "mainWebEnvironment", "mainWebE", "mainFrameE", "mainWindowContainer", "mainQueueElement", " mainWindowMember", " mainWebElement", "mainWheelElement", "centralFrameEl", "mainWebEngine", "mainTimeEl", "mainScreenElement", "mainFrameContainer", "mainWindowsE", " mainWheelEnvironment", " mainWindowE", "MainFrameFrame", "MainFrameEl", "currentFrameElement", "currentWindowEl", "mainGroupElement", " mainWindowObject", "MainFrameElement", " mainWheelElement", "mainWebMember", "MainFrameE", "MainWindowFrame", "MainWindowEl", "mainWindowFrame", "mainWindowEngine", "mainStreamEl", "mainStreamPage", " mainWebEngine", "MainWindowElement", "mainFlowBuilder", " mainWindowAddress", "mainWindowsElement", "mainGroupEngine", "mainWheelEl", "mainWebAddress", "mainWheelEnvironment", " mainWheelEl", "mainHostE", "mainMenuEl", " mainWindowEngine", " mainWheelMember", "mainWindowMember", "mainWindowEl", "mainMenuContainer", " mainHostElement", "mainQueueE", "mainHostBuilder", "currentWindowContainer", "mainFramePage", "mainFlowEnvironment", " mainHostBuilder", "mainFrameFrame", "mainScreenEl", "mainFlowEngine", "mainFrameelement", "mainWindowsFrame", "mainQueueFrame", " mainWebObject", "mainFrameElement", "currentWindowElement", "mainWindowObject", "mainFrameEnvironment", " mainWebEnvironment", "currentFramePage", "mainWheelMember", "mainWebObject", "mainWebBuilder", "currentWindowPage", "mainWindowE", "centralWindowelement", " mainWindowEl", "mainMenuPage", "centralWindowEl", "mainGroupEnvironment", "mainWindowEnvironment", "mainFlowE", "mainWebElement", "mainScreenelement", "mainTimeElement", "mainFrameMember", "currentFrameContainer", "mainGroupObject", "mainMenuElement", "mainStreamElement", "mainWebEl", "currentFrameEl", "mainWindowPage", "centralFrameelement", "mainFlowElement", "MainWindowE", "mainHostElement", "mainWindowsEl", "mainWindowBuilder", "centralFrameElement", "mainWindowelement", " mainHostE", " mainWindowEnvironment", " mainHostAddress", "mainQueueEl", " mainWindowBuilder", "mainFrameEl", "mainStreamContainer"], "volumeElement": ["VolumeContainer", " volumeContainer", " volumeLayer", "volumeContainer", "soundEl", "volumeEntry", "voiceLayer", "soundPart", "volumePart", "audioLayer", "voiceEngine", "soundElement", "voiceElement", " volumeEngine", "audioPart", "voiceContainer", "volumeEngine", "audioEngine", " volumePart", "volumeEl", "audioElement", " volumeEntry", " volumeEl", "voiceEl", "audioEl", "VolumeEntry", "volumelement", "volumeLayer", "voiceEntry", "VolumeElement", "audioEntry", "soundlement", "VolumeEl", "audiolement", " volumelement"], "player": ["app", "ader", "video", "position", " Player", "monitor", "apper", "ayer", "ater", "driver", "ler", "per", "e", "watch", "Player", "players", "playing", "loader", "able", "act", "play", "mor", "roller", "caster", "transfer", "live", "min", "Play", "par", "profile", "handler", "layer", "plays", "aster", "file", "part", "ser", "er", "ower", "game", "db", "audio", "active"]}}
{"id1": "4398382", "id2": "7044685", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 1, "substitutes": {"digest": ["generests", "Digester", "mdested", "encse", "digress", "digested", " digests", "mdester", "encester", " digse", "generester", "generest", "encest", "digests", "generested", "Digse", "Digest", " digested", "mdest", "digester", " digress", " digester", "mdests", "Digress", "digse", "encress"], "algorithm": ["algebra", "challgorithm", "aroding", "Aloding", " alenge", "algo", "challenge", "alignment", "Algorithm", "challgebra", " algo", "argorithm", "maloding", "Alignment", "malignment", "malgebra", "Algo", "malgorithm", "challgo", "Alenge", "aloding", "argebra", "alenge", "Algebra", " algebra", "arignment"], "text": ["source", "sequence", "message", "secret", "buffer", "output", "token", "str", "length", "path", "username", "config", "bytes", "txt", "word", "input", "image", "data", "TEXT", "object", "format", "url", "name", "ext", "Text", "code", "password", "address", "letter", "string", "connection", "struct", "test", "value", "attribute", "feed", "pattern", "content"], "mDigest": ["mDester", "mDigested", "mDesignester", "mDest", "mDgest", "MDester", " mGge", "mSignester", "MDigenge", "amDigested", "MDiger", "amDigest", "mDigenge", "MDigEST", "amDigener", "mGester", "mDigester", "amPostener", "mCodest", "mPostest", "mCodener", "mEncge", "mSignEST", " mDigester", "mDiggest", "mdigest", "mEncest", "mDigener", "mDenge", " mDigge", "MDgest", "mSignenge", "mCodested", "mdiger", "mEncester", "mSignge", "mSignest", "mdigester", "mEncast", "MDiggest", "mDigast", " mGester", "mdiggest", "amPostest", "mGge", " mGast", "MDigester", "mDigge", "amPostested", "mDesignest", "mDigEST", "MDest", " mDigast", "mSignast", "mdigener", "mdigested", "mDer", "mDEST", "mPostested", "mDesigngest", "MDer", "mDesigner", "mPostener", " mGest", "mGast", "mGest", "MDigest", "mDiger"], "raw": ["source", "message", "buffer", "result", "output", "json", "clean", "instance", "buf", "unsigned", "input", "image", "none", "default", "Raw", "data", "binary", "internal", "original", "array", "null", "initial", "hex", "container", "enc", "wrap", "full", "orig", "serial", "row", "partial", "response", "feed", "RAW", "content"], "encoder": ["eccode", "enode", "Encoding", "ecode", "encoded", "encode", "enccode", "Encoded", "Encode", "decode", "enoding", " encode", "ecoding", "enoder", "ecoded", "decoder", " encoding", "encoding", "deccode", " encoded", "decoding", "Encoder", "ecoder"]}}
{"id1": "6840241", "id2": "12172485", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["create", "sync", "cover", "load", "download", "system", "slave", "image", "process", "proxy", "open", "cop", "ip", "io", "clone", "clip", "share", "server", "transfer", "Copy", "mop", "size", "opy", "write", "loop", "type", "cmp"], "source": ["result", "se", "session", "inner", "this", "use", "seed", "slave", "e", "i", "ie", "input", "ources", "ource", "src", "image", "sin", "SOURCE", "data", "Source", "service", "resource", "proxy", "from", "si", "ink", "null", "rice", "server", "address", "sp", "connection", "channel", "size", "stream", "handler", "wrapper", "iter", "parent", "slice", "reader", "iterator", "start", "target"], "sink": ["tinker", "tource", "dsink", "sider", "SINK", "pider", "Sinker", "tink", "outsink", "partsinker", "pink", "outsource", "Sink", "partsINK", "asink", "dsinker", "sigh", "dsource", "Source", "pource", "sINK", "partsource", "asource", "outsinker", " sigh", "pinker", "tider", "asinker", "partsink", "sinker", "outsigh", "dsider", "pINK", " sinker", "asigh"]}}
{"id1": "13720140", "id2": "4056444", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 1, "substitutes": {"modifyProperty": ["Modifyproperty", "modifiedAttribute", "modureProperty", "modureproperty", "ModifyString", "modateString", "ModifyProperty", "modifiedProperty", "modifyAttribute", "modifiedproperty", "Modifiedproperty", "modifyproperty", "ModifyAttribute", "ModifiedAttribute", "modifyString", "modateproperty", "modateAttribute", "modateProperty", "modifiedString", "modureString", "modureAttribute", "ModifiedString", "ModifiedProperty"], "valueID": ["Valueid", "jobid", "contentIndex", "valueId", "ValueId", "ValueIP", "propertyID", "propertyid", "VALUEid", "contentID", "valueIP", "VALUEIndex", "jobId", "jobIP", "VALUEID", "contentid", "propertyIP", "valueIndex", "valueid", "jobID", "propertyId", "ValueID", "ValueIndex"], "value": ["text", "source", "secret", "message", "result", "expression", "output", "token", "Value", "username", "language", "update", "phrase", "VALUE", "command", "image", "padding", "val", "default", "data", "example", "object", "resource", "format", "description", "values", "document", "name", "array", "server", "code", "password", "function", "number", "address", "string", "element", "reference", "attribute", "key", "response", "entry", "v", "target", "pattern", "content"], "userID": ["UserName", " userMAC", "userMAC", " userid", "Userid", "UserID", "authorMAC", "userId", "authorId", "userName", "UserMAC", "authorid", " userName", "authorName", "userid", "UserId", "authorID", " userId"], "property": ["p", "primary", "message", "method", "style", "result", "expression", "prop", "position", "feature", "field", "update", "config", "info", "this", "prototype", "project", "data", "definition", "module", "object", "resource", "metadata", "operator", "foo", "Property", "tmp", "name", "base", "character", "password", "entity", "function", "term", "operation", "variable", "address", "string", "connection", "prefix", "section", "profile", "option", "element", "layer", "attribute", "temp", "properties", "part", "key", "entry", "type", "parent", "jo", "pair"], "newValue": ["NewVal", "currentVALUE", "oldValue", "nextVALUE", "newString", "NewValue", " newvalue", "oldvalue", "replaceValue", "defaultVal", "currentvalue", "currentValue", "newVal", "nextvalue", "replacevalue", "replaceVALUE", "currentVal", "newvalue", "defaultVALUE", "oldVALUE", "nextValue", "newVALUE", "defaultvalue", "NewVALUE", " newString", "defaultValue", "nextVal", "rawVALUE", "NewString", "rawValue", "oldVal", " newVal", " newVALUE", "rawVal", "replaceVal", "rawString"], "crypt": ["python", "copy", "cache", "pt", "Crypt", "client", "dec", " cryptography", "c", "com", "hash", "rypt", "cmd", "ca", "conn", "cash", "poly", "con", "prot", "auth", "binary", "mac", "ec", "chip", "core", "cook", "security", "mix", "utils", "conv", "code", "pool", "password", "cr", "hex", "ch", "coin", "cc", "comb", "cp", "chain", "enc", "cm", "coll", "ctr", "bec", "lib", "temp", "ryption", "key", "ssl", "contract", "cmp"], "digest": ["Digit", "Digist", "Digusher", "Digester", "cododed", "encoded", "DigEST", " digist", "digress", "designest", "codress", "Digoded", "digEST", "crest", "digested", "digusher", " digend", "encester", "gener", "Diger", "ddusher", "genested", "codester", "digist", "digend", "signested", "encest", "designusher", "signEST", "designit", "diger", "ddest", "Digest", "designester", "digoded", "crend", "digit", "genest", "signer", "crist", "genEST", "Digested", "digester", "Digend", "signest", "codest", " digester", "ddit", "crester", "ddester", "Digress", "encress"], "hexString": ["hexArray", " hexstring", " hexSection", "exArray", "hexBuffer", "cryptSection", " hexBuffer", "byteStr", "hashBuffer", "hexstring", "tempString", "tempArray", "byteArray", "rexArray", "exString", "tempBuffer", "hexSection", "rexString", "exstring", "tempSection", " hexStr", "exBuffer", "cryptBuffer", "rexstring", "cryptString", "rexBuffer", "hexStr", "byteString", "hashStr", "hashString", "cryptArray", " hexArray", "byteBuffer", "hashArray"], "i": ["p", "x", "init", "uri", "field", "c", "f", "s", "ii", "info", "gi", "ix", "e", "l", "I", "k", "pos", "ci", "data", "m", "abi", "in", "multi", "ip", "io", "bi", "si", "u", "b", "ti", "it", "ui", "pi", "oi", "index", "li", "j", "h", "hi", "di", "xi", "key", "r", "mu", "slice", "id", "o", "v", "ri", "d", "phi"]}}
{"id1": "160739", "id2": "149935", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createByteReader", " createInputStream", " createByteFile", " createIOReader", " createIOFile", " createInputReader", " createInputSteam", " createInputFile", "createInputSteam", "createOutputReader", "createOutputSteam", " createByteStream", "createOutputFile", " createOutputReader", "createInputStream", " createOutputSteam", "createInputFile", " createOutputFile", " createByteSteam", " createIOSteam", " createIOStream", "createInputReader"], "inFile": ["outFiles", "inputFile", "insFile", "incfile", "insfile", "incFile", "inFiles", "inputfile", "insFiles", "sourcefile", "incStream", "sourceFiles", "inputStream", "insStream", "outfile", "infile", "sourceStream", "outStream", "sourceFile", "inputFiles", "inStream", "incFiles"], "outFile": ["workingFile", "outTime", "workingDirectory", "targetfile", " outfile", "inputFile", " outStream", "workDir", "inputTime", "inputDir", " outDirectory", "targetDirectory", "outDir", "outDirectory", "targetFile", "workingStream", "inputfile", "inTime", "workTime", "outfile", "infile", "outStream", "workfile", "workFile", "targetStream", "inDir", "workingfile"], "k_blockSize": ["k_lockCount", "k_blockLength", "k_byteCode", "k_lineCount", "k_bitSize", "k_byteSize", "k_blocksSize", "k_lockLength", "k_BlockCode", "k_byteCount", "k_lineSize", "k_bitInfo", "k_lockSize", "k_byteLen", "k_lineInfo", "k_blockCount", "k_BlockCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksCount", "k_blockCode", "k_blockLen", "k_blocksLen", "k_BlockSize", "k_blocksLength", "k_byteInfo", "k_BlockLength", "k_bitCount", "k_blockInfo"], "byteCount": ["characterLen", "flushcount", "byteLen", "characterSize", "ByteCount", "bytecount", "ByteLength", "flushSize", "blockCount", "ByteSize", "blockSize", " byteLen", "byteSize", " byteSum", "characterLength", "Bytecount", "byteSum", "ByteSum", "byteLength", "ByteLen", " byteLength", "blockLength", " bytecount", "blockSum", "characterCount", "flushCount", " byteSize", "flushLength"], "buf": ["cv", "bh", "buffer", "result", "uf", "seq", "bag", "feat", "config", "buff", "fb", "len", "font", "bytes", "cmd", "src", "border", "exc", "brace", "loc", "data", "background", "bf", "cas", "img", "tmp", "base", "b", "fd", "Buffer", "append", "rc", "rb", "ucc", "queue", "batch", "alloc", "vec", "cap", "feed", "Buff", "ctx", "flush", "cb", "la"], "ofp": ["afp", "fort", "ofl", "OFnp", "afnp", "OFc", "ofc", "Ofnp", "Ofl", "OFtp", "oft", "Oftp", "ofnp", "Ofc", "OFl", "OFp", "forc", "Ofp", "afl", "oftp", "Oft", "forp", "fortp", "OFt", "afc"], "zos": ["ogl", "iframe", "bos", "zik", "tz", "zona", "abi", "zb", "core", "los", "inos", "zip", "zn", "lins", "css", "ozo", "zin", "zx", "nox", "forge", "oses", "liquid", "uz", "iffs", "zl", "gz", "rons", "nz", "zy", "za", "hz", "ossus", "os", "oS", "utils", "cos", "ZA", "dylib", "fits", "ZI", "zag", "budget", "zes", "outs", "jas", "js", "kos", "zon", "ls", "zers", "oda", "ros", "modules", "bs", "zo", "zh", "rez", "lol", "osi", "zi", "owicz", "soon", "z", "obb", "zer", "robe", "cfg", "zyk", "ws", "enos", "ses", "webkit", "zig", "zen", "packs", "obs", "bitcoin", "zar", "bes", "ops"], "osw": [" osow", "osx", "oswd", "ossnow", "osws", "lsw", "osnow", "isy", "bx", "ossy", " osfw", "lswo", "bws", "iswd", "ossow", "bwo", "ossw", "esww", "eshell", "esfw", "isd", "eswd", "issw", "osshell", "osd", "ossd", "lsws", "oswo", "osfw", "oshell", "osow", "esd", "esw", "essw", "bsx", "isw", "ossfw", "bsw", "isnow", "esnow", "osww", "esow", "ishell", "bsws", "osssw", "lsx", "osy", "bswo", "osswd", " osww", "ossww", "esy"], "bw": ["fsw", " bws", "bbwh", " bwu", "owu", "ebwd", "lsw", " bz", "fx", "bbaw", "Bw", "bx", "lbwh", "lbz", "bW", "abW", "bbz", "ebW", "bwe", "lw", "bz", "bws", "fbwe", "lbw", "baw", "fwa", "lbws", "bew", "bbwa", "Bwa", "fbw", " baw", "bbew", "owa", "fbwd", "bbwu", "fw", "oaw", "abw", "Bew", "lbwa", "abwe", "bbw", "fr", "abwd", "ebwe", " bwh", "ebw", "bsw", "lbx", "lbsw", " bew", "lwa", "lx", "fwh", "bwu", "ow", "fbW", "bwd", "bwa", "bbws", "lbr", "bwh", " bwa", "Bws"], "zot": ["azit", "zott", "zerita", "jos", "Zit", "Zott", "zerori", " zori", " zor", "ziot", "zor", "jit", "azot", "zita", "azor", "Ziot", "jot", "azott", "Zot", "zerot", "zeros", "azita", "Zita", "zerit", "Zor", "zori", "zerott", "jori", " ziot", "aziot"], "ifp": ["IFl", "IFi", "ifl", " ifl", "IFb", "IFf", "ipb", "iff", "ifb", "ifc", " ifi", "ipc", "ifi", "Ifp", "Ifc", "ipp", " iff", " ifb", "IFp", "Ifi", "Iff", " ifc", "IFc", "ipl"], "zis": ["zeis", "Zits", "xits", "Ziss", "zeip", "jits", "zipis", "xisi", "zenais", " zIS", "zIS", "xIS", "zipits", "jisi", "jit", "zenIS", "zits", "xis", "zisi", "zeiss", "ziss", " zais", "zib", "zipip", "zip", "jis", "zais", " zib", " zits", "zeits", "zenib", " zisi", "xib", "zipiss", "xit", "xais", "Zis", "zenis", "Zip"], "isr": ["irrb", " iscr", "ISrc", "issrs", "ISpr", "rispr", "irr", "risrc", "ISsr", "isrb", "issr", " isrs", "iscr", "ISrs", "ISr", "risrb", "risr", "irpr", "ISrb", "isrs", "isscr", "isssr", "irrc", "IScr", "ispr", " issr", "isrc"], "br": ["kr", "bh", "rib", "bro", "arr", "str", "ibr", "browser", "bar", "obl", "HR", " BR", "mr", "BR", "bl", "bp", "Br", "rs", " Br", "sr", "img", "bc", "ber", "obi", "b", "hr", "ocr", "ch", "gr", "cro", "rb", "body", "sp", "ibl", "div", "fr", "yr", "shr", "lr", "ctr", " dr", "tr", "bsp", " fr", "r", "err", "ob"], "zit": ["jith", "zipit", "jite", "zeit", "zipIT", "zeitter", " zip", "jits", "zitter", "zith", "jip", "zipite", "jIT", "zipita", "zipitter", " zith", "zenits", "zipits", "zic", "zeith", "jit", "zits", " zite", "zeita", "zita", "xic", "zipip", "zip", " zi", "zenith", "ji", " zits", "xith", "zIT", "zeits", "jic", "zeIT", "xi", "zenitter", "jita", "zenit", "zipith", "zi", "zite", "xit", " zic"]}}
{"id1": "12678045", "id2": "22625683", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"addQDInformation": ["addKdDirectory", "addQDSInformation", "addKDDirectory", "addQDMInformation", "addQdinformation", "addQdInformation", "addQdDirectory", "addKDinformation", "addQdInfo", "addQDMDirectory", "addQDSinformation", "addQDSInfo", "addKDInfo", "addQDinformation", "addKdInformation", "addQDMInfo", "addQDSDirectory", "addKdinformation", "addKDInformation", "addQDMinformation", "addQDDirectory", "addKdInfo", "addQDInfo"], "qdDate": [" qfDate", "qdAge", "qdxDate", "qtDate", " qfStatus", "qtDay", "qdtDate", "qdatTime", " qdData", "qfFile", "qdatDay", "qdVal", "qcDay", "sqdType", "qsModule", " qtDay", "qdyStatus", "qdtTime", "sqpVal", "qdxVal", "qdyTime", "qsTime", "qfStatus", "sqdDate", "qdxType", "qsName", "qdTime", "qdModule", " qsTime", "sqpName", "qdName", "qdyData", "qsDate", "qtStatus", "qtFile", "qdyName", "qidType", "qdtModule", "sqpDate", "qdxName", "qidVal", "qdatAge", "qcTime", "qfDate", "qidName", "qtTime", " qdName", " qdModule", "qcAge", "qdatDate", " qsDate", "qfData", "sqdName", " qtTime", "qtAge", "qdtName", "qcDate", " qdStatus", "qidDate", " qfData", "qpType", "qtData", "qdyDate", "qdType", "qdDay", " qdAge", "qdStatus", "qdyModule", "sqpType", " qtAge", "qpName", " qfFile", " qsModule", "sqdVal", "qdyFile", " qdTime", " qtDate", " qdDay", "qdData", "qpDate", " qsName", "qpVal"], "qdFile": ["qddDir", "sqdDir", "qdsInfo", "qdDir", "qfFolder", " qdFiles", "qdsfile", "sqdsDir", " qfDir", "qdxReader", "sqdsfile", " qdDir", "qdxFile", " qdInfo", "qdfile", "sqdReader", "qdsLog", "qdLog", " qfFile", "qdFiles", " qdsFile", " qdsLog", "qddInfo", "qdsDir", "qddFile", "qdsFolder", "sqdfile", "qfDir", "qdInfo", "qdxfile", "qdsReader", "qfLog", "qfFile", " qdsFolder", " qfBuffer", "qdsFile", "qdaFiles", " qdFolder", "qfInfo", "qdxDir", "qdaFile", "sqdFile", "sqdsFile", "qdFolder", "qdBuffer", "qdsBuffer", "qsFile", "qdReader", "qsDir", "qsfile", "qsReader", " qdBuffer", "qfFiles", "qddBuffer", "qdaLog", " qdsFiles", " qdLog", " qfInfo", "qdaFolder", "sqdsReader", "qdsFiles", "qfBuffer"], "_qdFileDate": ["_qndTimeDesign", "_qdcfileUpdate", "_qdcFileStatus", "_qdTimeDesign", "_qdDirectoryDesign", "_qdfileDesign", "_qdBaseStatus", "_qdBaseUpdate", "_qdFileName", "_qdTimeDate", "_qdDirectoryDate", "_qdcfileStatus", "_qdcFileDate", "_qdMinName", "_qdFileUpdate", "_qndTimeStatus", "_qndFileDate", "_qdMinUpdate", "_qdcfileName", "_qndFileStatus", "_qdFileDesign", "_qndTimeDate", "_qdTimeStatus", "_qdFiledate", "_qndFileDesign", "_qdDirectorydate", "_qdfileName", "_qdMinDate", "_qdcFileName", "_qdcFileUpdate", "_qdBaseDate", "_qdDirectoryStatus", "_qdMinStatus", "_qdfiledate", "_qdfileUpdate", "_qndTimedate", "_qdFileStatus", "_qdfileStatus", "_qndFiledate", "_qdcfileDate", "_qdfileDate", "_qdTimedate", "_qdBaseName"], "ii": ["uni", "uri", "ni", "ai", "gi", "ix", "ori", "ei", "i", "vi", "ie", "image", "ci", "oe", "ind", "yi", "abi", "ini", "chi", "ice", "vid", " iii", "iii", "iu", "bi", "si", "inf", "II", "ou", "mini", "ui", "pi", "oi", "ji", "index", "li", "ih", "iri", "hi", "di", "qi", "qa", "jp", "lu", "eni", "xi", "fi", "que", "id", "zi", "ti", " i"], "info": ["kid", "ref", "init", "information", "py", "f", "home", "gi", "buff", "alias", "archive", "extra", "link", "txt", "i", "INFO", "data", "abi", "object", "af", "comment", "prev", "job", "fo", "inf", "name", "b", "fw", "ext", "obj", "ui", "conf", "child", "api", "opt", "li", "h", "di", "Info", "qa", "handler", "def", "off", "bug", "part", "feed", "ignore", "entry", "id", "fam", "op", "end", "error", "hi"], "_qdValue": ["_qdsData", "_qdcName", "_sqdcInfo", "_sqdcData", "_qdsName", "_qdcInfo", "_sqdValue", "_qdData", "_qdcValue", "_qdsValue", "_qDInfo", "_qdsInfo", "_sqdInfo", "_qdcData", "_sqdcName", "_sqdcValue", "_qdName", "_qDName", "_qDValue", "_qDData", "_sqdData", "_sqdName", "_qdInfo"], "reader": ["source", "buffer", "result", "re", "uri", "client", "reading", "inner", "author", "f", "rr", "rar", "ler", "per", "driver", "input", "manager", "or", "read", "loader", "writer", "data", "service", "resource", "ger", "io", "rer", "server", "fd", "player", "dr", "rc", "worker", "handler", "parser", "Reader", "iter", "row", "r", "er", "feed", "entry", "ri", "report", "library", "http"], "urlName": ["uriInfo", "UrlArea", " urlPart", "UrlName", "URLPart", "Urlname", "URLString", "urlKey", "URLname", "urlname", " urlFamily", "uriFamily", " urlname", "UrlInfo", "urlFamily", " urlKey", "webFamily", "webInfo", "uriName", "UrlFile", " urlString", "webName", "URLInfo", " urlArea", "URLKey", "urlString", "UrlPart", "URLName", "urlFile", "URLArea", " urlFile", "URLFile", "urlPart", "urlArea", "UrlString", "UrlKey", "urlInfo", " urlInfo"], "url": ["source", "gl", "buffer", "uri", "large", "browser", " URL", "path", "Url", "f", "ball", "page", "l", "socket", "data", "web", "resource", "open", "director", "www", "base", "name", "bel", "server", "host", "URL", "sl", "address", "string", "connection", "channel", "pull", "ssl", "feed", "r", "user", "http"], "stream": ["source", "form", "buffer", "ream", "out", "client", "flash", "download", "f", "s", "view", "driver", "per", "input", "trans", "socket", "control", "draft", "data", "writer", "in", "resource", "open", "io", "zip", "sl", "Stream", "channel", "handler", "coll", "raw", "row", "r", "response", "feed", "user", "v", "oper", "http"], "file": ["source", "buffer", "File", "fp", "parse", "f", "page", "use", "ile", "l", "socket", "data", "writer", "loader", "folder", "object", "resource", "io", "log", "b", "server", "files", "book", "body", "lock", "handler", "part", "r", "feed", "user", " File", "db", "handle", "report", "http"], "line": ["text", "message", "column", "look", "buffer", "parse", "day", "strip", "comment", "base", "name", "log", "pe", "header", "rule", "LINE", "key", "entry", "section", "error", "lf", "sync", "pin", "home", "one", "word", "inline", "item", "data", "force", "job", "phase", "lc", "split", "lin", "range", "user", "style", "Line", "lines", "str", "lo", "link", "cle", "single", "definition", "nl", "shell", "limit", "cr", "side", "string", "block", "response", "status", "no", "se", "cell", "frame", "page", "pass", " Line", "l", "band", "ge", "letter", "body", "connection", "cl", "el", "part", "row", "le"], "_qdDate": ["_qdsYear", "_QdMonth", "_qdNumber", "_qndMonth", "_qfDate", "_qndTime", "_QdTime", "_sqdcDate", "_sqdcData", "_sqdsData", "_qdcDat", "_QdDate", "_qndDate", "_qdData", "_QdsDat", "_sqdsNumber", "_sqdDate", "_qdYear", "_qdcDay", "_qcdNumber", "_qdsTime", "_qdTime", "_sqdcDay", "_sqdsYear", "_sqdYear", "_qdsMonth", "_qdMonth", "_qndData", "_qdcDate", "_sqdsDate", "_qfData", "_qdsDat", "_QdDat", "_qcdDate", "_qdcData", "_qdDay", "_qdDat", "_qcdYear", "_qfDay", "_sqdNumber", "_qdsNumber", "_qdcTime", "_qfTime", "_QdsMonth", "_qdsDate", "_sqdcTime", "_sqdTime", "_qdcMonth", "_QdsDate", "_qndDat", "_sqdData", "_sqdDay", "_qndYear", "_qndNumber", "_qdsDay", "_qcdData", "_QdsTime", "_qdsData"], "pos": ["p", "x", "position", "ps", "pt", "prop", "port", "length", "push", " position", "point", "all", "len", "pl", "pass", "i", "po", "Pos", "down", "val", "loc", "in", "open", "act", "nos", "pose", "n", "next", "axis", "limit", "no", "os", "col", "spec", "post", "mid", "min", "index", "sp", "neg", "j", "POS", "size", "dev", "pres", "pr", "block", "sort", "pid", "off", "part", "pull", "end", "o", "unit", "type", "start", "doc", "offset", "rel"], "projectNum": ["productFamily", "componentNumber", "componentHash", "productNumber", "taskLen", " projectHash", "productNum", "projectName", " projectNumber", "ProjectName", "ProjectNumber", " projectLen", "taskName", " projectFamily", "componentFamily", "taskNumber", "ProjectNum", " projectName", "productHash", "projectNumber", "taskNum", "ProjectLen", "projectLen", "projectHash", "projectFamily", "componentNum"], "value": ["vector", "message", "group", "result", "Value", "feature", "amount", "project", "val", "data", "object", "resource", "description", "values", "name", "number", "profile", "range", "scale", "trial", "version", "key", "response", "type", "v", "target", "price"]}}
{"id1": "12782570", "id2": "12417893", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"logging": [" loguring", "Logging", " loging", "configuring", "logger", "Loguring", "configing", "loguring", "loging", "Loging", "Logger", "configging", "configger", " logger"], "wrap": ["p", "work", "message", "create", "init", "util", "sw", "cache", "widget", "parse", "cover", "wire", "flash", "bag", "frame", "f", "rap", " Wrap", "use", "wp", "w", "word", "war", "image", "or", "build", "process", "wra", "web", "box", "we", "format", "ad", "transform", "ws", "force", "self", "binary", "builder", "core", "wa", "b", " wrapped", "zip", "api", "h", "now", "div", "lock", "handler", "stream", "wrapper", "nw", "html", "wb", "ow", "pipe", "get", "handle", "run"], "buffer": ["source", "message", "ref", "bridge", "result", "copy", "cache", "table", "bar", "flash", "cover", "frame", "bb", "fb", "buff", "buf", "http", "pad", "view", "pb", "manager", "loader", "writer", "object", "board", "builder", "binary", "print", "shell", "base", "log", "b", "server", "player", "transfer", " buf", "msg", "nb", "Buffer", "header", "bm", "queue", "layer", "wrapper", "batch", "reference", "iter", "pause", "BU", "surface", "response", "feed", " buffers", "template", "reader", "bin", "cb", "report", "reply"], "encoding": ["challoded", "encording", "ecryption", "Encoding", "cording", "encoded", "enaching", "challoder", "encryption", "decoded", "decryption", "encoder", "Encoded", "decaching", "Encryption", "coding", "coder", "enoded", "enording", "challoding", "enoding", "encaching", "ecoding", "enoder", "ecoded", "decoder", "ecording", "decoding", "Encoder", "challaching", "ecoder", "coded"], "getEncoding": ["getCoder", "getCression", "getEncoded", " getEnoded", " getEnoder", " getEnoding", "getencoder", "getEnoder", "getEncression", " getEncoder", " getEnocol", "getEnasing", "getCasing", "getCompression", "getEncocol", "getEncasing", "getEnocol", "getCompoded", "getEnression", " getEncoded", "getEncoder", "getencoding", " getEncasing", " getEnasing", "getCoded", "getEnoding", "getCocol", " getEncression", "getEnoded", " getEnression", "getCompoding", " getEncocol", "getencocol", "getencasing", "getCoding", "getCompoder"], "headers": ["frames", "relations", "workers", "types", "parts", "writers", "lines", "ppers", "str", "dict", "bits", "keys", "s", "head", "ers", "groups", "options", "heads", "vals", "padding", "caps", "names", "strings", "rs", "ints", "values", "objects", "host", "params", "files", "features", "body", "header", "h", "links", "blocks", "details", "wrapper", "ings", "settings", "plugins", "properties", "breaks", "ports", "fields", "events", "ids", "http"], "is": ["tis", "mis", "as", "ris", "was", "IS", "out", "oss", "us", "isa", "so", "ists", "s", "its", "ori", "sis", "bas", "are", "iss", "i", "Is", "or", "iso", "in", "lis", "ws", "ses", "ms", "os", "ui", "fs", "bs", "isl", "api", "isi", "isol", "ins", "las", "ais", "ios", "aos", "abs", "es", "iris", "obs", "nis", "bis", "has", "js", "cms", "ops", "ois", "http"], "bos": ["org", "uds", "tis", "mis", "bh", "so", "was", "bits", "android", "bones", "opus", "home", "oes", "bas", "mos", "bo", "oops", "ubis", "ko", "bott", "abi", "obo", "mobi", "kb", "bot", "proxy", "bps", "ws", "shadow", "bi", "ros", "ses", "bc", "pins", "oks", "os", "los", "obi", "cos", "zos", "fs", "bots", "bs", "zo", "fits", "ubs", " Bos", "obos", "oos", "ios", "aos", "outs", "lins", "abs", "osa", "obs", "ob", "osi", "bis", "beans", "js", "cms", "oses", "ois", "bes", "ops"], "e": ["p", "x", "re", "se", "c", "f", "ite", "ale", "ie", "i", "de", "one", "d", "exc", "ele", "oe", "E", "ce", "ze", "ec", "ne", "ke", "be", "a", "pe", "die", "fe", "je", "element", "ee", "ae", "ev", "err", "er", "o", "type", "esi", "error", "ception", "ea"]}}
{"id1": "12078471", "id2": "12417893", "code1": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"tryLoadURL": ["tryLoadingString", " tryLoadUrl", " tryReadURL", "tryloadUrl", "tryloadString", "tryLoadingURL", "tryloadSSL", "tryReadSSL", " tryLoadSSL", "tryReadString", "tryReadURL", "tryLoadSSL", "tryLoadingSSL", " tryReadSSL", "tryLoadingUrl", "tryReadUrl", "tryLoadString", " tryReadString", "tryLoadUrl", " tryLoadString", "tryloadURL", " tryReadUrl"], "url": ["text", "source", "filename", "uri", "str", "path", "language", "Url", "download", "config", "f", "page", "link", "input", "l", "image", "loc", "service", "location", "resource", "base", "name", "server", "host", "URL", "address", "sl", "connection", "string", "ur", "ll", "file", "version", "ssl", "href", "feed", "id", "xml", "http"], "format": ["form", "method", "style", "filename", "mode", "str", "language", "feature", "field", "feat", "f", "config", "info", "at", "environment", "et", "agent", "writer", "magic", "object", "transform", "print", "export", "and", "class", "platform", "stage", "Format", "host", "printf", "function", "api", "handler", "settings", "filter", "value", "version", "file", "attribute", "key", "template", "feed", "atter", "unit", "type", "pattern", "att", "content"], "c": ["p", "cs", "client", "cf", "ac", "f", "tc", "e", "i", "l", "conn", "ci", "m", "con", "ce", "ec", "n", "pc", "b", "lc", "conv", "C", "u", "cr", "exec", "sc", "ch", "rc", "cc", "nc", "connection", "cp", "enc", "cm", "cl", "coll", "fc", "cd", "cu", "cn", "mc", "r", "ct", "ctx", "cb", "d", "dc"], "data": ["p", "text", "source", "message", "result", "buffer", "media", "output", "json", "str", "DATA", "empty", "f", "s", "bytes", "input", "da", "in", "resource", "storage", "ata", "a", "name", "database", "base", "u", "dat", "body", "string", "connection", "alpha", "stream", "value", "key", "response", "id", "reader", "o", "type", "bin", "d", "la", "content"], "model": ["lp", "message", "form", "style", "copy", "fp", "json", "client", "instance", "f", "config", "view", "l", "ca", "image", "Model", "m", "module", "record", "object", "builder", "ga", "document", "base", "bel", "lc", "server", "code", "zip", "query", "child", "api", "models", "channel", "handler", "layer", "coll", "cm", "value", "file", "row", "df", "response", "feed", "reader", "type", "parent", "xml", "pattern", "content"]}}
{"id1": "11183087", "id2": "6890417", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 0, "substitutes": {"doPost": ["doingPOST", " doSearch", "handlePost", "handlePut", " doPut", "handlePOST", "doPOST", "doPut", "doingSearch", "doingPost", " doPOST", "doSearch", "handleSearch", "doingPut"], "request": ["right", "message", "press", "create", "call", "remote", "result", "the", "forward", "buffer", "current", "client", "hello", "instance", "frame", "config", "info", "model", "event", "use", "view", "http", "state", "e", "have", "input", "enter", "image", "project", "complete", "get", "req", "data", "q", "web", "object", "resource", "context", "QUEST", "error", "url", "subject", "initial", "pe", "server", "post", "query", "child", "external", "queue", "rf", "parent", "route", "pull", "r", "er", "join", "rate", "user", "type", "xml", "Request", "report", "order", "application"], "response": ["message", "result", "output", "client", "model", "page", "view", "application", "resp", "writer", "web", "object", "resource", "reply", "guide", "document", "next", "server", "Response", "pool", "api", "res", "body", "onse", "connection", "respond", "results", "template", "site", "parent", "report", "status", "http"], "senha": ["zenca", "sanlah", "tonha", "renaka", " senwa", " senaka", "zensha", "senlah", "senwa", "renha", "senhi", "suitsha", "renHa", "tonlah", "snha", "sanha", "sanwa", "suitla", "suithi", "snsha", "senca", "tonHa", "zenHa", "snhi", "suitha", "renca", "zenaka", "senaka", "zenla", "zenha", "senHa", "snla", " senca", "tonwa", " senlah", "zenhi", "sensha", " senHa", "senla", "sanHa"], "email": ["account", "secret", "message", "business", "language", "username", "hello", "home", "alias", "environment", "model", "phrase", "e", "line", "data", "example", "service", "ip", "url", "name", "server", "label", "password", "zip", "address", "letter", "string", "Email", "fax", "office", "file", "login", "id", "user", "xml", "mobile", "mail"], "messageDigest": [" messagedigester", "messagedigester", " messageDigend", " messagedigEST", "medigester", "messageDEST", "messageDigend", "messagedigEST", " messageDigEST", "messagedigest", " messageDend", " messageDester", "messageDigEST", "messageMailEST", "messageDester", " messagedigest", "meDigher", "messageDher", "medigest", " messageDigester", "meDigEST", "messageDigester", "messagedigher", "messageDest", " messageDest", "messageMailend", "meDigest", " messageDEST", "messagedigend", "medigher", "messageMailest", "messageMailester", "meDigester", "medigEST", "messageDend", "messageDigher"], "usuario": ["ussuarial", "usituarial", "usuiario", "ususarius", " usuariat", "usuitarium", "suuarial", "usituasio", " ususariat", "usuarius", "usluasio", "usuirio", "usituario", "usuarial", "ussurio", "ussuasio", " usuiarium", "usuiarium", " usurio", "ususario", "usguariat", "usueariat", "usuariat", " usuillo", "usuearius", "usluarial", " ususillo", "ussuarium", " usuirio", "suuario", "suurio", "ususariat", "suluarial", "usguarius", "usuitrio", "usuitario", " usuarius", "sulurio", "usurio", "usuarium", "usueario", "ussuario", "suluario", "usuillo", "suuasio", "usuiasio", " usuiasio", "usguillo", "usguario", "uslurio", "suluasio", " ususario", " usuiario", "usiturio", "ususillo", " usuasio", "usuitasio", "usluario", " usuarium", "usuasio", " ususarius", "usueillo"], "redirect": ["induce", "Redirect", "edirect", "predroute", "rerict", "reroute", "Redroute", "predirection", " redition", " redurl", " redirection", "Redurl", " redrict", "reirect", "predrict", " redRECT", "predRECT", "Redrict", "redirection", " reduce", "predirect", "redrict", "Redition", "redurl", "indrict", "reduce", "indirect", "reirection", "preduce", "RedRECT", "redition", "Redirection", "edition", "edurl", "edirection", "redroute", "indirection", "redRECT"], "session": ["message", "group", "cookie", "app", "result", "cache", "browser", "client", "flash", "ession", "config", "info", "system", "state", "page", "use", "view", "event", "person", "input", "image", "data", "service", "object", "proxy", "comment", "storage", "document", "server", "query", "sl", "child", "sp", "connection", "sid", "ssl", "site", "user", "Session", "node", "http"]}}
{"id1": "8132219", "id2": "18974466", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "inFile": ["INSourceFile", "outFiles", "INFilename", "inputFile", "InFilename", " infile", "inPlace", " inFilename", "InFile", "inSourceFile", "binfile", " inSourceFile", "binFiles", "INfile", "outPlace", "inFiles", "inputfile", "binPlace", "InSourceFile", "INFile", "binFile", "outfile", "infile", "inputFiles", "inputPlace", "Infile", "inFilename"], "outFile": ["outFiles", " outFiles", " outfile", "outputFilename", "againPlace", " outPlace", "againFile", "outputPlace", "againfile", "outPlace", "inFiles", "outputfile", "outFilename", "againFilename", "outputFile", "outfile", "infile", " outFilename", "outputFiles", "inFilename"], "in": ["work", "x", "source", "as", "inn", "pin", "inner", "c", "f", "config", "i", "input", "image", "IN", "data", "m", "ini", "n", "io", "a", "url", "base", "name", "din", "is", "index", "ins", "connection", "In", "inc", "again", "like", "rin", "file", "part", "id", "reader", "bin", "ic"], "out": ["p", "x", "dot", "call", "buffer", "copy", "cache", "output", "client", "c", "w", "ex", "to", "OUT", "conn", "line", "image", "default", "data", "writer", "resource", "io", "n", "log", "name", "b", "null", "ext", "obj", "exec", "string", "external", "plain", "prefix", "Out", "write", "outs", "Output", "file", "version", "part", "o", "user", "v", "bin"], "inChannel": ["sinChan", "outchannel", " inConnection", "inChan", "iniLanguage", " inchannel", "inputChan", "inputChannel", "INChannel", "inLanguage", "INChan", "INStream", "outLanguage", "winChannel", "INSocket", "iniChannel", "inConnection", "outConnection", "winLanguage", "inichannel", " inChan", "sinChannel", "sinSocket", "iniStream", "INConnection", "inFlow", "sinFlow", "inchannel", "inputStream", "winchannel", " inSocket", "outChan", "INFlow", "outStream", "winStream", " inFlow", "INchannel", "inStream", "inSocket", "inputchannel"], "outChannel": ["outPath", "OutContext", "newStream", "outchannel", "OutChan", "inChan", " outStream", "againChan", "outputchannel", "outContext", "Outchannel", "newContext", "inPath", "inConnection", "outConnection", " outChan", " outchannel", "againChannel", "inchannel", "OutStream", "newChan", "outputChannel", "OutConnection", "newChannel", " outPath", "outChan", " outContext", "outStream", "outputChan", "OutChannel", "againPath", " outConnection", "againchannel"]}}
{"id1": "13122204", "id2": "4686922", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackFile", "UnzipProject", "unpatchProject", "unpackProject", "unzipProject", "unzipFile", "unarchiveProject", "unpackmodel", "unarchiveFile", "Unarchivemodel", "UnzipModel", "UnarchiveProject", "unpatchModel", "UnzipFile", "unarchiveModel", "unarchivemodel", "unzipmodel", "unpatchFile", "unpatchmodel", "UnarchiveModel", "unpackModel", "Unzipmodel", "UnarchiveFile"], "filename": ["source", "File", "fp", "uri", "path", "username", "kl", "download", "f", "model", "title", "il", "fil", "txt", "l", "src", "loc", "folder", "module", "location", "bf", "FILE", "directory", "url", "database", "name", "fd", "files", "fits", "jet", "SourceFile", "string", "fn", "Filename", "file", "utf", "nil"], "tempdir": ["TempDir", "TempDIR", " tempDir", " tempDIR", " temppath", "Tempdirectory", "Tempdir", "tempfolder", "tmpDir", "tmpdirectory", "tempDIR", "tmppath", "tmpdir", "temfolder", "tempDir", " tempfolder", "temdir", " tempdirectory", "tempath", "Tempfolder", "temppath", "temDir", "temdirectory", "tmpfolder", "tmpDIR", "tempdirectory"], "dest": ["source", "flat", "result", "prop", "output", "sync", "st", "session", "inner", "home", "store", " Dest", "nt", "txt", "de", "trans", "src", "rest", "cdn", "default", "loc", "walker", "folder", "done", "builder", "transform", "later", "export", "sup", "tmp", "log", "cont", "proc", "die", "transfer", "ui", "zip", "obj", "gen", "dist", "dat", "comb", "di", "exit", "handler", "usr", "test", "desc", "tar", "file", "temp", "std", "wb", "Dest", "walk", "dir", "opt", "target", "delete", "dc"], "fis": ["fsis", "fliss", "fiss", "filei", "flis", "fileis", " fid", " fiss", "fileisa", "fsbis", "filebis", "liss", "fileid", "lis", "flisa", "fid", "fisa", " fi", "li", "fbis", "fileiss", "fi", "lid", "flbis", "fsisa", "fsiss"], "BUFFER": ["MAFIX", "CUFF", "BUVEN", "MAFER", " BUFF", "SAPER", "TAVER", "BUVER", "MAPER", " BUFER", "SAUCK", "BOFIX", "UPVER", "UPVEN", "BOFFER", "BUFIX", "BOFER", " BUFIX", "TAPER", " BUUCK", "BOPER", "UPFF", "CUUCK", "BUPER", "CUFFER", "CUVEN", "SAFFER", "UPFFER", "BUFF", " BUPER", "TAFFER", "CUPER", "SAVER", "CUVER", " BUVER", " BUVEN", "BUFER", "BUUCK", "TAUCK", "MAFFER"], "zis": [" zas", "dbis", "zins", "jos", "zipis", "zii", "zipisa", " zIS", "xos", "zisa", " zii", "zipin", "xiss", "zIS", "yIS", "xii", "zipins", " zos", "Zisa", "zists", "jists", "yin", "diss", "zas", "xis", "ziss", "zos", "Zas", "jis", "zbis", "zipas", "ji", " zi", " zists", " zins", " ziss", "zipIS", "dii", "xbis", "xists", "xi", "yisa", "dis", " zbis", "Zins", "zin", "zi", "Zis", " zin", "yis", " zisa"], "entry": ["match", "ent", "source", "result", "se", "ace", "ry", "inner", "cat", "Entry", "info", "archive", "e", "ie", "nt", "de", "ident", "enter", "image", "cel", "line", "or", "record", "module", "ce", "la", "valid", "next", "si", "name", "ries", "pe", "ou", "lc", "spec", "ge", "server", "zip", "je", "rc", "li", "connection", "element", "file", "way", "porter", "part", "row", "pack", "feed", "her", "reader", "id", "end", "iterator", "inc", "jo"], "count": ["last", "buffer", "cache", "current", "length", "c", "f", "len", "use", "e", "i", "max", "pos", "line", "val", "read", "ind", "writer", "in", "core", "limit", "next", "base", "name", "log", "b", "allow", "add", "low", "code", "counter", "number", "time", "index", "list", "size", "Count", "cond", "coll", "write", "sum", "_", "weight", "iter", "file", "part", "key", "feed", "id", "end", "type", "start"], "data": ["message", "buffer", "result", "media", "str", "length", "DATA", "load", "shift", "info", "len", "bytes", "input", "pos", "image", "read", "record", "format", "zero", "next", "a", "base", "name", "array", "number", "dat", "body", "index", "size", "alpha", "write", "raw", "batch", "block", "value", "pack", "feed", "id", "reader", "start", "d", "la", "content"], "fos": ["xops", "bos", "foes", "xos", "dfos", "dfops", "afops", "foos", " fops", "dfoos", " fOS", "bops", " foes", "afis", "afOS", "afos", "xoes", " foos", "xoos", "fOS", "bOS", "bis", "fops", "dfoes"]}}
{"id1": "20073619", "id2": "1473212", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"getPagina": ["getPaguina", "getPaminate", "getChangine", "getPanginate", "getChagira", "getChaginate", "getPaginate", "getChagina", "getPangira", "getChagine", "getChangina", "getChangira", "getPamira", "getChanginate", "getPangine", "getPagine", "getPamina", "getPaguira", "getPamine", "getPagira", "getPangina", "getPaguine", "getPaguinate"], "strurl": ["strUrl", "StrUrl", "strURL", "wrstr", "wrstring", "ststr", "Strurl", "STRstring", "stristring", "wrURL", "arrhttp", "arrstr", "strhttp", "striURL", "stUrl", "sturl", "arrurl", "striurl", "Strstr", "arrUrl", "strstring", "wrurl", "STRstr", "sthttp", "STRURL", "Strhttp", "strstr", "STRurl", "stristr"], "resp": ["p", "lp", "ref", "ret", "result", "remote", "rec", "news", "json", "bb", "model", "page", "wp", "success", "serv", "conn", "rest", "default", "req", "www", "dest", "Resp", "reason", "Response", "host", "obj", "fe", "rep", "esp", "res", "api", "sp", "zip", "rss", "msg", "exp", "respond", "fr", "pretty", "coll", "comp", "respons", "html", "part", "err", "response", "pp", "rel", "rev", "rh", "esi", "cmp", "report", "content", "reply"], "url": ["ls", "source", "org", "gl", "buffer", "uri", "path", "Url", "f", "ball", "page", "e", "i", "l", "socket", "image", "web", "service", "resource", "open", "io", "base", "log", "inf", "b", "bel", "server", "job", "URL", "rl", "sl", "connection", "ur", "stream", "ll", "file", "ssl", "r", "entry", "user", "http"], "in": ["source", "as", "init", "into", "rec", "inn", "out", "gin", "cf", "inner", "c", "ac", "f", "s", "e", "i", "input", "l", "inside", "image", "IN", "ini", "con", "ar", "din", "b", "it", "is", "nin", "ins", "fr", "stream", "el", "lin", "In", "impl", "inc", "again", "file", "r", "err", "login", "id", "reader", "bin", "d", "doc"], "str": ["p", "text", "char", "rec", "arr", "st", "br", "c", "Str", "f", "s", "rr", "e", "i", "l", "line", "STR", "stri", "read", "data", "rs", "sr", "lc", "code", "obj", "cr", "wr", "sl", "sp", "dr", "cur", "string", "div", "fr", "enc", "cl", "pr", "coll", "raw", "iter", "tr", "err", "r", "reader", "doc"]}}
{"id1": "6470716", "id2": "949327", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"st": ["St", "ste", "est", "sb", "ist", "pt", "str", "ost", "Str", "f", "s", "ast", "stress", "src", "rest", "inst", "const", "ust", "www", "tt", "ST", "sth", "class", "stage", "code", "sc", "fe", "ft", "string", "struct", "fr", "ld", "sts", "cl", "put", "std", "t", "r", "sta", "sf", "id", "ct", "start", "d"], "url": ["ls", "source", "org", "gl", "uri", "path", "Url", "tool", "download", "f", "bb", "page", "pl", "link", "l", "image", "or", "build", "loc", "blog", "web", "hub", "open", "www", "base", "log", "bel", "b", "server", "host", "URL", "fl", "zip", "sl", "address", "string", "connection", "fr", "ur", "stream", "cl", "coll", "ll", "ul", "impl", "html", "file", "bug", "ssl", "feed", "err", "ob", "id", "user", "http"], "fis": ["fliss", "afIs", "Fiss", "fiss", "Fips", "bos", "FIS", "flis", "flIs", "flris", "flos", " fiss", " fips", "biss", "zIS", "fris", "Fos", "liss", "fips", "lis", "lris", "Fis", "bi", " fils", "Fris", "afis", " fi", "fils", "fIS", "zips", "afos", " fIS", "lils", "fli", "afiss", "fi", "fIs", "bis", "FIs", "flils", "zris", " fris"], "zis": [" zois", "zeis", "zenisi", "zeisa", "zipisi", "Zits", "zeips", "Ziss", "ezips", "zipi", "zipis", "zenais", " zIS", " zips", "zeIS", "zisa", "zIS", "zois", "ezis", "zipits", "qiss", "zisi", "zits", "zenois", "zipais", "ziss", " zais", "zipois", "ezisa", "qbis", " zi", "zbis", "ezIS", "Zais", "zips", "qis", " ziss", " zits", "zais", "qi", " zisi", "zipiss", "zipbis", " zbis", "zi", "Zis", "zenis", " zisa"], "entry": ["match", "ent", "result", "country", "se", "ace", "parse", "session", "ry", "cell", "inner", "cat", "Entry", "info", "archive", "extra", "nt", "ie", "e", "de", "ident", "enter", "image", "cel", "line", "or", "record", "in", "object", "comment", "next", "si", "sec", "ries", "pe", "lc", "spec", "ge", "obj", "zip", "address", "je", "li", "index", "rc", "exp", "fr", "element", "auto", "file", "part", "row", "r", "feed", "key", "sea", "reader", "inc", "la", "dc"], "count": ["buffer", "cache", "current", "depth", "length", "check", "c", "load", "len", "use", "i", "max", "skip", "line", "val", "read", "ind", "default", "limit", "base", "name", "log", "add", "allow", "code", "counter", "number", "child", "index", "list", "size", "Count", "write", "sum", "en", "_", "file", "more", "part", "feed", "id", "end", "type", "parent", "start", "offset"], "data": ["p", "text", "message", "buffer", "result", "cache", "str", "length", "DATA", "empty", "load", "shift", "info", "len", "buf", "bytes", "i", "input", "area", "image", "read", "zero", "a", "code", "number", "dat", "body", "string", "alpha", "size", "raw", "batch", "block", "value", "results", "feed", "reader", "start", "error", "d", "content"], "fos": ["fnos", "foses", "efosh", "dfosi", "efos", "efoses", "flos", "flol", "dfos", "fol", "FOS", "flOS", "Fos", "zol", "dfosh", "froses", "Fol", "Fnos", "frosi", "frosh", "zos", "flnos", "efosi", "fosh", "znos", "zOS", "fOS", "fosi", "dfoses", "fros"], "dest": ["source", "style", "result", "prop", "output", "out", "sync", "flash", "inner", "home", "txt", "de", "trans", "src", "rest", "cdn", "default", "loc", "des", "const", "writer", "done", "transform", "later", "img", "sup", "tmp", "cont", "outer", "die", "zip", "south", "dist", "dat", "wh", "comb", "dev", "di", "stream", "exit", "sum", "test", "desc", "coord", "std", "temp", "wb", "Dest", "slice", "end", "target", "dc"]}}
{"id1": "21182766", "id2": "6890417", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["call", "init", "create", "loading", "copy", "set", "parse", "path", "loaded", "check", "update", "config", "download", "info", "store", "use", "construct", "dump", "read", "install", "loader", "process", "resources", "build", "resource", "Load", "find", "class", "add", "proc", "setup", "loads", "write", "save", "include", "pack", "get", "start", "delete", "LOAD"], "propsName": ["propsname", "pepsName", "pepsNames", "propertiesPath", "comppsname", "comppsDesc", "proPSDesc", "pepertiesPath", "profsDesc", "propsDesc", "proPSPath", "comppertiesName", "propertiesname", "pepertiesName", "pepsPath", "propertiesNames", "propsNames", "propertiesDesc", "profsname", "proPSNames", "profsName", "pepertiesNames", "comppertiesPath", "propsPath", "proPSname", "comppertiesname", "comppsName", "comppertiesDesc", "proPSName", "pepsname", "pepertiesname", "propertiesName", "comppsPath", "profsPath", "profsNames"], "props": ["propps", "preps", "perds", "crops", "procs", "Procs", "prets", "prids", "cropps", "protpps", "comppos", "pecs", "prps", "probs", "perpos", "prips", "prots", "pebs", "prebs", "compps", "pripos", "pribs", "protpr", "croperties", "propos", "prpps", "compbs", "perbs", "propr", "perps", "Props", "peps", "prperties", "compds", "pets", "precs", "prods", "protps", "prpr", "protperties", "Probs", "properties", "Prots", "cropr"], "url": ["source", "ref", "gl", "buffer", "uri", "browser", "path", "Url", "f", "config", "not", "page", "event", "e", "i", "l", "src", "loader", "data", "service", "resource", "location", "base", "name", "bel", "b", "server", "URL", "fl", "sl", "api", "channel", "stream", "cl", "file", "r", "feed", "ssl", "ob", "id", "user", "xml", "jar", "http"]}}
{"id1": "21181542", "id2": "14093044", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "label": 1, "substitutes": {"deleteRoleType": ["deleteResourceTypes", " deleteroleTyp", "deleteResourcetype", "deleteRoletype", " deleteroletype", " deleteRoleTypes", "deleteroleType", "deleteroletype", "deleteRoleTypes", " deleteRoletype", " deleteRoleTyp", "deleteFunctionTyp", "deleteroleTypes", "deleteFunctionTypes", "deleteFunctionType", " deleteroleTypes", "deleteFunctiontype", "deleteRoleTyp", "deleteroleTyp", " deleteroleType", "deleteResourceTyp", "deleteResourceType"], "id": ["source", "edit", "kid", "uid", "Id", "rid", "uri", "length", "path", "f", "info", "model", "view", "i", "ident", "data", "in", "object", "vid", "ip", "error", "url", "name", "it", "code", "is", "mid", "address", "index", "string", "connection", "lock", "section", "oid", "ID", "sid", "pid", "like", "version", "request", "part", "key", "aid", "end", "type", "parent", "start", "ids"], "namespaceId": ["namesaneId", "NamespaceName", "membersetid", "namespacedPath", "namesentityID", "namesaneid", "worksspaceKey", "namesplaceID", "namesetID", "namesetId", "namesaceType", "namespacesID", "memberspaceType", "asentityId", "namesaceid", "asentityInfo", "Namespacedid", "namesplaceInfo", "worksspaceInfo", "namesentityName", "NamespaceType", "namesetInfo", "namespacedName", "namesaceInfo", "namespaceInfo", "memberspaceid", "workspaceid", "asentityName", "aspaceID", "workspaceType", "namesaceId", "aspaceName", "namesentityId", "namesspaceInfo", "namespacesName", "workspacesId", "namespacesid", "namespaceName", "worksspaceId", "namesenceContext", "membersetType", "nsaceid", "workspaceInfo", "namespacesId", "nsaceID", "nsaceId", "nspaceId", "nspaceid", "aspaceInfo", "nspaceID", "namesplaceId", "workspaceKey", "memberspaceId", "namespacedInfo", "namesentityInfo", "namesaceContext", "workspaceContext", "namespacesInfo", "namesaneType", "namespaceType", "namespacedid", "asentityID", "namespaceKey", "NamespacedName", "namesplaceid", "Namespaceid", "NamespacedId", "NamespaceId", "namesetType", "namesaceID", "workspacesContext", "aspaceId", "namespacesType", "namespacesPath", "namesspacePath", "workspacesType", "namespaceid", "namesetid", "namespaceContext", "worksspacePath", "namespacesContext", "namespaceID", "namesaneName", "membersetName", "namespacesKey", "namespacePath", "namesenceId", "namesspaceId", "namespacedId", "membersetId", "namesetName", "namesspaceKey", "namesenceType", "namespacedKey", "workspaceId", "nsaceInfo", "workspacesid", "namespacedType", "memberspaceName", "nspaceInfo", "NamespacedType", "namesenceid", "workspacePath"], "removeReferencesInRoleTypes": ["removeReferencesInServiceTypes", "removeReferencesFromRoleType", "removeReferencesFromroleTypes", "removeReferencesInroletypes", "removeReferencesedInRoleNames", "removeReferencesFromroleType", "removeReferencesFromRoleTypes", "removeReferencesInroleType", "removeReferencesFromroleRelations", "removeReferencesFromRoleRelations", "removeReferencesInRoletypes", "removeReferencesInRoleRelations", "removeReferencesInServiceType", "removeReferencesInroleTypes", "removeReferencesFromRoleNames", "removeReferencesInRuletypes", "removeReferencesInroleNames", "removeReferencesFromroleNames", "removeReferencesedInroletypes", "removeReferencesedInRoleTypes", "removeReferencesInRuleRelations", "removeReferencesInRuleNames", "removeReferencesedInroleTypes", "removeReferencesedInroleType", "removeReferencesInServiceNames", "removeReferencesInServiceRelations", "removeReferencesedInroleNames", "removeReferencesedInRoletypes", "removeReferencesedInRoleType", "removeReferencesInRuleType", "removeReferencesInRoleType", "removeReferencesInroleRelations", "removeReferencesInRoleNames", "removeReferencesInRuleTypes"], "permit": ["perit", "PERmission", "recmit", "Permits", "Permission", "PERmit", "permMIT", "permmit", "PERmissions", "permmissions", "recmits", "permits", "Perit", "permission", "recmission", "perMIT", "recit", " permits", "PerMIT", "PERMIT", " perit", "Permissions", " permission", "permissions", "permmission", "Permit"], "exist": ["match", "form", "edit", "create", "ist", "stick", "check", "continue", "update", "existing", "front", "purpose", "ident", "keep", "present", "icate", "destruct", "existent", "cont", "add", "destroy", "fill", "know", "index", "list", "existence", "write", "fail", "delete", "inc", "include", "register", "support", "diff", "apply", "same", "start", "cmp", "draw", "except"], "msgBuf": ["msgBUF", "msgDuf", " msgFuf", "msgDuff", "msgEBuf", "msgFBUF", "msgPlundle", "msgCbuf", "msgBbuff", "messageBbuf", "msgFaf", "msgLob", " msgLuf", "msgFBuf", "messageFbuf", "messageAuff", "msgFob", "msgEBbox", "msgAuff", "messageFuff", "messageAbuf", "msgCuf", "msgLUF", " msgFbuf", "msgLaf", "msgAbuf", "msgAaf", " msgFbuff", "msgFraf", "messageBob", "msgBuff", "msgFbuf", " msgFaf", " msgBbuf", "msgFuff", "msgDBbuf", "msgDBuff", "msgLuf", "msgBaf", " msgBuff", "messageFuf", " msgBraf", "msgAbox", "msgAraf", " msgLundle", "msgFBob", "msgFbuff", "msgCob", "msgFUF", "msgEBuff", "msgDbuf", "msgBob", " msgBundle", "msgAob", "msgLuff", "msgEBbuf", "msgPluf", "msgFuf", "messageBuf", "msgBbox", "msgBundle", "msgAuf", " msgBaf", "messageFUF", "messageFbox", "messageBuff", "msgDBUF", "messageAUF", "msgAUF", "msgFundle", "msgPluff", " msgFuff", "msgFbox", " msgFraf", " msgLuff", " msgLaf", "messageBUF", "msgPlaf", "msgAbuff", "msgFBuff", "msgLundle", "msgBraf", "msgDaf", " msgBbuff", "messageBbox", "msgBbuf", "msgCuff", "messageFob", "msgDBuf", "messageAuf"], "objects": ["relations", "frames", "types", "parts", "apps", "archs", "locks", "cats", "lines", "agents", "bugs", "jobs", "kids", "keys", "actions", "groups", "notes", "projects", "resources", "organisms", "names", "pps", "parents", "object", "products", "children", "cells", "values", "archives", "ks", "oids", "pins", "os", "boxes", "obj", "files", "members", "features", "links", "models", "ins", "points", "plugins", "users", "owners", "properties", "obs", "results", "items", "classes", "blocks", "people", "ids", "articles", "images", "roots", "phones", "ops"], "sqlRightId": ["SQLRightid", "SQLRightRef", "SQLRestRef", "SQLRightId", " sqlrightPoint", "sqlRestId", "SQLRestID", "sqlrightType", "sqlRRef", "sqlRID", "sqlLeftPoint", " sqlrightId", "SQLRestid", "sqlrightid", " sqlrightType", "SQLRightID", "sqlLeftId", " sqlRightType", "sqlLeftid", " sqlRightid", "sqlRightType", "SQLRestId", "sqlRestRef", " sqlrightid", "sqlrightId", "sqlRid", "sqlRestid", " sqlRightPoint", "sqlRestID", "sqlRightID", "sqlrightPoint", "sqlRightPoint", "sqlRId", "sqlRightRef", "sqlRightid", "sqlLeftType"], "sqlParent": ["qlParents", "qlParent", "sqlParents", "suRoot", "suparent", "qlRoot", " sqlParents", " sqlRoot", " sqlparent", "suParent", "sqlRoot", "qlparent", "sqlparent", "suParents"], "sql": ["session", " SQL", "update", " session", "ql", "s", "link", "conn", " db", "where", "dl", "description", "url", " msg", "log", "SQL", " url", "msg", "operation", "sl", "db", "repl", " params", "acl", "replace", "error", "select", "delete"], "pstmt": [" pstnt", "postmr", "Pcttr", " pndmb", " postmr", "s", "pstatnt", "pStm", "pstatmr", "pftr", " pStct", "pstatmt", "add", "pndmt", "postct", "pctmd", "All", "The", "pcttr", "pmtmd", "pctbl", " postmt", " postnt", "pstct", "Pctct", "this", "pctmr", "pmttr", "psttr", "pctmb", "Pstmt", "pstmd", "pndct", "pndbl", "pctm", "pstatct", "pstnt", "pstrmt", " pStmt", "_", "Security", "pfmt", "Pctmt", "pmtct", "pfmd", " pSttr", "Psttr", "New", "Error", "pstrtr", "pmtmb", " pstmb", "Pctmd", "pstmr", "pstrm", "pfct", "pSttr", "pmtmt", "pctmt", "pStmt", "Delete", " pndct", "delete", " pStm", "pctct", "pmtbl", "pctnt", "Pstct", " psttr", "pstm", "postnt", " pstm", " pstbl", "pstrct", "Pstmd", " pndmt", "pndmb", "postmt", "pStct", "pstbl", " pndbl", " postct", " pstct", "pstmb", " pstmr"], "typeGid": ["TypeCname", "typeGUid", "typeWid", "typeGVoid", "linkGname", "TypeGname", "typegname", "typeCname", "typeGID", "typeGUID", "linkGID", "typeGUname", "typeAccid", "TypeCmin", "typeGmin", "typeWmin", "typeGoid", "typeGUoid", "typeAccmin", "TypeCID", "typeCmin", "linkGid", "typegID", "typeWname", "typeGname", "linkGVname", "TypeGmin", "linkGVID", "typeCid", "TypeGID", "typegid", "linkGVoid", "TypeCid", "typeGVname", "typeAccID", "typeCID", "TypeGid", "typegoid", "typeAccname", "typeWID", "typeGVID", "linkGoid", "linkGVid", "typeGVid"], "defaultLevel": ["configDepth", "DefaultLevel", " defaultCl", "DefaultMode", "defaultCl", " defaultMode", " defaultDepth", "DefaultDepth", "DefaultCl", "configMode", "configLevel", "configCl", "defaultDepth", "defaultMode"], "success": ["match", "message", "result", "continue", "successful", "reg", "successfully", "Success", "complete", "resp", "data", "warning", "progress", "accept", "submit", "fail", "batch", "serial", "replace", "failed", "test", "results", "response", "roll", "launch", "error", "status"]}}
{"id1": "7809093", "id2": "6840241", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["GetData", "requestBody", "GetBody", "GetEntity", " getData", "getBody", " getBody", "setBody", "responseEntity", "setData", "setContent", "responseOutput", "GetOutput", "requestEntity", "GetContent", "getOutput", "responseBody", "requestOutput", "setEntity", "getEntity", " getEntity", "getData", "responseContent", "requestContent"], "request": ["message", "method", "result", "position", "uri", "current", "path", "instance", "http", "e", "input", "req", "data", "q", "object", "resource", "QUEST", "url", "name", "server", "query", "address", "operation", "string", "connection", "handler", "queue", "reference", "route", "r", "user", "type", "xml", "Request", "report", "application"], "sb": ["lp", "ls", "bh", "buffer", "su", "ab", "fp", "xb", "SB", "cb", "obb", "bb", "fb", "bj", "lab", "sg", "pb", "src", "abi", "bp", "ib", "zb", "binary", "bf", "lb", "sa", "sup", "bc", "bt", "b", "vm", "usb", "nb", "bs", "bg", "rb", "eb", "gb", "sk", "bm", "BB", "amb", "bsp", "wb", "sf", "db", "abb", "bd"], "client": ["p", "contact", "call", "app", "remote", "util", "cache", "output", "current", "uri", "Client", "session", "net", "c", "config", "tc", "https", "per", "console", "apache", "conn", "project", "bird", "default", "application", "con", "web", "service", "proxy", "builder", "ce", "resource", "force", "connect", "url", "server", "host", "api", "container", "connection", "channel", "handler", "cl", "plugin", "queue", "cli", "ssl", "context", "http"], "httpParams": ["HttpParamas", "httpArums", "httpPamer", "HTTPPoparams", "httpPARams", "httpPareters", "httpPoamer", "HTTPPARam", "httpPramer", "HTTPPARams", "HTTPParparams", "httpPeram", "HTTPPareters", "HTTPParamer", "httpPreters", "httpPARamas", "httpArams", "httpPrams", "httpPeramas", "httpParums", "HttpParparams", "httpPoams", "HTTPPoams", "httpPrparams", "httpPARums", "HttpParam", "httpParcs", "HTTPPARcs", "httpParamer", "httpPoeters", "httpPeters", "httpPams", "HTTPPoeters", "HTTPPARums", "httpParparams", "httpArcs", "HTTPParams", "httpParam", "HTTPParcs", "httpPerams", "httpPARparams", "httpPoparams", "httpPerparams", "httpParamas", "httpPARam", "HTTPParam", "HTTPParums", "HTTPPoamer", "httpPparams", "httpAram", "HttpParams", "httpPARcs"], "response": ["message", "relation", "result", "output", "json", "successful", "model", "http", "view", "page", "success", "resp", "data", "object", "resource", "reply", "document", "server", "Response", "api", "body", "onse", "connection", "respond", "received", "collection", "feed", "results", "error", "report", "status", "application"], "entity": ["source", "ent", "result", "media", "output", "json", "translation", "instance", "company", "environment", "model", "event", "component", "person", "e", "conn", "xml", "application", "data", "writer", "agent", "object", "resource", "ce", "node", "document", "em", "pe", "server", "article", "address", "api", "body", "connection", "channel", "element", "coll", "creator", "file", "collection", "entry", "type", "Entity", "content", "http"], "reader": ["source", "rx", "buffer", "reading", "ry", "inner", "rr", "rar", "ler", "i", "per", "input", "driver", "bird", "read", "loader", "writer", "oder", "ner", "in", "io", "editor", "rer", "server", "worker", "stream", "handler", "parser", "Reader", "iter", "row", "r", "er", "ser", "feed", "iterator", "ri"], "line": ["source", "message", "lf", "char", "Line", "lines", "str", "sync", "cell", "non", "len", "page", "model", "pass", "link", "word", "l", "inline", "val", "data", "definition", "comment", "ip", "url", "character", "name", "base", "no", "lc", "job", "code", "ge", "sel", "sl", "li", "string", "header", "LINE", "cl", "lin", "el", "layer", "block", "iter", "row", "key", "r", "feed", "entry", "id", "end", "le", "user", "unit", "content"]}}
{"id1": "18631594", "id2": "2525897", "code1": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"getMD5_Base64": ["getMD5_Base58", "getMD5Bybase64", "getMD5_SHA64", "getMD5_base8", "getMD5ByBase64", "getMD5_Meta58", "getMD5_base64", "getMD5_Base62", "getMD5Bybase62", "getMD5_SHA58", "getMD5_Base8", "getMD5_Meta8", "getMD5Bybase8", "getMD5_base62", "getMD5ByBase62", "getMD5_Meta64", "getMD5_SHA62", "getMD5_base58", "getMD5_Meta62", "getMD5ByBase58", "getMD5ByBase8", "getMD5_SHA8", "getMD5Bybase58"], "input": ["text", "source", "form", "buffer", "output", "str", "out", "empty", "s", "this", "plus", "Input", "i", "inside", "image", "IN", "data", "in", "format", "accept", "document", "url", "base", "inf", "array", "null", "password", "address", "string", "list", "alpha", "prefix", "addin", "raw", "value", "file", "temp", "request", "ssl", "reader", "type", "xml", "pattern"], "msgDigest": ["msgSignEST", "docdigest", "MsgDigested", "msgdigend", "MsgDested", "cmdDigest", "MsgDigest", "msgMixested", "msgCommener", "msgdigEST", "MsgDener", "msgDEST", "msgPullest", "MsgDest", "msgDigester", " msgSignester", "MsgDigester", "msgDigested", " msgDigend", "docDigender", " msgSignEST", "docdigested", "msgDested", "msgDer", "msgSignester", "cmddigex", "msgMDEST", " msgSignest", "MsgDester", "msgDend", "msgSignend", "msgDigend", "msgDest", "msgPullester", "docdigEST", "msgdigender", "cmdDigex", "msgDigEST", "msgPullex", "cmddigester", "docDigested", "cmddigest", "msgDigender", "msgDester", "docdigender", "msgMDender", "msgCommested", "msgdigested", "cmdDigester", "cmddiger", "MsgDigener", "docDigest", "cmdDiger", "msgDigex", "msgMixester", "msgCommester", " msgDigester", "msgdigester", "msgdigex", "msgPuller", "msgDener", "msgDiger", "msgSignest", "msgMDested", "msgMixest", "msgDigener", "msgMDest", "docDigEST", "msgDex", "msgdigest", "msgdiger", " msgDigEST", "msgCommest", " msgSignend", "msgMixener"], "rawData": ["RAWByte", "RawText", " rawString", " rawText", " rawByte", "packageData", "RAWBytes", "rawBytes", "packageText", "RawCode", "RAWData", "RawString", " rawCode", "packageString", " rawBytes", "rawByte", "RawBytes", "rawText", "RawData", "RawByte", "rawString", "rawCode", "RAWCode"], "encoded": ["engoded", "Encoding", "Encrypted", "decoded", "eccoded", "enccoded", "engrypted", "encoder", "decrypted", "Encoded", "enoded", "enoding", "Enccoded", "engcoded", "encrypted", "ecoding", "enoder", "ecoded", "decoder", "encoding", "decoding", "engoding", "Encoder", "enrypted", "ecrypted"], "retValue": ["RetString", "RetValue", " retValues", "newString", "returnValue", "newData", "resultString", "retString", "returnVal", "resultValues", "resultValue", " retText", "retText", " retVal", "returnString", "retData", "RetData", "RetText", "retVal", "newText", "newValue", "returnValues", "retValues", " retData", " retString", "resultVal"]}}
{"id1": "14877116", "id2": "4118412", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": [" copyFile", "cpfile", " cpfile", "CopyFile", " cpFiles", " cpCode", " copyCode", "Copyfile", "CopyFiles", " copyfile", "cpCode", "cpFiles", "CopyCode", " copyFiles"], "source": ["remote", "current", "se", "client", "token", "table", "path", "config", "this", "use", "view", "seed", "archive", "component", "ources", "ource", "image", "SOURCE", "project", "Source", "service", "object", "from", "resource", "ce", "Target", "force", "self", "dest", "directory", "document", "url", "base", "name", "subject", "database", "null", "server", "host", "zip", "secure", "grade", "scene", "string", "connection", "scope", "channel", "stream", "element", "reference", "iter", "file", "route", "slice", "template", "site", "unit", "type", "parent", "start", "node", "context"], "target": ["top", "remote", "result", "copy", "tor", "table", "current", "port", "token", "client", "path", "sync", "output", "download", "config", "alias", "home", "archive", "component", "master", "tail", "nt", "root", "owner", "to", "arget", "project", "ource", "global", "service", "object", "Target", "resource", "other", "format", "transform", "force", "self", "dest", "proxy", "director", "next", "url", "base", "name", "database", "folder", "null", "it", "server", "host", "connection", "external", "origin", "range", "reference", "iter", "file", "route", "template", "site", "boot", "type", "parent", "content"], "replace": ["match", "reset", "copy", "re", "sync", "cover", "flash", "update", "store", "use", "place", "compatible", "root", "move", "complete", "inline", "follow", "other", "force", "placed", "rm", "share", "allow", "change", "add", "multiple", "array", "split", "append", "fill", "align", "repeat", "repl", "write", "only", "range", "insert", "include", "route", "protect", "remove", "stall", "apply", "same", "delete", "hide", "rel", "reply"], "bufferSize": ["byteLen", "serverLen", " bufferCount", "bytesize", "flushSize", "buffersize", " buffersize", "queueSize", "serversize", "byteSize", "flushsize", "queuesize", "serverSize", " bufferLen", "flushLen", "queueLen", "bufferCount", "bufferLen", " bufferSIZE", "flushSIZE", "bufferSIZE", "serverSIZE", "queueCount", "byteCount"], "src": ["result", "sb", "copy", "rec", "sync", "flash", "gz", "archive", "ources", "input", "ource", "socket", "inst", "loc", "RC", "req", "Source", "sys", "in", "resource", "proxy", "sr", "dest", "reflect", "url", "tmp", "bc", "proc", "server", "obj", "sel", "sc", "zip", "sl", "secure", "sub", "rc", "rb", "cur", "fn", "gb", "stream", "sh", "sq", "ruby", "rt", "ssl", "ser", "ctx", "start", "cb"], "tarn": ["taur", " treen", "taron", "yarn", "ttarp", "ttaro", "tron", "wtern", "Treen", "ttarm", "taran", "treen", "trn", "ttern", " taron", "ttrn", "wtaran", "ntaron", "etann", " tern", "yaran", "thern", "ttann", "ntann", "ttarn", "wtarn", " tarm", "Tann", " tron", "Tarm", "tann", "tharn", "yern", "ttaron", "Trn", "tern", "taro", "Taran", " taro", "wtarm", " tarp", "ttron", "ntarp", "yarm", "ttaur", "ntarn", "tharo", " taur", "Tron", "etarn", "Tarn", "tarm", " trn", "etaran", " taran", "etreen", "tarp", " tann", "thaur"], "tardir": ["tarddir", "tardedpath", "tartdir", "tartart", "tarpirt", "tartirs", "tartire", "tartirt", "tardsar", "tarir", "tarart", "Tartir", "tardire", "tildart", "sardar", "sardirt", "tardsire", "sardsar", "Tartart", "tartar", "tardiri", "Tartiri", "tardirs", "tarpar", "tildir", "tarpire", "tartpath", "tardsdir", "Tartdir", "tardsir", "tardeddir", "tartiri", "tariri", "Tardirs", "sardire", "Tardiri", "tarar", "sardsire", "tildiri", "Tartpath", "Tardir", "Tarddir", "tardsirs", "sardsir", "tartir", "Tardpath", "Tartar", "sardsirt", "tardedir", "tardedirs", "Tardart", "tardart", "Tartirs", "Tardar", "sardir", "tardirt", "tarpir", "tildar", "tardar", "tardpath", "tardspath", "tardsirt"], "n": ["p", "x", "ln", "z", "c", "ni", "nt", "i", "e", "l", "k", "conn", "norm", "N", "nor", "none", "m", "nl", "in", "ne", "g", "nn", "u", "num", "nb", "number", "na", "nu", "j", "min", "nc", "fn", "pn", "mn", "rn", "ng", "nw", "coll", "en", "un", "sn", "ns", "cn", "dn", "o", "v", "d", " i"], "tar": ["buffer", "shape", "copy", "cloud", "large", "ray", "flash", "csv", "cat", "tc", "archive", "gz", "rar", "trans", "war", "ca", "skip", "tan", "box", "sr", "dest", "ar", "tmp", "cos", "tif", "transfer", "cr", "zip", "cro", "Tar", "tg", "dr", "par", "shr", "tf", "di", "safe", "sum", "sh", "test", "ra", "tr", "file", "temp", "pack", "sv", "raf", "jar", "car"], "bytes": ["frames", "ls", "nets", "bles", "eps", "Bytes", "ps", "words", "lines", "out", "bits", "keys", "seconds", "vals", "les", "resources", "ones", "data", "ipes", "vs", "bps", "cells", "io", "values", "pieces", "b", "os", "objects", "files", "bs", "reads", "steps", "pages", "outs", "runs", "es", "tes", "items", "classes", "boot", "blocks", "rows", "ops"], "readn": ["runns", "findne", "findN", "findn", "Readn", "writelen", "ReadN", "writen", " readl", "readN", "writene", "passns", "readno", " readlen", "Readl", "writeno", "runl", "readns", "writeN", " readN", "runlen", "runn", "runN", "readne", "Readlen", "passN", "readl", "passn", "passno", " readne", "findlen", "writens", "runno", "readlen"]}}
{"id1": "5061606", "id2": "3731077", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNeceseless", "createSettingsIfNequessary", "createSettingsIfNequessarily", "createSettingsIfNececary", "createSettingsIfNecccesseless", "createSettingsIfNequesseless", "createSettingsIfNequccessary", "createSettingsIfNecesnecessary", "createSettingsIfNequccesseless", "createSettingsIfNecessnecessary", "createSettingsIfNecccessnecessary", "createSettingsIfNececarily", "createSettingsIfNequccessnecessary", "createSettingsIfNececeless", "createSettingsIfNecccessarily", "createSettingsIfNequccessarily", "createSettingsIfNecesseless", "createSettingsIfNequessnecessary", "createSettingsIfNecesarily", "createSettingsIfNececnecessary", "createSettingsIfNecesary", "createSettingsIfNecccessary", "createSettingsIfNecessarily"], "out": ["source", "group", "init", "app", "result", "cookie", "copy", "cache", "output", "sync", "client", "path", "net", "at", "config", "this", "model", "page", "timeout", "ex", "i", "socket", "OUT", "conn", "image", "by", "data", "writer", "object", "io", "up", "editor", "a", "window", "url", "log", "name", "array", "null", "server", "obj", "pool", "exec", "password", "index", "connection", "channel", "lock", "prefix", "plain", "exit", "Out", "write", "plugin", "outs", "again", "off", "file", "parent", "err", "o", "user", "flush", "bin", "error"], "fSettings": ["Fsettings", "fsSetup", "sfSettings", "FConfig", " fConfig", "FSetting", "sfsettings", " fSetting", "sfettings", "fsSetting", "fileSetting", "FSetup", "fmSetup", " fJs", "fmConfig", "fettings", "rfConfig", "fsConfig", "filesettings", "rfFs", "fSetting", "fmSetting", "rfSetting", "fsSettings", " fsettings", "fConfig", "sfJs", "fmSettings", "fsFs", " fettings", "sfSetting", "FJs", "rfSettings", "fSetup", "fFs", "FSettings", "fJs", "fileettings", "fileSettings", "fsettings", " fFs"], "src": ["attr", "source", "text", "ref", "filename", "sb", "lower", "fp", "str", "uri", "st", "uc", "path", "config", "ource", "loc", "req", "prot", "img", "dest", "sr", "storage", "url", "base", "tmp", "b", "sel", "sc", "sub", "sl", "dist", "rc", "rb", "ins", "string", "gb", "cur", "stream", "ctr", "settings", "file", "route", "ssl", "cb"], "in": ["source", "init", "copy", "gin", "inn", "path", "inner", "c", "f", "s", "i", "input", "l", "image", "sin", "IN", "data", "ini", "win", "con", "n", "bin", "url", "b", "index", "ins", "connection", "thin", "stream", "In", "inc", "again", "rin", "file", "kin", "r", "err", "login", "id", "reader", "din"]}}
{"id1": "9236363", "id2": "17729554", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"unJarStart": ["syncJarRest", "syncServerRest", "copyjarRest", "copyServerEnd", "copyJarPath", "syncJarStart", "copyZipEnd", "copyServerPath", "copyZipRest", "syncServerPath", "copyjarPath", "copyJarEnd", "syncServerEnd", "copyJarStart", "copyJarRest", "copyjarStart", "syncJarEnd", "copyjarEnd", "syncJarPath", "copyZipPath", "copyZipStart", "syncServerStart", "copyServerStart", "copyServerRest"], "jarPath": [" jarUrl", "relFile", "JarCh", "javaPath", " jarpath", "badUrl", "JarPath", "badPath", "javaText", "jarContent", "jarLog", " jarText", "Jarpath", "garContent", " jarName", "jamPath", "narPath", "relEntry", "badpath", "JarFile", "garPath", "zipPath", "archivepath", "garpath", "javaCh", "narpath", "javaLog", "zippath", "garUrl", "garText", " jarFile", " jarLog", " jarContent", "archiveLog", "archiveDir", "javaUrl", "badLog", "garFile", "JarContent", "jamLog", "jamDir", "jarpath", "jarUrl", "javapath", "javaName", "jarCh", "jarText", " jarDir", "javaEntry", "jarName", "relpath", "jarDir", "jampath", "jarFile", "javaFile", "zipEntry", "zipFile", "narCh", "archivePath", "JarName", "narName"], "jarEntryStart": ["jarFileStart", "tarentryPart", "jarFileFinish", " jarEntrySource", "jarEntName", "tarentryName", "jarEntryFollow", "jarImportPart", "tarEntrySource", "jarentryName", "jarAttemptStart", "tarEntryName", "jarFileEnd", "tarentryStart", " jarEntryPart", "jarPartEnd", "jarEntryEnd", "jarentrySource", "jarImportFollow", " jarImportPart", " jarFileEnd", " jarImportStart", "jarPartStart", "jarEntSource", "jarAttemptPart", " jarImportFollow", " jarImportEnd", "jarPartPart", "jarImportSource", "jarEntryName", "jarEntrySource", "jarImportStart", "jarAttemptEnd", "jarEntStart", "tarEntryStart", "tarEntryPart", " jarEntryEnd", "jarImportFinish", " jarFileFinish", "jarImportName", "jarFileSource", "jarentryPart", "jarEntryPart", " jarFileName", "jarImportEnd", " jarEntryName", "jarEntryFinish", "tarentrySource", " jarEntryFinish", "jarAttemptFollow", " jarFilePart", "jarentryStart", "jarEntPart", "jarFileName", "jarPartFinish", "jarFileFollow", " jarFileSource", " jarEntryFollow", "jarFilePart", " jarFileStart"], "path": ["work", "text", "source", "cookie", "cache", "json", "session", "config", "PATH", "image", "default", "loc", "left", "location", "dest", "directory", "url", "base", "name", "log", "code", "ith", "zip", "temp", "key", "template", "dir", "type", "ion", "ctx", "error", "pattern", "mode", "uri", "clean", "home", "root", "ath", "po", "conn", "data", "object", "graph", "api", "test", "mount", "id", "parent", "method", "prop", "output", "Path", "wd", "folder", "resource", "next", "string", "prefix", "step", "boot", "content", "p", "th", "inner", "system", "archive", "pass", "pointer", "ph", "it", "host", "patch", "ha", "file", "request", "route", "then", "right", "context"], "relPath": ["relativeName", "relativePath", " relPos", " relName", "Relpath", "RELPos", "relativeDir", "RELPath", " relDir", "relativePos", "relDir", " relpath", "RelDir", "relName", "RELpath", "relPos", "relpath", "RelName", "RelPath", "RELName", "relativepath"], "jar": [" manifest", "pipe", "cookie", " parser", "ssl", "cache", "browser", "parse", "bar", "bag", "keeper", "com", "ball", "archive", "java", "rar", "ler", "per", " war", "war", "Jar", "drop", "sheet", "magic", "car", "module", "folder", "gap", "open", "sr", "ar", " dir", "url", "log", "fire", "server", " module", "ge", "zip", "sl", "sp", "dr", " tar", "plugin", "spin", "tar", " archive", "space", "start", "ser", "pack", "dir", " capsule", "er", "tab", "her", "mag", "xml", "pkg", "jo", "zone", " java"], "entries": ["quents", "enders", "entryries", "Entrys", "counters", "entryers", "antry", "Enties", "Entry", "countries", "antlements", "entEntry", "ientlements", "entryEntry", "Entursions", "itories", "ientries", "iters", "ENTents", "Entlements", "entensions", "entents", "quies", "itrys", "adders", "countensions", "entrys", "enters", "ientursions", "enties", "itries", "ENTies", "Enters", "quries", "entryensions", "endries", "entursions", "addries", "countEntry", "addensions", "antursions", "Entries", "ENTlements", "ENTries", "antries", "Entents", "addEntry", "endrys", "entories", "Entories", "entlements", "endories", "ientry", "qulements"], "entry": ["ent", "pie", " Entry", "se", "parse", "ry", "cat", "Entry", "e", "ie", "ler", "de", "enter", "cel", "oe", "or", "lie", "module", "resource", "ce", "la", "be", "name", "ries", "add", "mer", "it", "server", "ge", "obj", "zip", "address", "je", "element", "part", "r", "pack", "key", "reader", "jo"], "jarEntry": ["javaRule", "serFile", "celRule", "javaPath", "archiveRule", "jarEnt", "jobImport", "jobEntry", "javaentry", "jobentry", " jarEnt", "carEnt", " jarImport", "jarRule", "jobPath", " jarentry", "celEntry", "carElement", "archiveEntry", "javaElement", "archiveElement", "carPath", "archiveName", "javaName", "javaImport", "celFile", "javaEntry", "archiveFile", "jarName", "serEntry", "jarentry", "archiveEnt", "jarFile", "javaFile", "celEnt", " jarElement", "jarImport", "serName", "javaEnt", "jarElement", "carEntry", "serElement"], "ze": ["se", "z", "zer", "aze", "e", "ie", "kee", " ace", "cel", "ZE", "zy", "za", "ce", "ne", "ke", "be", "ide", "jo", "ja", "pe", "te", "code", "ge", "zip", " je", "sl", "fe", "zo", "li", "je", "zie", "zes", "ine", "zen", "xe", "ipe", "le", "zi"], "bin": ["init", "inn", "bar", "abin", "pin", "inner", "bb", "gi", "info", "len", "bas", "sin", "abi", "data", "ini", "in", "win", "resource", "proxy", "binary", "bot", "bi", "isin", "arin", "bit", "base", "log", "vin", "bn", "zip", "body", "index", "bank", "lock", "di", "cin", "plugin", "spin", "lib", "file", "kin", "login", "boot", "zone", "bis"]}}
{"id1": "17791385", "id2": "11377441", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "src": ["ls", "source", "filename", "sb", "uri", "st", "config", "s", "back", "txt", "input", "image", "sin", "inst", "loc", "resource", "img", "dest", "sup", "url", "inf", "b", "files", "obj", "sit", "sel", "sl", "sc", "dist", "rc", "rb", "ins", "upload", "stream", "file", "ipl", "http"], "dst": ["ddft", "fdfd", " dsts", "ddfd", "pdfd", " ddest", "pdsp", "Dst", "fdsp", "dsts", "dsp", "Dsts", "ddest", "Ddest", "stlt", "pdst", "pdft", "stdest", "fdst", "ddsp", "fdft", " dlt", "ststs", "ddst", "dlt", "dft", "Dlt", "stst", "dfd"], "in": ["as", "init", "ln", "gin", "inn", "pin", "inner", "f", "i", "input", "inside", "conn", "sin", "socket", "IN", "data", "m", "ini", "win", "con", "n", "url", "din", "is", "nin", "ins", "h", "cin", "lin", "In", "impl", "inc", "again", "rin", "kin", "file", "pull", "r", "err", "login", "oin", "id", "reader", "bin"], "out": ["x", "copy", "cache", "output", "sync", "client", "net", "at", "f", "s", "w", "ex", "i", "conn", "OUT", "line", "writer", "other", "self", "up", "io", "n", "bin", "null", "outer", "ext", "server", "exec", "post", "obj", "exp", "Out", "raw", "outs", "again", "off", "file", "temp", "parent", "part", "err", "o", "plain", "inc"], "buf": ["bh", "buffer", "uf", "seq", "uc", "length", "br", "bag", "c", "cat", "pad", "buff", "fb", "bb", "bytes", "cmd", "lim", "bl", "count", "ff", "val", "loc", "data", "bf", "bc", "base", "b", "fd", "fl", "rc", "rb", "cur", "queue", "raw", "batch", "off", "vec", "cap", "wb", "ctx", "v", "bin", "cb", "bd"], "len": ["lf", "ln", "length", "c", "f", "all", "lt", "ix", "nt", "i", "lim", "l", "pos", "count", "line", "val", "ind", "data", "n", "base", "name", "lc", "fd", "fin", "fl", "split", "sl", "li", "size", "cl", "el", "ll", "lin", "en", "Len", "cap", "part", "err", "end", "le", "rev", "bin", "no"]}}
{"id1": "21824901", "id2": "8788371", "code1": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyExternalResource": [" copyExternalSourceFile", "copyInternalResources", " copyInternalURL", "copyApplicationResource", "copyInternURL", "copyExternalResources", "copyApplicationResources", "copyInternSourceFile", " copyExternalResources", "copyInternalResource", "copyInternalURL", "copyInternalSourceFile", "copyApplicationSourceFile", "copyInternResource", "copyExternalSourceFile", " copyInternalSourceFile", "copyExternalURL", " copyInternalResources", "copyInternResources", "copyApplicationURL", " copyExternalURL", " copyInternalResource"], "sourceFile": ["srcFile", "srcfile", "destfile", " sourcefile", "sourcePage", " sourcePath", "destStream", " sourcePage", "inputFile", "sourceDirectory", "srcPath", "SourcePath", "sourcePath", " sourceStream", " sourceDirectory", "SourceFile", "inputfile", "sourcefile", "srcDirectory", "inputStream", "SourceDirectory", "destPage", "sourceStream", "inputPage", "Sourcefile"], "destFile": ["destDirectory", "sourceDir", "parentDir", "parentfile", "destfile", "srcfile", "srcFile", "DestPoint", "distDir", "targetfile", " destDir", "destDir", "DestDirectory", " destPoint", "DestDir", "distFile", "DestFiles", "targetDirectory", "targetDir", " destFiles", " destDirectory", "targetFile", "distfile", "destPoint", "parentFile", "srcFiles", "sourcefile", "sourceFiles", "srcDirectory", " destfile", "distDirectory", "DestFile", "sourcePoint", "srcDir", "destFiles", "Destfile", "parentFiles"], "source": ["result", "cache", "uri", "current", "client", "table", "output", "sync", "session", "inner", "config", "this", "use", "plus", "slave", "link", "pointer", "input", "src", "ource", "image", "SOURCE", "sin", "get", "Source", "service", "object", "resource", "proxy", "ce", "from", "dest", "core", "class", "si", "url", "null", "server", "api", "connection", "scope", "channel", "size", "stream", "reference", "file", "slice", "id", "unit", "reader", "parent", "start", "target", "status", "context"], "destination": ["Destribution", "destinated", "constinator", "constribution", "Destinated", "dependination", " destruction", "declinator", "dependruction", "Destruction", "declruction", "originator", "origruction", "declinated", " destinator", " destinated", "Destination", "dependinator", "constination", "declination", "destruction", "origination", "destinator", "dependinated", "construction", " destribution", "destribution", "Destinator", "originated"]}}
{"id1": "10385815", "id2": "5725177", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["create", "cmp", "sync", "paste", "Transfer", "update", "download", "Cop", "send", "move", "process", "open", "clone", "change", "transfer", "exec", "split", "zip", "upload", "Copy", "write", " Copy", "replace", "put", "file", "get", "delete"], "fileFrom": ["mailIn", "FileSource", " fileIn", "fileStart", "FileIn", "FileFrom", "fileAs", " fileStart", "mailAs", "ioFrom", " fileSource", "FileTo", "ioStart", "mailTo", "FileStart", "mailFrom", "ioTo", " fileAs", "fileSource", "fileIn", "ioSource", "FileAs"], "fileTo": ["fpFrom", " fileFile", "FileFrom", " fileTarget", "fpTo", "resourceFile", "fileFile", "fileTO", "FileTarget", "FileTo", " fileTO", "fileto", "Fileto", "FileFile", "FileTO", "fpto", " fileto", "fpTO", "fileTarget", "resourceTarget", "resourceTo", "resourceFrom"], "inputStream": ["InputFile", "InputChannel", " inputstream", "inputContext", "InputSync", "outputSteam", "inputFile", "InputContext", "outputContext", "Inputstream", "inputstream", "InputStream", " inputFile", "InputSteam", " inputSteam", "outputSync", "outputstream", "inputSteam", "outputFile", " inputContext", "inputSync", " inputSync"], "outputStream": ["OutputStream", "outputPath", "OutputStreamer", "writeStream", "OutputSteam", "writeSocket", "writeSteam", "outputStreamer", "referenceChannel", "inputChan", "inputSocket", " outputSteam", "OutputChan", "fourStreamer", "fourStream", "referenceStream", "inputPath", "OutputPath", " outputChan", " outputStreamer", "referenceSteam", "inputSteam", "fourSteam", "writeChannel", "OutputChannel", "fourChannel", "referenceSocket", "outputChan", "outputSocket", "outputSteam", " outputPath"], "inputChannel": ["outputClient", "audioCam", "butChannel", "parentPassword", "InputChannel", "inputContext", "InputContext", "inputChan", "outputContext", " inputSocket", " inputCam", "inputPassword", "inputCam", " inputPassword", "butCommand", "inputSocket", "parentChannel", " inputChan", "InputSocket", "audioChannel", "audioClient", "audioStream", "butContext", "InputStream", "inputCommand", "outputCam", "inputClient", "outputPassword", "outputCommand", "butChan", " inputClient", "InputChan", "parentChan", "outputChan", " inputContext", "outputSocket", "parentStream", " inputCommand"], "outputChannel": ["Outputchannel", "OutputStream", "inputQueue", "inputContext", "OutputContext", "inputChan", "outputContext", "outputchannel", "outContext", "outputQueue", "OutputChan", "OutputQueue", " outputQueue", " outputChan", " outputchannel", " outputContext", "outChannel", "OutputChannel", "outChan", "outputChan", "outStream", "inputchannel"]}}
{"id1": "19206412", "id2": "4468255", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"md5String": ["md512string", "md4string", "md5Str", " md512Bytes", " md512string", "md512Bytes", " md512String", "md512String", "md5string", "md6String", "md6Str", " md5Str", "md6string", " md5Bytes", "md512Str", "md4Bytes", " md512Str", "md5Bytes", "md4Str", "md6Bytes", "md4String", " md5string"], "str": ["text", "kr", "char", "result", "re", "arr", "out", "st", "dict", "br", "Str", "f", "s", "this", "bytes", "pass", "e", "txt", "STR", "stri", "data", "strings", "star", "sr", "self", "url", "name", "hr", "obj", "msg", "sp", "dr", "string", "exp", "fr", "enc", "tr", "r", "er", "err", "doc"], "md": ["me", "mand", "hm", "mm", "mp", "mod", "amd", "Cmd", "wd", "mk", "dig", "cmd", "dm", "mb", "mg", "data", "m", "map", "metadata", "ad", "mac", "sm", "ms", "vd", "um", "code", "pd", " MD", "ld", "od", "dd", "mo", "mt", "hd", " Md", "am", "cd", "sum", "MD", "dh", "mc", "ma", "df", "mu", "mag", "pm", "db", "d", "cmp", "rpm", "bd", "mail"], "hash": ["dot", "char", "cache", "arr", "check", "ash", "memory", "f", "ver", "image", "count", "kh", "chip", "print", "url", "base", "array", "search", "Hash", "host", "code", "number", "sha", "hex", "body", "address", "index", "h", "header", "range", "sum", "sh", "filter", "block", "html", "ha", "value", "tr", "part", "key", "her", "diff", "id", "rh", "bin", "error"], "hexChars": ["hexKhars", "hexchacters", " hexchARS", "hexCharats", "hexChashes", "hexCHARS", "hexCharars", "hashChars", "hexchARS", "hexCharases", "hashchacters", "hexchats", "hashChash", " hexChARS", "hexCHats", " hexchashes", "hexChases", "hashChacters", " hexchats", "hexKhash", "hashchars", " hexChats", "hashCHashes", " hexChashes", "hexCHacters", "hexCharashes", "hashCHash", "hexCars", "hashCHars", "hashCHARS", "hashchases", " hexchars", "hexchashes", "hexchars", "hashchARS", "hexCHashes", "hexCHars", "hexKhARS", "hexCharARS", "hexChARS", "hexCHases", "hexChash", "hexChacters", "hexCharacters", "hexCash", "hashChashes", "hashChases", "hexKhashes", "hexChats", "hashChARS", "hexCashes", "hexCHash", "hexCARS", "hexchases"], "res": ["rules", "ris", "ret", "result", "ps", "cs", "re", "ss", "out", "arr", "us", "cache", "s", "reg", "bytes", "Results", "vals", "resp", "des", "data", "req", "RS", "rs", "vs", "ras", "ros", "RES", "bs", "rss", "Rs", "Result", "string", "rus", "pres", "details", "vers", "rez", "resolution", "rex", "ress", "Res", "css", "pers", "es", "abs", "r", "response", "results", "err", "rev", "cons", "rows"], "i": ["p", "x", "uri", "length", "field", "c", "f", "ai", "gi", "ii", "info", "ix", "e", "ie", "l", "I", "k", "ci", "abi", "m", "in", "multi", "ip", "io", "bi", "iu", "a", "si", "base", "b", "u", "it", "ti", "code", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "di", "qi", "y", "xi", "temp", "part", "mu", "o", "id", "diff", "v", "ri", "d", "phi"]}}
{"id1": "17856064", "id2": "7087108", "code1": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" constructor", " execute", " structure", " parser", " validate", " install", " inspect", " assemble", " discover", " scan", " check", " parsed", " load", " pars", " ls", " analyze", " test", " compile", " extract", " params", " analyse", " process", " resolve", " start", " parsing", " read"], "unitName": [" unit1", "unitsNames", "units1", " unitname", " unitValue", "machineType", "unitsName", "machineName", "unitNames", "unitname", "machinePath", "Unitname", "machineValue", " unitNames", "UnitNames", " unitType", "uiType", " unitPath", "Unit1", "unitValue", "unitPath", "uiValue", "UnitName", "unit1", "uiName", "unitsname", "unitType", "uiPath"], "persistenceUnits": ["persistenceOperit", "persistenceUnitITS", "persistanceUnitit", "persistanceUnitists", "persistenceUNITS", "persistenceUnitodes", "persistenceOperodes", "persistanceUnists", "persistenceClites", "persistenceUnitit", "persistenceUnitists", "persistanceClITS", "persistanceClits", "persistenceUnitunits", "persistanceUnitits", "persistenceUnists", "persistenceLogites", "persistanceUnit", "persistenceOperites", "persistanceUnITS", "persistanceClitions", "persistenceUnitits", "persistenceUITS", "persistenceUites", "persistenceClits", "persistenceunists", "persistenceLogunits", "persistenceUnunits", "persistanceUnitites", "persistenceLogists", "persistanceUnitITS", "persistenceUNites", "persistenceUit", "persistenceunits", "persistenceUNitions", "persistenceununits", "persistanceUnodes", "persistenceUits", "persistenceUNodes", "persistenceUNits", "persistenceUnit", "persistenceUnititions", "persistanceUnites", "persistenceUnitites", "persistenceClitions", "persistenceClITS", "persistenceUnITS", "persistenceLogits", "persistenceunites", "persistanceUnitions", "persistanceUnunits", "persistenceOperits", "persistanceUnitodes", "persistenceUNit", "persistenceUnodes", "persistanceUnits", "persistanceUnitunits", "persistenceUnites", "persistenceUnitions", "persistanceClites"], "classes": [" instances", " constants", "result", "ps", " assignments", "set", " formulas", " protocols", " packages", " configurations", " interfaces", " groups", "groups", "services", " models", "resources", "names", " tests", " class", "class", "params", " sources", "Class", " suites", "es", " Classes", "properties", "results"], "i": ["p", "x", "uri", "z", "ni", "ai", "f", "gi", "ii", "info", "ori", "ix", "ie", "l", "I", "ci", "yi", "ini", "in", "multi", "ip", "iu", "bi", "n", "si", "u", "ui", "pi", "oi", "ji", "li", "index", "hi", "mi", "di", "qi", "eni", "y", "xi", "fi", "id", "v", "ri", "ti", "phi"], "url": ["ls", "source", "filename", "uri", "path", "username", "Url", "config", "f", "link", "l", "image", "data", "web", "in", "service", "resource", "location", "up", "io", "base", "name", "server", "URL", "sl", "address", "api", "string", "connection", "ur", "element", "plugin", "file", "route", "ssl", "href", "entry", "user", "xml", "http"], "b": ["p", "Builder", "ab", "bh", "sb", "br", "cb", "c", "f", "bb", "fb", "e", "pb", "l", "build", "B", "m", "hub", "builder", "be", "n", "a", "bc", "base", "bt", "obj", "bs", "verb", "rb", "eb", "gb", "lib", "wb", "r", "ob", "o", "bis", "v", "db", "library", "bd"], "d": ["p", "dot", "dos", "md", "c", "f", "s", "e", "dm", "l", "ds", "xml", "data", "m", "director", "dl", "n", "g", "u", "fd", "dt", "pd", "dat", " D", "di", "dd", "did", "D", "dom", "df", "t", "r", "dir", "id", "db", "dc"], "unitNodes": ["unitSnoded", "unitnurs", "unitnoms", " unitnodes", "unitnode", "unitRenobs", "unitnubes", "unitSnode", " unitNoded", "unitNubes", "unitNurs", "unitnoded", "unitNoms", "unitNoded", "unitDurs", "unitRenoms", " unitNobs", "unitnobs", " unitnode", " unitNoms", " unitNideos", "unitNeoms", "unitSnoms", " unitNurs", " unitnoded", "unitSnodes", "unitNeodes", "unitNobs", "unitNideos", " unitnideos", " unitnoms", "unitNeode", " unitnurs", "unitDideos", "unitDodes", "unitRenodes", " unitNubes", "unitnideos", "unitnodes", "unitRenubes", "unitNeoded"], "j": ["p", "json", "ij", "z", "br", "ni", "jl", "f", "ii", "bj", "note", "ie", "l", "dj", "aj", "q", "jit", "n", "g", "job", "v", "jj", "kj", "ja", "u", "it", "obj", "ji", "jet", "jc", "je", "h", "ch", "jen", "fr", "qi", "jp", "y", "syn", "key", "uj", "J", "section", "js", "jo"], "unitNode": ["tunnode", "unitN", "unitnode", "tunName", "UnitNode", "unitsName", "connectionNode", "tunElement", "connectionPath", "unitElement", "unitsElement", " unitPath", " unitnode", "connectionN", "tunNode", "UnitElement", "unitPath", " unitN", "unitsnode", "UnitN", "connectionElement", "UnitPath", " unitElement", "unitsNode"], "unitElt": ["unitIlem", "unitEselt", "unitUlem", " unitUlem", "unitNLT", "unitGelt", "unitUlt", " unitOLT", "unitOlt", " unitOld", "uniteler", "unitNlt", "unitOLT", "elementEld", "unitElem", " unitUxt", "unitelet", "unitelt", "unitOlet", "elementEslt", "unitNelt", "unitNld", " unitEelt", " unitEld", "unitGeld", "unitUxt", "unitElet", "unitext", "elementEsld", "uniteelt", " unitEler", "unitEelt", "unitExt", " unitOelt", "elementElt", "unitEsld", " unitUler", "elementElet", " unitExt", "unitelem", "elementEelt", "unitGeLT", "unitEld", "unitELT", " unitELT", " unitOlt", "unitEler", "unitIxt", " unitUlt", "unitIlt", "unitOld", "unitGeelt", "unitOelt", " unitElem", "elementEselt", "elementEslet", "unitEslet", "unitIler", "unitUler", "uniteld", "unitEslt"], "uName": ["uPath", "duNode", "uValue", "suValue", "unitNames", "uNames", "unitname", " uNames", "uname", "unitValue", "duName", "duNames", "suname", "suPath", "unitPath", "suName", " uPath", " uValue", "duValue", " uNode", "uNode", " uname"], "parameters": ["arameter", "aramels", "paramumers", "prometer", "pams", "promParameters", "peters", "persumers", "perseters", "persels", "pumers", "paramseter", "pareters", "paramseters", "paramels", "promels", "pels", "prometers", "params", "parameter", "aramParameters", "paramParameters", "paramams", "paramsels", "parumers", "arameters", "paramsParameters", "persams", "parels"], "classNodes": ["classSobs", "classVode", "classVodes", "fieldNinodes", " classCodes", "classNeode", " classClements", "classnodes", "classNinodes", "fieldNinode", "fieldNinODE", "classNODE", " classCoded", "classNelements", "classVODE", " classNoded", "classNanks", "Classnodes", "Classnode", "classNlements", "classClements", "classNeoded", "classSnodes", "classCodes", "fieldNode", " classNlements", "classNoded", "classEode", "classNobs", "fieldNodes", "ClassNodes", "classNinobs", "classNinode", "classNeodes", "ClassNoded", "classSODE", " classCode", "classEanks", "fieldNobs", "classCode", "classnanks", "ClassNode", "classEoded", "classSnlements", "ClassNanks", "Classnanks", "classSode", "classSnoded", "classnoded", "fieldNODE", "classnode", "classEodes", "classSodes", "classNinODE", "classSnode", "classCoded", "fieldNinobs", "classVobs", "Classnoded"], "k": ["work", "p", "kid", "kr", "ku", "z", "c", "f", "ky", "w", "ko", "ek", "q", "kw", "kk", "ad", "ke", "n", "g", "ks", "kn", "ik", "ch", "ki", "sk", "h", "kick", "K", "dk", "ok", "km", "y", "key", "r", "id", "unk", "ck", "kat", "v"], "classNode": ["elementTree", "fileElement", "configName", "ClassNs", "configSource", " classFile", "fileRoot", "busNode", "elementSource", "configElement", "elementNode", "classTree", "Classnode", "baseTree", "classFile", "busNs", "className", " classSource", "fileTree", " className", "classSource", " classNs", "baseNode", "baseRoot", "elementElement", "elementRoot", "busnode", "busFile", "classNs", "configNode", "classElement", "baseElement", "ClassNode", " classElement", "fileNode", "ClassFile", "classRoot", "classnode", " classnode"], "classElt": ["classELT", "classXLT", "elementExt", "ClassEler", "classYlt", "ClassElt", "ClassOxt", "ClassXld", "ClassOld", "classEler", "elementelt", "classYld", "elementEld", "classUlem", "classEld", "elementext", "ClassXelt", "classelem", "ClassElem", "classExt", "classElem", "elementeelt", "ClassOlt", "classXelt", "classEelt", "classUld", "classUelt", "classeLT", "classUlt", "elementElt", "classYelt", "Classelem", "ClassXLT", "classXxt", "classOlt", "ClassEld", "ClassExt", "ClassXlt", "classXler", "classOler", "elementEelt", "classYlem", "classYxt", "classext", "classUxt", "classeld", "classYler", "ClassELT", "ClassEelt", "Classeld", "ClassOler", "Classeelt", "classXlt", "classOld", "classOxt", "elementeld", "classXld", "Classelt", "classelt", "classeelt"], "elementName": ["stringName", "classname", "elementname", "stringFace", "layerFamily", "typeName", "articleApp", "typeFamily", "elementFace", "sectionFamily", "classValue", "typeApp", "layerName", "typeAnn", "modulename", "stringFamily", "sectionName", "modulePath", " elementFamily", "elementPath", "elementApp", "articleAnn", "className", "classPath", "layerAnn", "moduleName", "elementFamily", " elementPath", "articleFamily", "moduleValue", "sectionFace", " elementname", "layerApp", " elementFace", "articleName", "elementAnn"], "elementValue": ["entryValue", "ElementValue", "optionValue", "entryVal", "memberText", "optionVal", "elementText", "entryvalue", "objectValue", "Elementvalue", "objectVal", "styleVALUE", "styleValue", "optionvalue", "elementVal", "elementvalue", "memberVal", "elementString", "objectString", "entryText", "memberVALUE", " elementText", "styleText", "ElementString", "entryVALUE", "stylevalue", " elementVal", "objectvalue", "memberValue", "ElementVALUE", "ElementText", "elementVALUE", "optionString", " elementVALUE", "ElementVal"]}}
{"id1": "19549577", "id2": "19251426", "code1": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"callApiPost": ["callAAPIPOST", "callAiPut", "callUipost", "callAAPIPost", "callUpipost", "callApipost", "callUiPost", "callUpiPut", "callApiPOST", "callAapipost", "callAapiPut", "callAAPIpost", "callAapiPOST", "callAAPIPut", "callUpiPost", "callUiPut", "callUiPOST", "callAipost", "callAiPOST", "callUpiPOST", "callAiPost", "callApiPut", "callAapiPost"], "apiUrl": ["piPath", "APIUrl", "baseUr", " apiURL", "APIName", "piUr", "piUrl", "APIUr", "piName", "baseUrl", "APIPath", "apiName", "apiURL", "baseName", " apiUr", "apiUr", "APIURL", "apiPath", " apiPath", "baseURL", "piURL"], "parameters": ["prometer", "mandeter", "rameter", "paramers", "parers", "promams", "argams", "paramseter", "paramseters", "pareters", "rameters", "paramels", "prometers", "paramements", "params", "paramsements", "parameter", "ramels", "mandels", "pareter", "argeters", "paramams", "argeter", "paramsels", "ramements", "promers", "argers", "mandements", "mandeters"], "expected": ["style", "pecting", "current", "reported", "actual", "pect", "event", "pected", "e", "needed", "due", "ed", "default", "required", "found", "example", "done", "ce", "force", " unexpected", "fake", " expecting", "code", "seen", "pects", "future", "confirmed", "handled", "pretty", " expect", "received", "failed", "err", " expectation", "after", "forced", "error", "anticipated"], "url": ["source", "buffer", "result", "uri", "client", "browser", "Url", "f", "config", "page", "event", "l", "web", "service", "object", "resource", "www", "base", "log", "job", "server", "host", "URL", "address", "api", "sl", "connection", "string", "ur", "ul", "file", "ssl", "response", "user", "xml", "jar", "http"], "request": ["work", "message", "press", "remote", "buffer", "current", "json", "bar", "instance", "config", "event", "have", "project", "rest", "build", "builder", "wheel", "base", "pe", "post", "upload", "require", "queue", "error", "http", "result", "copy", "client", "hello", "use", "view", "command", "req", "up", "job", "allow", "api", "worker", "over", "pull", "rate", "user", "jar", "order", "pair", "access", "method", "call", "path", "claim", "driver", "input", "friend", "condition", "issue", "resource", "next", "string", "external", "received", "response", "get", "Request", "p", "create", "re", "large", "per", "enter", "complete", "q", "service", "open", "server", "query", "child", "connection", "er", "join", "right", "xml", "report"], "headerName": ["cookiename", "headString", "requestString", "HeaderString", " headerLine", "headName", "headerValue", "versionValue", "headersString", "versionname", " headerString", " headerKey", "requestname", "versionName", "headersKey", "HeaderValue", "Headername", "versionString", "requestName", "headname", "headersLine", "cookieName", "headersName", "cookieKey", "headValue", "headerString", "requestLine", "headerKey", "headername", "headerLine", " headername", "HeaderName", "cookieLine", "requestKey"], "out": ["flow", "group", "result", "buffer", "copy", "output", "client", "sync", "inner", "f", "s", "info", "page", "w", "extra", "console", "input", "dump", "OUT", "socket", "line", "data", "writer", "in", "builder", "print", "io", "name", "log", "null", "outer", "obj", "exec", "password", "string", "external", "plain", "stream", "Out", "write", "raw", "outs", "again", "file", "temp", "part", "err", "response", "key", "o", "flush", "error", "report"]}}
{"id1": "10131427", "id2": "19096138", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyChannel", "copyfile", "CopyChannel", "copyFiles", "CopyFile", "copyChannel", "transferfile", "transferFile", "transferChannel", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "in": ["work", "source", "buffer", "copy", "inn", "inner", "c", "ac", "config", "at", "ex", "i", "input", "image", "or", "IN", "data", "m", "ini", "resource", "io", "a", "url", "base", "name", "b", "min", "index", "ins", "In", "inc", "again", "file", "login", "id", "reader", "diff", "bin"], "out": ["p", "x", "source", "buffer", "copy", "cache", "output", "client", "c", "point", "at", "w", "ex", "OUT", "conn", "image", "data", "writer", "object", "dest", "io", "n", "base", "name", "exec", "string", "connection", "external", "prefix", "Out", "outs", "off", "file", "temp", "part", "o", "v", "target"], "sourceChannel": ["SourceQueue", " sourceManager", "srcQueue", "sourceConnection", "SourceChan", "ourceChannel", " sourcechannel", "sourceChan", "SourceConnection", " sourceConnection", "SourceManager", "SourceSocket", "srcConnection", " sourceStream", "sourceQueue", "sourceSocket", "srcSocket", "srcChannel", "targetchannel", "ourceStream", " sourceChan", "targetChan", "srcChan", "sourceManager", " sourceSocket", "sourcechannel", "srcManager", "sourceStream", "ourcechannel", "ourceChan", "targetStream", "SourceChannel", "SourceStream", "srcStream", "Sourcechannel", " sourceQueue", "targetChannel"], "destinationChannel": ["DestinationChannel", "destinationchannel", "destinatedChannel", "DestinatorCh", "destationchannel", "DestinationConnection", "destinateConnection", "destinationCh", "destationChannel", "destinationStream", "destinateChannel", "DestinatorChannel", "destinatedCh", "destinationschannel", "destationChan", "DestinatorConnection", "DestinationCh", "destinationChan", "DestinationStream", "destinatorConnection", "destinatedChan", "destinationConnection", "destinationsStream", "destinatedConnection", "DestinatorChan", "destationCh", "destinatorChan", "DestinatorStream", "destinationsChannel", "destationConnection", "DestinationChan", "Destinationchannel", "destinatechannel", "Destinatorchannel", "destinatorCh", "destinateStream", "destinationsConnection", "destinatorchannel", "destinatorChannel", "destinatorStream"]}}
{"id1": "1862616", "id2": "8047989", "code1": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"fetch": ["furl", " Fetch", " Fget", " furl", "Furl", "fget", "Fetch", "Fget", " Furl", " fget"], "reference": ["source", "message", "ref", "buffer", "re", "uri", "port", "path", "info", "i", "pointer", "object", "resource", "location", "proxy", "References", "database", "name", "base", "server", "relative", "number", "address", "connection", "string", "external", " Reference", "collection", "attribute", "Reference", "request", "ference", "Ref", "href", "response", "URI", "type", "REF", "target", " references"], "url": ["p", "ls", "ref", "cache", "uri", "uc", "Url", "f", "fb", "https", "page", "e", "l", "build", "q", "object", "resource", "www", "base", "u", "lc", "server", "b", "URL", "rl", "fl", "cr", "sl", "ch", "connection", "string", "h", "ur", "cl", "coll", "ll", "ssl", "feed", "err", "http"], "c": ["p", "call", "oc", "cs", "cf", "ac", "f", "http", "w", "e", "i", "l", "conn", "k", "ci", "m", "con", "ce", "ec", "g", "pc", "u", "b", "lc", "C", "cr", "exec", "sc", "ch", "rc", "cc", "nc", "h", "connection", "cp", "enc", "cl", "coll", "cm", "fc", "cu", "mc", "t", "r", "o", "ct", "v", "cb", "d", "co", "dc"]}}
{"id1": "6625074", "id2": "14567939", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "label": 1, "substitutes": {"SHA1": ["HA384", "SHAOne", " SHAOne", "sha256", "shaOne", "SHA256", "sha384", "HA256", "SHA384", "HA1", "HAOne", " SHA256", " SHA384", "sha1"], "text": ["source", "message", "buffer", "output", "str", " Text", "out", "token", "path", "translation", "config", "font", "bytes", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "format", "context", "editor", "class", "name", "ext", "Text", "code", "obj", "password", "transfer", "letter", "hex", "string", "struct", "test", "value", "template", "contract", "plain", "pattern", "content"], "sha1hash": ["sha256password", "shaOnehash", "SHA1cap", "SHA1text", "sha6Hash", "sha6hash", "sha_Hash", "ha2hash", "sha1hex", "sha2cap", "sha81Hash", "shaOnepassword", "ha1hash", "sha256text", "sha6log", "ha1hex", "sha_sum", "ha2hex", "SHA2cap", "sha6cap", "sha1cap", "ha2Hash", "ha1Hash", "sha1text", "sha2Hash", "sha81log", "sha1Hash", "sha2hash", "shaOnetext", "sha81cap", "sha256Hash", "ha2sum", "SHA2hash", "SHA1Hash", "sha2hex", "sha2sum", "SHA1hash", "sha_hex", "sha81hash", "sha2log", "sha1sum", "SHA2log", "ha1sum", "sha1password", "sha256hash", "shaOneHash", "sha_hash", "sha1log", "SHA1password", "SHA2Hash", "SHA1log"], "md": ["hm", "mm", "mp", "cf", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "de", "mb", "meta", "m", "nm", "metadata", "ad", "mac", "editor", "rm", "ms", "sm", "vd", "um", "nd", "pd", "sha", " MD", "gb", "od", "ld", "dd", "mo", "mt", "hd", "cd", "MD", "mc", "ma", "df", "pkg", "mag", "pm", "d", "rpm", "bd"]}}
{"id1": "23273706", "id2": "17773263", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"getProjectTreeData": ["getProjectTreeInfo", "getprojecttreeInfo", "getProjecttreeDATA", "getProjectDocumentData", "getProjectPageDATA", "getprojectTreeData", "getProjectDocumentMeta", "getProjecttreeInfo", "getProjectPageData", "getprojecttreeDATA", "getProjectPageMeta", "getprojecttreeMeta", "getProjectDocumentInfo", "getprojectTreeMeta", "getProjectTreeMeta", "getProjectTreeDATA", "getProjecttreeData", "getProjectPageInfo", "getProjectDocumentDATA", "getProjecttreeMeta", "getprojectTreeInfo", "getprojecttreeData", "getprojectTreeDATA"], "treeData": ["TreeList", "contentInfo", "TreeArray", "TreeData", "treeArray", "monkeyData", "monkeyDec", "reeText", "treeDec", "contentText", " treeInfo", "treeText", "bodyDat", "storyDat", "reeDat", "reeInfo", "treeDat", "monkeyArray", "reeList", " treeDat", "storyData", " treeDec", "storyDec", "storyArray", "contentData", "contentDat", "reeArray", "bodyList", "bodyData", "reeString", " treeArray", "reeData", " treeText", "treeList", " treeString", " treeList", "bodyString", "TreeString", "treeString", "TreeInfo", "monkeyDat", "treeInfo"], "filename": ["figure", "whatever", "uri", "fp", "ppa", "path", "username", "kl", "wav", "title", "ername", "fil", "txt", "sheet", "data", "folder", "location", "metadata", "dll", "journal", "framework", "directory", "FILE", "url", "database", "name", "tmp", "kn", "kj", "fd", "files", "password", "dylib", "SourceFile", "upload", "string", "fn", "prefix", "Filename", "file", "nil", "jpg", "xml"], "urlString": [" urlURL", "URLString", "addressStr", "URLURL", "URLstring", "urlStr", "addressString", "URLStr", "addressURL", "urlUrl", "locationUrl", " urlstring", "urlURL", "locationString", "URLUrl", "urlstring", " urlUrl", "addressstring", "locationStr", "locationstring", " urlStr"], "urldata": ["urlledATA", "URldat", "urlledata", "urlledta", "urlfat", " urLDdata", " urLDta", "urldat", "urLDat", "urleddata", "urledATA", "urllata", "urledta", " urldATA", "urledata", "urLDta", " urLDATA", "URlddata", "urLData", "urldATA", "URlfata", "URlfat", " urldta", " urLData", "urlldata", "urlfATA", "urlfata", "urlfdata", "urllat", "urldta", "URlfATA", "URldata", "urLDATA", "urllATA", "URldATA", "urlleddata", " urlddata", "urlddata", "urLDdata", "URlfdata"], "factory": ["cFactory", " fault", "confFactory", " fFactory", "conflier", "confiller", "liller", "cflier", "fuild", "ciller", "lactory", "fFactory", "ufactory", "luild", "cault", "cfFactory", "pFactory", "ufuild", "cfiller", "flier", " flier", "lictionary", " fictionary", "pault", "ufictionary", "fault", "pactory", "filler", "confactory", " fuild", "ufiller", "piller", "cfactory", "cactory", "fictionary", " filler"], "parser": ["p", "lp", "arser", "util", "uri", "se", "json", "parse", "instance", "s", "driver", "root", "l", "manager", "loader", "writer", "ph", "Parser", "builder", "pdf", "ger", "up", "b", "utils", "monkey", "fruit", "api", "string", "jack", "handler", "plugin", "auto", "t", "er", "r", "reader", "parent", "xml", "raf", "library", "http"], "u": ["p", "uni", "uv", "util", "su", "uri", "uf", "us", "c", "plug", " ur", "eu", "s", "l", "tu", "ru", "yu", "io", "iu", "url", "ou", "b", "ui", "nu", "ur", "ul", "lu", "universal", "cu", "hu", "uu", "U", "o", "d", "http"], "is": ["p", "mis", "as", "ris", "init", "uri", "IS", "isa", "us", "ai", "info", "s", "its", "ori", "isu", "iss", "are", "ie", "Is", "serv", "or", "iso", "gets", "in", "ib", "lis", "ir", "ip", "io", "ar", "it", "fs", "ui", "isl", "pi", "api", "ais", "ios", "es", "abs", "iris", "obs", "ob", "bis", "has", "ri", "ops", "http"], "os": ["OS", "ops", "as", "dos", "ps", "so", "oss", "us", "bos", "s", "oes", "ens", "pos", "or", "iso", "ose", "gets", "sys", "ol", "oa", "opens", "io", "ros", "ms", "cos", "los", "fs", "bs", "fits", "oos", "ios", "aos", "ils", "es", "obs", "Os", "o", "ob", "osi", "bis", "oses", "http"], "iBufSize": ["iBufsize", "iBbufsize", "iBlfLength", "iBbufSize", "iByteufLength", "iBytebufSize", "iLlfLength", "iBytebufLength", "iByteufsize", "iLlfSt", "iBbufLength", "iByteufSize", "iBufLength", "iLufSt", "iLlfSize", "iBuffLen", "iLufSize", "iBbufLen", "iBlfsize", "iBufferSt", "iBufferSize", "iBuffLength", "iLlfsize", "iBlfLen", "iBuffersize", "iBytebufLen", "iBuffSt", "iLufLength", "iBytebufsize", "iBuffsize", "iBufSt", "iBuffSize", "iByteufLen", "iBufLen", "iBlfSt", "iLufsize", "iBufferLength", "iBlfSize"], "inBuf": ["inBluf", " inFbuf", "inbuf", " inFaf", "inDuff", "inBunk", "inFuf", "inFuff", "inDbuf", "outBuffub", "outBuffump", "inBump", "outBump", "inCbuf", "inCunk", " inBuff", "inBlunk", " inBaf", "inCuf", " inBump", "inPluf", "outBuf", "outBuffbuf", "inBuffuf", "inPlump", "inDuf", "inBub", "inDaf", " inBunk", " inCunk", " inCuf", "outBbuf", "inbub", "inBuffump", " inCbuf", "inCuff", " inCump", "inPlunk", "inFaf", "inBbuf", "inbump", "inFbuf", "outBuffuf", "inBuff", "inBuffbuf", "inBlbuf", " inFuff", "inbbuf", "inBlub", "inBuffub", "inBaf", "inCaf", "inBlump", "outBub", "inPlbuf", "inCump", " inFuf", " inBbuf"], "iNumRead": ["pNumberRead", "inumWritten", "qiNumREAD", "iChanBuild", "qiNumread", "pNumberWritten", "iValREAD", "iNumread", "inumread", "iLenRead", "iNumREAD", "iNumberBuild", "pNumberread", "pNumWritten", "iLenWritten", "iFatWritten", "inumWrite", " iFatWritten", "iChanREAD", "qiValread", " iFatRead", "pNumRead", "iNumWritten", "iNumberWrite", "iValRead", "iFatRead", " iNumWrite", "inumRead", "iValBuild", "iNumberread", "qiValREAD", "qiValBuild", " iFatWrite", "pNumread", "iNumberREAD", "iValread", "iNumberWritten", "qiNumBuild", "iChanRead", "qiNumRead", "iFatWrite", "iNumberRead", "iChanread", "pNumWrite", "iNumWrite", "qiValRead", "iLenWrite", " iNumWritten", "pNumberWrite", "iNumBuild"], "f": ["p", "F", "fp", "uf", "c", "s", "e", "l", "ff", "m", "n", "g", "io", "b", "fd", "fs", "fe", "j", "h", "fn", "fr", "fa", "handler", "rf", "full", "fc", "file", "df", "t", "r", "fi", "sf", "o", "feed", "v", "d"], "inputstream": ["Inputsw", " inputsw", "Inputchannel", " inputchannel", "outputchannel", "Inputstream", "contentStream", "InputStream", " inputStream", "inputsystem", "contentsw", "contentstream", "outputStream", "Inputsystem", "inputsw", "outputstream", "inputStream", "contentsystem", " inputsystem", "inputchannel"], "document": ["p", "source", "DOM", "media", "output", "language", "info", "page", "e", "l", "tree", "project", "ocument", "xml", "data", " documents", "m", "record", "object", "context", "director", "n", "directory", "window", "null", "docs", "Document", "Documents", "container", "list", "html", "dom", "office", "file", "collection", "t", "response", " documentation", "parent", "node", "d", "doc", "content"], "nodelist": ["nodedestyle", "nodemark", "nodestate", "nodata", "anodedeme", " nodesels", "nondestate", "nodedestate", "nodedeme", "snodseline", "NODelist", "nonedelist", "nozette", " nodesename", "Nodelist", "nozelist", "nODesh", "nodeeme", "snodselist", "nozename", "nodels", "snodsette", "nODelist", "nodette", "Nodestyle", "nodeestate", "nODeline", "nodedemark", "nodesename", "nODestyle", "anodedata", "anodestate", "snodslist", "nodedelist", "nondeme", " nodename", "nodeme", "snodlist", "nodesh", "nodestyle", "Nodemark", "anodelist", "snodelist", "Nodesh", "nonedette", "nodlist", "nodeline", "NODesh", "nodesels", "nozemark", "NODemark", "nondelist", "nondata", "nodedette", "snodette", "nozels", "nodeelist", " nodeselist", "nODette", "anodeme", "nodseline", "nodedlist", "nodsette", " nodette", " nodels", "nodedeline", "anodedestate", "nozestyle", " nodesette", "nodslist", "nodename", "nodeata", "nodedesh", "anodata", "nodeselist", "nODlist", "nodselist", "nozesh", "nonedels", "nonedename", "NODestyle", "nODemark", "nodedata", "anodedelist", "nodesette", "snodeline"], "num": ["Num", "dim", "uni", "init", "span", "uri", "net", "np", "len", "nom", "lim", "max", "pos", "count", "norm", "loc", "m", "NUM", "con", "total", "multi", "n", "zero", "col", "um", "nb", "nr", "number", "nu", "index", "om", "mon", "div", "comb", "ul", "tri", "sum", "en", "nam", "dom", "umi", "temp", "part", "mu", "unit", "inc", "node", "mult"], "i": ["p", "x", "uri", "c", "ai", "info", "ii", "gi", "ori", "ix", "ie", "d", "l", "I", "ci", "yi", "m", "chi", "in", "ini", "multi", "ip", "iu", "g", "io", "bi", "si", "a", "b", "col", "it", "iv", "ui", "ik", "pi", "oi", "ji", "j", "li", "index", "isi", "hi", "mi", "di", "qi", "eni", "y", "xi", "part", "fi", "cli", "mu", "slice", "id", "o", "v", "start", "ri", "ti", "phi"]}}
{"id1": "21754659", "id2": "11673907", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSonendo", "getButtonSenico", "getbuttonSenira", "getButtonJonido", "getButtonSenido", "getButtonSonico", "getButtonJonico", "getButtonJonendo", "getbuttonSenico", "getButtonJonira", "getButtonSenendo", "getButtonSonira", "getbuttonSonira", "getbuttonSonico", "getbuttonSenendo", "getButtonSonendo", "getbuttonSenido", "getButtonSenira", "getbuttonSonido"], "buttonSonido": ["buttonSonardo", "buttonHomida", "btnSonigo", "buttonHonido", "buttonDonido", "buttonsonardo", "buttonDonino", "buttonDonigo", " buttonSonardo", "buttonHomido", "buttonHonino", "btnDonardo", "buttonsonini", "btnSonado", "btnDonigo", "btnSonido", "buttonTanido", "buttonHonardo", "buttonSenardo", "ButtonDonida", "ButtonSonida", "ButtonDonini", " buttonSenido", "buttonSenado", "ButtonDonido", "btnSonini", "buttonSenigo", " buttonSenado", "ButtonSonido", "buttonDonini", " buttonSenida", "buttonSenida", "btnSonardo", "buttonDonado", " buttonSenardo", "buttonTanida", "buttonSonino", "buttonsonado", "btnDonido", "buttonSenini", "buttonSenido", "buttonsonigo", "ButtonSonardo", "buttonSonigo", "buttonSonini", "buttonDonida", "buttonSonida", "ButtonDonardo", "buttonSenino", "buttonTanardo", "buttonsonido", "buttonHomardo", " buttonSonida", " buttonSonino", "buttonHonado", "buttonSonado", "buttonHomado", "ButtonSonado", " buttonSenino", " buttonSonado", "btnDonado", "buttonTanado", "ButtonSonini", "ButtonDonado", "buttonDonardo"], "e": [" ev", " exc", " exp", " cause", " E", " other", "event", " en", " ace", " caught", "ed", "E", " te", " ie", " ignored", " Event", " ate", " fe", " je", " inst", " invoked", "ee", " pe", " events", "t", " exception", "Event"], "fc": ["lf", "F", "xc", "fp", "FE", "fx", "cf", "wk", "FS", "WF", "c", "GF", "f", "fb", "tc", "wt", "il", "wic", "LC", "irc", " FC", "DC", "Factory", "con", "fm", "af", "bf", "ec", "flo", "FC", "bc", "pc", "lc", "fd", "fw", "isc", "fs", "fe", "WC", "fl", "nc", "fn", "fa", "fr", "enc", "fed", "mc", "fi", "ct", "xf", "PF", "CF", "roc", "dc"], "returnVal": ["ReturnValue", "ReturnVAL", "returnValue", "Returnval", " returnValue", "backval", "returnNum", " returnVAL", "backVal", "ReturnVal", " returnval", "returnVAL", "continueNum", "continueVal", " returnNum", "continueval", "continueValue", "backVAL", "ReturnNum", "backValue", "returnval"], "file": ["local", "source", "message", "filename", "File", "fp", "uri", "out", "cf", "path", "f", "info", "page", "use", "ile", "per", "input", "to", "l", "socket", "image", "single", "global", "get", "data", "folder", "object", "resource", "binary", "FILE", "directory", "io", "class", "url", "base", "name", "log", "b", "document", "files", "fe", "zip", "function", "connection", "lock", "handler", "full", "php", "lib", "up", "part", "feed", "dir", "sf", "user", "type", "db", "http"], "rutaGlobal": ["rutoInternational", "rucaGlobal", "rottaGeneral", "srottaLocal", "rottaCore", "srettaLocal", "rucaGeneral", "rottaGlobal", "rutaGeneral", "srottaGlobal", " rutoGlobal", "rutiCore", "srettaGlobal", " rutoGeneral", "rutoCore", "rettaLocal", "rutaReal", "rugaLocal", "rettaReal", "rucaInternational", "rugaInternational", "srutaGlobal", "rutoGeneral", "rutiInternational", "rundaInternational", "rutiReal", "rutiGlobal", " rutoInternational", "srettaInternational", "srutaCore", "rottaLocal", "srottaCore", "rutaCore", " rutaGeneral", "rutaInternational", "srottaGeneral", "rundaGlobal", "rutoLocal", "srutaReal", "srettaReal", "srutaGeneral", "rugaReal", "rugaGlobal", "rettaInternational", "rutiLocal", "srutaInternational", "rundaGeneral", "srutaLocal", " rutaInternational", "rutoGlobal", "rutaLocal", "rettaGlobal", "rutiGeneral"], "rutaRelativa": ["rutaMalariva", "rutaRelarivism", "rutaRelateiv", "rutaRelateiva", "rutaRelattiv", "rutaRelATivo", "rutaMalativism", "rutaRelarativa", "rutaRelarativas", "rutaRelarativo", "rutaRelativism", "rutaRelATiva", "rutaRelateivism", "rutaRelateivo", "rutaRelativas", "rutaMalativo", "rutaMalativas", "rutaRelativ", "rutaMalarivism", "rutaMalarivas", "rutaRelATivas", "rutaRelarivo", "rutaRelattiva", "rutaRelariva", "rutaRelarivas", "rutaRelarativ", "rutaRelattivo", "rutaRelattivism", "rutaRelativo", "rutaMalativa", "rutaRelattivas", "rutaRelATiv", "rutaRelarativism", "rutaRelariv", "rutaMalarivo"], "fis": ["fir", "viss", "Fiss", "fiss", "xys", " fiss", "xiss", " fir", "fris", "Fos", "Fis", "xis", "vos", " fIs", "Fir", "Fris", " fys", "friss", "vis", "xris", "frir", "fys", "vIs", "Fys", "fIs", "fros", "FIs", " fris"], "fos": ["infos", "infios", "fileos", "Fo", "tfos", "FOS", " fops", " fOS", "Fos", "Fis", "tfOS", "infis", "Fops", "tfo", "fo", "Focks", " fo", "fileops", " focks", "fios", "tfops", "fileo", "fileocks", "Fios", "fOS", "infOS", "fops", " fios", "focks"], "canalFuente": ["canalFUante", "canalKugent", "canalFuenza", "canalBuante", "canalsBuent", "canalsFuente", "canalFUent", "canalBuence", "canallBuente", "canalKuenza", "canalfuence", "canulFuencer", "canulFiente", "canalFient", "canalsFuento", "canalsFuante", "canalFience", "canallBuence", "canallFuence", "canulFiencer", "canalBuent", "canalFiente", "canulFuence", "canalBuento", "canalBuenza", "canalKuence", "canalFuent", "canulFuente", "canalMuent", "canalfuenza", "canalfugent", "canalFugent", "canalsBuante", "canalMuence", "canalJuence", "canalsBuento", "canalFuento", "canalJuente", "canulFient", "canallFugent", "canalsBuente", "canalFuante", "canallBuenza", "canallFuenza", "canalJuento", "canalJuante", "canallFuente", "canalKuente", "canulFience", "canalMuente", "canalMuencer", "canalFiencer", "canulFuent", "canalFUente", "canalsFuent", "canalJuent", "canalFUento", "canalJuencer", "canalBuente", "canalfuente", "canalFuence", "canalBugent", "canalFuencer", "canallBugent"], "canalDestino": ["canalCampania", "canalNegina", "canalNegino", "canalNegania", "canelDestania", "canalldestino", "canalCampino", "canelDestination", "canalNegination", "canaldestino", "canalldestinos", "canelDestina", "canalDestinos", "canelCampina", "canalDestination", "canalCampinos", "canaldestinos", "canalDestina", "canelCampino", "canallDestania", "canaldestination", "canelCampania", "canaldestania", "canallDestina", "canallDestino", "canalCampina", "canalldestania", "canaldestina", "canalDestania", "canelCampination", "canalldestina", "canalCampination", "canallDestinos", "canelDestino"]}}
{"id1": "255765", "id2": "10218878", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "label": 1, "substitutes": {"f": ["p", "x", "form", "lf", "F", "flat", "filename", "ref", "of", "fp", "fun", "fx", "cf", "path", "c", "s", "this", "w", "e", "l", "ff", "m", "fm", "folder", "fen", "bf", "self", "io", "g", "n", "a", "fo", "inf", "name", "b", "fd", "fs", "fe", "function", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "file", "df", "t", "feed", "r", "sf", "fi", "fold", "v", "d"], "in": ["source", "init", "gin", "session", "config", "w", "image", "con", "isin", "ins", "In", "d", "rec", "inn", "token", "pin", "with", "or", "IN", "data", "ini", "win", "n", "g", "up", "nin", "thin", "lin", "t", "diff", "bin", "str", "input", "socket", "serv", "a", "b", "gen", "is", "login", "reader", "get", "inc", "din", "p", "inner", "c", "ac", "pass", "ex", "l", "m", "it", "vin", "exec", "fe", "min", "connection", "fa", "lock", "cin", "again", "rin", "part", "r", "err", "ssl", "v", "ic"], "cbuf": ["cfuc", "rbbuf", "bcul", "bbuf", "bbuff", "ebuff", "fbuf", "rbux", "fbbuf", "bburs", "bbull", "rbuff", "cbutf", "bcur", "cbault", "rbul", "bcux", "buff", "buf", "dbuc", "rbuc", "fbuc", "cbuc", "dbuff", "zbuu", "cbux", "zbuf", "bcuff", "rbault", "rbutf", "cbuff", "ebuf", "bcuf", "CBuc", "bcull", "bux", "bault", "CBuf", "fbuff", "bcurs", "CBul", "ebuu", "cfuf", "dbur", "zbuff", "cfuff", "dbuf", "cbur", "rbull", "cfbuf", "cbull", "cbul", "CBuff", "rbuu", "rbuf", "rburs", "cburs", "cbuu", "ebutf", "cfur", "bcuc", "zbutf", "cbbuf", "bcault"], "read": ["work", "text", "x", "buffer", "Read", "parse", "want", "config", "w", "k", "cel", "val", "build", "close", "name", "log", "add", "pe", "report", "reads", "ack", "size", "stream", "repeat", "write", "ak", "ok", "iter", "un", "y", "key", "feed", "type", "start", "error", "d", "run", "last", "sync", "check", "load", "use", "view", "level", "ed", "count", "data", "play", "io", "g", "allow", "rc", "raw", "used", "ing", "insert", "id", "select", "know", "call", " reading", "reading", "update", "lex", "READ", "input", "send", "skip", "socket", "sleep", "ind", "readable", "print", "valid", "bit", " write", "each", "ize", "only", "en", "orig", "wait", " READ", "loop", "put", "reader", "bind", "get", "inc", "fill", " Read", "ride", "seek", "create", "re", "se", "length", "pass", "q", "record", "open", "old", "find", "connect", "ink", "num", "it", "change", "child", "hex", "oct", "index", "full", "r", "er", "end", "draw"], "totRead": ["totoRead", "totReading", "tobyLoad", " totLink", "notLoad", "totiBuild", "octotoReading", "tazonLoad", "TotWrite", "totSearch", " totalBuild", "TotaWrite", "totalBuild", "ntotWrite", "intotRead", "nottRead", "intottLoad", "tottSearch", "totaReading", "totiLink", "TottLoad", "totalAccept", "totaRead", "tobyUse", "tottFind", "totoLength", " totalWrite", "nottWrite", "dottLoad", "tottClose", "TotaLoad", "towWrite", "tetRead", "dotLoad", "tottedFollow", "totoConnect", "tottReader", "TottReader", "towReading", "tntWrite", "TottSearch", "dottReading", "totoUse", "intottBuild", "totingGet", "tottUse", "totaLink", "ntotRead", "totClose", "totGet", "tottBuild", "octotRead", "totoFind", "tottAccept", "dotReader", "TottFollow", "totalRead", "TotConnect", "towRead", "totAccept", "totoLoad", "towLoad", "totaBuild", "dottReader", "totoReading", "dotUse", "octotLength", "nottLoad", "tochLoad", "ntottLoad", "tottConnect", "TotSearch", "tatReader", "totingWrite", "TottRead", "tottLoad", "dottWrite", "totUse", "TotLoad", "dottUse", "TotFollow", "ntottReader", " totalLink", "totingSearch", "tottDraw", "totLoad", "totReader", " totalRead", "toyWrite", "tetWrite", "dottRead", "totLink", "tottGet", "toyDraw", "tntRead", "ntottRead", "intotLoad", "tottWrite", "totiRead", "TotaRead", "tochWrite", "TotDraw", "TotGet", "totaWrite", "tochRead", "intotBuild", "toyLoad", "tottedRead", "tochReader", "totingRead", "notWrite", "notAccept", "tollWrite", "ntottWrite", "TotaDraw", "tntReader", "tottRead", "TottConnect", "totoWrite", "ntotReader", "intottClose", "TottWrite", "tcotBuild", " totBuild", "tatRead", "tobyRead", "TottGet", "tcotLoad", "TotReader", " totWrite", "octotReading", "tollRead", "totalLink", "tollLoad", "totBuild", "ntotLoad", "tntLoad", "totingConnect", "tobyFind", "tcotClose", "tazonBuild", "tottLength", "nottAccept", "tollReading", "tottedWrite", "notRead", "dotReading", "tottFollow", "totalLoad", "tatLoad", "totingFollow", "tazonClose", "towLength", "TotReading", "totaLoad", "tottReading", "totDraw", "dotWrite", "totoSearch", "totLength", "totWrite", "octotoWrite", "totConnect", "tottedGet", "tatWrite", "dotRead", "octotWrite", "tetReading", "intottRead", "dottFind", "dotFind", "intotClose", "totaDraw", "totalWrite", "octotoLength", "TottReading", "totFind", "totaReader", "tetLoad", "toyRead", "tcotRead", "tazonRead", "TotRead", "totFollow", "totiWrite", "octotoRead", "towAccept"], "out": ["p", "x", "init", "output", "client", "sync", "net", "c", "ac", "s", "w", "plus", "ex", "l", "socket", "conn", "OUT", "writer", "n", "g", "io", "a", "up", "b", "outer", "ext", "exec", "obj", "conf", "h", "fn", "exp", "connection", "Out", "In", "outs", "inc", "again", "off", "file", "parent", "part", "t", "err", "r", "o", "v", "bin", "d"], "i": ["x", "source", "init", "buffer", "current", "ai", "I", "k", "ci", "abi", "chi", "ip", "name", "u", "li", "y", "key", "slice", "start", "d", "ti", "uri", "info", "ei", "one", "data", "ini", "multi", "iu", "bi", "io", "g", "pi", "api", "j", "eni", "id", "hi", "me", "ii", "e", "input", "ind", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "zi", "ri", "my", "phi", "p", "length", "z", "c", "ni", "gi", "ix", "ori", "ie", "l", "yi", "m", "q", "it", "ui", "ik", "oi", "index", "fi", "r", "v", "ic"]}}
{"id1": "8667872", "id2": "4798332", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"hash": ["text", "copy", "str", "update", "component", "dump", "build", " decipher", " sum", "print", " fingerprint", "add", "SHA", "Hash", "code", "gen", "hex", " Hash", "h", "string", "write", "sum", " hashes", " hashing"], "data": ["text", "source", "message", "result", "buffer", "media", "cache", "output", "str", "json", "length", "DATA", "memory", "info", "this", "bytes", "input", "dump", "image", "padding", "format", "storage", "a", "name", "database", "base", "picture", "address", "hex", "dat", "body", "string", "connection", "size", "alpha", "value", "key", "response", "reader", "content"], "digest": ["bigest", "Digester", "DigEST", "bigester", "digEST", "digge", "bigger", "Diger", " digse", "hedge", "decest", "Digger", "bigse", "digger", " digger", "signEST", " digit", " digge", " digEST", "diger", "hedester", "hedest", "Digse", "signester", " diger", "Digge", "Digest", "decester", "digit", "signer", "signse", "signit", "digester", " digester", "signest", "decit", "decEST", "digse", "hedger"]}}
{"id1": "18374478", "id2": "11334468", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"updateUser": ["editUser", "deleteUsers", "deleteuser", "createAccount", " updateRole", "createRole", " updateuser", "deletePassword", "UpdatePassword", "adduser", " updatePassword", "addUsers", "createUser", "Updateuser", "deleteRole", " updateWord", "UpdateMember", "editAccount", "createUsers", " updateMember", "updateAccount", "editRole", "UpdateUser", "updateMember", "editUsers", "updatePassword", "updateUsers", "UpdateRole", "addWord", "deleteMember", "deleteWord", "updateduser", "updateWord", "updateuser", "UpdateUsers", "deleteUser", "addUser", " updateAccount", "updatedWord", " updateUsers", "updatedUser", "updateRole", "UpdateWord", "updatedUsers"], "user": ["p", "account", "match", "me", "group", "message", "contact", "app", "result", "ro", "current", "str", "client", "username", "session", "instance", "author", "config", "ver", "update", "this", "model", "use", "view", "person", "page", "system", "per", "manager", "project", "USER", "data", "record", "object", "resource", "auth", "module", "self", "job", "character", "name", "log", "null", "server", "you", "pool", "post", "connection", "rule", "string", "profile", "plugin", "full", "used", "creator", "users", "version", "bug", "row", "response", "custom", "site", "parent", "member", "content", "User"], "conn": ["org", "util", "pt", "cache", "uc", "client", "sync", "oss", "cb", "c", "ac", "cat", "config", "reg", "Connection", "nt", "ca", "Conn", "serv", "ci", "socket", "loc", "con", "close", "pg", "act", "pub", "ec", "n", "sth", "connect", "core", "url", "pc", "ann", "log", "col", "ou", "server", "host", "pool", "cr", "exec", "conf", "ch", "api", "rc", "connection", "cc", "nc", "h", "lock", "cp", "cond", "enc", "coll", "pr", "el", "cm", "sql", "ha", "cn", "mc", "part", "cli", "ob", "ct", "ctx", "db", "co", "dc"], "autoCommit": ["autoComend", "autoComits", "autoRebits", "autoCommIT", "autoDebend", "autoDebIT", " autoComits", "autoBlend", "autoComIT", " autoDebit", " autoDebmit", "autoComit", "autoDebitting", "automaticDebit", "autoCmit", "automaticCommIT", " autoComit", "autoComite", "autoBlIT", "autoDebits", "autoAbit", "autoAbmit", "autoAbited", " autoCommmit", " autoCommitting", "autoCommite", "autoCommend", "autoBlmit", "autoDebite", "autoCommitting", "autoBlit", "autoCommits", "autoCited", " autoCommited", "automaticCommmit", " autoDebitting", "automaticDebmit", "automaticCommit", "autoRebite", "autoAbitting", "autoCit", "autoCitting", "automaticCommend", " autoCommits", " autoCommite", " autoComite", "autoCommmit", " autoDebited", "automaticDebIT", "autoRebit", "autoCommited", "autoDebmit", "autoDebited", "automaticDebend", "autoDebit"], "deleteRoles": ["delRole", "delLodes", "deleteGroles", "deleteSlases", "deleteRodes", "deleteNoots", "deleteDils", "deleteRases", "deleteRsases", "deleteGrils", "deleteSlole", "deleteGroots", "deleteRsoles", "insertRooles", "deleteCodes", "deleteCases", "deleteDoots", "delRoles", "destroyNoles", "destroyNils", "destroyRols", "deleteNols", "deleteRsole", "destroyNols", "deleteRoases", "deleteDases", "delLoles", "deleteDules", "insertRoases", "deleteGrols", "insertRoules", "deleteRoots", "deleteRols", "deleteRsules", "deleteRole", "deleteSloles", "deleteColes", "delLole", "deleteNils", "deleteRils", "deleteRules", "deleteLodes", "delRases", "delRodes", "destroyNoots", "insertRases", "deleteNoles", "deleteLole", "deleteRoules", "insertRules", "destroyRoles", "deleteLases", "deleteDoles", "deleteRoole", "insertRoole", "deleteRooles", "insertRole", "deleteSlodes", "deleteDole", "delLases", "destroyRoots", "deleteDols", "deleteLoles", "destroyRils", "deleteCole"], "insertRoles": ["insertRsoles", "insertRodes", "deleteSlanges", "insertGows", "deleteRoots", "deleteSloles", "insertShules", "insertGoots", "insertLules", "insertSloots", "copyRoots", "updateRoles", "insertRols", "insertRsanges", "insertSlanges", "updateLles", "updateRles", "deleteRodes", "insertRsodes", "insertRanges", "insertRles", "insertLows", " insertRole", " insertRodes", "insertSole", "deleteSloots", "copyRules", "insertRules", "insertSlodes", " insertSholes", "copyGoots", "insertLoles", "insertGules", "insertLles", "copyGows", "insertLols", "insertRows", " insertShole", "insertRsles", " insertShules", "insertRsols", "insertSodes", "insertRsoots", "updateRols", "updateLoles", "deleteRanges", "insertRsules", "insertRoots", "insertRole", "insertLoots", "updateLols", "deleteSlodes", " insertRules", "insertSloles", "insertSholes", "copyRows", "insertShole", "insertRsows", "copyGoles", "copyGules", "insertSules", "updateLules", "insertShodes", " insertShodes", "copyRoles", "insertGoles", "updateRules", "insertSoles"], "role": ["group", "relation", "ro", "username", "tool", "alias", "slave", "link", "one", "de", "l", "to", "or", "val", "module", "service", "resource", "force", "shadow", "error", "Role", "base", "roller", "label", "rl", "function", "guard", "string", "rule", "tag", "profile", "repl", "range", "route", "row", "key", "entry", "le", "type", "member", "ole", "rol", "zone"]}}
{"id1": "11183087", "id2": "15202804", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"doPost": ["doingPOST", " doSearch", "handlePost", "handlePut", " doPut", "handlePOST", "doPOST", "doPut", "doingSearch", "doingPost", " doPOST", "doSearch", "handleSearch", "doingPut"], "request": ["right", "message", "press", "create", "call", "remote", "result", "the", "forward", "buffer", "current", "client", "hello", "instance", "frame", "config", "info", "model", "event", "use", "view", "http", "state", "e", "have", "input", "enter", "image", "project", "complete", "get", "req", "data", "q", "web", "object", "resource", "context", "QUEST", "error", "url", "subject", "initial", "pe", "server", "post", "query", "child", "external", "queue", "rf", "parent", "route", "pull", "r", "er", "join", "rate", "user", "type", "xml", "Request", "report", "order", "application"], "response": ["message", "result", "output", "client", "model", "page", "view", "application", "resp", "writer", "web", "object", "resource", "reply", "guide", "document", "next", "server", "Response", "pool", "api", "res", "body", "onse", "connection", "respond", "results", "template", "site", "parent", "report", "status", "http"], "senha": ["zenca", "sanlah", "tonha", "renaka", " senwa", " senaka", "zensha", "senlah", "senwa", "renha", "senhi", "suitsha", "renHa", "tonlah", "snha", "sanha", "sanwa", "suitla", "suithi", "snsha", "senca", "tonHa", "zenHa", "snhi", "suitha", "renca", "zenaka", "senaka", "zenla", "zenha", "senHa", "snla", " senca", "tonwa", " senlah", "zenhi", "sensha", " senHa", "senla", "sanHa"], "email": ["account", "secret", "message", "business", "language", "username", "hello", "home", "alias", "environment", "model", "phrase", "e", "line", "data", "example", "service", "ip", "url", "name", "server", "label", "password", "zip", "address", "letter", "string", "Email", "fax", "office", "file", "login", "id", "user", "xml", "mobile", "mail"], "messageDigest": [" messagedigester", "messagedigester", " messageDigend", " messagedigEST", "medigester", "messageDEST", "messageDigend", "messagedigEST", " messageDigEST", "messagedigest", " messageDend", " messageDester", "messageDigEST", "messageMailEST", "messageDester", " messagedigest", "meDigher", "messageDher", "medigest", " messageDigester", "meDigEST", "messageDigester", "messagedigher", "messageDest", " messageDest", "messageMailend", "meDigest", " messageDEST", "messagedigend", "medigher", "messageMailest", "messageMailester", "meDigester", "medigEST", "messageDend", "messageDigher"], "usuario": ["ussuarial", "usituarial", "usuiario", "ususarius", " usuariat", "usuitarium", "suuarial", "usituasio", " ususariat", "usuarius", "usluasio", "usuirio", "usituario", "usuarial", "ussurio", "ussuasio", " usuiarium", "usuiarium", " usurio", "ususario", "usguariat", "usueariat", "usuariat", " usuillo", "usuearius", "usluarial", " ususillo", "ussuarium", " usuirio", "suuario", "suurio", "ususariat", "suluarial", "usguarius", "usuitrio", "usuitario", " usuarius", "sulurio", "usurio", "usuarium", "usueario", "ussuario", "suluario", "usuillo", "suuasio", "usuiasio", " usuiasio", "usguillo", "usguario", "uslurio", "suluasio", " ususario", " usuiario", "usiturio", "ususillo", " usuasio", "usuitasio", "usluario", " usuarium", "usuasio", " ususarius", "usueillo"], "redirect": ["induce", "Redirect", "edirect", "predroute", "rerict", "reroute", "Redroute", "predirection", " redition", " redurl", " redirection", "Redurl", " redrict", "reirect", "predrict", " redRECT", "predRECT", "Redrict", "redirection", " reduce", "predirect", "redrict", "Redition", "redurl", "indrict", "reduce", "indirect", "reirection", "preduce", "RedRECT", "redition", "Redirection", "edition", "edurl", "edirection", "redroute", "indirection", "redRECT"], "session": ["message", "group", "cookie", "app", "result", "cache", "browser", "client", "flash", "ession", "config", "info", "system", "state", "page", "use", "view", "event", "person", "input", "image", "data", "service", "object", "proxy", "comment", "storage", "document", "server", "query", "sl", "child", "sp", "connection", "sid", "ssl", "site", "user", "Session", "node", "http"]}}
{"id1": "5977352", "id2": "19687456", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyDir", "copyfile", " copyDir", "CopyFile", "copyFiles", " copyFiles", "transferfile", "transferFile", "transferDir", "Copyfile", "CopyFiles", " copyfile", "CopyDir"], "src": ["source", "filename", "sb", "uri", "fp", "path", "config", "s", "this", "buf", "view", "input", "ource", "conn", "inst", "loc", "data", "loader", "resource", "proxy", "img", "url", "tmp", "b", "proc", "obj", "files", "sel", "sc", "sl", "dist", "rc", "rb", "ins", "gb", "stream", "file", "slice"], "dest": ["source", "cache", "output", "table", "st", "path", " destination", "config", "home", "store", "this", "master", " Dest", "txt", "d", "de", "trans", "project", "rest", "cdn", "folder", "done", "dep", "later", "img", "class", "url", "tmp", "name", "cont", "null", "die", "obj", "destroy", "zip", "dist", "cp", "thin", "orig", "desc", "file", "temp", "route", "wb", "Dest", "part", "dir", "parent", "opt", "target", "delete", "dc"], "bufSize": ["buf2", "ufSize", "bufferSize", "buffersize", " bufsize", "bufLen", "uf2", "queueSize", "ufLen", " buf2", " bufLen", "queuesize", "queueLen", "buffer2", "ufsize", "bufsize", "bufferLen"], "force": ["ride", "p", "source", "Force", "remote", "ist", "sync", "push", "dirty", "load", "forces", "front", "f", "store", "use", "place", "hard", "urse", "count", "base", "deep", "rc", "require", "write", "only", "auto", "replace", "like", "file", "parent", "forcing", "pull", "route", "id", "forced", "apply", "flush", "delete", "no"], "buffer": ["source", "result", "cache", "length", "memory", "load", "buff", "fb", "buf", "seed", "bytes", "uffer", "border", "padding", "data", "binary", "zero", "limit", "url", "base", "b", "null", "transfer", "split", "address", "append", "Buffer", "queue", "write", "raw", "batch", "reference", "iter", "value", "request", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "text", "ride", "seek", "create", "select", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "lex", "len", "use", "view", "pass", "show", "level", "READ", "i", "input", "send", "skip", "ed", "count", "k", "sleep", "ind", "data", "build", "close", "ad", "open", "play", "find", "ip", "io", "n", "connect", "next", "b", "add", " write", "allow", "exec", "reads", "index", "size", "write", "raw", "block", "iter", "wait", "feed", "id", "reader", "end", "get", "start", "d", "fill", "run"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "c", "ac", "f", "pass", "ex", "i", "input", "socket", "conn", "image", "sin", "inside", "serv", "IN", "m", "con", "win", "ini", "up", "n", "isin", "a", "url", "base", "din", "b", "nin", "min", "ins", "connection", "cin", "thin", "In", "inc", "again", "rin", "kin", "lib", "part", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "ac", "at", "home", "this", "with", "w", "ex", "i", "one", "max", "socket", "conn", "OUT", "line", "image", "by", "writer", "n", "io", "up", "bin", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "nin", "connection", "exp", "plain", "Out", "write", "outs", "again", "off", "lib", "part", "err", "key", "o", "id", "user", "inc", "co", "can", "no"]}}
{"id1": "416857", "id2": "18202328", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 0, "substitutes": {"process": ["init", "output", " handle", "parse", " inspect", " display", " loop", " Process", "proc", "exec", " analyze", " report", " processes", " processing", " test", " finish", "run", "Process", " analyse", " work", "loop", " program", " browse", "report", "status"], "dir": ["p", "work", "source", "filename", "md", "File", "str", " Dir", "dict", "IR", "Dir", "c", "download", "config", "home", "wd", "txt", "root", "keep", "Name", "project", "src", "manager", "pos", "loc", "data", "folder", "object", "DIR", "ir", "dl", "dest", "directory", "base", "name", " d", "url", "fd", "zip", "dist", "dat", "dr", "Directory", "string", "direction", "dy", "target", "prefix", "lock", "cd", "file", "lib", "dn", "id", "pkg", "diff", "db", "d", "doc", "rel"], "list": ["x", "source", "cache", "out", "parse", "config", "bl", "left", "close", "we", "log", "name", "null", "pe", "cont", "code", "post", "li", "see", "header", "size", "queue", "write", "iter", "sort", "key", "entry", "listed", "pre", "group", "last", "result", "arr", "lists", "load", "all", "view", "show", "tree", "data", "names", "lc", "split", "live", "j", "coll", "batch", "test", "pull", "diff", "id", "parent", "ls", "match", "call", "LIST", "table", "output", "state", "link", "tail", "e", "input", "keep", "line", "map", "print", "array", "stat", "string", "chain", "detail", "filter", "block", "loop", "get", "status", "p", "set", "download", "page", "l", "complete", "record", "open", "www", "server", "index", "lock", "cl", "full", "file", "v"], "n": ["p", "x", "nat", "ln", "ot", "z", "net", "c", "ni", "all", "not", "len", "w", "e", "nt", "l", "conn", "none", "N", "count", "m", "ner", "nl", "left", "ne", "g", "nn", "name", "num", "b", "nb", "number", "j", "h", "nc", "fn", "size", "en", "sn", "iter", "ns", "y", "t", "adj", "network", "v", "node", "d", "no"], "bubblesort": ["rubblesorted", "bubbleshop", "ubblessort", "bubblingsort", "bubblerord", "grabblersorter", "bubbsort", "bubblesalt", "ubblingsort", "bubblehop", "bubbleort", "rubbleorted", "bubblinghop", "bubbesorter", "bubbleORT", "bublesalt", "ubblingport", "ubblingorted", "bubblersorter", "rubblessort", "bubbledorted", "barblesort", "bublesorter", "ubblesport", "ubblingort", "bubblingport", "bubbssort", "bubblesORT", "rubbleORT", "ubblehop", "grabblersalt", "rubblesORT", "bubblessort", "bubblesorted", "bubblerorter", "barblesorter", "bubblingorter", "bubblesorter", "bubbsorter", "grabblerssort", "rubblesort", "bubblersord", "rubbledorts", "bubblersalt", "bubblingorted", "rubblesorts", "rubbledsort", "bubbesport", "rubbleorts", "bubbleorter", "bubblesorts", "bubblerort", "barblesport", "bubblingORT", "bubbledorts", "barblerorter", "bublessort", "ubbleshop", "bubbesort", "bubblesord", "ubbleort", "rubblingsort", "bubbledORT", "bubbledhop", "bubblingorts", "bubblersport", "bubbledorter", "barblerort", "grabblesorter", "bubblesport", "bublesort", "barblerport", "rubbleort", "grabblesalt", "rubbledort", "bubblerorts", "grabblessort", "bubbsorts", "bubblersort", "bubbleorted", "ubblesort", "grabblersort", "rubblesorter", "bubbledport", "rubblingorted", "bubbledort", "bubblerssort", "rubbledorter", "barblerord", "grabblesort", "bubblerport", "ubbleorted", "rubblingorter", "bubbleorts", "bubbledsort", "bubbesord", "bubblingalt", "rubblingort", "bubblersorted", "barblesord", "ubblesorted", "bubblingort", "bubbsorted"], "i": ["x", "init", "ai", "I", "image", "ci", "chi", "directory", "isin", "name", "u", "li", "y", "slice", "start", "ti", "d", "uri", "shift", "ei", "ini", "multi", "bi", "iu", "io", "g", "sup", "lc", "iv", "pi", "api", "j", "anti", "eni", "cli", "mu", "id", "diff", "hi", "field", "ii", "e", "ind", "next", "si", "b", "is", "ji", "mi", "di", "qi", "xi", "ri", "phi", "p", "z", "inner", "c", "ni", "gi", "ix", "ori", "ie", "l", "inst", "uli", "yi", "m", "in", "it", "ui", "ik", "oi", "index", "part", "fi", "v"], "f": ["p", "F", "fp", "fx", "c", "fb", "w", "e", "l", "m", "folder", "g", "base", "b", "fd", "fw", "obj", "fs", "fe", "j", "h", "fn", "fr", "fa", "file", "df", "r", "fi", "sf", "v", "d", "raf"], "img": ["Image", "p", "png", "ani", "app", "iframe", "im", "br", "plug", "ai", "fb", "aug", "input", "l", "src", "image", "inst", "ff", "m", "fm", "aff", "pg", "g", "url", "pic", "NG", "inf", "iv", "hr", "fw", "tif", "picture", "obj", "bg", " image", "sl", "j", "api", "gd", "h", "div", "imag", "agi", "tf", "ng", "impl", "gif", "fc", "icon", "jpg", "v", "fig", "images"], "whichcase": ["whichpatch", "whoseCase", " whichcode", "howconfig", "whichconfig", " whichspace", "whatCase", "whetherCase", "howpath", "whethercase", "howcase", "whatcode", "howCase", "whichcode", "whichmatch", "hiscase", "whosecode", "existingpatch", "existingcase", " whichmatch", "whocase", "Whichmatch", "existingCase", "whosepath", "Whichpath", " whichpath", "whatspace", "whethermatch", "whosematch", "whichspace", "WhichCase", "Whichcode", "whichpath", "whatpath", "hiscode", "whocode", "Whichconfig", "whatcase", "existingcode", "whosecase", "whosespace", "whoCase", "whetherpatch", "hisCase", "hispatch", "whoseconfig", "Whichcase", "Whichpatch", "whosepatch", " whichCase", "whichCase"], "lastDigit": ["lastdigiton", "lastPosit", " lastDigger", "lastPosbit", "lastAddit", "lastdigbit", "lastDigger", "lastDits", " lastAddit", " lastAddits", " lastDigits", "lastDigition", "lastPosi", "lastAddith", "lastAddits", "lastPosition", "lastModbit", "lastCommith", "lastMarkash", "lastMarkith", "LastDigith", "lastSignbit", " lastDigi", "lastModith", "lastModash", "lastDigbit", "lastdigit", "lastCommi", "lastSignger", " lastDigbit", " lastDigition", "lastSignith", "lastModIT", "LastDigash", "lastDIT", "lastModit", " lastDigiton", "lastMarkits", "LastDigit", " lastAddith", "lastPosith", "lastSignit", "LastDigits", "lastDigiton", "lastAdditon", "lastDith", "lastDigith", "lastModits", "lastDigi", "lastModi", "lastdigith", "lastDit", "lastMarkit", "lastCommit", "lastdigger", " lastDigith", "lastDigIT", "lastdigits", "lastDigits", "lastCommition", "LastDigIT", "lastDigash", " lastAdditon"], "sorted": ["Sort", "setsored", "sorting", "unsorted", " sort", "setsorted", "nsorted", "saved", "Sorter", "unsorting", " sorter", "absort", "absorter", "sored", "Sorted", "insorted", "insorting", "setsorting", "nsaved", "unsort", "insaved", "absorting", "setsaved", "sort", "absorted", "nsored", "insored", "sorter", " sorting", "nsorting", "Sorting", "unsorter"], "temp": [" output", " tem", "buffer", "out", " Temp", "z", "c", "w", " tail", "l", "m", " template", "Temp", " big", "tmp", " temporary", " mm", " buf", " w", " seq", "size", " tmp", " buffer", " orig", " mem", " count", " result"], "tempp": ["prompl", "mempl", "tempar", "prompar", "timpar", "prompp", "timpl", "timporal", "templ", "memporal", "temporal", "mempar", "timpp", "promporal", "mempp"]}}
{"id1": "23273706", "id2": "23467091", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getProjectTreeData": ["getProjectTreeInfo", "getprojecttreeInfo", "getProjecttreeDATA", "getProjectDocumentData", "getProjectPageDATA", "getprojectTreeData", "getProjectDocumentMeta", "getProjecttreeInfo", "getProjectPageData", "getprojecttreeDATA", "getProjectPageMeta", "getprojecttreeMeta", "getProjectDocumentInfo", "getprojectTreeMeta", "getProjectTreeMeta", "getProjectTreeDATA", "getProjecttreeData", "getProjectPageInfo", "getProjectDocumentDATA", "getProjecttreeMeta", "getprojectTreeInfo", "getprojecttreeData", "getprojectTreeDATA"], "treeData": ["TreeList", "contentInfo", "TreeArray", "TreeData", "treeArray", "monkeyData", "monkeyDec", "reeText", "treeDec", "contentText", " treeInfo", "treeText", "bodyDat", "storyDat", "reeDat", "reeInfo", "treeDat", "monkeyArray", "reeList", " treeDat", "storyData", " treeDec", "storyDec", "storyArray", "contentData", "contentDat", "reeArray", "bodyList", "bodyData", "reeString", " treeArray", "reeData", " treeText", "treeList", " treeString", " treeList", "bodyString", "TreeString", "treeString", "TreeInfo", "monkeyDat", "treeInfo"], "filename": ["figure", "whatever", "uri", "fp", "ppa", "path", "username", "kl", "wav", "title", "ername", "fil", "txt", "sheet", "data", "folder", "location", "metadata", "dll", "journal", "framework", "directory", "FILE", "url", "database", "name", "tmp", "kn", "kj", "fd", "files", "password", "dylib", "SourceFile", "upload", "string", "fn", "prefix", "Filename", "file", "nil", "jpg", "xml"], "urlString": [" urlURL", "URLString", "addressStr", "URLURL", "URLstring", "urlStr", "addressString", "URLStr", "addressURL", "urlUrl", "locationUrl", " urlstring", "urlURL", "locationString", "URLUrl", "urlstring", " urlUrl", "addressstring", "locationStr", "locationstring", " urlStr"], "urldata": ["urlledATA", "URldat", "urlledata", "urlledta", "urlfat", " urLDdata", " urLDta", "urldat", "urLDat", "urleddata", "urledATA", "urllata", "urledta", " urldATA", "urledata", "urLDta", " urLDATA", "URlddata", "urLData", "urldATA", "URlfata", "URlfat", " urldta", " urLData", "urlldata", "urlfATA", "urlfata", "urlfdata", "urllat", "urldta", "URlfATA", "URldata", "urLDATA", "urllATA", "URldATA", "urlleddata", " urlddata", "urlddata", "urLDdata", "URlfdata"], "factory": ["cFactory", " fault", "confFactory", " fFactory", "conflier", "confiller", "liller", "cflier", "fuild", "ciller", "lactory", "fFactory", "ufactory", "luild", "cault", "cfFactory", "pFactory", "ufuild", "cfiller", "flier", " flier", "lictionary", " fictionary", "pault", "ufictionary", "fault", "pactory", "filler", "confactory", " fuild", "ufiller", "piller", "cfactory", "cactory", "fictionary", " filler"], "parser": ["p", "lp", "arser", "util", "uri", "se", "json", "parse", "instance", "s", "driver", "root", "l", "manager", "loader", "writer", "ph", "Parser", "builder", "pdf", "ger", "up", "b", "utils", "monkey", "fruit", "api", "string", "jack", "handler", "plugin", "auto", "t", "er", "r", "reader", "parent", "xml", "raf", "library", "http"], "u": ["p", "uni", "uv", "util", "su", "uri", "uf", "us", "c", "plug", " ur", "eu", "s", "l", "tu", "ru", "yu", "io", "iu", "url", "ou", "b", "ui", "nu", "ur", "ul", "lu", "universal", "cu", "hu", "uu", "U", "o", "d", "http"], "is": ["p", "mis", "as", "ris", "init", "uri", "IS", "isa", "us", "ai", "info", "s", "its", "ori", "isu", "iss", "are", "ie", "Is", "serv", "or", "iso", "gets", "in", "ib", "lis", "ir", "ip", "io", "ar", "it", "fs", "ui", "isl", "pi", "api", "ais", "ios", "es", "abs", "iris", "obs", "ob", "bis", "has", "ri", "ops", "http"], "os": ["OS", "ops", "as", "dos", "ps", "so", "oss", "us", "bos", "s", "oes", "ens", "pos", "or", "iso", "ose", "gets", "sys", "ol", "oa", "opens", "io", "ros", "ms", "cos", "los", "fs", "bs", "fits", "oos", "ios", "aos", "ils", "es", "obs", "Os", "o", "ob", "osi", "bis", "oses", "http"], "iBufSize": ["iBufsize", "iBbufsize", "iBlfLength", "iBbufSize", "iByteufLength", "iBytebufSize", "iLlfLength", "iBytebufLength", "iByteufsize", "iLlfSt", "iBbufLength", "iByteufSize", "iBufLength", "iLufSt", "iLlfSize", "iBuffLen", "iLufSize", "iBbufLen", "iBlfsize", "iBufferSt", "iBufferSize", "iBuffLength", "iLlfsize", "iBlfLen", "iBuffersize", "iBytebufLen", "iBuffSt", "iLufLength", "iBytebufsize", "iBuffsize", "iBufSt", "iBuffSize", "iByteufLen", "iBufLen", "iBlfSt", "iLufsize", "iBufferLength", "iBlfSize"], "inBuf": ["inBluf", " inFbuf", "inbuf", " inFaf", "inDuff", "inBunk", "inFuf", "inFuff", "inDbuf", "outBuffub", "outBuffump", "inBump", "outBump", "inCbuf", "inCunk", " inBuff", "inBlunk", " inBaf", "inCuf", " inBump", "inPluf", "outBuf", "outBuffbuf", "inBuffuf", "inPlump", "inDuf", "inBub", "inDaf", " inBunk", " inCunk", " inCuf", "outBbuf", "inbub", "inBuffump", " inCbuf", "inCuff", " inCump", "inPlunk", "inFaf", "inBbuf", "inbump", "inFbuf", "outBuffuf", "inBuff", "inBuffbuf", "inBlbuf", " inFuff", "inbbuf", "inBlub", "inBuffub", "inBaf", "inCaf", "inBlump", "outBub", "inPlbuf", "inCump", " inFuf", " inBbuf"], "iNumRead": ["pNumberRead", "inumWritten", "qiNumREAD", "iChanBuild", "qiNumread", "pNumberWritten", "iValREAD", "iNumread", "inumread", "iLenRead", "iNumREAD", "iNumberBuild", "pNumberread", "pNumWritten", "iLenWritten", "iFatWritten", "inumWrite", " iFatWritten", "iChanREAD", "qiValread", " iFatRead", "pNumRead", "iNumWritten", "iNumberWrite", "iValRead", "iFatRead", " iNumWrite", "inumRead", "iValBuild", "iNumberread", "qiValREAD", "qiValBuild", " iFatWrite", "pNumread", "iNumberREAD", "iValread", "iNumberWritten", "qiNumBuild", "iChanRead", "qiNumRead", "iFatWrite", "iNumberRead", "iChanread", "pNumWrite", "iNumWrite", "qiValRead", "iLenWrite", " iNumWritten", "pNumberWrite", "iNumBuild"], "f": ["p", "F", "fp", "uf", "c", "s", "e", "l", "ff", "m", "n", "g", "io", "b", "fd", "fs", "fe", "j", "h", "fn", "fr", "fa", "handler", "rf", "full", "fc", "file", "df", "t", "r", "fi", "sf", "o", "feed", "v", "d"], "inputstream": ["Inputsw", " inputsw", "Inputchannel", " inputchannel", "outputchannel", "Inputstream", "contentStream", "InputStream", " inputStream", "inputsystem", "contentsw", "contentstream", "outputStream", "Inputsystem", "inputsw", "outputstream", "inputStream", "contentsystem", " inputsystem", "inputchannel"], "document": ["p", "source", "DOM", "media", "output", "language", "info", "page", "e", "l", "tree", "project", "ocument", "xml", "data", " documents", "m", "record", "object", "context", "director", "n", "directory", "window", "null", "docs", "Document", "Documents", "container", "list", "html", "dom", "office", "file", "collection", "t", "response", " documentation", "parent", "node", "d", "doc", "content"], "nodelist": ["nodedestyle", "nodemark", "nodestate", "nodata", "anodedeme", " nodesels", "nondestate", "nodedestate", "nodedeme", "snodseline", "NODelist", "nonedelist", "nozette", " nodesename", "Nodelist", "nozelist", "nODesh", "nodeeme", "snodselist", "nozename", "nodels", "snodsette", "nODelist", "nodette", "Nodestyle", "nodeestate", "nODeline", "nodedemark", "nodesename", "nODestyle", "anodedata", "anodestate", "snodslist", "nodedelist", "nondeme", " nodename", "nodeme", "snodlist", "nodesh", "nodestyle", "Nodemark", "anodelist", "snodelist", "Nodesh", "nonedette", "nodlist", "nodeline", "NODesh", "nodesels", "nozemark", "NODemark", "nondelist", "nondata", "nodedette", "snodette", "nozels", "nodeelist", " nodeselist", "nODette", "anodeme", "nodseline", "nodedlist", "nodsette", " nodette", " nodels", "nodedeline", "anodedestate", "nozestyle", " nodesette", "nodslist", "nodename", "nodeata", "nodedesh", "anodata", "nodeselist", "nODlist", "nodselist", "nozesh", "nonedels", "nonedename", "NODestyle", "nODemark", "nodedata", "anodedelist", "nodesette", "snodeline"], "num": ["Num", "dim", "uni", "init", "span", "uri", "net", "np", "len", "nom", "lim", "max", "pos", "count", "norm", "loc", "m", "NUM", "con", "total", "multi", "n", "zero", "col", "um", "nb", "nr", "number", "nu", "index", "om", "mon", "div", "comb", "ul", "tri", "sum", "en", "nam", "dom", "umi", "temp", "part", "mu", "unit", "inc", "node", "mult"], "i": ["p", "x", "uri", "c", "ai", "info", "ii", "gi", "ori", "ix", "ie", "d", "l", "I", "ci", "yi", "m", "chi", "in", "ini", "multi", "ip", "iu", "g", "io", "bi", "si", "a", "b", "col", "it", "iv", "ui", "ik", "pi", "oi", "ji", "j", "li", "index", "isi", "hi", "mi", "di", "qi", "eni", "y", "xi", "part", "fi", "cli", "mu", "slice", "id", "o", "v", "start", "ri", "ti", "phi"]}}
{"id1": "2009072", "id2": "720361", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"openInput": ["createContent", "createInput", "openResource", "OpenContent", "OpenInput", "getInput", "createOutput", "getContent", "openContent", "getResource", "OpenResource", "OpenOutput", "getOutput", "openOutput", "createResource"], "path": ["text", "method", "form", "ref", "uri", "str", "Path", "clean", "inner", "c", "s", "plus", "txt", "PATH", "ath", "input", "word", "tree", "pointer", "root", "image", "data", "object", "context", "node", "transform", "self", "next", "base", "name", "relative", "obj", "api", "index", "string", "list", "prefix", "stream", "enc", "full", "filter", "value", "file", "temp", "request", "route", "part", "key", "sign", "template", "end", "id", "user", "parent", "xml", "pattern", "content", "http"], "len": ["lp", "lf", "ln", "span", "str", "length", "l", "pos", "count", "line", "val", "lon", "n", "limit", "base", "lc", "fl", "split", "sl", "sp", "li", "list", "size", "lin", "ll", "en", "Len", "iter", "part", "end", "le", "v", "fin"], "p": ["lp", "pre", "tp", "ps", "fp", "py", "c", "point", "np", "f", "s", "param", "i", "pb", "po", "l", "m", "vp", "ep", "ip", "pa", "pc", "u", "pe", "api", "sp", "j", "cp", "pr", "jp", "ap", "t", "pp", "o", "v", "P"], "url": ["source", "uri", "client", "browser", "Url", "f", "ball", "page", "link", "l", "conn", "image", "blog", "web", "object", "resource", "open", "location", "www", "base", "b", "server", "host", "URL", "fl", "sl", "api", "string", "connection", "channel", "html", "file", "ssl", "feed", "ob", "user", "http"], "result": ["match", "source", "message", "ret", "buffer", "output", "uri", "instance", "this", "page", "http", "event", "val", "data", "object", "resource", "open", "up", "air", "tmp", "array", "obj", "res", "api", "Result", "stream", "raw", "request", "r", "response", "results", "err", "entry", "reader", "ssl", "report", "content"]}}
{"id1": "17190057", "id2": "23088292", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["enccode", "enode", "uncode", "Enescape", "encescape", "Enode", "enescape", "unescape", "unode", "Encode"], "input": ["text", "source", "form", "buffer", "result", "output", "str", "empty", "instance", "config", "this", "plus", "Input", "i", "image", "data", "amp", "in", "format", "binary", "img", "inf", "array", "null", "password", "address", "hex", "secure", "string", "alpha", "crypt", "prefix", "stream", "addin", "raw", "def", "temp", "request", "ssl", "reader", "xxx", "audio", "pattern", "context"], "NoSuchAlgorithmException": ["NoSuchEdryptionException", "NoSuchAlryptionWarning", "NoSuchEdgorithmError", "NoSuchEdgorithmement", "NoSuchAlgoException", "NoSuchAlgoWarning", "NoSuchAlryptionError", "NoSuchAlodingError", "NoSuchEdgorithmWarning", "NoSuchEdryptionWarning", "NoSuchAlgoError", "NoSuchAlryptionException", "NoSuchAlgorithmError", "NoSuchEdryptionError", "NoSuchAlgorithmWarning", "NoSuchAlgorithmement", "NoSuchEdryptionement", "NoSuchAlodingWarning", "NoSuchAlgoement", "NoSuchAlodingement", "NoSuchAlodingException", "NoSuchEdgorithmException", "NoSuchAlryptionement"], "md": ["me", "mand", "message", "mm", "mp", "mod", "amd", "hash", "wd", "dig", "cmd", "dm", "mb", "meta", "m", "nm", "metadata", "ad", "mad", "mac", "ms", "um", "code", "zip", "sha", "pd", " MD", "mi", "od", "dd", "mo", "mt", "hd", "sum", "cd", "MD", "mc", "ma", "key", "df", "mag", "pm", "db", "d", "doc", "bd", "dc"]}}
{"id1": "20995534", "id2": "7633336", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesfromclassname", "loadPropertiesFromClassfile", "loadPropertiesFromSubfile", "loadPropertiesfromclassloader", "loadPropertiesFromclassname", "loadPropertiesfromclasspath", "loadPropertiesFromclassfile", "loadPropertiesFromSubpath", "loadPropertiesfromClasspath", "loadPropertiesFromClassname", "loadPropertiesFromSubname", "loadPropertiesFromclassloader", "loadPropertiesfromClassloader", "loadPropertiesfromclassfile", "loadPropertiesFromClassloader", "loadPropertiesfromClassname", "loadPropertiesFromSubloader", "loadPropertiesfromClassfile", "loadPropertiesFromclasspath"], "path": ["p", "text", "source", "work", "method", "filename", "prop", "uri", "Path", "c", "config", "content", "level", "root", "ath", "PATH", "pointer", "data", "loader", "object", "location", "resource", "error", "base", "name", "log", "host", "string", "prefix", "handler", "enc", "full", "value", "request", "properties", "route", "key", "template", "dir", "id", "part", "type", "parent", "xml", "pattern", "context"], "locations": ["operations", "LOCocations", "colATIONS", " location", "LOCions", "locATIONS", " locors", "LOCors", "Location", "LOCations", "sllements", "slibraries", "LOCATIONS", "Locions", " lococations", "lococations", "slations", "locibraries", " loclements", "location", "Lococations", "LocATIONS", "slation", "slATIONS", "operation", "slators", "locors", "colions", "Locator", "colations", "loclements", "LOCation", "colation", "operibraries", " locators", "slator", "operators", "locator", "Loclements", " locATIONS", "Locors", " locibraries", "locators", " locator", "locions", "Locations"], "props": ["propps", "pbperties", "procs", "suppcs", "produps", "protros", "supppps", " probs", "suppperties", "produpps", " procs", "protbs", "propp", "peperties", "probs", "proros", "pbps", "pps", "pebs", "pperties", "posps", " propp", "posbs", "pbs", "peps", " properties", "produperties", "posperties", "producs", "protps", "suppps", "pospp", "pbros", "protperties", "peros", "properties", "pbbs", "ppp", " propps"], "url": ["ls", "source", "org", "gl", "uri", "str", "out", "Url", "f", "e", "i", "l", "ource", "src", "loc", "location", "resource", "class", "base", "name", "bel", "b", "URL", "obj", "rl", "sl", "address", "string", "connection", "element", "el", "ll", "coll", "layer", "lr", "file", "route", "err", "r", "ssl", "ob", "feed", "id", "key", "user", "entry", "href", "rel", "http"], "in": ["source", "as", "init", "into", "gin", "inn", "out", "inner", "c", "ac", "f", "config", "s", "ex", "i", "input", "serv", "socket", "conn", "image", "src", "IN", "data", "con", "ini", "resource", "io", "n", "bin", "isin", "a", "din", "it", "is", "nin", "ins", "connection", "stream", "lin", "In", "impl", "again", "file", "r", "err", "login", "id", "reader", "inc", "ic"]}}
{"id1": "3330944", "id2": "16142024", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"extractImage": ["compractImage", "extractText", "extvertImage", "compressFile", "extractLayer", "extrateFile", "compractFile", "extractFile", "extrateImage", "extressFile", "compractText", "extrateText", "extvertText", "extvertLayer", "extvertFile", "extressImage", "extressText", "compressText", "extrateLayer", "compressLayer", "compressImage", "compractLayer", "extressLayer"], "input": ["work", "text", "source", "form", "init", "media", "current", "out", "path", "DATA", "inner", "empty", "PUT", "config", "view", "Input", "command", "i", "src", "OUT", "image", "sin", "SOURCE", "inside", "IN", "data", "amp", "ini", "img", "url", "base", "inf", "tmp", "null", "ink", "standard", "picture", "address", "rc", "string", "prefix", "qa", "API", "raw", "In", "inc", "RAW", "file", "temp", "include", "request", "pull", "id", "reader", "type", "parent", "bin", "xml", "audio", "dc"], "output": ["source", "secret", "message", "text", "filename", "result", "current", "out", "generated", "path", "config", "page", "image", "format", "resource", "document", "name", "password", "address", "string", "external", "prefix", "exit", "write", "Output", "file", "version", "temp", "response", "dir", "unit", "parent", "target", "STDOUT"], "params": ["p", "attr", "lp", "rules", "parts", "ps", "words", "json", "mm", "photos", "py", "Param", "styles", "config", "s", "Par", "param", "mos", "phrase", "processor", "options", "i", "fps", "services", "manager", "resources", "data", "names", "lis", "afi", "vs", "ras", "pixel", "si", "base", "pins", "lc", "proc", "spec", "server", "obj", "theme", "conf", "pi", "ams", "features", "api", "models", "par", "las", "details", "Parameters", "settings", "batch", "plugins", "properties", "pro", "phys", "results", "dis", "reader", "ctx", "bis", "xml", "http"], "w": ["work", "p", "sw", "widget", "out", "world", "f", "wd", "wt", "wp", "wic", "war", "hw", "writer", "m", "wi", "web", "W", "we", "kw", "ws", "wa", "wx", "aw", "fw", "wh", "worker", "rw", "nw", "write", "wm", "temp", "wb", "wave", "ow", "wl", "reader", "pipe", "xml", "wal", "wcs"], "in": ["p", "source", "init", "ani", "gin", "inn", "out", "pin", "ac", "f", "config", "ai", "ex", "i", "socket", "conn", "image", "inside", "src", "inas", "IN", "data", "m", "ini", "win", "con", "binary", "img", "n", "bin", "mc", "arin", "isin", "din", "b", "null", "vin", "nin", "min", "index", "ins", "connection", "fa", "cin", "thin", "qa", "lin", "In", "again", "rin", "file", "kin", "include", "temp", "part", "r", "cgi", "login", "ssl", "id", "cli", "err", "inc"], "dest": ["source", "doc", "style", "flat", "remote", "prop", "st", "path", "config", "home", "wd", "gui", "txt", " Dest", "de", "src", "project", "rest", "default", "loc", "folder", "resource", "done", "decl", "dep", "img", "sup", "tmp", "name", "cont", "null", "die", "destroy", "dat", "dist", "beta", "target", "comb", "di", "exit", "test", "nam", "desc", "coord", "dom", "temp", "route", "wb", "Dest", "dis", "dir", "id", "parent", "din", "d", "delete", "dc"], "bi": ["bh", "sb", " bio", "pin", "ni", "ai", "ba", "gi", "ii", "info", "bas", "ori", "vi", "i", "wei", "ci", "abi", "ini", "wi", "chi", "bid", "ib", "ga", "si", "bc", "obi", "b", "Bi", "mini", "nb", "BI", "bs", "pi", "ji", "ki", "li", "isi", "oi", "dat", "gb", "bank", "fa", "bm", "di", "agi", "qi", "oci", "eni", "umi", "cu", "xi", "fi", "cli", "mu", "zi", "bis", "bin", "ti", "phi"], "os": ["ors", "OS", "as", "cs", "dos", "ot", "so", "out", "oss", "us", "bos", "oes", "s", "i", "ds", "pos", "des", "vs", "ws", "oa", "nos", "io", "ks", "oS", "los", "ou", "cos", "is", "fs", "bs", "fits", "oos", "xs", "ios", "aos", "outs", "co", "ns", "es", "obs", "Os", "o", "osi", "ob", " bos", "oses", "ops"]}}
{"id1": "8062076", "id2": "13024538", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "label": 0, "substitutes": {"updateUser": ["UpdateAccount", "changeUser", "changePerson", "changeAccount", "UPDATEAccount", "UPDATEPerson", "UpdatePerson", "updateAccount", "UPDATEUser", "UPDATERole", "updatePerson", "UpdateUser", "updateRole", "changeRole", "UpdateRole"], "portalUserBean": ["portalUserDeAN", "portalGroupBEann", "portalUserDeane", "portalClientBeAN", "portalGroupBeann", "portalClientBEam", "portalUserPlan", "portalUserBann", "portalClientBeans", "portalUserBegan", "portalClientBEAN", "portalGroupBEan", "portalGroupBeans", "portalUserBoam", "portalUserBegans", "portalFileBein", "portalClientBean", "portalFileBeAN", "portalUserBoin", "portalUserBans", "portalUserPeane", "portalUserBoan", "portalFileBeans", "portalUserBeean", "portalUserBeann", "portalUserBeam", "portalUserPeans", "portalUserBeane", "portalUserBEAN", "portalUserPlane", "portalUserBeans", "portalUserDeans", "portalGroupBEAN", "portalUserBEan", "portalFileBans", "portalClientBeane", "portalUserBEans", "portalFileBeane", "portalUserBeAN", "portalUserPlAN", "portalClientBeam", "portalUserPean", "portalUserPlean", "portalUserPeAN", "portalGroupBEans", "portalUserBin", "portalUserEane", "portalUserBoane", "portalFileBean", "portalUserDean", "portalGroupBeAN", "portalUserBane", "portalUserBEam", "portalFileBan", "portalClientBEan", "portalUserBAN", "portalClientBEane", "portalUserBan", "portalUserPeean", "portalUserEin", "portalUserBoans", "portalUserEan", "portalUserBegAN", "portalUserEAN", "portalUserBoAN", "portalFileBin", "portalUserBam", "portalUserBein", "portalFileBAN", "portalUserBegann", "portalFileBane", "portalUserBEann", "portalUserEans", "portalClientBEans", "portalUserBEane", "portalGroupBean", "portalFileBeean"], "authSession": ["AuthConnection", "authConnection", "AuthStream", "httpConnection", "authConn", "httpStream", "authsession", " authsession", " authStream", "authClient", "uthClient", "httpsession", "AuthConn", "uthsession", "uthSession", "AuthSession", "httpSession", "uthConn", " authConn", "Authsession", " authConnection", " authClient", "authStream", "AuthClient"], "dbDyn": ["DbPSyn", "dbCodyr", "dbCyn", "libDym", "dbDys", "libDys", "dbDoyr", "dbByr", "dbDyr", "dbBahn", "dbDefyn", "dbFSyn", "dbCYN", "cbDien", "dbBSyn", "dbDYN", "dbSYN", "dbDoyn", "DbPyn", "dbDsyn", "dbFYN", "dbDSyn", "dbWyn", "dbdyn", " dbDoyan", "bbDYN", "dbDoneYN", "dbWYN", "dbCodyn", "DbSyn", "dbCym", "dbIyn", "dbCynam", "dbByn", "dbFsyn", "dbNyn", "DbCynam", "dbIynam", "dbDgn", "dbDoneien", " dbBynam", "cbDyn", "dbdgn", " dbDsyn", "dbDien", "DbDgn", "dbDefym", "dbNyl", "dbSgn", "dbDynam", "dbDoynam", "dbFyr", "dbWSyn", "dbNgn", "dbIyan", "dbDahn", "bbFsyn", "libDyn", "bbFyn", "dbPyr", "dbBsyn", " dbDoyn", "dbCodSyn", "DbDyn", "DbSgn", "dbBYN", "cbDynam", " dbDyan", "dbFynam", " dbBsyn", "DbDyr", "dbSyn", "bbDyn", "cbBynam", "DbCyn", "dbWsyn", " dbByn", "dbFyan", "DbDYN", "dbPyn", "cbBien", "dbPSyn", "DbCYN", "dbDoneyn", "dbdyl", "dbdSyn", "dbDefys", "dbFyn", "dbDyl", "dbDosyn", "DbSYN", "bbDSyn", "dbDym", "dbdynam", "dbdYN", "dbCodahn", "dbSyl", "DbDSyn", "dbBien", "dbDefSyn", "dbPahn", "cbBYN", "dbDoyan", " dbDosyn", "DbSyl", "DbPahn", "cbDYN", "DbDyl", "dbDyan", "dbDoneynam", " dbDynam", "bbDsyn", "DbCSyn", "dbCSyn", "dbCys", " dbDyr", "dbNYN", "libDSyn", "dbIsyn", "bbFYN", " dbByr", "DbPyr", " dbDoynam", "DbDahn", "bbFSyn", "dbBynam", "cbByn", "DbDynam"], "ps": ["p", "pre", "ls", "ons", "PD", "aps", "eps", "as", "cs", "ts", "ss", "lines", "ups", "mp", "ppa", "py", "ips", "s", "this", "its", "http", "pl", "als", "per", "pb", "po", "pse", "ds", "pos", "hs", "les", "pps", "pg", "proxy", "PS", "vs", "ws", "rs", "cop", "pa", "where", "ras", "ks", "pc", "ms", "os", "pe", "qs", "Ps", "fs", "fe", "bs", "post", "res", "sp", "ins", "details", "pr", "jp", "gs", "ns", "ils", "pers", "css", "properties", "pp", "pes", "ports", "js", "posts", "ops"], "sql": ["ls", "eps", "util", "ln", "sb", "su", "fp", "str", "sync", "session", "csv", " SQL", "ql", "s", "seed", "sg", "sol", "l", "conn", "sys", "nl", "dl", "comment", "statement", "description", "shell", "url", "job", "log", "SQL", "os", "spec", "params", "setup", "printf", "function", "msg", "sl", "query", "zip", "string", "fn", "lock", "repl", "pr", "ll", "details", "sq", "acl", "html", "serial", "general", "ssl", "ob", "id", "sv", "sf", "join", "db", "select", "rel", "http"], "idList": ["idLIST", "addresslist", "dateColl", "IdInfo", "idColl", "dateTree", "Idlist", " idInfo", "IdTree", "dateInfo", "IdLIST", "IdColl", "userList", "userLIST", "idlist", "IdSet", "IdList", "idSet", "addressLIST", "idInfo", "addressSet", "addressList", "idTree", "dateList", " idTree", "userSet", " idColl", "userlist"], "num": ["Num", "dim", "form", "uni", "init", "su", "result", "np", "len", "ord", "sol", "nom", "lim", "one", "i", "pos", "count", "norm", "loc", "NUM", "con", "multi", "n", "zero", "nn", "no", "du", "um", "gen", "nb", "nr", "number", "hex", "nu", "index", "lang", "oct", "fn", "mon", "div", "size", "miss", "mn", "gru", "begin", "sum", "nam", "umi", "dom", "coord", "temp", "off", "nov", "loop", "sn", "numbered", "uu", "non", "unit", "inc", "node", "mult"], "i1": ["ci5", "ii4", "I81", " i5", " i4", "i4", "i5", "ci0", "ci81", "ii1", "xi1", " i0", "ci1", "I1", "i0", "ii81", "xi11", "I5", "ii11", "i81", "xi4", " i11", " i81", "i11", "I0", "xi81"]}}
{"id1": "7006052", "id2": "7149578", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFilesFile", " copyFilesTo", "copySourceFileFile", "copyfileFrom", "copyFileFrom", " copyFileFrom", "copySourceFileFrom", " copyFilesFile", "copyfileInfo", "copySourceFileTo", "copyfileFile", " copyFilesFrom", "copyFileInfo", "copyFileFile", " copyFilesInfo", " copyFileInfo", "copyFilesTo", "copyFilesInfo", "copyfileTo", "copyFilesFrom", "copySourceFileInfo", " copyFileFile"], "src": ["source", "remote", "filename", "sb", "uri", "sync", "path", "config", "s", "archive", "txt", "image", "sin", "loc", "data", "resource", "rs", "old", "img", "sup", "url", "inf", "b", "code", "sel", "sub", "sc", "sl", "rc", "rb", "string", "fn", "upload", "stream", "file", "href", "slice", "js"], "dest": ["source", "filename", "result", "flat", "output", " destination", "home", " Dest", "txt", "project", "default", "loc", "data", "des", "const", "folder", "done", "later", "img", "sup", "tmp", "name", "b", "die", "sub", "secure", "dist", "comb", "orig", "test", "desc", "temp", "route", "wb", "Dest", "dir", "bin", "opt", "target", "delete"], "destFile": ["destfile", "targetfile", " destDir", "destDir", "DestF", "DestDir", "destF", "DestFiles", " destinationF", "targetDir", "targetFiles", " destFiles", "targetFile", " destinationFile", " destfile", "DestFile", " destinationFiles", " destinationDir", "destFiles", "Destfile", " destF"], "in": ["source", "init", "ln", "gin", "inn", "pin", "inner", "f", "s", "pass", "i", "input", "l", "socket", "inside", "image", "trans", "IN", "data", "con", "win", "ini", "up", "n", "url", "din", "is", "nin", "ins", "cin", "thin", "stream", "lin", "In", "impl", "inc", "again", "rin", "kin", "r", "err", "login", "id", "reader", "diff", "bin"], "out": ["work", "copy", "cache", "output", "sync", "client", "net", "inner", "ac", "this", "extra", "w", "ex", "one", "conn", "OUT", "image", "data", "writer", "other", "up", "io", "n", "bin", "log", "cos", "null", "outer", "ext", "exec", "post", "obj", "pool", "exp", "plain", "Out", "again", "off", "file", "parent", "part", "err", "o", "user", "inc"], "buf": ["cv", "bh", "buffer", "result", "cache", "uf", "seq", "uc", "length", "path", "br", "bag", "c", "pad", "buff", "fb", "bytes", "bl", "ff", "loc", "data", "map", "box", "bf", "cas", "bc", "tmp", "b", "pool", "Buffer", "rb", "rc", "blocks", "queue", "raw", "batch", "orig", "block", "off", "vec", "cap", "ctx", "v", "bin", "cb", "bd"], "len": ["pre", "lf", "ln", "length", "c", "f", "all", "bytes", "nt", "ie", "lim", "l", "pos", "count", "line", "val", "ind", "data", "n", "url", "base", "num", "lc", "fd", "fl", "split", "body", "li", "min", "size", "coll", "el", "en", "Len", "iter", "off", "cap", "part", "id", "rev", "end", "fin", "no"]}}
{"id1": "18164929", "id2": "6682825", "code1": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"isCodebaseDownloadable": ["isCodebdownloaded", "isCodebasedownloadEnabled", "isCodebasedownloaded", "isCodebdownloadiable", "isCodebasedownloadable", "isCodebaseVersionable", "isCodebaseVersionEnabled", "isCodebDownloadEnabled", "isCodebaseDownloadEnabled", "isCodebaseDownloaded", "isCodebaseAccessiable", "isCodebaseVersioniable", "isCodebaseAccessEnabled", "isCodebDownloadiable", "isCodebaseDownloadiable", "isCodebasedownloadiable", "isCodebdownloadEnabled", "isCodebdownloadable", "isCodebDownloadable", "isCodebDownloaded", "isCodebaseVersioned", "isCodebaseAccessed", "isCodebaseAccessable"], "p": ["lp", "tp", "ps", "property", "prop", "fp", "cache", "c", "f", "np", "s", "per", "e", "pb", "l", "m", "pa", "u", "b", "proc", "pi", "api", "j", "cp", "hp", "jp", "pr", "parser", "policy", "pers", "properties", "pro", "t", "pp", "o", "pkg", "P"], "file": ["source", "message", "media", "File", "fp", "cache", "uri", "length", "path", "f", "info", "page", "image", "line", "single", "object", "resource", "binary", "FILE", "action", "class", "base", "name", "log", "code", "pool", "split", "child", "body", "live", "string", "connection", "header", "queue", "value", "key", "feed", "dir", "type", "parent", "db", "content", "http"], "codebase": ["corebase", "foreup", "CodeBase", "chebase", "codeurl", "codeb", " codebi", "Codefile", "codearea", "codebi", "curfile", " codearea", " codeurl", "Codebase", "cbfile", "codedfile", "codedup", "foreurl", "codedb", "cbbase", "curbi", "Codeb", "codedurl", "Codeurl", "cheBase", "corefile", "codeBase", " codefile", "cburl", "curbase", "cbup", "forebase", "Codearea", "chefile", "codefile", "codedbase", " codeb", "forefile", "codeup", "codedarea", "corebi", " codeBase"], "cbUrl": ["cdBase", "cdurl", "liburl", "cdURL", "dbOb", "oburl", "obURL", "cfURL", "bbBase", "cpUrl", "cpURL", "libUrl", "dburl", "cpUr", "zbURL", "obBase", "obUrl", "cfurl", "rbURL", "rbBase", "dbBase", "bbUrl", "dbUrl", "libOb", "cbOb", "cpurl", "dbURL", "cfBase", "rbUr", "cfUrl", "cburl", "cbUr", "cbURL", "bbURL", "dbUr", "cbGl", "cfGl", "cdUrl", "libURL", "rbUrl", "bburl", "zbGl", "bbOb", "cfUr", "zbBase", "rburl", "cbBase", "dbGl", "zbUrl"], "protocol": ["Protpoint", "infocol", "methodocol", "scheotype", "scheocol", "platformotype", "prototype", "methodicle", "methodpoint", "scheology", "protology", "Protocol", "methodotype", "Protology", "platformocol", "proticle", "methodology", "infotype", "Prototype", "infology", "platformpoint", "platformology", "scheicle", "inficle", "protpoint"], "filename": ["source", "uri", "fp", "length", "path", "username", "title", "il", "phrase", "fil", "txt", "word", "l", "src", "loc", "folder", "nl", "location", "resource", "binary", "dll", "email", "directory", "FILE", "database", "name", "subject", "params", "password", "string", "fn", "connection", "prefix", "Filename", "fax", "utf", "nil", "ssl", "application"], "size": ["uni", "fee", "length", "SIZE", "bytes", "conn", "count", "loc", "Size", "limit", "name", "small", "width", "body", "enc", "ize", "Len", "unit", "content"], "files": ["ls", "tests", "parts", "types", "bands", "writers", "lines", "sheets", "lists", "keys", "groups", "balls", "resources", "names", "strings", "children", "flows", "objects", "thumbnails", "fs", "fits", "features", "steps", "Files", "links", "fields", "pages", "views", "bees", "users", "planes", "results", "items", "classes", "blocks", "stars", "images", "jobs"], "st": ["St", "ste", "est", "str", "se", "set", "ost", "first", "s", "ast", "nt", "l", "bl", "src", "rest", "inst", "const", "ust", "sr", "ut", "ST", "be", "sa", "b", "rd", "nd", "sc", "sl", "ft", "sp", "string", "stop", "stack", "fr", "ld", "sts", "cl", "sh", "sn", "std", "t", "r", "sta", "end", "start", "d"], "url": ["source", "group", "ref", "char", "uri", "str", "path", "Url", "cb", "tool", "plug", "config", "f", "page", "link", "l", "image", "service", "object", "resource", "ol", "www", "base", "name", "log", "bel", "mail", "server", "host", "URL", "fl", "address", "sl", "li", "string", "connection", "ur", "layer", "el", "ll", "coll", "pull", "key", "id", "user", "type", "db", "rel", "http"], "part": ["pre", "source", "work", "group", "parts", " Part", "token", "str", "path", "field", "point", "pad", "front", "component", "place", "per", "word", "po", "area", "pos", "line", "year", "PART", "format", "action", "and", "base", "name", "change", "band", "split", "product", "letter", "ch", "string", "connection", "patch", "section", "but", "full", "filter", "block", "html", "Part", "partial", "key", "step", "art", "slice", "id", "unit", "type", "parent", "start", "user", "jo", "pair"], "data": ["message", "video", "cache", "dict", "session", "config", "extra", "pos", "image", "val", "default", "builder", "base", "name", "post", "zip", "li", "upload", "div", "def", "key", "template", "slice", "type", "start", "d", "la", "result", "client", "load", "home", "info", "model", "view", "area", "da", "writer", "object", "ata", "split", "api", "batch", "test", "partial", "parent", "parts", "style", "media", "output", "DATA", "state", "format", "action", "and", "next", "di", "dd", "response", "results", "reader", "content", "empty", "download", "complete", "aa", "record", "missing", "database", "change", "exec", "ui", "function", "child", "dat", "body", "index", "list", "full", "end", "after"], "len": ["lf", "ref", "span", "ln", "fun", "length", "alt", "lt", "lim", "bl", "pos", "count", "line", "val", "loc", "elt", "ol", "limit", "num", "lc", "label", "fl", "split", "sl", "body", "min", "li", "fn", "enc", "en", "lit", "Len", "lib", "partial", "rev", "fat", "fin", "js", "offset"], "success": ["primary", "access", "message", "method", "right", "top", "result", "continue", "successful", "load", " Success", "pass", "show", "successfully", "src", " successful", "Success", "complete", "func", "high", "process", "default", "left", "warning", "comment", "progress", "accept", "speed", "connect", "job", "danger", "rc", " succ", "submit", "fail", "sum", "failed", "save", "ssl", "results", "response", "cess", "roll", "sign", "member", "parent", "ccess", "error", "select", "status"]}}
{"id1": "2461169", "id2": "539195", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "4223002", "id2": "13981689", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMAC1", "getPasswordMD256", "getPasswordSHA512", "getPasswordMAC512", "getpasswordMD256", "getpasswordMD1", "getPasswordMac1", "getpasswordMD512", "getPasswordMac5", "getPasswordSHA5", "getPasswordSHA256", "getPasswordMD512", "getPasswordMD1", "getpasswordSHA512", "getPasswordMac512", "getpasswordMD5", "getPasswordMAC256", "getpasswordSHA5", "getPasswordSHA1", "getpasswordSHA256", "getpasswordSHA1", "getPasswordMac256", "getPasswordMAC5"], "algorithm": ["algebra", "omalgorithm", " alignment", " alger", "fgorith", "calgorithm", "algo", "aggorithm", " alrator", "fgebra", "alphabet", "omalphabet", "alignment", "calgebra", "Algorithm", "Alrator", "agrator", "fgo", "alm", "alger", " algo", "Alger", "alrator", " alest", "Alignment", "Algo", "Alphabet", " alm", "calgorith", "fgorithm", "Algorith", "algorith", "geger", "gegorithm", "agignment", "aggo", "Alest", "geest", " algorith", "omalgorith", "Algebra", "Alm", " alphabet", "calgo", "alest", "omalgo", "gem"], "messageDigest": ["MessageModester", " messagedigester", "messagedigester", " messagedigEST", "phrasedigested", "messageDEST", "messageModester", "MessageDigester", "messagedigEST", "MessageDigested", " messageDigEST", "messagedigest", "MessageModEST", "messageMDEST", "messageDigEST", "phraseDigest", "phraseDigEST", "phraseDigested", "messageDigested", "messageModString", "phrasedigEST", "messageMDester", "messageDester", " messagedigest", "phrasedigester", "messageDested", " messageDigester", "phrasedigest", "messageMDest", "messageDigester", "messageModEST", "messageModest", "messageDest", "phraseDigester", "messageDigString", "messagedigString", "messagedigested", " messageDigString", "MessageDigest", "messageModested", " messagedigString", "MessageModested", "MessageDigEST", "messageMDString", "MessageModest"], "hexString": ["hexArray", " hexstring", "byteStream", "shortstring", "shortString", "checkBuffer", "hexBuffer", " hexBuffer", "textString", "hashBuffer", "hexstring", "byteLine", "hexLine", "shortArray", "textLine", "checkStr", "byteArray", "hashFunction", "textArray", "textstring", " hexStr", "checkString", "textStream", " hexFunction", "hexStr", "byteString", " hexLine", "hashStr", "hashString", "shortBuffer", " hexArray", "hexFunction", "checkFunction", "textBuffer", "hexStream", " hexStream"], "i": ["p", "x", "uri", "c", "f", "ai", "s", "ii", "info", "gi", "ix", "e", "d", "l", "I", "ci", "abi", "m", "chi", "in", "multi", "n", "bi", "io", "a", "si", "u", "b", "ui", "volume", "pi", "oi", "index", "li", "j", "h", "hi", "mi", "di", "mu", "xi", "fi", "key", "t", "r", "slice", "o", "id", "end", "type", "v", "zi", "ri", "ti", "phi"]}}
{"id1": "7458833", "id2": "8011262", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileTocodeFile", " copyParseFileToOutputfile", " copyParseFileToCodeClass", " copyParseFileToMapfile", " copyParseFileTocodeClass", " copyParseFiletoOutputfile", " copyParseFileTocodeFiles", " copyParseFileTocodefile", " copyParseFileToMapFile", " copyParseFiletoCodefile", " copyParseFileToCodefile", " copyParseFiletoOutputClass", " copyParseFiletoOutputFiles", " copyParseFileToMapFiles", " copyParseFiletoCodeFiles", " copyParseFiletoCodeFile", " copyParseFileToMapClass", " copyParseFiletoCodeClass", " copyParseFiletoOutputFile", " copyParseFileToOutputClass", " copyParseFileToOutputFiles", " copyParseFileToOutputFile", " copyParseFileToCodeFiles"], "in": ["ls", "as", "init", "gin", "inn", "pin", "inner", "f", "i", "input", "socket", "inside", "image", "read", "IN", "get", "m", "con", "win", "ini", "up", "n", "io", "din", "is", "nin", "min", "ins", "cin", "stream", "lin", "In", "impl", "inc", "again", "rin", "kin", "pull", "r", "err", "login", "oin", "id", "reader", "bin", "ic"], "out": ["work", "source", "as", "cache", "output", "sync", "client", "net", "inner", "this", "w", "ex", "i", "one", "socket", "OUT", "conn", "image", "writer", "other", "n", "io", "up", "bin", "log", "outer", "ext", "server", "exec", "post", "exp", "plain", "Out", "outs", "again", "file", "err", "o", "user", "parent", "inc"], "buffer": ["sequence", "source", "position", "shape", "cache", "result", "uf", "available", "pad", "buff", "fb", "buf", "event", "input", "uffer", "padding", "count", "read", "data", "duration", "total", "binary", "limit", "document", "base", "array", "null", "server", "capacity", "number", "address", "Buffer", "string", "channel", "queue", "layer", "raw", "batch", "reference", "iter", "pause", "request", "wave", "feed", "slice"], "length": ["sequence", "match", "style", "position", "shape", "Length", "path", "load", "point", "bb", "before", "len", "view", "level", "l", "ength", "count", "line", "duration", "total", "limit", "url", "character", "width", "code", "number", "address", "time", "index", "string", "size", "lock", "repeat", "range", "full", "block", "distance", "weight", "value", "part", "partial", "pull", "feed", "slice", "ob", "end", "id", "row", "type", "start", "offset", "volume"]}}
{"id1": "20929570", "id2": "4501356", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "label": 1, "substitutes": {"toMd5": ["toBd15", "toMm7", "toMcd5", "toMmd15", "toBd7", "toMcd15", "toMmd512", "toBmd15", "toMcd512", "toBmd512", "toBd512", "toMmd5", "toMm15", "toMd15", "toMm5", "toMd512", "toMcd7", "toBmd7", "toMmd7", "toBd5", "toBmd5", "toMm512", "toMd7"], "str": ["text", "source", "kr", "char", "buffer", "result", "arr", "out", "st", "br", "Str", "f", "s", "bytes", "pass", "e", "txt", "input", "conn", "STR", "stri", "data", "in", "sr", "url", "name", "sec", "b", "obj", "msg", "sp", "dr", "string", "exp", "fr", "enc", "tr", "temp", "r", "err"], "messageDigest": ["messageDEST", "MessageDigester", "messageGest", "messageDester", "messageDefest", "messageDefested", "messageDested", "messageDeter", "messageMarkest", "messageDigester", "Messagedigester", "messageDuster", "messageDigse", "messageDigeter", "messageDigetter", "messageDse", "messageMixest", "MessageMarkester", "MessageDigse", "moreDigest", " messageDigEST", "messagedigetter", " messageDester", "moreDigeter", "MessageDefester", "MessageDefse", " messageDuster", "MessagedigEST", "messageDher", " messageDigester", "messageGEST", "messagedigher", " messageDest", "messagedigested", "MessageMarketter", "MessageDigher", "moredigested", "moredigester", "MessageDigEST", "messageDetter", "messageUploadEST", "messageDigher", "MessageDefested", "Messagedigested", "messagedigEST", "MessageDigested", "messagedigest", "messageMarkester", "messageDigEST", "messageDigested", "messageMixested", "messageHashest", "MessageMarkest", "messageDefester", "messageUploadested", "messageGester", "messageHasheter", "messageUploadest", "messagediguster", "messageHashested", "messageMarkher", "messageMixse", "MessageDigetter", "MessageDefest", "messagedigeter", "messagedigester", "messageHashester", "MessageMarkher", "messageMixester", "moredigeter", "messageDefse", "messageDest", " messageDiguster", " messageDEST", "moredigest", "messageUploadester", "moreDigested", "messageDiguster", "Messagedigest", "MessageDigest", "messageGuster", "moreDigester", "messageMarketter"], "byteArray": ["charOrder", "wordString", "charNumber", "ByteArray", "charBuffer", "doublearray", " byteBuffer", "wordBuffer", "wordArray", "bitBuffer", " byteIndex", "ByteLength", " byteAddress", "doubleBuffer", "ByteNumber", " bytearray", "ByteBuffer", "pixelBuffer", "byteOrder", "pixelArray", "byteObject", "pixelObject", "bitLength", "resourceArray", "charArray", "charAmount", "charObject", "doubleArray", "bitObject", "pixelLength", "ByteAddress", "byteLength", "doubleString", " byteString", " byteAmount", "charLength", " byteNumber", "byteAddress", " byteLength", "bitIndex", "byteNumber", "byteIndex", "bitarray", "byteString", "bitArray", "resourcearray", "resourceLength", "ByteAmount", "charAddress", "byteAmount", "bytearray", "resourceIndex", "byteBuffer", " byteOrder", "ByteOrder", "wordarray"], "md5StrBuff": ["md5TrDb", "md2StringText", "md2StrRest", "md5STRRest", "md5StringDb", "md5StringRest", "md5strText", "md5StringComp", "md5STRBuffer", "md5StBuffer", "md2StrText", "md6StrText", "md5StRef", "md5TrBuff", "md5StrText", "md5StrBuffer", "md5StrComp", "md5StrRef", "md5StringText", "md2StrRef", "md5StringBuffer", "md2StringRest", "md6StrBuffer", "md5TrText", "md6StrBuff", "md5strApp", "md6strText", "md6strBuff", "md5StApp", "md2StringApp", "md5strBuff", "md6Strbuff", "md2StrApp", "md5STRBuff", "md2StrComp", "md5StrRest", "md5StComp", "md2StringDb", "md2StringComp", "md2StringBuff", "md6strbuff", "md2StrBuffer", "md5Strbuff", "md5StringApp", "md5STRComp", "md2StringRef", "md5StRest", "md2StringBuffer", "md5TrRef", "md5StDb", "md2StrDb", "md5strbuff", "md5TrBuffer", "md5strBuffer", "md5StText", "md5StBuff", "md5StrApp", "md2StrBuff", "md5StrDb", "md5StringRef", "md5Trbuff", "md5Stringbuff", "md5StringBuff", "md6strBuffer"], "i": ["p", "x", "uri", "length", "inner", "c", "field", "f", "ai", "gi", "ii", "info", "ix", "e", "ie", "l", "I", "k", "ci", "abi", "in", "multi", "ip", "n", "io", "iu", "bi", "si", "name", "b", "u", "ti", "it", "lc", "ui", "pi", "oi", "ji", "li", "index", "j", "h", "di", "qi", "y", "xi", "part", "fi", "mu", "slice", "id", "o", "v", "ri", "d", "phi"]}}
{"id1": "16388708", "id2": "18748516", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "14324112", "id2": "16556717", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"innerProcess": ["innerprocess", " outerAccept", " outerprocess", " outerMethod", " innerprocess", " outerProcess", "innerAccept", " innerMethod", "middleProcess", "middleprocess", " innerAccept", "middleMethod", "middleAccept", "innerMethod"], "curi": ["biri", "buri", "CURI", "Cri", "ldirectory", "Ciri", "requiri", "fri", "ucuri", "cturi", "cdirectory", "ciri", " cURI", "cacheuri", "Curi", "nuri", "furi", "cacheui", "fcri", "ucURI", " cuid", " cuni", "ucuni", " cdirectory", "ctiri", " cri", "nURI", "Cdu", "lcouri", "cuid", "fcURI", "Cui", "cURI", "fui", "uciri", "cacheURI", "firi", "lcURI", "lcuri", "ctuid", " cdu", "lcri", " cui", "requuri", " ciri", "cri", "couri", "lcui", "lciri", "fcumi", "cumi", "cdu", "ctURI", "requumi", " couri", "cachedu", "bURI", "fURI", "bdirectory", "luid", "cui", "lURI", "fcuri", "numi", "liri", "funi", "luri", "nri", " cumi", "cuni", "lri", "requuni", "luni", "Couri", "lumi"], "maxsize": [" maxSize", "defaultize", "minsize", "totalize", "MAXname", "totalSize", "MAXsize", "maxscale", "Maxize", " maxname", "totalsize", "minaddress", "maxaddress", "lastSize", "defaultsize", "totalscale", " maxscale", "lastaddress", "MaxSize", "Maxname", "MAXSize", "minSize", " maxaddress", "maxSIZE", "lastsize", "defaultSize", "axize", "Maxscale", "axSize", "Maxsize", " maxize", "maxize", "maxSize", "maxname", " maxSIZE", "MAXSIZE", "MaxSIZE", "axsize"], "regexpr": ["perepr", "rerexpr", "reqor", "rerePR", "rexpp", "replexPr", "rerePr", "refplexpp", "rentaxpr", "regexpect", "pegexexpr", "pereexpr", "REgexr", "perePr", "replexpr", "requpr", "replaypt", "reuxpr", "resexPr", "replexpp", "replexpl", "resexps", "regexor", "equPr", "egexps", "rentaxexpr", "replexexpr", "rerexps", "regexps", "replaypr", "replayr", "REgexpt", "rentaxPR", "rexpr", "equps", "regexPR", "regexpt", "refgexpp", "refgexpl", "rerepr", "regexpl", "REgexpr", "REqr", "refgexpr", "refplexpl", "rerexpect", "reqpt", "regexpp", "refplexpr", "resexpect", "reqpr", "reuxpl", "refgexPr", "pegexpr", "reuxPr", "regexexpr", "pegexPR", "replayor", "perePR", "egexPr", "rexpl", "refplexPr", "REqpr", "REqpt", "REqor", "rerexPr", "egexpr", "resexpr", "REgexor", "regexr", "reqr", "reuxpp", "pegexPr", "rexPr", "rentaxPr", "equpect", "egexpect", "rereexpr", "regexPr", "requps", "equpr", "requpect", "replexPR", "requPr"], "cs": ["ls", "TS", "ps", "ts", "cache", "str", "sync", "cf", "c", "tc", "GC", "ca", "ds", "acs", "ci", "rs", "ce", "ras", "ec", "cells", "cas", "ces", "ks", "pc", "ms", "cos", "lc", "qs", "spec", "cr", "fs", "sc", "acts", "bs", "cks", "ch", "cus", "cc", "ins", "acks", "cp", "ches", "cl", "coll", "cm", "gs", "ics", "Cs", "ences", "ns", "css", "mc", "cn", "CS", "ctx", "js", "cms", "cons", "wcs"], "digest": ["signusher", "Digusher", "Digester", " digher", "DigEST", "digEST", " digusher", "digusher", "Diger", "returngest", "shaher", "returnEST", "returnest", "shaEST", "shaer", "signEST", "diggest", " digEST", "diger", "signester", " diger", "Digest", " diggest", "Diggest", "digester", "returnester", "shaest", " digester", "signest", "digher", "Digher"], "s": ["p", "ls", "su", "ps", "summary", "sb", "ss", "str", "lines", "sync", "session", "c", "f", "w", "i", "groups", "l", "services", "single", "strings", "ws", "cells", "n", "g", "si", "ms", "u", "b", "params", "sl", "states", "h", "string", "details", "sets", "ns", "r", "t", "o", "sv", "S", "v", "js", "d"], "m": ["p", "text", "im", "mm", "f", "i", "M", "dm", "l", "imm", "fm", "nm", "mac", "n", "g", "v", "rm", "sm", "ms", "b", "um", "gm", "tm", "h", "machine", "mi", "bm", "arm", "cm", "mo", "am", "wm", "mc", "r", "t", "ym", "pm", "d"]}}
{"id1": "13012591", "id2": "8921716", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"getPasswordHash": ["getPasswordSum", "getpasswordhash", "getHashSum", "getHashHash", "getPasswordSecret", "getPasswordhash", "getpasswordSecret", " getpasswordHash", " getPasswordSum", " getpasswordSum", "getpasswordHash", "getHashhash", "getHashSecret", "getStringSum", "getStringhash", "getStringSecret", " getpasswordhash", "getpasswordSum", " getPasswordSecret", " getPasswordhash", "getStringHash", " getpasswordSecret"], "password": ["p", "text", "secret", "account", "message", " passwords", "source", "buffer", "words", "cache", "token", "path", "username", "config", "wd", "pass", "phrase", "word", "input", "padding", "data", "auth", "PASS", "email", "database", "name", "array", "security", "sword", "code", "number", "address", "string", "crypt", "prefix", "confirmed", "Password", "attribute", "key", "user", "pattern", "content"], "md": ["mand", "hm", "alg", "mm", "mp", "mod", "amd", "dig", "cmd", "dm", "mb", "meta", "material", "mg", "map", "m", "amp", "mage", "nm", "metadata", "ad", "mac", "sm", "ms", "vd", "pd", "sha", "gm", "gd", "dr", " MD", "gb", "arm", "od", "ld", "dd", "bm", "cm", "mo", "mt", "hd", "mem", "MD", "dh", "mc", "ma", "mu", "pkg", "mag", "pm", "db", "d", "bd", "dc"], "hash": ["dot", "match", "secret", "message", "mask", "bh", "hed", "ashes", "cache", "square", "length", "check", "cover", "ash", "dig", "image", "count", "build", "kh", "data", "map", "total", "mac", "url", "array", "search", "Hash", "host", "code", "number", "query", "sha", "hex", "address", "index", "body", "h", "header", "sum", "sh", "batch", "block", "html", "ha", "filter", "row", "key", "diff", "error", "handle", "carry"], "buf": ["cv", "ref", "bh", "buffer", "sb", "ab", "fp", "uf", "cf", "br", "cb", "bag", "f", "pad", "buff", "fb", "bb", "home", "pb", "va", "src", "ff", "data", "bp", "box", "aux", "abi", "af", "bf", "cas", "img", "tmp", "bc", "b", "conv", "array", "nb", "book", "Buffer", "rb", "h", " buffer", "abs", "cap", "pkg", "Buff", "ctx", "v", "bin", "db"], "i": ["p", "x", "uri", "length", "field", "c", "f", "ai", "s", "ii", "gi", "e", "d", "vi", "l", "I", "k", "ci", "uli", "data", "m", "chi", "abi", "multi", "ip", "io", "bi", "si", "u", "b", "it", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "di", "qi", "eni", "xi", "fi", "r", "t", "mu", "o", "end", "id", "v", "ri", "ti", "phi"]}}
{"id1": "18731843", "id2": "10131427", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"doBody": [" doBytes", "handleFile", "handleBody", "DoResponse", "doBytes", "DoFile", "handleResponse", "doResponse", "DoBody", " doFile", "doFile", "handleBytes", "DoBytes", " doResponse"], "req": ["ref", "rx", "rec", "download", "config", "info", "this", "reg", "rr", "src", "conn", "serv", "qt", "qq", "q", "data", "resource", "proc", "requ", "spec", "obj", "query", "res", "rss", "respond", "fr", "jp", "comp", "def", "request", "r", "err", "crit", "cgi", "reader", "rh", "sem", "Request", "report", "http"], "resp": ["p", "pre", "ref", "ret", "result", "rec", "re", "cache", "download", "bb", "rr", "serv", "pos", "exc", "val", "data", "prot", "Resp", "job", "b", "proc", "Response", "obj", "rep", "res", "api", "sp", "inv", "respond", "jp", "respons", "comp", "html", "request", "part", "err", "response", "r", "rev", "cb", "cmp", "report", "reply"], "bis": ["phis", "uds", "mis", "tis", "ris", "bh", "sb", "bits", "obb", "bb", "fb", "bas", "sis", "ori", "iss", "ubis", "sin", "abi", "bian", "lis", "bid", "bps", "binary", "alis", "bi", "isin", "ses", "pins", "b", "os", "obi", "los", "usb", "is", "oris", "bs", "rots", "obos", "ais", "ios", "atis", "lins", "iris", "nis", "obs", "boot", "bin", "ois", "bes"], "bos": ["phis", "tis", "uds", "bh", "bits", "opus", "bones", "obb", "bris", "bas", "mos", "bo", "oops", "ubis", "antis", "bott", "abi", "obo", "bps", "bi", "ros", "bin", "obi", "os", "oks", "los", "oS", "zos", "oros", "bs", "zo", "fits", "obos", "las", "oos", "ios", "aos", "lol", "lins", "osa", "obs", "osi", "boot", "oses", "ois", "bes", "ops"]}}
{"id1": "620855", "id2": "17161805", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doVersioncheck", "doVersionScan", "doFeatureScan", " doVersionScan", "doVersionUpdate", "doFeaturecheck", "doFeatureCheck", "doVersioncheck", "doChangeCheck", "doFeatureUpdate", "doversioncheck", " doversionCheck", " doversioncheck", "doversionScan", " doversionUpdate", "doChangeUpdate", " doVersionUpdate", "doChangecheck", "doversionCheck", "doChangeScan", " doversionScan", "doversionUpdate"], "view": ["video", "cache", "out", "session", "config", "head", "event", "vol", "image", "comment", "base", "display", "pool", "see", "div", "views", "fail", "can", "http", "group", "form", "im", "client", "check", "ve", "this", "model", "use", "show", "by", "object", "self", "up", "ou", "user", "edit", "style", "update", "View", "link", "e", "input", "screen", "box", "VIEW", "sel", "container", "gu", "block", "html", "value", "widget", "port", "cell", "page", "manager", "review", "window", "server", "change", "ui", "query", "body", "index", "vis", "list", "lock", "el", "full", "row", "layout", "v"], "url": ["ls", "source", "gl", "buffer", "uri", "browser", "length", "path", "Url", "download", "f", "bb", "link", "l", "socket", "image", "blog", "loader", "loc", "web", "resource", "open", "hub", "builder", "location", "email", "www", "base", "log", "name", "b", "null", "server", "host", "URL", "zip", "sl", "address", "string", "fr", "stream", "ul", "ll", "impl", "file", "bug", "ssl", "ob", "id", "rel", "http"], "in": ["source", "as", "init", "buffer", "inn", "out", "pin", "inner", "ac", "s", "input", "socket", "sin", "IN", "data", "m", "ini", "win", "con", "resource", "binary", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "again", "rin", "file", "err", "login", "reader", "bis", "din", "doc"], "bin": ["init", "buffer", "gin", "inn", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "ban", "IN", "abi", "loader", "ini", "win", "record", "con", "binary", "bot", "bi", "arin", "b", "vin", "bn", "fin", "nb", "is", "body", "lock", "cin", "lin", "spin", "ruby", "file", "lib", "oin", "login", "reader", "din", "run"], "line": ["text", "lf", "look", "Line", "lines", "str", "out", "parse", "pin", "cell", "page", "link", "e", "one", "word", "l", "val", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "base", "name", "log", "b", "lc", "job", "pe", "code", "ge", "zip", "letter", "sl", "string", "LINE", "el", "lin", "range", "cl", "ine", "block", "write", "file", "part", "row", "key", "entry", "end", "le", "unit", "type", "id", "user", "jo"], "version": ["secret", "python", "video", "position", "license", "cover", "feature", "update", "download", "date", "ver", "author", "model", "versions", "VERSION", "driver", "project", "image", "install", "release", "format", "latest", "vert", "name", "device", "null", "server", "host", "code", "beta", "string", "Version", "patch", "dev", "option", "plugin", "value", "bug", "pull", "support", "id", "unit", "type", "v", "section", "vision", "user"], "build": ["work", "make", "style", "clean", "load", "update", "home", "ver", "built", "info", "use", "lease", "link", "show", "how", "image", "install", "follow", "release", "Build", "builder", "help", "print", "valid", "job", "log", "add", "building", "uild", "hold", "post", "tag", "patch", "lock", "block", "mount", "bug", "pull", "row", "feed", "boot", "unit", "get", "run", "rel", "http"]}}
{"id1": "16550855", "id2": "18489832", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 0, "substitutes": {"readPage": ["getFile", "readpage", "findPage", "openFile", "getPage", "readFile", "openPage", "findpage", "findPages", "getPages", "findFile", "readPages", "openpage", "getpage", "openPages"], "ignoreComments": ["includeComment", "ignorecomments", "useTags", "includeTags", "useComments", "oreQuotes", " ignoreQuotes", "useQuotes", "ignoreComment", " ignoreTags", " ignoreComment", "ignoreTags", "usecomments", "includecomments", " ignorecomments", "oreComments", "ignoreQuotes", "orecomments", "oreComment", "oreTags", "includeComments"], "in": ["source", "as", "init", "buffer", "into", "rec", "re", "inn", "gin", "out", "token", "client", "inner", "c", "f", "s", "e", "i", "input", "socket", "inside", "image", "IN", "data", "m", "ini", "win", "con", "loader", "on", "isin", "url", "din", "b", "it", "is", "nin", "min", "index", "ins", "h", "connection", "stream", "lin", "In", "inc", "again", "kin", "version", "file", "r", "t", "err", "login", "ssl", "reader", "id", "user", "bin", "http"], "inputLine": ["InputLine", "InputLink", "Inputline", "requestRow", "ifCo", "pullline", "pullRow", " inputLink", "installLine", "inputline", "rawLine", "InputL", "inputName", " inputText", "pullLink", " inputLook", "requestCo", " inputName", "rawName", "commentLine", "imageline", "InputName", "InputCell", "rawline", "inputRow", " inputL", "inputLink", "requestline", " inputline", "rawL", "ifLine", "inputL", "commentline", "InputPage", "commentCell", "inputCell", " inputPage", " inputCo", "incLine", " inputCell", "inputCo", "rawLink", "rawText", "requestLink", "InputText", "incL", "incline", "imageLine", "pullLine", "installline", "imageLook", "installL", "InputLook", "requestLook", "requestLine", "inputText", "ifline", " inputRow", "ifLook", "installLook", "imageL", "inputPage", "commentPage", "incLook", "inputLook"], "html": ["attr", "ht", "text", "message", "source", "embed", "flat", "result", "summary", "hot", "output", "json", "str", "flash", "strong", "f", "home", "page", "title", "view", "hard", "link", "show", "js", "dump", "war", "inline", "high", "atom", "data", "amp", "web", "blog", "format", "bf", "gh", "img", "tt", "www", "url", "base", "HTML", "article", "ui", "msg", "api", "body", "live", "rss", "htm", "tml", "h", "links", "header", "detail", "tf", "details", "wrap", "css", "temp", "bsp", "part", "template", "plain", "xml", "doc", "content", "http"]}}
{"id1": "692738", "id2": "22022715", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 0, "substitutes": {"url": ["source", "ref", "filename", "buffer", "uri", "path", "Url", "f", "config", "link", "l", "image", "loc", "loader", "service", "location", "resource", "www", "io", "base", "name", "bel", "null", "server", "host", "URL", "rl", "sl", "address", "string", "connection", "fr", "ur", "el", "ll", "lr", "html", "file", "ssl", "feed", "href", "ob", "id", "xml", "http"], "in": ["source", "as", "init", "inn", "gin", "out", "token", "pin", "inner", "c", "f", "config", "this", "ex", "i", "input", "socket", "serv", "conn", "inside", "image", "val", "or", "IN", "data", "m", "ini", "con", "resource", "n", "io", "isin", "a", "bin", "din", "is", "nin", "min", "ins", "In", "impl", "again", "rin", "file", "part", "err", "r", "login", "ssl", "id", "reader", "inc", "xml", "cms"]}}
{"id1": "7103223", "id2": "11005804", "code1": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"testPost": ["TestPOST", "testpost", "TestPost", "testPOST", "testTest", "TestTest", "testingPOST", "Testpost", " testPOST", "testingTest", "testingpost", "testingPost", " testpost", " testTest"], "request": ["method", "message", "call", "create", "result", "buffer", "copy", "client", "push", "session", "claim", "instance", "update", "use", "http", "e", "i", "send", "rest", "complete", "build", "req", "data", "throw", "condition", "object", "resource", "open", "QUEST", "q", "next", "document", "url", "add", "server", "transfer", "post", "query", "child", "api", "address", "upload", "string", "worker", "submit", "delete", "reference", "test", "remove", "rate", "user", "get", "xml", "Request", "report", "application"], "response": ["message", "method", "result", "output", "json", "out", "client", "session", "f", "environment", "status", "page", "success", "tree", "image", "xml", "application", "resp", "data", "object", "resource", "reply", "document", "next", "server", "Response", "pool", "api", "body", "index", "onse", "connection", "respond", "ception", "full", "block", "collection", "feed", "site", "o", "parent", "error", "report", "http"]}}
{"id1": "255765", "id2": "18696387", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"f": ["p", "x", "form", "lf", "F", "flat", "filename", "ref", "of", "fp", "fun", "fx", "cf", "path", "c", "s", "this", "w", "e", "l", "ff", "m", "fm", "folder", "fen", "bf", "self", "io", "g", "n", "a", "fo", "inf", "name", "b", "fd", "fs", "fe", "function", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "file", "df", "t", "feed", "r", "sf", "fi", "fold", "v", "d"], "in": ["source", "init", "gin", "session", "config", "w", "image", "con", "isin", "ins", "In", "d", "rec", "inn", "token", "pin", "with", "or", "IN", "data", "ini", "win", "n", "g", "up", "nin", "thin", "lin", "t", "diff", "bin", "str", "input", "socket", "serv", "a", "b", "gen", "is", "login", "reader", "get", "inc", "din", "p", "inner", "c", "ac", "pass", "ex", "l", "m", "it", "vin", "exec", "fe", "min", "connection", "fa", "lock", "cin", "again", "rin", "part", "r", "err", "ssl", "v", "ic"], "cbuf": ["cfuc", "rbbuf", "bcul", "bbuf", "bbuff", "ebuff", "fbuf", "rbux", "fbbuf", "bburs", "bbull", "rbuff", "cbutf", "bcur", "cbault", "rbul", "bcux", "buff", "buf", "dbuc", "rbuc", "fbuc", "cbuc", "dbuff", "zbuu", "cbux", "zbuf", "bcuff", "rbault", "rbutf", "cbuff", "ebuf", "bcuf", "CBuc", "bcull", "bux", "bault", "CBuf", "fbuff", "bcurs", "CBul", "ebuu", "cfuf", "dbur", "zbuff", "cfuff", "dbuf", "cbur", "rbull", "cfbuf", "cbull", "cbul", "CBuff", "rbuu", "rbuf", "rburs", "cburs", "cbuu", "ebutf", "cfur", "bcuc", "zbutf", "cbbuf", "bcault"], "read": ["work", "text", "x", "buffer", "Read", "parse", "want", "config", "w", "k", "cel", "val", "build", "close", "name", "log", "add", "pe", "report", "reads", "ack", "size", "stream", "repeat", "write", "ak", "ok", "iter", "un", "y", "key", "feed", "type", "start", "error", "d", "run", "last", "sync", "check", "load", "use", "view", "level", "ed", "count", "data", "play", "io", "g", "allow", "rc", "raw", "used", "ing", "insert", "id", "select", "know", "call", " reading", "reading", "update", "lex", "READ", "input", "send", "skip", "socket", "sleep", "ind", "readable", "print", "valid", "bit", " write", "each", "ize", "only", "en", "orig", "wait", " READ", "loop", "put", "reader", "bind", "get", "inc", "fill", " Read", "ride", "seek", "create", "re", "se", "length", "pass", "q", "record", "open", "old", "find", "connect", "ink", "num", "it", "change", "child", "hex", "oct", "index", "full", "r", "er", "end", "draw"], "totRead": ["totoRead", "totReading", "tobyLoad", " totLink", "notLoad", "totiBuild", "octotoReading", "tazonLoad", "TotWrite", "totSearch", " totalBuild", "TotaWrite", "totalBuild", "ntotWrite", "intotRead", "nottRead", "intottLoad", "tottSearch", "totaReading", "totiLink", "TottLoad", "totalAccept", "totaRead", "tobyUse", "tottFind", "totoLength", " totalWrite", "nottWrite", "dottLoad", "tottClose", "TotaLoad", "towWrite", "tetRead", "dotLoad", "tottedFollow", "totoConnect", "tottReader", "TottReader", "towReading", "tntWrite", "TottSearch", "dottReading", "totoUse", "intottBuild", "totingGet", "tottUse", "totaLink", "ntotRead", "totClose", "totGet", "tottBuild", "octotRead", "totoFind", "tottAccept", "dotReader", "TottFollow", "totalRead", "TotConnect", "towRead", "totAccept", "totoLoad", "towLoad", "totaBuild", "dottReader", "totoReading", "dotUse", "octotLength", "nottLoad", "tochLoad", "ntottLoad", "tottConnect", "TotSearch", "tatReader", "totingWrite", "TottRead", "tottLoad", "dottWrite", "totUse", "TotLoad", "dottUse", "TotFollow", "ntottReader", " totalLink", "totingSearch", "tottDraw", "totLoad", "totReader", " totalRead", "toyWrite", "tetWrite", "dottRead", "totLink", "tottGet", "toyDraw", "tntRead", "ntottRead", "intotLoad", "tottWrite", "totiRead", "TotaRead", "tochWrite", "TotDraw", "TotGet", "totaWrite", "tochRead", "intotBuild", "toyLoad", "tottedRead", "tochReader", "totingRead", "notWrite", "notAccept", "tollWrite", "ntottWrite", "TotaDraw", "tntReader", "tottRead", "TottConnect", "totoWrite", "ntotReader", "intottClose", "TottWrite", "tcotBuild", " totBuild", "tatRead", "tobyRead", "TottGet", "tcotLoad", "TotReader", " totWrite", "octotReading", "tollRead", "totalLink", "tollLoad", "totBuild", "ntotLoad", "tntLoad", "totingConnect", "tobyFind", "tcotClose", "tazonBuild", "tottLength", "nottAccept", "tollReading", "tottedWrite", "notRead", "dotReading", "tottFollow", "totalLoad", "tatLoad", "totingFollow", "tazonClose", "towLength", "TotReading", "totaLoad", "tottReading", "totDraw", "dotWrite", "totoSearch", "totLength", "totWrite", "octotoWrite", "totConnect", "tottedGet", "tatWrite", "dotRead", "octotWrite", "tetReading", "intottRead", "dottFind", "dotFind", "intotClose", "totaDraw", "totalWrite", "octotoLength", "TottReading", "totFind", "totaReader", "tetLoad", "toyRead", "tcotRead", "tazonRead", "TotRead", "totFollow", "totiWrite", "octotoRead", "towAccept"], "out": ["p", "x", "init", "output", "client", "sync", "net", "c", "ac", "s", "w", "plus", "ex", "l", "socket", "conn", "OUT", "writer", "n", "g", "io", "a", "up", "b", "outer", "ext", "exec", "obj", "conf", "h", "fn", "exp", "connection", "Out", "In", "outs", "inc", "again", "off", "file", "parent", "part", "t", "err", "r", "o", "v", "bin", "d"], "i": ["x", "source", "init", "buffer", "current", "ai", "I", "k", "ci", "abi", "chi", "ip", "name", "u", "li", "y", "key", "slice", "start", "d", "ti", "uri", "info", "ei", "one", "data", "ini", "multi", "iu", "bi", "io", "g", "pi", "api", "j", "eni", "id", "hi", "me", "ii", "e", "input", "ind", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "zi", "ri", "my", "phi", "p", "length", "z", "c", "ni", "gi", "ix", "ori", "ie", "l", "yi", "m", "q", "it", "ui", "ik", "oi", "index", "fi", "r", "v", "ic"]}}
{"id1": "6379126", "id2": "7006052", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTutorialPage", "riartutorialDir", "riartourDir", "riarTravisDir", "riarTourElement", "riarTravispage", "riarTravisPage", "riarTourDir", "riarTourpage", "riarTinyDir", "riartutorialPage", "riarTinyPage", "riarTravisElement", "riarTutorialDir", "riarTinypage", "riarTinyElement", "riarTutorialElement", "riartutorialpage", "riartourpage", "riartourElement", "riarTourPage", "riartourPage", "riarTutorialpage", "riartutorialElement"], "indexDir": ["IndexTier", "IndexDir", "includeTier", "indexTier", "includeJar", "indexJar", "zipDIR", "zipDir", "includeDir", "IndexJar", "zipJar", "IndexDIR", "includeDIR", "zipTier", "indexDIR"], "cssDir": ["fontDie", "piecesD", "ssDar", "javascriptDir", "codesLen", "ssUrl", "catsDoc", "CSSLen", "CSSDIR", "fontDir", "javascriptDb", "gzDIR", "ssDir", "CSSDoc", "cssDar", "ssDie", "cssLen", "codesDoc", "cssUrl", "cssDb", "ssDIR", "codesDir", "CSSDir", "catsDir", "cssD", "CSSDar", "piecesDIR", "CSSDb", "fontDIR", "CSSUrl", "javascriptDar", "gzDir", "ssDb", "ssD", "ssDirectory", "gzDirectory", "javascriptDIR", "cssDoc", "catsLen", "piecesDir", "cssDirectory", "gzUrl", "piecesDie", "cssDIR", "CSSDirectory", "fontD", "cssDie"], "capDir": ["casdir", "apsDirectory", "apsdir", "CapDirectory", "apsVol", "CapDir", "casDir", "capdir", "capDirectory", "capVol", "casVol", "apsDir", "casDirectory", "CapVol", "Capdir"], "licDir": ["lifManager", "licDoc", "libDir", "lifDoc", "libdir", "volDir", "libManager", "licdir", "volManager", "libDoc", "volDoc", "licManager", "voldir", "lifDir", "lifdir"], "midDir": ["casdir", "middir", "mindTier", "midTier", "mindDir", "casTier", "limdir", "midDIR", "limDir", "casDir", "mindDIR", "limTier", "casDIR", "limDIR", "minddir"], "filesDir": ["filesDur", "stylesDirectory", "stylesDur", "pagesDir", "stylesDIR", "imagesDirectory", "ballsPos", " filesVol", "opensDir", "filesDirectory", "filesVol", "pagesVol", "filesFile", "filesPos", "locksDIR", "stylesDir", "videosFile", " filesPos", "FilesFolder", "opensDIR", "locksDir", "opensDirectory", "locksDur", "locksDirectory", "opensDur", "videosDirectory", "imagesDir", "videosFolder", "filesDIR", "pagesPos", "FilesFile", "imagesFolder", "filesFolder", "ballsDir", "ballsVol", "FilesDir", "imagesFile", "FilesDirectory"], "videosDir": ["viewsDir", "videoFile", "videosDb", "viewsUrl", "videoDirectory", " videosFile", "videoDb", "videosFile", "viewsFile", " videosDirectory", "imagesDb", "videosDirectory", "viewsDirectory", " videosUrl", "imagesDir", "videoDir", "videosUrl", "videoUrl", " videosDb"], "imagensDir": ["imgensDir", "imagensJar", "imgensFile", "imagersDIR", "imagersJar", " imagensFile", "imagenciesDir", "imagentsJar", " imagersDir", "imagensFile", "imgensDIR", "imgentsFile", "imagenDirectory", " imagensDirectory", " imagensJar", "imgentsDir", "imagenciesDIR", "imagersDirectory", "imagentsDIR", "imagenJar", "imagenciesDirectory", "imagenFile", " imagersJar", "imagensDirectory", "imagentsFile", "imagenciesFile", "imgensDirectory", "imagensDIR", "imagenDir", " imagersFile", "imagentsDirectory", "imagersFile", " imagersDirectory", "imgentsDIR", "imagersDir", "imagentsDir", "imgentsDirectory"], "local": ["p", "util", "remote", "current", "json", "Location", "path", "username", "available", "inner", "basic", "home", "back", "state", "http", "pass", "Local", "input", "l", "pal", "localhost", "present", "global", "shared", "defined", "loc", "data", "total", "location", " Local", "LOC", "where", "personal", "internal", "self", "directory", "valid", "base", "name", "tmp", "log", "small", "initial", "standard", "relative", "conf", "upload", "specified", "managed", "lock", "prefix", "safe", "serial", "file", "temp", "request", "part", "partial", "dir", "user", "same", "d", "active"], "srcCss1": ["srcCpePre", "srcPcssPre", "srcPss1", "srcCfg2", "srcCse2", "srcRcss0", "srcCcss1", "srcPss2", "srcCfg4", "srcRcss81", "srcCss0", "srcCss11", "srcPss4", "srcPcss1", "srcCcss2", "srcCcssPre", "srcCfg1", "srcRss11", "srcRcss11", "srcCcss4", "srcPcss81", "srcCass3", "srcCcss3", "srcCcss11", "srcPssPre", "srcPss81", "srcCfgPre", "srcCss81", "srcCass11", "srcRss0", "srcCass2", "srcCrss81", "srcRcss2", "srcPcss4", "srcCrss3", "srcRss2", "srcCrss1", "srcRcss1", "srcCrss11", "srcCass81", "srcCssPre", "srcPss3", "srcCcss81", "srcCpe2", "srcCse1", "srcCass0", "srcCse0", "srcPcss3", "srcCse11", "srcCcss0", "srcCpe1", "srcCrss2", "srcCpe4", "srcPcss2", "srcRss1", "srcCass1", "srcRss81"], "destCss1": ["destPss3", "destCass1", "destCrss1", "destPss1", "destCass2", "destCrss2", "destPcssCard", "destPss81", "destPcss81", "destCrss81", "destCxx2", "destPcss2", "destCss0", "destCassCard", "destCfg1", "destCcss2", "destCfg0", "destCss81", "destPss0", "destPssCard", "destCcss0", "destCssCard", "destPss2", "destCxx3", "destPcss0", "destCass3", "destCxxCard", "destCcssCard", "destCcss1", "destCfg2", "destCrss0", "destPcss1", "destPcss3", "destCcss3", "destCass81", "destCfg3", "destCrss3", "destCcss81", "destCxx1"], "srcCss2": ["srcCcssB", "srcChess2", "srcAcss1", "srcPss1", "srcCfg2", "srcPcss27", "srcCass52", "srcCcss1", "srcCfgTwo", "srcPss2", "srcAccss2", "srcCcss52", "srcCng1", "srcCssB", "srcCfgB", "srcCross4", "srcCfgL", "srcCss27", "srcChessTwo", "srcPcss1", "srcCcss2", "srcCssTwo", "srcCfg1", "srcCross52", "srcUcss1", "srcCcss4", "srcCcss3", "srcUcssTwo", "srcCross1", "srcCng2", "srcUss2", "srcCrssL", "srcCass2", "srcAccss4", "srcAcss4", "srcCng27", "srcCrss3", "srcCfg3", "srcPssL", "srcUss1", "srcCrss1", "srcChess1", "srcCross2", "srcPss3", "srcAcss2", "srcUssB", "srcAcss52", "srcUssTwo", "srcCss52", "srcPcssL", "srcChessB", "srcPcss3", "srcAccss1", "srcCcss27", "srcPss27", "srcUcss2", "srcCrss2", "srcPcss2", "srcCssL", "srcCcssTwo", "srcCcssL", "srcUcssB", "srcCass1", "srcCass4", "srcAccss52", "srcCrss27"], "destCss2": ["destNcss32", "destCest2", "destNss4", "destCfg32", "destNss2", "destNss1", "destCfg72", "destNcssB", "destNcss3", "destCess2", "destNssB", "destCess4", "destCcssB", "destNcss72", "destNss32", "destCcss32", "destCess1", "destNcss2", "destCess72", "destCfg1", "destCcss2", "destCfgB", "destCssB", "destCcss72", "destCss72", "destCest3", "destCss32", "destCfg2", "destNss3", "destCcss1", "destCestB", "destCcss4", "destNcss4", "destCest1", "destCcss3", "destCess32", "destNss72", "destCfg3", "destCfg4", "destNcss1"], "srcCss3": ["srcCcss6", "srcPss2", "srcCss183", "srcClass15", "srcCcss15", "srcCcss4", "srcCssAND", "srcRcss4", "srcCass2", "srcPcssAND", "srcRcss1", "srcPss3", "srcPcss6", "srcRcssThird", "srcCass1", "srcCfg2", "srcCstyle6", "srcCstyle93", "srcCcss93", "srcCfg4", "srcCfg1", "srcCsh2", "srcCass3", "srcCcss183", "srcCrss3", "srcCfg3", "srcRss4", "srcPssAND", "srcScstyle2", "srcRss2", "srcCss93", "srcScss15", "srcClass3", "srcCssThird", "srcPcss3", "srcCss15", "srcRss1", "srcCcssAND", "srcRss183", "srcCcss1", "srcRssThird", "srcCsh183", "srcCsl3", "srcCstyle3", "srcCshThird", "srcScstyle15", "srcCrss6", "srcRcss183", "srcScss3", "srcCsh3", "srcRss3", "srcCstyleAND", "srcCstyle15", "srcCstyle2", "srcScstyle93", "srcCcss2", "srcCcss3", "srcScstyle3", "srcRcss3", "srcScss93", "srcRcss2", "srcCsl183", "srcClass2", "srcCrssAND", "srcCcssThird", "srcCslThird", "srcClass93", "srcCsl2", "srcCrss2", "srcPcss2", "srcPss6", "srcCass4", "srcScss2"], "destCss3": ["destScrss2", "destCcss183", "destPss3", "destCcss03", "destScrss183", "destNss2", "destScss183", "destNcss3", "destNcss43", "destNss43", "destCross2", "destCass2", "destCstyle2", "destCrss2", "destScss2", "destCstyle43", "destCross53", "destScss6", "destCss53", "destPss53", "destCrss6", "destCja2", "destCja3", "destPcss53", "destCja6", "destCross03", "destNcss2", "destPcss2", "destCstyle3", "destCstyle03", "destScss3", "destCcss43", "destCass43", "destCja183", "destPss2", "destCass3", "destNss3", "destCstyle53", "destCross3", "destCcss6", "destPcss03", "destCss03", "destCrss183", "destPss03", "destScrss3", "destPcss3", "destCcss53", "destCcss3", "destScrss6", "destCrss3", "destCss43", "destCcss2", "destCss183"], "srcCss4": ["srcCcssFour", "srcPcssFour", "srcPss1", "srcCcss1", "srcPss2", "srcPss4", "srcPcss1", "srcCcss2", "srcCcss4", "srcPssFour", "srcCass2", "srcCrssFour", "srcPcss4", "srcCrss4", "srcCrss1", "srcCassFour", "srcCssFour", "srcCrss2", "srcPcss2", "srcCass1", "srcCass4"]}}
{"id1": "18504192", "id2": "8046691", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "in": ["buffer", "copy", "inn", "inner", "c", "ac", "at", "info", "i", "input", "src", "image", "or", "IN", "data", "m", "ini", "old", "io", "url", "base", "name", "b", "min", "index", "ins", "In", "inc", "again", "file", "parent", "part", "login", "id", "reader", "diff", "bin", "d"], "out": ["p", "call", "copy", "cache", "output", "client", "c", "point", "w", "ex", "OUT", "conn", "line", "data", "writer", "object", "dest", "io", "n", "base", "name", "b", "obj", "password", "exec", "string", "connection", "external", "prefix", "Out", "outs", "again", "file", "temp", "part", "err", "o", "inc", "target"], "source": ["copy", "se", "client", "sync", "use", "component", "view", "slave", "ie", "i", "input", "ources", "ource", "src", "project", "sin", "SOURCE", "get", "writer", "Source", "service", "proxy", "from", "storage", "self", "dest", "core", "clone", "null", "server", "sl", "secure", "connection", "scope", "origin", "size", "channel", "stream", "settings", "iter", "ssl", "slice", "reader", "unit", "parent", "start", "target"], "destination": ["declification", "destinated", "destification", "testinations", " destining", "Destinated", "testinated", "dependination", "continated", "Destinations", "declinator", "continator", "contination", " destinations", "declinated", "testinator", " destinator", "testination", " destinated", "Destining", "Destination", "dependinator", "declination", "destinator", "contining", "dependinated", "Destinator", "destinations", "Destification", "destining", "dependification"]}}
{"id1": "755203", "id2": "8079516", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "21425787", "id2": "494226", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "in": ["work", "source", "inn", "inner", "c", "ac", "at", "ex", "i", "input", "image", "or", "IN", "data", "m", "ini", "up", "io", "a", "url", "base", "name", "b", "exec", "min", "index", "ins", "connection", "In", "inc", "again", "file", "login", "id", "reader", "bin"], "out": ["p", "x", "source", "call", "result", "cache", "output", "client", "c", "point", "at", "w", "ex", "to", "OUT", "conn", "data", "writer", "object", "dest", "io", "n", "up", "base", "name", "b", "server", "exec", "connection", "prefix", "Out", "outs", "again", "off", "file", "temp", "part", "o", "user", "v", "inc", "target"], "sourceChannel": ["ourceConnection", "sourceConnection", "SourceChan", "ourceChannel", " sourcechannel", "sourceChan", "SourceConnection", " sourceConnection", "resourceChan", "Sourcechannel", "srcConnection", " sourceStream", "sourceSocket", "srcSocket", "srcChannel", "targetchannel", "resourceChannel", " sourceChan", "srcChan", "targetChan", " sourceSocket", "ourceSocket", "sourcechannel", "ourcechannel", "sourceStream", "ourceChan", "targetStream", "resourcechannel", "SourceChannel", "SourceStream", "resourceConnection", "targetChannel"], "destinationChannel": ["destinatingChan", "DestinationChannel", "destinatingStream", "destinationchannel", "DestinationManager", "destinatedChannel", "destinationFile", "DestinatingStream", "destinatedFile", "destationchannel", "DestinationConnection", "destinateConnection", "destationChannel", "destinationStream", "destinateChannel", "DestinatorChannel", "destructionChannel", "destationFile", "destinatedManager", "destinatorManager", "destinatedStream", "destinationChan", "DestinationStream", "DestinatorConnection", "destinatedChan", "destinatorConnection", "destinationConnection", "DestinatingManager", "destinatedConnection", "destinatorChan", "DestinatingChannel", "destinatedchannel", "DestinatorChan", "DestinatorFile", "destinationManager", "destationConnection", "destinateChan", "destinatingChannel", "DestinationChan", "Destinationchannel", "Destinatorchannel", "destructionChan", "destinatingManager", "DestinationFile", "destructionConnection", "destinatorFile", "DestinatingChan", "destinatorchannel", "destinatorChannel", "destinatorStream"]}}
{"id1": "4593011", "id2": "6371589", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"loadDDL": ["loadODL", "loadSDL", "loadDDE", "LoadCDLL", "loadSDLL", "loadDDML", "LoadDDLL", "loadCDML", "loadDDLL", "loadODE", "loadCDLL", "loadSDE", "LoadDDE", "LoadCDML", "LoadDDL", "loadODML", "loadCDE", "LoadDDML", "loadODLL", "loadCDL", "LoadCDL", "LoadCDE", "loadSDML"], "stmt": ["estmp", "STgr", "estm", "Stmb", " stmn", "estmt", "Stmp", "sttt", "Stmd", "stgr", "tmt", "Sttt", " stgr", "STmt", "STmr", "stmd", " sttt", "tmd", "Stdb", "constdb", "stmr", "rmt", "tdb", "sttr", "estmb", " sttr", "STpr", "stdb", "Stmt", "rm", "STmb", "Stm", "estmd", "rdb", "rmd", " stm", "Stmr", "strpr", "strmt", " stpr", "STtr", "stm", "tm", "constm", "stmn", "estmr", "strtr", "strgr", "stpr", "constmn", "Stmn", "stmp", "esttt", "constmt", "stmb", "STmp", " stdb", " stmd"], "qry": ["quri", "qrys", "eqrys", "qri", " qRY", "Qry", "quury", "eqry", "qries", "Qri", "qurys", " qries", "qury", "Qrys", "quries", " qrys", "quRY", "equry", "eqRY", "Qries", "qRY", " qury", " qri"], "q": ["p", "select", " p", "c", "f", "config", "ql", "quant", "e", "i", "k", "qq", "qt", "req", "iq", "quest", "n", "b", "qs", "requ", "query", "ch", "queue", "qa", " sq", "sq", "qu", "Q", "request", " req", " query", "key", "r", "t", "id", "eq", "v", "dq", "d"]}}
{"id1": "14878593", "id2": "16623181", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": [" hyperlinkStyle", " hyperlinkUpdated", "hyperimageStyle", "hyperimageUpdated", "hyperflowUpdated", "hyperLinkUpdate", "hyperlinkEvent", "hyperlinkUpdated", " hyperLinkEvent", " hyperlinkEvent", "hyperflowUpdate", "hyperlinkStyle", "hyperflowStyle", " hyperLinkStyle", "hyperimageEvent", "hyperimageUpdate", "hyperLinkUpdated", " hyperLinkUpdated", "hyperflowEvent", " hyperLinkUpdate", "hyperLinkStyle", "hyperLinkEvent"], "e": ["p", "x", "message", "eve", "c", "f", "environment", "this", "event", "ie", "de", "ed", "exc", "enter", "E", "data", "m", "ce", "ec", "g", "a", "u", "esi", "change", "it", "exec", "handler", "element", "ee", "el", "ae", "es", " event", "ev", "t", "er", "entry", "o", "type", "v", "events", "Event", "ea"], "url": ["text", "source", "filename", "buffer", "video", "uri", "absolute", "browser", "large", "path", "Url", "download", "f", "config", "page", "event", "view", "link", "l", "image", "data", "service", "object", "resource", "email", "location", "io", "base", "log", "server", "host", "URL", "sl", "address", "secure", "string", "connection", "channel", "element", "plugin", "layer", "file", "ssl", "http"], "stream": ["source", "form", "buffer", "video", "sw", "output", "out", "client", "port", "path", "flash", "f", "view", "driver", "per", "input", "trans", "draft", "src", "image", "or", "read", "data", "loader", "resource", "transform", "io", "log", "thread", "pool", "sl", "upload", "string", "Stream", "channel", "handler", "wrapper", "raw", "file", "temp", "ssl", "response", "feed", "reader", "engine", "oper", "http"], "writer": ["text", "source", "buffer", "words", "writers", "output", "widget", "inner", "author", "written", "this", "w", "driver", "writing", "word", "draft", "riter", "data", "service", "format", "builder", "Writer", "storage", "io", "document", "wrote", "null", "player", "writ", "letter", "string", "worker", "channel", "rw", "handler", "WR", "write", "office", "temp", "key", "r", "entry", "reader", "unit", "engine", "xml"], "editor": ["text", "attr", "edit", "video", "Editor", "browser", "widget", "cover", "translation", "author", "config", "fb", "this", "font", "title", "archive", "info", "content", "driver", "flower", "ie", "button", "owner", "area", "manager", "options", "riter", "oder", "ner", "object", "director", "journal", "builder", "comment", "open", "paper", "io", "document", "server", "article", "player", "ui", "term", "api", "external", "layer", "plugin", "auto", "settings", "parser", "html", "creator", "office", "part", "er", "edited", "ob", "layout", "reader", "o", "parent", "order"], "name": ["source", "style", "filename", "uri", "large", "path", "username", "ame", "alias", "info", "NAME", "home", "title", "one", "word", "Name", "image", "none", "default", "data", "names", "object", "comment", "n", "action", "base", "null", "label", "number", "letter", "address", "time", "string", "connection", "size", "prefix", "full", "office", "value", "file", "version", "named", "part", "anc", "key", "id", "type", "no"], "dialog": ["choect", "demog", "flOG", "navog", "navbox", "fogged", "dialect", "dialogue", "locOG", "choog", "flogs", "flog", "videobot", "locogue", "llog", "dialogg", "dialogged", "chobox", "plob", "chooc", "demogged", "dialbot", "plOG", "fog", "locob", "collogs", "demogg", "dialbox", "plogue", "log", "logue", "paloc", "fbot", "palect", "palbox", "plog", "dembot", "llogue", "dialogs", "navect", "collogue", "llogs", "llOG", "videoogged", "videoog", "navoc", "lOG", "locog", "videoogg", "collOG", "collog", "dialoc", "lob", "dialob", "flogue", "fogg", "dialOG", "palog"]}}
{"id1": "21152728", "id2": "19276022", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"authenticate": ["authication", "Authentication", " authenticated", "authicate", "authenticating", "Authenticated", "authentication", "authenticated", "authicated", "Authenticate", "authicating", " authentication", " authenticating", "Authenticating"], "module": ["course", "message", "method", "role", "mode", "table", "str", "script", "pin", "mod", "py", "instance", " Module", "config", "model", "domain", "component", "input", "manager", "conn", "project", "data", "m", "object", "resource", "service", "io", "class", "base", "name", "device", "vm", "server", "modules", "msg", "query", "address", "connection", "rule", "require", "scope", "lock", "prefix", "header", "chain", "mi", "element", "plugin", "cm", "mission", "file", "pm", "entry", "site", "unit", "Module", "ctx", "member", " modules"], "rand": ["init", "ro", "re", "token", "out", "push", "pad", "reg", "seed", "rar", "Rand", "max", "gram", "conn", "raid", "bird", "han", "in", "auth", "bot", "round", "rot", "grad", "NG", "random", "gen", "nd", " random", "chance", "gd", "rc", "min", "alpha", "crypt", "dd", "ng", "range", "sum", "rage", "winner", "r", "right", "pattern"], "challenge": ["Challenge", "challise", "passise", "buckenge", " challge", "passenges", "scheise", " challchall", "challge", "passenge", "scheaine", "chalenge", "challonge", "chalge", "challaine", "challenges", "chge", " challonge", "Challge", "chalenges", "buckge", "chise", "challchall", "buckchall", "chenge", "Challise", "chaine", "Challaine", "schege", "Challonge", "chalise", "Challchall", "scheenge", "scheenges", "passge", "buckonge"], "b64": ["base62", "B16", "base58", "B64", "base16", " bbl", "bb64", "xbbl", "bbl", " b48", " b4", "b58", "b4", "mb64", "b48", "basebl", "xb62", "bb58", "xb64", " b16", "b36", "bb16", "base48", "base36", "mb58", "b16", "base64", "mb4", "mb16", "bb36", " b62", "B58", "xb48", " b36", "b62", "B4", " b58"], "reply": ["text", "secret", "message", "remote", "result", "buffer", "reset", "uri", "out", "sync", "parse", "py", "frame", "info", "back", "http", "rr", "link", "notice", " replies", "resp", "data", "service", "comment", "voice", "next", "related", "base", "reason", "server", "Response", "query", "address", "body", "string", "respond", "connection", "prefix", "queue", "repl", "range", "Reply", "write", "received", "replace", "answer", "request", "route", "ridge", "part", "template", "entry", "id", "error", "report"], "user": ["account", "text", "match", "secret", "me", "uid", "source", "result", "role", "token", "client", "out", "username", "cover", "field", "session", "pin", "author", "ver", "date", "use", "person", "pass", "per", "word", "manager", "project", "USER", "by", "data", "service", "object", "resource", "proxy", "consumer", "open", "comment", "force", "valid", "url", "character", "name", "device", "allow", "server", "using", "host", "password", "query", "address", "string", "rule", "lock", "profile", "plugin", "write", "full", "used", "replace", "creator", "users", "parent", "request", "bug", "key", "route", "entry", "id", "login", "type", "error", "User"], "response": ["account", "secret", "message", "result", "uri", "json", "output", "token", "session", "model", "resp", "data", "service", "object", "resource", "format", "description", "url", "server", "Response", "host", "password", "address", "api", "body", "string", "header", "respond", "connection", "profile", "respons", "version", "answer", "request", "error", "status"], "secrets": ["Secures", "secret", "securs", "securityures", "secures", "regurs", "securityurs", "Secrets", "regards", " secret", "secards", "secredits", "SECrets", "securityrets", "SECures", " secredits", "Securs", "SECret", "Secret", "SECards", "subret", "SECurs", "Secredits", "subredits", "regret", "regrets", "Secards", "subrets", "securityret"], "md4": [" md44", "sha2", "md2", "sha4", "MD6", " md256", " md6", "madfour", "sha04", "md5", "mc6", "MD4", " md04", "mad4", "mc4", "md256", "MD256", "mdfour", "sha5", "MD2", " md2", "MD04", " md5", "mad04", "mad2", "mc5", "shafour", "sha6", " mdfour", " MD6", "md44", "md6", " MDfour", "mad256", " MD4", "MDfour", " MD2", "sha44", "MD44", "md04", "mcfour"], "line": ["text", "message", "lf", "style", "look", "Line", "lines", "str", "sync", "parse", "out", "cell", "lo", "frame", "model", "page", "pass", "link", "l", "inline", "data", "definition", "record", "object", "strip", "comment", "shell", "url", "log", "name", "lc", "pe", "server", "code", "letter", "body", "string", "header", "rule", "lock", "profile", "LINE", "cl", "lin", "range", "block", "value", "file", "part", "row", "entry", "end", "le", "error", "status"], "passwd": ["assw", " passpassword", "ppass", " passpass", "asspass", "pw", "asswd", "assWD", "Passpassword", "passwordpassword", "Passpass", "PassWD", "passwordword", "passwordpass", "Passw", "password", "passw", " password", "passpass", "pwd", "Passwd", "passpassword", "Password", "passWD", "passwordwd", "pWD"], "hash": ["match", "secret", "style", "hed", "cache", "check", "flash", "cover", "ash", "image", "build", "kh", "object", "shadow", "url", "base", "array", "Hash", "server", "sha", "hex", "body", "h", "tag", "header", "sum", "sh", "block", "html", "ha", "value", "version", "key", "sign", "her", "id", "rh"]}}
{"id1": "16760971", "id2": "1371265", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"generateHash": ["generatesHash", " GeneratedKey", "generoseMac", " GenerateSalt", " GeneratedMac", "generoseSalt", "generatedHash", "generatesMac", "generoseHash", " GeneratedSalt", "generateSalt", " GeneratedHash", "generoseKey", " GenerateHash", " GenerateKey", "generatedSalt", "generatesKey", " GenerateMac", "generateKey", "generatesSalt", "generateMac", "generatedMac", "generatedKey"], "key": ["work", "text", "secret", "message", "char", "cy", "token", "str", "ace", "fee", "path", "keys", "point", "date", "hash", "seed", "word", "k", "data", "cert", "ce", "mac", "self", "url", "base", "name", "pe", "code", "password", "msg", "address", "hex", "proof", "body", "string", "rule", "connection", "crypt", "prefix", "full", "block", "trust", "file", "sign", "KEY", "id", "type", "user", "Key", "pair"], "md": ["me", "mand", "message", "hm", "mm", "mp", "clean", "mod", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", "po", "ds", "mb", "mg", "m", "nm", "mage", "metadata", "mad", "ad", "mac", "editor", "bm", "rm", "sm", "ms", "mail", "nd", "pd", "dr", " MD", "ld", "di", "dd", "od", "cm", "mo", "mt", " Md", "hd", "mem", "am", "cd", "MD", "dh", "mc", "ma", "df", "mag", "pm", "d", "rpm", "bd", "dc"], "bytes": ["ls", "parts", "bles", "Bytes", "words", "lines", "bits", "ips", "keys", "fb", "s", "seconds", " bits", "vals", "les", "ones", "data", "errors", "strings", "bps", "binary", "vs", "cells", "values", "pieces", "letters", "pins", "b", "objects", "os", "files", "zip", "bs", "gb", "pages", "codes", "outs", "es", "items", "boot", "bis", "blocks", "rows", "ops"], "buff": ["app", "flat", "buffer", "sb", "uf", "fx", "py", "bag", "obb", "f", "bb", "fb", "buf", "hack", "bo", "txt", "agg", "pb", "ff", "mb", "cast", "ph", "amp", "kb", "bf", "tt", "tmp", "b", "fw", "nb", "Buffer", "append", "eb", "gb", "uff", "bm", "cp", "tf", "cpp", "batch", "html", "bug", "pp", "ob", "diff", "Buff", "ctx", "bis", "cb", "abb", "bd"], "l": ["p", "x", "ls", "lp", "ln", "L", "al", "length", "z", "kl", "c", "jl", "f", "pl", "il", "e", "i", "bl", "nl", "ell", "ol", "dl", "lb", "n", "u", "b", "lc", "col", "ly", "rl", "fl", "sl", "li", "j", "h", " L", "cl", "el", "ll", "ul", "lu", "lv", "t", "o", "le", "v", "d", "la"], "hx": ["dhx", " hxc", "hrx", "hxa", "hsrx", "Hxc", "hc", "Hrx", " hrx", "Hex", " hwx", "hsx", " hxa", "Hx", "hswx", "hwx", "dhc", " hc", " hex", "dhex", "Hc", "hex", "hsxc", "hxs", " hxs", "hmxs", "hxc", " hy", "hmy", "Hxa", "Hy", "hmx", "dhxc", "hmxa", "hy", "Hxs", "Hwx"]}}
{"id1": "23199071", "id2": "10385815", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getStreamstream", "getContentstream", "getReadChannel", "getReadStream", "newInputSteam", "getInputChannel", "newInputstream", "getReadstream", "getContentStream", "getInputstream", "getContentChannel", "newContentChannel", "newContentstream", "getStreamStream", "newInputChannel", "getInputSteam", "getStreamSteam", "getContentSteam", "newInputStream", "newContentStream", "getReadSteam", "newContentSteam", "getStreamChannel"], "url": ["source", "ref", "remote", "buffer", "gl", "uri", "str", "loc", "path", "Url", "tool", "download", "f", "page", "link", "i", "l", "image", "default", "resources", "build", "data", "left", "web", "in", "service", "resource", "location", "email", "q", "www", "class", "base", "name", "log", "bel", "null", "server", "host", "URL", "rl", "fl", "sl", "address", "api", "secure", "string", "rule", "fr", "ur", "cl", "lr", "ll", "full", "el", "coll", "ul", "html", "route", "pull", "r", "feed", "dir", "ob", "id", "ssl", "href", "type", "user", "jar", "rel", "http"], "file": ["work", "source", "local", "File", "uri", "cache", "fp", "path", "f", "info", "model", "page", "place", "use", "e", "l", "image", "line", "loc", "data", "folder", "object", "resource", "money", "able", "play", "FILE", "class", "base", "name", "log", "b", "job", "files", "fe", "zip", "letter", "child", "live", "connection", "rule", "full", "lib", "part", "route", "feed", "dir", "id", "unit", "plain", "db", "http"]}}
{"id1": "23532405", "id2": "18748516", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"persist": ["Persister", "Persistence", "persister", "plist", "plister", "persistence", " Persists", " Persistence", "Persist", "plists", " Persist", "persists", " Persister", "plistence", "Persists"], "ffConfigurable": ["effConfural", "uffLogurable", "ffconfigurred", "effConfigurable", "ffConfiguring", "ffPlur", "ffConfured", "ffConfurred", "ffPlurable", "ffFure", "effConfigural", "ffSegural", "ffGurable", "ffLoguring", "ffConfigure", "ffLogural", "ffSegurer", "ffConfur", "uffConfiguring", "ffConfigurer", "FFConfigurer", "uffLogure", "ffFured", "ffLogurer", "FFConfurred", "ffconfigurable", "effConfigured", "uffLogured", "ffGuring", "ffFuring", "ffConfigured", "ffPluring", "FFConfurer", "ffConfigur", "FFConfigurable", "ffPlurer", "uffConfigure", "ffLogurable", "FFConfigural", "ffConfurable", "ffconfigurer", "ffConfigural", "effConfurer", "ffSegured", "uffConfigurable", "uffConfigured", "FFConfur", "ffSegurable", "effConfigurer", "FFConfurable", "FFConfigur", "ffLogure", "FFConfural", "ffGurer", "effConfured", "ffConfure", "ffConfurer", "ffLogured", "ffSegurred", "FFConfuring", "FFConfigurred", "ffConfigurred", "ffGur", "uffLoguring", "ffconfigural", "ffConfuring", "ffConfural", "ffFurable", "FFConfiguring", "effConfurable"], "relativePath": ["relativeName", "protectedFile", " relativePoint", "absolutePath", " relativeName", "relativeLocation", "absoluteName", " relativeFile", "protectedPath", "ativePath", "ativeName", "ativeLocation", "relativeFile", "absoluteUrl", " relativepath", " relativeLocation", "protectedPoint", "ativeUrl", "absoluteLocation", "relativeUrl", " relativeUrl", "absolutePoint", "absolutepath", "absoluteFile", "relativePoint", "protectedpath", "relativepath"], "file": ["work", "source", "local", "form", "filename", "File", "fp", "cache", "out", "cf", "path", "config", "f", "store", "model", "use", "place", "ile", "il", "show", "e", "l", "image", "single", "data", "in", "folder", "object", "location", "module", "self", "io", "FILE", "directory", "class", "url", "base", "name", "log", "b", "pe", "it", "files", "fe", "zip", "stream", "handler", "el", "full", "php", "temp", "parent", "part", "dir", "sf", "unit", "le", "type", "get", " File", "db", "http"], "is": ["mis", "as", "ris", "ps", "was", "IS", "isa", "out", "us", "oss", "ai", "info", "ii", "iss", "i", "Is", "iso", "gets", "in", "does", "ir", "ws", "ip", "io", "si", "ms", "fs", "ui", "api", "isi", "ais", "ios", "ics", "es", "iris", "nis", "bis"], "os": ["OS", "as", "oss", "us", "bos", "ips", "uns", "oes", "s", "ori", "ens", "iso", "ol", "rs", "oa", "io", "ms", "oS", "cos", "los", "ou", "ies", "fs", "oid", "oos", "ais", "ios", "aos", "outs", "ils", "ows", "obs", "Os", "o", "osi", " bos", "oses", "ops"]}}
{"id1": "6988216", "id2": "20623709", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runRawQuery", " runRawFilter", " runClientConnect", "runRawFilter", " runSimpleSearch", "runSimpleConnect", "runRawSearch", "runSimpleQuery", "runSimpleSearch", " runRawConnect", " runBasicFilter", " runClientSearch", " runClientQuery", " runBasicSearch", "runRawConnect", " runBasicConnect", " runSimpleConnect", "runSimpleFilter", " runRawSearch", " runSimpleFilter", " runClientFilter", " runSimpleQuery", "runRawQuery", " runBasicQuery"], "dummySource": ["pummyService", "puddySource", "dandySite", "dumbConfig", "dellyType", "pummySite", "pummyType", "dumbOrigin", " dumbConfig", "dumbContent", "duddyClient", "dummyType", "dellyContent", "duddySite", "dumbSource", " dumbOrigin", "duddyOrigin", "dandyClient", "duddyContent", "puddyService", " dumbSource", "dundleOrigin", " dumbContent", "duddyService", "puddyClient", "dummyClient", "daddySite", "dellyService", "dummySourceFile", "pummySource", "pummyClient", "puddySite", "dandySourceFile", "dandySource", "pummyContent", "puddySourceFile", "puddyType", "dundleContent", "dummyService", " dummyOrigin", "duddyConfig", "dummyOrigin", "pummySourceFile", "dellySource", "daddyClient", "duddySource", "dummySite", "daddySourceFile", " dummyConfig", "duddyType", "dundleSource", "dummyConfig", "daddyType", "daddyService", "daddyContent", "daddySource", "duddySourceFile", "dundleConfig", "puddyContent"], "os": ["ls", "OS", "as", "oc", "dos", "ps", "ss", "ols", "out", "oss", "bos", "us", "uns", "s", "ori", "ens", "mos", "i", "ds", "pos", "acs", "conn", "or", "iso", "ose", "sys", "object", "ol", "vs", "oa", "nos", "io", "ros", "ks", "ms", "cos", "oS", "los", "ou", "is", "fs", "bs", "om", "oos", "ios", "aos", "ok", "ox", "ns", "ows", "es", "css", "obs", "op", "Os", "o", "osi", "oses", "ops"], "dummyContent": ["duddyBody", " dummyContents", "DummyReader", " dellyOutput", "duddyReader", " dummyOutput", "duckyBody", "dumperContents", "dellyContents", "DummyContent", "DuckySource", "dellyContent", " dellyContents", "dummyOutput", "duckyReader", "dumperBody", "dumpingContent", "DuckyContent", "duddyContent", "dumpingOutput", "DummyBody", "dummyBody", "dummyContents", "duckyContent", "dummycontent", " dummycontent", "dumperSource", "dumperReader", "dumperContent", "DuckyBody", "DuckyReader", "dumpingContents", "duckySource", "dellyOutput", "dummyReader", "duddySource", "DummySource", "dumpercontent", "dumpingcontent", " dellyContent", "dellycontent", " dellycontent", "dumperOutput"], "source": ["text", "result", "cache", "uri", "client", " Source", "sync", "config", "s", "info", "use", "seed", "slave", "e", "i", "ources", "ource", "src", "SOURCE", "sin", "resources", "Source", "service", "object", "resource", "proxy", "storage", "core", "class", "url", "cos", "search", "host", " sources", "sc", "sl", "secure", "scope", "connection", "string", "channel", "size", "stream", "element", "sn", "ser", "site", "reader", "unit", "parent", "node", "target"], "content": ["text", "match", "message", "result", "media", "expression", "output", "current", "music", "news", "cover", "clean", "load", "update", "activity", "config", "cms", "model", "title", "sol", "input", "image", "data", "service", "resource", "transform", "comment", "description", "document", "url", "cos", "cont", "server", "host", "code", "child", "address", "body", "header", "size", "html", "Content", "value", "version", "css", "response", "feed", "comments", "children", "xml", "target", "report"], "qResult": ["queryResults", "rresult", "queryFilter", "qResponse", "kresult", "kResults", "qFilter", "QFilter", "queryReturn", "kReturn", "qRes", "QReturn", "iqResult", "QResult", "kRes", "QResults", "iqResponse", "queryResult", "rRes", "qReturn", "rSource", "iqresult", "queryResponse", " qResponse", "qresult", "rResult", " qresult", "querySource", "kFilter", "qResults", "iqResults", "queryresult", "queryRes", "kResult", "qSource", " qResults", "kSource"], "results": ["tests", "ions", "result", "lines", "successful", "versions", "s", "its", "Results", "groups", "shows", "resources", "data", "errors", "values", "RESULTS", "ries", "qs", "objects", "docs", "files", "members", "res", "reports", "features", "ins", "models", "pages", "blocks", "details", "vers", "runs", "users", "collection", "response", "items", "children", "events", "ids", "rows"], "it": ["p", "ort", "edit", "ait", "the", "init", "It", "itted", "info", "not", "its", "ite", "i", "l", "ited", "ci", "or", "pit", "in", "rit", "which", "ip", "and", "si", "iti", "you", "ati", "sit", " It", "split", "stat", "list", "ins", "mit", "IT", "lit", "iter", "t", "ITS", "op", "r", "id", "entry", "slice", "v", "ic"], "rSrc": ["rDsRC", " rDssrc", "rEssrc", " rEsRC", "rAsrec", " rSource", " rSsrc", "rEsRC", " rSRC", "rIsrc", "rSsrc", " rEsrc", " rDsRC", " rEssrc", "RIsRC", "rPsrc", "rDssrc", "rIsRC", "rSrec", "RSource", " rEsource", "rAsRC", "rAssrc", "rPsource", "RIsrec", "rSource", "RIsource", "rSRC", "rIsource", "RSRC", "rDsrc", "RIsrc", " rDsrc", "rIsrec", "rEsrc", "RSrec", "RSrc", "rDsource", "rAsource", "rEsource", "rPssrc", "rPsRC", " rDsource", "rAsrc"], "rSrcIn": ["rSsrcIn", "rSRCIns", "rAsRCIn", "rSrcIns", "rSvcIN", "rSourceOut", "rSvcin", "rSsrcIN", "rCrcIN", "rSourceIn", "rCRCIn", "rSrcin", "rAsrcIn", "rCrcIns", "rSsrcin", "rCrcin", "rSRCIN", "rSourceIns", "rAsRCOut", "rCsrcOut", "rCrcOut", "rSRCOut", "rSRCin", "rCsrcIn", "rSvcOut", "rAsRCin", "rAsrcin", "rCsrcIN", "rSourcein", "rSRCIn", "rCRCIns", "rCsrcin", "rCrcIn", "rAsrcOut", "rSrcIN", "rSsrcOut", "rSvcIn", "rCRCOut", "rSvcIns", "rSrcOut"], "actualOut": ["operatorOUT", " ActualOUT", "assertOUT", "illegalOUT", " actualOutput", "assertIn", "publicIn", "assertBridge", "nexpectedWin", " actualOUT", "illegalOut", "nexpectedIn", " ActualOut", "publicOUT", "eventout", "realOut", "eventIn", " actualWin", " actualout", "operatorOut", "assertOut", "publicOutput", "actualBridge", "actualOUT", "illegalOutput", "actualIn", "eventOUT", "operatorIn", " actualIn", "operatorout", "actualout", " actualBridge", "illegalIn", "realout", " ActualBridge", "realIn", "realWin", " ActualIn", "actualOutput", "nexpectedOut", "actualWin", "publicOut", "nexpectedout", "eventOut"]}}
{"id1": "13852596", "id2": "23510383", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"execute": ["call", "create", "copy", "parse", "ute", "invoke", "load", "all", "process", "install", "evaluate", "server", "code", "exec", "transfer", "report", " invoke", " perform", "Exec", "submit", "test", "register", "apply", "start", "handle", "run"], "resources": ["relations", "workers", "types", "rules", "chains", "apps", "locks", "writers", "groups", "issues", "services", "projects", "strings", "resource", "cells", "flows", "archives", "works", "rings", "objects", "series", "thumbnails", "params", "files", "stores", "reports", "features", "models", "pages", "scripts", "plugins", "users", "rates", "results", "Resources", "items", "maps", "classes", "ions", "events", "ids", "stars", "images", "roots"], "i": ["p", "ani", "uri", "ai", "f", "gi", "ii", "info", "ori", "s", "e", "vi", "ie", "l", "I", "k", "wei", "ci", "abi", "ini", "we", "ami", "ir", "multi", "ip", "iu", "bi", "io", "si", "ti", "u", "is", "ui", "pi", "oi", "isi", "j", "li", "iri", "h", "hi", "di", "qi", "eni", "xi", "cli", "mu", "o", "id", "v", "esi", "ri", "ic", "phi"], "classFile": ["classFILE", "ruleLine", "staticfile", "classEntry", "CLASSFile", "connectionFile", "sessionFILE", "ClassGlobal", "customEntry", "sessionFile", "classClass", "Classfile", "filefile", "lassFiles", " classFILE", " classPage", "baseFile", "lassClass", "lassGlobal", "fileFiles", "finalFILE", "serviceLine", "CLASSEntry", "classGlobal", "staticFILE", "packEntry", "fileLoader", "CLASSFILE", "connectionfile", "ClassFactory", "ClassPage", "ClassImage", "sessionfile", " classEntry", "finalfile", "CLASSLoader", " classLoader", "ClassFiles", "baseUrl", "classLoader", "ClassClass", "customFILE", "classfile", "ClassFilename", "servicefile", "staticLine", "classesPath", "objectFiles", "ClassEntry", "objectfile", " classFiles", "classFactory", " classLine", "finalUrl", "ClassDir", " classGlobal", "classImage", "fileImage", "packFile", "classFiles", "ruleFile", "classPage", "classUrl", "ClassStream", "classesFile", "packFILE", "fileFile", " classFactory", " classStream", "classesFiles", "finalFile", "classStream", "CLASSLine", "classesfile", "classDirectory", "classPath", "classDir", " classFilename", "sessionEntry", " classClass", "CLASSDirectory", "connectionFiles", "baseFILE", "ruleFiles", "customFiles", " classDir", "ruleFilename", "CLASSfile", "ClassFile", "packfile", "serviceFile", "customFile", "classFilename", "CLASSImage", "ClassPath", "ClassLine", "fileDirectory", "basefile", "ClassDirectory", "fileLine", "staticFile", "sessionFactory", "CLASSUrl", "CLASSPage", "CLASSFiles", "objectDir", "classLine", "lassFile", "connectionStream", "objectFile", "sessionFiles", " classPath", " classfile", "serviceFILE", "ClassFILE"], "inputStream": ["InputFile", "initSteam", "InputStreamer", "uploadstream", "binaryFile", "importSteam", "inputContext", "outputStreamer", " inputstream", "rawFile", "inputFile", "importStream", "childstream", "inputSw", "childContext", "activeSteam", "outputContext", "binaryStream", "activeStream", "outputReader", "childStream", "uploadStream", "Inputstream", "rawStream", "activeStreamer", "rawSteam", "initStreamer", "inputReader", "inputstream", "InputStream", "outputSw", "InputSw", "importStreamer", "uploadSw", " inputFile", "InputSteam", "binaryStreamer", "inputStreamer", " inputStreamer", " inputSteam", "outputstream", "inputSteam", "rawStreamer", "childReader", "outputFile", "uploadFile", "importstream", "activestream", " inputContext", "initStream", "outputSteam", "initstream", " inputReader", "binarySteam"], "reader": ["source", "arser", "rx", "buffer", "copy", "writers", "re", "client", "reading", "sync", "inner", "author", "system", "rr", "seed", "driver", "ler", "per", "rar", "input", "owner", "manager", "war", "draft", "shared", "or", "read", "riter", "loader", "ner", "oder", "resource", "builder", "director", "ger", "Writer", "io", "editor", "reflect", "rer", "server", "book", "dr", "rc", "worker", "handler", "stream", "ee", "layer", "wrapper", "parser", "Reader", "iter", "request", "row", "key", "er", "entry", "keeper", "right", "ri", "report", "context", "http"], "oldSize": ["OldName", "oldName", "OldSc", " oldSc", "oldLength", "prevSize", "prevLength", "prevSc", " oldName", "prevName", "OldSize", " oldLength", "OldLength", "oldSc"], "writer": ["wer", "buffer", "writers", "token", "widget", "wire", "inner", "author", "written", "w", "driver", "ler", "writing", "word", "e", "war", "manager", "draft", "read", "riter", "data", "ner", "loader", "service", "resource", "builder", "format", "director", "object", "Writer", "oder", "walker", "editor", "io", "document", "player", "writ", "wr", "child", "index", "worker", "string", "rw", "handler", "element", "ee", "write", "wrapper", "winner", "parser", "iter", "creator", "Reader", "maker", "row", "r", "er", "her", "engine", "report", "dc"], "b": ["p", "ab", "buffer", "bar", "br", "abc", "c", "f", "bb", "fb", "ba", "w", "e", "pb", "l", "k", "B", "m", "object", "binary", "lb", "be", "g", "a", "base", "u", "null", "rb", "db", "h", "eb", "emb", "r", "ob", "boot", "bin", "orb", "d", "bd"], "outputStream": [" outputView", "OutputStream", "outstream", "protectedSteam", "OutputStreamer", "OutputSteam", "Outputstream", "OutputView", "outputStreamer", " outputSteam", "inputstream", "protectedStream", "protectedStreamer", "protectedstream", "dataStream", "dataStreamer", "outputContainer", " outputStreamer", "outStreamer", "inputStreamer", "inputView", "outputstream", "outSteam", "inputSteam", " outputContainer", "dataSteam", "outStream", " outputstream", "outputView", "inputContainer", "outputSteam", "dataContainer"], "injectedClasses": ["injectedWrites", "injectedClassies", "injectionClasses", "injectedClassites", "injectedclassies", "injectionclassites", "injectedWrits", "injectionClassies", "injectedProjectes", "injectionclasss", "injectedclassites", "injectedclasses", "injectionclassies", "injectedWritites", "injectionClassites", "injectedProjectites", "injectionclasses", "injectedProjecties", "injectedWrities", "injectedProjects", "injectionClasss", "injectedclasss", "injectedClasss"], "newSize": ["NewStorage", "finalSize", "NewSize", " newLength", "newStorage", "newFontSize", "finalStorage", " newFontSize", "finalFontSize", "finalLength", " newStorage", "newLength", "NewFontSize", "NewLength"]}}
{"id1": "13852596", "id2": "884867", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"execute": ["call", "create", "copy", "parse", "ute", "invoke", "load", "all", "process", "install", "evaluate", "server", "code", "exec", "transfer", "report", " invoke", " perform", "Exec", "submit", "test", "register", "apply", "start", "handle", "run"], "resources": ["relations", "workers", "types", "rules", "chains", "apps", "locks", "writers", "groups", "issues", "services", "projects", "strings", "resource", "cells", "flows", "archives", "works", "rings", "objects", "series", "thumbnails", "params", "files", "stores", "reports", "features", "models", "pages", "scripts", "plugins", "users", "rates", "results", "Resources", "items", "maps", "classes", "ions", "events", "ids", "stars", "images", "roots"], "i": ["p", "ani", "uri", "ai", "f", "gi", "ii", "info", "ori", "s", "e", "vi", "ie", "l", "I", "k", "wei", "ci", "abi", "ini", "we", "ami", "ir", "multi", "ip", "iu", "bi", "io", "si", "ti", "u", "is", "ui", "pi", "oi", "isi", "j", "li", "iri", "h", "hi", "di", "qi", "eni", "xi", "cli", "mu", "o", "id", "v", "esi", "ri", "ic", "phi"], "classFile": ["classFILE", "ruleLine", "staticfile", "classEntry", "CLASSFile", "connectionFile", "sessionFILE", "ClassGlobal", "customEntry", "sessionFile", "classClass", "Classfile", "filefile", "lassFiles", " classFILE", " classPage", "baseFile", "lassClass", "lassGlobal", "fileFiles", "finalFILE", "serviceLine", "CLASSEntry", "classGlobal", "staticFILE", "packEntry", "fileLoader", "CLASSFILE", "connectionfile", "ClassFactory", "ClassPage", "ClassImage", "sessionfile", " classEntry", "finalfile", "CLASSLoader", " classLoader", "ClassFiles", "baseUrl", "classLoader", "ClassClass", "customFILE", "classfile", "ClassFilename", "servicefile", "staticLine", "classesPath", "objectFiles", "ClassEntry", "objectfile", " classFiles", "classFactory", " classLine", "finalUrl", "ClassDir", " classGlobal", "classImage", "fileImage", "packFile", "classFiles", "ruleFile", "classPage", "classUrl", "ClassStream", "classesFile", "packFILE", "fileFile", " classFactory", " classStream", "classesFiles", "finalFile", "classStream", "CLASSLine", "classesfile", "classDirectory", "classPath", "classDir", " classFilename", "sessionEntry", " classClass", "CLASSDirectory", "connectionFiles", "baseFILE", "ruleFiles", "customFiles", " classDir", "ruleFilename", "CLASSfile", "ClassFile", "packfile", "serviceFile", "customFile", "classFilename", "CLASSImage", "ClassPath", "ClassLine", "fileDirectory", "basefile", "ClassDirectory", "fileLine", "staticFile", "sessionFactory", "CLASSUrl", "CLASSPage", "CLASSFiles", "objectDir", "classLine", "lassFile", "connectionStream", "objectFile", "sessionFiles", " classPath", " classfile", "serviceFILE", "ClassFILE"], "inputStream": ["InputFile", "initSteam", "InputStreamer", "uploadstream", "binaryFile", "importSteam", "inputContext", "outputStreamer", " inputstream", "rawFile", "inputFile", "importStream", "childstream", "inputSw", "childContext", "activeSteam", "outputContext", "binaryStream", "activeStream", "outputReader", "childStream", "uploadStream", "Inputstream", "rawStream", "activeStreamer", "rawSteam", "initStreamer", "inputReader", "inputstream", "InputStream", "outputSw", "InputSw", "importStreamer", "uploadSw", " inputFile", "InputSteam", "binaryStreamer", "inputStreamer", " inputStreamer", " inputSteam", "outputstream", "inputSteam", "rawStreamer", "childReader", "outputFile", "uploadFile", "importstream", "activestream", " inputContext", "initStream", "outputSteam", "initstream", " inputReader", "binarySteam"], "reader": ["source", "arser", "rx", "buffer", "copy", "writers", "re", "client", "reading", "sync", "inner", "author", "system", "rr", "seed", "driver", "ler", "per", "rar", "input", "owner", "manager", "war", "draft", "shared", "or", "read", "riter", "loader", "ner", "oder", "resource", "builder", "director", "ger", "Writer", "io", "editor", "reflect", "rer", "server", "book", "dr", "rc", "worker", "handler", "stream", "ee", "layer", "wrapper", "parser", "Reader", "iter", "request", "row", "key", "er", "entry", "keeper", "right", "ri", "report", "context", "http"], "oldSize": ["OldName", "oldName", "OldSc", " oldSc", "oldLength", "prevSize", "prevLength", "prevSc", " oldName", "prevName", "OldSize", " oldLength", "OldLength", "oldSc"], "writer": ["wer", "buffer", "writers", "token", "widget", "wire", "inner", "author", "written", "w", "driver", "ler", "writing", "word", "e", "war", "manager", "draft", "read", "riter", "data", "ner", "loader", "service", "resource", "builder", "format", "director", "object", "Writer", "oder", "walker", "editor", "io", "document", "player", "writ", "wr", "child", "index", "worker", "string", "rw", "handler", "element", "ee", "write", "wrapper", "winner", "parser", "iter", "creator", "Reader", "maker", "row", "r", "er", "her", "engine", "report", "dc"], "b": ["p", "ab", "buffer", "bar", "br", "abc", "c", "f", "bb", "fb", "ba", "w", "e", "pb", "l", "k", "B", "m", "object", "binary", "lb", "be", "g", "a", "base", "u", "null", "rb", "db", "h", "eb", "emb", "r", "ob", "boot", "bin", "orb", "d", "bd"], "outputStream": [" outputView", "OutputStream", "outstream", "protectedSteam", "OutputStreamer", "OutputSteam", "Outputstream", "OutputView", "outputStreamer", " outputSteam", "inputstream", "protectedStream", "protectedStreamer", "protectedstream", "dataStream", "dataStreamer", "outputContainer", " outputStreamer", "outStreamer", "inputStreamer", "inputView", "outputstream", "outSteam", "inputSteam", " outputContainer", "dataSteam", "outStream", " outputstream", "outputView", "inputContainer", "outputSteam", "dataContainer"], "injectedClasses": ["injectedWrites", "injectedClassies", "injectionClasses", "injectedClassites", "injectedclassies", "injectionclassites", "injectedWrits", "injectionClassies", "injectedProjectes", "injectionclasss", "injectedclassites", "injectedclasses", "injectionclassies", "injectedWritites", "injectionClassites", "injectedProjectites", "injectionclasses", "injectedProjecties", "injectedWrities", "injectedProjects", "injectionClasss", "injectedclasss", "injectedClasss"], "newSize": ["NewStorage", "finalSize", "NewSize", " newLength", "newStorage", "newFontSize", "finalStorage", " newFontSize", "finalFontSize", "finalLength", " newStorage", "newLength", "NewFontSize", "NewLength"]}}
{"id1": "18793482", "id2": "22366505", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyapplicationMsg", "modifyApplicationContent", "modifyApplicationMsg", "modifyExternalContent", "modifiedapplicationContent", "modifiedapplicationMsg", "modifyApplicationmessage", "modifyExternalMsg", "modifyapplicationMessage", "modifyExternalmessage", "modifyExternalMessage", "modifyapplicationmessage", "modifiedApplicationmessage", "modifiedapplicationmessage", "modifyAppContent", "modifiedApplicationMessage", "modifiedApplicationMsg", "modifyAppMsg", "modifyAppmessage", "modifyAppMessage", "modifiedApplicationContent", "modifiedapplicationMessage", "modifyapplicationContent"], "locale": ["placeame", "locationALE", "placeale", "localame", "localale", "Locame", " locales", "LocALE", "locue", "localALE", "localator", "localales", "Locales", "Locue", "locationue", "locALE", "locame", "Locator", " locame", "locales", "Locale", "locationale", "placeALE", "locator", "locationales", "localue", "placeales", " locator"], "messageName": ["MessageKey", " messageKey", "messageType", "reasonValue", " messageType", "MessageValue", "phraseName", "MessageType", "messagename", " messagename", "Messagename", "reasonName", "msgValue", "msgName", "msgType", "reasonname", "phraseValue", "reasonType", "MessageName", "phraseType", "phraseKey", "msgKey", "messageKey"], "messageValue": ["messageVal", "messageType", " messageType", "MessageValue", "MessageType", " messageVal", "responseVal", "responseName", "msgValue", "responseType", "MessageVal", "msgName", "msgType", "msgVal", "MessageName", "responseValue"], "properties": ["property", "ps", "prop", "perties", "json", "py", "ips", "config", "txt", "options", "pb", "resources", "data", "metadata", " Properties", "Property", "tmp", "params", "obj", "conf", "api", "stats", " props", "settings", "Pro", "pro", "xml", "ops"], "i18nPath": ["i18nPart", "i18onUrl", "i11fUrl", "i18nFile", "i16nPath", "i32nPath", "i32ninPath", "i18npath", "i16nspath", "i16nStr", "i18ninLocation", "i18nUrl", "i18ninFile", "i11fPath", "i32ninLocation", "i11nUrl", "i18onFile", "i18fCorp", "i16nsPath", "i18naStr", "i18nLocation", "i18nsPath", "i32nFile", "i18ninUrl", "i18fUrl", "i18naPart", "i16nsPart", "i18nsFile", "i16npath", "i18fpath", "i18onPath", "i18nsPart", "i32ninUrl", "i18neUrl", "i11nCorp", "i18bpath", "i32nLocation", "i32nUrl", "i18nepath", "i16nPart", "i18ninPath", "i18nsStr", "i11npath", "i18bPath", "i18nspath", "i18nsLocation", "i11fpath", "i11nPath", "i16nsStr", "i18nePath", "i18napath", "i18nsCorp", "i18onLocation", "i32ninFile", "i18bStr", "i18naPath", "i18nStr", "i18fPath", "i11fCorp", "i18nsUrl", "i18bPart", "i18neCorp", "i18nCorp"], "englishFile": ["englishPath", "examplePath", "Englishfile", "EnglishFiles", "ianaJar", "propertiesPath", "englishFiles", " englishFiles", "exampleFile", "englishDir", "ianaPath", " englishJar", "ianaDir", "languageFile", "propertiesFolder", "EnglishFile", "propertiesfile", " englishDir", "EnglishFolder", " englishfile", "languageDir", "englishFolder", "languageFiles", "EnglishPath", " englishPath", "examplefile", "languagePath", "languagefile", "ianaFile", "propertiesFile", "exampleFolder", "englishJar", "languageJar", "englishfile"], "propertiesFilePath": ["pertiesFilepath", "propertiesfilePath", "pertiesfileURL", "propertiesFilepath", "propertiesFilespath", "pertiesFilePath", "propertiesfilepath", "propertiesSourceFileURL", "pertiesDirName", "propertiesDirName", "propertiesDirUrl", "pertiesFileName", "pertiesfilepath", "propertiesFileURL", "pertiesFileUrl", "propertiesfileUrl", "propertiesSourceFileName", "propertiesSourceFilepath", "propertiesfileName", "pertiesDirPath", "pertiesDirUrl", "pertiesfileName", "propertiesFileUrl", "propertiesDirPath", "propertiesFilesUrl", "propertiesFileName", "propertiesfileURL", "propertiesFilesURL", "pertiesDirpath", "propertiesFilesName", "propertiesFilesPath", "propertiesSourceFilePath", "pertiesFileURL", "pertiesfilePath", "propertiesDirpath"], "file": ["text", "source", "message", "buffer", "property", "File", "ile", "directory", "url", "base", "name", "log", "pe", "zip", "stream", "http", "application", "model", "use", "show", "one", "word", "or", "data", "module", "object", "binary", "play", "force", "up", "files", "book", "entity", "future", "unit", "parent", "media", "path", "language", "field", "socket", "single", "folder", "resource", "format", "FILE", "b", "die", "string", "h", "php", "reader", "content", "p", "filename", "fp", "f", "page", "l", "class", "it", "fe", "function", "letter", "child", "connection", "lock", "handler", "full", "part", "le"], "in": ["p", "init", "into", "inn", "gin", "pin", "inner", "f", "s", "plus", "i", "input", "l", "inside", "image", "sin", "or", "IN", "ic", "con", "ini", "win", "io", "n", "isin", "din", "b", "it", "nin", "ins", "cin", "lin", "In", "inc", "again", "rin", "kin", "r", "er", "login", "err", "reader", "bin", "ri", "d"], "out": ["p", "work", "output", "sync", "net", "inner", "f", "home", "s", "w", "ex", "i", "word", "one", "to", "socket", "OUT", "image", "by", "builder", "n", "io", "bin", "up", "and", "b", "ou", "outer", "ext", "exec", "string", "exp", "plain", "Out", "write", "full", "outs", "again", "lib", "part", "r", "err", "cli", "o", "end", "v", "inc", "error", "co"], "c": ["p", "x", "cy", "char", "xc", "uc", "dec", "cf", "ac", "f", "w", "i", "pointer", "l", "k", "ci", "con", "ce", "ice", "ec", "n", "a", "arc", "bc", "pc", "character", "b", "col", "lc", "C", "code", "cr", "cont", "sc", "ch", "rc", "cur", "h", "cc", "esc", "size", "enc", "cl", "cu", "t", "r", "ct", "o", "v", "d", "abc", "dc"], "is": ["as", "ris", "ps", "re", "IS", "str", "us", "isa", "info", "s", "its", "isu", "iss", "are", "i", "Is", "serv", "iso", "ib", "does", "ir", "si", "os", "it", "ui", "res", "api", "ins", "stream", "ais", "ios", "iter", "es", "id", "bis", "get", "has", "ri"], "breader": ["breaders", "feedamer", "breadr", "brewer", "webamer", " BreadER", "weber", " Breader", " Breaders", "webiter", "feediter", "feeder", " cakeers", " cakeER", " cakeler", " breadler", "webr", "brewamer", "breaditer", " cakeer", "feedr", "breadamer", " Breadler", "breadER", " breaders", " breadER", "brewr", "brewiter", "breadler"], "line": ["text", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "lined", "sync", "cell", "lo", "frame", "day", "model", "page", "pass", "link", "phrase", "one", "word", "l", "item", "inline", "data", "definition", "nl", "strip", "comment", "ip", "next", "url", "base", "name", "log", "character", "lc", "band", "code", "split", "letter", "sl", "body", "li", "side", "string", "header", "rule", "LINE", "el", "lin", "write", "plugin", "block", "value", "part", "row", "key", "response", "feed", "entry", "end", "le", "liner", "section", "error", "status", "no"], "strBuilder": ["brbuilder", "brBuilder", "brBuild", "brBlock", "StrBuilder", "stringBuild", "brBuilding", "stringBuffer", " strBuilding", "strBuild", "brBuffer", "strBuilding", "StrBuilding", "StrBlock", " strBlock", "strBuffer", "StrBuffer", "stringBuilder", " strBuffer", " strBuild", "strBlock", "stringbuilder", "stringBuilding", "Strbuilder", " strbuilder", "strbuilder", "StrBuild"], "pieces": ["parts", "nets", "apps", "words", "lines", "bits", "forms", "marks", "bones", "lists", "keys", "ips", "styles", "bytes", "pots", "seconds", "groups", "services", "vals", "cards", "tips", "names", "strings", "cells", "flows", "values", "rings", "letters", "sections", "pins", "objects", "boxes", "files", "split", "cuts", "features", "steps", "pages", "places", "packs", "planes", "tops", "items", "blocks", "circle", "piece", "phones", "ops"], "found": ["created", "normal", "result", "Found", "identified", "loaded", "first", "successful", "f", "all", "not", "filled", "built", "lost", "printed", "l", "given", "still", "count", "successfully", "val", "defined", "updated", "left", "got", "required", "fixed", "missing", "old", "find", "matched", "valid", "expected", "null", "search", "sent", "fl", "letter", "true", "confirmed", "based", "full", "used", "failed", "fall", "temp", "made", "finding", "err", "broken", "changed", " Found"]}}
{"id1": "15737836", "id2": "2676365", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["del", "create", "sync", "update", "de", "drop", "process", "close", "release", "where", " update", "Delete", "connect", "execute", "exec", "destroy", " destroy", " Delete", "write", "sql", "replace", "save", " create", "remove", "id", "get", "select", "clear"], "site": ["source", "course", "remote", "result", "cache", "set", "sync", "se", "license", "session", "sites", "config", "environment", "ite", "model", "page", "domain", "isite", "note", "conn", "project", "line", "image", "item", " Site", "blog", "data", "install", "module", "object", "location", "node", "class", "si", "base", "name", "database", "edge", "null", "server", "sit", "theme", "db", "target", "profile", "plugin", "sql", "sample", "space", "Site", "unit", "type", "zone", "section", "xml", "network", "status"], "dbo": ["rdBo", " dBo", "rdbc", "drbc", "Dbo", "jBO", "dBO", "pba", "dBo", "pBo", "rdbo", "idebo", " dbi", "pbo", "idebl", "gBO", "pBO", "idbo", " dbos", "Dho", "fBo", "jba", "fbo", "ideho", " dBO", "idho", "gBo", "gbo", "gbos", "jbo", "ideBo", "rdbi", "drbo", " dbc", "DBO", "dbl", "Dba", "drBo", "dbos", "idBo", "jBo", "idbl", "fBO", " dba", "Dbl", "dba", "Dbos", "dho", "drbi", "fba", "dbi", "DBo", "dbc"], "connection": ["relation", "management", "result", "position", "cache", "table", "client", "connected", "session", "translation", "c", "union", "config", "instance", "environment", "Connection", "use", "component", "driver", "manager", "conn", "image", "ci", "condition", "loc", "con", "resource", "builder", "node", "communication", "statement", "directory", "io", "connect", "document", "database", "bc", "subject", "character", "graph", "log", "server", "pool", "function", "query", "index", "container", "machine", "channel", "lock", "handler", "engine", "sql", "reference", "creator", "collection", "ongo", "response", "unit", "ctx", "ion", "section", "db", "library", "context", "application"], "preparedStatement": ["prehedStatement", "prepperDocument", "PreparedParent", "prearedDatabase", "preparableStatement", "PrearedStatement", "prearedHeader", "prearedStat", "eculatedStatement", "psefixedStatement", "preciseStatement", "preppedStatement", "eparedTransaction", "caparedStatement", "preculatedTransaction", "preamedStatement", "previousConnection", "preutedQuery", "previousTransaction", "preachedStatement", "preciseParent", "PrearedStat", "psefixedComment", "previousComment", "proparableStatement", "proparableStat", "calyingStatement", "preplacedStat", "preparedInstance", "PrearedString", "prearedScope", "PreparedTransaction", "PreparedComment", "eparedstatement", "prepperTransaction", "eculatedstatement", "preparedScope", "pseparedComment", "prequalifiedStatement", "partvisedStatement", "prequalifiedStat", "preutedOperation", "preachedString", "proparedStatement", "preformedTransaction", "preachedDatabase", "prefixedStatement", "preferredQuery", "partvisedComment", "preparedDatabase", "preamedParent", "preplacedComment", "preparedService", "preparedConnection", "preppedQuery", "preutedStatement", "previsedStatement", "prehedComment", "preamedString", "preferredStatement", "preciseString", "partparedStatement", "prelyingStatement", "calyingTransaction", "preparedParent", "PrearedComment", "PreppedStatement", "eparedStatement", "previousDocument", "PrearedService", "preculatedStatement", "PreparedService", "calyingComment", "preformedService", "PreppedConnection", "PreppedTransaction", "preparedStat", "prehedScope", "PreppedDocument", "PreparedConnection", "PreparedHeader", "caparedTransaction", "preformedString", "prehedQuery", "prefixedOperation", "prearedComment", "PreparedOperation", "preamedStat", "PreparedString", "prequalifiedInstance", "calyingstatement", "prearedQuery", "proparableInstance", "proparablestatement", "eparedConfiguration", "psefixedQuery", "pseparedStatement", "preparedComment", "preformedConfiguration", "preparedstatement", "PreparedStatement", "preparedHeader", "preparedOperation", "partvisedQuery", "preculatedConfiguration", "prepperConnection", "preutedHeader", "preciseStat", "preformedstatement", "PreparedStat", "preplacedStatement", "caparedstatement", "PrearedParent", "proparedStat", "preformedDatabase", "preparedQuery", "preculatedstatement", "previsedComment", "prearedInstance", "preppedString", "partparedQuery", "eculatedConfiguration", "preppedConnection", "proparedstatement", "preparableStat", "preppedTransaction", "preplacedQuery", "preppedComment", "PreparedQuery", "PrearedDatabase", "previousstatement", "PrearedHeader", "PrearedOperation", "prearedService", "prefixedHeader", "pseparedQuery", "pseparedScope", "prepperStatement", "prearedTransaction", "prearedstatement", "prearedString", "caparedComment", "preppedDocument", "partparedComment", "prequalifiedstatement", "eculatedTransaction", "proparedInstance", "preferredComment", "PrearedQuery", "prefixedComment", "partparedStat", "PreparedDocument", "prelyingComment", "prefixedQuery", "PreparedDatabase", "prearedOperation", "preformedStatement", "prearedConfiguration", "psefixedScope", "previsedQuery", "preachedService", "prelyingTransaction", "preparedTransaction", "prearedParent", "preparableInstance", "previsedStat", "preparedString", "preparedConfiguration", "previousStatement", "prelyingstatement", "prearedStatement", "partvisedStat", "preparedDocument", "preferredString", "prefixedScope", "preparablestatement"], "resultSet": ["responseList", "responseLine", "resultsLine", " resultSize", "ResultSize", "ResultSource", "responseSet", " resultList", "resultGet", "rowSet", "resultSize", "ResultLine", "ResultGet", "ResultSet", "responseSource", " resultGet", "resultList", "rowSize", "resultSource", "resultsList", "resultsSource", "ResultList", " resultSource", "resultsSet", "rowSource", "resultLine", "rowGet", " resultLine"], "chkSql": ["chksSql", "chkRsq", "chkSQL", "chkSsql", "chkPresq", "chkOssl", "chkPssl", "chKSq", "chkPssql", "chkPresQL", "chkOsq", "chksAsql", "chksAssql", "chksSq", "chKRssl", "chkAssql", "chkPresql", "chksAsq", "chkPsql", "chkOsQL", "chKSsl", "chKRsql", "chkOsql", "chksAsQL", "chksSsql", "chkPressql", "chKRsq", "chkRsql", "chksSQL", "chKSsql", "chkRssql", "chkSsl", "chkRssl", "chkSq", "chKRssql", "chkAsq", "chkAsQL", "chkOssql", "chkAsql", "chkPsq", "chKSql"], "selfDefinePath": ["selfDefinedKey", "selfDefinepath", "selfDefiningpath", "selfDefinedPath", "selfDefenPath", "selfDefineName", "selfDeclineKey", "selfDefiningPath", "selfDefineKey", "selfDefineUrl", "selfDefinesUrl", "selfDeclinedPath", "selfDefenLocation", "selfDefiningKey", "selfDefinesLocation", "selfDeclinedpath", "selfDefinedUrl", "selfDefineLocation", "selfDeclinepath", "selfDefenName", "selfDefinedLocation", "selfDefiningUrl", "selfDefinesKey", "selfDeclinedKey", "selfDefinespath", "selfDeclineUrl", "selfDeclinedUrl", "selfDefinedpath", "selfDefinesPath", "selfDefinedName", "selfDeclinePath", "selfDefinesName", "selfDefenpath"], "sqlStr": ["sqlBr", "querystr", "sqlText", "queryDec", "sqlWr", "SQLString", "SQLStr", " sqlDec", "queryStr", " sqlString", "qlString", "SQLWr", "SQLDec", "sqlDec", "SQLBr", "sqlstr", " sqlstr", " sqlWr", "SQLText", "sqlString", "queryText", "qlStr", "qlWr", " sqlText", "SQLstr", "qlBr", " sqlBr"]}}
{"id1": "6457199", "id2": "11673907", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doRequest": ["DoProxy", "DoResponse", "runRequest", "doResponse", "runProxy", "DoRequest", " doCall", "doProxy", "runCall", "doCall", " doResponse", "runResponse", " doProxy", "DoCall"], "request": ["method", "message", "call", "result", "buffer", "re", "uri", "json", "client", "session", "hello", "instance", "event", "view", "xml", "complete", "application", "req", "object", "url", "name", "server", "query", "string", "queue", "reference", "route", "reader", "user", "right", "error", "Request", "report", "context", "http"], "response": ["message", "result", "re", "output", "json", "out", "client", "model", "page", "view", "http", " Response", "success", "application", "resp", "writer", "service", "object", "document", "server", "Response", "host", "api", "body", "index", "onse", "connection", "respond", "respons", "reference", "parent", "route", "more", "results", "feed", "site", "template", "v", "error", "report", "status", "reply"], "path": ["p", "text", "source", "work", "method", "message", "uri", "token", "port", "Path", "inner", "alias", "info", "content", "PATH", "ath", "pointer", "image", "data", "left", "object", "location", "self", "url", "base", "name", "arc", "host", "code", "relative", "ith", "child", "api", "index", "string", "patch", "prefix", "full", "anc", "route", "partial", "key", "template", "part", "id", "end", "walk", "type", "right", "dir", "slice", "pattern", "context", "http"], "internal": ["primary", "local", "attr", "source", "x", "Internal", "normal", "remote", "rx", "re", "uri", "absolute", "international", "inner", "actual", "alias", "system", "ident", "inside", "single", "shared", "inline", "background", "binary", "personal", "storage", "original", "url", "base", "intern", "name", "initial", "relative", "central", "standard", "api", "special", "rc", "string", "external", "origin", "prefix", "regular", "impl", "exclusive", "route", "custom", "foreign", "join", "parent", "outside", "context", "http"], "resource": ["source", "relation", "result", "buffer", "media", "re", "uri", "client", "this", "rera", "use", "real", "pointer", "ource", "manager", "rest", "src", "image", "resources", "record", "sr", "url", "base", "server", "Resource", "address", "res", "api", "rc", "string", "external", "rule", "connection", "stream", "range", "ruby", "reference", "resolution", "file", "route", "r", "context", "http"], "mimeType": ["monseTypes", "milePath", "mimesInfo", "mpePath", "smIMEInfo", "mimesType", "mIMEInfo", "smimeType", "smimeInfo", " mileInfo", "modInfo", "pimeType", "pipTypes", "mimeName", "maxType", "manceTypes", "mancetype", " mileType", "mimePath", "mimeInfo", "mileInfo", "monseType", "mileTypes", "mimetype", "smimeName", "pipPath", "pimePath", "mIMEName", "modName", "mipPath", " mimeTypes", "pipType", "mIMEtype", "mpeInfo", "modType", " mileTypes", "manceType", "mipTypes", "monsePath", "miptype", "mpeTypes", "maxName", "mpeType", "pimeTypes", "smIMEName", "maxInfo", "mimesTypes", "pimetype", "maxtype", " milePath", "mimesPath", "smIMEtype", "piptype", "mimeTypes", "mancePath", "smIMEType", " mimePath", "modtype", "mileType", " mimeInfo", "mipType", "smimetype", "mIMEType", "monsetype"], "is": ["as", "ris", "ps", "uri", "IS", "im", "was", "us", "isa", "info", "its", "ori", "sis", "are", "iss", "i", "Is", "serv", "or", "iso", "in", "lis", "ir", "vs", "ras", "ip", "isc", "ui", "fs", "api", "isi", "res", "ais", "ios", "iris", "nis", "bis", "ri", "ops", "ois", "http"], "os": ["OS", "as", "cs", "dos", "ps", "so", "ols", "oss", "us", "bos", "oes", "s", "ori", "acs", "iso", "ose", "vs", "nos", "io", "opens", "ros", "cos", "oS", "los", "ies", "bs", "res", "ais", "ios", "aos", "outs", "ows", "Os", "o", "osi", "oses", "ops"]}}
{"id1": "16673769", "id2": "2398448", "code1": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"Start": ["Stop", "create", "init", "Test", " stop", "Run", " Startup", "process", "Begin", "Do", "Load", "End", "Boot", " Run", "stop", "Init", "ize", "Process", "Main", "Service", "register", "end", "Exception", "Starting", "get", "start", " start", "run"], "resources": ["relations", "types", "rules", "lines", "styles", "bytes", "groups", "ids", "ources", "services", "issues", "projects", "errors", "parents", "resource", "opens", "archives", "works", "objects", "thumbnails", "files", "features", "reports", "stores", "states", "models", "rows", "pages", "uploads", "fires", "vers", "settings", "plugins", "users", "includes", "results", "Resources", "maps", "classes", "ions", "events", "packages", "stars", "roots", "http"], "url": ["ls", "source", "text", "filename", "buffer", "gl", "uri", "json", "str", " URL", "path", "Url", "download", "config", "f", "page", "l", "socket", "image", "loc", "data", "service", "resource", "location", "email", "io", "base", "name", "server", "host", "URL", "rl", "sl", "api", "address", "string", "connection", "channel", "stream", "element", "layer", "lr", "ll", "coll", "ul", "html", "file", "mount", "route", "r", "href", "ssl", "feed", "response", "key", "xml", "http"], "configFileContents": ["configContentContents", "configFileIncludes", "jsonFileContent", "configContentIncludes", "jsonFileValues", "configfileLocation", "jsonfileContents", "configFileParameters", "logFileLocation", "configfileIncludes", "configResourceIncludes", "configContentParameters", "jsonFileTextures", "configContentContent", "jsonfileStream", "configFileContent", "configfileStream", "configFILEContent", "configDirectoryTextures", "configUrlParameters", "jsonfileContent", "configFileValues", "configfileTextures", "configDirectoryContent", "jsonFileStream", "logfileParameters", "logfileContent", "configFileLocation", "configFileTextures", "configUrlContents", "configfileContents", "logFileContent", "logfileContents", "jsonfileIncludes", "logfileLocation", "logFileParameters", "configFILEContents", "configUrlContent", "jsonfileValues", "configDirectoryContents", "configResourceContents", "logFileContents", "configfileValues", "configfileContent", "jsonfileTextures", "configContentLocation", "configResourceContent", "configDirectoryStream", "jsonFileContents", "configFileStream", "configContentValues", "configfileParameters", "configUrlLocation", "configResourceValues", "configFILEStream", "configFILETextures", "jsonFileIncludes"], "configurable": ["configure", "Configure", "structuration", "Configuration", "structural", "configuring", " configure", "confuring", "Configurer", "Configur", "structur", "figur", "structurable", "figurable", "configur", "confural", "confur", "configuration", "confuration", " configurer", "configural", "configurer", "Configuring", "confurer", "figural", "confure", "structure", "structuring", "Configurable", "Configural", "confurable", " configur", "structurer", " configuration", "figurer", " configural"], "jsonData": ["ajInfo", "JSONArray", " jsonParser", "xmlDATA", "jsArray", " jsonReader", "JSONData", "JSONDATA", "jsonVar", "sonDiv", "jsonParser", " jsonVar", "sslValue", "xmlCode", " jsonDiv", " jsonCode", "sonData", "JSONValue", "journalDiv", "sonDATA", "jsonDiv", "jsonDATA", "jsString", "JSONInfo", "sonParser", "jsonValue", "jsonArray", " jsonDATA", "ajDat", "JSONDat", "rssData", "sslInfo", "xmlData", "jsonCode", "journalData", "xmlReader", "xmlInfo", "xmlString", "sslData", "sonCode", "jsDATA", "rssDATA", "sslDat", "jsonDat", "jsonString", "JSONReader", "jsonReader", "JSONCode", "jsonInfo", "rssParser", "rssVar", "ajValue", "JSONString", " jsonInfo", "xmlArray", "sonVar", "ajData", "journalCode", "jsData"]}}
{"id1": "9096314", "id2": "693636", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "label": 1, "substitutes": {"handleNodeLostService": ["handleNodeErrorServices", "handleNodeUnknownServices", "handlenodelostService", "handleNodeLostServices", "handlenodelostServer", "handlenodeLostService", "handleNodeLostFunction", "handlenodelostFunction", "handleNodeErrorService", "handlenodeLostFunction", "handleNodelostFunction", "handleNodeUnknownServer", "handleNodeUnknownFunction", "handlenodeLostServer", "handlenodelostServices", "handleNodelostServer", "handleNodeLostServer", "handleNodelostServices", "handleNodelostService", "handleNodeUnknownService", "handleNodeErrorFunction", "handlenodeLostServices", "handleNodeErrorServer"], "eventID": [" eventName", "documentId", "sessionId", "nodeType", "resourceName", "resourceId", "serviceId", "EventID", "documentName", "nodeName", "resourceID", "EventId", " eventType", "resourceid", "serviceName", " eventId", " eventid", "eventName", "documentID", "nodeid", "sessionID", "sessionName", "eventType", "EventType", "eventid", "eventId", "EventName", "nodeId"], "nodeID": ["networkInfo", "nodeURL", "networkId", "networkID", "resourceName", "nodeInfo", "resourceId", " nodeid", "serviceId", "NodeId", "nodeName", "resourceID", "eventInfo", "objectId", "serviceName", "objectid", "resourceid", "NodeURL", "eventName", " nodeId", " nodeInfo", "nodeid", "objectID", " nodeURL", "Nodeid", " nodeName", "eventid", "objectName", "eventURL", "nodeId", "serviceid", "eventId", "NodeID"], "ipAddr": [" ipAddri", "apiAddp", "epaddr", "ipAttri", "apiAttr", "ipAttress", " ipAtto", "ipaddo", "ipaddri", "epAddl", "apiAttp", " ipAddo", "ipAddri", "ipAttr", " ipAdder", "ipaddl", "ipAddresser", "ipChrer", " ipChrs", "ipAddresso", "ipAttrs", "ipChrs", "ipAddressrs", "ipaddrs", "epaddrer", "ipAttrer", " ipAddrer", "ipAddp", " ipAddress", "ipAddressrer", "ipAddressl", "ipChl", "ipAddrs", "ipAtter", "ipAddo", "apiAttri", "apiAddr", "ipChri", "ipAddressp", "ipaddr", "ipaddrer", "ipAddl", " ipAttrs", "epAddrs", "ipAddressri", "epaddrs", " ipAtter", "ipAddress", " ipChrer", "ipAtto", "ipChp", "ipAddrer", "ipaddress", " ipChr", " ipAttr", "ipAddressr", " ipAddrs", " ipChri", "epAddr", "ipAttp", "ipadder", "epAddrer", "epaddl", "ipAdder", "apiAttrs", "apiAddrs", "apiAddri", "ipChr"], "serviceID": ["serviceIDs", "imageID", "imageUID", "serviceUID", "networkId", "networkID", "featureId", "ServiceType", "ServiceID", "serviceId", "ServiceIP", "roleID", "eventIP", "ServiceId", " serviceid", "networkName", " serviceId", "featureID", "serviceName", " serviceIDs", " serviceIP", "siteIP", "eventName", " serviceUID", "siteid", "roleIP", "featureUID", "roleid", "imageId", " serviceType", "networkid", " serviceName", "ServiceName", "ServiceIDs", "eventIDs", "serviceIP", "eventType", "eventid", "siteId", "roleId", "serviceid", "siteID", "eventId", "serviceType"], "eventTime": ["eventName", "EventTime", " eventName", "serverInfo", "serverName", "servertime", "eventInfo", "EventName", " eventInfo", "eventtime", "serverTime", " eventtime", "EventInfo", "Eventtime"], "log": ["cache", "config", "event", "w", "proxy", "url", "base", "pe", "pool", "write", "crit", "key", "feed", "entry", "type", "error", "http", "tool", "info", "reg", "model", "use", "level", "or", "writer", "LOG", "job", "low", "thread", "user", "db", "og", "call", "output", "path", "lo", "plug", "lex", "Log", "pl", "pg", "ger", "sec", "gen", "stat", "tag", "exp", "en", "put", "loop", "debug", "contract", "get", "guard", "port", "net", "cell", "c", "cat", "f", "l", "blog", "where", "class", "it", "host", "ge", "stop", "lock", "cl", "full", "bug", "sign"], "dbConn": ["databaseDr", "webNC", "DBConn", "DbCtrl", " dbNC", " dbCo", "libConn", "DbColl", "dbCs", " dbconn", "libCon", "DbConn", "webCtrl", "databaseConnection", "DbConnection", "dbCon", "databaseConn", "sqlSession", "dbDr", "DbDr", " dbDr", " dbColl", "DBCs", "dbCo", "dbColl", "sqlconn", "libCt", "libconn", "dbConnection", "dbConnect", "dbSession", "dbCt", " dbConnect", "DbConnect", " dbCs", "DbCs", "logCtrl", " dbCt", "Dbconn", " dbConnection", "webConn", "logConn", "dbNC", "sqlCtrl", "DbSession", " dbSession", "dbCtrl", "databaseconn", "DbCt", "sqlConn", "DbCo", "DBConnect", "sqlNC", "logConnect", "sqlCo", "DbCon", "dbconn", " dbCon", " dbCtrl", "DBCt", "logColl", "sqlCt", "webCt"], "getNextOutageIdStmt": ["getNextOutageIDStnt", "getNextOutageIDSmt", "getNextOutageIdStb", "getNextOutageIdstmt", "getNextOutageIdCb", "getNextOutageIdRMT", "getNextOutageIDSr", "getNextOutageIDSb", "getNextOutageIDStb", "getNextOutageIdSnt", "getNextOutageIdstr", "getNextOutageIdCr", "getNextOutageIdStr", "getNextOutageIdCmt", "getNextOutageIdSMT", "getNextOutageIdCnt", "getNextOutageIdSmt", "getNextOutageIdRb", "getNextOutageIdSb", "getNextOutageIdStnt", "getNextOutageIdstMT", "getNextOutageIdStMT", "getNextOutageIdRr", "getNextOutageIdstnt", "getNextOutageIdRmt", "getNextOutageIDStmt", "getNextOutageIDStMT", "getNextOutageIdSr", "getNextOutageIDSMT", "getNextOutageIDSnt", "getNextOutageIDStr", "getNextOutageIdCMT"], "outageID": ["outrageUID", "outageHandle", "outAGEId", "OutageSecret", "OutageHandle", "outagingName", "inageUID", "outissueUID", "outflowName", "outAGEID", "outflowId", "OutageID", "outissueId", "outrageHandle", "outageURL", "OutrageSecret", "outagingID", "OutrageName", "inageId", "inageID", "inrageURL", "outagingId", "OutageId", "OutrageID", "outrageSecret", "outflowHandle", "outagementId", "OutageName", "outrageId", "inrageUID", "outageName", "OutrageHandle", "outagementID", "outAGEUID", "inrageID", "outrageID", "outflowID", "outagementHandle", "outrageName", "outagingSecret", "outageUID", "outageId", "outissueURL", "inageURL", "outAGEName", "inrageId", "OutrageId", "outissueID", "outrageURL", "outAGEURL", "outagementName", "outAGESecret", "outageSecret"], "seqRS": [" seqMR", " seqRC", "reqTS", "structRs", "seqRs", "colRS", "eqRT", "eqRs", " seqTS", "sequRC", "structrs", "sequRL", "sequTS", "invSR", " sequenceMR", "sequencers", "eqRS", "reqRC", "seqRR", "eqRR", "sqRS", "reqRR", "reqRL", " seqRL", "seqTS", "sequenceRs", "sequenceRS", " sequenceRC", "seqRC", "sqRC", "seqSR", "reqRS", "colRR", "colRT", "invRS", "sequRS", "reqRT", "invRs", "sqRT", "reqRs", "seqRT", " sequenceRT", " sequenceRS", " seqRT", "sqMR", "structSR", "colRs", "seqMR", "seqrs", "sequenceSR", "invrs", "seqRL", "structRS"], "newOutageWriter": ["newInflowWriter", "newoutureRW", "newInflowRW", "newoutagewriter", "newOutissueWrite", "newExagewriter", "newOutlinewriter", "newOutageInfo", "newOutageWrite", "newOutartRW", "newOutagewriter", "newInageRW", "newExageReader", "newoutureWrite", "newOutflowWrite", "newoutureWriter", "newOutartInfo", "newOutpacewriter", "newOutpaceReader", "newOutagementWrit", "newOutpaceWriter", "newOutissueReader", "newoutageReader", "newoutureReader", "newExlinewriter", "newInageWriter", "newOutissueWriter", "newOuturewriter", "newOutpointRW", "newOutlineReader", "newOutpointReader", "newOutflowInfo", "newExlineWrite", "newExageWriter", "newoutageInfo", "newInageWrite", "newOutageWrit", "newOutagementWriter", "newOutureReader", "newOutrageWriter", "newOutageRW", "newOutflowWrit", "newInflowWrite", "newoutageRW", "newOutflowRW", "newOutureWrite", "newoutageWriter", "newOutflowReader", "newOutpointWriter", "newOutagementRW", "newOutlineWriter", "newOutartWrite", "newOutrageWrite", "newInageWrit", "newOutlineWrite", "newOutureRW", "newoutageWrite", "newInflowWrit", "newOutartWriter", "newExlineWriter", "newOutissuewriter", "newOutagementWrite", "newOutureWriter", "newouturewriter", "newOutpointWrite", "newOutageReader", "newOutpaceRW", "newExageWrite", "newOutureInfo", "newOutflowWriter", "newExlineReader", "newOutrageWrit", "newOutrageRW", "newOutflowwriter", "newoutureInfo"]}}
{"id1": "6906419", "id2": "9996334", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["enccryptPassword", "encryptpassword", "decipherpassword", "encipherpassword", "decryptpassword", "encipherPassword", "encratePassword", "encratepassword", "decipherPassword", "decryptHash", "decryptString", "enccryptString", "decipherHash", "enccryptHash", "encryptHash", "decipherString", "encrateHash", "encipherHash", "encrateString", "decryptPassword", "enccryptpassword", "encryptString", "encipherString"], "password": ["p", "text", "secret", " passwords", "message", "buffer", "words", "token", "path", "username", "wd", "pass", "seed", "phrase", "word", "input", "project", "padding", "data", "auth", "PASS", "database", "name", "array", "sword", "address", "string", "crypt", "prefix", "confirmed", "Password", "key", "user", "pattern", "content"], "digest": ["diffester", "digeter", "Digeter", "Digester", "Digests", "DigEST", "hasheter", " digeter", "diffest", "DigText", "hashest", "digEST", "diffested", "digested", "initest", " digests", "Diger", "initText", "hashester", "diffEST", "signEST", "digText", " digEST", "digests", "diger", "initests", "signester", " diger", "Digest", "signer", " digested", "Digested", "digester", "hasher", "initEST", " digester", "signest", " digText"], "hash": ["secret", "match", "message", "mask", "history", "char", "bh", "buffer", "hed", "ashes", "cache", "cover", "check", "ash", "memory", "f", "image", "count", "build", "kh", "map", "auth", "url", "log", "array", "search", "Hash", "code", "number", "query", "sha", "hex", "address", "index", "body", "h", "header", "sum", "batch", "sh", "filter", "ha", "html", "block", "value", "version", "bug", "key", "wave", "diff", "id", "bin", "error", "handle"], "buf": ["cv", "uv", "cmp", "bh", "buffer", "sb", "ab", "fp", "uf", "out", "uc", "port", "cb", "bag", "f", "bb", "fb", "buff", "pad", "ba", "home", "config", "uber", "vr", "pb", "va", "src", "func", "data", "box", "aux", "builder", "af", "bf", "cas", "img", "url", "bc", "tmp", "b", "conv", "runner", "fw", "nb", "Buffer", "append", "rb", "cur", "bu", "queue", "coll", "vec", "cap", "wb", "ob", "pkg", "Buff", "ctx", "v", "bin", "db", "abb", "la", "abc"], "i": ["p", "x", "uni", "init", "uri", "length", "c", "f", "ai", "gi", "ii", "info", "ix", "e", "d", "ie", "l", "I", "count", "ci", "abi", "ini", "multi", "ip", "n", "iu", "io", "a", "si", "u", "b", "it", "mini", "ui", "pi", "oi", "ji", "li", "index", "j", "h", "hi", "di", "qi", "xi", "fi", "key", "mu", "slice", "o", "id", "type", "v", "ri", "ti", "phi"], "halfbyte": ["postabyte", " halfurl", "halfByte", "littlebit", "sideByte", "Halfchar", " halfchar", "quarterbytes", "halfnumber", "thirdbyte", "wardurl", "halfreference", "superchar", "quarterabyte", " halfabyte", "quarterurl", "sidereference", "littleByte", "sidebit", "thirdsecond", "postbyte", "quarterbyte", "littlebyte", " halfsecond", " halfbit", "halfsecond", "quarterByte", "halfchar", "wardbyte", "postbit", "halfbytes", "halfbit", "superbit", "thirdnumber", "sidebyte", "quarternumber", "halfabyte", "Halfbyte", "superbyte", "halfurl", "quarterbit", "wardbytes", " halfnumber", "HalfByte", " halfByte", "quartersecond", "Halfbit", " halfreference", "littlereference", " halfbytes"], "two_halfs": ["two_commonows", "two_commonrows", "two_commonions", "two_halfrows", "two_thirdrows", "two_thirdis", "two_halfis", "two_commons", "two_quarterows", "two_Halfis", "two_hatrows", "two_quarterions", "two_partis", "two_Halfrows", "two_halfbytes", "two_halfows", "two_hatows", "two_thirdbytes", "two_thirds", "two_hats", "two_hations", "two_quarters", "two_Halfbytes", "two_Halfs", "two_parts", "two_partrows", "two_quarterrows", "two_halfions", "two_partbytes"]}}
{"id1": "255765", "id2": "18433984", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"f": ["p", "x", "form", "lf", "F", "flat", "filename", "ref", "of", "fp", "fun", "fx", "cf", "path", "c", "s", "this", "w", "e", "l", "ff", "m", "fm", "folder", "fen", "bf", "self", "io", "g", "n", "a", "fo", "inf", "name", "b", "fd", "fs", "fe", "function", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "file", "df", "t", "feed", "r", "sf", "fi", "fold", "v", "d"], "in": ["source", "init", "gin", "session", "config", "w", "image", "con", "isin", "ins", "In", "d", "rec", "inn", "token", "pin", "with", "or", "IN", "data", "ini", "win", "n", "g", "up", "nin", "thin", "lin", "t", "diff", "bin", "str", "input", "socket", "serv", "a", "b", "gen", "is", "login", "reader", "get", "inc", "din", "p", "inner", "c", "ac", "pass", "ex", "l", "m", "it", "vin", "exec", "fe", "min", "connection", "fa", "lock", "cin", "again", "rin", "part", "r", "err", "ssl", "v", "ic"], "cbuf": ["cfuc", "rbbuf", "bcul", "bbuf", "bbuff", "ebuff", "fbuf", "rbux", "fbbuf", "bburs", "bbull", "rbuff", "cbutf", "bcur", "cbault", "rbul", "bcux", "buff", "buf", "dbuc", "rbuc", "fbuc", "cbuc", "dbuff", "zbuu", "cbux", "zbuf", "bcuff", "rbault", "rbutf", "cbuff", "ebuf", "bcuf", "CBuc", "bcull", "bux", "bault", "CBuf", "fbuff", "bcurs", "CBul", "ebuu", "cfuf", "dbur", "zbuff", "cfuff", "dbuf", "cbur", "rbull", "cfbuf", "cbull", "cbul", "CBuff", "rbuu", "rbuf", "rburs", "cburs", "cbuu", "ebutf", "cfur", "bcuc", "zbutf", "cbbuf", "bcault"], "read": ["work", "text", "x", "buffer", "Read", "parse", "want", "config", "w", "k", "cel", "val", "build", "close", "name", "log", "add", "pe", "report", "reads", "ack", "size", "stream", "repeat", "write", "ak", "ok", "iter", "un", "y", "key", "feed", "type", "start", "error", "d", "run", "last", "sync", "check", "load", "use", "view", "level", "ed", "count", "data", "play", "io", "g", "allow", "rc", "raw", "used", "ing", "insert", "id", "select", "know", "call", " reading", "reading", "update", "lex", "READ", "input", "send", "skip", "socket", "sleep", "ind", "readable", "print", "valid", "bit", " write", "each", "ize", "only", "en", "orig", "wait", " READ", "loop", "put", "reader", "bind", "get", "inc", "fill", " Read", "ride", "seek", "create", "re", "se", "length", "pass", "q", "record", "open", "old", "find", "connect", "ink", "num", "it", "change", "child", "hex", "oct", "index", "full", "r", "er", "end", "draw"], "totRead": ["totoRead", "totReading", "tobyLoad", " totLink", "notLoad", "totiBuild", "octotoReading", "tazonLoad", "TotWrite", "totSearch", " totalBuild", "TotaWrite", "totalBuild", "ntotWrite", "intotRead", "nottRead", "intottLoad", "tottSearch", "totaReading", "totiLink", "TottLoad", "totalAccept", "totaRead", "tobyUse", "tottFind", "totoLength", " totalWrite", "nottWrite", "dottLoad", "tottClose", "TotaLoad", "towWrite", "tetRead", "dotLoad", "tottedFollow", "totoConnect", "tottReader", "TottReader", "towReading", "tntWrite", "TottSearch", "dottReading", "totoUse", "intottBuild", "totingGet", "tottUse", "totaLink", "ntotRead", "totClose", "totGet", "tottBuild", "octotRead", "totoFind", "tottAccept", "dotReader", "TottFollow", "totalRead", "TotConnect", "towRead", "totAccept", "totoLoad", "towLoad", "totaBuild", "dottReader", "totoReading", "dotUse", "octotLength", "nottLoad", "tochLoad", "ntottLoad", "tottConnect", "TotSearch", "tatReader", "totingWrite", "TottRead", "tottLoad", "dottWrite", "totUse", "TotLoad", "dottUse", "TotFollow", "ntottReader", " totalLink", "totingSearch", "tottDraw", "totLoad", "totReader", " totalRead", "toyWrite", "tetWrite", "dottRead", "totLink", "tottGet", "toyDraw", "tntRead", "ntottRead", "intotLoad", "tottWrite", "totiRead", "TotaRead", "tochWrite", "TotDraw", "TotGet", "totaWrite", "tochRead", "intotBuild", "toyLoad", "tottedRead", "tochReader", "totingRead", "notWrite", "notAccept", "tollWrite", "ntottWrite", "TotaDraw", "tntReader", "tottRead", "TottConnect", "totoWrite", "ntotReader", "intottClose", "TottWrite", "tcotBuild", " totBuild", "tatRead", "tobyRead", "TottGet", "tcotLoad", "TotReader", " totWrite", "octotReading", "tollRead", "totalLink", "tollLoad", "totBuild", "ntotLoad", "tntLoad", "totingConnect", "tobyFind", "tcotClose", "tazonBuild", "tottLength", "nottAccept", "tollReading", "tottedWrite", "notRead", "dotReading", "tottFollow", "totalLoad", "tatLoad", "totingFollow", "tazonClose", "towLength", "TotReading", "totaLoad", "tottReading", "totDraw", "dotWrite", "totoSearch", "totLength", "totWrite", "octotoWrite", "totConnect", "tottedGet", "tatWrite", "dotRead", "octotWrite", "tetReading", "intottRead", "dottFind", "dotFind", "intotClose", "totaDraw", "totalWrite", "octotoLength", "TottReading", "totFind", "totaReader", "tetLoad", "toyRead", "tcotRead", "tazonRead", "TotRead", "totFollow", "totiWrite", "octotoRead", "towAccept"], "out": ["p", "x", "init", "output", "client", "sync", "net", "c", "ac", "s", "w", "plus", "ex", "l", "socket", "conn", "OUT", "writer", "n", "g", "io", "a", "up", "b", "outer", "ext", "exec", "obj", "conf", "h", "fn", "exp", "connection", "Out", "In", "outs", "inc", "again", "off", "file", "parent", "part", "t", "err", "r", "o", "v", "bin", "d"], "i": ["x", "source", "init", "buffer", "current", "ai", "I", "k", "ci", "abi", "chi", "ip", "name", "u", "li", "y", "key", "slice", "start", "d", "ti", "uri", "info", "ei", "one", "data", "ini", "multi", "iu", "bi", "io", "g", "pi", "api", "j", "eni", "id", "hi", "me", "ii", "e", "input", "ind", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "zi", "ri", "my", "phi", "p", "length", "z", "c", "ni", "gi", "ix", "ori", "ie", "l", "yi", "m", "q", "it", "ui", "ik", "oi", "index", "fi", "r", "v", "ic"]}}
{"id1": "2113444", "id2": "17029388", "code1": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"newVelocityEngine": ["newVelocityDriver", "newVelisionDriver", "newVelantomEngine", "newVelysicsServer", "newVelysicsDriver", "newvelocityInstance", "newvelocityServer", "newvelantomInstance", "newvelantomDriver", "newVelantomInstance", "newVelysicsEngine", "newVelantomDriver", "newvelantomEngine", "newVelocityServer", "newVelocityInstance", "newVelisionServer", "newVelisionInstance", "newvelocityDriver", "newVelantomServer", "newVelisionEngine", "newVelysicsInstance", "newvelocityEngine", "newvelantomServer"], "velocityEngine": ["velocityCase", "velosityServer", "velocolServer", "VelocityModel", "velvelModule", "collocityImpl", "velvelEngine", "velvelController", "veloDriver", "explocityNode", "velvelCase", " velisionCase", "velocityServer", " velocityCore", "velisionCase", "velisionCore", "velotionEngine", "collocityController", "veloModel", "explocityModule", "VeloService", "collocityServer", "velocityController", " velisionController", "velityDriver", "velocolImpl", "velocityService", "velvelCore", "velantomModule", "velvelNode", "velosityCore", " velisionEngine", "veloService", "velisionServer", "velocityModel", "velantomServer", "explosityEngine", "velvelServer", "velocolEngine", "explocityServer", "velosityController", "velocityImpl", "velosityCase", " velocityController", "VeloEngine", "velosityModule", "velocityCore", "velotionService", "velosityNode", "explosityServer", "collisionServer", "VeloModel", "velosityEngine", "VelocityDriver", " velocityCase", "collisionController", "VelocityEngine", "VeloDriver", "velvelImpl", "velisionImpl", " velisionCore", "velantomNode", "explosityNode", "velityService", "velantomEngine", "collisionEngine", "velocityNode", "VelocityService", "velityModel", "explosityModule", "veloEngine", "velisionEngine", "velocityDriver", "collisionImpl", "velotionModel", "velityEngine", "velocityModule", "velisionController", "velocolController", "explocityEngine", "velotionDriver", "collocityEngine"], "is": ["mis", "as", "init", "ris", "ps", "uri", "IS", "out", "im", "us", "was", "isa", "ai", "info", "s", "its", "state", "ori", "il", "iss", "i", "ie", "Is", "src", "or", "iso", "in", "close", "resource", "lis", "ib", "does", "ip", "io", "ar", "si", "os", "it", "isc", "ui", "fs", "isl", "address", "res", "api", "isi", "stream", "ais", "ios", "iter", "es", "abs", "iris", "err", "nis", "id", "bis", "get", "has", "ois", "http"], "url": ["source", "uri", "str", "path", "Url", "f", "config", "page", "il", "e", "i", "l", "src", "image", "loc", "loader", "data", "service", "resource", "location", "io", "base", "b", "server", "host", "URL", "sl", "address", "api", "string", "ur", "stream", "file", "r", "feed", "ssl", "id", "xml", "http"], "props": ["propps", "preps", "preperties", "proPS", "crops", "propPS", "procs", "Procs", "promcs", "prombs", " probs", " procs", "prps", "propperties", "preds", "probs", "promps", "propfs", "ProPS", "prob", "croperties", "crods", "profs", "Props", "prperties", " properties", "protb", "protfs", "prfs", " prods", "prefs", "prods", "protps", "prb", "protperties", "Probs", "promds", "propb", "properties", " profs", "crofs", "Prods", "propbs", " proPS", "propcs"]}}
{"id1": "8166767", "id2": "23088292", "code1": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"invoke": ["call", "create", " execute", "instance", "info", "http", "construct", "java", "timeout", "via", " invoking", "send", "to", "oke", "func", "process", "evaluate", "in", "object", "service", "open", "resource", "online", "reflect", "fire", "next", "execute", "initial", "exec", "post", "operation", "olve", "connection", "wrap", "submit", "request", "apply", "start", "handle", "run", "reply"], "invocation": ["invoking", "envocation", "envoid", "inocation", "allocation", "Invoking", "implocation", "Invoid", "invoid", " invoking", "installiation", "inoking", "alloked", "imploke", "convoice", "invoked", "invoker", " invoked", "Inviation", " invoice", "installoker", "Invoke", "envoker", "installoid", "alloice", "convoke", "invoice", "Invocation", "convoker", " invoker", "Invoice", "alloker", "imploked", "Invoker", "inviation", "installocation", "inoker", "alloke", "convocation", "imploice", "enviation"], "retryTimes": ["retryingTimes", "retryYears", "RetryingTokens", "retrowTime", "retyPoints", "reryDays", "retayYears", "retryingTokens", "retryTS", "RetryTokens", "RetryingYears", "retrowPoints", "retvalTimes", "RetryingHours", "retvalTime", "retryHours", "retryingTS", "retriedHours", "rettryPoints", "rettryDays", "retryingHours", "reryTimes", "retrainTokens", "RetryTS", "retryingTime", "retriedTime", "retriedYears", "retayTimes", "retryPoints", "retriedTS", "retriedTimes", "rettryTime", "retayTime", "RetryHours", "retrowTokens", "RetryTime", "retryingDays", "retryTime", "retryingYears", "retyHours", "RetryPoints", "retvalPoints", "RetryingTime", "retriedPoints", "retyTime", "retvalDays", "retayTS", "RetryTimes", "RetryingTimes", "RetryingPoints", "RetryingTS", "retrowTimes", "retryingPoints", "rettryTimes", "retryTokens", "retrainPoints", "retrainTime", "retryDays", "retyTimes", "reryPoints", "RetryYears", "retrainTimes", "reryTime"], "url": ["ls", "source", "method", "enabled", "uri", "json", "path", "Url", "config", "f", "l", "src", "image", "loc", "service", "location", "resource", "email", "www", "base", "name", "server", "host", "URL", "rl", "address", "string", "channel", "ll", "html", "route", "r", "href", "response", "ssl", "id", "http"], "postMethod": ["postRequest", "POSTMethod", "postFunction", "getMethod", "POSTPost", " postOperation", "postPost", "PostPost", "getRequest", "POSTFunction", "headMethod", " postMethods", "getFunction", "PostOperation", "PostMethods", "headFunction", "PostFunction", " postRequest", "PostRequest", "getMethods", "postMethods", " postFunction", "postOperation", "POSTOperation", "headMethods", "headPost", "PostMethod", " postPost"], "rsp": ["Rsp", "srpc", "rsl", "rSp", "rcsl", " rsl", "rssp", "frsc", "Rpc", "frSp", "rssc", "rpc", " rpc", "rsc", "Rserv", "rcsp", "srsp", "rssh", "srsl", "Rsl", " rSp", "frsl", "rsh", "rcsc", "rssl", " rsc", "Rsc", "RSp", "rcsh", " rserv", "srserv", "rserv", "frsp", " rsh"], "sl": ["ls", "su", "sw", "se", "sync", "SL", "SB", "Sl", "kl", "hl", "pl", "il", "sil", "l", "bl", "cel", "nl", "dl", "sr", "shell", "si", "lc", "sel", "rl", "fl", "isl", "sp", "fr", "cl", "el", "ll", "coll", "sh", "sn", "ssl", "ser", "sle", "sf", "cli", "la", " Sl", "status"], "entity": ["source", "ent", "message", "oter", "result", "output", "json", "translation", "info", "environment", "model", "http", "page", "person", "e", "et", "data", "agent", "service", "resource", "email", "metadata", "node", "document", "em", "article", "obj", "api", "body", "string", "connection", "enc", "el", "collection", "response", "type", "xml", "Entity", "content", "application"], "sb": ["bh", "su", "ab", "ss", "xb", "SB", "cb", "obb", "bb", "fb", "s", "info", "lab", "buff", "bj", "ub", "txt", "sg", "pb", "src", "mb", "bp", "kb", "ib", "bf", "lb", "ws", "sr", "sth", "sa", "si", "bc", "sm", "b", "bt", "rob", "usb", "nb", "bs", "split", "bg", "sp", "rb", "eb", "gb", "string", "bm", "lr", "orb", "sq", "abs", "bsp", "wb", "ssl", "sf", "ob", "sv", "db", "bd"], "is": ["as", "ris", "rx", "uri", "IS", "isa", "str", "out", "was", "ai", "s", "info", "its", "iss", "i", "ie", "Is", "src", "serv", "or", "iso", "data", "in", "lis", "ib", "ir", "ip", "io", "ar", "si", "os", "it", "ui", "fs", "address", "api", "isi", "iri", "stream", "ais", "ios", "iter", "es", "iris", "ser", "ob", "id", "bis", "has", "ri"], "reader": ["rx", "buffer", " Reader", "reading", "ry", "inner", "f", "s", "rr", "rar", "e", "i", "ler", "per", "l", "or", "read", "writer", "oder", "in", "ner", "ini", "ir", "io", "editor", "ink", "rer", "it", "server", "rb", "rc", "stream", "handler", "lr", "parser", "Reader", "iter", "row", "r", "er", "ser", "ob", "feed", "entry", "ri"], "line": ["text", "message", "lf", "char", "style", "Line", "lines", "str", "sync", "cell", "frame", "len", "page", "pass", "e", "i", "l", "cle", "inline", "data", "comment", "character", "name", "base", "b", "pe", "lc", "job", "code", "sel", "ge", "number", "letter", "body", "li", "string", "header", "LINE", "cl", "lin", "block", "part", "row", "key", "response", "non", "entry", "feed", "unit", "le", "end", "no"], "responseBody": ["requestBody", "ResponseBody", "replyMessage", "replyPart", "respbody", "requestbody", " responsePart", " responseContent", "entityMail", "respBody", "replybody", "ResponseMessage", "responsePart", "entityText", "responseMail", "respMail", "entitybody", "entityBody", "ResponsePart", "respText", "replyBody", "responseText", "responseMessage", " responseMail", "responsebody", " responseText", "replyContent", " responseMessage", "ResponseContent", "responseContent", "Responsebody", "requestContent", " responsebody"], "t": ["p", "x", "types", " type", "ts", "tor", "ot", "st", "c", "f", "s", "wt", "w", "e", "i", "l", "k", "et", "m", "total", "format", "n", "g", "class", "u", "it", "dt", "te", "ext", "Type", " T", "T", "h", "target", "tf", "ant", "en", "y", "r", "template", "ct", "o", "type", "v", "d"], "serviceUrl": ["serviceURL", "serverUrl", "responseLine", "ServiceLine", "serverId", "playURL", "playName", "serviceId", "serviceLink", "serverUr", "playUrl", "serverURL", "ServiceStr", "ServiceId", " serviceId", "responseURL", "playSl", "ServiceUr", "serviceUr", "serviceName", "serviceSl", "storageLink", "ServiceSl", "ServiceUrl", " serviceUr", "serverName", "storageUrl", " serviceName", "storageURL", "ServiceName", "storageLine", "ServiceURL", " serviceURL", "serviceStr", "responseLink", "serviceLine", " serviceSl", "serverStr", "ServiceLink", " serviceStr", "responseUrl"]}}
{"id1": "13852596", "id2": "16825994", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"execute": ["call", "create", "copy", "parse", "ute", "invoke", "load", "all", "process", "install", "evaluate", "server", "code", "exec", "transfer", "report", " invoke", " perform", "Exec", "submit", "test", "register", "apply", "start", "handle", "run"], "resources": ["relations", "workers", "types", "rules", "chains", "apps", "locks", "writers", "groups", "issues", "services", "projects", "strings", "resource", "cells", "flows", "archives", "works", "rings", "objects", "series", "thumbnails", "params", "files", "stores", "reports", "features", "models", "pages", "scripts", "plugins", "users", "rates", "results", "Resources", "items", "maps", "classes", "ions", "events", "ids", "stars", "images", "roots"], "i": ["p", "ani", "uri", "ai", "f", "gi", "ii", "info", "ori", "s", "e", "vi", "ie", "l", "I", "k", "wei", "ci", "abi", "ini", "we", "ami", "ir", "multi", "ip", "iu", "bi", "io", "si", "ti", "u", "is", "ui", "pi", "oi", "isi", "j", "li", "iri", "h", "hi", "di", "qi", "eni", "xi", "cli", "mu", "o", "id", "v", "esi", "ri", "ic", "phi"], "classFile": ["classFILE", "ruleLine", "staticfile", "classEntry", "CLASSFile", "connectionFile", "sessionFILE", "ClassGlobal", "customEntry", "sessionFile", "classClass", "Classfile", "filefile", "lassFiles", " classFILE", " classPage", "baseFile", "lassClass", "lassGlobal", "fileFiles", "finalFILE", "serviceLine", "CLASSEntry", "classGlobal", "staticFILE", "packEntry", "fileLoader", "CLASSFILE", "connectionfile", "ClassFactory", "ClassPage", "ClassImage", "sessionfile", " classEntry", "finalfile", "CLASSLoader", " classLoader", "ClassFiles", "baseUrl", "classLoader", "ClassClass", "customFILE", "classfile", "ClassFilename", "servicefile", "staticLine", "classesPath", "objectFiles", "ClassEntry", "objectfile", " classFiles", "classFactory", " classLine", "finalUrl", "ClassDir", " classGlobal", "classImage", "fileImage", "packFile", "classFiles", "ruleFile", "classPage", "classUrl", "ClassStream", "classesFile", "packFILE", "fileFile", " classFactory", " classStream", "classesFiles", "finalFile", "classStream", "CLASSLine", "classesfile", "classDirectory", "classPath", "classDir", " classFilename", "sessionEntry", " classClass", "CLASSDirectory", "connectionFiles", "baseFILE", "ruleFiles", "customFiles", " classDir", "ruleFilename", "CLASSfile", "ClassFile", "packfile", "serviceFile", "customFile", "classFilename", "CLASSImage", "ClassPath", "ClassLine", "fileDirectory", "basefile", "ClassDirectory", "fileLine", "staticFile", "sessionFactory", "CLASSUrl", "CLASSPage", "CLASSFiles", "objectDir", "classLine", "lassFile", "connectionStream", "objectFile", "sessionFiles", " classPath", " classfile", "serviceFILE", "ClassFILE"], "inputStream": ["InputFile", "initSteam", "InputStreamer", "uploadstream", "binaryFile", "importSteam", "inputContext", "outputStreamer", " inputstream", "rawFile", "inputFile", "importStream", "childstream", "inputSw", "childContext", "activeSteam", "outputContext", "binaryStream", "activeStream", "outputReader", "childStream", "uploadStream", "Inputstream", "rawStream", "activeStreamer", "rawSteam", "initStreamer", "inputReader", "inputstream", "InputStream", "outputSw", "InputSw", "importStreamer", "uploadSw", " inputFile", "InputSteam", "binaryStreamer", "inputStreamer", " inputStreamer", " inputSteam", "outputstream", "inputSteam", "rawStreamer", "childReader", "outputFile", "uploadFile", "importstream", "activestream", " inputContext", "initStream", "outputSteam", "initstream", " inputReader", "binarySteam"], "reader": ["source", "arser", "rx", "buffer", "copy", "writers", "re", "client", "reading", "sync", "inner", "author", "system", "rr", "seed", "driver", "ler", "per", "rar", "input", "owner", "manager", "war", "draft", "shared", "or", "read", "riter", "loader", "ner", "oder", "resource", "builder", "director", "ger", "Writer", "io", "editor", "reflect", "rer", "server", "book", "dr", "rc", "worker", "handler", "stream", "ee", "layer", "wrapper", "parser", "Reader", "iter", "request", "row", "key", "er", "entry", "keeper", "right", "ri", "report", "context", "http"], "oldSize": ["OldName", "oldName", "OldSc", " oldSc", "oldLength", "prevSize", "prevLength", "prevSc", " oldName", "prevName", "OldSize", " oldLength", "OldLength", "oldSc"], "writer": ["wer", "buffer", "writers", "token", "widget", "wire", "inner", "author", "written", "w", "driver", "ler", "writing", "word", "e", "war", "manager", "draft", "read", "riter", "data", "ner", "loader", "service", "resource", "builder", "format", "director", "object", "Writer", "oder", "walker", "editor", "io", "document", "player", "writ", "wr", "child", "index", "worker", "string", "rw", "handler", "element", "ee", "write", "wrapper", "winner", "parser", "iter", "creator", "Reader", "maker", "row", "r", "er", "her", "engine", "report", "dc"], "b": ["p", "ab", "buffer", "bar", "br", "abc", "c", "f", "bb", "fb", "ba", "w", "e", "pb", "l", "k", "B", "m", "object", "binary", "lb", "be", "g", "a", "base", "u", "null", "rb", "db", "h", "eb", "emb", "r", "ob", "boot", "bin", "orb", "d", "bd"], "outputStream": [" outputView", "OutputStream", "outstream", "protectedSteam", "OutputStreamer", "OutputSteam", "Outputstream", "OutputView", "outputStreamer", " outputSteam", "inputstream", "protectedStream", "protectedStreamer", "protectedstream", "dataStream", "dataStreamer", "outputContainer", " outputStreamer", "outStreamer", "inputStreamer", "inputView", "outputstream", "outSteam", "inputSteam", " outputContainer", "dataSteam", "outStream", " outputstream", "outputView", "inputContainer", "outputSteam", "dataContainer"], "injectedClasses": ["injectedWrites", "injectedClassies", "injectionClasses", "injectedClassites", "injectedclassies", "injectionclassites", "injectedWrits", "injectionClassies", "injectedProjectes", "injectionclasss", "injectedclassites", "injectedclasses", "injectionclassies", "injectedWritites", "injectionClassites", "injectedProjectites", "injectionclasses", "injectedProjecties", "injectedWrities", "injectedProjects", "injectionClasss", "injectedclasss", "injectedClasss"], "newSize": ["NewStorage", "finalSize", "NewSize", " newLength", "newStorage", "newFontSize", "finalStorage", " newFontSize", "finalFontSize", "finalLength", " newStorage", "newLength", "NewFontSize", "NewLength"]}}
{"id1": "13946197", "id2": "22752444", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"transformByMD5": [" transformWithMSecret", " transformByMC5", " transformBymd5", " transformWithM3", " transformByM3", " transformByMC3", " transformWithM4", " transformBymd4", " transformBymdSecret", " transformByMD3", " transformByMDSecret", " transformByMD4", " transformByMCSecret", " transformBymd3", " transformWithMD5", " transformByM5", " transformByMC4", " transformWithMD4", " transformWithMDSecret", " transformByM4", " transformByMSecret", " transformWithM5", " transformWithMD3"], "password": ["p", "text", "secret", " passwords", "message", "account", "source", "filename", "token", "path", "username", "config", "hash", "wd", "phrase", "word", "pattern", "padding", "data", "object", "auth", "PASS", "resource", "email", "database", "name", "device", "sword", "params", "address", "wallet", "string", "connection", "channel", "prefix", "crypt", "Password", "attribute", "login", "user", " Password"], "md5": ["mand3", " MD45", "materialfive", "mdfive", "MDql", "md4", "md2", "mand5", " md3", "MDdown", " MD3", "mdse", "mddown", " md45", "md512", "mandse", " MDdown", " mdql", " MDok", "md3", "mdok", "amd512", "amd3", "md55", "mand45", " md2", "MD2", " MD55", "MDse", "amd2", "MDok", "MD5", "mand2", "amd5", " mddown", " mdok", "mdql", "MD512", "materialql", "material5", "md45", " MD5", " md4", " MD4", " md512", "mand4", "mand55", "MDfive", " md55", " mdfive", " mdse", "MD3", "material2"], "output": ["dot", "secret", "text", "message", "sequence", "style", "buffer", "property", "result", "generated", "out", "generation", "config", "written", "page", "word", "console", "input", "image", "complete", "data", "resource", "format", "foo", "document", "character", "display", "width", "reason", "outer", "array", "letter", "address", "beta", "string", "prefix", "queue", "exit", "write", "full", "reference", "Output", "response", "o", "unit", "hidden", "target", "offset"], "bufferPass": ["BufferPass", " bufferPush", " bufferCopy", "ufferFeed", "bufPush", "bufferpass", "bufPass", " bufferPack", "ufferLine", "ufferCopy", " bufferLine", "bufferFeed", "BufferComp", "bufferPush", " bufferComp", "bufFeed", "ufferPush", "BufferLink", "bufLink", "Bufferpass", "bufferScan", "ufferPass", " bufferpass", "bufferPack", " bufferFeed", "bufCopy", "bufferLine", " bufferScan", "BufferFeed", "bufferComp", "bufLine", "bufferLink", "bufComp", " bufferLink", "bufpass", "ufferPack", "bufferCopy", "bufScan", "bufPack", "ufferScan"], "b": ["p", "x", "ab", "buffer", "sb", "br", "c", "f", "bb", "ba", "fb", "s", "bytes", "w", "e", "i", "l", "bl", "k", "line", "B", "binary", "lb", "bf", "n", "be", "bi", "a", "url", "base", "u", " a", "null", "obj", "bs", "body", "rb", "eb", "h", "db", "abb", "orb", "y", "wb", "r", "t", "ob", "v", " eb", "cb", "d"]}}
{"id1": "21488518", "id2": "21979714", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "label": 0, "substitutes": {"createNew": ["openOpen", "openResource", "openCopy", "resourceOpen", "openNew", "resourceResource", "createOpen", "newResource", "resourceNew", "createCopy", "newOpen", "newCopy", "createResource", "resourceCopy", "newNew"], "name": ["x", "style", "filename", "large", "current", "client", "path", "username", "ame", "alias", "NAME", "model", "title", "ix", "e", "one", "word", "Name", "image", "none", "default", "data", "names", "folder", "resource", "missing", "comment", "old", "self", "on", "n", "directory", "class", "url", "base", "no", "search", "ext", "code", "label", "ui", "number", "address", "time", "string", "connection", "ename", "prefix", "size", "full", "office", "named", "file", "value", "part", "anc", "key", "non", "id", "end", "type", "parent", "member", "common", "content"], "in": ["work", "source", "init", "buffer", "inner", "len", "plus", "pass", "i", "input", "src", "image", "read", "IN", "data", "ini", "record", "resource", "win", "con", "up", "bin", "exec", "ins", "connection", "size", "thin", "In", "raw", "inc", "file", "login", "id", "reader", "slice", "diff", "din"], "length": ["sequence", "filename", "buffer", "Length", "path", "load", "len", "timeout", "bytes", "level", "count", "padding", "ength", "line", "duration", "limit", "url", "width", "password", "number", "body", "time", "size", "id", "type", "offset", "content"], "contentType": ["Contenttype", "ContentPath", "resourcetype", " contenttype", "resourcePath", "contenttype", " contentPath", "resourceLength", "contentLength", "resourceType", " contentLength", "ContentLength", "ContentType", "contentPath"], "dest": ["source", "flat", "result", "prop", "output", " destination", "config", "home", "store", "gz", "trip", "txt", "d", "de", "trans", "src", "tx", "cdn", "folder", "done", "later", "transform", "img", "sup", "tmp", "cont", "tif", "destroy", "zip", "conf", "dist", "upload", "comb", "thin", "orig", "desc", "temp", "route", "wb", "Dest", "dir", "parent", "opt", "target", "dc"], "out": ["source", "result", "buffer", "copy", "cache", "output", "client", "sync", "path", "f", "this", "gz", "view", "page", "ex", "cmd", "socket", "conn", "OUT", "line", "image", "data", "writer", "object", "resource", "img", "io", "up", "url", "log", "null", "ext", "server", "obj", "exec", "pool", "password", "zip", "connection", "exp", "channel", "lock", "Out", "outs", "again", "file", "temp", "parent", "err", "o", "flush", "bin"], "request": ["access", "call", "remote", "buffer", "forward", "re", "client", "path", "claim", "instance", "config", "store", "use", "input", "friend", "respect", "project", "complete", "get", "req", "object", "resource", "open", "QUEST", "quest", "wheel", "directory", "url", "job", "base", "rer", "pe", "ext", "transfer", "query", "child", "upload", "external", "reference", "route", "response", "rate", "user", "type", "xml", "Request", "report"]}}
{"id1": "11562173", "id2": "13414771", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"checkInputStream": ["checkFilestream", "checkIOSteam", "checkFileChannel", "checkOutputChannel", "checkInputChannel", "checkOutputstream", "checkInputstream", " checkInputChannel", " checkOutputstream", " checkInputSteam", "checkIOstream", "checkInputSteam", "checkFileStream", " checkOutputSteam", "checkFileSteam", "checkOutputSteam", "checkOutputStream", "checkIOChannel", " checkInputstream", "checkIOStream", " checkOutputChannel", " checkOutputStream"], "in": ["p", "x", "source", "as", "into", "inn", "inner", "c", "plus", "input", "src", "image", "IN", "data", "con", "ini", "io", "isin", "up", "din", "is", "min", "index", "ack", "ins", "connection", "comp", "In", "inc", "again", "login", "reader", "bin", "ic"], "cmp": ["p", "upp", "match", "pre", "mom", "cs", "cache", "fp", "mp", "ctrl", "cho", "c", "config", "np", "com", "ci", "loc", "amp", "comment", "cop", "prev", "up", "sup", "pixel", "clip", "pc", "conv", "lc", "spec", "proc", "omp", "code", "asc", "ch", "index", "rc", "cc", "cup", "cp", "prefix", "coll", "comp", "cpp", "sort", "op", "diff", "ctx", "cb", "co", "roc"], "all": ["p", "local", "match", "call", "al", "not", "one", "l", "none", "global", "default", "process", "total", "valid", "and", "a", "ann", "array", "allow", "asc", "null", "All", "each", "ALL", "best", "list", "alpha", "cl", "coll", "full", "auto", "acl", "both", "always", "only", "am", "sum", "partial", "any", "parent", "except"], "stream": ["source", "iterator", "form", "result", "sw", "output", "ream", "client", "port", "steam", "instance", "this", "model", "per", "input", "trans", "socket", "src", "object", "round", "transform", "progress", "self", "up", "platform", "speed", "document", "cont", "null", "host", "pool", "ack", "string", "Stream", "channel", "stack", "coll", "comp", "wrapper", "raw", "impl", "test", "temp", "track", "response", "feed", "roll", "reader", "user", "v", "context"], "out": ["p", "x", "result", "copy", "output", "sync", "c", "point", "not", "this", "extra", "OUT", "project", "image", "data", "other", "comment", "io", "up", "bin", "name", "array", "null", "outer", "b", "obj", "index", "list", "exp", "prefix", "option", "Out", "full", "sum", "outs", "block", "again", "parent", "part", "response", "o", "user", "v", "inc"], "i": ["p", "x", "init", "uri", "c", "f", "ai", "gi", "ii", "info", "ix", "e", "d", "l", "I", "k", "ci", "ind", "abi", "ini", "multi", "n", "bi", "io", "si", "u", "b", "lc", "it", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "mi", "di", "qi", "strength", "xi", "fi", "key", "r", "slice", "id", "end", "type", "v", "start", "ri", "ti"]}}
{"id1": "659316", "id2": "14191679", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"argv": ["paramb", "argsf", " argver", "argumentver", "argf", " argl", "paramV", "argumentc", " argf", "argsv", "argl", "paramv", "argver", "Argve", "interV", "ArgV", "interl", "paraml", "argc", "Argl", " argV", "Argver", "Argv", "argumentve", "interc", "argb", " argb", "Argc", " argve", "argsl", "interv", "Argb", "argve", "argumentv", "argsc", "argV", "Argf", " argc"], "sources": ["psources", "fors", "tource", "vesores", "tources", "sesences", "statources", "issource", "statigs", "sores", "fource", "sresources", "fides", "sigs", "psource", "issources", "vesigs", "vesources", " sors", " sides", "sences", "tresources", "issides", "sesores", "statences", "sors", "issors", "psresources", "psides", "sesources", "fources", "fresources", "sides", "statores", "sesigs", "vesences", "tides"], "targets": ["tagnencies", "taxlets", "targends", " taxes", "targens", " taxends", "Targens", "tampels", " targens", "toket", "Targels", "tiges", "taxens", "tanglets", "taxets", "Tangets", "tagnets", "taxends", "taxels", "Tanglets", "targes", "tokets", "tagnet", "tagnens", "tangends", "tigens", "Tangens", "tamplets", " taxens", "tampets", "tangens", "tanges", "targels", " targes", " tokens", "targencies", "tokens", "Targlets", "tangets", " tokets", "tigets", "targlets", "tigends", "Targets", "taxes", " targends", "tanget", " taxets", "tampens", "tangels", "Tangels", " toket", " tokencies", "tokencies", " targencies", "tangencies"], "srclen": ["srCLength", "rscelEN", "srcelEN", "srplen", "rsclens", "srploen", "rsclEN", "srseln", "srctoen", " srcloen", "srselen", "srclens", "srClens", "srCln", "srClen", "srceln", "srselens", "rsclen", "srpleno", " srclength", " srploen", "rsceln", "rscelen", " srplength", "srclEN", "srClEN", "srcten", "srctength", "srcleno", "srCLen", "rscelens", " srcleno", "srcln", "srplength", "srcelen", "srselEN", " srpleno", "rscln", "srclength", " srplen", "srcteno", "srcelens", "srcloen", "srCLoen", "srCLeno"], "source": ["create", "remote", "copy", "cache", "uri", "current", "out", "client", "path", "config", "s", "use", "view", "seed", "event", "component", "model", "link", "driver", "ources", "input", "src", "ource", "image", "SOURCE", "single", "get", "Source", "in", "service", "resource", "proxy", "force", "self", "dest", "url", "sl", "secure", "rc", "scope", "channel", "size", "stream", "ssl", "slice", "id", "reader", "unit", "type", "parent", "start"], "tgt": ["tnt", " tgz", "hret", " tret", " tgs", " tgh", " tkt", "Targ", "Tkt", "Tch", "hnt", "bitarg", "hgz", "lret", "rkt", "ptgt", "Tgs", "tkt", "hgt", "tgz", "bitgt", "biticket", " tbuster", "tch", " tch", "tret", "targ", "rgt", "ticket", "lgz", "tgh", " targ", " tnt", "ptbuster", "Tgt", "lbuster", "rch", "Ticket", "larg", "lnt", "lgt", " ticket", "ptnt", "ptarg", "Tgh", "bitgh", "tbuster", "tgs", "rgs"], "target": ["match", "remote", "result", "output", "goal", "out", "port", "client", "path", "session", "current", "download", "point", "cross", "archive", "event", "component", "master", "tail", "driver", "nt", "slave", "view", "to", "arget", "conn", "project", "manager", "image", "service", "object", "Target", "resource", "director", "open", "force", "dest", "io", "core", "next", "url", "base", "null", "it", "child", "connection", "external", "channel", "handler", "plugin", "mount", "route", "unit", "parent", "member", "rel"], "deletes": ["deises", "delouts", "dedates", " dedates", "downdates", "degrades", "delises", "kesouts", "kesleted", "Deires", "desletes", "exletes", "desists", "disires", "disists", "desles", "exlete", "deles", "downletes", " deleted", "exdates", " deouts", "disletes", "deouts", "Deles", " degrades", "deleted", "delletes", "kesises", "exgrades", "disles", " deises", "Deists", "kesletes", "delleted", "Deletes", "downgrades", "desires", "deires", "deists", "delete", " delete", "downlete"], "del": ["local", "copy", "se", "dec", "clean", "update", "download", "model", "d", "de", "bl", "skip", "down", "install", "data", "nl", "dl", "up", "base", "name", "add", "null", "change", "Del", "sel", "fl", "delay", "neg", "lock", "coll", "el", "ll", "fail", "ul", "def", "file", "pull", "syn", "err", "remove", "dir", "diff", "id", "get", "Delete", "delete", " Del", " delete", "rel"]}}
{"id1": "10728243", "id2": "17158020", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"scramble411": ["scramprint5", "screamprint5", "scramcy41", "scramble5", "scramprint41", "screamble41", "screamprint41", "scrambe5", "screamprint411", "scramcy411", "scramcy123", "scramble41", "screamprint123", "screamble5", "screamble123", "scrambe123", "scramble123", "scrambe41", "scramcy5", "screamble411", "scramprint411", "scrambe411", "scramprint123"], "password": ["account", "secret", "filename", "words", "token", "path", "username", "config", "pad", "hash", "wd", "pass", "phrase", "word", "input", "project", "padding", "auth", "PASS", "email", "mac", "sudo", "name", "sword", "security", "number", "address", "wallet", "string", "channel", "crypt", "prefix", "sum", "Password", "attribute", "dh", "key", "user"], "seed": ["text", "secret", "source", "mode", "token", "length", "username", "pad", "alias", "hash", "state", "pass", "phrase", "driver", "padding", "eed", "sudo", "shadow", "name", "device", "random", "prime", "zip", "address", "string", "finger", "machine", "Salt", "crypt", "size", "prefix", "sum", "key", "volume", "slice", "id", "template", "pattern", "offset", "pair"], "md": ["ht", "mand", "hm", "mode", "mm", "mp", "amd", "Cmd", "wd", "dig", "cmd", "dm", "po", "ds", "mb", "meta", "mg", "ind", "addr", "m", "nm", "mad", "metadata", "ad", "mac", "grad", "rm", "bm", "sm", "ms", "vd", "kg", "nd", "pd", "mid", "sha", "gd", " MD", "om", "mi", "ld", "di", "dd", "od", "mo", "mn", "mt", " Md", "hd", "mem", "cm", "am", "cd", "km", "MD", "dh", "mc", "part", "ma", "df", "diff", "pkg", "mag", "pm", "d", "doc", "bd", "dc"], "passwordHashStage1": ["passwordSumStage2", "passwordSumStage4", "passwordHashStep1", "passwordHashstage4", "passwordHashStage0", "passwordHashstage0", "passwordHashstage2", "passwordSumPhaseOne", "passwordHashStage3", "passwordHashPhase3", "passwordSumPhase1", "passwordHashStageOne", "passwordHashStep3", "passwordSumPhase0", "passwordHashstage1", "passwordHashPhase1", "passwordHashstageOne", "passwordHashstage3", "passwordSumStageOne", "passwordHashPhase2", "passwordHashPhase4", "passwordHashPhaseOne", "passwordHashStage4", "passwordHashStep2", "passwordSumStage1", "passwordSumStage3", "passwordHashPhase0", "passwordSumPhase4", "passwordSumPhase3", "passwordSumPhase2", "passwordSumStage0"], "passwordHashStage2": ["passwordHashstage8", "passwordSumStage2", "passwordSumPhase02", "passwordHashPhaseTwo", "passwordHashStep1", "passwordHashstageTwo", "passwordHashPhase02", "passwordBlockStage1", "passwordHashstage02", "passwordSumPhaseTwo", "passwordHashPhase8", "passwordHashstage2", "passwordBlockstage2", "passwordHashStep4", "passwordSumStage02", "passwordSumStageTwo", "passwordSumPhase1", "passwordBlockStage4", "passwordBlockStage2", "passwordBlockstage8", "passwordHashstage1", "passwordHashPhase1", "passwordHashStep8", "passwordHashPhase2", "passwordBlockStage8", "passwordBlockstage1", "passwordHashStageTwo", "passwordHashStage8", "passwordHashPhase4", "passwordHashStep2", "passwordSumStage1", "passwordBlockstage4", "passwordSumPhase2", "passwordHashStage4", "passwordHashstage4", "passwordHashStage02"], "toBeXord": ["tobeCrossord", "toBeCrossords", "tobeCrossor", "toBeYord", "toBeWorkord", "tobeCrossords", "toBEXORD", "toBEXord", "tobeXorder", "tobeYord", "toBeZords", "toBeCrossors", "toBeYorder", "toBeCrossORD", "toBeZor", "toBeWorkor", "toBeYors", "tobeYors", "toBeXords", "tobeXord", "toBeWorkors", "tobeCrossors", "toBeWorkords", "tobeYorder", "toBeZord", "toBEXords", "toBeYords", "toBeZors", "toBeWorkorder", "tobeXors", "toBeYORD", "toBEYor", "toBEYords", "toBEYord", "toBeZorder", "tobeYor", "toBeXors", "toBeXorder", "toBeZORD", "toBeCrossord", "toBeCrossor", "toBeWorkORD", "toBEYORD", "toBeYor", "tobeXords", "toBeXor", "toBeXORD", "toBEXor", "tobeXor"], "numToXor": ["numtoXor", "numtoxor", "numToCrossors", "numToXOr", "numToxOR", "numToAbsOR", "numToAnyOr", "numtoXorer", "numToWorkors", "numtoXOR", "numToAnyor", "num2Absorer", "numToAnyOR", "numToAbsOr", "num2AbsOr", "numtoxorer", "numToWorkorer", "numToAbsorer", "numToxors", "numToCrossor", "numToCrossOR", "num2Xor", "num2AbsOR", "num2Absor", "numToAnyorer", "numToWorkor", "numToCrossOr", "num2Xorer", "num2XOR", "numtoxors", "numToXors", "num2XOr", "numtoxOR", "numToAbsor", "numToXorer", "numToXOR", "numToxorer", "numtoXors", "numToxor", "numToWorkOR", "numToCrossorer"], "i": ["p", "x", "uri", "z", "c", "f", "ai", "info", "ii", "gi", "ix", "e", "l", "I", "k", "ci", "abi", "m", "chi", "in", "multi", "ip", "io", "bi", "n", "a", "si", "u", "b", "ti", "it", "ui", "pi", "oi", "li", "index", "j", "h", "hi", "di", "qi", "off", "y", "xi", "part", "key", "r", "slice", "t", "id", "o", "v", "ri", "d"]}}
{"id1": "2668853", "id2": "11032546", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2Stream", "decodeFile2file", "decodeFiletoFiles", "decodeStringToStream", "decodeFileAsfile", "decodeStringToFiles", "decodeFileAsStream", "decodeFiletofile", "decodeFile2File", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileTofile", "decodeFiletoStream", "decodeFile2Files", "decodeString2Stream", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeStringTofile", "decodeFiletoFile", "decodeString2file", "decodeString2File"], "infile": ["infp", "outFile", "inputFile", "infiles", "outfiles", "outfilename", "minfp", " inFile", "inputfile", " infilename", "inputfilename", "inFile", "minFile", "inputfiles", "minfilename", "outfp", "inputfp", "infilename", "minfile", " infiles"], "outfile": ["infp", "outFile", "infilename", "Outfile", " outfp", " outfilename", " outfolder", "outfull", "outputfp", "Outfolder", " outFile", "outputfolder", "infolder", "outfolder", "outfilename", "outputfile", "outputfilename", " outfull", "outputfull", "OutFile", "outputFile", "outfp", "Outfull"], "in": ["source", "as", "init", "re", "gin", "inn", "pin", "inner", "ac", "f", "s", "this", "ex", "e", "i", "input", "socket", "inside", "conn", "inas", "image", "IN", "data", "m", "con", "win", "ini", "up", "a", "din", "b", "is", "nin", "min", "ins", "cin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "reader", "bin", "ic"], "out": ["work", "as", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "s", "pass", "ex", "to", "socket", "OUT", "conn", "line", "image", "writer", "other", "on", "io", "up", "base", "name", "b", "outer", "ext", "exec", "post", "obj", "exp", "lock", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "op", "o", "bin", "error", "target", "co", "no"], "buffer": ["source", "shape", "result", "length", "memory", "bb", "buff", "pad", "buf", "bytes", "seed", "input", "uffer", "padding", "border", "data", "resource", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "size", "queue", "layer", "batch", "reference", "iter", "value", "pause", "row", "wave", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "x", "current", "Read", "parse", "k", " sleep", " check", "add", " connect", "reads", "size", "write", "iter", "feed", "start", "run", "copy", "sync", "check", "load", "use", "count", "play", " find", " copy", "allow", " reach", "id", " parse", "select", "tell", "reading", "lex", "READ", "send", "input", "skip", "line", "sleep", "ind", " r", "limit", "next", " write", " use", " reader", " receive", "wait", " get", "reader", "get", "inc", "fill", " Read", "ride", "seek", "se", "length", "pass", " request", "open", "ad", "find", " send", "connect", " ride", " load", "exec", "index", "r", "end"], "success": ["ceed", "better", "fast", "result", "first", "continue", "successful", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "found", "warning", "correct", "follow", "done", "good", "accept", "zero", "valid", "job", "danger", "null", "initial", " succ", "true", "yes", "rolling", "safe", "fail", "full", "winner", "ok", "failed", "again", "value", "response", "cess", "results", "roll", "ccess", "error", "selected", "status", "content"]}}
{"id1": "12128591", "id2": "9371421", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"hash": ["text", "copy", "str", "parse", "check", "update", "component", "dump", "build", "print", " fingerprint", "log", "add", "SHA", "Hash", "code", "hex", " Hash", "h", "crypt", "sum", "pack", " hashing", " hashes", "get"], "data": ["p", "text", "source", "message", "style", "buffer", "result", "media", "cache", "output", "str", "length", "DATA", "memory", "pad", "info", "s", "bytes", "input", "image", "padding", "in", "format", "missing", "a", "class", "name", "database", "base", "address", "hex", "dat", "body", "api", "string", "connection", "alpha", "value", "response", "template", "content"], "digest": ["generests", "peder", "bigest", "signusher", "Digusher", "Digester", "Digast", "DigEST", "bigester", "digEST", "decests", "logest", "Digenge", " digusher", "pedest", "digusher", "pede", " digests", "mdester", "digenge", "pedester", "bigger", "Diger", "generit", "mdast", "decest", "logester", "generester", "Digger", "bigusher", "digger", " digger", "digast", "generest", "signEST", " digit", " digEST", "digests", "diger", " dige", "signester", "dige", " diger", "mdenge", "Digest", "decester", "digit", "Dige", "logast", "mdest", "digester", "logenge", " digester", "signest", "decit"]}}
{"id1": "3584508", "id2": "23677128", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"copyResource": [" downloadFile", " copyFile", "transferUrl", " downloadUrl", " downloadResource", " copyresource", "copyFile", "copyresource", "copyUrl", " downloadresource", "transferResource", "transferFile", "transferresource", " copyUrl"], "url": ["ls", "source", "ref", "remote", "re", "uri", "path", "Url", "download", "f", "page", "l", "src", "ource", "image", "loc", "data", "loader", "web", "object", "resource", "www", "base", "name", "bel", "server", "host", "URL", "sl", "address", "string", "connection", "stream", "lr", "file", "r", "feed", "ssl", "id", "xml", "http"], "input": ["source", "form", "buffer", "cache", "current", "out", "parse", "client", "session", "inner", "instance", "load", "f", "bb", "config", "this", "plus", "Input", "i", "l", "socket", "image", "data", "in", "resource", "open", "binary", "act", "progress", "accept", "bin", "error", "base", "inf", "active", "exec", "address", "api", "ack", "index", "upload", "connection", "stream", "element", "qa", "but", "file", "temp", "request", "pull", "ssl", "feed", "reader", "get", "inc", "xml", "audio", "context", "http"], "output": ["flow", "source", "result", "buffer", "copy", "cache", "current", "out", "production", "config", "environment", "console", "socket", "control", "image", "default", "data", "writer", "web", "object", "resource", "other", "binary", "document", "log", "ou", "outer", "operation", "address", "connection", "external", "stream", "queue", "layer", "write", "Output", "put", "file", "response", "unit", "network", "target", "application"], "b": ["p", "x", "ab", "buffer", "sb", "bar", "br", "cb", "c", "f", "bb", "fb", "buf", "e", "i", "pb", "l", "k", "mb", "line", "B", "m", "binary", "lb", "bf", "be", "bi", "n", "a", "bit", "base", "bc", "nb", "bs", "rb", "h", "batch", "file", "abs", "r", "ob", "v", "bin", "db", "d"]}}
{"id1": "20735941", "id2": "88047", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"getFile": ["openFile", "openResource", "newFile", "newfile", "newResource", "openfile", "createfile", "createFiles", "openFiles", "getFiles", "getResource", "newFiles", "createFile", "getfile", "createResource"], "home": ["bar", "path", "first", "f", "store", "this", "domain", "back", "plus", "family", "root", "owner", "project", " HOME", "default", "build", "folder", "resource", "hub", "location", "www", "directory", "HOME", "up", "class", "base", "name", "log", "search", "server", "host", "h", "house", "Home", "include", "dir", "join", "user", "parent", "library"], "fileName": [" filePath", "resourcePath", "urlName", "filename", "resourceName", "filePath", "filePart", "fileType", "urlname", " fileType", "FilePart", "FilePath", " filePart", " filename", "fileUrl", "fileNum", "remotePath", "fullPath", "fullName", "FileNum", "FileName", "singlename", "resourceUrl", "urlPath", "singleType", " fileNum", "fullname", "Filename", "fullPart", "FileType", "remoteName", "urlNum", "remoteUrl", "singlePath", " fileUrl", "singleName"], "file": ["work", "source", "local", "filename", "buffer", "File", "fp", "current", "output", "table", "path", "uri", "f", "store", "model", "use", "place", "ile", "e", "l", "image", "line", "or", "get", "data", "folder", "object", "resource", "money", "play", "up", "FILE", "be", "class", "base", "name", "log", "job", "it", "fe", "function", "child", "letter", "live", "zip", "connection", "rule", "lock", "plain", "handler", "el", "full", "lib", "part", "feed", "dir", "le", "user", "parent", "type", "db", "run", "http"], "url": ["ls", "source", "org", "uri", "path", "Url", "download", "f", "bb", "page", "il", "i", "l", "ource", "socket", "image", "conn", "loc", "data", "web", "service", "object", "resource", "location", "www", "io", "base", "name", "job", "b", "log", "server", "host", "URL", "rl", "zip", "sl", "api", "address", "string", "rule", "connection", "fr", "ur", "coll", "lr", "el", "impl", "lib", "pull", "r", "feed", "ssl", "ob", "http"], "in": ["source", "as", "init", "into", "inn", "gin", "inner", "c", "ac", "f", "s", "plus", "e", "i", "input", "l", "socket", "inside", "image", "line", "IN", "data", "ini", "resource", "io", "n", "bin", "a", "up", "din", "isin", "b", "is", "ins", "stream", "lin", "In", "again", "pull", "r", "login", "reader", "inc"], "out": ["flow", "source", "init", "copy", "output", "client", "sync", "net", "inner", "this", "ex", "i", "to", "socket", "OUT", "conn", "line", "serv", "IN", "data", "writer", "object", "resource", "io", "up", "base", "b", "null", "ext", "exec", "is", "exp", "Out", "write", "In", "outs", "inc", "again", "err", "o", "plain", "bin", "co"]}}
{"id1": "1954410", "id2": "21063400", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecutes", "doexecuteApply", "doexecuteutes", "submitExecApply", "doSendApply", "doSendRun", "submitexecuteutes", "doExecRun", "submitExecRun", "doExecutes", "submitexecuteRun", "submitexecuteApply", "doSendute", "doexecuteRun", "submitExecute", "doSendutes", "submitexecuteute", "doExecApply", "doexecuteute"], "mapping": ["fapper", "matching", "fapping", "minding", "aminding", "amapping", "amapper", "finding", "mapper", " mapper", " minding", " matching", "amatching", "fatching"], "form": ["flow", "method", "app", "FORM", "forms", "field", "Form", "config", "component", "page", "command", "control", "owner", "definition", "object", "format", "builder", "transform", "url", " forms", "formation", "post", "submit", "dom", "feed", "template", "xml", "pattern"], "request": ["message", "method", "create", "call", "Bytes", "result", "re", "uri", "json", "client", "current", "path", "hello", "session", "Accept", "instance", "frame", "Upload", "s", "this", "model", "use", "view", "HTTP", "input", "complete", "req", "data", "q", "object", "resource", "format", "QUEST", "self", "ware", "url", "name", "add", "server", "requ", "Response", "query", "address", "worker", "queue", "submit", "Reply", "_", "parent", "route", "pull", "reader", "user", "type", "xml", "Request", "report", "context", "application"], "response": ["message", "result", "output", "json", "client", "status", "model", "page", "view", " Response", " responses", "application", "resp", "data", "req", "object", "resource", "Resp", "server", "Response", "res", "handler", "v", "xml", "report", "reply"], "errors": [" status", " flashes", " payload", " translations", " Messages", " session", " commands", " logger", " error", " this", " responses", " warnings", " changes", " replies", " management", " managers", "mess", " acc", " updates", " mess", " messages", " messaging", " problems", " calls", " messenger", " failures", " events", " logs", " streams"], "isMultipart": ["isMultipparts", "isMultippedost", "isMultIPound", "isMultompost", "isMultipost", "isMultipound", "isMultompPart", "isMultipage", "isMultiipound", "isMultIPPart", "isMultompound", "isMultitage", "isMultiipPart", "isMultippart", "isMultIPart", "isMultiIPart", "isMultiated", "isMultippedound", "isMultompart", "isMultiparts", "isMultiipart", "isMultippated", "isMultitart", "isMultiIPost", "isMultippedart", "isMultiIPPart", "isMultIPost", "isMultitarts", "isMultipPart", "isMultippedPart", "isMultiarts", "isMultitated", "isMultippage", "isMultiIPound", "isMultiipost", "isMultiage", "isMultiart", "isMultipated"], "mailInstance": ["fileManager", "fileinstance", "fileInstance", "mailUsage", "emailinstance", " emailinstance", " mailUsage", "emailInstance", "fileUsage", " emailInstance", "mailinstance", " emailUsage", "mailInst", "emailManager", " emailInst", " mailInst", " mailinstance", "mailManager", "emailInst", " mailManager", "fileInst"], "fields": ["types", "parts", "rules", "holders", "locks", "words", "lines", "forms", "field", "lists", "keys", "forces", "s", "groups", "input", "services", "atts", "dates", "data", "gets", "strings", "checks", "cells", "flows", "archives", "objects", "qs", "boxes", "params", "ments", "files", "facts", "utils", "members", "features", "states", "links", "acks", "models", "tags", "pages", "uploads", "views", "details", "loads", "plugins", "packs", "users", "properties", "headers", "changes", "maps", "classes", "comments", "events", "ids", "rows", "posts"], "attachments": ["Attachments", "payments", "attachers", "Attachees", "extions", "exters", "attions", "attees", "attachresses", "attps", "attachlements", "payment", "achresses", "Attachps", "Attachlements", "suppees", "achments", "attachps", "attments", "attachment", " attachment", " attachparts", "attachparts", "attachions", "attment", "Attachions", "extps", "achparts", "atters", "attlements", "achment", "supplements", "payparts", "payresses", "Attachers", "extments", "suppment", "suppments", " attachresses", "attachees", "Attachment"], "items": ["types", "parts", "apps", "locks", "lines", "orders", "lists", "Items", "keys", "ips", "its", "ers", "groups", "data", "names", "objects", "apters", "qs", "files", "reports", "list", "ins", "links", "models", "pages", "plugins", "es", "results", "children", "events", "ids", "alls", "rows", "phones", "ops"], "iter": ["itter", "edit", "inner", "finder", "ver", "ite", "ter", "page", "event", "master", "cher", "i", "keep", "enter", "skip", "upper", "gener", "loc", "ner", "walker", "ir", "ip", "Iterator", "it", "izer", "outer", "Iter", "zip", "altern", "ator", "li", "list", "exp", "former", "chain", "coll", "el", "ul", "inc", "file", "loop", "err", "er", "ser", "end", "reader", "inter", "slice", "iterator", "oper", "order", "http"], "item": ["source", "current", "instance", "event", "extra", "image", "val", "ip", "url", "base", "name", "post", "Item", "li", "temp", "slice", "entry", "type", "section", "volume", "result", "token", "load", "info", "all", "i", "area", "or", "data", "example", "object", "other", "up", "original", "obj", "entity", "api", "layer", "coll", "plugin", "art", "site", "user", "order", "update", "hop", "atom", "issue", "folder", "resource", "next", "container", "element", "attribute", "more", "reader", "get", "app", "widget", "album", "inner", "page", "complete", "anything", "service", "missing", "storage", "it", "server", "index", "handler", "full", "file", "custom", "er"], "aux": ["offs", " auxiliary", "uc", "ups", "uf", "frac", "union", "alias", "buf", "aus", "extra", "etc", " Aux", "data", "des", "ux", "aff", "strings", "amp", "af", "ras", "cas", "ru", "sup", "aw", "array", "lc", "asc", "ext", "ou", "ants", "sub", "lang", "imp", "prefix", "axe", "aos", "fax", "auc", "ox", "off", "abs", "anc", "au", "pkg", "packages", "cmp", "abc", "except"], "part": ["p", "pre", "group", "parts", " Part", "ref", "field", "instance", "f", "point", "info", "back", "component", "per", "one", "word", "po", "l", "pos", "area", "joined", "val", "data", "PART", "object", "format", "act", "on", "action", "and", "class", "error", "base", "name", "b", "add", "change", "fact", "obj", "player", "pi", "ch", "connection", "list", "patch", "but", "layer", "comp", "element", "full", "plugin", "block", "html", "Part", "file", "start", "step", "partial", "key", "art", "diff", "join", "id", "type", "parent", "section", "user", "co", "no", "pair"], "baos": ["BAo", "baoss", "baOs", "baot", "paot", "baoS", "abaosi", " baoS", "BAis", "Bao", " baoss", "baosh", "boOS", "pao", "boo", "BAOs", "BAoss", "haos", "BaOs", " bao", "baOS", "bois", "paOS", "Baos", "BAoS", "Baosi", "abais", "abaOs", " baOS", "BaoS", "bais", "hao", "boosh", "hais", "abaos", "BAosi", "baosi", " bais", "boos", "Bais", "pais", "boot", "bao", "BAos", "paos", "paosh", " baot", "BAosh", "haoss"], "body": ["text", "source", "message", "parts", "media", "summary", "output", "port", "json", "length", "fee", "translation", "flash", "Body", "state", "pass", "options", "tree", "data", "object", "resource", "binary", "comment", "description", "shell", "document", "url", "name", "b", "null", "params", "zip", "query", "string", "header", "connection", "size", "full", "html", "value", "headers", "template", "end", "type", "common", "content", "reply"], "preferencesInstance": ["preffeesinstance", "prefeesinstance", "prefiesinstance", "preffeesClient", "prefirmsClient", "preferencesClient", "prefirmsInstance", "prefeesClient", "prefiesClient", "prefiesInstance", "prefeesInstance", "preffeesInstance", "preferencesinstance", "prefferencesClient", "prefirmsinstance", "prefferencesInstance", "prefferencesinstance"]}}
{"id1": "13757855", "id2": "22993368", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"process": ["call", "create", "output", "parse", "path", "load", "processing", "update", "construct", "view", "processor", "project", "build", "evaluate", "resource", "transform", "proc", "code", "exec", "Process", "submit", "request", "cess", "handle", "run"], "tpl": [" tplates", " tper", "atplug", "qtcp", "tplate", "tcp", "itpl", "tbl", "tper", "Tper", "pPL", "stpp", "Tplates", "tcl", "ttemplate", "qtfc", "tsl", "qtple", " tcl", "tfc", "qtyl", " tfc", "Tpp", "Tplate", "stpl", "qtpl", "Tpl", "itplate", "tplates", "atplate", "ppl", "lple", " tbl", "Tple", "templates", "atml", "templ", "latcp", "itPL", "fplate", " tple", "temPL", "Tcl", "stplate", " tPL", "Tipl", " tsl", "itplates", "tmpl", "lper", "lplate", " tplug", "Tbl", "tml", "tmyl", " ttemplate", "qtbl", "TPL", "pipl", " tml", "psl", "latyl", "lml", "fpl", "pcl", "lPL", "tpp", "temtemplate", "tmcp", " tpp", "tplug", "latpl", "tPL", "lpl", "Tsl", " tplate", "tyl", "Ttemplate", "Tml", "Tfc", "latple", "atpl", "lcl", "stPL", "tmple", "fml", " tipl", "tipl", "fplug", "tple"], "model": ["message", "result", "media", "copy", "json", "language", "config", "param", "command", "project", "Model", "data", "m", "module", "location", "where", "node", "document", "log", "graph", "params", "conf", "body", "models", "xml", "doc"], "packageName": ["PackageName", "groupUrl", "PackageNames", "packageInfo", "projectKey", "contextName", "groupname", "projectname", "modulename", "projectName", "packageUrl", "contextInfo", "contextname", "moduleName", "moduleUrl", "contextNames", " packageNames", "packageNames", " packagename", " packageInfo", "moduleKey", "groupName", "groupKey", "packageKey", "packagename", "projectUrl", "PackageInfo", "Packagename"], "outFileName": ["OutFileName", "inDirEnd", "outfileOnce", " outDirLine", "outFilenameMode", "outFilenamePath", "outFullname", "outDirEnd", "outFileInfo", "outFileOnce", "outfileEnd", "outDirLine", "difffileName", "difffileTime", "outFullTime", " outDirPath", "outStreamInfo", "outStreamType", "outBufferName", "OUTBufferName", "outDirname", "OUTFileMode", "inDirCopy", "diffFileName", "inDirPath", "outFullInfo", " outFilePath", "OUTFileNames", " outFullType", "OUTBufferNames", "outFullPath", "outBufferHalf", "OutFilename", "OUTFileName", " outFileType", "outfileName", " outFullName", "outFileMode", "outBufferNames", "outfileHalf", "outFileNames", "outFilenameCopy", "outLineTime", "outFileTime", "outFilesTime", "diffFileTime", "outBufferMode", "outFilenameEnd", "outRuleName", "outLineInfo", "outRuleInfo", "outFullNames", " outFileLine", "OutDirLine", "outfileCopy", "outFilename", "outLinename", "outfileNames", "inFilePath", "outStreamName", "OutDirNames", " outDirName", "outFilesName", "OutFileNames", "outDirName", "OUTBufferHalf", "difffileOnce", "outFileType", "outFilenameHalf", "difffileInfo", "OUTFileHalf", "outLineLine", "outFullName", "diffFileInfo", "outFilenameName", "outRuleType", "outFileCopy", "outFileHalf", "outLineNames", "OutFileLine", "outfileInfo", "diffFileOnce", "outfilePath", " outDirTime", "outDirInfo", "OUTBufferMode", "outFilesPath", "outDirTime", "OutDirName", "outFileEnd", " outFileTime", "outLineOnce", "outDirCopy", "outfileMode", " outFullInfo", "outLineName", "outFilesLine", "inFileEnd", "OutDirname", "outFullType", "inDirName", "outDirPath", "inFileCopy", "outDirOnce", "outDirNames", "outFilePath", " outFileInfo", "outFileLine", "inFileName", "outFilenameNames", "outfileTime", "outFullLine"], "xsltParam": ["xldMode", "xslpParam", "xsltVal", "xslicVal", "xslicparam", "xldparam", "xsldparam", "xsldVal", "xslpVal", "xltMode", "xslicParam", "xsltparam", "xltVal", "xslicMode", "xslpMode", "xldParam", "xsltMode", "xsldParam", "xslpparam", "xsldMode", "xltParam", "xldVal", "xltparam"], "artifact": ["ARTifest", "Arturation", "aratfact", "ARTifacts", "aratifacts", " artribution", " arturation", "Artifact", "advertifacts", "Artfact", "artfact", " artifacts", "aratifest", "aratifact", "advertribution", "Artifest", "arturation", "advertifact", "artifacts", "artifest", "ARTfact", "ARTifact", "Artifacts", "Artribution", "artribution", "adverturation"], "destinationPath": ["distinatorKey", "destiationLog", "DestinatingPoint", "destinationAuth", "destinateDir", "datinatePath", "destinatorLocation", "restificationLocation", "destificationPoint", "constinationWidth", "constinationPath", "destinationString", "distinationFile", "desturationHandler", " destificationLog", "destificationPart", "destributionDir", "destificationName", "DestinationText", "tempinatedPath", "distinationCase", "destinatingLocation", "DestinationPart", "datinateLocation", "destationTime", "tempinationDir", "distributionDir", "restinationpath", "destinationLocation", "desticationName", "constinatorDir", "desticationFile", "destinatedPath", "DestinationName", "DestificationPath", "destinateLocation", "destinatorStep", "destiationDir", "destinateTime", "restinationString", "tempinationPath", "destinatorFile", "destinatedDir", "tempinationpath", "destinationsPath", "destplingAuth", "destplingPath", "tempinationHalf", "destinatedPoint", "combinatorPath", "destcreationUrl", "destinatePath", "tempinatedpath", "destributionName", "destplingDir", "destinatorKey", "destignmentPath", "destinationName", "constinationsName", "destinationFile", "destinatedFile", "destensionPoint", "destificationpath", "restinatorPath", "destinationHandler", "constinatorContext", "restinationPoint", "destinatingpath", "distinatorPath", "DestinationPath", "desticationKey", "desticationStep", "destplingWidth", "combinatorName", "distinationpath", "constinationName", "destinationTime", "destinatingName", "destinatingText", "restinatorPoint", "datinationLocation", "distinationName", "constinatorUrl", "destinationPart", "destributionCase", "destinatorPath", " destificationDir", "destinationHalf", "destinationDir", "destinationsPoint", "destinatingPoint", "distinatorStep", "DestinatingText", "restificationPoint", "constinationPoint", "destinationKey", "distinatorName", "destationPath", "destinatorCase", "destificationPath", "destificationLog", "destplingUrl", "distinationCry", "combinationHandler", "destinationpath", "destinatePoint", "distinatorCase", "desticationPart", "destinatorString", "DestinatingName", "destinatorContext", "destinatedHalf", "destinatePart", "restinatorString", "destinationCase", "destinatorName", "destinerContext", "destinateHandler", "destiationPath", "combinationPath", "destificationDir", "destributionPath", "restificationpath", "constinationpath", "destinatorHandler", "DestinationPoint", "distinationDir", "destensionPath", "destiningPoint", "combinatorpath", "destinationStep", "destinateString", "destinerpath", "constinationsPath", "distributionPath", "distinationStep", "destinatorHalf", "destationLocation", " destificationAuth", "constinationDir", "destributionpath", "desturationName", "constinatorPath", "destcreationPath", "destiningPath", "DestinatingPath", "destensionText", "destinateText", "constinatorWidth", "destinatorPoint", "destiningpath", "desturationpath", "destinerPath", "combinationName", "destinatedCase", "destinerDir", "destinatedString", "destinatorCry", "destensionName", "destiningContext", "DestificationPart", "destinatorTime", "destignmentCry", "destinationCry", "destationpath", "distinationKey", "distinatorFile", "constinatorpath", "destinationText", " destinationLog", "datinateTime", "destinationPoint", "restinationHalf", "constinationspath", "restinationLocation", "destinationWidth", "datinationTime", "destplingLog", "desturationPath", "destinatorpath", "datinatepath", "distinationPath", "datinationpath", "destinatedpath", "constinationsPoint", "destinatorDir", "destinatingPath", "destributionCry", "destiationAuth", "destiningDir", "destificationAuth", "combinatorHandler", "combinationpath", "destignmentCase", "destinationContext", "destinatorUrl", "distributionCase", "destinatorWidth", "destinateHalf", "constinationContext", "desticationPath", "destcreationWidth", "DestificationName", "tempinatedHalf", "destinationsName", "destiningName", "tempinatedDir", "restinationPath", " destificationPath", "restificationPath", "destificationLocation", " destinationAuth", "destinatedKey", "destinationUrl", "datinationPath", "destignmentName", "destinationLog", "distinatorCry", "destinatepath", "restinatorHalf", "distributionpath", " destinationDir", "destinatedStep", "constinationUrl", "destinateName", "destinationspath"], "in": ["x", "source", "cache", "c", "config", "ex", "i", "input", "image", "IN", "data", "con", "n", "bin", "name", "min", "ins", "connection", "In", "inc", "r", "t", "reader", "din", "d", "doc"], "out": ["source", "group", "result", "copy", "cache", "output", "str", "client", "path", "session", "point", "with", "store", "page", "state", "w", "ex", "all", "manager", "OUT", "dump", "line", "conn", "writer", "sys", "comment", "ne", "io", "up", "log", "name", "outer", "server", "gen", "obj", "post", "msg", "exec", "pool", "index", "list", "string", "connection", "free", "lock", "prefix", "Out", "write", "full", "outs", "again", "Output", "file", "lib", "temp", "version", "part", "err", "cli", "key", "o", "user", "parent", "bin", "error", "doc"], "root": ["history", " roots", "cache", "json", "path", "instance", "cat", "options", "tree", "meta", "xml", "resources", "loader", "module", "format", "Root", "transform", "values", "url", "graph", "params", "modules", "query", "index", "_", "collection", "include", "r", "results", "id", "parent", "node", "pattern", "roots", " result"]}}
{"id1": "22441244", "id2": "20426057", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "18748516", "id2": "16621503", "code1": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"copy": ["p", " copied", "sync", "paste", "download", "all", "Cop", "dump", "move", "cop", " copying", "clone", "clip", " clipboard", "change", "transfer", "zip", "split", "append", "Copy", "write", " Copy", "replace", "put", "file", "diff", "cmp"], "fromFile": ["FromPlace", "addressFilename", "FromFile", "sourceDirectory", "fromFilename", "FromDirectory", "sourcePlace", " fromfile", " fromDirectory", "sourceFilename", "fromPlace", "FromFilename", "fromDirectory", "sourcefile", "addressfile", "fromfile", " fromPlace", "addressDirectory", "sourceFile", "addressFile", "Fromfile"], "toFile": ["toString", "targetfile", "toPlace", "targetString", "throughfile", "tofile", "targetFilename", "throughFILE", "ToFile", " toString", " tofile", "ToFilename", "targetPlace", "targetFile", "throughFile", "outputPlace", "ToString", "toFilename", " toFilename", "outputfile", "toFILE", "outputFILE", "throughPlace", "Tofile", "targetFILE"], "inputFile": [" inputfile", "InputFile", "currentLibrary", "currentFile", "outFile", "inputLibrary", "currentPlace", "outPage", "fromLibrary", "currentfile", "InputStream", " inputStream", "InputPage", " inputStyle", "fromPlace", "outStyle", " inputPage", " inputPlace", "inputfile", "InputStyle", "inputStyle", "inputStream", "fromfile", " inputLibrary", "outStream", "inputPage", "inputPlace"], "outputFile": ["outputPath", " outputfile", "outputDir", "targetfile", "inputFolder", " outputStyle", "targetDir", "inputPath", "outputFolder", "targetFile", "OutputPath", "Outputfile", "targetFolder", "OutputDir", "OutputStyle", "inputfile", "outputfile", " outputDir", "targetPath", "OutputFile", "OutputFolder", "targetStyle", "outputStyle"], "in": ["source", "init", "into", "ln", "inn", "gin", "pin", "inner", "f", "s", "i", "input", "l", "socket", "inside", "image", "sin", "get", "IN", "issue", "con", "win", "ini", "up", "isin", "a", "din", "nin", "min", "ins", "connection", "cin", "lin", "In", "inc", "again", "rin", "file", "pull", "r", "login", "reader", "bin", "ic"], "out": ["as", "cache", "output", "client", "sync", "net", "at", "s", "w", "ex", "one", "i", "to", "OUT", "image", "line", "writer", "other", "io", "n", "up", "error", "b", "null", "outer", "exec", "over", "plain", "Out", "write", "raw", "outs", "again", "off", "file", "parent", "lib", "o", "v", "inc", "outside"], "c": ["p", "x", "cy", "oc", "char", "xc", "current", "uc", "cf", "ac", "f", "e", "i", "pointer", "l", "k", "count", "ci", "m", "ce", "ec", "n", "character", "pc", "b", "col", "lc", "C", "code", "cr", "u", "sc", "ch", "index", "rc", "cc", "nc", "esc", "enc", "cl", "cm", "fc", "cu", "t", "r", "ct", "id", "o", "v", "d", "dc"]}}
{"id1": "6371589", "id2": "17029388", "code1": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"insertUser": ["insertPassword", "InsertPassword", "createUsers", "createPerson", "insertPerson", " insertPassword", "insertUsers", "InsertUsers", " insertUsers", " insertPerson", "createUser", "InsertUser", "createPassword", "InsertPerson"], "newUsers": ["oldUser", "oldPeople", "NEWusers", "newUser", "path", "NewUser", "s", " newUser", "this", "New", "oldUsers", "NewPeople", "newusers", "oldusers", "Newusers", "NewMembers", "All", "newMembers", "NEWPeople", " newMembers", "Get", "_", " newusers", " newPeople", "NewUsers", "NEWMembers", "newPeople", "NEWUsers"], "pass": ["secret", "access", "sw", "ss", "port", "parse", "oss", "push", "session", "clean", "wd", "skip", "pos", "gram", "PASS", "act", "mess", "pa", "log", "col", "asses", "gen", "pool", "post", "cr", "conf", "sl", "Pass", "fr", "fail", "pas", "en", "ass", "def", "ress", "row", "pack", "pp", "mail"], "realmPass": ["almFail", "realfSecret", "realamPassword", "perMPass", "permLink", "realarmPASS", "perfPASS", "realnmAuth", "realarmAuth", "realmTrans", "realfPASS", "realmAuth", "realnmSecret", "almsFail", "realmPack", "realsmLink", "realmsFail", "realarmpass", "realamPass", "realmsPack", "palMPass", "palmpass", "realmeConf", "almsPass", "permAuth", "realnmPass", "realMpass", "realampass", "realmLink", "realfAuth", "almConf", "perfPass", "reallFail", "almPass", "realmConf", "realMPass", "permPack", "perMLink", "reallConf", "perMPassword", "realarmFail", "realmsConf", "perMPack", "realmsPassword", "realmFail", "realarmPass", "almsConf", "permPassword", "realsmPack", "permPASS", "realMFail", "perfAuth", "palMpass", "realarmSecret", "almsTrans", "perfSecret", "realmePass", "realMPack", "palmPassword", "reallTrans", "realMLink", "realmSecret", "almTrans", "realmsPass", "realmsTrans", "realmsLink", "palmPass", "realnmPASS", "permSecret", "realmeTrans", "palmFail", "realsmPass", "realmPassword", "realarmPassword", "realfPass", "realsmPassword", "palMPassword", "realMPassword", "realmeFail", "realmPASS", "reallPass", "permPass", "palMFail", "realamFail", "realmpass"], "userDirs": ["userDir", "UserIdir", "userDict", "UserDict", "userIdict", "userEdirs", "UserDir", "UserIdirection", "userDirirection", "userIdir", "userIdirs", "userDirection", "userIdirection", "UserDirs", "userDirirs", "userDirict", "UserDirection", "userEdirection", "UserIdirs", "UserIdict", "userEdict", "userDirir", "userEdir"], "iter": ["inse", "itter", "parse", "inner", "finder", "f", "ite", "ter", "its", "master", "cher", "driver", "ler", "ie", "i", "keep", "enter", "upper", "gener", "loader", "ner", "walker", "liter", "ir", "itor", "n", "Iterator", "iv", "it", "outer", "ipper", "izer", "Iter", "sel", "zip", "oper", "ator", "sl", "li", "vis", "imp", "former", "chain", "handler", "coll", "ul", "exit", "loop", "err", "er", "feed", "icer", "end", "reader", "inter", "keeper", "inc", "slice", "http"], "user": ["source", "message", "who", "current", "session", "to", "project", "image", "comment", "url", "name", "log", "u", "post", "rule", "profile", "replace", "creator", " result", "group", "result", "ver", "model", "use", "word", "usa", "or", "by", "data", "module", "object", "other", "force", "self", "up", "job", "using", "plugin", "used", "users", "site", "parent", "member", "order", "account", "me", "match", "update", "not", "e", "line", "USER", "resource", "from", "valid", "character", "theme", "string", "option", "fill", "User", "human", "author", "date", "page", "person", "per", "manager", "blog", "record", "service", "open", "ru", "server", "change", "lock", "usr", "full", "file", "request", "route", "row", "custom", "er"], "realm": ["realf", "palms", "realM", "palme", "palM", "realma", "alme", "Realms", " realf", " realp", "palp", "alm", " realma", "Realme", "alf", "elema", "Realm", "elef", "eleme", "RealM", " realM", "palm", "alma", "realme", "realp", "elem", "Realp", " realme"], "username": ["attr", "source", "su", "property", "ug", "current", "session", "config", "alias", "slave", "nick", "auth", "directory", "url", "name", "sword", "null", "picture", " nickname", "time", "direction", "true", "profile", "uu", "mobile", "token", "uri", "hello", "ame", "home", "component", "phrase", "ghost", "consumer", "email", "sudo", "gender", "password", "verb", "plugin", "nil", "account", "me", "method", "whatever", "role", "language", "ername", "purpose", "driver", "mother", "resource", "description", "character", "subject", " password", "string", "prefix", " slug", "attribute", "href", "login", "month", "uid", "human", "filename", "phone", "length", "title", "person", "family", "ident", "nom", "manager", " hashtag", "localhost", "duration", "database", "host", "address", "begin", "usr", "ruby", "Password", "route", "rights"], "ph": ["p", "ht", "th", "aph", "bh", " che", " guide", " exp", "phil", "mm", " p", "pl", "phrase", "per", " poly", "pal", "uth", "hw", "kh", " arch", "rah", " auth", "auth", "prof", "prot", "gh", "pa", "Ph", "fo", " sh", "iph", "pe", "password", "conf", "sl", "ch", "li", "wh", "h", "pha", "hi", "arch", "cl", "hp", "ap", "sh", "php", " mg", "PH", "eth", "oph", "eph", "her", "fam", "pkg", "rh", " ssh", "mph", "phi"], "realms": ["palns", "palms", " realmes", "Realfaces", "almes", "alns", "palfaces", "Realms", "alm", "Realmes", "realfaces", " realfaces", "Realm", "palm", "alms", "realmes", "realns", "Realns", "palmes"], "realmName": ["realmPart", "agmString", "realmPath", "agmPath", "realnString", "workmsN", "agmName", "workmsPart", "realcmName", "realmsCode", "realmeNames", "realmsNames", "workmN", "agmsName", "realnName", "realmeName", "workmsCode", "realmeString", "realrmN", "realcmCode", "realmsName", "realmN", "agmNames", "realmCode", "realnNames", "realrmName", "realmsN", "agmsString", "realmsPath", "workmCode", "realmsPart", "realmsString", "realmString", "realrmPart", "realmePath", "workmName", "realrmCode", "agmsPath", "realmNames", "realcmN", "realcmPart", "realnPath", "workmsName", "workmPart", "agmsNames"], "psImpl": ["psFactory", "ptyImpl", "sqlimpl", "ptyFactory", " connimpl", "psBuilder", "sqlBuilder", "sqlImpl", " connFactory", "ptyimpl", " connBuilder", "psimpl", " connImpl", "ptyBuilder", "sqlFactory"], "iterator": ["sequence", "forward", "inner", "instance", "ter", "enter", "gener", "loader", "walker", "Iterator", "choice", "it", "random", "outer", "ui", "ator", "append", "li", "size", "former", "stream", "creator", "collection", "entry", "inter", "adder"]}}
{"id1": "23161545", "id2": "1371265", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomUid", "getRandomUUID", "getRandomGCID", "getRandGUID", "getRandGuid", "getRandGID", "getRandomGCUID", "getRandomGuid", "getRandUUID", "getRandUid", "getRandomIGID", "getRandGid", "getRandomIGid", "getRandomUuid", "getRandomGID", "getRandUID", "getRandomGCuid", "getRandomIGUID", "getRandomGid", "getRandomUID", "getRandomIGuid", "getRandomGCid", "getRandUuid"], "secure": ["secret", "remote", " insecure", "depth", "session", "config", "https", "use", "timeout", "seed", "unsigned", "service", "proxy", "ce", "stable", "weak", "force", "sr", "smart", "sec", "deep", "security", "random", "server", "allow", "host", "zip", "sensitive", "Secure", "external", "require", "confirmed", "encrypted", "safe", "pure", "secondary", "exclusive", "ssl", "protect", "debug", "active"], "md5": [" md500", "MDql", "md2", " md11", "md500", " md3", " MD11", " MD3", "cmd3", "cmdql", "md512", " mdql", "md3", " md2", "MD2", "cmd512", "MD5", "MD11", "cmd5", "mdql", "MD512", " MD500", " MD5", "md11", " md512", " MD2", "MD3", "MD500"], "sbValueBeforeMD5": ["sbValueBeforeMD1", "sbValueBeforeMD65", "sbValueBeforemd25", "sbValueAfterMD65", "sbValueBeforeMAC3", "sbValueBeforeMD7", "sbValueBeforeMS375", "sbValueBeforeMC5", "sbValueAfterMD7", "sbValueAfterMD0", "sbValueBeforeMD0", "sbValueBeforeMI5", "sbValueAfterMD95", "sbValueBeforeDER5", "sbValueBeforemd512", "sbValueBeforeSHA1", "sbValueBeforeDER3", "sbValueBeforeMD25", "sbValueAfterMD25", "sbValueBeforeMD20", "sbValueGivenMD375", "sbValueAfterMS0", "sbValueBeforeMAC55", "sbValueBeforeMD005", "sbValueAfterMS20", "sbValueGivenMD5", "sbValueAfterMS65", "sbValuebeforeMD1", "sbValueBeforeDER20", "sbValueBeforeMS3", "sbValueBeforeMR5", "sbValueBeforeMD75", "sbValueBeforeMAC5", "sbValueBeforeMS95", "sbValueBeforeMP3", "sbValueGivenMD512", "sbValueBeforeMI20", "sbValueBeforeMR3", "sbValuebeforeMD20", "sbValueBeforeSHA20", "sbValuebeforeMD005", "sbValueBeforeMS512", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeAMD1", "sbValueBeforeD75", "sbValueBeforemd75", "sbValueBeforemd95", "sbValueGivenmd512", "sbValueBeforeMD3", "sbValueBeforeMS65", "sbValueBeforeSD20", "sbValueAfterMP1", "sbValueGivenmd3", "sbValueBeforeMI3", "sbValueAfterMS95", "sbValueBeforeMS20", "sbValueBeforeMC512", "sbValueBeforeMD55", "sbValueAfterMD5", "sbValueBeforeDER55", "sbValueBeforeMI7", "sbValuebeforeSD1", "sbValueBeforeDER0", "sbValueBeforemd65", "sbValueBeforeMS1", "sbValueBeforeSHA5", "sbValueBeforemd3", "sbValueBeforeMR25", "sbValueBeforeAMD3", "sbValueBeforeD3", "sbValueAfterMS3", "sbValueAfterMS25", "sbValueBeforeMS25", "sbValuebeforeSD20", "sbValueBeforeD65", "sbValueBeforemd5", "sbValueBeforeMS5", "sbValueBeforeMP5", "sbValueGivenmd5", "sbValueAfterMD75", "sbValueBeforeMD375", "sbValueBeforeSD5", "sbValueBeforeMS75", "sbValueBeforemd375", "sbValueBeforeMP7", "sbValueBeforeDER005", "sbValueAfterMS55", "sbValueAfterMS5", "sbValuebeforeSD5", "sbValueBeforeSD005", "sbValueAfterMP7", "sbValueAfterMS75", "sbValueAfterMD20", "sbValueAfterMP3", "sbValueBeforeMS7", "sbValueBeforeAMD20", "sbValueGivenmd375", "sbValueBeforeMS55", "sbValueBeforeMI1", "sbValueBeforeMC375", "sbValueBeforeMR95", "sbValueBeforeDER1", "sbValueBeforeMS0", "sbValuebeforeMD5", "sbValueBeforeSD1", "sbValueGivenMD3", "sbValueBeforeAMD5", "sbValueBeforeMC3", "sbValueAfterMD55", "sbValueBeforeMP1", "sbValueAfterMD3", "sbValueBeforeMD512", "sbValuebeforeSD005", "sbValueBeforeSHA005", "sbValueBeforeMAC0", "sbValueBeforeMD95", "sbValueBeforeD5", "sbValueAfterMP5"], "time": ["work", "mode", "depth", "timer", "length", "date", "etime", "event", "tz", "timeout", "seed", "Time", "tim", "count", "loc", "year", "duration", "hour", "money", "speed", "TIME", "name", "random", "host", "counter", "ime", "delay", "race", "times", "size", "clock", "value", "version", "cost", "slice", "id", "rate", "type", "user", "start", "error", "offset"], "rand": ["right", "ro", "depth", "clean", "risk", "reg", "rr", "seed", "root", "Rand", "max", "raid", "rank", "count", "year", "q", "pick", "win", "bot", "round", "bit", "random", "gen", "cr", "mid", "res", "chance", "index", "rc", "delay", "rule", "lang", "min", "alpha", "ng", "range", "rage", "serial", "winner", "version", "r", "id", "rate", "type", "rh", "error", "rol", "order"], "valueBeforeMD5": ["valueBeforeAMD53", "valueInsideMD5", "valueInsideMD85", "valueBeforeMP53", "valueBeforeAMD5", "valueBeforemd3", "valueBeforemd85", "valueBeforemd5", "valueBeforeMD85", "valueBeforeAMD2", "valueInsideMD3", "valueAfterMD53", "valueAfterAMD53", "valueBeforemd2", "valueBeforeMC85", "valueBeforeMC3", "valueBeforeAMD3", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueBeforeMC5", "valueBeforeMD53", "valueBeforeMC2", "valueAfterAMD3", "valueBeforeMP2", "valueBeforeMP5", "valueInsideMD2"], "array": ["vector", "message", "app", "result", "shape", "expression", "arr", "cache", "ray", "feature", "instance", "our", "archive", "view", "area", "angle", "image", "data", "record", "object", "binary", "storage", "air", "integer", "database", "allow", "function", "number", "address", "api", "string", "list", "arrow", "element", "range", "batch", "sample", "value", "collection", "Array", "row", "any", "section", "error", "audio", "pair"], "sb": ["lp", "sbm", "bh", "buffer", "ab", "xb", "SB", "obb", "bb", "fb", "s", "buf", "lab", "bj", "sg", "pb", "src", "bl", "mb", " SB", "bp", "kb", "ib", "zb", "binary", "bf", "lb", "sth", "sa", "nn", "si", "bc", "rob", "bt", "usb", "nb", "bs", "sl", "rb", "eb", "gb", "bm", "BB", "lr", "orb", "sq", "ruby", "bsp", "wb", "sf", "ob", "sv", "cb", "abb", "stab"], "j": ["p", "x", "out", "ij", "length", "z", "br", "c", "jl", "f", "bj", "ii", "e", "i", "ie", "l", "k", "aj", "q", "n", "g", "job", "v", "jj", "num", "ja", "code", "obj", "ji", "ch", "li", "index", "dy", "jp", "pr", "y", "part", "key", "adj", "uj", "o", "end", "J", "js", "d", "jo"], "b": ["p", "x", "ab", "bar", "br", "cb", "c", "f", "bb", "fb", "e", "i", "pb", "l", "k", "mb", "B", "ib", "binary", "bf", "lb", "n", "bi", "be", "a", "bit", "bc", "job", "nb", "bs", "eb", "rb", "BB", "orb", "y", "bug", "ob", "bin", "db", "d"], "valueAfterMD5": ["valueAfterMP2", "valueAfterMP3", "valueAfterVM2", "valueAfterVM3", "valueAfterVM5", "valueAfterMD7", "valueBeforeMD7", "valueAfterAMD7", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterMP7", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueAfterVM7", "valueAfterAMD3", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMP5", "valueBeforeMP7"]}}
{"id1": "2808955", "id2": "8667872", "code1": "    @Override\n    public EntrySet read(EntrySet set) throws ReadFailedException {\n        if (!SourceCache.contains(url)) {\n            SSL.certify(url);\n            try {\n                super.setParser(Parser.detectParser(url.openStream()));\n                final PipedInputStream in = new PipedInputStream();\n                final PipedOutputStream forParser = new PipedOutputStream(in);\n                new Thread(new Runnable() {\n\n                    public void run() {\n                        try {\n                            OutputStream out = SourceCache.startCaching(url);\n                            InputStream is = url.openStream();\n                            byte[] buffer = new byte[100000];\n                            while (true) {\n                                int amountRead = is.read(buffer);\n                                if (amountRead == -1) {\n                                    break;\n                                }\n                                forParser.write(buffer, 0, amountRead);\n                                out.write(buffer, 0, amountRead);\n                            }\n                            forParser.close();\n                            out.close();\n                            SourceCache.finish(url);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n                super.setIos(in);\n            } catch (Exception e) {\n                throw new ReadFailedException(e);\n            }\n            return super.read(set);\n        } else {\n            try {\n                return SourceCache.get(url).read(set);\n            } catch (IOException e) {\n                throw new ReadFailedException(e);\n            }\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"read": ["work", "create", "copy", "current", "Read", "reading", "parse", "check", "ry", "ping", "load", "update", "http", "view", "READ", "input", "send", "skip", "socket", "process", "data", "readable", "build", "close", "resource", "open", "ic", "play", "weak", "find", "print", "next", "add", "search", "exec", "query", "reads", "index", "scan", "stream", "write", "block", "iter", "wait", "es", "request", "feed", "reader", "get", "start", "select", "fill", "run", "content"], "set": ["source", "SET", "init", "reset", "cache", "sync", "parse", "session", "load", "update", "config", "store", "use", "state", "seed", "send", "src", "et", "or", "object", "resource", "context", "ut", "url", "base", "name", "spec", "server", "setup", "rule", "size", "settings", "sets", "test", "ssl", "setting", "entry", "site", "end", "id", "type", "get", "start"], "in": ["p", "source", "init", "cache", "inn", "gin", "client", "pin", "inner", "f", "i", "input", "socket", "src", "image", "IN", "data", "ini", "win", "con", "resource", "on", "io", "url", "it", "min", "ins", "spin", "In", "inc", "again", "file", "pull", "ssl", "login", "id", "reader", "bin", "ic"], "forParser": ["foreParser", "ForReader", "foreMaster", " forJar", "ofListener", "withJar", " forFile", "withParser", "forReader", "ForFile", "ForParser", "forJar", " forparser", "foreReader", "withFile", "ofParser", "ofReader", "withparser", "forFile", " forMaster", "forparser", "foreparser", " forListener", "forMaster", "Forparser", "ForJar", " forReader", "forListener", "ofJar", "ForListener", "ForMaster"], "out": ["source", "init", "app", "copy", "cache", "output", "sync", "client", "net", "inner", "page", "ex", "i", "to", "socket", "conn", "OUT", "image", "writer", "io", "up", "url", "log", "os", "null", "outer", "ext", "exec", "Out", "outs", "again", "inc", "file", "err", "ssl", "cli", "o", "parent", "bin", "co", "can", "http"], "is": ["as", "ris", "ps", "im", "IS", "isa", "us", "was", "ai", "s", "its", "are", "iss", "i", "Is", "ci", "sin", "or", "ib", "lis", "does", "ir", "vs", "ip", "isin", "url", "os", "ui", "fs", "bs", "isl", "api", "isi", "ins", "ais", "ios", "iris", "id", "bis", "has", "ri", "ois"], "buffer": ["sequence", "source", "cache", "uri", "length", "memory", "buff", "info", "buf", "page", "seed", "bytes", "slave", "phrase", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "null", "server", "counter", "transfer", "address", "Buffer", "delay", "channel", "size", "queue", "layer", "repeat", "batch", "reference", "iter", "feed", "slice", "reader", "bin", "offset"], "amountRead": ["poolWrite", "AmountReader", "weightBuild", "AmountHandle", " numberHandle", "enoughReader", "poolRead", "AmountWrite", "lengthWrite", "numberRead", "AmountRead", "lengthHandle", " amountWrite", "numberWrite", "enoughRead", " numberLoad", "weightLoad", " amountReader", "numberReader", " numberRead", "enoughWrite", "poolLoad", "amountLoad", "AmountLoad", " amountStart", "amountReader", "weightReader", " amountLoad", "amountWrite", "amountHandle", "AmountStart", "enoughStart", "amountStart", "AmountBuild", " numberWrite", "poolReader", "weightRead", " amountBuild", "numberLoad", "lengthRead", "amountBuild", "lengthLoad"]}}
{"id1": "16557837", "id2": "19739421", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["transferfromFile", "copyfromFile", "copyFileFrom", "copyFromFile", "copyFromFrom", "transferFromTo", "copyFromWith", "transferfromWith", "transferFromFrom", "copyDirTo", "copyDirFrom", "copyfromTo", "copyfromFrom", "copyDirFile", "copyFileWith", "copyFileFile", "copyDirWith", "transferFromWith", "transferfromTo", "transferFromFile", "transferfromFrom", "copyfromWith", "copyFileTo"], "srcFile": ["sourceDir", "srcfile", "destfile", "rcFiles", "sourceSourceFile", "rcFile", "srcPage", "destDir", "srcSourceFile", "rcDir", "srcPath", " srcPage", "rcfile", "sourcePath", " srcSourceFile", "srcClass", " srcClass", " srcDir", " srcFiles", "sourceClass", "srcFiles", "sourcefile", " srcfile", "rcSourceFile", " srcPath", "sourceFiles", "rcPage", "destClass", "rcPath", "destPage", "srcDir", "destSourceFile", "sourceFile", "destFiles"], "destFile": [" destinationFine", "destfile", " destFilename", "Destfile", " destinationPage", "wbFiles", "southFile", " destPath", " destDir", "destDir", "destPlace", "destFine", "destFilename", "destroyPage", "destroyFile", "DestDir", "defaultfile", "DestFiles", "defaultDir", "destPath", " destinationfile", " destPage", "targetDir", "targetFiles", "defaultFiles", " destFiles", "targetFile", "southPlace", "defaultFile", "destroyFilename", " destinationFile", "wbFilename", " destinationFilename", " destFine", "targetPath", "DestSourceFile", " destfile", "southFilename", "DestFile", "srcPlace", " destSourceFile", "destPage", " destinationFiles", "destroyFine", "srcDir", " destPlace", " destinationDir", "destSourceFile", "DestPath", "southDir", "srcFilename", "destFiles", "wbSourceFile", "DestFilename", "wbFile"], "in": ["p", "x", "source", "as", "init", "inn", "pin", "inner", "c", "ac", "f", "i", "input", "socket", "inside", "image", "ci", "IN", "con", "win", "ini", "io", "n", "bin", "isin", "url", "b", "is", "nin", "min", "index", "ins", "h", "connection", "channel", "cin", "Out", "lin", "In", "inc", "again", "like", "rin", "file", "part", "pull", "r", "err", "login", "o", "reader", "id", "din", "co"], "out": ["source", "cache", "json", "session", "extra", "to", "image", "down", "comment", "url", "base", "name", "log", "ext", "code", "post", "channel", "write", "In", "off", "key", "error", "pre", "group", "copy", "client", "sync", "this", "dump", "OUT", "conn", "IN", "writer", "win", "io", "up", "job", "ou", "obj", "term", "raw", "auto", "outs", "lib", "cli", "diff", "user", "parent", "bin", "call", "output", "point", "state", "note", "input", "socket", "line", "sys", "resource", "ger", "outer", "gen", "ico", "string", "prefix", "Out", "o", "inc", "doc", "no", "net", "inner", "c", "store", "page", "cmd", "ex", "window", "server", "exec", "query", "connection", "list", "lock", "again", "file", "part", "err", "co"], "fis": ["flios", "foss", "cfios", "cfris", "flis", "flos", "cfi", "gi", "pris", "his", " foss", "pos", "hos", "fris", "hios", "Fos", "lis", "pis", "Fis", "gos", " fais", "frris", "fais", " fIs", "los", "cfis", "Fris", " fi", "lais", "li", "fios", "hi", "fli", "gais", "cfoss", "fross", "fi", "fIs", "pIs", "fros", "FIs", "cfos", "gis", " fris"], "fos": ["infos", "foss", "Faos", "tis", "bos", "foes", "flos", "boes", "Fo", "Foes", "eis", "gose", "gout", "po", "pos", "faos", "Fos", "flose", "infoss", "lis", "fics", "pis", "Fis", "fout", "gos", "infis", "flo", " foes", "fo", " fout", "poes", "bics", "los", "fose", " fo", "toes", "infose", "eos", "tos", "loss", "flout", "eose", " faos", "tics", "paos", "bis", "eoss", "lose", " fose", " fics", "go"], "srcModified": ["srcMinIFIED", " srcModification", "srcModined", "srcMinified", "srcXined", " srcModressed", "srcModIFIED", "sourceModification", "srcXification", "sourceMinify", "sourceModify", "srcModification", "srcVerined", "srcModressed", "sourceMinIFIED", " srcModIFIED", "srcMetification", "sourceModified", "srcXed", "srcModed", "sourceModIFIED", "srcmodIFIED", "srcMetIFIED", "srcmodified", "sourceMinified", " srcModed", " srcModined", "srcMinification", "srcmodressed", "srcVerified", "srcMetified", "srcMetressed", "srcModify", "srcMinify", "srcVerification", "srcXified", "srcVered", "srcmodification", "srcmodify", "sourceMinification"]}}
{"id1": "12078471", "id2": "13644375", "code1": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"tryLoadURL": ["tryLoadingString", " tryLoadUrl", " tryReadURL", "tryloadUrl", "tryloadString", "tryLoadingURL", "tryloadSSL", "tryReadSSL", " tryLoadSSL", "tryReadString", "tryReadURL", "tryLoadSSL", "tryLoadingSSL", " tryReadSSL", "tryLoadingUrl", "tryReadUrl", "tryLoadString", " tryReadString", "tryLoadUrl", " tryLoadString", "tryloadURL", " tryReadUrl"], "url": ["text", "source", "filename", "uri", "str", "path", "language", "Url", "download", "config", "f", "page", "link", "input", "l", "image", "loc", "service", "location", "resource", "base", "name", "server", "host", "URL", "address", "sl", "connection", "string", "ur", "ll", "file", "version", "ssl", "href", "feed", "id", "xml", "http"], "format": ["form", "method", "style", "filename", "mode", "str", "language", "feature", "field", "feat", "f", "config", "info", "at", "environment", "et", "agent", "writer", "magic", "object", "transform", "print", "export", "and", "class", "platform", "stage", "Format", "host", "printf", "function", "api", "handler", "settings", "filter", "value", "version", "file", "attribute", "key", "template", "feed", "atter", "unit", "type", "pattern", "att", "content"], "c": ["p", "cs", "client", "cf", "ac", "f", "tc", "e", "i", "l", "conn", "ci", "m", "con", "ce", "ec", "n", "pc", "b", "lc", "conv", "C", "u", "cr", "exec", "sc", "ch", "rc", "cc", "nc", "connection", "cp", "enc", "cm", "cl", "coll", "fc", "cd", "cu", "cn", "mc", "r", "ct", "ctx", "cb", "d", "dc"], "data": ["p", "text", "source", "message", "result", "buffer", "media", "output", "json", "str", "DATA", "empty", "f", "s", "bytes", "input", "da", "in", "resource", "storage", "ata", "a", "name", "database", "base", "u", "dat", "body", "string", "connection", "alpha", "stream", "value", "key", "response", "id", "reader", "o", "type", "bin", "d", "la", "content"], "model": ["lp", "message", "form", "style", "copy", "fp", "json", "client", "instance", "f", "config", "view", "l", "ca", "image", "Model", "m", "module", "record", "object", "builder", "ga", "document", "base", "bel", "lc", "server", "code", "zip", "query", "child", "api", "models", "channel", "handler", "layer", "coll", "cm", "value", "file", "row", "df", "response", "feed", "reader", "type", "parent", "xml", "pattern", "content"]}}
{"id1": "17083703", "id2": "19608872", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"savaRolePerm": ["sqlRolePerM", "sqlRolePERM", "sqlRolePERm", "sqlRoleperm", "sqlRolePermission", "sqlRolePerms", "sqlRolePerm", "sqlRolePERms", "sqlRolepermission", "sqlRolePERmission", "sqlRoleperM", "sqlRoleperms"], "roleid": ["teamid", "roId", "RoleId", "resourceId", "roleID", "teamId", "Roleinfo", "resourceID", "rolename", "resourceid", "roleinfo", " rolename", "resourcename", " roleids", "roleids", "roid", " roleID", "teamID", " roleId", "roinfo", " roleinfo", "Roleids", "roleId", "teamname", "Roleid", "roids"], "role_perm_collect": ["role_permpcol", "role_perm_cont", "role_permpcollect", "role_per_set", "role_perm__collection", "role_per_collect", "role_per_collection", "role_perm__collect", "role_permpcont", "role_perm_ignore", "role_permfCollect", "role_per_map", "role_perm_col", "role_perm__ignore", "role_per_ignore", "role_perm_coll", "role_perm_map", "role_permpCollect", "role_permfcol", "role_permfcollection", "role_perm_set", "role_perm_collection", "role_per_cont", "role_permamcollect", "role_perm__cont", "role_per_coll", "role_permfcollect", "role_perm__map", "role_permamignore", "role_per_Collect", "role_perm_Collect", "role_permammap", "role_permamcollection", "role_per_col", "role_permpcollection"], "cp": ["p", "tp", "CP", "cs", "fp", "mp", "cf", "c", "CF", "ca", "Conn", "cdn", "DC", "ph", "bp", "pg", "cop", "gp", "pc", "proc", "pool", "orp", "cr", "pd", "ch", "priv", "cc", "cm", "cpp", "hp", "dp", "pr", "cd", "jp", "cn", "mc", "pp", "ct", "pkg", "ctx", "pm", "cb", "cmp", "dc"], "conn": ["p", "org", "cmp", "util", "uc", "client", "oss", "cf", "sync", "cb", "c", "ac", "cat", "config", "reg", "Connection", "nt", "po", "ca", "Conn", "ci", "loc", "con", "close", "pg", "act", "ec", "n", "connect", "core", "error", "pc", "ann", "col", "ou", "server", "exec", "orp", "cr", "res", "ch", "connection", "cc", "nc", "lock", "enc", "coll", "pr", "fail", "oci", "sql", "ok", "cn", "mc", "ssl", "dn", "ct", "ctx", "db", "co", "dc"], "rs": ["ls", "eps", "ris", "cs", "rx", "ps", "ss", "mr", "ds", " rows", "RC", "RS", "rm", "os", "rl", "rep", "res", "rc", "Rs", "xs", "pr", "runs", "ns", "rt", "ows", "row", " Rs", "rows"], "pstmt": [" pstnt", "Pstmb", " pvmb", " pstmn", "pconstmb", "postm", "pvml", " pstml", "pvmn", "pStm", "pscmt", " psthm", "psthmd", "pftdt", "Pstm", "Pctwd", "pdnt", "pstbm", "postma", "pctmd", "pdmb", "pstmn", "pdmt", " postm", "Pstbm", " pftnt", "psthpo", "pctpo", "pstdr", "pptm", " postmt", "pattpo", "pctmit", "Pctst", "pstml", "pftst", " pssmb", "psthm", "psthmt", "pstpo", "psthdt", "pfmr", " pssnt", " postnt", " pvmn", "Pstnt", "pctml", "pctmr", "pftnt", "Pctbm", "pvmt", " pftmt", " psthpo", "pssmb", "pngmt", " pstdr", "pctdr", "postmb", " pssdr", "pctmb", "Pstmt", "pftm", "pptmt", "pattm", "pscnt", "pddr", "pstmit", " pvml", "pattmd", "pstmd", "pctmc", "pssmt", "pctm", "pstnt", "pwdmt", "Pstst", "pfmt", "Pctmt", "pspmr", "pfmit", "Pctmc", "pStwd", "pwdm", " pstmp", "pStma", "pspm", "Pstmc", "pattmt", "Pstwd", "Pctmb", "pctmn", " pstmb", "pctdt", "pStmb", " pvmt", "Pctma", "pngmit", "pstmr", "Pctdt", "Pstdt", " pftmp", "pfm", "pconstwd", "Pctm", "Pctmit", " pstmd", "pStnt", "pscmc", "pctmt", " psthmd", "psthml", "Pstma", "pStmt", " pftm", "pctnt", "pssdr", " pstpo", "Pctmr", "Pstmp", "pctbm", "pstm", "pssnt", "postnt", "psthmb", "pconstma", " psthmt", " pstm", "pngm", "pspmt", "pptmp", "pstst", "psthmn", "pngmb", "pstmc", " pssmt", "Pctnt", "pctmp", "pstma", "pconstmt", "pvmb", "pfmb", "pfmp", "Pctmp", "pptnt", "psthnt", "postmt", "pscmb", "pstdt", " postma", "pwdbm", "pstmp", "pstmb", "Pstmit", "postmc", "pctma", "pftmp", "pftmt", "psthst", "pstwd", "pctwd", "pwdnt", " pstma", "pspmp", "Pstmr", "pctst"], "factory": ["familyactory", "vixture", "Flux", "miller", "ciller", "fFactory", "fiactory", "mactory", "fiille", "familyille", "flier", "Factory", "flux", "fiFactory", "vactory", "familylux", "filler", "Fille", "clier", "FFactory", "filux", "viller", "familyFactory", "mixture", "cixture", "vlier", "fixture", "cactory", "mlier", "fille"], "op": [" Op", "oc", "Op", " cop", " app", "OP", " os", " parent", " operator", " ops", " org", "or", "Oper", " auth", " http", " OP", " ori", "Ops", " opt", "operation", " Operation", " co", "o", " operate", " project", "oper", "Operation", "ops"], "role_perm_ir": ["role_perm_reader", "role_perm_IR", "role_permqreader", "role_per_irt", "role_per_ire", "role_perm_iter", "role_per_iter", "role_per_ir", "role_perm_irt", "role_permidir", "role_permidire", "role_priv_IR", "role_permiditer", "role_perm_nir", "role_per_reader", "role_priv_nir", "role_perm_ior", "role_priv_ir", "role_permqir", "role_priv_iter", "role_perm_ire", "role_permqior", "role_permidirt", "role_per_ior", "role_permqiter"], "rolePerm": ["RoleAdM", "rolePartM", "rolePERm", "rolePmission", " rolePerms", "roleParp", "rolepermission", "rolePERms", "rolePerM", "rolPermission", "roleElms", "roleElm", "RolePerr", "rolePerr", "rolePrivm", "rolePrivms", "RolePartms", "RoleAdr", "rolPerm", "rolePartmission", "rolePERmission", "rolPerM", "roleAdr", "rolePrivmission", "roleperp", "roleParm", "rolePrivr", "roleperm", "rolPerms", "rolePerp", "roleElM", "rolePp", "roleperms", "RoleAdm", "rolElmission", "RolePerm", "rolePerms", "roleAdM", "rolePrivM", "rolePartm", "roleParmission", "RolePerms", "rolePm", "roleElmission", "RolePerM", "roleParms", "rolElms", "RolePartM", "rolePartms", "rolePERr", "rolElm", " rolePmission", "RolePermission", " rolePms", "rolePERM", "rolElM", " rolePermission", " rolePp", "rolePms", " rolePerp", "RolePartmission", "rolePermission", " rolePm", "RolePartm", "roleAdm"]}}
{"id1": "12579075", "id2": "8747840", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFormsystemperties", "loadFormsystemproperty", "loadFromLocalString", "loadFormSystemproperty", "loadFromLocalProperty", "loadFromsystemperties", "loadFromSysperties", "loadFromSysproperty", "loadFormsystemString", "loadFromsystemProperty", "loadFromLocalproperty", "loadFromSystemproperty", "loadFromSysString", "loadFormSystemperties", "loadFormsystemProperty", "loadFromSysProperty", "loadFromsystemString", "loadFormSystemString", "loadFromsystemproperty", "loadFromSystemperties", "loadFromSystemString", "loadFromLocalperties", "loadFormSystemProperty"], "propertyName": ["propStr", "propertyNames", " propertyStr", "propPath", "filePart", "propertyPart", "PropertyStr", "propertyPath", "PropertyName", " propertyString", "propName", "propertyStr", "fileNames", " propertyNames", "fileName", "propPart", "fileString", "propertyValue", "propString", "PropertyPath", "propValue", " propertyValue", "propertyString", "PropertyValue", "propNames", " propertyPart", " propertyPath"], "urlStr": ["UrlName", "urlText", "urlName", "URLWr", "uristr", "Urlstr", "URLString", " urlText", "UrlWr", "URLstr", "uriStr", "uriWr", "UrlText", "httpStr", "urlstr", "urlSt", "httpstr", "httpText", " urlSt", "URLSt", "URLStr", "resourceString", "uriName", "resourceStr", " urlString", " urlWr", " urlstr", "urlWr", " urlName", "URLName", "urlString", "resourceSt", "UrlStr", "UrlString", "httpName", "UrlSt"], "in": ["p", "source", "as", "init", "inn", "gin", "out", "client", "cf", "session", "inner", "c", "ac", "f", "i", "input", "l", "socket", "serv", "conn", "image", "src", "IN", "data", "m", "con", "ini", "resource", "n", "isin", "bin", "a", "din", "fac", "is", "nin", "min", "ins", "cin", "stream", "In", "again", "file", "part", "r", "err", "login", "ssl", "id", "reader", "inc", "ic", "doc"], "xmlDoc": [" xmlStr", " xmlConfig", " xmlDom", "jsonDocument", "jsonStr", "mlDocument", "xmlDom", "domUrl", "externalDocument", "mlConfig", "officeDocument", "domDoc", "jsonDoc", "officeDom", "officeStr", "xmlUrl", "mlUrl", "mlDoc", "domDocument", "mlStr", " xmlDocument", "jsonDom", "webDoc", "officeDoc", "externalStr", "xmlConfig", "webUrl", "webDocument", "xmlDocument", "externalDoc", "externalConfig", "domStr", "xmlStr", "webStr"], "url": ["ls", "source", "gl", "buffer", "uri", "str", "browser", "client", "Url", "instance", "download", "config", "f", "input", "l", "src", "socket", "inst", "image", "data", "web", "resource", "open", "www", "io", "base", "inf", "bel", "b", "server", "URL", "sl", "string", "connection", "fr", "stream", "el", "ll", "file", "ssl", "feed", "id", "reader", "user", "http"]}}
{"id1": "8093133", "id2": "23370621", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXmlWithFile", "loadXmlWithUrl", "loadXMLFromUrl", "loadXmlFromFile", "loadXmlAsURL", "loadXmlAsUrl", "loadXMLFromFile", "loadXmlFromurl", "loadXmlfromurl", "loadXmlAsurl", "loadXmlfromFile", "loadXmlWithurl", "loadXMLfromUrl", "loadXMLFromurl", "loadXmlfromURL", "loadXmlfromUrl", "loadXmlFromURL", "loadXmlAsFile", "loadXMLfromurl", "loadXMLfromFile", "loadXmlWithURL", "loadXMLfromURL", "loadXMLFromURL"], "url": ["source", "org", "buffer", "uri", "str", "client", "path", "Url", "config", "page", "link", "l", "conn", "image", "loc", "loader", "service", "object", "location", "resource", "open", "io", "base", "server", "host", "URL", "obj", "address", "sl", "string", "file", "ssl", "feed", "id", "user", "http"], "timeout": ["buffer", "token", "period", "out", "port", "length", "sync", "cache", "client", "config", "seconds", "scroll", "socket", "sleep", "data", "duration", "resource", "Timeout", "io", "limit", "window", "server", "capacity", "until", "delay", "time", "size", "lock", "wait", "resolution", "ssl", "key", "unit", "type", "network", "offset"], "xmlType": [" xmltype", " xmlStyle", "xmlClass", "xmlFile", "mlType", "writerModel", "phpFile", "writerType", " xmlModel", " xmlClass", "xmlStyle", "elementtype", "xmlModel", "mlTypes", " xmlFile", "phpTypes", "phpType", "writertype", " xmlTypes", "mlFile", "elementStyle", "writerStyle", "mlClass", "phpClass", "xmltype", "elementModel", "elementType", "xmlTypes"], "connection": ["relation", "position", "uri", "client", "connected", "c", "union", "config", " Connection", "Connection", "event", "use", "l", "socket", "conn", "application", "condition", "loc", "writer", "con", "resource", "proxy", "builder", "which", "communication", "open", "io", "directory", "connect", "database", "character", "bc", "b", "lc", "server", "function", "index", "container", "channel", "handler", "wrapper", "closed", "collection", "version", "response", "entry", "unit", "reader", "network", "ion", "section", "context", "http"], "buffInputStream": ["BuffOutputStream", "buffReadStream", "BuffReadstream", "buffInSteam", "buffInputstream", "buffInputSteam", "BuffInputSteam", "buffinputSteam", "buffOutputStream", "BuffInputstream", "buffOutputSteam", "BuffOutputSteam", "buffReadSteam", "BuffReadSteam", "buffinputStream", "BuffOutputstream", "buffInStream", "BuffReadStream", "BuffInputStream", "buffOutputstream", "buffReadstream", "buffInstream", "buffinputstream"]}}
{"id1": "6966398", "id2": "12236729", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"reader": ["p", "source", "buffer", "se", "client", "reading", "ry", "load", "instance", "rake", "config", "rr", "driver", "per", "ler", "rar", "input", "manager", "k", "or", "read", "loader", "writer", "ner", "oder", "resource", "builder", "df", "io", "pe", "server", "book", "reads", "rc", "dr", "connection", "rw", "handler", "stream", "cer", "parser", "Reader", "iter", "file", "row", "r", "er", "pp", "keeper", "feed", "her", "o", "ri", "cms", "raf", "context"], "ks": ["ls", "inks", "powers", "cs", "ps", "ss", "se", "kies", "ku", "ips", "keys", "KS", "DS", "ko", "k", "ds", "hs", "ans", "books", "acs", "gets", "kb", "rs", "checks", "vs", "ges", "ke", "opens", "kes", "works", "ms", "qs", "orks", "cks", "fs", "acts", "bs", "reads", "icks", "ki", "sk", "acks", "akes", "ches", "ics", "ns", "es", "CS", "ck", "ctx", "co", "rows", "ops"], "key": ["p", "secret", "char", "cache", "client", "ring", "c", "keys", "point", "state", "court", "seed", "ca", "k", "read", "service", "pg", "ce", "ke", "io", "base", "pe", "server", "code", "transfer", "ki", "lock", "ee", "trust", "value", "file", "sign", "ssl", "type", "user", "co", "Key", "pair"], "chain": ["sequence", "secret", "chains", "cache", "table", "set", "path", "c", "config", "store", "family", "root", "image", "none", "box", "object", "wheel", "base", "code", "Chain", "cr", "container", "list", "rule", "stack", "lock", "crypt", "wrap", "enc", "coll", "range", "scale", "block", "collection", "file", "mc", "slice", "network", "circle", "pair"], "os": ["p", "OS", "ps", "ot", "oss", "bos", "s", "options", "pos", "ds", " o", "iso", "object", "rs", "ol", "opens", "io", "ros", "ms", "ou", "los", "cos", "is", "fs", "res", "rss", "oid", "ios", "aos", "outs", "es", "op", "Os", "o", "osi", "ob", " bos", "oses", "ops"], "stamper": ["stammper", "spAMler", " nostampper", "spAMpe", "stAMler", "spAMper", "streampe", "stameper", "path", "stammpper", "stameple", "stammler", "this", "s", "spammer", "streamper", " nostameple", "starmler", "stample", "stammer", "streammer", "data", "stamepper", "stammmer", "starmper", "g", " nostample", "stammple", "stAMpe", " nostamper", " nostamler", "function", "starmpper", "stAMmer", "stAMper", "stameler", " nostamepper", "starmple", "spampe", "spamper", "stampe", "spamler", "_", "streamler", "stampper", " nostameper", "stammpe", "stamler", "spAMmer", " nostameler"], "appearance": [" applier", "askence", "installasion", "signearance", "formearance", "appfacing", "suppearing", "ppaser", "suppointment", "byearance", " appeared", "ppearance", "ppasion", "signearing", " appear", " appence", "suppearance", "byearing", "ppear", "feedointment", "formismo", " appismo", "signears", "Appearance", "appaser", " appaser", "appearing", "applier", " appearing", "appear", "attearance", "formearing", "askearance", "appence", "appismo", "byismo", " appfacing", "appasion", "formear", "byear", "signointment", "appeared", "signear", " appears", "appears", "suppasion", "atteared", "formaser", "installear", "ppearing", "feedfacing", "signfacing", "attfacing", "feedear", "Appearing", "attence", "askeared", "signlier", "appointment", "suppear", "installearing", "suppfacing", "Appears", "installearance", "Applier", "feedearance", "askfacing"]}}
{"id1": "1954410", "id2": "22801734", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecutes", "doexecuteApply", "doexecuteutes", "submitExecApply", "doSendApply", "doSendRun", "submitexecuteutes", "doExecRun", "submitExecRun", "doExecutes", "submitexecuteRun", "submitexecuteApply", "doSendute", "doexecuteRun", "submitExecute", "doSendutes", "submitexecuteute", "doExecApply", "doexecuteute"], "mapping": ["fapper", "matching", "fapping", "minding", "aminding", "amapping", "amapper", "finding", "mapper", " mapper", " minding", " matching", "amatching", "fatching"], "form": ["flow", "method", "app", "FORM", "forms", "field", "Form", "config", "component", "page", "command", "control", "owner", "definition", "object", "format", "builder", "transform", "url", " forms", "formation", "post", "submit", "dom", "feed", "template", "xml", "pattern"], "request": ["message", "method", "create", "call", "Bytes", "result", "re", "uri", "json", "client", "current", "path", "hello", "session", "Accept", "instance", "frame", "Upload", "s", "this", "model", "use", "view", "HTTP", "input", "complete", "req", "data", "q", "object", "resource", "format", "QUEST", "self", "ware", "url", "name", "add", "server", "requ", "Response", "query", "address", "worker", "queue", "submit", "Reply", "_", "parent", "route", "pull", "reader", "user", "type", "xml", "Request", "report", "context", "application"], "response": ["message", "result", "output", "json", "client", "status", "model", "page", "view", " Response", " responses", "application", "resp", "data", "req", "object", "resource", "Resp", "server", "Response", "res", "handler", "v", "xml", "report", "reply"], "errors": [" status", " flashes", " payload", " translations", " Messages", " session", " commands", " logger", " error", " this", " responses", " warnings", " changes", " replies", " management", " managers", "mess", " acc", " updates", " mess", " messages", " messaging", " problems", " calls", " messenger", " failures", " events", " logs", " streams"], "isMultipart": ["isMultipparts", "isMultippedost", "isMultIPound", "isMultompost", "isMultipost", "isMultipound", "isMultompPart", "isMultipage", "isMultiipound", "isMultIPPart", "isMultompound", "isMultitage", "isMultiipPart", "isMultippart", "isMultIPart", "isMultiIPart", "isMultiated", "isMultippedound", "isMultompart", "isMultiparts", "isMultiipart", "isMultippated", "isMultitart", "isMultiIPost", "isMultippedart", "isMultiIPPart", "isMultIPost", "isMultitarts", "isMultipPart", "isMultippedPart", "isMultiarts", "isMultitated", "isMultippage", "isMultiIPound", "isMultiipost", "isMultiage", "isMultiart", "isMultipated"], "mailInstance": ["fileManager", "fileinstance", "fileInstance", "mailUsage", "emailinstance", " emailinstance", " mailUsage", "emailInstance", "fileUsage", " emailInstance", "mailinstance", " emailUsage", "mailInst", "emailManager", " emailInst", " mailInst", " mailinstance", "mailManager", "emailInst", " mailManager", "fileInst"], "fields": ["types", "parts", "rules", "holders", "locks", "words", "lines", "forms", "field", "lists", "keys", "forces", "s", "groups", "input", "services", "atts", "dates", "data", "gets", "strings", "checks", "cells", "flows", "archives", "objects", "qs", "boxes", "params", "ments", "files", "facts", "utils", "members", "features", "states", "links", "acks", "models", "tags", "pages", "uploads", "views", "details", "loads", "plugins", "packs", "users", "properties", "headers", "changes", "maps", "classes", "comments", "events", "ids", "rows", "posts"], "attachments": ["Attachments", "payments", "attachers", "Attachees", "extions", "exters", "attions", "attees", "attachresses", "attps", "attachlements", "payment", "achresses", "Attachps", "Attachlements", "suppees", "achments", "attachps", "attments", "attachment", " attachment", " attachparts", "attachparts", "attachions", "attment", "Attachions", "extps", "achparts", "atters", "attlements", "achment", "supplements", "payparts", "payresses", "Attachers", "extments", "suppment", "suppments", " attachresses", "attachees", "Attachment"], "items": ["types", "parts", "apps", "locks", "lines", "orders", "lists", "Items", "keys", "ips", "its", "ers", "groups", "data", "names", "objects", "apters", "qs", "files", "reports", "list", "ins", "links", "models", "pages", "plugins", "es", "results", "children", "events", "ids", "alls", "rows", "phones", "ops"], "iter": ["itter", "edit", "inner", "finder", "ver", "ite", "ter", "page", "event", "master", "cher", "i", "keep", "enter", "skip", "upper", "gener", "loc", "ner", "walker", "ir", "ip", "Iterator", "it", "izer", "outer", "Iter", "zip", "altern", "ator", "li", "list", "exp", "former", "chain", "coll", "el", "ul", "inc", "file", "loop", "err", "er", "ser", "end", "reader", "inter", "slice", "iterator", "oper", "order", "http"], "item": ["source", "current", "instance", "event", "extra", "image", "val", "ip", "url", "base", "name", "post", "Item", "li", "temp", "slice", "entry", "type", "section", "volume", "result", "token", "load", "info", "all", "i", "area", "or", "data", "example", "object", "other", "up", "original", "obj", "entity", "api", "layer", "coll", "plugin", "art", "site", "user", "order", "update", "hop", "atom", "issue", "folder", "resource", "next", "container", "element", "attribute", "more", "reader", "get", "app", "widget", "album", "inner", "page", "complete", "anything", "service", "missing", "storage", "it", "server", "index", "handler", "full", "file", "custom", "er"], "aux": ["offs", " auxiliary", "uc", "ups", "uf", "frac", "union", "alias", "buf", "aus", "extra", "etc", " Aux", "data", "des", "ux", "aff", "strings", "amp", "af", "ras", "cas", "ru", "sup", "aw", "array", "lc", "asc", "ext", "ou", "ants", "sub", "lang", "imp", "prefix", "axe", "aos", "fax", "auc", "ox", "off", "abs", "anc", "au", "pkg", "packages", "cmp", "abc", "except"], "part": ["p", "pre", "group", "parts", " Part", "ref", "field", "instance", "f", "point", "info", "back", "component", "per", "one", "word", "po", "l", "pos", "area", "joined", "val", "data", "PART", "object", "format", "act", "on", "action", "and", "class", "error", "base", "name", "b", "add", "change", "fact", "obj", "player", "pi", "ch", "connection", "list", "patch", "but", "layer", "comp", "element", "full", "plugin", "block", "html", "Part", "file", "start", "step", "partial", "key", "art", "diff", "join", "id", "type", "parent", "section", "user", "co", "no", "pair"], "baos": ["BAo", "baoss", "baOs", "baot", "paot", "baoS", "abaosi", " baoS", "BAis", "Bao", " baoss", "baosh", "boOS", "pao", "boo", "BAOs", "BAoss", "haos", "BaOs", " bao", "baOS", "bois", "paOS", "Baos", "BAoS", "Baosi", "abais", "abaOs", " baOS", "BaoS", "bais", "hao", "boosh", "hais", "abaos", "BAosi", "baosi", " bais", "boos", "Bais", "pais", "boot", "bao", "BAos", "paos", "paosh", " baot", "BAosh", "haoss"], "body": ["text", "source", "message", "parts", "media", "summary", "output", "port", "json", "length", "fee", "translation", "flash", "Body", "state", "pass", "options", "tree", "data", "object", "resource", "binary", "comment", "description", "shell", "document", "url", "name", "b", "null", "params", "zip", "query", "string", "header", "connection", "size", "full", "html", "value", "headers", "template", "end", "type", "common", "content", "reply"], "preferencesInstance": ["preffeesinstance", "prefeesinstance", "prefiesinstance", "preffeesClient", "prefirmsClient", "preferencesClient", "prefirmsInstance", "prefeesClient", "prefiesClient", "prefiesInstance", "prefeesInstance", "preffeesInstance", "preferencesinstance", "prefferencesClient", "prefirmsinstance", "prefferencesInstance", "prefferencesinstance"]}}
{"id1": "18339787", "id2": "13946197", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"reload": ["refill", "overfill", "preloading", "reloading", "refload", "overload", "prefill", "refresh", "preload", "overresh", "refloading", "preresh", "reffill", "reresh", "overloading"], "currentDate": ["CurrentTime", "reportedDate", "CurrentKey", "reportedDay", "reportedName", " currentTime", " currentName", "CurrentName", " currentDay", "newUpdate", "CurrentUpdate", "newDate", " currentKey", "reportedTime", "currentTime", "CurrentDate", "CurrentDay", "newDay", "currentDay", "currentKey", "currentUpdate", "newKey", " currentUpdate", "currentName"], "xpath": [" xparent", " xath", " xp", "Xcase", "Xprop", "axcase", "xPath", " xPath", "axpath", "xparent", "lexpath", "exath", "txPath", "Xp", "exparent", "xstream", "lexparent", "axath", "xath", "expath", "lexPath", "axPath", "xcase", "xp", " xstream", "lexstream", "Xpath", " xprop", " xcase", "exp", "Xstream", "exprop", "txstream", "xprop", "exstream", "XPath", "exPath", "Xath", "txpath"], "docBuilderFactory": ["documentBuildF", "docBuildF", "docBuilderInterface", "docbuilderFactory", "documentBuildService", "projectBuilderInterface", "documentBuilderF", "docBuilder2", "projectbuilder2", "documentBuilderFactory", "documentBuildFactory", "docBuildFactory", "docbuilder2", "documentBuilderService", "docbuilderService", "docManagerFactory", "projectBuilder2", "projectBuilderFactory", "docBuildFactor", "projectBuilderFactor", "docbuilderInterface", "docBuild2", "docbuilderF", "projectbuilderInterface", "docBuilderService", "docManager2", "projectbuilderFactor", "docBuildInterface", "docBuilderFactor", "docManagerFactor", "docBuildService", "docbuilderFactor", "docBuilderF", "projectbuilderFactory", "docManagerInterface"], "docBuilder": ["fileBook", "documentBuild", "docFactory", " docBuild", "xmlParser", "documentbuilder", "xmlBuilder", "docBook", "documentFactory", "docParser", "documentBook", " docFactory", "fileFactory", "Docbuilder", "DocParser", "fileBuild", "documentBuilder", "docBuild", " docBook", "documentParser", "DocBuild", "xmlbuilder", "xmlBuild", "docbuilder", "DocBuilder", "fileBuilder"], "conn": ["uc", "client", "out", "path", "session", "Url", "c", "config", "Connection", "cmd", "nt", "l", "socket", "Conn", "ci", "serv", "loc", "loader", "con", "connect", "log", "ann", "conv", "lc", "server", "URL", "exec", "conf", "ch", "api", "body", "db", "connection", "nc", "channel", "lock", "cp", "enc", "coll", "cm", "cn", "ssl", "cli", "ct", "ctx", "cb", "http"], "url": ["ls", "org", "gl", "uri", "str", "client", "path", "Url", "download", "f", "config", "l", "serv", "image", "build", "blog", "loader", "data", "web", "resource", "www", "base", "log", "bel", "server", "host", "URL", "sl", "connection", "string", "channel", "fr", "coll", "ll", "impl", "file", "ssl", "feed", "err", "ob", "db", "http"], "xml": ["x", "arr", "json", "ml", "parse", "path", "update", "config", "date", "model", "event", "wt", "page", "content", "txt", "root", "apache", "input", "tree", "image", "atom", "data", "writer", "example", "email", "node", "document", "log", "graph", "zip", "address", "rss", "stream", "element", "el", "php", "html", "dom", "office", "file", "temp", "request", "feed", "response", "wl", "layout", "reader", "children", "events", "doc", "context", "http"], "exchangeRateDate": ["excurrencyRateFile", "exchangeWeightDate", "exchangeTimeDate", "expirePricePrice", "expirePriceDate", "exchangeRateKey", "excurrencyRateTime", "exchangePriceKey", "exchangePricePrice", "excurrencyTimeDate", "exchangeRatingPrice", "exchangeFactorTime", "expireRateFormat", "exchangeRatingDate", "exchangeTimeDuration", "exchangeWeightKey", "exchangePriceDate", "exchangeWeightFormat", "excurrencyRateDate", "expireRatePrice", "exchangeRateDuration", "excurrencyTimeDuration", "expireRateDate", "exchangeWeightPrice", "exchangeRatingKey", "exchangePriceFormat", "expirePriceFormat", "exchangeRateTime", "exchangeRatingFormat", "expirePriceKey", "exchangeFactorDuration", "expireRateKey", "exchangeFactorDate", "exchangeRateFormat", "exchangeRateFile", "exchangeRatePrice", "exchangeFactorFile", "excurrencyRateDuration", "exchangeTimeFile", "excurrencyTimeTime", "exchangeTimeTime", "excurrencyTimeFile"], "currenciesNode": ["curatorsContainer", "cururrenciesDocument", "comrenciesNode", "contracturrenciesRoot", "corenciesNode", "curatorsnode", "cururrenciesnode", "currenciesRoot", "contractrenciesNode", "curportsPath", "curcurrencyElement", "curratesBlock", "curlationsBlock", "comrenciesBlock", "curlationsPath", "curlationsElement", "comportsElement", "cururrenciesBlock", "cururrenciesArray", "curratesRoot", "currenciesDocument", "courrenciesContainer", "contractrenciesBlock", "currenciesElement", "curitiesArray", "curratesNode", "curatorsArray", "curportsNode", "corenciesArray", "curatorsNode", "currenciesArray", "cururrenciesNode", "curriesRoot", "currenciesContainer", "curitiesNode", "curitiesnode", "currenciesBlock", "contracturrenciesNode", "curratesDocument", "comportsBlock", "curportsElement", "curcurrencyPath", "curcurrencyBlock", "cururrenciesRoot", "currenciesPath", "comportsPath", "corenciesnode", "curriesDocument", "contracturrenciesDocument", "contracturrenciesBlock", "curriesBlock", "corenciesContainer", "courrenciesNode", "currenciesnode", "cururrenciesContainer", "curcurrencyNode", "courrenciesnode", "courrenciesArray", "curitiesContainer", "curlationsNode", "curriesNode", "contractrenciesRoot", "contractrenciesDocument", "curportsBlock", "comportsNode", "comrenciesElement", "comrenciesPath"], "currencies": ["perums", "urums", "scherency", "loccoins", "scheurrencies", "carales", "carurrency", "urrencies", " curacters", " cururrencies", "cururrencies", "chales", "carrencies", " currency", "curcoins", "locurrency", "chcoins", "cururrency", "carcoins", "curales", " curries", " curums", "currency", "curums", "perrencies", "scheries", "curversions", " curversions", "perversions", "urversions", "locales", "scherencies", "curries", "churrency", "charries", "peracters", "locrencies", "uracters", "charrencies", "charurrencies", "curacters", "charrency", "chrencies"], "i": ["p", "x", "uri", "z", "c", "f", "ai", "gi", "ii", "info", "e", "l", "I", "ci", "yi", "abi", "m", "q", "in", "chi", "multi", "ip", "n", "iu", "io", "g", "si", "bi", "u", "b", "it", "lc", "ui", "pi", "oi", "ji", "index", "li", "j", "hi", "di", "qi", "eni", "y", "xi", "fi", "t", "r", "mu", "slice", "o", "id", "end", "v", "start", "ri", "ti", "phi"]}}
{"id1": "6188784", "id2": "8754809", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "p", "create", "sync", "download", "Cop", "to", "move", "map", "cop", " copying", "clone", "clip", "change", "transfer", " transfer", "zip", "split", "Copy", "lock", "cp", " Copy", "replace", "put", "file", "cmp"], "source": ["remote", "cache", "sync", "path", "inner", "use", "i", "ie", "input", "ources", "src", "ource", "SOURCE", "sin", "down", "Source", "from", "resource", "up", "base", "name", "ins", "connection", "origin", "stream", "iter", "file", "route", "slice", "site", "reader", "id", "unit", "parent", "start", "target"], "dest": ["style", "flat", "result", " destination", "home", "d", "de", "src", "down", "folder", "done", "which", "later", "img", "sup", "tmp", "cont", "die", "destroy", "dist", "comb", "thin", "exit", "orig", "test", "desc", "coord", "temp", "wb", "Dest", "dir", "bin", "target", "delete", "dc"], "in": ["work", "as", "init", "into", "gin", "inn", "client", "pin", "inner", "c", "ac", "f", "s", "plus", "i", "ie", "input", "socket", "inside", "image", "src", "conn", "sin", "IN", "issue", "m", "con", "win", "ini", "resource", "n", "isin", "up", "url", "base", "din", "pc", "name", "it", "nin", "min", "ins", "connection", "cin", "thin", "plugin", "In", "inc", "again", "file", "parent", "include", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["call", "buffer", "output", "client", "sync", "net", "inner", "cat", "at", "not", "this", "our", "extra", "w", "timeout", "ex", "i", "one", "socket", "OUT", "conn", "down", "writer", "other", "io", "n", "up", "vert", "name", "ou", "outer", "ext", "exec", "password", "pool", "obj", "connection", "exp", "channel", "prefix", "option", "Out", "write", "outs", "again", "off", "file", "parent", "part", "lib", "err", "o", "id", "plain", "bin", "outside", "no"], "size": ["x", "seek", "shape", "mode", "depth", "sync", "length", "empty", "SIZE", "len", "bytes", "e", "send", "iz", "max", "count", "loc", "close", "open", "ice", "Size", "n", "export", "speed", "si", "name", "small", "width", "add", "sized", "capacity", "transfer", "sec", "number", "address", "time", "izes", "order", "ize", "sum", "scale", "en", "any", "end", "unit", "flush", "start", "clear", "offset", "content"], "buf": ["cv", "cmp", "buffer", "uf", "uc", "cf", "seq", "br", "bag", "feat", "ba", "fb", "buff", "len", "bytes", "src", "ff", "map", "data", "box", "bf", "cas", "bc", "b", "Buffer", "rb", "coll", "ha", "ra", "vec", "BU", "fam", "pkg", "ctx", "bin", "cb", "la", "bd"]}}
{"id1": "22268798", "id2": "8486429", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["createContent", "buildResource", "buildContent", "loadResource", "getContents", "loadcontent", "getcontent", "createContents", "buildContents", "getResource", "buildcontent", "loadContent", "createResource", "loadContents", "createcontent"], "principal": ["prunctential", "prercipal", "Princunctential", "pruncteter", "princeter", "prerceter", "Princincipal", "prunctipal", "Princincificate", "pricipificate", "Princuncteter", "pricipeter", "Princunctipal", "pricipipal", "princificate", "prunctificate", "prercificate", "prercential", "Princunctificate", "Princincential", "princential", "Princinceter", "pricipential"], "path": ["text", "source", "method", "property", "prop", "uri", "client", "Path", "instance", "info", "link", "PATH", "ath", "root", "pointer", "project", "data", "loader", "object", "location", "resource", "format", "context", "class", "next", "name", "api", "string", "prefix", "file", "request", "part", "user", "parent", "node", "pattern"], "version": ["current", "json", "depth", "str", "out", " versions", "vision", "versions", "date", "ver", "model", "VERSION", "level", "project", "val", "release", "object", "resource", "format", "server", "string", "Version", "value", "parent", "v", "node", "target"], "properties": ["types", "property", "ps", "prop", "perties", "json", "ips", "state", "options", "resources", "data", "metadata", "values", "Property", "objects", "params", "address", "features", "details", "settings", "Pro", "plugins", "pro", "results", "items", "classes", "fields"], "uniqueName": ["stringName", " uniquename", " uniqueTime", "basePath", "filename", "basename", "blockPath", " uniqueType", "uniqueKey", "filePath", "UniqueTime", "Uniquename", "fileTime", "stringKey", "UniquePath", "uniqueType", "baseKey", "UniqueName", "stringPath", "blockType", "stringname", "uniquePath", "fileName", "baseName", " uniqueKey", " uniquePath", "UniqueType", "uniqueTime", "blockName", "UniqueKey", "blockKey", "uniquename"], "url": ["ls", "source", "position", "uri", "client", "Url", "download", "f", "bb", "this", "page", "link", "l", "conn", "image", "build", "loc", "found", "web", "object", "location", "resource", "proxy", "open", "www", "base", "name", "log", "server", "host", "URL", "address", "sl", "string", "channel", "layer", "el", "ll", "coll", "html", "file", "ssl", "feed", "ob", "user", "parent", "error", "http"], "content": ["source", "message", "create", "remote", "result", "copy", "media", "output", "current", "client", "cache", "cf", "cover", "c", "load", "instance", "config", "ac", "this", "model", "page", "update", "ca", "conn", "image", "complete", "default", "condition", "data", "const", "object", "resource", "proxy", "ce", "location", "comment", "core", "document", "cont", "lc", "ext", "host", "code", "server", "change", "child", "address", "container", "section", "handler", "cm", "layer", "wrapper", "full", "coll", "creator", "Content", "temp", "file", "key", "response", "reader", "user", "parent", "common", "node"], "connection": ["relation", "position", "uri", "client", "connected", "session", "c", "config", "Connection", "http", "control", "conn", "image", "loc", "data", "con", "object", "resource", "context", "open", "proxy", "communication", "io", "directory", "connect", "character", "database", "server", "pool", "number", "container", "string", "channel", "handler", "coll", "creator", "response", "reader", "section", "application"], "mimeType": ["mmimeInfo", "mimesType", "mIMEInfo", "miveInfo", "MimeType", "mangPath", "mimeName", "mmimeType", "MIMEtype", "mimePath", "mimeInfo", "mimetype", "Mimetype", "mIMEName", "metyInfo", "mmiveType", "mIMEtype", "metyType", "mimestype", "MimeName", "mmimetype", "mIMEPath", "mangName", "MIMEPath", "mangType", "mmivetype", "MIMEName", "mangtype", "mivetype", "miveType", "mmiveInfo", "mimesPath", "MimePath", "MIMEType", "mIMEType", "metytype", "mimesName"]}}
{"id1": "16378239", "id2": "9449064", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["orReference", "orLink", "orref", "ofref", "Byref", "orExternal", "toReference", "ByLink", "toLink", "ByReference", "ByExternal", "ofExternal", "toExternal", "toref", "ofReference", "ofLink"], "inputStream": ["InputFile", "inStream", "inReader", " inputObject", " inputstream", "InputString", "inputFile", "InputObject", "tempStream", "inputObject", "outputString", "tempReader", "Inputstream", "tempSteam", "inputReader", "InputReader", "inputstream", "InputStream", "instream", "inSteam", " inputString", "outputStream", "outputObject", "inputString", "InputSteam", "outputstream", "inputSteam", "outputFile", "tempstream", "outputSteam"], "tempFile": ["Tempfile", " tempFiles", "fakefile", "fakeFiles", "tmpPage", " tempDir", "fakeDir", "tempF", "fakeFile", "tempFiles", "tempStream", "TempFiles", "tmpFiles", "TempContent", " tempfile", "tmpDir", "tmpF", "fakeF", "tempContent", "tmpContent", "tempPage", "tmpFile", " tempStream", "tempDir", "tempfile", "tmpStream", "fakeStream", "tmpfile", " tempF", " tempContent", "TempFile", "fakePage", " tempPage"], "out": ["source", "init", "result", "copy", "output", "sync", "client", "path", "flush", "instance", "f", "this", "extra", " in", "ex", "to", "OUT", "conn", "line", "image", "data", "writer", "in", "object", "resource", "later", "io", "a", "url", "base", "array", "null", "outer", "ext", "server", "obj", "exec", "pool", "connection", "plain", "Out", "write", "outs", "again", "file", "temp", "part", "err", "o", "user"]}}
{"id1": "3309233", "id2": "20232250", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doAsyncAsync", "buildInAsync", " doUsingStudio", " doAsConsole", " doInAsync", " doAsyncStudio", " doInConsole", "buildUsingStudio", "buildUsingConsole", "buildInConsole", "buildInBackground", " doAsAsync", " doAsyncConsole", " doUsingBackground", " doUsingAsync", "buildUsingAsync", "buildInStudio", " doAsStudio", " doAsBackground", " doUsingConsole", " doInStudio", "buildUsingBackground", " doAsyncBackground"], "params": ["p", "ls", "source", "types", "parts", "eps", "ps", "lines", "json", "parse", "py", "Param", "keys", "config", "s", "Par", "page", "phrase", "options", "i", "services", "ds", "resources", "data", "names", "mes", "strings", "values", "pins", "objects", "los", "files", "address", "ams", "reports", "sp", "arms", "par", "details", "Parameters", "settings", "properties", "results", "comments", "type", "pm", "ctx", "posts"], "param": ["p", "ram", "prem", "mand", "rem", "meter", "monitor", "mm", "path", "Param", "config", "iam", "model", "page", "pb", "gram", "conn", "single", "project", "default", " parameter", "amp", "object", "pri", "comment", "mor", "name", "pc", "vm", "proc", "null", "Parameter", "pool", "password", "lc", "conf", "address", "ams", "connection", "string", "channel", "arm", "par", "cp", "option", "cm", "am", "km", "temp", "parent", "part", "aram", "ctx", "pm", "contract", "prom", "camp"], "client": ["p", "app", "Client", "session", "c", "config", "apache", "conn", "project", "bird", "con", "service", "proxy", "help", "ce", "resource", "force", "self", "connect", "url", "base", "server", "host", "secure", "api", "connection", "channel", "cp", "handler", "cl", "comp", "plugin", "cm", "request", "cli", "response", "ssl", "google", "http"], "post": ["p", "pre", "form", "create", "set", "pod", "json", "push", "c", "load", "f", "head", "wp", "hop", "e", "pb", "send", "pos", "posted", "install", "comment", "and", "next", "base", "add", "proc", "server", "zip", "query", "api", "body", "upload", "patch", "dd", "submit", "Post", "put", "request", "part", "response", "pp", "op", "feed", "entry", "POST", "http"], "resp": ["ref", "rec", "re", "json", "download", "page", "content", "success", "e", "serv", "conn", "req", "resource", "reply", "Resp", "server", "Response", "exec", "obj", "rep", "res", "api", "sp", "body", "respond", "par", "handler", "enc", "received", "fc", "request", "err", "response", "comm", "rh", "error", " response", "status", "rel", "http"], "entity": ["ent", "output", "json", "translation", "instance", "activity", "model", "event", "person", "e", "conn", "line", "xml", "data", "agent", "object", "resource", "node", "ec", "base", "article", "code", "obj", "ity", "body", "string", "connection", "enc", "element", "el", "coll", "attribute", "response", "entry", "unit", "Entity", "status", "content"], "result": ["text", "match", "source", "message", "ret", "property", "output", "json", "translation", "instance", "status", "page", "place", "success", "line", "default", "data", "record", "object", "resource", "location", "description", "url", "name", "address", "res", "Result", "string", "details", "desc", "value", "row", "response", "results", "entry", "report", "content"]}}
{"id1": "62362", "id2": "20375440", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"convert": ["oconverted", "subversion", "unverted", "unversion", "converted", "CONverted", " deconverted", "subverted", "Convert", "CONception", "unception", "subvert", " deconversion", "Conversion", "CONvert", "oconverting", "Converting", "Converted", "Conception", "CONverting", "conception", "conversion", "oconvert", "subverting", "converting", " deconverting", "unvert", "oconversion", " deconvert", "CONversion"], "src": ["attr", "source", "ref", "filename", "video", "sb", "fp", "uri", "secure", "st", "path", "username", "feat", "load", "download", "config", "s", "back", "buf", "component", "gz", "input", "ource", "inst", "sin", "loc", "RC", "req", "Source", "sys", "prot", "resource", "img", "storage", "sth", "url", "tmp", "name", "stage", "proc", "spec", "code", "obj", "sel", "sc", "rl", "sit", "supp", "scene", "SourceFile", "rc", "upload", "string", "fn", "rb", "gb", "dist", "stream", "cpp", "impl", "sn", "file", "Dest", "ssl", "slice", "href", "reader", "ctx", "cb", "cmp"], "dest": ["disk", "source", "path", " destination", "home", "txt", "img", "class", "tmp", "null", "cont", "obj", "dist", "dat", "fn", "di", "orig", "test", "std", "temp", "lib", "Dest", "dir", "bin", " dst", "target", "dc"], "in": ["source", "as", "ps", "inn", "pin", "f", "pass", "ex", "i", "input", "inas", "val", "IN", "data", "ini", "win", "n", "up", "isin", "a", "io", "inf", "din", "is", "ins", "stream", "In", "inc", "file", "r", "t", "err", "login", "reader", "bin", "d", "doc"], "p": ["lp", "pre", "tp", "ps", "fp", "py", "c", "f", "np", "s", "wp", "per", "i", "e", "pb", "po", "l", "bp", "m", "pg", "cop", "pa", "g", "v", "pc", "b", "pe", "pd", "pi", "sp", "j", "h", "cp", "pr", "jp", "parser", "part", "t", "pp", "op", "r", "o", "pm", "d", "P"], "ds": ["ts", "ups", "s", "DS", "hs", "ans", "ipes", "ded", "dds", "ins", "xs", "ns", "d", "ays", "dos", "ps", "words", "sync", "styles", "ys", "groups", "data", "da", "des", "rs", "ths", " ps", "os", "utils", "pd", "icks", "dist", "els", "models", "points", "sts", "scripts", "plugins", "js", "db", "cons", "posts", "ls", "parts", "tools", "cs", "ss", "lines", "dm", "vals", "sys", "ges", "ks", "qs", "docs", "ants", "bs", "nas", "amps", "Ds", "di", "dd", " props", "gs", "ads", "ils", " sd", "lp", "uds", "tests", "eps", "services", "dates", "dl", "vs", "dt", "dat", "gd", "ld", " DS", "dp", "df", "obs", "dc"], "format": ["source", "nat", "form", "style", "filename", "fp", "table", "path", "language", "feat", "frame", "config", "f", "at", "model", "data", "magic", "record", "act", "class", "url", "name", "spec", "Format", "host", "fd", "function", "letter", "api", "tag", "string", "struct", "sche", "fn", "prefix", "handler", "plugin", "scale", "filter", "parser", "file", "version", "part", "t", "template", "atter", "layout", "unit", "type", "ant", "pattern"], "hasPixelData": ["hasPixelSize", "haspixeldata", "hasByteData", "haspixelData", "hasByteStyle", "showsByteDATA", "hasPictureSize", "hasPixelStyle", "hasPixelDATA", "haspixelSize", "showsPixelDATA", "hasPictureData", "showsPixelData", "hasBytedata", "showsPixeldata", " hasPixelSize", "showsPixelStyle", "hasPixeldata", "hasByteSize", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPicturedata", " hasPixeldata", "showsByteData"], "inflate": ["infloated", "infolode", "insvenode", "insflode", "infface", "inFlation", "insvenATE", "insvenating", "invenating", "inadequode", "inadequATE", "insflATE", "Inflation", "infloation", "invenATE", "insflate", "infolate", "inflode", "inflATE", "invenate", "invenode", "inflace", "Inflate", "inFlace", "inadequating", "inadequate", "inFlate", "InFlate", "infolATE", "infolating", "InFlace", "inffated", "insflating", "inFlated", "infloace", "infloate", "inflated", "inflation", "InFlated", "inffate", "inflating", "inffation", "insvenate", "InFlation", "Inflated", "Inflace"], "pxlen": ["pcln", "xplength", "pglen", "txln", "pnglen", "fxpos", "fxlen", "mxpos", "xpcount", "pxlength", "mxdata", "pxln", "pxpos", "ppl", "campos", "mxlen", "txlen", "fxdata", "pxcount", "mxlength", "axlon", "pclin", "pgLen", "txlin", "xplen", "axlen", "axlin", "pxlin", "mxsize", "pxdata", "pxlon", "pclen", "axln", "pgden", "mxln", "pxsize", "pngsize", "camdata", "txlon", "pnglength", "pngcount", "camlen", "ppLen", "fxLen", "xpsize", "mxcount", "fxln", "camln", "fxl", "pxLen", "pplen", "pgl", "pclon", "pxl", "ppden", "pxden", "fxden"], "out": ["work", "group", "copy", "cache", "output", "re", "session", "point", "pad", "store", "page", "state", "dump", "OUT", "conn", "line", "sys", "io", "up", "v", "log", "server", "gen", "obj", "post", "query", "list", "lock", "Out", "outs", "again", "lib", "step", "cli", "err", "inter", "user", "parent", "error", "co"]}}
{"id1": "20011285", "id2": "19739421", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "create", "sync", "paste", "py", "load", "update", "download", "cat", "link", "move", "cop", "clone", "rm", "share", "clip", "log", "change", "transfer", "zip", "split", "upload", "Copy", "cp", "opy", "write", "replace", "file", "save", "apply", "type", "get", "delete"], "sourceFile": ["ourceFolder", "sourceDir", "ourceDirectory", "apiFile", "SourceTime", "sourcePage", "ourceSourceFile", " sourcefile", " sourceFILE", "sourceFILE", "siteFiles", "sourceSourceFile", "ourceBook", " sourceFolder", "ourceFiles", "sampleFiles", " sourceFiles", " sourcePage", "apiFiles", "siteFILE", "sampleFilename", "siteFile", "slaveFilename", "sourceDirectory", "ourceFile", " sourceSourceFile", "ourceTime", "sampleFile", "sampleFILE", "SourcePlace", "sourcePlace", " sourceTime", "targetDirectory", "siteFilename", "targetDir", "apiFILE", "targetFiles", "sourceFilename", "ourcefile", "slaveFiles", "sourceBook", "targetFile", " sourceBook", "targetFolder", "SourceDir", " sourceDirectory", "SourceSourceFile", " sourceFilename", "SourceFile", "sourcefile", "slaveFile", "sourceFiles", "sourceTime", "sourceFolder", "apiFilename", "SourceDirectory", " sourcePlace", "slaveFILE", "ourcePage", "SourceBook", "targetPage", "ourcePlace", " sourceDir", "Sourcefile", "SourceFiles"], "destinationFile": ["destinatingFiles", "destwayFiles", "destinateFolder", "dominationPath", "destinatefile", " destinatingFile", "DestinationDirectory", "dominatorFiles", "distructionFolder", "destinationPath", "distructionFILE", "distinationFile", "dominationFile", "desturationDirectory", "distructionFile", "destwayfile", "targetinatedFolder", "destinatorSourceFile", "destinatorfile", " destinationfile", "destuationFile", "destuationfile", "destinatingFolder", "destinationDirectory", "targetinationFolder", "destinatorDirectory", "dominatorFILE", "DestinationFile", "destinatorFile", "destinateFile", "destinationSourceFile", "destinatePath", "distinationfile", "destinatedFolder", "destinatedFile", "DestinatingFile", "destructionfile", "targetinationfile", "destinateFiles", " destinatingfile", "destuationFILE", "destructionFile", "destinatingfile", "destinatedfile", "destinatorPath", "destinatingFILE", "dominatorFile", "desturationFiles", "destinationFolder", "destinationFILE", "destructionFolder", "DestinationSourceFile", "targetinatedFiles", "targetinationFiles", "destinatingFile", "destwayFile", "dominationfile", "destinatorFILE", "destwayFILE", "destuationFolder", "destinatorFolder", "destinationfile", "targetinatedfile", "DestinatingDirectory", "dominationFILE", "distructionfile", "destinationFiles", "distinationFolder", "destructionFILE", " destinationFolder", "desturationSourceFile", "dominationFiles", "destinatingSourceFile", " destinationFiles", "targetinationFile", "destinatedFiles", "desturationFile", "dominatorfile", " destinatingFiles", "destinatingPath", "dominatorPath", "targetinatedFile", "distinationFILE", " destinatingFolder", "destinatorFiles", "DestinationFiles", "DestinatingFiles", "destinatingDirectory", "DestinatingSourceFile"], "tmp": ["p", "stuff", "tp", "apps", "flat", "cache", "current", "media", "pty", "mp", "ppa", "st", "mm", "py", "csv", "np", "fb", "bb", "buf", "page", "e", "txt", "po", "area", "pos", "mb", "meta", "data", "amp", "folder", "storage", "img", "ip", "dest", "sup", "rm", "array", "vm", "params", "files", "obj", "zip", "split", "nb", "api", "dat", "sp", "rb", "upload", "list", "handler", "mo", "temp", "part", "t", "pp", "slice", "dir", "diff", "tab", "v", "db", "cmp"], "f": ["p", "x", "lf", "F", "fp", "uf", "fx", "cf", "c", "info", "fb", "this", "e", "l", "ff", "m", "af", "bf", "io", "g", "fo", "inf", "b", "u", "fd", "fs", "fe", "conf", "fl", "j", "fn", "fr", "fa", "tf", "handler", "rf", "full", "fc", "file", "fi", "t", "r", "df", "o", "xf", "v", "d"], "i": ["p", "x", "uri", "ij", "c", "ai", "s", "ii", "gi", "info", "ix", "e", "d", "vi", "l", "I", "ie", "ci", "m", "in", "multi", "ip", "n", "io", "iu", "bi", "si", "name", "u", "b", "lc", "ui", "pi", "oi", "ji", "li", "j", "index", "h", "hi", "di", "qi", "y", "xi", "fi", "key", "o", "id", "v", "start", "ri", "ti"], "source": ["result", "cache", "uri", "current", "client", "back", "use", "view", "component", "slave", "this", "e", "ie", "input", "ource", "src", "SOURCE", "get", "Source", "service", "from", "resource", "ce", "proxy", "storage", "force", "io", "core", "si", "base", "null", "server", "ge", "sl", "secure", "grade", "scope", "connection", "stream", "wrapper", "slice", "site", "diff", "id", "reader", "parent", "start", "target"], "destination": ["destinating", "destinated", " destation", "estinator", "Destinated", "partinator", "destation", "combinate", "generinator", "partation", "generination", "estination", "destinate", "partination", "combinating", "Destation", "generinate", "partinated", "combinator", "generinated", " destinator", "Destinate", " destinated", "estinating", "combination", "Destination", "destinator", "Destinating", "Destinator", "combinated", "estinate"]}}
{"id1": "20602651", "id2": "3197876", "code1": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"readURL": ["loadURL", " readUrl", " readURI", "createUrl", "loadURI", " readString", "loadUrl", "createString", "loadString", "createURI", "createURL", "readUrl", "readURI", "readString"], "url": ["source", "buffer", "uri", "json", "path", "Url", "tool", "config", "f", "date", "page", "input", "l", "image", "loader", "data", "service", "resource", "www", "base", "name", "job", "server", "URL", "address", "sl", "secure", "string", "connection", "rule", "ur", "lr", "el", "file", "pull", "ssl", "feed", "err", "user", "jar", "http"], "istream": ["irstore", "istram", "intream", "istsr", "astraw", "ismraw", "iststream", "istroll", "istsstream", "irstram", "introll", "isdrog", "astream", "isdream", "ISTream", "istsrog", "irstro", "ismream", "isdro", "irstream", "ismroll", "intstream", "ISTr", "istrog", "istrar", "ISTore", "aststream", "ISTro", "istsrar", "istsam", "istr", "istsram", "irststream", "isdore", "irstrog", "ISTrog", "intraw", "isdam", "istsream", "ismstream", "istro", "irstrar", "istraw", "isdr", "ISTam", "astroll", "istore", "astrar", "istam", "astram"], "isr": ["israr", "isser", "wasR", "usrs", "waslr", "issrar", "issrs", "wasr", "isR", "sser", "idrs", "iser", "issr", "ossr", " isrs", "isrt", "osrs", "islr", "issrr", "osr", "isslr", "idrar", "ssrr", " islr", " isR", " israr", "osrar", "usrar", " isrr", " ispr", "isrr", "usr", " issr", "idrt", "isrs", "issR", "sspr", "isssr", "issrt", " iser", "wasrs", "usrt", "ssr", "isspr", "ispr", "idr"], "in": ["source", "as", "init", "ln", "rec", "gin", "inn", "out", "pin", "inner", "c", "s", "e", "i", "input", "l", "socket", "inside", "conn", "image", "or", "IN", "data", "m", "ini", "win", "isin", "a", "din", "vin", "is", "nin", "min", "index", "ins", "cin", "stream", "cl", "lin", "In", "inc", "again", "iter", "rin", "kin", "err", "ssl", "login", "r", "ilo", "reader", "id", "slice", "bin"], "line": ["text", "source", "message", "column", "lf", "char", "style", "Line", "lines", "str", "sync", "cell", "frame", "page", "pass", "link", "e", "l", "inline", "data", "nl", "object", "comment", "character", "log", "name", "lc", "code", "number", "sl", "letter", "string", "header", "rule", "connection", "lock", "LINE", "el", "lin", "write", "raw", "block", "value", "part", "row", "response", "entry", "end", "unit", "le", "error", "status", "content"]}}
{"id1": "3375724", "id2": "12246545", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitULosFe", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitulosFe", " importarEmissoresDosTituloF", " importarEmissoresDosTitulosf", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitularF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitulof", " importarEmissoresDosTituloFe", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTituloPF", " importarEmissoresDosTitulasF", " importarEmissoresDosTitULoPF", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitularf", " importarEmissoresDosTitulasf", " importarEmissoresDosTitulosF", " importarEmissoresDosTitulosPF", " importarEmissoresDosTitulasPF"], "pArquivoTXT": ["pArquivoBEMP", "pArquivaTxt", "pArquivTxt", "pArquivoFEXT", "pArquivoBLS", "pArquivoOTXT", "pArquivoOTTP", "pArquivDBT", "pArquivoLXT", "pArquivDXT", "pArquivoFxt", "pArquivTLS", "pArquivaTXT", "pArquivoTEMP", "pArquivaTBT", "pArquivoTBT", "pArquivaFEMP", "pArquivaFTP", "pArquivoBXT", "pArquivTBT", "pArquivoBTP", "pArquivaFXT", "pArquivaTTP", "pArquivoQXT", "pArquivDLS", "pArquivoTLS", "pArquivoQBT", "pArquivoFTP", "pArquivDxt", "pArquivTXT", "pArquivoBBT", "pArquivaTEMP", "pArquivoDLS", "pArquivoLBT", "pArquivoLLS", "pArquivoOTEMP", "pArquivoFXT", "pArquivaFEXT", "pArquivoDxt", "pArquivoQxt", "pArquivaFxt", "pArquivaTEXT", "pArquivoBxt", "pArquivoLxt", "pArquivoTxt", "pArquivoTTP", "pArquivoDXT", "pArquivoOTxt", "pArquivoDEXT", "pArquivoFEMP", "pArquivoTEXT", "pArquivoDBT", "pArquivaFBT", "pArquivoFBT", "pArquivoQEXT"], "pAndamento": [" pAndmentoo", " pAndementO", " pOramentoo", " pAndentionO", " pOrementO", " pOrementoo", " pAndamentO", " pAndentionoo", " pOramentos", " pOramento", " pAndamentos", " pAndmento", " pAndemento", " pAndamentoo", " pAndmentO", " pAndentionos", " pAndmentos", " pOrementos", " pAndentiono", " pAndementoo", " pAndementos", " pOremento", " pOramentO"], "numeroDoRegistro": ["numeroDoregestros", "numeroDoRegiftro", "numeroDoRegestros", "numeroDoRegistrano", "numeroDoregestro", "numeroDoregistrano", "numeroDoRegestro", "numeroDoRegpectro", "numeroDoRegiftrano", "numeroDoregistorno", "numeroDoregistros", "numeroDoRegestrano", "numeroDoRegpectros", "numeroDoregistro", "numeroDoregestorno", "numeroDoRegistros", "numeroDoRegestorno", "numeroDoRegiftorno", "numeroDoRegpectorno", "numeroDoRegiftros", "numeroDoregestrano", "numeroDoRegpectrano", "numeroDoRegistorno"], "in": ["ln", "span", "inn", "out", "session", "c", "f", "config", "s", "with", " out", "ex", "i", "l", "IN", "data", "m", "con", "ini", "ner", "n", "g", "bin", "url", " IN", "b", "is", "query", "nin", "conf", "ins", "connection", "cin", "scan", "cl", "In", "again", "rin", "kin", "part", "err", "r", "t", "login", "slice", "reader", "inc"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialCombario", "stmtLimpezaInicialDestario", "stmtLimpezaInicialCombania", "stmtLimpezaInicialdestario", "stmtLimpezaInicioDestario", "stmtLimpezaInicioCombario", "stmtLimpezaInicialdestino", "stmtLimpezaInicialDesaco", "stmtLimpezaInicialDestao", "stmtLimpezaIniciaDestination", "stmtLimpezaInicioDestino", "stmtLimpezaInicioCombao", "stmtLimpezaInicioCombino", "stmtLimpezaIniciaDestania", "stmtLimpezaInicialdestao", "stmtLimpezaInicialDesao", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombao", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDestination", "stmtLimpezaInicialDesario", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestaco", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestania", "stmtLimpezaInicialdestania", "stmtLimpezaInicioDestao"], "sql": ["ls", "eps", "software", "filename", "result", "sb", "util", "json", "csv", " SQL", "kl", "ql", "s", "seed", "cmd", "sg", "sol", "expr", "l", "socket", "install", "data", "sys", "nl", "lua", "where", "dl", "comment", "statement", "description", "shell", "url", "log", "SQL", "search", "spec", "params", "setup", "rl", "msg", "stat", "sl", "query", "zip", "body", "term", "string", "fn", "details", "el", "sq", "acl", "html", "sn", "QL", "err", "ssl", "sf", "id", "sv", "layout", "db", "select", "liquid", "http"], "stmtDestino": ["stmtDistino", "stmtCamporno", "stmCamporno", "stmtDistaco", "stmtdestorno", "stmCampino", "stmtDestaco", "stmtDestorno", "stmtDestin", "stmtCampania", "stmtdestinos", "stmCampaco", "stmCampania", "stmtCampaco", "stmdDestorno", "stmtDistin", "stmtDestinos", "stmtdestania", "stmtDistorno", "stmDestania", "stmtdestaco", "stmtDistinos", "stmtdestin", "stmtCampino", "stmdDestinos", "stmdDestin", "stmDestorno", "stmdDestino", "stmtDestania", "stmDestino", "stmDestaco", "stmtDistania", "stmtdestino"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABECALSHI", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABECALLHOU"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPJTO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAPE_TO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADANDOSAD", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADADIES___"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_EGIS", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_POR_RegIES", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_RegIS"], "tamanhoDosArquivos": ["tamanhoDosArqIVlos", "tamanhoDosArQUivos", "tamanhoDosArquivalos", "tamanhoDosArqIVo", "tamanhoDosArQUivo", "tamanhoDosArquievOs", "tamanhoDosArqIVoes", "tamanhoDosArquivaloes", "tamanhoDosArquivalo", "tamanhoDosArquIVos", "tamanhoDosArquIVoes", "tamanhoDosArquivOs", "tamanhoDosArquivoes", "tamanhoDosArquervlos", "tamanhoDosArquervoes", "tamanhoDosArQUervlos", "tamanhoDosArQUivlos", "tamanhoDosArqivos", "tamanhoDosArquIVo", "tamanhoDosArquIVOs", "tamanhoDosArquIVlos", "tamanhoDosArQUervos", "tamanhoDosArquievos", "tamanhoDosArquervo", "tamanhoDosArqivo", "tamanhoDosArquivo", "tamanhoDosArquivallos", "tamanhoDosArquivlos", "tamanhoDosArquievo", "tamanhoDosArquervos", "tamanhoDosArqivoes", "tamanhoDosArquervOs", "tamanhoDosArQUervOs", "tamanhoDosArqivlos", "tamanhoDosArQUivOs", "tamanhoDosArquievlos", "tamanhoDosArQUervo", "tamanhoDosArqIVos"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimmada"], "registro": ["regastros", "regastration", "regustros", "registros", "regestro", "regustro", " regestro", " registulo", " regestros", "regustulo", " regestration", " regestulo", "regestros", " registros", "regestration", "regustration", "regastulo", "registration", "regastro", "regestulo", " registration", "registulo"], "campos": ["CampOS", " campas", " caso", "Campo", "Campas", " campOS", "campOS", "campo", " campo", " casos", "Campos", " casOS", "campas", " casas"]}}
{"id1": "5977352", "id2": "6421904", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyDir", "copyfile", " copyDir", "CopyFile", "copyFiles", " copyFiles", "transferfile", "transferFile", "transferDir", "Copyfile", "CopyFiles", " copyfile", "CopyDir"], "src": ["source", "filename", "sb", "uri", "fp", "path", "config", "s", "this", "buf", "view", "input", "ource", "conn", "inst", "loc", "data", "loader", "resource", "proxy", "img", "url", "tmp", "b", "proc", "obj", "files", "sel", "sc", "sl", "dist", "rc", "rb", "ins", "gb", "stream", "file", "slice"], "dest": ["source", "cache", "output", "table", "st", "path", " destination", "config", "home", "store", "this", "master", " Dest", "txt", "d", "de", "trans", "project", "rest", "cdn", "folder", "done", "dep", "later", "img", "class", "url", "tmp", "name", "cont", "null", "die", "obj", "destroy", "zip", "dist", "cp", "thin", "orig", "desc", "file", "temp", "route", "wb", "Dest", "part", "dir", "parent", "opt", "target", "delete", "dc"], "bufSize": ["buf2", "ufSize", "bufferSize", "buffersize", " bufsize", "bufLen", "uf2", "queueSize", "ufLen", " buf2", " bufLen", "queuesize", "queueLen", "buffer2", "ufsize", "bufsize", "bufferLen"], "force": ["ride", "p", "source", "Force", "remote", "ist", "sync", "push", "dirty", "load", "forces", "front", "f", "store", "use", "place", "hard", "urse", "count", "base", "deep", "rc", "require", "write", "only", "auto", "replace", "like", "file", "parent", "forcing", "pull", "route", "id", "forced", "apply", "flush", "delete", "no"], "buffer": ["source", "result", "cache", "length", "memory", "load", "buff", "fb", "buf", "seed", "bytes", "uffer", "border", "padding", "data", "binary", "zero", "limit", "url", "base", "b", "null", "transfer", "split", "address", "append", "Buffer", "queue", "write", "raw", "batch", "reference", "iter", "value", "request", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "text", "ride", "seek", "create", "select", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "lex", "len", "use", "view", "pass", "show", "level", "READ", "i", "input", "send", "skip", "ed", "count", "k", "sleep", "ind", "data", "build", "close", "ad", "open", "play", "find", "ip", "io", "n", "connect", "next", "b", "add", " write", "allow", "exec", "reads", "index", "size", "write", "raw", "block", "iter", "wait", "feed", "id", "reader", "end", "get", "start", "d", "fill", "run"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "c", "ac", "f", "pass", "ex", "i", "input", "socket", "conn", "image", "sin", "inside", "serv", "IN", "m", "con", "win", "ini", "up", "n", "isin", "a", "url", "base", "din", "b", "nin", "min", "ins", "connection", "cin", "thin", "In", "inc", "again", "rin", "kin", "lib", "part", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "ac", "at", "home", "this", "with", "w", "ex", "i", "one", "max", "socket", "conn", "OUT", "line", "image", "by", "writer", "n", "io", "up", "bin", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "nin", "connection", "exp", "plain", "Out", "write", "outs", "again", "off", "lib", "part", "err", "key", "o", "id", "user", "inc", "co", "can", "no"]}}
{"id1": "22441244", "id2": "2511579", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "11556231", "id2": "539195", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"ByURL": ["ByUrl", "CreateURI", "bySSL", "byURI", "CreateURL", "byURL", "createUrl", "ByURI", "createSSL", "CreateSSL", "createURI", "createURL", "byUrl", "BySSL", "CreateUrl"], "urlstr": ["httpSTR", "Urlname", "Urlstr", "URLname", "URLstr", "urlname", "UrlSTR", " urlname", "Urlstring", "httpStr", "URLstring", "httpstr", "urlStr", "httpstring", "URLStr", " urlSTR", " urlstring", "urlstring", "UrlStr", "urlSTR", "URLSTR"], "uri": ["text", "filename", "absolute", "path", "username", "Url", "domain", "i", " URI", "manager", "image", "resource", "location", "description", "io", "directory", "database", "base", "server", "host", "URL", "ui", "query", "address", "pi", "iri", "string", "direction", "prefix", "qi", "attribute", "collection", "file", "route", "href", "URI", "id", "type", "ri", "http"], "url": ["client", "path", "session", "Url", "download", "f", "system", "page", "link", "l", "conn", "image", "loc", "loader", "web", "service", "resource", "location", "proxy", "base", "server", "host", "URL", "sl", "address", "li", "string", "channel", "stream", "file", "ssl", "feed", "id", "user", "http"], "connection": ["relation", "client", "connected", "c", "system", "Connection", "i", "control", "l", "socket", "conn", "or", "application", "writer", "con", "resource", "open", "director", "io", "directory", "connect", "database", "server", "URL", "body", "channel", "stream", "handler", "collection", "response", "context", "http"], "in": ["as", "init", "inn", "out", "client", "inner", "c", "ac", "f", "s", "i", "input", "socket", "conn", "or", "IN", "writer", "ini", "con", "bin", "a", "and", "connect", "ins", "stream", "lin", "In", "kin", "r", "login", "inc", "cms"], "reader": ["buffer", "result", "out", "reading", "client", "inner", "ler", "i", "input", "conn", "or", "read", "writer", "loader", "ini", "resource", "io", "server", "rc", "channel", "stream", "handler", "ais", "wrapper", "parser", "Reader", "iter", "row", "r", "er", "entry"], "is": ["mis", "as", "ris", "im", "IS", "out", "isa", "was", "ai", "s", "info", "iss", "i", "Is", "serv", "conn", "src", "ci", "or", "iso", "lis", "rs", "sr", "io", "si", "os", "ui", "fs", "isl", "isi", "sp", "iri", "ins", "rss", "ais", "ios", "iris", "err", "nis", "bis", "has", "ri", "cms"], "document": ["message", "result", "output", "config", "root", "ocument", " documents", "writer", "m", "object", "resource", "node", "class", "database", "graph", "docs", "Document", "Documents", "element", "collection", "response", " documentation", "parent", "xml", "doc", "content", "application"], "source": ["text", "language", "instance", "info", "content", "driver", "input", "src", "SOURCE", "Source", "service", "object", "resource", "class", "container", "string", "stream", "element", "parser", "file", "unit", "parent", "node", "context"], "name": ["text", "filename", "property", "instance", "NAME", "info", "domain", "root", "word", "Name", "names", "definition", "object", "format", "resource", "location", "comment", "description", "base", "string", "tag", "prefix", "element", "value", "file", "attribute", "named", "key", "URI", "id", "type", "parent", "node"], "namespaceURI": ["namesheetURI", "namesistenceFINE", "Namespacesuri", "perspacedGI", "NamespacesMI", "NamespacesURI", "NamespaceURI", "nameservingURI", "namesistenceURI", "namesheetGI", "namespaceduri", "namespacedURI", "namesferenceURI", "namespacedNS", "namespaceNS", "namespacesFINE", "namesistenceuri", "namesferenceFINE", "namespacedGI", "Namespaceuri", "perspaceduri", "namesferenceuri", "namespaceGI", "namespacesuri", "perspaceGI", "perspaceURI", "namespacesMI", "NamespacesFINE", "NamespaceMI", "namespaceFINE", "nameservingNS", "namespacesURI", "namespaceMI", "perspacedURI", "namespaceuri", "nameservinguri", "namesferenceMI", "NamespaceNS", "namesheeturi", "perspaceuri", "namesistenceMI", "NamespaceFINE"], "qualifiedName": ["qualPath", " qualifiedname", "localType", "fixedname", "qualifiedType", " qualifiedURI", "localPath", "simplename", "qualURI", " qualifiedType", "qualName", "simplePath", "fixedName", " qualifiedPath", "fixedPath", "localname", "qualifiedPath", "qualifiedURI", "fixedType", "qualname", "simpleURI", "simpleName", "qualifiedname"], "data": ["text", "message", "buffer", "property", "media", "str", "output", "script", "DATA", "language", "config", "NAME", "info", "model", "input", "default", "definition", "object", "resource", "context", "format", "node", "ata", "description", "class", "base", "number", "child", "body", "string", "stream", "element", "def", "value", "template", "id", "comments", "type", "parent", "xml", "doc", "content"], "tagName": [" tagClass", "TagClass", "localClass", "Tagname", "TagName", "tagClass", "localname"], "target": ["method", "uid", "property", "prop", "path", "instance", "info", "NAME", "head", "component", "domain", "root", "object", "Target", "location", "resource", "format", "next", "class", "base", "host", "label", "address", "href", "template", "parent", "node"], "elementId": ["elementid", " elementID", "objectTag", "elementID", "nodeId", "objectId", " elementid", "objectid", " elementTag", "nodeID", "elementTag", "nodeTag", "objectID", "nodeid"], "tagname": ["className", "classname", "TagNAME", "tagNAME", " tagNAME", "classNAME", "Tagname", "TagName"], "localName": [" localname", "clientName", " localNAME", "localname", "clientNAME", "clientname", "qualifiedname", "qualifiedNAME", "localNAME"]}}
{"id1": "13596891", "id2": "7166270", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 1, "substitutes": {"doTransfer": ["handleTransfer", "doImport", " doSend", "makeSend", "doRequest", "makeImport", "handleRequest", "makeRequest", " doImport", "makeTransfer", "handleSend", "doSend", "handleImport", " doRequest"], "request": ["message", "form", "create", "remote", "result", "position", "re", "current", "client", "session", "instance", "config", "com", "this", "model", "http", "event", "command", "input", "enter", "complete", "condition", "req", "data", "q", "in", "object", "resource", "record", "QUEST", "subject", "server", "requ", "post", "query", "time", "connection", "stream", "queue", "rf", "received", "version", "reader", "type", "user", "xml", "Request", "report", "context", "application"], "response": ["message", "call", "remote", "result", "re", "output", "json", "client", "out", "cache", "session", "cover", "status", "model", "page", "view", "event", " Response", "success", "serv", "image", "default", "application", "resp", "writer", "warning", "service", "object", "resource", "reply", "next", "document", "server", "Response", "res", "body", "index", "onse", "connection", "header", "respond", "full", "en", "version", "results", "site", "error", "report", "content", "http"], "method": ["text", "message", "call", "position", "property", "mode", "json", "METHOD", "path", "session", "date", "head", "use", "cmd", "command", "send", "process", "resource", "format", "description", "class", "callback", "subject", "reason", "hod", "verb", "term", "time", "string", "direction", "prefix", "sort", "version", "route", "pull", "sign", "type", "Method", "status", "content"], "servletContext": ["servlexConfig", "servletsConfig", "ServletsConfig", "servleContext", "Servletscontext", "servantCurrent", " servletCurrent", "servantProvider", " servletConfig", "ServletsController", "servletConfig", "servlexContext", "servApplicationcontext", " servantConfig", "ServletConfig", "servletsController", "Servletcontext", "ServletsContext", "servApplicationConfig", "servleConfig", "ServletController", "servantConfig", "servantContext", "servlexcontext", "servApplicationController", "servleProvider", " servantCurrent", "servLETCurrent", "servletcontext", "servletsContext", "servApplicationContext", " servletProvider", " servantProvider", "servLETProvider", "ServletContext", "servletProvider", "servLETContext", "servletscontext", "servletCurrent", "servLETConfig", "servlexController", "servleCurrent", " servantContext", "servletController"], "wac": ["wsacs", " Wae", " Wacs", " wAC", "wsac", "wae", " wae", "wAC", "wsAC", " Wac", " WAC", " wacs", "wacs", "wsae"], "szUrl": ["szeFrame", "sizUrl", "szerURL", "szaURL", "szurl", "szaUrl", " sizURL", "asizFrame", "szeurl", "sizURL", "szenURL", "szeUr", "szenurl", "sznURL", "szPath", "szeURL", "aszUrl", "sizFrame", " szURL", "aszurl", "aszURL", " szurl", "szerUr", "szeFolder", " sizFolder", " sizUrl", "sznurl", "aszUr", "szeUrl", "aszFrame", "asizUrl", "sziurl", "sizurl", "szFrame", "szenFolder", "sznPath", "szaUr", "szerUrl", "aszPath", "sznUr", " szFolder", "asizURL", "asizurl", "sznUrl", " sizurl", "sizFolder", "sziUrl", "sizUr", "sziURL", "szaPath", "szerFrame", "szenUrl", "sizPath", "sziUr", "szFolder", "szUr", "szURL", "asizUr", "asizPath"], "url": ["source", "org", "gl", "buffer", "cloud", "re", "uri", "client", " URL", "Url", "f", "config", "page", "event", "il", "l", "socket", "conn", "loc", "web", "service", "resource", "location", "context", "lb", "www", "base", "name", "log", "server", "host", "obj", "URL", "rl", "fl", "sl", "li", "connection", "string", "ur", "stream", "ul", "el", "ll", "impl", "file", "ssl", "key", "user", "get", "xml", "rel", "http"], "is": ["x", "as", "ris", "rx", "uri", "IS", "im", " isn", "isa", "was", "oss", "us", "ai", "info", "ii", "il", "isu", "iss", "i", "Is", "src", "serv", "ci", "iso", "web", "ib", "lis", "ir", " bis", "ip", "io", " are", "os", "it", "isf", "isc", "isl", "bs", "isi", "rc", "ais", "ios", "ils", "bis", "has", "ri", "cms"], "sout": ["Souts", " souts", "sdata", "sin", "SOut", " sOut", " sin", "Sin", "Sout", "souts", " sdata", "SOUT", "Sdata", "sOUT", "sOut", " sOUT"], "con": ["remote", "cache", "uc", "event", "Connection", "ca", "close", "core", "conf", "Con", "cur", "cc", "cp", "general", "fc", "un", "crit", "ct", "ctx", "type", "run", "can", "http", "ren", "pre", "util", "client", "ctrl", "pin", "ocon", "com", "ver", "view", "java", "conn", "const", "win", "don", "cos", "lc", "rc", "nc", "coll", "user", "cons", "pen", "fun", "cf", "single", "internal", "wa", "bc", "pc", "subject", "C", "gen", "wan", "en", "version", "san", "syn", "non", "login", "get", "inc", "status", "Internal", "xc", "re", "net", "c", "author", "l", "func", "m", "web", "open", "ec", "on", "connect", "conv", "server", "exec", "ran", "fe", "query", "min", "connection", "fa", "cl", "Common", "cn", "ssl", "CON", "common", "co"], "hNames": ["hrName", " hKeys", "hostNs", " hName", "HFiles", "HNames", "hBlocks", "hVs", "hrNs", " hNs", "HVs", " hBlocks", "hostTypes", "HName", " hFiles", " hVs", "ihBlocks", "hrTypes", "hTypes", "hKeys", "hostKeys", "hNs", " hTypes", "HBlocks", "hostNames", "ihName", "ihVs", "hrNames", "hFiles", "hrKeys", "ihNames", "HTypes", "hrFiles", "hName"], "txt": ["text", "ht", " text", "rx", "gt", "tin", "fp", "str", "fx", "git", "csv", "py", "vt", "gi", "lt", "gz", "wt", "rr", "phrase", "nt", "tx", "et", "XT", "qt", "elt", "utt", "nm", "q", "in", "prot", "TEXT", "binary", "name", "bt", "wx", "dt", "Text", "obj", "zip", "htm", "header", "struct", "inet", "jp", "value", "lv", "t", "key", "xt", "ct", "sv", "xxx", "kt", "v", "section", "cb", "ctx"], "inBody": [" inbody", "insReader", "InReader", "outFile", "inReader", "INbody", "insFile", "INStream", "Inbody", "insBody", "INReader", "InFile", " inReader", "InBody", " inFile", "INFile", "inFile", "inbody", "INBody", "insStream", " inStream", "outStream", "outbody", "outBody", "inStream", "InStream"], "bufCh": ["bufferch", "buffCh", " bufChar", "ufCol", "ufCH", "bufferCH", "ufCh", "queueCol", "bufch", "ufChar", "bufC", " bufC", "ufC", "queueCh", "ufch", "buffC", "queuech", " bufch", " bufCH", "bufferChar", "bufChar", "bufCH", "buffch", "bufferCh", " bufCol", "buffCH", "queueCH", "bufCol"], "r": ["p", "x", " rg", "result", "re", "str", "br", "c", "f", "reg", "rr", "w", "e", "i", "k", "m", "q", "ner", "rs", "ru", "sr", "n", "g", "ar", "v", "b", "u", "hr", "R", "nr", "rl", "cr", "rd", "res", "rc", "rb", "fr", "rw", "pr", "range", "lr", "rf", "rt", "er", "ror", "err", "reader", "rh", "ri", "d", "rg"], "outReq": ["outRquest", "outRece", " outRequest", " outRereq", "outConh", " outReh", "outDece", "outRsque", "outREce", " outEreq", " outEque", "outRecck", "outEque", "outRecce", " outSeck", "outReck", " outRsh", "outRque", "outREh", " outRque", "outREq", "outRsce", "outRreq", " outEq", "outEck", " outEck", "outDequest", "outRecque", "outREck", "outEq", "outSeq", "outReh", "outSequest", "outDeque", "outRq", "outREque", " outReck", "outRecreq", " outRece", "outConce", " outRsce", "outRsq", " outSeq", " outRsq", "outEreq", " outRsque", "outRereq", "outConq", "outSeck", " outReque", "outRsh", " outSeque", " outRquest", "outConque", "outRecq", "outDeq", "outRce", " outRce", " outSece", "outSeque", "outReque", "outRck", "outSece", " outRq", "outRequest"], "buff": [" Buff", "p", "buffer", "uf", "lines", "f", "bb", "info", "buf", "map", "data", "num", "b", "array", "Msg", "Pad", " Buffer", "Ptr", "Buffer", "ch", " chunk", "Info", "file", " buffers", "Buff"]}}
{"id1": "2324868", "id2": "8430178", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"actionPerformed": ["actionOccuted", "actionCalled", "actionExecuted", "actionPeralled", "actionExecalled", " actionPeruted", " actionExecuted", "actionExecressed", " actionExecformed", " actionExecressed", "actionCuted", "actionPerressed", " actionExecalled", " actionPeralled", "actionExecformed", "actionOccalled", "actionOccressed", "actionPeruted", " actionPerressed", "actionCformed", "actionOccformed", "actionCressed"], "e": ["x", "me", "se", "c", "f", "event", "de", "exc", "et", "an", "E", "q", "ec", "self", "g", "a", "name", "te", "ee", "ae", "es", "ev", "t", "ctx", "v", "events", "type", "ception"], "delim": ["selam", "delcm", " delimmer", " delcm", "elim", "delam", "selim", "Delem", "selm", " delam", "selem", "flimmer", "delimmer", "Delcm", "flim", "delem", "Delam", "flcm", "flam", "Delimmer", "elem", "Delm", "elam", "Delim", "delm", "elm"], "r": ["p", "kr", "rx", "re", "br", "c", "f", "rr", "w", "rar", "i", "l", "writer", "rs", "ir", "ws", "sr", "ru", "n", "ar", "hr", "adr", "R", "cr", "rl", "res", "rss", "rb", "dr", "rc", "fr", "rw", "pr", "lr", "iter", "rt", "tr", "err", "er", "reader", "rh", "nr"], "line": ["text", "source", "lf", "look", "style", "Line", "re", "lines", "str", "cell", "page", "pass", "link", "one", "word", "l", "inline", "val", "data", "nl", "comment", "job", "name", "log", "col", "pe", "lc", "code", "sel", "rl", "number", "split", "sl", "time", "string", "rule", "header", "LINE", "el", "lin", "cl", "block", "value", "file", "row", "response", "key", "entry", "id", "reader", "end", "le", "feed", "fin", "no"], "url": ["ls", "org", "uri", "client", "path", "Url", "f", "link", "l", "loc", "blog", "web", "nl", "resource", "sr", "www", "base", "log", "server", "host", "URL", "rl", "fl", "sl", "connection", "string", "fr", "ur", "lr", "file", "pull", "ssl", "err", "ob", "jar", "http"], "conn": ["p", "fp", "out", "sync", "cf", "ctrl", "client", "cb", "c", "f", "dc", "Connection", "w", "nt", "l", "socket", "Conn", "loc", "con", "open", "pub", "n", "io", "connect", "ann", "conv", "cr", "ch", "gr", "api", "rc", "cur", "connection", "nc", "lock", "cp", "rn", "enc", "coll", "pr", "cl", "cm", "sql", "cn", "rt", "ssl", "err", "ct", "ctx", "db", "co", "http"], "wr": ["wer", "wy", "kr", "Wr", "rx", "out", "wk", "wd", "rr", "w", "wt", "mr", "vr", "rar", "war", "riter", "writer", "rs", "sr", "Writer", "wa", "wx", "hr", "fw", "cr", "res", "gr", "rss", "dr", "rb", "wh", "fr", "rw", "shr", "wrap", "WR", "pr", "write", "nw", "wm", "rt", "err", "wb", "wave", "wl", "RW", "rh", "nr", "wal", "ew"], "tokens": ["pargen", "Tokoks", "tokenens", "takos", "targens", "Taken", "itokenets", "token", "targelines", "tokenets", "Tokens", "pargens", "takets", "takelines", "tkicks", "takens", "takoks", "targen", "toyen", "tokos", "tokoks", "tokets", "Takicks", "Takens", "torkicks", "Tokicks", "pargets", "itokenos", "toyets", "tokenos", "tokicks", "Token", "tkens", "pokets", "torken", "targets", "toyens", "itokens", "tkoks", "torkens", "tken", "itoken", "takicks", "tOKelines", "tokelines", "tOKen", "tokenen", "poken", "tOKens", "torkoks", "pargelines", "itokenens", "toyos", "itokenen", "taken", "pokelines", "itokets", "Takoks", "itokos", "tOKets", "pokens"], "in": ["init", "ln", "inn", "str", "out", "gin", "pin", "inner", "ina", "i", "input", "inas", "sin", "IN", "data", "ini", "win", "con", "n", "isin", "bin", "arin", "io", "vin", "it", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "kin", "pull", "err", "oin", "reader", "zin", "din", "tin", "ic"]}}
{"id1": "22135199", "id2": "8430178", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCodingOfFiles", "testCachingOfFiles", "testCodingEmptyFiles", "testCodingZeroFile", "testCodingNoSourceFile", "testCodingOfSourceFile", "testCachingEmptyFiles", "testCachingEmptyFile", "testCodingNoStream", "testCodingNoFile", "testCachingOfFile", "testCachingOfStream", "testCodingEmptySourceFile", "testCodingZeroSourceFile", "testCodingOfStream", "testCachingEmptySourceFile", "testCachingOfSourceFile", "testCodingZeroFiles", "testCachingEmptyStream", "testCodingNoFiles", "testCodingEmptyStream", "testCodingOfFile", "testCodingZeroStream"], "baos": ["buo", " baotes", "waOS", "BaOS", "kao", "Baoes", "baoa", "baOs", "buOS", "waOs", "baoS", " baoS", "kaos", "aaaaOS", "pao", "bios", "buoa", " baoes", "kaOS", "bioes", "Baotes", "BaOs", "baotes", "baOS", "buos", "biotes", "aaaaoS", "paOS", "Baos", "aaaaos", "BaoS", "kaoa", "waos", "paoa", "bioS", "waoS", "bao", "paos", "baoes", "aaaaOs"], "channel": ["flow", "source", "group", "video", "out", "client", "cho", "c", "config", "system", "console", "socket", "conn", "an", "data", "service", "self", "bean", "io", "camera", "url", "log", "server", "sc", "ch", "container", "connection", "Channel", "handler", "queue", "stream", "chan", "cam", "sea", "feed", "reader", "parent", "can", "context", "annels"], "params": ["cmp", "ps", "mm", "Param", "config", "Par", "param", "processor", "options", "conn", "tx", "cpu", " param", "null", "proc", "stats", "api", "ams", "size", "par", " parameters", "Parameters", "settings", "parser", "css", "ctx", "cms", "ops", "http"], "outbuf": ["inputbuf", "outputcb", "outputqueue", " outbag", "outbuffer", " outbuff", "inputqueue", " outbuffer", "outcb", "outputbuf", " outcb", "Outbuff", " outqueue", "outbuff", "inputbag", "outbag", "outputbuffer", "Outbuffer", "outqueue", "outputbuff", "Outcb", "inputbuff", "Outbuf", "outputbag"], "metrics": ["Metrix", "Metras", "metrix", "metals", "matrix", "monrics", "monics", "Metals", "matals", " metals", "Metric", " metrix", "monric", " metics", "matric", "matrics", "Metrics", " metras", "metras", "Metics", "metric", "monras", "metics", " metric"], "encoder": ["eccode", "enode", "Encoding", "ecode", "encoded", " encoser", "encipher", "encler", "encode", "enccode", " encressor", "Encipher", "Encoded", "Encode", "ecipher", "enoser", "enressor", "ecressor", "enoded", " enccode", " encler", " encode", "ecoding", " encipher", "enoder", "ecoded", " encoding", "ecoser", "encoser", "encoding", " encoded", "Encler", "ecler", "Encoser", "Encoder", "ecoder", "encressor"], "tmpFile": ["testfile", "poraryfile", "tempFolder", "mpFunction", "tmpPage", "tmpPath", "txtPage", "tempFiles", "mpPath", "tmpFilename", "tempFile", "txtFile", "mpfile", "testFile", "txtFunction", "poraryFile", "poraryPage", "tmpFiles", "tmpDir", "mpFile", "testFolder", " tmpfile", " tmpFiles", " tmpPath", "txtfile", "mpFilename", "tempfile", "tmpFolder", "mpPage", " tmpDir", "tmpFunction", "tmpfile", "testFiles", "vtDir", "vtFile", "vtFilename", " tmpFolder", "poraryFunction", " tmpFilename", "mpDir", "tempPath", "vtfile", "mpFiles"], "fout": ["furl", "sfout", "sfchannel", "fwrite", "fdout", "fragain", "flagain", "Fout", "fdwrite", "flurl", "fio", " fio", "Fio", "Ffile", "sfio", " ffile", "Fchannel", "fagain", "frout", "frwrite", "sffile", "fdurl", "flwrite", "flout", "frurl", "fdagain", "ffile"], "wrtout": ["wrcouter", "wrdouter", "wadrout", "WRTout", "wrtOut", "wrcagain", " wrtin", " wrtouter", "Wrtout", "wrtn", "wadrwriter", "WrtOut", "wrout", "wRTout", "wrcin", "wrdin", "WRTwriter", "wrdout", "WRTouter", "wadragain", "wRTOut", "wrtwriter", "wRTin", "wrOut", "WRTOut", "wadrouter", "wrdwriter", "WRTn", "wRTwriter", "wrin", " wrcagain", "wadrin", "wrcOut", "wrn", "wrcout", "Wrtn", "Wrtwriter", "Wrtin", "Wrtouter", "wRTagain", " wrcin", " wrtagain", " wrcout", "WRTin", "wrtin", "wRTouter", " wrcouter", "wrcn", "wrtagain", "wrtouter", "wRTn"], "fchannel": ["hqueue", " fconn", " fchan", "fconn", "fchan", "bchannel", " fcontainer", "pchannel", "hchannel", "fenqueue", "hresource", "bchan", "fstream", "pconn", "fenstream", "presource", "fqueue", "hstream", "fenresource", "fcontainer", "bconn", "fenchannel", "bcontainer", "pcontainer", "pstream", "fresource", "pchan", "pqueue"], "s": ["p", "ls", "su", "ps", "ts", "ss", "c", "f", "e", "i", "services", "l", "m", "strings", "n", "g", "ses", "ms", "u", "qs", "b", "os", "states", "string", "ins", "gs", "ings", "settings", "ns", "es", "abs", "t", "r", "o", "S", "v", "js"]}}
{"id1": "8064604", "id2": "17207832", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"init": ["create", "reset", "set", "client", "load", "update", "config", "info", "construct", "sleep", "build", "install", "open", "initial", "it", "setup", "transfer", "exec", "connection", "Init", "activate", "cli", "boot", "launch", "start"], "mgr": ["amgr", "ambr", "amigr", "marr", "Mgr", "pigr", "amrr", " migr", "migr", " mr", "mr", "mbr", "prr", "mrr", "Mtr", "cgr", "pgr", "mtr", "cr", " mtr", "Marr", "pbr", " mrr", "ctr", " marr", "Mr", "carr", " mbr"], "cfg": ["cache", "MC", " chain", "cf", " config", "cb", "config", " conf", " cf", "map", "gate", "gp", "g", "Conf", "Msg", "Hash", "gen", "password", " cache", "conf", "bm", " img", "chain", "mem", "file", "mc", " ssh", "db", " configuration"], "sock": [" socket", "opensib", "opensocket", "opensocks", " socks", "gesocks", "gesink", "Sink", "gesock", "socket", "Socket", "Sock", "opensock", "sib", "gesocket", "Socks", " sink", " sib", "socks", "Sib", "sink"], "_cman": [" _cgr", "_cfg", "_mman", "_cmn", " _cmn", "_mcgr", " _mcfg", " _cfg", " _mcman", "_mfg", " _mcmn", "_gman", "_mcman", "_mmn", "_gfg", "_mcfg", "_cgr", "_mcmn", "_mgr", "_gmn", "_ggr", " _mcgr"], "_sock": ["_unsock", "_opensocket", " _svc", "_sdk", "_nsock", "_Svc", " _serve", "_socket", "_csocks", "_sort", "_svc", "_nsockets", "_openserve", "_docks", "longsock", "_unsocks", "_opensort", "_unsocket", "_Socks", "_sockets", "_asockets", "_unsdk", "_Sock", "_bocket", "longsrc", "_opensvc", " _socks", "longnsrc", "_bort", "_Sdk", "_dock", "_socks", "_csock", "_dort", "_opensock", "_jsocks", "longnsocks", "_docket", "_jsdk", "_nsocks", "_bock", "_nsrc", "_opensocks", "_jsock", "_bocks", "longnsockets", "_src", "longsocks", "_csockets", "longnsock", "_asock", "longsockets", "_asocks", "_csrc", "_jsocket", "_serve", "_Serve", "_asrc", "_Socket"], "i": ["p", "x", "my", "uri", "field", "inner", "ni", "f", "ai", "s", "ii", "gi", "ix", "info", "e", "ie", "l", "I", "k", "ci", "m", "ini", "in", "q", "chi", "multi", "ip", "io", "bi", "iu", "si", "n", "u", "ti", "it", "b", "is", "ui", "pi", "ji", "oi", "li", "index", "j", "h", "hi", "mi", "di", "qi", "value", "y", "xi", "r", "slice", "o", "id", "v", "ri", "d", "phi"], "key": ["text", "source", "json", "k", "ip", "base", "name", "search", "code", "rule", "pid", "temp", "entry", "type", "section", "char", "token", "ace", "check", "shift", "phrase", "root", "data", "pick", "fix", "label", "ki", "sum", "id", "order", "pair", "secret", "match", "kid", "cy", "str", "fee", "field", "point", "link", "cert", "nice", "number", "string", "prefix", "qi", "value", "op", "KEY", "ck", "length", "wire", "ask", "ie", "kh", "q", "mac", "mix", "change", "query", "index", "connection", "patch", "lock", "trust", "row", "sign", "Key"], "_sout": ["_sbio", "_sbout", "_sein", "_seio", "_seout", "_SOut", "_sOut", "_Sin", "_Sio", "_sin", "_sio", "_sbin", "_sbOut", "_seOut", "_Sout"], "_sinp": ["_sinpc", "_inpc", "_dispc", "_srer", "_inp", "_disp", "_srb", "_sinb", "_disb", "_srpc", "_iner", "_siner", "_inb", "_diser", "_srp"], "seed": ["secret", "source", "kid", "cookie", "char", "shape", "token", "json", "username", "shift", "pad", "slave", "driver", "root", "input", "black", "sleep", "kh", "data", "pick", "folder", "eed", "sudo", "shadow", "name", "random", "host", "theme", "password", "zip", "prime", "address", "sha", "delay", "index", "string", "finger", "dd", "digit", "scale", "sum", "serial", "sample", "test", "sql", "parser", "ruby", "row", "grain", "slice", "feed", "id", "pattern"], "rand": ["who", "re", "reg", "rr", "rar", "Rand", "max", "gram", "bird", "ind", "pick", "win", "bot", "round", "next", "grad", "der", "NG", "random", "gen", "cr", "nd", " random", "dist", "min", "dr", "rc", "dev", "chain", "ng", "range", "sample", "r", "roll", "id", "user", "rh", "start", "draw", "go"], "hex": ["x", "text", "cookie", "json", "buff", "loc", "auth", "transform", "ip", "code", "zip", "sha", "div", "tri", "serial", "lit", "pex", "iter", "temp", "pack", "rh", "pattern", "form", "closure", "char", "token", "check", "shift", "quant", "cross", "view", "cube", "shadow", "ticket", "wh", "raw", "sum", "batch", "id", "bin", "secret", "hess", "alph", "cf", "box", "string", "exp", "alpha", "chain", "scale", "loop", "sex", "length", "pad", "ex", "kh", "ph", "num", "mix", "letter", "ch", "oct", "index", "lock", "digit", "rex", "row", "cmp"], "pass": ["ride", "secret", "access", "press", "ss", "parse", "oss", "path", "flash", "push", "session", "cross", "skip", "line", "read", "process", "service", "auth", "PASS", "strip", "act", "fix", "allow", "proc", "gen", "code", "post", "password", "report", "oct", "rss", "Pass", "worker", "lock", "prefix", "fail", "test", "Password", "ass", "ress", "task", "route", "step", "feed", "sign", "login", "handle", "run", "mail"], "md5": ["MD85", "mand3", "sha2", "sha7", " MD\n", "MD\n", "mand5", "ma5", "md4", "md2", "sha4", " md3", "md\n", " mdody", "MD4", "md512", " md7", "sha512", "md3", "mdody", "md7", "sha5", "ma4", " md2", "MD2", "md\t", "MD5", "md85", "mand2", "ma85", " md85", "sha3", " MD\t", "MD512", " md4", " md\t", "ma2", "MDody", " md512", "mandody", " md\n", "MD\t", "MD7", "MD3"], "hash": ["text", "secret", "hed", "cache", "ash", "alt", "dig", "build", "kh", "addr", "auth", "mac", "url", "base", "host", "code", "password", "sha", "h", "string", "header", "lock", "sum", "ruby", "block", "ha", "html", "version", "her", "id", "rh", "db"], "banner": ["banorer", "warnler", "Banning", "planorer", "planners", "planning", "bannet", "banning", "ironnet", "annning", "binning", "warnner", "bannel", "planner", "bann", "bluener", "plann", "ironner", "Banker", "binorer", "blueler", "warnnel", "Banorer", "Bannel", "blueker", "banler", "annner", "ironning", "Banner", "bluenel", "banners", "Bann", "warnker", "binn", "annnet", "binner", "ironners", "annners", "Banler", "plannet", "banker"], "txt": ["text", " text", "rx", "flat", "lines", "json", "str", "pty", "git", "cb", "vt", "config", "info", "buff", "fb", "gz", "np", "bytes", "wd", "buf", "js", "notes", "ff", "tx", "xml", "qt", "data", "elt", "utt", "TEXT", "bot", "email", "pdf", "img", "tmp", "tty", "ext", "Text", "obj", "zip", "rss", "htm", "struct", "gold", "thin", "details", "parser", "test", "file", "xt", "diff", "xxx", "kt", "tin", "hea", "rpm"], "sname": ["asname", "nsdata", "esnames", "esName", "vesnames", " sName", "sdata", "vesname", "snames", "esnamed", "sName", " snames", "asdata", " sdata", "asnamed", " snamed", "snamed", "vesName", "nsnames", "asnames", "vesnamed", "nsname", "nsnamed", "esname"], "spass": ["espasses", "spash", "Sposs", "splash", "SPill", "SPasses", "aspad", "sloss", "espash", "SPass", "slill", "slasses", "Spasses", "sposs", "splass", "spasses", "espass", "Spill", "spill", "spad", "splasses", "splad", "aspass", "SPoss", "Spass", "slass", "espad", "aspash", "aspasses"], "sseed": ["ssroot", "psecret", "stoken", " spassword", "psslave", "sgrain", "gseed", "gsgrain", "sentry", "pseed", " sentry", "psseed", "Seed", "symseed", "submitentry", "Sseed", "submittoken", "sslave", "sroot", "symkey", "gsseed", "symeed", "pslave", "dtoken", " stoken", "ssseed", "skey", "ssslave", "psroot", "proot", "spassword", "submitseed", "symgrain", "gskey", "dseed", "Skey", "sssecret", "dpassword", "Sgrain", "submitpassword", "dentry", "ssecret", "pssecret"], "items": ["parts", "apps", "ends", "units", "locks", "lines", "orders", "cats", "photos", "bits", "Items", "ips", "keys", "lists", "styles", "bytes", "groups", "js", "xml", "item", "projects", "data", "names", "rooms", "cells", "opens", "flows", "values", "pieces", "pins", "objects", "qs", "boxes", "params", "files", "ants", "members", "links", "models", "pages", "loads", "plugins", "owners", "abs", "results", "events", "ids", "articles", "images", "rows", "posts", "phones", "ops"]}}
{"id1": "421042", "id2": "4830847", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "ref", "filename", "buffer", "uri", "path", "Url", "f", "config", "link", "l", "image", "loc", "loader", "service", "location", "resource", "www", "io", "base", "name", "bel", "null", "server", "host", "URL", "rl", "sl", "address", "string", "connection", "fr", "ur", "el", "ll", "lr", "html", "file", "ssl", "feed", "href", "ob", "id", "xml", "http"], "in": ["source", "as", "init", "inn", "gin", "out", "token", "pin", "inner", "c", "f", "config", "this", "ex", "i", "input", "socket", "serv", "conn", "inside", "image", "val", "or", "IN", "data", "m", "ini", "con", "resource", "n", "io", "isin", "a", "bin", "din", "is", "nin", "min", "ins", "In", "impl", "again", "rin", "file", "part", "err", "r", "login", "ssl", "id", "reader", "inc", "xml", "cms"]}}
{"id1": "539195", "id2": "20886320", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"copy": [" cp", "create", "csv", "py", "paste", "load", "download", "cat", "cop", "io", "clone", "rm", "it", "change", "transfer", "zip", "split", "Copy", "cp", "opy", "write", "delete", "replace", "php", "put", "file", "get", "cmp"], "src": ["source", "remote", "filename", "sb", "uri", "sync", "path", "config", "s", "archive", "txt", "image", "sin", "inst", "loc", "RC", "sys", "resource", "rs", "img", "sup", "url", "name", "code", "sit", "sel", "sub", "sc", "sl", "secure", "dist", "rc", "rb", "string", "gb", "cur", "upload", "stream", "ruby", "desc", "file", "ssl", "href", "slice", "id", "target"], "dest": ["text", "source", "them", "filename", "flat", "prop", "output", "feat", " destination", "home", "buff", "wd", "txt", " Dest", "rest", "default", "loc", "data", "const", "folder", "done", "later", "tmp", "du", "tern", "die", "destroy", "dat", "dist", "target", "comb", "orig", "test", "desc", "coord", "replace", "temp", "wb", "Dest", "dir", "slice", "end", "opt", "d", "delete"], "ifp": ["upp", "ibtp", "pppa", "dfap", "IFpp", " ifap", "ifcp", "ifap", "ifpa", "upcp", "uppp", "dfb", "dfpa", "ifb", " ifpp", "Ifpa", "ppb", "iftp", "dfp", " ifpa", "iplp", "ifi", "Ifp", "iplpa", "ppap", "upo", "ifo", "ibp", "ipltp", "ibi", "Iftp", " ifcp", "ifpp", " ifb", "ibpa", "IFp", "Ifi", "ppp", "IFo", " ifo", "ipli", "IFcp"], "ofp": ["Off", "ofy", "OFc", "ovi", "ofc", " ofi", "ippc", "ovf", " ofy", "ippy", "ippps", " off", "ippp", "OFy", " ofc", "Ofi", "Ofc", "OFp", "OFps", "ofps", "ovp", "Ofp", "ovc", " ofps", "off", "ofi"], "fis": ["infi", "flus", "infos", "infiss", "fiss", "flis", " fps", "ofis", "cfi", "ofbis", " fiss", "flps", "hps", "fps", "cfiss", "his", " fus", "hs", "hus", " fais", "infis", "fais", " fbis", "fus", "fs", "cfis", "cfbis", " fi", " fs", "fbis", "fls", "ofos", "ofais", "cfais", "fi", "cfos"], "fos": ["foses", " foses", "fpos", "bos", "foes", " foser", "Foes", "foser", " fops", "pos", "Fos", "poses", "bios", " fpos", "pis", "Fis", " fios", "Foses", "ifops", " foes", "boser", "poes", "ifos", "ifis", "ifoser", "fios", "Fios", "Fpos", "bis", "fops", "bpos", "bops"], "b": ["p", "ab", "buffer", "sb", "xb", "br", "c", "f", "bb", "buff", "ba", "buf", "e", "i", "l", "mb", "B", "ib", "binary", "lb", "bf", "bi", "a", "base", "bound", "nb", "bs", "rb", "eb", "gb", "h", "abb", "emb", "wb", "r", "ob", "boot", "bis", "v", "db", "d"]}}
{"id1": "3958807", "id2": "22135199", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadFinaryFile", "loadBbinaryContent", "loadBinaryFile", "loadFbinaryStream", "loadFinaryInput", "loadBInputStream", "loadBatchContent", "loadBatchFile", "loadBInputInput", "loadBbinaryFile", "loadBInputContent", "loadBatchStream", "loadBatchInput", "loadBbinaryInput", "loadBinaryInput", "loadBinaryContent", "loadFinaryContent", "loadFbinaryFile", "loadFbinaryContent", "loadBbinaryStream", "loadFbinaryInput", "loadFinaryStream", "loadBInputFile"], "streamName": ["resourcePath", " streamKey", "filename", "resourceName", "filePath", "fileType", " streamname", "fileKey", "channelPath", "streamname", "resourcename", "streamType", " streamPath", "StreamName", "fileName", "streamKey", "streamPath", "Streamname", "channelKey", " streamType", "resourceType", "channelName", "StreamPath"], "streamToLoad": ["streamToUse", "channelToLoad", "objectTOUpload", "streamWillUse", "channelToAdd", "streamtoUse", "streamToload", " streamtoLoad", " streamToAdd", "streamtoload", "objectTOLoad", "streamToRead", "channeltoAdd", "streamtoAdd", "objectTORead", " streamToRead", "streamWithUse", "streamtoLoad", "channelToload", "streamTOUse", "objectToRead", " streamtoUse", "objectToLoad", "streamTORead", "streamToAdd", "streamWithLoad", "streamTOAdd", "channeltoLoad", "streamWillRead", "streamWillAdd", "streamWillUpload", "channeltoload", "streamTOload", " streamtoRead", " streamtoAdd", "streamWithAdd", "objectToUse", "streamtoRead", "streamtoUpload", "objectTOUse", "streamWillLoad", " streamToUse", "streamToUpload", "streamTOUpload", "objectToUpload", "streamTOLoad", "streamWithRead"], "sz": ["wsze", "sze", " sze", " szip", " szi", "pszip", "szip", "ssiz", "pszi", "wszip", "wsz", "imszes", "imsiz", "siz", " szes", "psze", "imsz", " siz", "ssze", "ssz", "sszes", "szi", "wszi", "imsze", "szes", "psz"], "req": ["ref", "rx", "rec", "client", "cb", "download", "f", "rr", "input", "src", "conn", "serv", "qt", "q", "progress", "Resp", "wx", "proc", "requ", "exec", "obj", "res", "rss", "inv", "respond", "require", "fr", "rw", "ok", "def", "request", "r", "response", "err", "pkg", "ctx", "rh", "sem", "Request", "report", "http"], "resp": ["rem", "ref", "ret", "remote", "rec", "re", "output", "fp", "client", "download", "bb", "page", "wp", "e", "serv", "conn", "reply", "prev", "Resp", "cook", "wx", "proc", "server", "Response", "obj", "exec", "zip", "rep", "esp", "res", "body", "sp", "rss", "api", "respond", "par", "jp", "html", "rup", "request", "wb", "err", "response", "df", "circ", "rev", "comm", "ctx", "rh", "cmp", "report", "rel", "http"], "out": ["p", "buffer", "copy", "cache", "output", "s", "buf", "gz", "i", "serv", "OUT", "conn", "default", "data", "in", "object", "binary", "ws", "img", "io", "tmp", "base", "log", "os", "b", "null", "exec", "pool", "zip", "res", "fn", "Out", "aos", "auto", "outs", "again", "response", "op", "o", "boot", "bin", "co", "ops"], "bos": ["mis", "bh", "bro", "obb", "lo", "bb", "biz", "bas", "bo", "oops", "ubis", "ko", "bott", "abi", "obo", "bot", "zb", "bps", "bi", "ros", "flo", "rob", "bc", "bin", "pins", "os", "los", "zos", "bs", "zo", "fits", "cro", "obos", "las", "oos", "ios", "aos", "lol", "bare", "obs", "osa", "ob", "boot", "osi", "bis", "bes"]}}
{"id1": "10176678", "id2": "23335922", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpGozipping", "testLoadHttpGzips", "testLoadHttpGgzipped", "testLoadHttpgzipained", "testLoadHttpGzipips", "testLoadHttpGgzained", "testLoadHttpgzipipping", "testLoadHttpGzipping", "testLoadHttpgzips", "testLoadHttpGozained", "testLoadHttpGozipped", "testLoadHttpgzipips", "testLoadHttpGzained", "testLoadHttpgzained", "testLoadHttpGgzipping", "testLoadHttpgzipping", "testLoadHttpgzipipped", "testLoadHttpGzipained", "testLoadHttpGzipipping", "testLoadHttpGgzips", "testLoadHttpGzipipped", "testLoadHttpGozips", "testLoadHttpgzipped"], "url": ["ls", "source", "method", "ref", "filename", "buffer", "gl", "uri", "path", "Url", "config", "f", "info", "page", "l", "src", "image", "xml", "loc", "data", "location", "resource", "class", "base", "log", "name", "server", "host", "URL", "zip", "sl", "address", "string", "connection", "ll", "html", "file", "route", "key", "response", "ssl", "id", "type", "error", "pattern", "http"], "loadingInfo": ["loadingInf", "loadinginfo", "loadingManager", "lockingInfo", " loadingConfig", " loadingObj", "LoadingInf", "lockingObj", "LoadingObj", " loadingManager", "loaderinfo", "LoadingConfig", "loaderConfig", "loadingObj", "loaderInf", "lockingInf", "Loadinginfo", "loadingConfig", " loadingInf", "LoadingInfo", "LoadingManager", "lockingManager", " loadinginfo", "loaderInfo"], "contentInputStream": ["contentImportstream", "contentByteStream", "contentContentstream", "contentOutputObject", "contentContentStream", "contentBytestream", "contentInputstream", "ContentInputStream", "contentInputObject", "contentImportObject", "ContentOutputObject", "ContentOutputStream", "contentImportSteam", "contentOutputSteam", "ContentInputString", "contentOutputStream", "ContentInputSteam", "contentContentSteam", "contentReadString", "contentReadstream", "ContentOutputstream", "contentReadStream", "contentContentObject", "ContentInputObject", "ContentOutputString", "ContentOutputSteam", "contentInputSteam", "ContentInputstream", "contentByteString", "contentImportStream", "contentOutputstream", "contentInputString", "contentReadSteam", "contentOutputString", "contentByteSteam"], "actual": ["including", "actually", "current", "length", "reported", "wrong", "successful", "existing", "pect", "event", "als", "ual", "real", "covered", "example", "evaluate", "found", "act", "valid", "original", "truth", "fake", "array", "initial", "older", "pects", " Actual", "affected", "former", "future", "handled", "received", "average", "failed", "response", "acceptable", "events", "ception", "anticipated", "content"], "expected": ["nexpected", "length", "reported", "cover", "wrong", "pect", "info", "pected", "driver", "real", "needed", "usual", "defined", "updated", "found", "example", "data", "required", "allowed", "original", " unexpected", "fake", " expecting", "seen", "size", "future", "handled", " expect", "received", "always", "failed", "acceptable", "error", "ception", "anticipated"]}}
{"id1": "17583193", "id2": "14450108", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"populateRecord": ["extulateAll", "poputeAll", "extulateRecord", "poputeRecord", "popractRecord", "extractInstance", "extractModel", "extulateModel", "extulateInstance", "popractAll", "populatesRecord", "populatesAll", "poputeInstance", "poputeModel", "populateInstance", "popractInstance", "populatesInstance", "populatesModel", "extractAll", "populateModel", "populateAll", "popractModel", "extractRecord"], "attrIDs": ["sortID", "attIDS", "attrIDES", "attributeids", "attributeIDs", "addrID", "attrID", "tagIDS", "attributeENTS", "sortIDS", "tagIDs", "attributeIDES", "attrids", "attributeID", "addrIDs", "attID", "sortids", "attrIDS", "addrIDS", "tagIDES", "attids", "attIDES", "attrENTS", "tagID", "attributeIDS", "addrENTS", "sortIDES", "attIDs", "attENTS"], "i": ["x", "init", "ai", "I", "k", "ci", "left", "ami", "ip", "u", "li", "y", "key", "slice", "start", "ti", "d", "uri", "info", "ini", "multi", "io", "bi", "iu", "n", "g", "pi", "api", "ki", "eni", "cli", "id", "ii", "e", "ind", "a", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "ri", "my", "phi", "p", "ij", "length", "z", "inner", "c", "ni", "f", "gi", "ix", "ori", "ie", "l", "yi", "m", "in", "it", "ui", "ik", "oi", "index", "fi", "v"], "sortIDs": ["SortUID", "sortID", "allIDS", "filterID", "allIDES", "useIDS", "syncID", "syncIDS", "altIDES", "ortIDS", "searchID", "searchids", "orderADS", "attrID", " sortIDS", "allID", "allIDs", "useID", "SortIDES", "sortIDS", " sortids", "altIDs", "orderID", "sortFiles", "SortIDS", "SortIDs", "filterUID", "filterIDs", "altIDS", "syncIDES", "sortADS", "orderIDES", "sortids", "ortIDs", "orderIDs", " sortFiles", "attrIDS", "altID", "searchIDES", "useIDs", "attrADS", "sortUID", "updateFiles", "syncIDs", "searchIDS", " sortUID", "ortUID", "orderIDS", " sortADS", "orderids", "orderFiles", " sortID", "updateIDs", "searchIDs", "ortID", "updateIDES", "sortIDES", "useIDES", "attrFiles", "filterIDS", "ortids", "updateIDS", "SortID", "updateID", "attrUID", "ortIDES", " sortIDES"], "j": ["p", "x", "last", "ij", "z", "br", "jl", "f", "ii", "bj", "ix", "w", "e", "dj", "ie", "l", "k", "aj", "left", "q", "n", "next", "job", "v", "jj", "ja", "b", "u", "obj", "ui", "oj", "ji", "jet", "li", "je", "h", "jc", "fr", "di", "qi", "jp", "pr", "y", "xi", "part", "key", "adj", "uj", "o", "J", "section", "js", "d", "jo"], "temp": [" dummy", "flat", " Temp", "empty", "ash", " original", "emp", "tc", "alt", "porary", "ex", "needed", "max", "ed", " fake", "tem", "Temp", "stable", "tmp", "fake", " temporary", "modified", " unused", " test", " modified", "holder", " tmp", "wrap", "orig", "used", "iter", "test", "tr", "partial", "key", "pack", " orig", "non", "get", " result"]}}
{"id1": "659316", "id2": "23273706", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"argv": ["paramb", "argsf", " argver", "argumentver", "argf", " argl", "paramV", "argumentc", " argf", "argsv", "argl", "paramv", "argver", "Argve", "interV", "ArgV", "interl", "paraml", "argc", "Argl", " argV", "Argver", "Argv", "argumentve", "interc", "argb", " argb", "Argc", " argve", "argsl", "interv", "Argb", "argve", "argumentv", "argsc", "argV", "Argf", " argc"], "sources": ["psources", "fors", "tource", "vesores", "tources", "sesences", "statources", "issource", "statigs", "sores", "fource", "sresources", "fides", "sigs", "psource", "issources", "vesigs", "vesources", " sors", " sides", "sences", "tresources", "issides", "sesores", "statences", "sors", "issors", "psresources", "psides", "sesources", "fources", "fresources", "sides", "statores", "sesigs", "vesences", "tides"], "targets": ["tagnencies", "taxlets", "targends", " taxes", "targens", " taxends", "Targens", "tampels", " targens", "toket", "Targels", "tiges", "taxens", "tanglets", "taxets", "Tangets", "tagnets", "taxends", "taxels", "Tanglets", "targes", "tokets", "tagnet", "tagnens", "tangends", "tigens", "Tangens", "tamplets", " taxens", "tampets", "tangens", "tanges", "targels", " targes", " tokens", "targencies", "tokens", "Targlets", "tangets", " tokets", "tigets", "targlets", "tigends", "Targets", "taxes", " targends", "tanget", " taxets", "tampens", "tangels", "Tangels", " toket", " tokencies", "tokencies", " targencies", "tangencies"], "srclen": ["srCLength", "rscelEN", "srcelEN", "srplen", "rsclens", "srploen", "rsclEN", "srseln", "srctoen", " srcloen", "srselen", "srclens", "srClens", "srCln", "srClen", "srceln", "srselens", "rsclen", "srpleno", " srclength", " srploen", "rsceln", "rscelen", " srplength", "srclEN", "srClEN", "srcten", "srctength", "srcleno", "srCLen", "rscelens", " srcleno", "srcln", "srplength", "srcelen", "srselEN", " srpleno", "rscln", "srclength", " srplen", "srcteno", "srcelens", "srcloen", "srCLoen", "srCLeno"], "source": ["create", "remote", "copy", "cache", "uri", "current", "out", "client", "path", "config", "s", "use", "view", "seed", "event", "component", "model", "link", "driver", "ources", "input", "src", "ource", "image", "SOURCE", "single", "get", "Source", "in", "service", "resource", "proxy", "force", "self", "dest", "url", "sl", "secure", "rc", "scope", "channel", "size", "stream", "ssl", "slice", "id", "reader", "unit", "type", "parent", "start"], "tgt": ["tnt", " tgz", "hret", " tret", " tgs", " tgh", " tkt", "Targ", "Tkt", "Tch", "hnt", "bitarg", "hgz", "lret", "rkt", "ptgt", "Tgs", "tkt", "hgt", "tgz", "bitgt", "biticket", " tbuster", "tch", " tch", "tret", "targ", "rgt", "ticket", "lgz", "tgh", " targ", " tnt", "ptbuster", "Tgt", "lbuster", "rch", "Ticket", "larg", "lnt", "lgt", " ticket", "ptnt", "ptarg", "Tgh", "bitgh", "tbuster", "tgs", "rgs"], "target": ["match", "remote", "result", "output", "goal", "out", "port", "client", "path", "session", "current", "download", "point", "cross", "archive", "event", "component", "master", "tail", "driver", "nt", "slave", "view", "to", "arget", "conn", "project", "manager", "image", "service", "object", "Target", "resource", "director", "open", "force", "dest", "io", "core", "next", "url", "base", "null", "it", "child", "connection", "external", "channel", "handler", "plugin", "mount", "route", "unit", "parent", "member", "rel"], "deletes": ["deises", "delouts", "dedates", " dedates", "downdates", "degrades", "delises", "kesouts", "kesleted", "Deires", "desletes", "exletes", "desists", "disires", "disists", "desles", "exlete", "deles", "downletes", " deleted", "exdates", " deouts", "disletes", "deouts", "Deles", " degrades", "deleted", "delletes", "kesises", "exgrades", "disles", " deises", "Deists", "kesletes", "delleted", "Deletes", "downgrades", "desires", "deires", "deists", "delete", " delete", "downlete"], "del": ["local", "copy", "se", "dec", "clean", "update", "download", "model", "d", "de", "bl", "skip", "down", "install", "data", "nl", "dl", "up", "base", "name", "add", "null", "change", "Del", "sel", "fl", "delay", "neg", "lock", "coll", "el", "ll", "fail", "ul", "def", "file", "pull", "syn", "err", "remove", "dir", "diff", "id", "get", "Delete", "delete", " Del", " delete", "rel"]}}
{"id1": "771802", "id2": "13595251", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createByteReader", " createInputStream", " createByteFile", " createIOReader", " createIOFile", " createInputReader", " createInputSteam", " createInputFile", "createInputSteam", "createOutputReader", "createOutputSteam", " createByteStream", "createOutputFile", " createOutputReader", "createInputStream", " createOutputSteam", "createInputFile", " createOutputFile", " createByteSteam", " createIOSteam", " createIOStream", "createInputReader"], "inFile": ["outFiles", "inputFile", "insFile", "incfile", "insfile", "incFile", "inFiles", "inputfile", "insFiles", "sourcefile", "incStream", "sourceFiles", "inputStream", "insStream", "outfile", "infile", "sourceStream", "outStream", "sourceFile", "inputFiles", "inStream", "incFiles"], "outFile": ["workingFile", "outTime", "workingDirectory", "targetfile", " outfile", "inputFile", " outStream", "workDir", "inputTime", "inputDir", " outDirectory", "targetDirectory", "outDir", "outDirectory", "targetFile", "workingStream", "inputfile", "inTime", "workTime", "outfile", "infile", "outStream", "workfile", "workFile", "targetStream", "inDir", "workingfile"], "k_blockSize": ["k_lockCount", "k_blockLength", "k_byteCode", "k_lineCount", "k_bitSize", "k_byteSize", "k_blocksSize", "k_lockLength", "k_BlockCode", "k_byteCount", "k_lineSize", "k_bitInfo", "k_lockSize", "k_byteLen", "k_lineInfo", "k_blockCount", "k_BlockCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksCount", "k_blockCode", "k_blockLen", "k_blocksLen", "k_BlockSize", "k_blocksLength", "k_byteInfo", "k_BlockLength", "k_bitCount", "k_blockInfo"], "byteCount": ["characterLen", "flushcount", "byteLen", "characterSize", "ByteCount", "bytecount", "ByteLength", "flushSize", "blockCount", "ByteSize", "blockSize", " byteLen", "byteSize", " byteSum", "characterLength", "Bytecount", "byteSum", "ByteSum", "byteLength", "ByteLen", " byteLength", "blockLength", " bytecount", "blockSum", "characterCount", "flushCount", " byteSize", "flushLength"], "buf": ["cv", "bh", "buffer", "result", "uf", "seq", "bag", "feat", "config", "buff", "fb", "len", "font", "bytes", "cmd", "src", "border", "exc", "brace", "loc", "data", "background", "bf", "cas", "img", "tmp", "base", "b", "fd", "Buffer", "append", "rc", "rb", "ucc", "queue", "batch", "alloc", "vec", "cap", "feed", "Buff", "ctx", "flush", "cb", "la"], "ofp": ["afp", "fort", "ofl", "OFnp", "afnp", "OFc", "ofc", "Ofnp", "Ofl", "OFtp", "oft", "Oftp", "ofnp", "Ofc", "OFl", "OFp", "forc", "Ofp", "afl", "oftp", "Oft", "forp", "fortp", "OFt", "afc"], "zos": ["ogl", "iframe", "bos", "zik", "tz", "zona", "abi", "zb", "core", "los", "inos", "zip", "zn", "lins", "css", "ozo", "zin", "zx", "nox", "forge", "oses", "liquid", "uz", "iffs", "zl", "gz", "rons", "nz", "zy", "za", "hz", "ossus", "os", "oS", "utils", "cos", "ZA", "dylib", "fits", "ZI", "zag", "budget", "zes", "outs", "jas", "js", "kos", "zon", "ls", "zers", "oda", "ros", "modules", "bs", "zo", "zh", "rez", "lol", "osi", "zi", "owicz", "soon", "z", "obb", "zer", "robe", "cfg", "zyk", "ws", "enos", "ses", "webkit", "zig", "zen", "packs", "obs", "bitcoin", "zar", "bes", "ops"], "osw": [" osow", "osx", "oswd", "ossnow", "osws", "lsw", "osnow", "isy", "bx", "ossy", " osfw", "lswo", "bws", "iswd", "ossow", "bwo", "ossw", "esww", "eshell", "esfw", "isd", "eswd", "issw", "osshell", "osd", "ossd", "lsws", "oswo", "osfw", "oshell", "osow", "esd", "esw", "essw", "bsx", "isw", "ossfw", "bsw", "isnow", "esnow", "osww", "esow", "ishell", "bsws", "osssw", "lsx", "osy", "bswo", "osswd", " osww", "ossww", "esy"], "bw": ["fsw", " bws", "bbwh", " bwu", "owu", "ebwd", "lsw", " bz", "fx", "bbaw", "Bw", "bx", "lbwh", "lbz", "bW", "abW", "bbz", "ebW", "bwe", "lw", "bz", "bws", "fbwe", "lbw", "baw", "fwa", "lbws", "bew", "bbwa", "Bwa", "fbw", " baw", "bbew", "owa", "fbwd", "bbwu", "fw", "oaw", "abw", "Bew", "lbwa", "abwe", "bbw", "fr", "abwd", "ebwe", " bwh", "ebw", "bsw", "lbx", "lbsw", " bew", "lwa", "lx", "fwh", "bwu", "ow", "fbW", "bwd", "bwa", "bbws", "lbr", "bwh", " bwa", "Bws"], "zot": ["azit", "zott", "zerita", "jos", "Zit", "Zott", "zerori", " zori", " zor", "ziot", "zor", "jit", "azot", "zita", "azor", "Ziot", "jot", "azott", "Zot", "zerot", "zeros", "azita", "Zita", "zerit", "Zor", "zori", "zerott", "jori", " ziot", "aziot"], "ifp": ["IFl", "IFi", "ifl", " ifl", "IFb", "IFf", "ipb", "iff", "ifb", "ifc", " ifi", "ipc", "ifi", "Ifp", "Ifc", "ipp", " iff", " ifb", "IFp", "Ifi", "Iff", " ifc", "IFc", "ipl"], "zis": ["zeis", "Zits", "xits", "Ziss", "zeip", "jits", "zipis", "xisi", "zenais", " zIS", "zIS", "xIS", "zipits", "jisi", "jit", "zenIS", "zits", "xis", "zisi", "zeiss", "ziss", " zais", "zib", "zipip", "zip", "jis", "zais", " zib", " zits", "zeits", "zenib", " zisi", "xib", "zipiss", "xit", "xais", "Zis", "zenis", "Zip"], "isr": ["irrb", " iscr", "ISrc", "issrs", "ISpr", "rispr", "irr", "risrc", "ISsr", "isrb", "issr", " isrs", "iscr", "ISrs", "ISr", "risrb", "risr", "irpr", "ISrb", "isrs", "isscr", "isssr", "irrc", "IScr", "ispr", " issr", "isrc"], "br": ["kr", "bh", "rib", "bro", "arr", "str", "ibr", "browser", "bar", "obl", "HR", " BR", "mr", "BR", "bl", "bp", "Br", "rs", " Br", "sr", "img", "bc", "ber", "obi", "b", "hr", "ocr", "ch", "gr", "cro", "rb", "body", "sp", "ibl", "div", "fr", "yr", "shr", "lr", "ctr", " dr", "tr", "bsp", " fr", "r", "err", "ob"], "zit": ["jith", "zipit", "jite", "zeit", "zipIT", "zeitter", " zip", "jits", "zitter", "zith", "jip", "zipite", "jIT", "zipita", "zipitter", " zith", "zenits", "zipits", "zic", "zeith", "jit", "zits", " zite", "zeita", "zita", "xic", "zipip", "zip", " zi", "zenith", "ji", " zits", "xith", "zIT", "zeits", "jic", "zeIT", "xi", "zenitter", "jita", "zenit", "zipith", "zi", "zite", "xit", " zic"]}}
{"id1": "5237257", "id2": "4750967", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"download": ["output", "paste", "load", "update", "archive", "dump", "complete", "process", "release", "open", "url", "log", "transfer", "Download", "zip", "exec", "upload", "run", "submit", "file", "register", " downloading", "pack", "start", "select", "delete", "report"], "fileName": ["fileCode", "resourcePath", "fileDirectory", "resourceName", "fileType", "FileCode", " fileType", " fileDirectory", "FilePath", "fileFolder", "resourceDirectory", " fileFolder", "fileUrl", "FileFolder", "FileName", "resourceUrl", "FileUrl", "FileDirectory", "resourceCode", "FileType", "resourceFolder", "resourceType", " fileCode", " fileUrl"], "filePath": ["resourcePath", " fileFile", "FileLocation", "fileLocation", "resourceName", "filePart", "resourceFile", "resourceLocation", "FilePart", "fileFile", " filePart", "FilePath", "Filepath", "resourcePart", "FileName", "FileFile", " filepath", "filepath", "resourcepath", " fileLocation"], "in": ["work", "x", "source", "as", "init", "copy", "re", "gin", "inn", "sync", "pin", "inner", "ac", "f", "ax", "this", "i", "input", "l", "socket", "inside", "image", "IN", "data", "m", "con", "win", "ini", "resource", "issue", "on", "n", "up", "bin", "a", "url", "io", "name", "isin", "b", "is", "nin", "ins", "cin", "spin", "In", "lin", "inc", "again", "rin", "file", "r", "err", "login", "cgi", "id", "reader", "din"], "out": ["x", "source", "call", "copy", "cache", "output", "sync", "client", "path", "net", "inner", "at", "point", "with", "this", "extra", "view", "ex", "cmd", "one", "to", "socket", "OUT", "conn", "image", "line", "or", "IN", "by", "writer", "on", "n", "io", "up", "url", "base", "name", "log", "null", "outer", "ext", "server", "exec", "obj", "password", "nin", "string", "exp", "prefix", "option", "Out", "write", "In", "outs", "again", "off", "office", "file", "lib", "err", "o", "id", "user", "bin", "error"]}}
{"id1": "1954410", "id2": "8932510", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecutes", "doexecuteApply", "doexecuteutes", "submitExecApply", "doSendApply", "doSendRun", "submitexecuteutes", "doExecRun", "submitExecRun", "doExecutes", "submitexecuteRun", "submitexecuteApply", "doSendute", "doexecuteRun", "submitExecute", "doSendutes", "submitexecuteute", "doExecApply", "doexecuteute"], "mapping": ["fapper", "matching", "fapping", "minding", "aminding", "amapping", "amapper", "finding", "mapper", " mapper", " minding", " matching", "amatching", "fatching"], "form": ["flow", "method", "app", "FORM", "forms", "field", "Form", "config", "component", "page", "command", "control", "owner", "definition", "object", "format", "builder", "transform", "url", " forms", "formation", "post", "submit", "dom", "feed", "template", "xml", "pattern"], "request": ["message", "method", "create", "call", "Bytes", "result", "re", "uri", "json", "client", "current", "path", "hello", "session", "Accept", "instance", "frame", "Upload", "s", "this", "model", "use", "view", "HTTP", "input", "complete", "req", "data", "q", "object", "resource", "format", "QUEST", "self", "ware", "url", "name", "add", "server", "requ", "Response", "query", "address", "worker", "queue", "submit", "Reply", "_", "parent", "route", "pull", "reader", "user", "type", "xml", "Request", "report", "context", "application"], "response": ["message", "result", "output", "json", "client", "status", "model", "page", "view", " Response", " responses", "application", "resp", "data", "req", "object", "resource", "Resp", "server", "Response", "res", "handler", "v", "xml", "report", "reply"], "errors": [" status", " flashes", " payload", " translations", " Messages", " session", " commands", " logger", " error", " this", " responses", " warnings", " changes", " replies", " management", " managers", "mess", " acc", " updates", " mess", " messages", " messaging", " problems", " calls", " messenger", " failures", " events", " logs", " streams"], "isMultipart": ["isMultipparts", "isMultippedost", "isMultIPound", "isMultompost", "isMultipost", "isMultipound", "isMultompPart", "isMultipage", "isMultiipound", "isMultIPPart", "isMultompound", "isMultitage", "isMultiipPart", "isMultippart", "isMultIPart", "isMultiIPart", "isMultiated", "isMultippedound", "isMultompart", "isMultiparts", "isMultiipart", "isMultippated", "isMultitart", "isMultiIPost", "isMultippedart", "isMultiIPPart", "isMultIPost", "isMultitarts", "isMultipPart", "isMultippedPart", "isMultiarts", "isMultitated", "isMultippage", "isMultiIPound", "isMultiipost", "isMultiage", "isMultiart", "isMultipated"], "mailInstance": ["fileManager", "fileinstance", "fileInstance", "mailUsage", "emailinstance", " emailinstance", " mailUsage", "emailInstance", "fileUsage", " emailInstance", "mailinstance", " emailUsage", "mailInst", "emailManager", " emailInst", " mailInst", " mailinstance", "mailManager", "emailInst", " mailManager", "fileInst"], "fields": ["types", "parts", "rules", "holders", "locks", "words", "lines", "forms", "field", "lists", "keys", "forces", "s", "groups", "input", "services", "atts", "dates", "data", "gets", "strings", "checks", "cells", "flows", "archives", "objects", "qs", "boxes", "params", "ments", "files", "facts", "utils", "members", "features", "states", "links", "acks", "models", "tags", "pages", "uploads", "views", "details", "loads", "plugins", "packs", "users", "properties", "headers", "changes", "maps", "classes", "comments", "events", "ids", "rows", "posts"], "attachments": ["Attachments", "payments", "attachers", "Attachees", "extions", "exters", "attions", "attees", "attachresses", "attps", "attachlements", "payment", "achresses", "Attachps", "Attachlements", "suppees", "achments", "attachps", "attments", "attachment", " attachment", " attachparts", "attachparts", "attachions", "attment", "Attachions", "extps", "achparts", "atters", "attlements", "achment", "supplements", "payparts", "payresses", "Attachers", "extments", "suppment", "suppments", " attachresses", "attachees", "Attachment"], "items": ["types", "parts", "apps", "locks", "lines", "orders", "lists", "Items", "keys", "ips", "its", "ers", "groups", "data", "names", "objects", "apters", "qs", "files", "reports", "list", "ins", "links", "models", "pages", "plugins", "es", "results", "children", "events", "ids", "alls", "rows", "phones", "ops"], "iter": ["itter", "edit", "inner", "finder", "ver", "ite", "ter", "page", "event", "master", "cher", "i", "keep", "enter", "skip", "upper", "gener", "loc", "ner", "walker", "ir", "ip", "Iterator", "it", "izer", "outer", "Iter", "zip", "altern", "ator", "li", "list", "exp", "former", "chain", "coll", "el", "ul", "inc", "file", "loop", "err", "er", "ser", "end", "reader", "inter", "slice", "iterator", "oper", "order", "http"], "item": ["source", "current", "instance", "event", "extra", "image", "val", "ip", "url", "base", "name", "post", "Item", "li", "temp", "slice", "entry", "type", "section", "volume", "result", "token", "load", "info", "all", "i", "area", "or", "data", "example", "object", "other", "up", "original", "obj", "entity", "api", "layer", "coll", "plugin", "art", "site", "user", "order", "update", "hop", "atom", "issue", "folder", "resource", "next", "container", "element", "attribute", "more", "reader", "get", "app", "widget", "album", "inner", "page", "complete", "anything", "service", "missing", "storage", "it", "server", "index", "handler", "full", "file", "custom", "er"], "aux": ["offs", " auxiliary", "uc", "ups", "uf", "frac", "union", "alias", "buf", "aus", "extra", "etc", " Aux", "data", "des", "ux", "aff", "strings", "amp", "af", "ras", "cas", "ru", "sup", "aw", "array", "lc", "asc", "ext", "ou", "ants", "sub", "lang", "imp", "prefix", "axe", "aos", "fax", "auc", "ox", "off", "abs", "anc", "au", "pkg", "packages", "cmp", "abc", "except"], "part": ["p", "pre", "group", "parts", " Part", "ref", "field", "instance", "f", "point", "info", "back", "component", "per", "one", "word", "po", "l", "pos", "area", "joined", "val", "data", "PART", "object", "format", "act", "on", "action", "and", "class", "error", "base", "name", "b", "add", "change", "fact", "obj", "player", "pi", "ch", "connection", "list", "patch", "but", "layer", "comp", "element", "full", "plugin", "block", "html", "Part", "file", "start", "step", "partial", "key", "art", "diff", "join", "id", "type", "parent", "section", "user", "co", "no", "pair"], "baos": ["BAo", "baoss", "baOs", "baot", "paot", "baoS", "abaosi", " baoS", "BAis", "Bao", " baoss", "baosh", "boOS", "pao", "boo", "BAOs", "BAoss", "haos", "BaOs", " bao", "baOS", "bois", "paOS", "Baos", "BAoS", "Baosi", "abais", "abaOs", " baOS", "BaoS", "bais", "hao", "boosh", "hais", "abaos", "BAosi", "baosi", " bais", "boos", "Bais", "pais", "boot", "bao", "BAos", "paos", "paosh", " baot", "BAosh", "haoss"], "body": ["text", "source", "message", "parts", "media", "summary", "output", "port", "json", "length", "fee", "translation", "flash", "Body", "state", "pass", "options", "tree", "data", "object", "resource", "binary", "comment", "description", "shell", "document", "url", "name", "b", "null", "params", "zip", "query", "string", "header", "connection", "size", "full", "html", "value", "headers", "template", "end", "type", "common", "content", "reply"], "preferencesInstance": ["preffeesinstance", "prefeesinstance", "prefiesinstance", "preffeesClient", "prefirmsClient", "preferencesClient", "prefirmsInstance", "prefeesClient", "prefiesClient", "prefiesInstance", "prefeesInstance", "preffeesInstance", "preferencesinstance", "prefferencesClient", "prefirmsinstance", "prefferencesInstance", "prefferencesinstance"]}}
{"id1": "3558512", "id2": "397240", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"serialize": ["serialization", "finalized", " serialization", "finalify", "Serialization", "serialify", "serialze", "normalze", " serializable", "erialze", "Serializable", "Serialize", " serialze", "normalized", "normalify", "Serialized", "erialization", "serializable", "serialized", "Serialify", "erializable", "finalze", "normalize", "finalize", "Serialze", "erialize"], "out": ["source", "png", "filename", "buffer", "copy", "cache", "output", "client", "archive", "page", "w", "ex", "i", "dump", "OUT", "image", "conn", "data", "writer", "loader", "io", "up", "a", "name", "server", "gen", "obj", "pool", "exec", "string", "Out", "raw", "outs", "file", "temp", "err", "o", "parent", "bin", "report", "content"], "parser": ["p", "lp", "arser", "as", "copy", "cache", "ss", "parse", "instance", "system", "seed", "master", "rar", "per", "processor", "txt", "manager", "loader", "writer", "Parser", "builder", "tt", "up", "class", "base", "pe", "server", "upload", "worker", "cp", "handler", "plugin", "wrapper", "php", "test", "file", "er", "pp", "reader", "pkg", "parent", "xml", "pillar"], "on_disk": ["onnetdrive", "onJdemand", "onJdisk", "on_storage", "onbookdisk", "off_drive", "onjdisk", "on_lock", "on_demand", "onJdrive", "onbootstorage", "onbootdrive", "onbookdrive", "on_space", "off_space", "onbootlock", "onjdrive", "onnetdisk", "on_file", "onnetfile", "on_drive", "off_delete", "onJlock", "onnetspace", "off_disk", "onjspace", "off_storage", "off_file", "off_lock", "onjfile", "onbootdisk", "onnetdemand", "onbookdelete", "on_delete", "off_demand"], "in": ["source", "as", "copy", "inn", "pin", "inner", "c", "ac", "f", "ax", "info", "pass", "i", "input", "socket", "conn", "inas", "IN", "data", "ini", "win", "con", "din", "min", "ins", "connection", "thin", "stream", "lin", "In", "inc", "again", "rin", "file", "kin", "r", "login", "o", "reader", "bin"]}}
{"id1": "13362846", "id2": "5414088", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setContenuit", "setContineu", "setContineuit", "setTonenuer", "setContenues", "setTonenu", "setContonenuer", "setContennues", "setTenuit", "setContineuer", "setTenu", "setContenuer", "setContonenues", "setContennu", "setContonenu", "setContineues", "setTenuer", "setTenues", "setContennuer", "setTonenues", "setContonenuit", "setTonenuit", "setContennuit"], "contenuFichier": ["contenuFaffie", "contenuFaffier", "contenuFochique", "contenuPFicher", "contenuTicheery", "contenuFcherer", "contenuMichique", "contenuFrenchique", "contenuFrencherer", "contenuPhactoryoyer", "contenuTicheiere", "contenuFactoryie", "contenuTichiere", "contenuFichieri", "contenuFaffer", "contenuFichery", "contenuFichtique", "contenuFichique", "contenuMaffiers", "contenuFocher", "contenuFochiere", "contenuFicheier", "contenuFichtiere", "contenuPFichier", "contenuPrefichiers", "contenuFactoryiere", "contenuMichie", "contenuPhactoryier", "contenuFichtier", "contenuMrenchique", "contenuMichiers", "contenuMrenchier", "contenuFactoryoyer", "contenuPrefaffiers", "contenuPrefichiere", "contenuPrefichie", "contenuFchery", "contenuFicheiere", "contenuFochie", "contenuFaffieri", "contenuFicie", "contenuPhichoyer", "contenuFichtie", "contenuFaffiere", "contenuFicier", "contenuMaffieri", "contenuTicherer", "contenuFichiers", "contenuPrefaffiere", "contenuFicher", "contenuFicheery", "contenuTicheerer", "contenuFchiere", "contenuPFochique", "contenuFactoryier", "contenuPhactoryie", "contenuPhichiere", "contenuFrenchiere", "contenuFichiere", "contenuPhactoryiere", "contenuPFocher", "contenuPrefaffie", "contenuFchier", "contenuPFichiere", "contenuFicheique", "contenuFrenchery", "contenuTicheier", "contenuFrenchoyer", "contenuFicheieri", "contenuFichoyer", "contenuPrefichier", "contenuMrenchiere", "contenuFochiers", "contenuMaffier", "contenuMaffie", "contenuTichery", "contenuFochier", "contenuMichier", "contenuFrenchier", "contenuMaffiere", "contenuFrenchie", "contenuFicheie", "contenuPhichie", "contenuPFochier", "contenuFaffique", "contenuFiciere", "contenuFicherer", "contenuPhichier", "contenuFrenchiers", "contenuFicheerer", "contenuPrefaffier", "contenuPFichique", "contenuPFochiere", "contenuMrenchie", "contenuMichiere", "contenuFicoyer", "contenuFicheer", "contenuFichie", "contenuFaffiers", "contenuMichieri", "contenuFichtieri", "contenuTichier"], "fichierElectronique": ["fichierElectorniques", "fichierElectron\u00e9e", "fichierElectroneier", "fichierElectrolier", "fichierAdministronier", "fichierElectromistic", "fichierAustrolier", "fichierElectrolique", "fichierElectonlique", "fichierAdministronsique", "fichierElectronsiere", "fichierElectronsiques", "fichierElectaronie", "fichierElectornique", "fichierAustroliere", "fichierAdministronsie", "fichierElectronsical", "fichierElectroliere", "fichierElectroneique", "fichierCentornlique", "fichierElectronsique", "fichierElectolonique", "fichierElectoloniere", "fichierElectolonica", "fichierElectroneiere", "fichierElectrons\u00e9e", "fichierElectonie", "fichierAdministronsical", "fichierAdministroniques", "fichierElectrolie", "fichierCentornique", "fichierElectpronique", "fichierAustronique", "fichierElectromical", "fichierElectronsica", "fichierAdministronsier", "fichierElectoloniques", "fichierElectroniere", "fichierElectroneie", "fichierAustroniques", "fichierAdministronie", "fichierElectornlique", "fichierCentronique", "fichierCentroniques", "fichierElectroliques", "fichierAdministrons\u00e9e", "fichierElectonier", "fichierElectronical", "fichierElectproniques", "fichierElectronlique", "fichierAdministronique", "fichierElectrolica", "fichierElectornier", "fichierElectronistic", "fichierElectronslique", "fichierElectaronier", "fichierAdministronsistic", "fichierElectaron\u00e9e", "fichierCentronier", "fichierElectronsistic", "fichierAustroliques", "fichierElectonique", "fichierAdministronical", "fichierElectronica", "fichierCentronlique", "fichierElectpronical", "fichierElectpronistic", "fichierCentorniques", "fichierElectronsier", "fichierAustrolique", "fichierElectromique", "fichierElectroneiques", "fichierAustroniere", "fichierElectroniques", "fichierAdministronslique", "fichierElectrol\u00e9e", "fichierElectronsie", "fichierAdministron\u00e9e", "fichierAustronier", "fichierElectronie", "fichierAdministronsiques", "fichierElectromiques", "fichierElectronier", "fichierElectronelique", "fichierAdministronistic", "fichierAdministronlique", "fichierElectaronique", "fichierCentornier"], "utilisateurCourant": ["utilisationCourants", "utilisateurGovernateur", "utilisateurCourateur", "utilisateurGovernante", "utilisationCourante", "utilisateurGovernant", "utilisateurCourants", "utilisationApplicante", "utilisateurGovernants", "utilisationCourant", "utilisateurParticipant", "utilisationApplicateur", "utilisateurCourante", "utilisateurApplicants", "utilisateurApplicateur", "utilisateurParticipante", "utilisationCourateur", "utilisateurApplicant", "utilisateurApplicante", "utilisationApplicant", "utilisateurParticipants", "utilisationApplicants", "utilisateurParticipateur"], "support": ["pport", "contact", "util", "facebook", "concept", "summary", "media", "client", "push", "Support", "cover", "feature", "config", "system", "info", "compatible", "knowledge", "control", "services", "respect", "friend", "evidence", "review", "service", "proxy", "help", "format", "supported", "force", "storage", " Support", "accept", "document", "ann", "share", "allow", "utils", "supp", "best", "bank", "plugin", "Library", "settings", "protection", "pull", "library", "know"], "ficheDocument": ["fielCatalog", "fcheMatrix", "inficheDoc", "fraudDirectory", "fineFeature", "fagueDocument", "fagueDirectory", "facheDocument", "foineDocument", " fcheDirectory", "fcheDirectory", "facheDocuments", "ficheNumber", "FcheContent", "affinedocument", " ficheDocuments", "enfoiceDocument", "fraudCompany", "afficheFeature", "FicheDoc", "foiceDirectory", "ficheDocuments", "fchaDoc", "affineDocument", " fcheDocuments", "ficheCatalog", "afficheDocument", "foiceDocument", " ficheDirectory", "ficheMatrix", "foineDoc", "infraudNumber", " fcheDocument", "fetchDocument", "FcheDocument", "enficheCompany", "inficheNumber", "ficheFeature", "fielDirectory", "fruitDocument", "ficheCompany", "enficheCatalog", "enficheDirectory", "enfoiceDirectory", "enfoiceCompany", "infraudDocument", "enficheDocument", "friqueDocument", "infichedocument", "fcheDocuments", " ficheMatrix", "FcheDoc", "fielCompany", "fetchdocument", "finedocument", " fcheMatrix", "fcheContent", "fchaContent", "FicheContent", "financeNumber", "enfoiceCatalog", "Fichedocument", "friqueContent", "affichedocument", "fraudNumber", "fagueMatrix", "foineFeature", "facheMatrix", "foiceCatalog", "financeDocument", "facheDirectory", "Fchedocument", "affineDoc", "infraudDoc", "affineFeature", "fetchFeature", "fineDoc", "ficheContent", "fineDocument", "fcheDoc", "afficheDoc", "fraudDoc", "fetchDoc", "ficheDoc", "friquedocument", "infrauddocument", "fchedocument", "fchadocument", "fichedocument", "fruitdocument", "inficheDocument", "fruitNumber", "fcheDocument", "frauddocument", "fchaDocument", "foiceCompany", "FicheDocument", "friqueDoc", "foinedocument", "fagueDocuments", "fraudDocument", "ficheDirectory", "financeDoc", "fielDocument", "fruitDoc", "fraudCatalog", "financedocument"], "nomFichier": ["nomWchery", "nomPhichiere", "nomNichiller", "nomFachiller", "nomPichien", "nomFichien", "nomPichery", "nomVich\u00e8re", "nomFichtery", "nomVcher", "nomFiqurier", "nomFichiere", "nomWichire", "nomPchery", "nomVchieri", "nomF\u00e9tier", "nomWichiere", "nomFichieri", "nomF\u00e9tien", "nomPchien", "nomNichier", "nomPrefchieri", "nomFachrier", "nomPchier", "nomFichtiner", "nomVchier", "nomPhicherer", "nomFachieri", "nomFichire", "nomFochier", "nomWchier", "nomFiscier", "nomFrench\u00e8re", "nomFochery", "nomPrefchier", "nomPrefichieri", "nomFchy", "nomFachier", "nomFchire", "nomVch\u00e8re", "nomFichery", "nomPhichieri", "nomPhachiere", "nomFichtiere", "nomFichiner", "nomPhichier", "nomFiscy", "nomNichtiner", "nomPrefichire", "nomFachiner", "nomFchieri", "nomFichtire", "nomFitherer", "nomPrefichrier", "nomFochiere", "nomFrenchier", "nomFrenchieri", "nomFacherer", "nomFacher", "nomFichtiller", "nomVicher", "nomFchiere", "nomWichery", "nomFithiere", "nomFachire", "nomFiquier", "nomNicher", "nomVichieri", "nomNichtier", "nomFochire", "nomPchy", "nomFithieri", "nomFisciller", "nomFch\u00e8re", "nomF\u00e9ty", "nomFchrier", "nomFicherer", "nomFchier", "nomFiquieri", "nomVichier", "nomFchery", "nomPichy", "nomPrefchire", "nomFithier", "nomFisciner", "nomFichterer", "nomFichtier", "nomFichtieri", "nomPhachieri", "nomWchire", "nomFchien", "nomPrefichier", "nomWichier", "nomFiscery", "nomWchiere", "nomF\u00e9tery", "nomFiscien", "nomFcher", "nomFrencher", "nomFichy", "nomPhachier", "nomFachiere", "nomPrefchrier", "nomFichrier", "nomFich\u00e8re", "nomNichter", "nomFach\u00e8re", "nomPichier", "nomNichiner", "nomFichter", "nomFichiller", "nomFiscer", "nomFicher", "nomPhacherer", "nomFiquire", "nomNichtiller"], "extension": ["Extension", "Extime", "extception", "extensions", "EXTension", "anchension", "Extression", "encion", "encension", "encception", "EXTensions", "extion", "anchensions", "exception", "exression", "exension", "EXTime", "anchime", "Extception", "Extion", "extime", "encression", "extression", "Extensions", "exion"], "fichierElectroniqueExistant": ["fichierElectroniqueXist", "fichierElectroniquesExists", "fichierElectroniqueExplclusive", "fichierElectroniqueExplistant", "fichierElectroniqueExplivist", "fichierElectroniquesExistance", "fichierElectroniquesXist", "fichierElectroniquesXclusive", "fichierElectroniqueExilingual", "fichierElectroniqueSistance", "fichierElectroniqueexclusive", "fichierElectroniqueXistant", "fichierElectroniquesXistent", "fichierElectroniqueXistent", "fichierElectroniqueexists", "fichierElectroniquesXilingual", "fichierElectroniqueSistent", "fichierElectroniquesXistance", "fichierElectroniqueXists", "fichierElectroniquesXistant", "fichierElectroniqueexivist", "fichierElectroniquesExilingual", "fichierElectroniqueSilingual", "fichierElectroniqueexistance", "fichierElectroniquesExist", "fichierElectroniqueexist", "fichierElectroniqueExistance", "fichierElectroniquesXivist", "fichierElectroniqueExplists", "fichierElectroniqueexistant", "fichierElectroniqueexilingual", "fichierElectroniquesExistant", "fichierElectroniqueXilingual", "fichierElectroniqueExistent", "fichierElectroniqueExists", "fichierElectroniquesExistent", "fichierElectroniqueExplistance", "fichierElectroniqueExclusive", "fichierElectroniqueXivist", "fichierElectroniquesXists", "fichierElectroniquesExclusive", "fichierElectroniqueXclusive", "fichierElectroniquesExivist", "fichierElectroniqueSistant", "fichierElectroniqueExist", "fichierElectroniqueXistance", "fichierElectroniqueexistent", "fichierElectroniqueExivist", "fichierElectroniqueExplist"], "idIgid": ["idUgname", "idIgenids", "idIgnID", "idIgnid", "idIogdid", "idUguids", "idIgubit", "idEGbit", "idIgudid", "idEGdid", "idEgdid", "idIggids", "idUguID", "idUguid", "idIgenname", "idIgids", "idUguname", "idIgod", "idIGids", "idEGids", "idIgdid", "idIgmid", "idIgID", "idIguod", "idIGdid", "idIgenid", "idUgID", "idIgmids", "idIogid", "idEGid", "idUgid", "idUgids", "idEgid", "idIogids", "idIgname", "idIgenID", "idIgmname", "idIgmID", "idIggod", "idEgids", "idIguid", "idEgbit", "idIggID", "idIGid", "idIguids", "idIguname", "idIGbit", "idIguID", "idIggid", "idIgbit", "idIogbit", "idIgnids", "idIgnod"], "inputStream": ["InputStreamer", " inputThread", " inputstream", "outputStreamer", "eventStream", "InputThread", "InputLength", " inputLength", "Inputstream", "eventStreamer", "inputstream", "InputStream", "eventSteam", "inputLength", "outputLength", "InputSteam", "eventstream", "inputStreamer", " inputSteam", "inputThread", "outputstream", "inputSteam", "outputThread", "outputSteam"], "outputStream": ["entityStream", "OutputStream", "OutputStreamer", "OutputSteam", "officeStream", "Outputstream", "inputContext", "outputStreamer", "officeSteam", "OutputContext", "entityStreamer", "outputContext", " outputSteam", "inputstream", "entitystream", "officeStreamer", "entitySteam", " outputContext", "inputStreamer", "outputstream", "inputSteam", "officestream", " outputstream", "outputSteam"], "typeMime": ["typeMatangle", "TypeSmime", "TypeSmangle", "typeMimes", "TypeMangle", "typeMetime", "typeSmangle", "TypeMide", "typeMetimes", "typeMatide", "typeSmimes", "typeMatime", "TypeMimes", "typeMangle", "typeMatimes", "typeSmime", "typeMetide", "TypeSmimes", "typeMide", "TypeMime", "typeSmide", "TypeSmide", "typeMetangle"], "tailleFichier": [" tailleFicheier", " tailleFochie", " taillefichie", " taillefochie", " tailleFignier", " taillefocher", " taillefochier", " tailleFochier", " tailleFichie", " taillefichiers", " tailleFigner", " tailleFichiers", " taillefochiers", " tailleFochiers", " taillefichier", " tailleFignie", " tailleFocher", " tailleFicheiers", " tailleFicheer", " tailleFicheie", " tailleFigniers", " tailleficher", " tailleFicher"]}}
{"id1": "23273706", "id2": "20619879", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectTreeInfo", "getprojecttreeInfo", "getProjecttreeDATA", "getProjectDocumentData", "getProjectPageDATA", "getprojectTreeData", "getProjectDocumentMeta", "getProjecttreeInfo", "getProjectPageData", "getprojecttreeDATA", "getProjectPageMeta", "getprojecttreeMeta", "getProjectDocumentInfo", "getprojectTreeMeta", "getProjectTreeMeta", "getProjectTreeDATA", "getProjecttreeData", "getProjectPageInfo", "getProjectDocumentDATA", "getProjecttreeMeta", "getprojectTreeInfo", "getprojecttreeData", "getprojectTreeDATA"], "treeData": ["TreeList", "contentInfo", "TreeArray", "TreeData", "treeArray", "monkeyData", "monkeyDec", "reeText", "treeDec", "contentText", " treeInfo", "treeText", "bodyDat", "storyDat", "reeDat", "reeInfo", "treeDat", "monkeyArray", "reeList", " treeDat", "storyData", " treeDec", "storyDec", "storyArray", "contentData", "contentDat", "reeArray", "bodyList", "bodyData", "reeString", " treeArray", "reeData", " treeText", "treeList", " treeString", " treeList", "bodyString", "TreeString", "treeString", "TreeInfo", "monkeyDat", "treeInfo"], "filename": ["figure", "whatever", "uri", "fp", "ppa", "path", "username", "kl", "wav", "title", "ername", "fil", "txt", "sheet", "data", "folder", "location", "metadata", "dll", "journal", "framework", "directory", "FILE", "url", "database", "name", "tmp", "kn", "kj", "fd", "files", "password", "dylib", "SourceFile", "upload", "string", "fn", "prefix", "Filename", "file", "nil", "jpg", "xml"], "urlString": [" urlURL", "URLString", "addressStr", "URLURL", "URLstring", "urlStr", "addressString", "URLStr", "addressURL", "urlUrl", "locationUrl", " urlstring", "urlURL", "locationString", "URLUrl", "urlstring", " urlUrl", "addressstring", "locationStr", "locationstring", " urlStr"], "urldata": ["urlledATA", "URldat", "urlledata", "urlledta", "urlfat", " urLDdata", " urLDta", "urldat", "urLDat", "urleddata", "urledATA", "urllata", "urledta", " urldATA", "urledata", "urLDta", " urLDATA", "URlddata", "urLData", "urldATA", "URlfata", "URlfat", " urldta", " urLData", "urlldata", "urlfATA", "urlfata", "urlfdata", "urllat", "urldta", "URlfATA", "URldata", "urLDATA", "urllATA", "URldATA", "urlleddata", " urlddata", "urlddata", "urLDdata", "URlfdata"], "factory": ["cFactory", " fault", "confFactory", " fFactory", "conflier", "confiller", "liller", "cflier", "fuild", "ciller", "lactory", "fFactory", "ufactory", "luild", "cault", "cfFactory", "pFactory", "ufuild", "cfiller", "flier", " flier", "lictionary", " fictionary", "pault", "ufictionary", "fault", "pactory", "filler", "confactory", " fuild", "ufiller", "piller", "cfactory", "cactory", "fictionary", " filler"], "parser": ["p", "lp", "arser", "util", "uri", "se", "json", "parse", "instance", "s", "driver", "root", "l", "manager", "loader", "writer", "ph", "Parser", "builder", "pdf", "ger", "up", "b", "utils", "monkey", "fruit", "api", "string", "jack", "handler", "plugin", "auto", "t", "er", "r", "reader", "parent", "xml", "raf", "library", "http"], "u": ["p", "uni", "uv", "util", "su", "uri", "uf", "us", "c", "plug", " ur", "eu", "s", "l", "tu", "ru", "yu", "io", "iu", "url", "ou", "b", "ui", "nu", "ur", "ul", "lu", "universal", "cu", "hu", "uu", "U", "o", "d", "http"], "is": ["p", "mis", "as", "ris", "init", "uri", "IS", "isa", "us", "ai", "info", "s", "its", "ori", "isu", "iss", "are", "ie", "Is", "serv", "or", "iso", "gets", "in", "ib", "lis", "ir", "ip", "io", "ar", "it", "fs", "ui", "isl", "pi", "api", "ais", "ios", "es", "abs", "iris", "obs", "ob", "bis", "has", "ri", "ops", "http"], "os": ["OS", "ops", "as", "dos", "ps", "so", "oss", "us", "bos", "s", "oes", "ens", "pos", "or", "iso", "ose", "gets", "sys", "ol", "oa", "opens", "io", "ros", "ms", "cos", "los", "fs", "bs", "fits", "oos", "ios", "aos", "ils", "es", "obs", "Os", "o", "ob", "osi", "bis", "oses", "http"], "iBufSize": ["iBufsize", "iBbufsize", "iBlfLength", "iBbufSize", "iByteufLength", "iBytebufSize", "iLlfLength", "iBytebufLength", "iByteufsize", "iLlfSt", "iBbufLength", "iByteufSize", "iBufLength", "iLufSt", "iLlfSize", "iBuffLen", "iLufSize", "iBbufLen", "iBlfsize", "iBufferSt", "iBufferSize", "iBuffLength", "iLlfsize", "iBlfLen", "iBuffersize", "iBytebufLen", "iBuffSt", "iLufLength", "iBytebufsize", "iBuffsize", "iBufSt", "iBuffSize", "iByteufLen", "iBufLen", "iBlfSt", "iLufsize", "iBufferLength", "iBlfSize"], "inBuf": ["inBluf", " inFbuf", "inbuf", " inFaf", "inDuff", "inBunk", "inFuf", "inFuff", "inDbuf", "outBuffub", "outBuffump", "inBump", "outBump", "inCbuf", "inCunk", " inBuff", "inBlunk", " inBaf", "inCuf", " inBump", "inPluf", "outBuf", "outBuffbuf", "inBuffuf", "inPlump", "inDuf", "inBub", "inDaf", " inBunk", " inCunk", " inCuf", "outBbuf", "inbub", "inBuffump", " inCbuf", "inCuff", " inCump", "inPlunk", "inFaf", "inBbuf", "inbump", "inFbuf", "outBuffuf", "inBuff", "inBuffbuf", "inBlbuf", " inFuff", "inbbuf", "inBlub", "inBuffub", "inBaf", "inCaf", "inBlump", "outBub", "inPlbuf", "inCump", " inFuf", " inBbuf"], "iNumRead": ["pNumberRead", "inumWritten", "qiNumREAD", "iChanBuild", "qiNumread", "pNumberWritten", "iValREAD", "iNumread", "inumread", "iLenRead", "iNumREAD", "iNumberBuild", "pNumberread", "pNumWritten", "iLenWritten", "iFatWritten", "inumWrite", " iFatWritten", "iChanREAD", "qiValread", " iFatRead", "pNumRead", "iNumWritten", "iNumberWrite", "iValRead", "iFatRead", " iNumWrite", "inumRead", "iValBuild", "iNumberread", "qiValREAD", "qiValBuild", " iFatWrite", "pNumread", "iNumberREAD", "iValread", "iNumberWritten", "qiNumBuild", "iChanRead", "qiNumRead", "iFatWrite", "iNumberRead", "iChanread", "pNumWrite", "iNumWrite", "qiValRead", "iLenWrite", " iNumWritten", "pNumberWrite", "iNumBuild"], "f": ["p", "F", "fp", "uf", "c", "s", "e", "l", "ff", "m", "n", "g", "io", "b", "fd", "fs", "fe", "j", "h", "fn", "fr", "fa", "handler", "rf", "full", "fc", "file", "df", "t", "r", "fi", "sf", "o", "feed", "v", "d"], "inputstream": ["Inputsw", " inputsw", "Inputchannel", " inputchannel", "outputchannel", "Inputstream", "contentStream", "InputStream", " inputStream", "inputsystem", "contentsw", "contentstream", "outputStream", "Inputsystem", "inputsw", "outputstream", "inputStream", "contentsystem", " inputsystem", "inputchannel"], "document": ["p", "source", "DOM", "media", "output", "language", "info", "page", "e", "l", "tree", "project", "ocument", "xml", "data", " documents", "m", "record", "object", "context", "director", "n", "directory", "window", "null", "docs", "Document", "Documents", "container", "list", "html", "dom", "office", "file", "collection", "t", "response", " documentation", "parent", "node", "d", "doc", "content"], "nodelist": ["nodedestyle", "nodemark", "nodestate", "nodata", "anodedeme", " nodesels", "nondestate", "nodedestate", "nodedeme", "snodseline", "NODelist", "nonedelist", "nozette", " nodesename", "Nodelist", "nozelist", "nODesh", "nodeeme", "snodselist", "nozename", "nodels", "snodsette", "nODelist", "nodette", "Nodestyle", "nodeestate", "nODeline", "nodedemark", "nodesename", "nODestyle", "anodedata", "anodestate", "snodslist", "nodedelist", "nondeme", " nodename", "nodeme", "snodlist", "nodesh", "nodestyle", "Nodemark", "anodelist", "snodelist", "Nodesh", "nonedette", "nodlist", "nodeline", "NODesh", "nodesels", "nozemark", "NODemark", "nondelist", "nondata", "nodedette", "snodette", "nozels", "nodeelist", " nodeselist", "nODette", "anodeme", "nodseline", "nodedlist", "nodsette", " nodette", " nodels", "nodedeline", "anodedestate", "nozestyle", " nodesette", "nodslist", "nodename", "nodeata", "nodedesh", "anodata", "nodeselist", "nODlist", "nodselist", "nozesh", "nonedels", "nonedename", "NODestyle", "nODemark", "nodedata", "anodedelist", "nodesette", "snodeline"], "num": ["Num", "dim", "uni", "init", "span", "uri", "net", "np", "len", "nom", "lim", "max", "pos", "count", "norm", "loc", "m", "NUM", "con", "total", "multi", "n", "zero", "col", "um", "nb", "nr", "number", "nu", "index", "om", "mon", "div", "comb", "ul", "tri", "sum", "en", "nam", "dom", "umi", "temp", "part", "mu", "unit", "inc", "node", "mult"], "i": ["p", "x", "uri", "c", "ai", "info", "ii", "gi", "ori", "ix", "ie", "d", "l", "I", "ci", "yi", "m", "chi", "in", "ini", "multi", "ip", "iu", "g", "io", "bi", "si", "a", "b", "col", "it", "iv", "ui", "ik", "pi", "oi", "ji", "j", "li", "index", "isi", "hi", "mi", "di", "qi", "eni", "y", "xi", "part", "fi", "cli", "mu", "slice", "id", "o", "v", "start", "ri", "ti", "phi"]}}
{"id1": "21754659", "id2": "20924119", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSonendo", "getButtonSenico", "getbuttonSenira", "getButtonJonido", "getButtonSenido", "getButtonSonico", "getButtonJonico", "getButtonJonendo", "getbuttonSenico", "getButtonJonira", "getButtonSenendo", "getButtonSonira", "getbuttonSonira", "getbuttonSonico", "getbuttonSenendo", "getButtonSonendo", "getbuttonSenido", "getButtonSenira", "getbuttonSonido"], "buttonSonido": ["buttonSonardo", "buttonHomida", "btnSonigo", "buttonHonido", "buttonDonido", "buttonsonardo", "buttonDonino", "buttonDonigo", " buttonSonardo", "buttonHomido", "buttonHonino", "btnDonardo", "buttonsonini", "btnSonado", "btnDonigo", "btnSonido", "buttonTanido", "buttonHonardo", "buttonSenardo", "ButtonDonida", "ButtonSonida", "ButtonDonini", " buttonSenido", "buttonSenado", "ButtonDonido", "btnSonini", "buttonSenigo", " buttonSenado", "ButtonSonido", "buttonDonini", " buttonSenida", "buttonSenida", "btnSonardo", "buttonDonado", " buttonSenardo", "buttonTanida", "buttonSonino", "buttonsonado", "btnDonido", "buttonSenini", "buttonSenido", "buttonsonigo", "ButtonSonardo", "buttonSonigo", "buttonSonini", "buttonDonida", "buttonSonida", "ButtonDonardo", "buttonSenino", "buttonTanardo", "buttonsonido", "buttonHomardo", " buttonSonida", " buttonSonino", "buttonHonado", "buttonSonado", "buttonHomado", "ButtonSonado", " buttonSenino", " buttonSonado", "btnDonado", "buttonTanado", "ButtonSonini", "ButtonDonado", "buttonDonardo"], "e": [" ev", " exc", " exp", " cause", " E", " other", "event", " en", " ace", " caught", "ed", "E", " te", " ie", " ignored", " Event", " ate", " fe", " je", " inst", " invoked", "ee", " pe", " events", "t", " exception", "Event"], "fc": ["lf", "F", "xc", "fp", "FE", "fx", "cf", "wk", "FS", "WF", "c", "GF", "f", "fb", "tc", "wt", "il", "wic", "LC", "irc", " FC", "DC", "Factory", "con", "fm", "af", "bf", "ec", "flo", "FC", "bc", "pc", "lc", "fd", "fw", "isc", "fs", "fe", "WC", "fl", "nc", "fn", "fa", "fr", "enc", "fed", "mc", "fi", "ct", "xf", "PF", "CF", "roc", "dc"], "returnVal": ["ReturnValue", "ReturnVAL", "returnValue", "Returnval", " returnValue", "backval", "returnNum", " returnVAL", "backVal", "ReturnVal", " returnval", "returnVAL", "continueNum", "continueVal", " returnNum", "continueval", "continueValue", "backVAL", "ReturnNum", "backValue", "returnval"], "file": ["local", "source", "message", "filename", "File", "fp", "uri", "out", "cf", "path", "f", "info", "page", "use", "ile", "per", "input", "to", "l", "socket", "image", "single", "global", "get", "data", "folder", "object", "resource", "binary", "FILE", "directory", "io", "class", "url", "base", "name", "log", "b", "document", "files", "fe", "zip", "function", "connection", "lock", "handler", "full", "php", "lib", "up", "part", "feed", "dir", "sf", "user", "type", "db", "http"], "rutaGlobal": ["rutoInternational", "rucaGlobal", "rottaGeneral", "srottaLocal", "rottaCore", "srettaLocal", "rucaGeneral", "rottaGlobal", "rutaGeneral", "srottaGlobal", " rutoGlobal", "rutiCore", "srettaGlobal", " rutoGeneral", "rutoCore", "rettaLocal", "rutaReal", "rugaLocal", "rettaReal", "rucaInternational", "rugaInternational", "srutaGlobal", "rutoGeneral", "rutiInternational", "rundaInternational", "rutiReal", "rutiGlobal", " rutoInternational", "srettaInternational", "srutaCore", "rottaLocal", "srottaCore", "rutaCore", " rutaGeneral", "rutaInternational", "srottaGeneral", "rundaGlobal", "rutoLocal", "srutaReal", "srettaReal", "srutaGeneral", "rugaReal", "rugaGlobal", "rettaInternational", "rutiLocal", "srutaInternational", "rundaGeneral", "srutaLocal", " rutaInternational", "rutoGlobal", "rutaLocal", "rettaGlobal", "rutiGeneral"], "rutaRelativa": ["rutaMalariva", "rutaRelarivism", "rutaRelateiv", "rutaRelateiva", "rutaRelattiv", "rutaRelATivo", "rutaMalativism", "rutaRelarativa", "rutaRelarativas", "rutaRelarativo", "rutaRelativism", "rutaRelATiva", "rutaRelateivism", "rutaRelateivo", "rutaRelativas", "rutaMalativo", "rutaMalativas", "rutaRelativ", "rutaMalarivism", "rutaMalarivas", "rutaRelATivas", "rutaRelarivo", "rutaRelattiva", "rutaRelariva", "rutaRelarivas", "rutaRelarativ", "rutaRelattivo", "rutaRelattivism", "rutaRelativo", "rutaMalativa", "rutaRelattivas", "rutaRelATiv", "rutaRelarativism", "rutaRelariv", "rutaMalarivo"], "fis": ["fir", "viss", "Fiss", "fiss", "xys", " fiss", "xiss", " fir", "fris", "Fos", "Fis", "xis", "vos", " fIs", "Fir", "Fris", " fys", "friss", "vis", "xris", "frir", "fys", "vIs", "Fys", "fIs", "fros", "FIs", " fris"], "fos": ["infos", "infios", "fileos", "Fo", "tfos", "FOS", " fops", " fOS", "Fos", "Fis", "tfOS", "infis", "Fops", "tfo", "fo", "Focks", " fo", "fileops", " focks", "fios", "tfops", "fileo", "fileocks", "Fios", "fOS", "infOS", "fops", " fios", "focks"], "canalFuente": ["canalFUante", "canalKugent", "canalFuenza", "canalBuante", "canalsBuent", "canalsFuente", "canalFUent", "canalBuence", "canallBuente", "canalKuenza", "canalfuence", "canulFuencer", "canulFiente", "canalFient", "canalsFuento", "canalsFuante", "canalFience", "canallBuence", "canallFuence", "canulFiencer", "canalBuent", "canalFiente", "canulFuence", "canalBuento", "canalBuenza", "canalKuence", "canalFuent", "canulFuente", "canalMuent", "canalfuenza", "canalfugent", "canalFugent", "canalsBuante", "canalMuence", "canalJuence", "canalsBuento", "canalFuento", "canalJuente", "canulFient", "canallFugent", "canalsBuente", "canalFuante", "canallBuenza", "canallFuenza", "canalJuento", "canalJuante", "canallFuente", "canalKuente", "canulFience", "canalMuente", "canalMuencer", "canalFiencer", "canulFuent", "canalFUente", "canalsFuent", "canalJuent", "canalFUento", "canalJuencer", "canalBuente", "canalfuente", "canalFuence", "canalBugent", "canalFuencer", "canallBugent"], "canalDestino": ["canalCampania", "canalNegina", "canalNegino", "canalNegania", "canelDestania", "canalldestino", "canalCampino", "canelDestination", "canalNegination", "canaldestino", "canalldestinos", "canelDestina", "canalDestinos", "canelCampina", "canalDestination", "canalCampinos", "canaldestinos", "canalDestina", "canelCampino", "canallDestania", "canaldestination", "canelCampania", "canaldestania", "canallDestina", "canallDestino", "canalCampina", "canalldestania", "canaldestina", "canalDestania", "canelCampination", "canalldestina", "canalCampination", "canallDestinos", "canelDestino"]}}
{"id1": "2736184", "id2": "21232043", "code1": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"getURLContent": ["getStreamContent", "getStreamBody", "getRequestBody", "postURLResource", "getRequestContents", "getUrlContent", "postURLBody", "postUrlContent", "getStreamResource", "getStreamContents", "getRequestResource", "postUrlResource", "postURLContent", "getURLContents", "getRequestContent", "postUrlContents", "getUrlResource", "postUrlBody", "getURLBody", "getURLResource", "postURLContents", "getUrlBody", "getUrlContents"], "urlPath": ["URLPath", "resourcePath", "urlName", "URLpath", "resourceName", "filePath", "urlContent", "bufferpath", "fileCase", "UrlPath", "bufferContent", "urlUrl", "UrlCase", "fileUrl", "resourceUrl", "fileName", "Urlpath", "URLUrl", "bufferPath", "bufferCase", "URLName", "filepath", "urlpath", "resourcepath", "fileContent", "UrlContent", "urlCase"], "requestData": ["responseData", "requestBody", " requestdata", "taskText", "taskdata", "requestText", "RequestBody", "RequestData", "taskBody", "taskData", " requestBody", "responseText", "requestdata", " requestInfo", "RequestInfo", "requestInfo", "responseBody", "RequestText", "responseInfo", " requestText", "Requestdata"], "charset": ["chasesET", "charsET", "charsetting", "clARSpace", "chasource", "CharsET", "chacterspace", "Charset", "clarspace", "chARSource", "claseset", "chasesetting", "Charsource", "clarsetting", "charsets", "chARSpace", "clARSets", "chactersource", "chasET", "charsource", "chARSetting", "chaspace", "Chaset", "chactersET", "chARSet", "clasesetting", "Chaspace", "clarsets", "clARSet", "chasetting", "chasesets", "clasespace", "clarset", "charspace", "Chasource", "clarsET", "clasesET", "Charspace", "chARSets", "ChasET", "chacterset", "chaset", "chaseset", "clARSET", "chasespace", "chARSET"], "reader": ["source", "result", "cache", "client", "sync", "inner", "config", "rr", "timeout", "driver", "i", "socket", "bird", "read", "loader", "writer", "oder", "in", "ner", "resource", "req", "q", "io", "core", "server", "ch", "rc", "connection", "worker", "channel", "handler", "raw", "parser", "Reader", "iter", "request", "row", "err", "r", "er", "error", "http"], "conn": ["init", "cache", "uc", "connected", "session", "config", "ai", "Connection", "ca", "ci", "con", "close", "auth", "act", "core", "ann", "col", "code", "conf", "channel", "cp", "enc", "ct", "ctx", "error", "can", "http", "client", "sync", "reg", "Conn", "pub", "io", "n", "rc", "nc", "coll", "Connect", "mc", "cli", "comm", "cb", "org", "cf", "path", "nt", "socket", "pg", "pc", "cm", "en", "o", "c", "ac", "cat", "cmd", "in", "open", "ec", "on", "connect", "conv", "server", "exec", "query", "ch", "connection", "lock", "cn", "part", "err", "ssl", "co", "dc"], "buffer": ["flow", "source", "message", "result", "sb", "cache", "output", "fp", "str", "length", "bb", "buff", "fb", "buf", "use", "timeout", "uffer", "line", "data", "writer", "loader", "throw", "resource", "builder", "binary", "print", "base", "array", "b", "server", "transfer", "counter", "Buffer", "append", "string", "queue", "batch", "iter", "request", "row", "wave", "response", "feed", "cb", "report"], "out": ["source", "group", "call", "init", "app", "result", "copy", "cache", "output", "client", "sync", "net", "inner", "download", "config", "w", "timeout", "cmd", "socket", "OUT", "data", "writer", "con", "in", "object", "resource", "loader", "io", "bin", "base", "log", "name", "null", "outer", "server", "exec", "pool", "obj", "conf", "child", "ch", "container", "connection", "string", "channel", "Out", "write", "outs", "again", "file", "parent", "part", "err", "ssl", "login", "o", "user", "plain", "inc", "error", "network", "co", "no"], "url": ["ls", "org", "cache", "uri", "uc", "client", "path", "Url", "c", "f", "il", "l", "socket", "con", "web", "resource", "open", "www", "n", "base", "log", "bc", "b", "lc", "server", "host", "URL", "sl", "api", "connection", "channel", "ur", "ll", "file", "ssl", "http"], "repCode": ["repZone", " repType", "repResponse", "respCode", " repData", "RepState", "replData", "replType", " repResponse", "replCode", " repState", "RepCode", "respResponse", "respType", "repType", "replCount", "respZone", " repZone", "respCount", "repCount", "respData", "repData", " repCount", "RepZone", "respState", "repState", "RepResponse"], "count": ["char", "cache", "current", "depth", "length", "c", "len", "use", "i", "max", "keep", "read", "ind", "found", "process", "act", "force", "core", "limit", "base", "name", "add", "allow", "col", "code", "counter", "number", "child", "index", "time", "list", "size", "Count", "cond", "sum", "weight", "more", "part", "key", "id", "end", "get", "start", "offset"], "chBuffer": ["quBuffer", "chImpl", "ichBuff", "quBar", "chArray", "charBuffer", "ichBar", "charbuffer", " chBuff", "chCount", "chBar", "ichBuffer", "ichCount", "quBuff", "phbuffer", "cbuffer", "ChBuffer", "ChBar", "Chbuffer", " chImpl", " chbuffer", "charArray", "cBuffer", "chBuff", "ctBuff", "ChBuff", "cArray", "ctBuffer", "ChCount", "cBuff", "phImpl", "phBuff", "quCount", "ctArray", "ChImpl", "charBuff", "chbuffer", "ctbuffer", "phBuffer"], "input": ["source", "form", "output", "client", "inner", "instance", "config", "s", "this", "event", "Input", "driver", "i", "inch", "l", "socket", "image", "data", "loader", "in", "resource", "inf", "server", "active", "exec", "child", "connection", "stream", "wrapper", "iter", "temp", "request", "r", "er", "inc", "http"]}}
{"id1": "18217985", "id2": "23467091", "code1": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"fromHtml": ["fromHText", "fromBushttp", " fromChText", "fromShhtml", " fromHUrl", "fromPhttp", "fromChText", "fromHttpText", "fromBushtml", " fromChUrl", "fromShUrl", "fromChhtml", " fromChhtml", " fromPhHTML", "fromHttp", "fromHttptml", " fromPhttp", " fromHText", "fromBushHTML", " fromHml", "fromHttpUrl", "fromHhtml", "fromPhml", "fromChUrl", "fromHttpHTML", "fromChtml", "fromHttpml", " fromHhtml", "fromHml", " fromHHTML", " fromPhml", "fromHttpttp", "fromHHTML", "fromHttphtml", "fromPhHTML", " fromChtml", " fromPhtml", "fromHUrl", "fromPhtml", "fromBushml", "fromShtml", " fromHttp", "fromShText"], "url": ["text", "source", "org", "ref", "remote", "uri", "str", "client", "browser", "path", "Url", "download", "config", "f", "page", "domain", "il", "link", "input", "l", "image", "or", "loc", "loader", "blog", "web", "service", "object", "location", "builder", "resource", "open", "email", "www", "base", "name", "server", "host", "article", "URL", "obj", "address", "ch", "sl", "api", "connection", "string", "ur", "lr", "html", "file", "cli", "r", "ssl", "response", "id", "xml", "http"], "defaultEncoding": ["currentEnoding", " defaultEncasing", "defaultencode", "currentEnoded", "defaultChoding", " defaultencoding", "currentEncoding", "defaultCoder", "defaultencasing", " defaultCasing", "defaultEnode", "defaultCoded", "defaultEngoding", "defaultEngoder", " defaultCoding", "defaultEncoder", "defaultEnoding", "defaultChasing", "defaultEnasing", "currentEncoded", " defaultencoder", "defaultEngasing", " defaultCoded", " defaultencoded", " defaultencasing", "defaultEncode", "currentEncasing", "defaultencoder", " defaultCoder", "defaultencoded", "defaultEnoded", " defaultEncoder", "defaultencoding", "defaultCoding", "defaultChoded", "defaultEncasing", "currentEnode", "defaultChode", "currentEnasing", "defaultCasing", " defaultEncoded", "defaultEngoded", "defaultEncoded", "defaultEnoder", "currentEncode"], "overrideEncoding": ["overwriteEncoding", "overrideEnoding", "overrideencoder", "overrideEncoder", "overrideCoding", "overwriteEnoded", "overrideEnasing", "overrideCoded", "overwriteEnoding", "overrideEncoded", "overrideEncasing", "overrideCoder", "overwriteEnasing", "overrideencasing", "overwriteEncoder", "overwriteEncoded", "overwriteEncasing", "overrideencoding", "overrideEnoder", "overwriteEnoder", "overrideEnoded", "overrideCasing", "overrideencoded"], "conn": ["out", "client", "sync", "session", "cb", "c", "config", "f", "dc", "reg", "Connection", "cmd", "nt", "l", "serv", "Conn", "socket", "loc", "con", "close", "open", "ad", "act", "n", "connect", "ann", "conv", "server", "exec", "conf", "ch", "api", "connection", "nc", "cp", "enc", "coll", "sql", "cn", "err", "ssl", "cli", "dn", "ct", "ctx", "db", "co", "http"], "contentType": ["enctype", "resourceName", "contentClass", "ContentLine", " contentFormat", "documentName", "ContentClass", "contentPath", "ContentUnit", "codeFile", "filetype", "languageStyle", " contentText", "inputPath", "wordtype", "inputUnit", " contentUnit", "documentType", "ontentPath", "inputType", "documentInfo", "ContentFile", "encLength", "contentFile", "codeType", "fileType", "contentToken", "contentText", "wordType", "languagetype", " contentLength", "ontentClass", "inputLine", "codetype", "inputtype", "contentName", "ContentLength", "ContentType", "ContentPath", "languageInfo", " contentName", "wordName", "codeInfo", "languageType", " contenttype", "codeStyle", " contentToken", "ontentType", "contentStyle", "fileFile", "ContentText", "contentLength", "ontentName", " contentStyle", " contentClass", " contentLine", "workType", "Contenttype", "contenttype", "resourceLength", "workToken", "codeName", "ContentName", " contentFile", "contentInfo", "filePath", "ContentInfo", "resourceInfo", "contentFormat", "ontentLength", "resourceUnit", "contentLine", "resourcetype", " contentPath", "workLength", "worktype", "documentText", "ontentFormat", "encToken", "encType", "resourceType", "codeUnit", "ContentFormat", " contentInfo", "contentUnit"], "encoding": ["enhoding", "equoding", "enhode", "engoded", "Encoding", "execoded", "encoded", " encapping", "enaching", "encode", "encryption", "encasing", "Encasing", "collasing", "casing", "equapping", "enhryption", "encoder", "ecasing", "enhasing", "Encoded", "colloded", "Encryption", "Encode", "coding", "execoding", " encryption", "engoder", "engapping", "coder", "enoded", "caching", "colloding", "enoding", "execoder", "execasing", " encosing", "encaching", "enosing", "ecoding", "Encaching", "enoder", " encode", "engosing", "ecoded", "colloder", "equosing", "equoded", " encoder", "encosing", " encasing", "engasing", "engoding", "enasing", "Encoder", "encapping", "ecoder", "equoder", "coded"], "i": ["p", "x", "init", "uri", "c", "ni", "f", "ai", "gi", "ii", "ori", "ix", "info", "ei", "e", "ie", "l", "I", "area", "ci", "yi", "abi", "ini", "multi", "ip", "io", "bi", "iu", "si", "u", "lc", "is", "ui", "pi", "api", "ji", "li", "j", "h", "oi", "hi", "mi", "di", "qi", "eni", "xi", "fi", "cli", "t", "mu", "slice", "o", "id", "zi", "adi", "v", "ri", "ti", "phi"], "s": ["p", "ls", "source", "as", "su", "ps", "sb", "ts", "ss", "str", "sync", "session", "c", "f", "sym", "e", "sg", "l", "ds", "m", "service", "strings", "ws", "n", "g", "a", "si", "ses", "u", "os", "b", "fs", "sl", "string", "h", "ins", "enc", "details", "gs", "en", "settings", "ns", "abs", "es", "r", "ssl", "t", "o", "sv", "site", "S", "v", "js", "d"], "expected": [" e", "nexpected", "style", "pecting", " Expect", "current", "reported", "wrong", "actual", "pect", "info", "event", "pected", "e", "ie", "needed", "ed", "default", "updated", "required", "example", "found", "allowed", "format", "email", "yet", "latest", "supported", "force", " ie", " received", "next", " unexpected", "fake", " accepted", "opened", "host", " expecting", "seen", "specified", " expects", "now", "ception", "pretty", "handled", "element", "encrypted", " expect", "received", "provided", "failed", "illegal", " event", " expectation", "response", "entry", "acceptable", "forced", "type", " email", "error", "target"], "index": ["x", "match", "edit", "column", "position", "shape", "current", "output", "length", "update", "point", "date", "info", "all", "page", "ix", "level", "input", "pos", "none", "ind", "loc", "condition", "ini", "object", "open", "where", "find", "connect", "num", "search", "array", "Index", "width", "number", "address", "list", "size", "prefix", "alpha", "option", "element", "sort", "weight", "value", "version", "pull", "key", "slice", "end", "id", "unit", "type", "diff", "inc", "offset", "active"], "msg": ["text", "og", "message", "sim", "Message", "ug", "str", "info", "reg", "title", "rr", "ag", "mr", "cmd", "sg", "agg", "fg", "format", "mess", "g", "log", "name", "ms", "reason", "Msg", "gen", "printf", "mid", "gm", "lang", "dr", "details", "mt", "gs", "mit", "desc", "MS", "ma", "err", "comm", " message", "error", "doc"], "in": ["p", "as", "buffer", "rx", "gin", "inn", "out", "inner", "c", "ax", "input", "inas", "xml", "read", "IN", "data", "ini", "win", "con", "io", "din", "b", "dr", "ins", "connection", "fr", "stream", "In", "impl", "inc", "rin", "r", "err", "login", "id", "reader", "bin", "tin"]}}
{"id1": "21979462", "id2": "14688886", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURLtoLong", " downloadURLintoString", " downloadURLintoStr", " downloadUrlasstring", " downloadURLtoStr", " downloadURLtostring", " downloadURL2Str", " downloadUrltoString", " downloadURLasLong", " downloadUrltostring", " downloadUrlasLong", " downloadURLasstring", " downloadURLasStr", " downloadUrltoStr", " downloadURLintostring", " downloadUrlasString", " downloadURL2String", " downloadURLasString", " downloadURL2string", " downloadUrltoLong", " downloadURLintoLong", " downloadUrlasStr", " downloadURL2Long"], "url": ["source", "ref", "remote", "buffer", "gl", "uri", "path", "Url", "config", "f", "page", "link", "l", "image", "loc", "loader", "data", "service", "resource", "base", "name", "bel", "b", "job", "server", "URL", "address", "sl", "connection", "rule", "lr", "el", "file", "ssl", "user", "http"], "in": ["source", "as", "init", "into", "buffer", "ln", "rx", "re", "gin", "inn", "out", "inner", "ac", "f", "at", "s", "fb", "cms", "i", "input", "read", "IN", "data", "ini", "af", "n", "isin", "bin", "b", "it", "is", "nin", "min", "ins", "h", "fr", "lin", "In", "impl", "inc", "again", "r", "ssl", "login", "ilo", "err", "reader", "din", "db", "ic"], "sb": ["ls", "bh", "buffer", "xb", "SB", "obb", "bb", "s", "buff", "lab", "buf", "fb", "ub", "sg", "pb", "src", "mb", "B", " SB", "bp", "kb", "ib", "zb", "erb", "bf", "lb", "sth", "sa", "si", "bc", "bt", "b", "usb", "nb", "bs", "rb", "db", "gb", "eb", "bm", "BB", "lr", "amb", "bsp", "wb", "sf", "Bs", "sv", " eb", "cb", "abb", "bd"], "str": ["text", "char", "result", "arr", "st", "br", "Str", "f", "s", "pass", "txt", "i", "l", "bl", "line", "STR", "stri", "read", "data", "sr", "n", "name", "b", "lc", "spec", "obj", "cr", "wr", "sl", "sp", "dr", "cur", "string", "list", "exp", "div", "fr", "enc", "cl", "pr", "coll", "iter", "tr", "r", "err", "key", "ct", "doc"]}}
{"id1": "13362846", "id2": "17557289", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"setContenu": ["setContenuit", "setContineu", "setContineuit", "setTonenuer", "setContenues", "setTonenu", "setContonenuer", "setContennues", "setTenuit", "setContineuer", "setTenu", "setContenuer", "setContonenues", "setContennu", "setContonenu", "setContineues", "setTenuer", "setTenues", "setContennuer", "setTonenues", "setContonenuit", "setTonenuit", "setContennuit"], "contenuFichier": ["contenuFaffie", "contenuFaffier", "contenuFochique", "contenuPFicher", "contenuTicheery", "contenuFcherer", "contenuMichique", "contenuFrenchique", "contenuFrencherer", "contenuPhactoryoyer", "contenuTicheiere", "contenuFactoryie", "contenuTichiere", "contenuFichieri", "contenuFaffer", "contenuFichery", "contenuFichtique", "contenuFichique", "contenuMaffiers", "contenuFocher", "contenuFochiere", "contenuFicheier", "contenuFichtiere", "contenuPFichier", "contenuPrefichiers", "contenuFactoryiere", "contenuMichie", "contenuPhactoryier", "contenuFichtier", "contenuMrenchique", "contenuMichiers", "contenuMrenchier", "contenuFactoryoyer", "contenuPrefaffiers", "contenuPrefichiere", "contenuPrefichie", "contenuFchery", "contenuFicheiere", "contenuFochie", "contenuFaffieri", "contenuFicie", "contenuPhichoyer", "contenuFichtie", "contenuFaffiere", "contenuFicier", "contenuMaffieri", "contenuTicherer", "contenuFichiers", "contenuPrefaffiere", "contenuFicher", "contenuFicheery", "contenuTicheerer", "contenuFchiere", "contenuPFochique", "contenuFactoryier", "contenuPhactoryie", "contenuPhichiere", "contenuFrenchiere", "contenuFichiere", "contenuPhactoryiere", "contenuPFocher", "contenuPrefaffie", "contenuFchier", "contenuPFichiere", "contenuFicheique", "contenuFrenchery", "contenuTicheier", "contenuFrenchoyer", "contenuFicheieri", "contenuFichoyer", "contenuPrefichier", "contenuMrenchiere", "contenuFochiers", "contenuMaffier", "contenuMaffie", "contenuTichery", "contenuFochier", "contenuMichier", "contenuFrenchier", "contenuMaffiere", "contenuFrenchie", "contenuFicheie", "contenuPhichie", "contenuPFochier", "contenuFaffique", "contenuFiciere", "contenuFicherer", "contenuPhichier", "contenuFrenchiers", "contenuFicheerer", "contenuPrefaffier", "contenuPFichique", "contenuPFochiere", "contenuMrenchie", "contenuMichiere", "contenuFicoyer", "contenuFicheer", "contenuFichie", "contenuFaffiers", "contenuMichieri", "contenuFichtieri", "contenuTichier"], "fichierElectronique": ["fichierElectorniques", "fichierElectron\u00e9e", "fichierElectroneier", "fichierElectrolier", "fichierAdministronier", "fichierElectromistic", "fichierAustrolier", "fichierElectrolique", "fichierElectonlique", "fichierAdministronsique", "fichierElectronsiere", "fichierElectronsiques", "fichierElectaronie", "fichierElectornique", "fichierAustroliere", "fichierAdministronsie", "fichierElectronsical", "fichierElectroliere", "fichierElectroneique", "fichierCentornlique", "fichierElectronsique", "fichierElectolonique", "fichierElectoloniere", "fichierElectolonica", "fichierElectroneiere", "fichierElectrons\u00e9e", "fichierElectonie", "fichierAdministronsical", "fichierAdministroniques", "fichierElectrolie", "fichierCentornique", "fichierElectpronique", "fichierAustronique", "fichierElectromical", "fichierElectronsica", "fichierAdministronsier", "fichierElectoloniques", "fichierElectroniere", "fichierElectroneie", "fichierAustroniques", "fichierAdministronie", "fichierElectornlique", "fichierCentronique", "fichierCentroniques", "fichierElectroliques", "fichierAdministrons\u00e9e", "fichierElectonier", "fichierElectronical", "fichierElectproniques", "fichierElectronlique", "fichierAdministronique", "fichierElectrolica", "fichierElectornier", "fichierElectronistic", "fichierElectronslique", "fichierElectaronier", "fichierAdministronsistic", "fichierElectaron\u00e9e", "fichierCentronier", "fichierElectronsistic", "fichierAustroliques", "fichierElectonique", "fichierAdministronical", "fichierElectronica", "fichierCentronlique", "fichierElectpronical", "fichierElectpronistic", "fichierCentorniques", "fichierElectronsier", "fichierAustrolique", "fichierElectromique", "fichierElectroneiques", "fichierAustroniere", "fichierElectroniques", "fichierAdministronslique", "fichierElectrol\u00e9e", "fichierElectronsie", "fichierAdministron\u00e9e", "fichierAustronier", "fichierElectronie", "fichierAdministronsiques", "fichierElectromiques", "fichierElectronier", "fichierElectronelique", "fichierAdministronistic", "fichierAdministronlique", "fichierElectaronique", "fichierCentornier"], "utilisateurCourant": ["utilisationCourants", "utilisateurGovernateur", "utilisateurCourateur", "utilisateurGovernante", "utilisationCourante", "utilisateurGovernant", "utilisateurCourants", "utilisationApplicante", "utilisateurGovernants", "utilisationCourant", "utilisateurParticipant", "utilisationApplicateur", "utilisateurCourante", "utilisateurApplicants", "utilisateurApplicateur", "utilisateurParticipante", "utilisationCourateur", "utilisateurApplicant", "utilisateurApplicante", "utilisationApplicant", "utilisateurParticipants", "utilisationApplicants", "utilisateurParticipateur"], "support": ["pport", "contact", "util", "facebook", "concept", "summary", "media", "client", "push", "Support", "cover", "feature", "config", "system", "info", "compatible", "knowledge", "control", "services", "respect", "friend", "evidence", "review", "service", "proxy", "help", "format", "supported", "force", "storage", " Support", "accept", "document", "ann", "share", "allow", "utils", "supp", "best", "bank", "plugin", "Library", "settings", "protection", "pull", "library", "know"], "ficheDocument": ["fielCatalog", "fcheMatrix", "inficheDoc", "fraudDirectory", "fineFeature", "fagueDocument", "fagueDirectory", "facheDocument", "foineDocument", " fcheDirectory", "fcheDirectory", "facheDocuments", "ficheNumber", "FcheContent", "affinedocument", " ficheDocuments", "enfoiceDocument", "fraudCompany", "afficheFeature", "FicheDoc", "foiceDirectory", "ficheDocuments", "fchaDoc", "affineDocument", " fcheDocuments", "ficheCatalog", "afficheDocument", "foiceDocument", " ficheDirectory", "ficheMatrix", "foineDoc", "infraudNumber", " fcheDocument", "fetchDocument", "FcheDocument", "enficheCompany", "inficheNumber", "ficheFeature", "fielDirectory", "fruitDocument", "ficheCompany", "enficheCatalog", "enficheDirectory", "enfoiceDirectory", "enfoiceCompany", "infraudDocument", "enficheDocument", "friqueDocument", "infichedocument", "fcheDocuments", " ficheMatrix", "FcheDoc", "fielCompany", "fetchdocument", "finedocument", " fcheMatrix", "fcheContent", "fchaContent", "FicheContent", "financeNumber", "enfoiceCatalog", "Fichedocument", "friqueContent", "affichedocument", "fraudNumber", "fagueMatrix", "foineFeature", "facheMatrix", "foiceCatalog", "financeDocument", "facheDirectory", "Fchedocument", "affineDoc", "infraudDoc", "affineFeature", "fetchFeature", "fineDoc", "ficheContent", "fineDocument", "fcheDoc", "afficheDoc", "fraudDoc", "fetchDoc", "ficheDoc", "friquedocument", "infrauddocument", "fchedocument", "fchadocument", "fichedocument", "fruitdocument", "inficheDocument", "fruitNumber", "fcheDocument", "frauddocument", "fchaDocument", "foiceCompany", "FicheDocument", "friqueDoc", "foinedocument", "fagueDocuments", "fraudDocument", "ficheDirectory", "financeDoc", "fielDocument", "fruitDoc", "fraudCatalog", "financedocument"], "nomFichier": ["nomWchery", "nomPhichiere", "nomNichiller", "nomFachiller", "nomPichien", "nomFichien", "nomPichery", "nomVich\u00e8re", "nomFichtery", "nomVcher", "nomFiqurier", "nomFichiere", "nomWichire", "nomPchery", "nomVchieri", "nomF\u00e9tier", "nomWichiere", "nomFichieri", "nomF\u00e9tien", "nomPchien", "nomNichier", "nomPrefchieri", "nomFachrier", "nomPchier", "nomFichtiner", "nomVchier", "nomPhicherer", "nomFachieri", "nomFichire", "nomFochier", "nomWchier", "nomFiscier", "nomFrench\u00e8re", "nomFochery", "nomPrefchier", "nomPrefichieri", "nomFchy", "nomFachier", "nomFchire", "nomVch\u00e8re", "nomFichery", "nomPhichieri", "nomPhachiere", "nomFichtiere", "nomFichiner", "nomPhichier", "nomFiscy", "nomNichtiner", "nomPrefichire", "nomFachiner", "nomFchieri", "nomFichtire", "nomFitherer", "nomPrefichrier", "nomFochiere", "nomFrenchier", "nomFrenchieri", "nomFacherer", "nomFacher", "nomFichtiller", "nomVicher", "nomFchiere", "nomWichery", "nomFithiere", "nomFachire", "nomFiquier", "nomNicher", "nomVichieri", "nomNichtier", "nomFochire", "nomPchy", "nomFithieri", "nomFisciller", "nomFch\u00e8re", "nomF\u00e9ty", "nomFchrier", "nomFicherer", "nomFchier", "nomFiquieri", "nomVichier", "nomFchery", "nomPichy", "nomPrefchire", "nomFithier", "nomFisciner", "nomFichterer", "nomFichtier", "nomFichtieri", "nomPhachieri", "nomWchire", "nomFchien", "nomPrefichier", "nomWichier", "nomFiscery", "nomWchiere", "nomF\u00e9tery", "nomFiscien", "nomFcher", "nomFrencher", "nomFichy", "nomPhachier", "nomFachiere", "nomPrefchrier", "nomFichrier", "nomFich\u00e8re", "nomNichter", "nomFach\u00e8re", "nomPichier", "nomNichiner", "nomFichter", "nomFichiller", "nomFiscer", "nomFicher", "nomPhacherer", "nomFiquire", "nomNichtiller"], "extension": ["Extension", "Extime", "extception", "extensions", "EXTension", "anchension", "Extression", "encion", "encension", "encception", "EXTensions", "extion", "anchensions", "exception", "exression", "exension", "EXTime", "anchime", "Extception", "Extion", "extime", "encression", "extression", "Extensions", "exion"], "fichierElectroniqueExistant": ["fichierElectroniqueXist", "fichierElectroniquesExists", "fichierElectroniqueExplclusive", "fichierElectroniqueExplistant", "fichierElectroniqueExplivist", "fichierElectroniquesExistance", "fichierElectroniquesXist", "fichierElectroniquesXclusive", "fichierElectroniqueExilingual", "fichierElectroniqueSistance", "fichierElectroniqueexclusive", "fichierElectroniqueXistant", "fichierElectroniquesXistent", "fichierElectroniqueXistent", "fichierElectroniqueexists", "fichierElectroniquesXilingual", "fichierElectroniqueSistent", "fichierElectroniquesXistance", "fichierElectroniqueXists", "fichierElectroniquesXistant", "fichierElectroniqueexivist", "fichierElectroniquesExilingual", "fichierElectroniqueSilingual", "fichierElectroniqueexistance", "fichierElectroniquesExist", "fichierElectroniqueexist", "fichierElectroniqueExistance", "fichierElectroniquesXivist", "fichierElectroniqueExplists", "fichierElectroniqueexistant", "fichierElectroniqueexilingual", "fichierElectroniquesExistant", "fichierElectroniqueXilingual", "fichierElectroniqueExistent", "fichierElectroniqueExists", "fichierElectroniquesExistent", "fichierElectroniqueExplistance", "fichierElectroniqueExclusive", "fichierElectroniqueXivist", "fichierElectroniquesXists", "fichierElectroniquesExclusive", "fichierElectroniqueXclusive", "fichierElectroniquesExivist", "fichierElectroniqueSistant", "fichierElectroniqueExist", "fichierElectroniqueXistance", "fichierElectroniqueexistent", "fichierElectroniqueExivist", "fichierElectroniqueExplist"], "idIgid": ["idUgname", "idIgenids", "idIgnID", "idIgnid", "idIogdid", "idUguids", "idIgubit", "idEGbit", "idIgudid", "idEGdid", "idEgdid", "idIggids", "idUguID", "idUguid", "idIgenname", "idIgids", "idUguname", "idIgod", "idIGids", "idEGids", "idIgdid", "idIgmid", "idIgID", "idIguod", "idIGdid", "idIgenid", "idUgID", "idIgmids", "idIogid", "idEGid", "idUgid", "idUgids", "idEgid", "idIogids", "idIgname", "idIgenID", "idIgmname", "idIgmID", "idIggod", "idEgids", "idIguid", "idEgbit", "idIggID", "idIGid", "idIguids", "idIguname", "idIGbit", "idIguID", "idIggid", "idIgbit", "idIogbit", "idIgnids", "idIgnod"], "inputStream": ["InputStreamer", " inputThread", " inputstream", "outputStreamer", "eventStream", "InputThread", "InputLength", " inputLength", "Inputstream", "eventStreamer", "inputstream", "InputStream", "eventSteam", "inputLength", "outputLength", "InputSteam", "eventstream", "inputStreamer", " inputSteam", "inputThread", "outputstream", "inputSteam", "outputThread", "outputSteam"], "outputStream": ["entityStream", "OutputStream", "OutputStreamer", "OutputSteam", "officeStream", "Outputstream", "inputContext", "outputStreamer", "officeSteam", "OutputContext", "entityStreamer", "outputContext", " outputSteam", "inputstream", "entitystream", "officeStreamer", "entitySteam", " outputContext", "inputStreamer", "outputstream", "inputSteam", "officestream", " outputstream", "outputSteam"], "typeMime": ["typeMatangle", "TypeSmime", "TypeSmangle", "typeMimes", "TypeMangle", "typeMetime", "typeSmangle", "TypeMide", "typeMetimes", "typeMatide", "typeSmimes", "typeMatime", "TypeMimes", "typeMangle", "typeMatimes", "typeSmime", "typeMetide", "TypeSmimes", "typeMide", "TypeMime", "typeSmide", "TypeSmide", "typeMetangle"], "tailleFichier": [" tailleFicheier", " tailleFochie", " taillefichie", " taillefochie", " tailleFignier", " taillefocher", " taillefochier", " tailleFochier", " tailleFichie", " taillefichiers", " tailleFigner", " tailleFichiers", " taillefochiers", " tailleFochiers", " taillefichier", " tailleFignie", " tailleFocher", " tailleFicheiers", " tailleFicheer", " tailleFicheie", " tailleFigniers", " tailleficher", " tailleFicher"]}}
{"id1": "2936678", "id2": "9956095", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    public void exportNotesToServer() {\n        boolean uploaded = true;\n        try {\n            File f = new File(UserSettings.getInstance().getNotesFile());\n            FileInputStream fis = new FileInputStream(f);\n            String urlString = protocol + \"://\" + UserSettings.getInstance().getServerAddress() + UserSettings.getInstance().getServerDir() + f.getName();\n            setDefaultAuthenticator();\n            URL url = new URL(urlString);\n            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n            urlc.setDoOutput(true);\n            urlc.setRequestMethod(\"PUT\");\n            OutputStream os = urlc.getOutputStream();\n            int nextByte = fis.read();\n            while (nextByte != -1) {\n                os.write(nextByte);\n                nextByte = fis.read();\n            }\n            fis.close();\n            os.close();\n            if (urlc.getResponseCode() != HttpURLConnection.HTTP_CREATED && urlc.getResponseCode() != HttpURLConnection.HTTP_NO_CONTENT) {\n                uploaded = false;\n            }\n        } catch (SSLHandshakeException e) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.sslcertificateerror\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n            uploaded = false;\n        } catch (Exception e) {\n            uploaded = false;\n        }\n        if (uploaded) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"info.notesfileuploaded\"), I18N.getInstance().getString(\"info.title\"), JOptionPane.INFORMATION_MESSAGE);\n        } else {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.notesfilenotuploaded\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }\n", "label": 0, "substitutes": {"getUniqueKey": ["makeuniqueHash", "getUniquekey", "getuniquekey", "getPrimarykey", "makeuniqueKey", "getUniqueLink", "getuniqueHash", "getStringkey", "makeUniqueLink", "makeUniquekey", "getStringKey", "makeuniqueLink", "getPrimaryLink", "getStringLink", "getuniqueKey", "getuniqueLink", "getPrimaryKey", "getUniqueHash", "makeuniquekey", "getPrimaryHash", "makeUniqueHash", "makeUniqueKey", "getStringHash"], "digest": ["Digit", "Digester", "dester", "Digests", "DigEST", "digEST", "digested", " digests", "uuid", "Digid", "uuester", "dests", "longested", "uuEST", "dested", "dest", "genit", "uuest", " digit", "digests", " digEST", "Digest", "digit", "genest", "digid", " digested", "Digested", "genEST", "longester", " digid", "digester", "longEST", "longest", " digester"], "md": ["mand", "hm", "alg", "mm", "mp", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", " dd", "de", "mb", "meta", "mg", "sd", "m", "nm", "metadata", "ad", "mad", "mac", "grad", "ud", "sm", "vd", "gen", "nd", "pd", "gd", "med", " MD", "gb", "ld", "od", "dd", "mn", "mo", "mt", "hd", "cd", "km", "MD", "dh", "mc", "pm", "ma", "df", "mag", "v", "d", "rpm", "bd", "dc"], "timeVal": ["timeValue", "TimeSeries", " timeSeries", "TimeValue", "timeval", "rateValue", "TIMEVal", "rateVal", " timeValue", "TimeBu", "rateBu", " timeLen", "TIMEval", "TIMESeries", "timeBu", "rateLen", "timeSeries", " timeBu", "timeLen", "TimeLen", " timeval", "TimeVal", "TIMEValue", "Timeval"], "localHost": [" localPort", "remoteHost", "privatehost", "remoteMac", "remotePort", "LocalAddress", "privateAddress", "LocalHost", "remotehost", "localhost", " localMac", "localAddress", "LocalMac", "localMac", "privatePort", " localAddress", " localhost", "privateHost", "Localhost", "remoteAddress", "localPort", "LocalPort"], "randVal": ["randomVal", " randLen", " randBu", "RandStr", "randomValue", "RandBu", "randomBu", "RandomValue", "randLen", "randBu", "randomStr", "RandomVal", "randValue", " randValue", "randomval", " randval", "RandValue", "randval", "RandomLen", "RandVal", " randStr", "randomLen", "randStr", "Randomval"], "val": ["x", "ref", "ret", "result", "pt", "seq", "update", "reg", "buf", "vol", "az", "bl", "vals", "ind", "loc", "data", "addr", "format", "values", "VAL", "valid", "grad", "base", "sel", "msg", "sl", "res", "live", "db", "eval", "string", "gb", "dev", "enc", "pr", "range", "el", "test", "value", "temp", "pm", "key", "id", "rev", "unit", "v", "Val", "abc"]}}
{"id1": "19868933", "id2": "23666867", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingnFile", "copyFromFileToFileUsingnIO", "copyFromFileToFileWithFileChannel", "copyFromFileToFileWithNio", "copyFromFileToFileUsingNFile", "copyFromFileToFileUsingNio", "copyFromFileToFileUsingNetChannel", "copyFromFileToFileUsingNChannel", "copyFromFileToFileWithNIO", "copyFromFileToFileWithNFile", "copyFromFileToFileWithFileFile", "copyFromFileToFileWithFileio", "copyFromFileToFileWithNChannel", "copyFromFileToFileUsingFileio", "copyFromFileToFileUsingFileChannel", "copyFromFileToFileUsingnio", "copyFromFileToFileUsingNetIO", "copyFromFileToFileWithFileIO", "copyFromFileToFileUsingFileIO", "copyFromFileToFileUsingNetio", "copyFromFileToFileUsingNetFile", "copyFromFileToFileUsingFileFile", "copyFromFileToFileUsingnChannel"], "inputFile": [" inputfile", "InputFile", "sourceDir", "imagefile", "imageFile", "InputDirectory", " inputDir", "sourceDirectory", "inputDir", " inputDirectory", "inputDirectory", "InputStream", " inputStream", "outputStream", "inputfile", "outputfile", "inputStream", "sourceStream", "InputDir", "sourceFile", "imageStream", "imageChannel"], "outputFile": ["OutputStream", "outputPath", " outputfile", "targetfile", "outputDirectory", " outputStream", "targetDirectory", "inputDirectory", " outputFiles", "targetFiles", "inputPath", "targetFile", "Outputfile", "outputStream", "outputfile", " outputDirectory", "targetPath", "OutputFile", "inputStream", "OutputFiles", "targetStream", "outputFiles", " outputPath"], "inputChannel": ["InputFile", "httpChan", "httpChannel", "InputChannel", "Inputchannel", "httpCh", "inputChan", " inputchannel", "outputListener", " inputSocket", "outputchannel", "httpSocket", "inputSocket", "parentChannel", " inputChan", "InputSocket", "InputStream", "parentSocket", " inputStream", "outputCh", "outputStream", "InputListener", "parentFile", " inputListener", "inputStream", "InputChan", "parentChan", "outputChan", "InputCh", "inputCh", "outputSocket", "inputListener", "parentStream", "inputchannel"], "outputChannel": ["outSocket", "OutputStream", "outputConnection", "inputChan", "inputConnection", " outputStream", "OutputChan", "outputStream", "OutputConnection", " outputChan", "OutputSocket", "outChannel", "OutputFile", " outputConnection", "inputStream", "OutputChannel", " outputSocket", "outChan", "outputChan", "outStream", "outputSocket"]}}
{"id1": "5274228", "id2": "23517481", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"put": ["create", "cache", "output", "client", "parse", "st", "Put", "update", "PUT", "build", "data", "resource", "format", "transform", "add", "UT", "transfer", "post", "operation", "string", "patch", "write", "submit", "replace", "file", "pull", "get"], "resourceID": ["serviceIDs", "responseKey", "resourceId", "serviceId", "objectIDs", "ResourceURL", "responseID", "responseURL", "objectId", "resourceid", "resourceURL", "objectid", "resourceIDs", "resourceKey", "ResourceID", "responseId", "Resourceid", "requestId", "ResourceId", "objectID", "ResourceKey", "serviceID", "requestURL", "serviceid", "requestID", "ResourceIDs", "requestKey"], "headersMap": [" headersFile", "httpMap", "httpSet", "headersSet", "ersFile", "headersFile", "headerSet", "httpArray", "httpList", " headersSet", "headerList", "headerFile", "headerMap", "ersArray", "headerArray", "ersMap", "ersList"], "httpClient": ["HttpClient", "httpsClient", "ttpClient", "httpContext", " httpContext", "phpCall", "httpConnection", "httpsPut", " httpCall", "ttpConnection", "httpsBase", "HttpContext", " httpConnection", "httpServer", "httpsConnection", "HttpPut", "httpCall", "httpsServer", "httpCase", "httpBase", "ttpPut", "HttpServer", "HttpCase", "phpClient", " httpCase", " httpBase", "phpCase", "ttpBase", "HttpCall", " httpServer", "httpsContext", "phpPut"], "httpPut": ["HttpClient", "HttpPush", "phpPush", "phpSplit", "httpsClient", "phpGet", "viewPUT", " httpGet", "viewPut", " httpPUT", "phpAdd", " httpWrite", "httpsPut", "httpsPUT", "httpDo", "webPush", "httpGet", "httpsSplit", "webPut", "httpSplit", "httpPush", "httpsAdd", "HttpDo", "HttpPut", "internalPut", " httpAdd", "Httpput", "httpWrite", "internalGet", "internalPush", "httpput", "internalWrite", " httpPush", "httpAdd", "phpWrite", "webPUT", "httpsPush", "HttpPUT", "HttpGet", "httpsput", "httpPUT", "viewPush", "httpsGet", "viewput", " httpSplit", " httpDo", "httpsDo", "webGet", "phpPut"], "headersList": ["driversMap", " headersL", "headersSet", "ersL", "headerSet", " headersSet", "driversL", "headerList", "headerMap", "ersArray", "headerArray", "driversArray", "ersList", "headersL", "headerL", "driversList", "ersSet"], "iterator": ["vector", "sequence", "init", "set", "starter", "inner", "basic", "finder", "instance", "ter", "driver", "processor", "ie", "pointer", "gener", "loader", "walker", "writer", "done", "started", "later", "multi", "operator", "division", "next", "Iterator", "interstitial", "runner", "outer", "random", "Iter", "ator", "append", "li", "former", "size", "handler", "engine", "stream", "kick", "parser", "iter", "creator", "eni", "loop", "collection", "start", "step", "slice", "entry", "end", "reader", "inter", "oper", "ski", "adder"], "headersArray": ["filesAr", "headsList", "filesArray", "headsLength", "ersAr", " headersAr", "hersAr", "filesMap", " headersHash", "headsArray", "headersLength", " headersLength", "ersArray", "hersList", "ersMap", "hersArray", "filesHash", "headersHash", "ersHash", "hersLength", "headsAr", "headersAr"], "fields": ["FIELD", "types", "lines", "json", "field", "keys", "dates", "data", "errors", "format", "values", "params", "files", "zip", "body", "region", "prefix", "codes", "details", "Field", "properties", "dir", "comments", "pattern", "rows", "content"], "occiHeaders": ["occiBuilders", "occiBuilderers", "ocsiHeadlers", "ocsiBufflers", "occiHostlers", "occiBuffers", "ocsiHeaders", "occiHoster", "occiBuffer", "ocsiHeader", "ocsiBuffer", "occiBufflers", "occiHosterers", "occiHeader", "occiHeadlers", "occiHeaderers", "occiBuilder", "ocsiHeaderers", "ocsiBufferers", "occiBufferers", "occiHosters", "occiBuildlers", "ocsiBuffers"], "H": ["Hop", "F", "J", "HC", "L", "HT", "Header", "Length", "HR", "HS", "HTTP", "TH", "M", "I", "SH", "N", "B", "OH", "NH", "G", "W", "X", "C", "Index", "HH", "R", "DH", "HE", "HM", "T", "EH", "V", "ID", "HI", "K", "MH", "D", "Q", "Handler", "CH", "HB", "Y", "U", "S", "rh", "P", "Head"], "header": ["message", "bridge", "result", "buffer", "token", "Header", "feature", "cover", "inner", "frame", "f", "info", "back", "head", "ter", "event", "extra", "cher", "driver", "per", "ler", "ker", "manager", " request", "writer", "definition", "service", "consumer", "builder", "metadata", "later", "comment", "document", "outer", "server", "player", "dr", "string", "rule", "holder", "former", "detail", "handler", "layer", "second", "block", "value", "file", "request", "row", "key", "er", "response", "her", "entry", "reader", "liner", "http"], "statusLine": ["responseLine", "statusBody", "StatusLine", "statusFile", "StatusText", "StatusFile", "StatusString", " statusBody", " statusText", " statusString", "StatusCode", "responseFile", "responseText", "StatusBody", " statusFile", "errorLine", "statusString", "statusText", "errorCode", "errorBody", "responseCode", "errorString"], "httpResponse": ["Httpresponse", "httpresponse", "HttpEnvironment", "ttpResult", " httpPage", "HttpBlock", "statusBody", " httpEnvironment", "statusResponse", "httpResp", "HttpBody", "statusResult", "actualResponse", " httpResult", "httpsRequest", " httpBody", "actualresponse", "actualLine", "HttpLine", "httpBlock", "ttpResponse", "HttpStatus", " httpResp", "httpPage", "httpsPage", "httpsResponse", " httpStatus", "statusBlock", " httpRequest", " httpLine", "ttpResp", "httpResult", "HttpResponse", "templateResponse", "HttpPage", "httpRequest", "templateLine", "httpLine", "httpsEnvironment", "actualRequest", "httpStatus", "httpsBody", "httpEnvironment", " httpresponse", "HttpResp", "httpsResult", "HttpResult", "httpBody", "ttpRequest", "HttpRequest", "templateStatus", " httpBlock", "templateResp"], "statusCode": [" statusType", "StatusCount", "responseLine", " statuscode", "StatusLine", "errorType", "StatusType", "StatusData", "StatusText", "statusData", " StatusLine", " statusCount", "responseType", "StatusCode", "resultcode", "responseText", " StatusData", "statuscode", "errorText", "resultCode", "statusType", " StatusCode", "statusCount", "errorLine", "resultCount", " StatusType", "statusText", "resultLine", " statusData", "errorCode", "responseCode", "Statuscode"]}}
{"id1": "2642914", "id2": "3806532", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGarz", "addFileToZipGzi", "addFileToZipGarzip", "addFileToTarGarx", "addFileToTarGgz", "addFileToZipGzip", "addFileToTarGszip", "addFileToZipGszi", "addFileToZipGszip", "addFileToZipGsz", "addFileToTargz", "addFileToTargzip", "addFileToTargzi", "addFileToZipGgz", "addFileToTarGuzi", "addFileToTarGuz", "addFileToTarGarzip", "addFileToZipGarx", "addFileToTarGszi", "addFileToZipGz", "addFileToTarGsgz", "addFileToZipGsgz", "addFileToTarGzi", "addFileToTarGzip", "addFileToTarggz", "addFileToZipGarzi", "addFileToZipGx", "addFileToTarGarzi", "addFileToTarGuzip", "addFileToTarGsz", "addFileToTarGux", "addFileToTargx", "addFileToTarGx", "addFileToTarGargz", "addFileToZipGarz"], "taro": ["targo", "Tabo", " tabo", "Tara", "taron", "Too", "atargo", "ptabo", "tamar", "stoo", "laro", "Taron", "Toran", "stero", "largo", "lro", " tara", " tero", "ataro", "Tamar", "too", " taron", "storo", " taco", "Toro", "Tero", "thaco", "ptargo", "tabo", "ptaron", "stamar", "thamar", "Taro", "faro", "atro", "tro", "atoran", "toran", "staro", "Taco", "loran", " too", "staco", "Tro", " tro", "fargo", "tara", "taco", "ptaco", "ptaro", "tharo", "thoro", "fara", "toro", "Targo", "tero", "stro", "faco", " targo"], "path": ["p", "text", "source", "ref", "filename", "cache", "uri", "str", "Path", "c", "PATH", "ath", "pointer", "root", "image", "loc", "data", "folder", "object", "location", "from", "resource", "directory", "url", "name", "log", "string", "fn", "file", "route", "key", "dir", "id", "type", "parent", "pattern"], "base": ["p", "pre", "buffer", "Base", "cache", "uri", "absolute", "home", "store", "back", "bas", "extra", "root", "ase", "area", "default", "from", "resource", "bf", "core", "url", "name", "b", "server", "relative", "address", "api", "index", "string", "prefix", "file", "part", "key", "dir", "id", "site", "type", "parent", "start", "http"], "f": ["p", "form", "lf", "F", "flat", "ref", "of", "fp", "fx", "cf", "c", "fb", "s", "this", "w", "e", "i", "l", "found", "m", "aff", "framework", "fen", "af", "bf", "self", "n", "g", "url", "inf", "fo", "b", "fd", "fac", "fs", "fe", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "file", "df", "r", "t", "feed", "sf", "fold", "v", "d", "raf"], "entryName": ["entrySize", "resourcePath", "archiveSize", " entryPath", "resourceName", "filePath", "EntryTime", "fileType", "fileTime", " entrySize", " entryType", "resourcename", "EntryName", "elementName", "elementPath", "EntryPath", "entryname", "resourceSize", "archiveName", "fileName", "entryTime", "EntryType", "entryType", " entryTime", "elementTime", " entryname", "archivename", "archivePath", "entryPath", "elementType"], "goIn": ["coIns", "poIN", "Goin", "GOIN", "goIN", "poin", "GOIn", "gain", "poIns", "loIn", "goOut", "GoIns", "GOOut", "loIN", "poIn", "poOut", "loin", "GoIn", "gaIns", "coOut", "coin", "coIn", "GOIns", "GoIN", "goin", "loIns", "gaIn", "goIns", "gaIN", "GOin"], "tarEntry": ["rarInfo", "tarInfo", " Tarentry", "rarEntry", "zipEnt", "tarEnt", " tarentry", "rarFile", "Tarentry", " tarElement", " tarEnt", "TarElement", "tarentry", " TarElement", "tarElement", "rarEnt", " tarFile", "tarFile", " TarEntry", "TarEntry", " tarInfo", "zipEntry", "zipFile", "zipInfo"], "children": ["ren", "words", "current", "output", "jobs", "father", "kids", "well", "all", "iblings", "scenes", "Children", "ools", "balls", "loc", "data", "web", "parents", "other", "open", "which", "many", "opens", "values", "name", "files", "pool", "sub", "members", "each", "bars", "ales", "ins", "h", "rows", "far", "pages", "blocks", "ul", "plugins", "when", "feed", "pes", "ports", "parent", "packages", "roots", "content"], "child": ["kid", "cloud", "hel", "client", "c", "leaf", "page", "slave", "per", "i", "root", "l", "draft", "count", "cel", "or", "Child", "build", "data", "in", "comment", "shell", "and", "job", "name", "server", "code", "pool", "ch", "connection", "channel", "layer", "file", "lib", "pull", "row", "key", "feed", "entry", "id", "parent"]}}
{"id1": "19810820", "id2": "3024970", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFileStream", "copyDirectoryStream", "copyStreamChannel", "copyfileChan", "transferfileChan", "copyStreamStream", "transferfilechannel", "copyFileChan", "copyfileStream", "copyfilechannel", "transferFileStream", "copyfileChannel", "transferFileChannel", "copyDirectoryChannel", "transferfileStream", "copyStreamchannel", "copyStreamChan", "transferFilechannel", "copyDirectorychannel", "copyDirectoryChan", "transferfileChannel", "copyFilechannel", "transferFileChan"], "src": ["ls", "source", "filename", "sb", "lower", "sync", "st", "client", "path", "download", "config", "s", "input", "conn", "inst", "sin", "SOURCE", "func", "rest", "loc", "RC", "sys", "Source", "rs", "img", "dest", "sth", "sup", "url", "ses", "tmp", "b", "server", "sit", "sel", "sub", "sc", "sl", "dist", "scene", "rc", "rb", "cur", "upload", "stream", "sq", "ruby", "ssl", "slice", "ctx", "start"], "dst": [" dST", "blt", "tlt", "ldST", "stST", "DST", "dost", " ddest", "brc", "fdput", "Dst", " dost", "bst", "adST", "fdrc", "adst", "tST", "adrc", "tst", "bput", "Dost", "ddest", "adput", "dart", "dput", "stlt", "Ddest", "ldst", "fdst", "dST", "bart", "dlt", "tart", "bST", "drc", "fdST", "start", "ldost", "lddest", "stst"], "preserveModificationTime": ["preserveModifyingtime", "preserveModifiedTime", "preserveModifyTime", "preserveMinifiedFile", "preserveMinificationtime", "preserveModifyingFile", "preserveMinifiedTime", "preserveModationtime", "preserveModifiedFile", "preserveModationTime", "preserveMinificationFile", "preserveModificationtime", "preserveModifyingTime", "preserveModifytime", "preserveModificationFile", "preserveMinificationTime", "preserveModationFile", "preserveModifiedtime", "preserveMinifiedtime"], "inputChannel": ["errorCache", "imageGate", "inputQueue", "requestChannel", "binarychannel", "InputChannel", "Inputchannel", "outputConsole", "outputConnection", "inputChan", " inputchannel", "binaryChannel", "requestCode", " inputSocket", "outputchannel", "fileChan", "requestChan", "inputConnection", " inputConsole", "inputSocket", "InputQueue", "outputCode", " inputChan", "inputGate", "outputQueue", "fileConsole", "InputSocket", " inputQueue", "binaryGate", "outputBuffer", " inputStream", " inputCache", "InputBuffer", "fileConnection", "inputConsole", "requestStream", "outputStream", "errorChannel", " inputConnection", "fileChannel", "outputGate", "imagechannel", "imageChan", "inputCode", "inputBuffer", "outputCache", "errorStream", "inputCache", "inputStream", "InputChan", "binaryChan", " inputCode", "errorChan", "outputChan", "outputSocket", " inputBuffer", "imageChannel", "inputchannel"], "outputChannel": ["Outputchannel", "OutputStream", "outputManager", "outchannel", "writeStream", " outputButton", "writeChan", "inputManager", "writeQueue", "inputChan", "outputchannel", " outputStream", "outputQueue", "OutputChan", "OutputQueue", "outButton", " outputQueue", "inputButton", "outputStream", " outputChan", " outputchannel", "writeManager", "outChannel", "inputStream", "writeChannel", "OutputChannel", "outChan", "outputChan", "outStream", "outputButton", " outputManager"], "length": ["sequence", "text", "form", "last", "style", "position", "result", "buffer", "current", "Length", "session", "available", "load", "with", "len", "head", "slave", "l", "max", "count", "complete", "build", "duration", "limit", "next", "base", "width", "number", "child", "delay", "size", "lock", "sum", "full", "block", "php", "value", "start", "pull", "partial", "part", "join", "id", "end", "type", "section", "offset", "volume"], "total": ["Total", "last", "result", "set", "current", "translation", "available", "all", "info", "len", "less", "i", "max", "count", "complete", "found", "duration", "done", "multi", "valid", "limit", "base", "toc", "otal", "cur", "size", "sum", "scale", "full", "always", "used", "failed", "part", "partial", "key", "id", "type", "start", "error", "offset", "no"]}}
{"id1": "5138455", "id2": "812803", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"save": ["create", "copy", "output", "parse", "load", "Save", "download", "store", "dump", "process", "clone", "transfer", "post", "split", "zip", "files", "append", "upload", "Copy", "write", "put", "file", "pack", "apply", "xml", "run"], "bytes": ["frames", "ls", "parts", "Bytes", "buffer", "words", "lines", "bits", "ips", "s", "its", "buf", "pointer", "services", "vals", "resources", "data", "bps", "binary", "values", "pins", "os", "objects", "files", "zip", "bs", "address", "rb", "gb", "codes", "outs", "es", "tes", "slice", "boot", "blocks"], "outputFile": ["targetJar", "outputPath", " outputfile", "outputDir", "targetfile", "inputFiles", "inputFile", "referenceDir", "inputDir", "responsefile", "inputF", "outputF", "outputDirectory", " outputFiles", "inputDirectory", "targetDir", "responseDir", "referencePath", "inputPath", "referenceFile", "targetFile", "responseFile", "referencefile", "inputfile", "outputfile", "outputJar", " outputDirectory", " outputDir", "OutputFile", "OutputF", " outputJar", "OutputDirectory", "OutputFiles", "responseJar", "outputFiles", " outputF", " outputPath"], "in": ["work", "source", "as", "init", "copy", "inn", "token", "pin", "inner", "c", "f", "s", "info", "pass", "i", "input", "inside", "inas", "image", "conn", "sin", "IN", "data", "m", "ini", "win", "con", "n", "up", "bin", "a", "isin", "base", "url", "b", "is", "exec", "nin", "ins", "connection", "cin", "In", "inc", "again", "rin", "file", "part", "r", "err", "login", "ssl", "id", "reader", "din"], "out": ["x", "call", "init", "as", "copy", "cache", "output", "sync", "client", "inner", "at", "f", "this", "w", "ex", "i", "socket", "conn", "image", "OUT", "outside", "writer", "object", "n", "up", "io", "a", "b", "null", "outer", "ext", "server", "exec", "post", "obj", "connection", "exp", "Out", "write", "In", "outs", "inc", "again", "file", "temp", "parent", "err", "op", "o", "user", "bin", "error"]}}
{"id1": "530882", "id2": "2668634", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "350482", "id2": "22338097", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doVersioncheck", "doReleaseWork", "doReleasecheck", "doVersionTest", " doReleaseTest", "doReleaseCheck", " doReleaseCheck", "doversionTest", "doVERSIONTest", " doBuildcheck", "doReleaseTest", "doVersioncheck", " doBuildTest", " doVersionWork", "doversioncheck", "doVERSIONCheck", "doBuildWork", " doReleasecheck", "doBuildCheck", "doVersionWork", "doVERSIONcheck", "doBuildTest", " doBuildWork", "doversionCheck", " doVersionTest", " doBuildCheck", "doVERSIONWork", "doBuildcheck"], "view": ["form", "edit", "style", "app", "buffer", "cache", "widget", "port", "out", "client", "session", "cell", "update", "config", "this", "model", "View", "page", "event", "show", "e", "use", "gui", "input", "l", "image", "screen", "box", "q", "VIEW", "object", "comment", "self", "accept", "window", "display", "server", "change", "sel", "ui", "body", "see", "vis", "div", "lock", "views", "gu", "el", "full", "block", "html", "request", "row", "layout", "reader", "v", "can", "http"], "url": ["source", "buffer", "uri", "browser", "client", "path", "Url", "f", "bb", "input", "l", "socket", "image", "build", "blog", "loader", "web", "service", "resource", "open", "hub", "base", "log", "bel", "server", "host", "URL", "zip", "sl", "address", "string", "connection", "channel", "stream", "ll", "file", "lib", "ssl", "ob", "user", "http"], "in": ["source", "as", "init", "buffer", "gin", "inn", "out", "inner", "ac", "s", "i", "input", "socket", "sin", "IN", "data", "ini", "win", "con", "resource", "binary", "n", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "rin", "file", "login", "reader", "bis", "din"], "bin": ["init", "ln", "buffer", "inn", "gin", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "inline", "IN", "abi", "data", "loader", "win", "record", "con", "binary", "bot", "bi", "log", "b", "bn", "fin", "nb", "body", "lock", "cin", "lin", "spin", "ruby", "file", "kin", "lib", "part", "oin", "reader", "din", "run"], "line": ["text", "source", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "cell", "day", "load", "lo", "home", "model", "page", "pass", "link", "e", "i", "word", "l", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "valid", "base", "name", "log", "b", "lc", "job", "pe", "band", "code", "ge", "split", "letter", "string", "rule", "LINE", "el", "lin", "cl", "layer", "ine", "block", "file", "part", "row", "key", "non", "entry", "end", "le", "unit", "site", "id", "no"], "develBuild": ["deployBuild", "develBuilder", "dewardbuild", "deployBuilt", "DEvelbuild", "dewardBuilder", "desvenRun", "DEvelBuilt", "desvenBuilder", "deviousBuild", "desvelbuild", "desvelBuilder", "deVELRun", "desvelRun", "deVELBuilder", "devenBuild", "develbuild", "desvelBuild", "deVELbuild", "develRun", "desvenRelease", "DEvelBuild", "deployBuilder", "devenBuilder", "develRelease", "desvelBuilt", "deelRelease", "DEVELBuilt", "deployRun", "dellBuild", "dewardBuild", "dewardBuilt", "devenbuild", "DEVELBuilder", "desvenbuild", "dellRun", "DEVELBuild", "DEvelBuilder", "deelBuilder", "dellBuilder", "desvenBuild", "DEVELbuild", "develBuilt", "desvenBuilt", "deviousbuild", "devenBuilt", "deelBuild", "deVELBuild", "devenRun", "deelRun", "dellRelease", "deviousBuilt", "deVELBuilt", "desvelRelease", "devenRelease", "deploybuild"], "stableBuild": ["basebuild", "latestBuilder", "stablebuild", "compatibleBuild", "latestbuild", "prettyBuilder", "stableVersion", "validBuilder", "securebuild", "prettybuild", "latestBuild", "compatibleBuilder", "baseBuild", "secureBuild", "compatiblebuild", "secureBuilder", "stableBuilder", "validBuild", " stablebuild", " stableVersion", "staticbuild", "validbuild", " stableBuilder", "baseVersion", "prettyVersion", "prettyBuild", "staticBuild", "baseBuilder", "staticBuilder"]}}
{"id1": "19235551", "id2": "8801182", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"handleFCLAException": [" handlePCL1", " handleFCLAError", " handlePCLAError", " handlePCLception", " handleFCLException", " handlePCLException", " handleFCLception", " handleFCLAception", " handleFCLA1", " handlePCLAception", " handleFCMAError", " handleFCAException", " handleFCMAception", " handlePCLError", " handleFCMA1", " handleFCAception", " handleFCLError", " handleFCA1", " handleFCL1", " handlePCLAException", " handleFCMAException", " handleFCAError", " handlePCLA1"], "params": ["source", "video", "cache", "json", "parse", "config", "s", "param", "options", "pos", "image", "global", "core", "base", "spec", "css", "temp", "es", "phys", "type", "same", "images", "http", "as", "result", "ps", "words", "styles", "model", "i", "resources", "data", "names", "module", "rs", "vm", "files", "members", "res", "api", "models", "tags", "points", "plugin", "settings", "plugins", "site", "posts", "ls", "parts", "rules", "media", "photos", "master", "errors", "external", "details", "Parameters", "changes", "results", "status", "relations", "types", "eps", "apps", "services", "manager", "vs", "database", "pins", "series", "server", "ams", "features", "list", "request", "ops"], "uri": ["source", "message", "nexus", "remote", "git", "containing", "domain", "image", "uin", "location", "metadata", "directory", "core", "picture", "direction", "general", "distance", "slice", "type", "wiki", "http", "volume", "mode", "component", "i", "ini", "module", "binary", "force", "multi", "io", "verb", "api", "pi", "future", "plugin", "eni", "cli", "doi", "URI", "id", "site", "unit", "sequence", "course", "path", "license", "tile", "link", "folder", "resource", "description", "theme", "mi", "prefix", "detail", "oid", "version", "href", "response", "ri", "uni", "filename", "username", "gi", "archive", "ori", "title", "menu", "duration", "service", "nuclear", "database", "server", "transfer", "ui", "query", "address", "iri", "origin", "umi", "route"], "url": ["source", "client", "browser", "path", "Url", "config", "system", "page", "link", "control", "l", "conn", "image", "loc", "web", "object", "resource", "location", "open", "proxy", "director", "base", "window", "server", "URL", "sl", "li", "string", "channel", "layer", "plugin", "file", "ssl", "id", "user", "orb", "target", "http"], "connection": ["relation", "result", "client", "connected", "c", "config", "Connection", "i", "control", "socket", "conn", "image", "application", "condition", "data", "con", "service", "object", "resource", "open", "proxy", "close", "communication", "io", "connect", "document", "character", "database", "server", "body", "string", "channel", "handler", "response", "ion", "section", "db", "context", "http"]}}
{"id1": "17974661", "id2": "7458833", "code1": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"requestServerModifications": ["requestClientModurations", "requestServerMutification", "requestClientModifications", "requestServermodifications", "requestClientmodifies", "requestClientmodifications", "requestServerModification", "requestServermodifies", "requestServerMutifications", "requestClientmodification", "requestClientModification", "requestServerModurations", "requestClientmodurations", "requestServermodification", "requestServermodurations", "requestServerModifies", "requestServerMutifies", "requestServerMuturations", "requestClientModifies"], "sessionId": [" sessionid", " sessionKey", "connectionID", "connectionKey", "connectionId", "essionKey", "connectionid", " sessionInfo", "connectionName", "SessionInfo", "Sessionid", " sessionID", "sessionID", "connectionInfo", "sessionid", "sessionName", "sessionKey", "sessionInfo", "essionName", "essionID", "SessionID", "SessionId", "essionId", " sessionName"], "out": ["remote", "buffer", "result", "cache", "output", "path", "session", "flush", "config", "timeout", "ex", "socket", "OUT", "conn", "image", "data", "writer", "in", "object", "resource", "io", "url", "log", "name", "server", "exec", "external", "lock", "Out", "write", "outs", "again", "file", "err", "o", "user", "parent", "report", "content"], "client": ["call", "app", "uri", "Client", "session", "c", "config", "https", "driver", "per", "socket", "conn", "bird", "con", "web", "service", "proxy", "ce", "resource", "self", "io", "connect", "url", "base", "server", "host", "api", "connection", "channel", "handler", "php", "request", "cli", "ssl", "http"], "builder": ["Builder", "message", "result", "buffer", "sb", "uri", "str", "length", "path", "info", "built", "image", "xml", "build", "writer", "object", "bean", "url", "base", "log", "b", "array", "runner", "building", "letter", "api", "address", "string", "prefix", "orb", "filter", "parser", "request", "row", "r", "door", "keeper", "reader", "v", "db", "builders", "http"], "method": ["message", "call", "METHOD", "path", "session", "invoke", "instance", "ter", "event", "use", "view", "trip", "send", "build", "process", "data", "service", "module", "resource", "url", "job", "name", "server", "function", "operation", "api", "connection", "string", "stream", "plugin", "wrapper", "request", "pull", "r", "end", "user", "Method", "type", "http"], "response": ["message", "relation", "result", "output", "json", "session", "page", "view", "success", "serv", "image", "default", "application", "resp", "data", "found", "service", "object", "resource", "reply", "document", "next", "server", "Response", "function", "res", "body", "index", "onse", "connection", "respond", "ception", "stream", "full", "received", "value", "version", "request", "wave", "results", "feed", "site", "entry", "error", "report", "status", "http"], "header": ["message", "cookie", "result", "buffer", "forward", "token", "Header", "port", "cover", "inner", "field", "info", "head", "event", "param", " Header", "manager", "line", "data", "writer", "metadata", "director", "prev", "document", "url", "name", "hr", "server", "host", "number", "body", "dr", "h", "string", "connection", "holder", "handler", "layer", "second", "block", "value", "attribute", "version", "request", "headers", "key", "er", "her", "entry", "err", "error", "status", "content"], "code": [" status", "x", "message", "CE", "last", "call", "result", "mode", "ode", "re", "length", "c", "f", "back", "charge", "state", "success", "level", "e", "ie", "de", "one", "count", "line", "complete", "none", "ose", "close", "age", "ce", "reply", "done", "ec", "be", "ide", "expected", "name", "reason", "change", "ge", "zip", "number", "Code", "see", "scene", "rule", "codes", "cause", "score", "go", "cod", "xx", "key", "id", "rate", "type", "zone", "error", "ception", "co", "status", "coded"], "expectedLength": ["expectedSize", "actualSize", "pectedlength", " expectedSize", " expectedlength", " expectedLen", "actualLength", "actuallength", "pectedLength", "actualLen", "expectedlength", "expectedLen", "pectedLen", "pectedSize"], "is": ["x", "as", "ris", "uri", "IS", "im", "isa", "us", "was", "set", "mark", "ire", "s", "info", "ii", "its", "not", "are", "iss", "i", "Is", "serv", "ri", "ci", "iso", "data", "in", "lis", "ws", "ip", "io", "error", "si", "name", "ms", "os", "params", "isc", "fs", "bs", "isl", "res", "isi", "ins", "stream", "ais", "ios", "ish", "_", "es", "iris", "key", "non", "id", "bis", "js", "select", "status", "ops"]}}
{"id1": "10218878", "id2": "5414088", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFileFile", "DecodeMapfile", "DecodemapFile", "DecodeFileFiles", "DecodeFilefile", "DecodeDataFiles", "DecoderMapFiles", "DecodemapFiles", "DecoderFileFile", "Decodemapfile", "DecoderMapFile", "DecoderFileFiles", "DecoderFilefile", "DecodeDataFile", "DecodeMapFiles", "DecodeDatafile", "DecoderMapfile"], "mapFile": ["addressFull", "MapLog", "loadfile", "batchUrl", "loadFull", "fileFile", "mapFull", "MapUrl", "mapfile", "MapFile", "mapLog", "loadTable", "filefile", "apperUrl", "addressTable", "fileTable", "apperLog", "loadFile", "mapTable", "addressfile", "mapUrl", "batchFile", "fileFull", "batchLog", "addressFile", "apperFile"], "outputFile": ["OutputStream", " outputfile", "outputDir", "inputFiles", "inputFile", "responseStream", "inputFolder", "inputDir", "responsefile", "responseFiles", " outputStream", " outputFiles", "outputFolder", "Outputfile", "responseFile", "outputStream", "OutputDir", "outputfile", " outputDir", "OutputFile", "OutputFiles", "OutputFolder", "outputFiles", " outputFolder"], "magicKey": ["MagicKey", "magicLink", "specialkey", "specialSecret", " magicK", "magicSecret", "prefixLink", "MagicLetter", "cacheKey", "cacheChar", " magicSecret", " magicLink", "Magickey", "magicK", " magickey", " specialKey", "prefixKey", " specialkey", "specialKey", " specialLetter", "cachekey", "techLink", " magicKEY", "magickey", " specialK", "cacheSecret", "prefixKEY", " magicChar", "techkey", "techKEY", "magicChar", "specialChar", "MagicK", "magicLetter", "magicKEY", "techKey", "prefixkey", " magicLetter"], "buffer": ["source", "message", "shape", "position", "cache", "result", "token", "bar", "length", "memory", "pad", "buff", "bb", "buf", "seed", "input", "uffer", "count", "read", "FFER", "data", "writer", "binary", "comment", "document", "url", "base", "array", "b", "null", "code", "transfer", "address", "Buffer", "variable", "header", "stack", "queue", "layer", "batch", "reference", "iter", "pause", "row", "wave", "feed", "slice", "reader", "offset"], "nread": ["nreads", "Nload", "Nfind", " nRead", "pload", "NRead", "Nread", " nload", "enreads", "nwrite", "enwrite", " nwrite", "enread", "pread", "nereader", "nfind", "neread", "neRead", "nload", "enfind", "nreader", "newrite", "pRead", "Nreader", "pwrite", "Nreads", " nfind", "nRead", "enRead", "Nwrite", " nreads", " nreader"], "map": ["work", "pre", "source", "flow", "group", "make", "message", "create", "app", "bridge", "copy", "cache", "media", "out", "parse", "client", "apper", "cover", "config", "pad", "use", "master", "per", "one", "input", "image", "m", "data", "module", "resource", "MAP", "open", "core", "code", "pool", "transfer", "address", "index", "list", "header", "lock", "over", "stream", "cm", "layer", "ap", "write", "block", "file", "wave", "pack", "key", "maps", "pair"], "output": ["flow", "cut", "cache", "out", "update", "config", "model", "page", "control", "console", "input", "image", "global", "pot", "data", "web", "module", "object", "other", "resource", "export", "core", "document", "log", "ou", "outer", "utils", "function", "operation", "address", "number", "connection", "external", "exit", "queue", "layer", "write", "reference", "Output", "sort", "put", "file", "office", "ilo", "response", "o", "unit", "oper", "error", "target", "run", "application"], "i": ["p", "x", "uri", "length", "z", "c", "f", "ai", "gi", "ii", "info", "e", "l", "I", "ci", "uli", "m", "ini", "in", "multi", "ip", "io", "bi", "a", "si", "u", "b", "it", "ui", "pi", "oi", "ji", "li", "j", "di", "qi", "xi", "t", "mu", "slice", "id", "o", "zi", "v", "ri", "ti", "phi"]}}
{"id1": "3252116", "id2": "14619453", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMAC5", "getMAC3", "getMD4", "getSHA3", "getMP512", "getSHA4", "getSHA512", "getMP3", " getSHA4", " getSHA5", "getMP4", "getMP5", "getMAC512", " getMD3", "getMD512", "getMAC4", " getMD512", "getMD3", " getSHA512", "getSHA5", " getMD4", " getSHA3"], "source": ["text", "secret", "buffer", "result", "output", "uri", "fp", "config", "f", "this", "e", "input", "src", "ource", "SOURCE", "data", "Source", "service", "object", "from", "resource", "dest", "document", "url", "base", "security", "code", "password", "sl", "body", "sp", "string", "connection", "stream", "file", "slice", "parent", "target", "content"], "s": ["p", "ls", "sb", "ps", "ts", "ss", "ends", "f", "its", "als", "sym", "bytes", "e", "sg", "services", "ds", "m", "strings", "rs", "ws", "n", "g", "si", "ses", "b", "os", "series", "is", "fs", "sl", "string", "h", "ins", "gs", "ings", "sets", "ns", "es", "t", "r", "results", "ssl", "S", "bis", "js", "d", "rows", "ops"], "hexDigits": ["hashDigists", "hexdigings", "hexdigites", "hexSignit", "hexdigit", "hexdigals", "hexDigals", "hexDigists", "hashFormits", "tempSignites", "hexEdits", "hexSignists", "hexSignites", "hexdigats", "tempDigists", "hexDigitives", " hexDigings", "hexdigists", "hashFormists", "hexEdists", "hexdigitives", "hexFormists", "hashDigats", "hexFormitives", "hexSignits", "hexSignals", "hexFormits", "hexDigites", "hexSignats", "tempDigals", "hexEdites", "hexDigings", "hexdigits", " hexDigases", "hashDigitives", "hexdigases", "tempSignals", "tempSignists", "tempDigites", "tempSignits", "hexDigases", "hexSignitives", "hashFormats", "hexFormats", "hexDigit", "hashDigits", "hexSignases", "hexDigats", "hexEdals", "hashFormitives", "hexSignings", " hexDigit", "tempDigits"], "md": ["mand", "mm", "mp", "amd", "f", "dc", "wd", "dig", "cmd", "dm", "mb", "meta", "mg", "m", "nm", "mad", "metadata", "mac", "bf", "em", "rm", "sm", "vd", "um", "pd", "sha", " MD", "mi", "di", "dd", "cm", "mt", "hd", "cd", "am", "MD", "mc", "ma", "df", "mu", "mag", "pm", "rpm", "bd", "mail"], "tmp": ["p", "stuff", "pre", "app", "buffer", "mp", " temp", "config", "np", "pad", "fb", "buf", "buff", "extra", "seed", "wp", "txt", "pointer", "area", "ppo", "meta", "data", "bp", "storage", "img", "dest", "sup", "base", "bt", "array", "proc", "params", "obj", "api", "append", "sp", "rb", "now", "cpp", "test", "temp", "pp", "v", "cb", "cmp"], "str": ["text", "char", "style", "cs", "arr", "ss", "st", "dict", "dec", "br", "inner", "Str", "txt", "pos", "STR", "stri", "data", " substr", "sr", "sec", "spec", " sp", "hr", "code", "obj", "cr", "exec", "sl", "hex", "sp", "dr", "j", "string", "exp", "cur", "div", "fr", "enc", "pr", "ctr", "iter", "tr", "temp", "part", "r", "err", "unit", "v", "doc"], "k": ["p", "x", "work", "kid", "ku", "c", "f", "mk", "w", "e", "ko", "ek", "q", "kk", "kw", "n", "g", "ks", "b", "u", "ch", "ki", "j", "sk", "kick", "K", "ok", "dk", "ak", "y", "key", "id", "unk", "ck", "o", "v", "kat", "d"], "i": ["p", "x", "uri", "z", "c", "shift", "f", "ai", "gi", "ii", "info", "e", "l", "I", "ci", "abi", "m", "in", "chi", "ini", "multi", "ip", "iu", "n", "io", "a", "si", "bi", "u", "b", "ti", "it", "ui", "pi", "oi", "ji", "j", "li", "index", "hi", "di", "qi", "y", "xi", "t", "mu", "v", "ri", "d", "phi"], "byte0": ["byte1", "byte2", " byte00", "number5", "numberk", "number1", "word5", "bytek", "word1", "letter2", "pixel2", "letter00", " byte2", "pixel6", "number0", "pixel00", "byte6", "byte5", "word0", "byte00", "pixelk", "number00", "word2", "letterk", "pixel5", " byte5", " byte6", "letter0", "pixel0", "number2", "number6", " byte1"]}}
{"id1": "21656668", "id2": "6188784", "code1": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyResourceToFile": ["copyResourcesToResource", "copyResource2Files", "copyResourcesFromFile", "copyResourceToFiles", "copyResourcesToFile", "copyResourceAsResource", "copyResourceAsFolder", "copyResource2File", "copyResourceToResource", "copyResourcesToFolder", "copyResourceAsFiles", "copyResourceFromFolder", "copyResourceFromFiles", "copyResourcesFromFolder", "copyResourcesFromFiles", "copyResourceAsFile", "copyResource2Resource", "copyResourceToFolder", "copyResource2Folder", "copyResourcesFromResource", "copyResourcesToFiles", "copyResourceFromFile", "copyResourceFromResource"], "resourceFilename": ["resourcePath", "requestString", "resourceSourceFile", "resourcefilename", "sourceSourceFile", "requestfilename", "sourceString", " resourceSourceFile", "resourceFile", "ResourceString", "ResourceFile", " resourcefilename", "requestFilename", "resourceString", " resourceString", "sourceFilename", " resourcePath", "ResourceFilename", " resourceFile", "Resourcefilename", "ResourceSourceFile", "requestPath", "sourceFile", "ResourcePath"], "destinationFilename": ["destinatorModule", "DestificationThumbnail", "destinationFile", "destarationFile", "destationFile", "destignmentFile", "DestificationFilename", "destignmentThumbnail", "destationModule", "DestificationFile", "DestificationModule", "destinatorSourceFile", "destationFilename", "destinatorFilename", "destinationThumbnail", "DestificationSourceFile", "destificationSourceFile", "destationSourceFile", "destificationThumbnail", "DestinationSourceFile", "destinationModule", "DestinationThumbnail", "destificationFile", "destificationModule", "destarationThumbnail", "destarationFilename", "destignmentFilename", "DestinationFile", "destificationFilename", "destinatorFile", "DestinationModule", "DestinationFilename", "destinationSourceFile"], "inStream": [" instream", "binStream", "outstream", "inSt", "outFile", "binStreamer", "ninStreamer", " inCh", "outSt", "outCh", "INstream", "INStream", "inputstream", "inStreamer", "inSteam", "inCh", "instream", "ninSteam", "binstream", " inFile", "outStreamer", "INFile", "inputStreamer", "inFile", " inSt", "outSteam", "inputSteam", "inputStream", " inSteam", " inStreamer", "inputSt", "inputCh", "binSteam", "ninstream", "INStreamer", "ninStream", "INSteam"], "outStream": ["oneStreamer", "outPath", " outstream", "oneStream", "outstream", "outFile", "OutPath", "againSteam", "outputStreamer", "OUTSteam", "outputSteam", " outSteam", "againDirectory", "againStreamer", "Outstream", "OUTStreamer", "inPath", "inputDirectory", "OutSteam", "inStreamer", "instream", "inSteam", "outDirectory", " outFile", "outputStream", "oneSteam", " outStreamer", "outStreamer", "OUTFile", "inFile", "inputStreamer", "OutStream", "outputstream", "outSteam", "inputSteam", "inputStream", "workStreamer", "workStream", "oneDirectory", " outPath", "workstream", "againStream", "againstream", "workSteam", "OUTStream"]}}
{"id1": "19584877", "id2": "16142024", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToFiles", "encodeStringToFile", "encodeFileFromString", "encodeFileToStream", "encodeFileToString", "encodeFileFromStream", "encodeString2String", "encodeFile2File", "encodeFile2String", "encodeFiletoFiles", "encodeStringToStream", "encodeFileToFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeString2Stream", "encodeFile2Stream", "encodeFile2Files", "encodeFiletoFile", "encodeStringToString", "encodeFiletoString", "encodeString2File", "encodeFileFromFiles", "encodeString2Files"], "infile": ["infp", "outFile", "inputFile", "infiles", "InFile", "outfiles", "outfilename", "inputfile", " infilename", "inputfilename", "inFile", "inputfiles", "Infilename", "outfp", "inputfp", "Infiles", "Infile", "infilename", " infiles", " infp"], "outfile": ["infp", "outFile", "newname", "Outfile", " outfp", "outname", "newfile", " outfilename", " outfolder", "outputfp", "Outfolder", " outFile", "Outname", "infolder", "outputfolder", "outfolder", "outfilename", "outputfile", " outname", "outputfilename", "OutFile", "newFile", "newfolder", "outfp", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "image", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "base", "b", "vin", "is", "nin", "min", "ins", "cin", "thin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "source", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "on", "io", "up", "job", "base", "name", "ou", "outer", "exec", "post", "obj", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "fb", "buf", "len", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "input", "count", "sleep", "ind", "close", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", "modified", " succ", "true", "rolling", "respons", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "8932510", "id2": "12883117", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 0, "substitutes": {"doPost": ["sendPOST", "DoPost", "sendGet", " doPOST", " doGet", "doGet", "DoPOST", " doPut", "sendPut", "DoGet", "doPOST", "doPut", "DoPut", "sendPost"], "request": ["message", "remote", "buffer", "current", "session", "instance", "config", "head", "event", "have", "project", "image", "url", "post", "queue", "stream", "type", "http", "application", "form", "result", "uri", "client", "hello", "info", "this", "model", "view", "command", "req", "data", "writer", "object", "QUEST", "self", "allow", "save", "remove", "rate", "user", "parent", "method", "call", "path", "input", "condition", "resource", "next", "document", "subject", "requ", "attribute", "reader", "get", "Request", "create", "question", "re", "port", "frame", "enter", "complete", "q", "server", "query", "child", "connection", "list", "rf", "join", "right", "xml", "report", "context"], "response": ["message", "result", "re", "output", "json", "client", "view", " Response", "image", "xml", "resp", "writer", "data", "service", "object", "resource", "reply", "description", "next", "document", "server", "Response", "host", "res", "onse", "connection", "respond", "stream", "respons", "site", "error", "report", "status", "application"], "is": ["p", "mis", "as", "ris", "ist", "uri", "IS", "isa", "out", "was", "us", "isp", "ai", "info", "ori", "sis", "are", "iss", "i", "ie", "Is", "ci", "iso", "web", "in", "ib", "lis", "ini", "ir", "alis", "vs", "ip", "isin", "url", "si", "it", "isc", "ui", "isl", "address", "api", "isi", "iri", "pi", "bs", "rss", "ais", "ios", "eni", "iris", "nis", "bis", "ri", "ois", "http"], "page": ["p", "account", "message", "result", "cache", "so", "phone", "browser", "path", "flash", "session", "cover", "f", "view", "wp", "pl", "per", "root", "button", "po", "ko", "area", "image", "line", "blog", "menu", "web", "photo", "pg", "object", "record", "node", "www", "ip", "next", "url", "pe", "change", "article", "server", "pool", "code", "child", "Page", "sp", "list", "channel", "pages", "order", "handler", "filter", "html", "office", "bad", "pm", "sea", "pp", "site", "end", "plane", "parent", "user", "error", "can", "wiki"], "os": ["p", "ls", "OS", "ps", "ot", "so", "oss", "bos", "po", "socket", "pos", "object", "oa", "io", "ros", "ms", "oo", "obj", "oto", "oid", "mo", "ios", "op", "o", " bos", "ops"], "rootUrl": ["remoteurl", "randomurl", "rootPage", " rootURL", "weburl", "randomPage", "rootURL", " rooturl", "webPage", "randomUrl", " rootPage", "rooturl", "remotePage", "webURL", "remoteURL", "remoteUrl", "randomURL"], "isMultipart": ["isMultumpArt", "isMultitepart", "isMultiippoint", "isMultipparts", "isMultisepart", "isMultippoint", "isMultiiseArt", "isMultumparts", "isMultumppart", "isMultipppart", "isMultiseArt", "isMultiipArt", "isMultypArt", "isMultumpart", "isMultippart", "isMultiiseart", "isMultiteart", "isMultiipparts", "isMultiisepart", "isMultiparts", "isMultiipart", "isMultiiparts", "isMultipoint", "isMultypart", "isMultiipppart", "isMultisearts", "isMultiipoint", "isMultipArt", "isMultiippart", "isMultiteoint", "isMultiseart", "isMultiisearts", "isMultyppart", "isMultyparts", "isMultitearts"], "rd": ["ren", "ird", "rx", "rid", "pt", "hh", "wid", "lt", "rr", "RD", "dig", "dj", "ds", "func", "ind", "loc", "aa", "rs", "ru", "director", "rob", "fd", "cr", "rl", "wr", "pd", "fl", "rolog", "rss", "dr", "rb", "respond", "fr", "ld", "rw", "dd", "od", "rn", "rf", "cd", "ra", "rt", "std", "dh", "xd", "rg", "rh", "db", "dra", "td", "bd"], "upload": [" uploading", "form", "create", "util", "pload", "out", " submission", "instance", "Upload", "f", "load", "archive", "driver", "command", "input", "control", "project", "image", "or", "install", "folder", "object", "up", "io", "sup", "url", " instance", " uploaded", " Upload", "server", "transfer", "post", "zip", "container", "uploads", "dd", "stream", "parser", " archive", "file", "pkg", "user", "audio", "http"], "webUrl": ["rootPage", "wwwURL", "webUr", " webUr", "wwwUrl", "WebUrl", "rootURL", "WebUr", "rootPath", " webLine", " webPath", " webURL", "webPath", "WebLine", "rootUr", "webPage", "wwwUr", " webPage", "WebPath", "webURL", "webLine", "WebURL", "WebPage", "wwwLine"], "iter": ["inse", "itter", "init", "set", "apper", "inner", " iterator", "ver", "info", "ite", "its", "ter", "cher", "feed", "keep", "enter", "gener", "or", "loc", "ner", "walker", "in", "liter", "ir", "Iterator", "collect", "iv", "it", "izer", "outer", "Iter", "exec", "ator", "li", "list", "vis", "iner", "former", "over", "coll", "inc", "eni", "file", "ser", "er", "ignore", "err", "end", "reader", "inter", "keeper", "iterator", "oper", "slice", "order", "http"], "item": ["p", "source", "app", "result", "rec", " Item", "bar", "inner", "instance", "update", "custom", "info", "this", "extra", "hop", "link", "e", "input", "area", "image", "or", "atom", "data", "m", "get", "in", "object", "other", "record", "q", "ip", "up", "g", "ar", "it", "entity", "zip", "stat", "api", "Item", "li", "queue", "element", "layer", "coll", "plugin", "el", "value", "file", "temp", "part", "row", "r", "er", "feed", "entry", "items", "unit", "end", "user", "site", "op", "xml", "order"], "name": ["x", "call", "path", "field", "inner", "ame", "ni", "f", "NAME", "info", "not", "e", "one", "i", "word", "Name", "none", "data", "m", "nm", "in", "names", "old", "on", "n", "col", "label", "term", "na", "child", "time", "string", "connection", "size", "prefix", "layer", "am", "block", "nam", "orig", "named", "part", "key", "non", "id", "end", "type", "parent", "member", "common", "no"], "baos": ["BAo", "nais", "Baios", "abao", "BAOS", "baOs", "caos", "BAios", "cao", "cais", "BAis", "Bao", "paOs", "pao", "saOS", " baios", "BAoes", " baoes", "abaOS", "BaOs", " bao", "baOS", "saos", "Baos", "caOS", "paoes", "sais", " baOS", "bais", "naos", "baios", "abaios", "naOs", "caOs", "abaos", "nao", " bais", "Bais", "pais", "bao", "BAos", "paos", "sao", "baoes"], "wpIs": ["wpAs", "wpOs", "fwI", "cpis", "ipIS", "phpIns", "fwIs", "fwIS", "wpis", "WPIS", "wordpressis", "wpI", "wxIns", "fwAs", "wordpressAs", "ipAs", "cpIs", "WPI", "fpis", "WPIs", "WPAs", "phpIs", "wxIS", "xpIs", "wxis", "xpOs", "fpOs", "cpIns", "fpIs", "WPis", "phpIS", "cpIS", "wordpressIs", "phpis", "ipIs", "wpIns", "xpAs", "WPOs", "wxIs", "gpOs", "WPIns", "xpis", "gpIns", "wpIS", "wordpressOs", "fpIns", "gpis", "gpIs", "ipI"], "u": ["p", "uni", "uv", "uid", "una", "util", "su", "fu", "uri", "us", "Url", "c", "f", "s", "i", "input", "l", "web", "tu", "ru", "iu", "url", "ou", "b", "ui", "api", "nu", "bu", "uci", "ur", "ul", "lu", "Lu", "cu", "file", "hu", "mu", "U", "uu", "o"]}}
{"id1": "19467540", "id2": "4168534", "code1": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 1, "substitutes": {"updateProductIfAvailable": ["updateProductUnlessAvailable", "updateProductsIfAvailable", "updateProductUnlessPresent", "updateProductifPresent", "updateProductsifAvailability", "updateProductIfAvailability", "updateProductsIfAvailability", "updateProductsifAvailable", "updateProductsIfPresent", "updateProductsIfavailable", "updateProductWhereAvailability", "updateProductsifavailable", "updateProductWherePresent", "updateProductUnlessavailable", "updateProductifAvailable", "updateProductIfPresent", "updateProductifAvailability", "updateProductsifPresent", "updateProductUnlessAvailability", "updateProductifavailable", "updateProductWhereAvailable", "updateProductWhereavailable", "updateProductIfavailable"], "carro": ["Carra", "corros", "charro", "charrio", "CarRO", "harro", "charco", "carrio", "corrow", "carra", "Carrio", " carlo", "carlo", "corro", " carco", " carros", " carrio", " carRO", "borros", "corco", "carco", "Carros", "carros", "Carlo", "Carroc", "harra", "harlo", "borlo", "carroc", "borroc", "carrow", "borro", "Carro", "carRO", " carroc", "harros", "charRO", "corlo", "charros", "corra", "charrow", " carrow"], "request": ["p", "work", "message", "method", "create", "demand", "remote", "result", "current", "json", "client", "port", "username", "hello", "session", "instance", "config", "info", "model", "use", "input", "project", "respect", "resources", "data", "req", "application", "condition", "object", "resource", "platform", "core", "job", "url", "subject", "server", "params", "pool", "query", "worker", "require", "queue", "submit", "collection", "register", "r", "response", "remove", "join", "apply", "user", "parent", "xml", "Request", "http"], "listado": [" listada", "listada", "catando", "listando", "catado", "listable", "sortando", "sortada", " listando", "catable", " listable", "sortado", "catada", "sortable"], "conexion": ["cextiton", "cexiton", "conexiion", " conexions", " conexeion", "conelexif", "Colexion", "caxiton", "conexbao", "cexpiton", "coneplexion", "cexison", "conexaor", " conexaion", " conexao", "cexpao", "conexiang", "conexiao", "conexesao", "conexeion", "cexao", "conextion", "conexbion", "conenexiton", "conexesions", "cextao", "conexeION", "conexaao", "coneexiao", "caexiao", "Coleexion", "conexpions", "conexeution", " conexeif", "coneexiton", "conexpution", "conexione", "conextension", " conexION", "conextiton", "cexion", "conexao", "zonexION", "conexpION", "conelexion", "conexpiton", "cexpione", "coneplexison", "conexiension", "conexpao", "conexpansion", "ColeexION", "coneXao", " conexaao", "conexION", "Coleexiton", "conexaions", "conexesion", "conelexison", "conexyION", "conexiION", "zonextion", "coneyiao", "conextione", "cextison", "conexbions", "coneexION", "conextao", "conextison", "zonexension", "caxion", "conenexion", "caxions", "coneplexao", "conexif", "zonextension", "ColexION", "coneyions", "coneexions", "coneexion", " conexution", "conenexansion", "zonexiang", "conexension", "conexeif", "conextiang", "conexpione", "conexions", "caexiton", "conexansion", " conexaor", "conexiton", "zonextION", "conexution", "zonextiang", "conexpion", "conenexION", "Coleexansion", " conexor", "coneyion", "coneXion", "conexison", "conexbor", "caexions", " conexif", "caxiao", "conexesor", "conexyion", "conexpiao", "conexiiang", "caexion", "coneXione", "conexyiang", " conexeution", "conextION", "cexpion", "coneXiton", "conelexution", "conexyension", "conexor", "conelexION", "cextion", "Colexiton", "conexaion", "conelexiton", "conelexao", "coneyiton", "cexione", "coneplexiton", " conexaions", "zonexion", "coneexansion", " conexeION", "Colexansion", "conexpif"], "select": ["text", "match", "create", "init", "result", "copy", "set", "sync", "parse", "port", "push", "elect", "config", "state", "construct", "use", "view", "input", "build", "where", "lect", "connect", "reflect", "core", "subject", "collect", "execute", "search", "selection", "Select", "sel", "query", "SELECT", "sql", "sq", "test", "save", "insert", "pull", "ssl", "remove", "roll", "join", "apply", "get", "delete"], "update": ["edit", "create", "result", "copy", "current", "set", "json", "sync", "push", "status", "view", "options", "send", "build", "updated", "resource", "where", "Update", "up", "url", "database", "execute", "add", "search", "change", "post", "index", "UPDATE", "write", "settings", "replace", "save", "insert", "pull", "ssl", "response", "feed", "id", "apply", "get", "delete", "run", "http"], "rs": ["relations", "ls", "ats", "ums", "ris", "rx", "cs", "ps", "result", "ret", "ts", "parse", "ys", "ars", "rr", "mr", "ds", "hs", "rors", "errors", "sys", "RS", "vs", "ws", "sr", "ras", "values", "ros", "ks", "rob", "rm", "qs", "spec", "utils", "hr", "server", "rd", "rl", "res", "ack", "rss", "rc", "Rs", "ins", "acks", "features", "asts", "rys", "xs", "details", "pr", "vers", "repl", "sq", "runs", "rt", "rates", "ows", "row", "r", "results", "obs", "changes", "maps", "response", "fields", "js", "rows", "rg", "roc"], "codigoProd": ["codigoCompanyds", "codigoprold", "codidoprods", "codidoProld", "codigoPUdr", "codidoprold", "codigoPerd", "codigoSelect", "codigaProd", "codigoProld", "codigoprodB", "codicoprold", "codicoProdo", "codigoPd", "codigoPeardB", "codigoCompanyld", "codigaProld", "codigoPropdr", "codidoProdl", "codigo\n", "codigoprodo", "codigoPromds", "codigoPropdd", "codigoPromld", "codigoPld", "codidoprod", "codigoProdB", "codigaProsd", "codichoSelect", "codigoPropd", "codigoSuppds", "codigiPropd", "codigoProdl", "codigoPeards", "codigoProdh", "codicoProd", "codigoCompanyd", "codogoSelect", "codidoProds", "codigoPeardd", "codidoprodl", "codicoprodo", "codigoproe", "codigoPromd", "codicho\n", "codigaprodh", "codigoPromdB", "codigoProds", "codicoProds", "codigoPrope", "codigiPrope", "codigoprodd", "codigaprod", " codigo\n", " codigoSelect", "codigoSuppd", "codidoProdd", "codigoPds", "codogo\n", "codigoProdo", "codigoPUd", "codigoProsd", "codigoPerdl", "codigoprodl", "codigaprosd", "codidoprodd", "codigoProdr", "codidoprodB", "codigoPdo", "codigoCompanydo", "codigoprods", "codigiProdd", "codigoPeard", "codigoPUe", "codidoProdB", "codigoprosd", "codigoprodr", "codidoProd", "codigiProd", "codigiSelect", "codicoprods", "codigiProe", "codigi\n", "codigoPerds", "codicoProld", "codigaProdh", "codigoProe", "codigoprod", "codigoProdd", "codigiPropdr", " codichoSelect", "codigoPerld", "codicoprod", "codigoPUdd", "codigaprold", "codigoSuppdl", "codigiPropdd", "codigoSuppld", "codigoPromsd", " codicho\n", "codigoPromdh", "codigiProdr", "codigoprodh", "codigoPromdd"], "filasAfectadas": ["filasAfectida", "filasAducado", "filasAcessida", "filasAcfectida", "filasAcesadas", "filasAcesado", "filasAcfectable", "filasAcfectadas", "filasAcesable", "filasAducadas", "filasAfectado", "filasAducida", "filasAfectable", "filasAccesadas", "filasAcessadas", "filasAducable", "filasAccesable", "filasAcfectado", "filasAccesida", "filasAcesida", "filasAcessable", "filasAcessado", "filasAccesado"], "iterador": ["errabo", "iterator", "neroration", "outerado", "errator", "iteroration", "errador", "iterada", " iterado", "iterato", "nerador", "Iterador", "alternador", "iteraton", "enterator", "alternable", "nerable", "enterador", " iteroration", " iterator", "iterrar", "Iterar", "Iterado", " iterato", "outeraton", "perator", "enterabo", "iterado", "errrar", " iterada", "nerabo", "alternabo", "outerador", "iter\u00e1", "enter\u00e1", "Iter\u00e1", "iterable", "operator", "Iterabo", "Iterrar", "operada", " iterable", "Iterator", "iterabo", "operador", " iterabo", " iter\u00e1", "operato", "iterar", "outerar", " iterar", " iterrar", "perato", "perada", "Iteraton", "perador", "alternoration", " iteraton"], "prod": ["produd", "provb", "provd", " prog", "pubc", "Prob", " prob", " prodd", "perc", "provds", "prog", "Prod", "provdd", "prob", "proD", "proc", "produds", "perb", "Prog", "perd", "pubD", "pubd", " prods", "produc", "perg", "Prodd", "prods", " proD", "produD", " proc", "Prods", "prodd", "Proc", "pubds"], "exito": ["EXitation", "EXiting", "pacitation", "pacited", "pacito", "xiting", "paciting", "xitation", "exiting", "xito", "xited", "EXited", "exited", "exitation", "EXito"]}}
{"id1": "13596891", "id2": "20028790", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"doTransfer": ["handleTransfer", "doImport", " doSend", "makeSend", "doRequest", "makeImport", "handleRequest", "makeRequest", " doImport", "makeTransfer", "handleSend", "doSend", "handleImport", " doRequest"], "request": ["message", "form", "create", "remote", "result", "position", "re", "current", "client", "session", "instance", "config", "com", "this", "model", "http", "event", "command", "input", "enter", "complete", "condition", "req", "data", "q", "in", "object", "resource", "record", "QUEST", "subject", "server", "requ", "post", "query", "time", "connection", "stream", "queue", "rf", "received", "version", "reader", "type", "user", "xml", "Request", "report", "context", "application"], "response": ["message", "call", "remote", "result", "re", "output", "json", "client", "out", "cache", "session", "cover", "status", "model", "page", "view", "event", " Response", "success", "serv", "image", "default", "application", "resp", "writer", "warning", "service", "object", "resource", "reply", "next", "document", "server", "Response", "res", "body", "index", "onse", "connection", "header", "respond", "full", "en", "version", "results", "site", "error", "report", "content", "http"], "method": ["text", "message", "call", "position", "property", "mode", "json", "METHOD", "path", "session", "date", "head", "use", "cmd", "command", "send", "process", "resource", "format", "description", "class", "callback", "subject", "reason", "hod", "verb", "term", "time", "string", "direction", "prefix", "sort", "version", "route", "pull", "sign", "type", "Method", "status", "content"], "servletContext": ["servlexConfig", "servletsConfig", "ServletsConfig", "servleContext", "Servletscontext", "servantCurrent", " servletCurrent", "servantProvider", " servletConfig", "ServletsController", "servletConfig", "servlexContext", "servApplicationcontext", " servantConfig", "ServletConfig", "servletsController", "Servletcontext", "ServletsContext", "servApplicationConfig", "servleConfig", "ServletController", "servantConfig", "servantContext", "servlexcontext", "servApplicationController", "servleProvider", " servantCurrent", "servLETCurrent", "servletcontext", "servletsContext", "servApplicationContext", " servletProvider", " servantProvider", "servLETProvider", "ServletContext", "servletProvider", "servLETContext", "servletscontext", "servletCurrent", "servLETConfig", "servlexController", "servleCurrent", " servantContext", "servletController"], "wac": ["wsacs", " Wae", " Wacs", " wAC", "wsac", "wae", " wae", "wAC", "wsAC", " Wac", " WAC", " wacs", "wacs", "wsae"], "szUrl": ["szeFrame", "sizUrl", "szerURL", "szaURL", "szurl", "szaUrl", " sizURL", "asizFrame", "szeurl", "sizURL", "szenURL", "szeUr", "szenurl", "sznURL", "szPath", "szeURL", "aszUrl", "sizFrame", " szURL", "aszurl", "aszURL", " szurl", "szerUr", "szeFolder", " sizFolder", " sizUrl", "sznurl", "aszUr", "szeUrl", "aszFrame", "asizUrl", "sziurl", "sizurl", "szFrame", "szenFolder", "sznPath", "szaUr", "szerUrl", "aszPath", "sznUr", " szFolder", "asizURL", "asizurl", "sznUrl", " sizurl", "sizFolder", "sziUrl", "sizUr", "sziURL", "szaPath", "szerFrame", "szenUrl", "sizPath", "sziUr", "szFolder", "szUr", "szURL", "asizUr", "asizPath"], "url": ["source", "org", "gl", "buffer", "cloud", "re", "uri", "client", " URL", "Url", "f", "config", "page", "event", "il", "l", "socket", "conn", "loc", "web", "service", "resource", "location", "context", "lb", "www", "base", "name", "log", "server", "host", "obj", "URL", "rl", "fl", "sl", "li", "connection", "string", "ur", "stream", "ul", "el", "ll", "impl", "file", "ssl", "key", "user", "get", "xml", "rel", "http"], "is": ["x", "as", "ris", "rx", "uri", "IS", "im", " isn", "isa", "was", "oss", "us", "ai", "info", "ii", "il", "isu", "iss", "i", "Is", "src", "serv", "ci", "iso", "web", "ib", "lis", "ir", " bis", "ip", "io", " are", "os", "it", "isf", "isc", "isl", "bs", "isi", "rc", "ais", "ios", "ils", "bis", "has", "ri", "cms"], "sout": ["Souts", " souts", "sdata", "sin", "SOut", " sOut", " sin", "Sin", "Sout", "souts", " sdata", "SOUT", "Sdata", "sOUT", "sOut", " sOUT"], "con": ["remote", "cache", "uc", "event", "Connection", "ca", "close", "core", "conf", "Con", "cur", "cc", "cp", "general", "fc", "un", "crit", "ct", "ctx", "type", "run", "can", "http", "ren", "pre", "util", "client", "ctrl", "pin", "ocon", "com", "ver", "view", "java", "conn", "const", "win", "don", "cos", "lc", "rc", "nc", "coll", "user", "cons", "pen", "fun", "cf", "single", "internal", "wa", "bc", "pc", "subject", "C", "gen", "wan", "en", "version", "san", "syn", "non", "login", "get", "inc", "status", "Internal", "xc", "re", "net", "c", "author", "l", "func", "m", "web", "open", "ec", "on", "connect", "conv", "server", "exec", "ran", "fe", "query", "min", "connection", "fa", "cl", "Common", "cn", "ssl", "CON", "common", "co"], "hNames": ["hrName", " hKeys", "hostNs", " hName", "HFiles", "HNames", "hBlocks", "hVs", "hrNs", " hNs", "HVs", " hBlocks", "hostTypes", "HName", " hFiles", " hVs", "ihBlocks", "hrTypes", "hTypes", "hKeys", "hostKeys", "hNs", " hTypes", "HBlocks", "hostNames", "ihName", "ihVs", "hrNames", "hFiles", "hrKeys", "ihNames", "HTypes", "hrFiles", "hName"], "txt": ["text", "ht", " text", "rx", "gt", "tin", "fp", "str", "fx", "git", "csv", "py", "vt", "gi", "lt", "gz", "wt", "rr", "phrase", "nt", "tx", "et", "XT", "qt", "elt", "utt", "nm", "q", "in", "prot", "TEXT", "binary", "name", "bt", "wx", "dt", "Text", "obj", "zip", "htm", "header", "struct", "inet", "jp", "value", "lv", "t", "key", "xt", "ct", "sv", "xxx", "kt", "v", "section", "cb", "ctx"], "inBody": [" inbody", "insReader", "InReader", "outFile", "inReader", "INbody", "insFile", "INStream", "Inbody", "insBody", "INReader", "InFile", " inReader", "InBody", " inFile", "INFile", "inFile", "inbody", "INBody", "insStream", " inStream", "outStream", "outbody", "outBody", "inStream", "InStream"], "bufCh": ["bufferch", "buffCh", " bufChar", "ufCol", "ufCH", "bufferCH", "ufCh", "queueCol", "bufch", "ufChar", "bufC", " bufC", "ufC", "queueCh", "ufch", "buffC", "queuech", " bufch", " bufCH", "bufferChar", "bufChar", "bufCH", "buffch", "bufferCh", " bufCol", "buffCH", "queueCH", "bufCol"], "r": ["p", "x", " rg", "result", "re", "str", "br", "c", "f", "reg", "rr", "w", "e", "i", "k", "m", "q", "ner", "rs", "ru", "sr", "n", "g", "ar", "v", "b", "u", "hr", "R", "nr", "rl", "cr", "rd", "res", "rc", "rb", "fr", "rw", "pr", "range", "lr", "rf", "rt", "er", "ror", "err", "reader", "rh", "ri", "d", "rg"], "outReq": ["outRquest", "outRece", " outRequest", " outRereq", "outConh", " outReh", "outDece", "outRsque", "outREce", " outEreq", " outEque", "outRecck", "outEque", "outRecce", " outSeck", "outReck", " outRsh", "outRque", "outREh", " outRque", "outREq", "outRsce", "outRreq", " outEq", "outEck", " outEck", "outDequest", "outRecque", "outREck", "outEq", "outSeq", "outReh", "outSequest", "outDeque", "outRq", "outREque", " outReck", "outRecreq", " outRece", "outConce", " outRsce", "outRsq", " outSeq", " outRsq", "outEreq", " outRsque", "outRereq", "outConq", "outSeck", " outReque", "outRsh", " outSeque", " outRquest", "outConque", "outRecq", "outDeq", "outRce", " outRce", " outSece", "outSeque", "outReque", "outRck", "outSece", " outRq", "outRequest"], "buff": [" Buff", "p", "buffer", "uf", "lines", "f", "bb", "info", "buf", "map", "data", "num", "b", "array", "Msg", "Pad", " Buffer", "Ptr", "Buffer", "ch", " chunk", "Info", "file", " buffers", "Buff"]}}
{"id1": "14191679", "id2": "15645004", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnodeReturn", "EncodReturns", "EncodReturn", "EncodData", "EncodeReturns", "EnccodeData", "EnodeResult", "EnodeReturns", "EnodedResult", "EncodResult", "EnodedReturns", "EnodedReturn", "EnodeData", "EnccodeResult", "EnccodeReturn", "EnccodeReturns", "EnodedData", "EncodeResult", "EncodeData"], "IOException": ["DownloadException", "DownloadError", " IOception", "Downloadception", "IOception", "IPError", "IPException", "IOError", " IOError", "IPception"], "c": ["p", "gc", "cs", "xc", "cache", "uc", "client", "cf", "ac", "f", "e", "l", "ci", "m", "ce", "ec", "n", "pc", "conv", "lc", "proc", "C", "u", "cr", "b", "sc", "ch", "cur", "cc", "nc", "cp", "chain", "enc", "cpp", "fc", "cd", "cu", "y", "mc", "t", "r", "ct", "d", "cmp", "dc"], "tmpf": ["tempcf", " tmpfs", "poraryf", "zipf", "zipfs", "tmpfd", "tempfs", "empfs", "tempF", " tmpF", "vmf", "tmpfs", " tmpcf", " tmpfen", "vmF", "empf", "tmpF", "tempfen", "porarycf", "vmcf", "zipF", "poraryfen", "vmfs", "poraryF", "tempfd", "empF", "tmpcf", "tempf", "tmpfen", "zipfd", "empfd"], "cw": ["Cw", " cwa", "cws", "cwd", "rcwe", "cwb", "pW", "rcwd", " csw", "pw", "Cws", "ffw", " cW", "fws", "csw", "cwa", "fwa", "pwa", "psw", "lcw", "fw", "cW", "lcwe", "rcw", " cwd", "lcwd", " cwb", "lcwb", " cwe", "cfw", " cws", "Csw", "Cfw", "Cwa", "cwe", "rcwb", "CW", " cfw"], "encdata": [" encData", "envdata", "extData", "installData", "envdat", "installdat", "secData", "encdatabase", "envreader", "extdat", "secdata", "extdata", "envkeys", "extdatabase", "encData", "Encdata", "enccache", " encdatabase", " encdat", "incdata", "incroot", "EncData", " encreader", "encreader", "envData", "encdat", "installdatabase", "Enckeys", "enckeys", "Encdat", "inccache", "installdata", "secdat", " encroot", " enccache", "seckeys", "encroot", "increader", "envroot", "envcache"], "pigdata": ["pagresults", "pippcache", "pigscache", "pigrdata", "pocresource", "pagdata", "pocData", "picresource", "PigData", "PigsData", "Pigsla", "Pigresults", "pigrData", "pichdata", "Pigresource", "Pigsdat", "pocdata", "PibData", "Pigscache", "pigresults", "picdat", "pippdata", "Pigdata", "pichcache", "pagData", "pigdat", "pigresource", "pigData", "Pigdat", "picData", "pigrresults", "pichData", "pigsla", "Pibresource", "pigcache", "pigsdat", "pocdat", "pigsdata", "pippData", "Pigla", "Pibdata", "pigsData", "pichla", "pibdat", "pigrdat", "pigsresults", "pibdata", "pigla", "pibresource", "pippla", "Pigsdata", "pibData", "pagdat", "Pigsresults", "Pibdat", "picdata", "Pigcache"], "pigroute": ["pibrouter", "apibrouter", "pirmroute", "miarote", "pigrationoute", "pibrote", "pigrationouter", "apigrouter", "pigrationange", "pipeloute", "piarune", "apibroute", "fibrote", "fibrange", "migroute", "pibrroute", "pirmouter", "pigerote", "figrroute", "pigrouter", "pigerune", "piarouting", "migrote", "figrote", "pipelote", "pipelouting", "pigeroute", "pibrange", "pigrroute", "pirmouting", "pirmoute", "pigrote", "apibrouting", "migrouting", "figrange", "pigerouting", "miaroute", "pigrange", "apibrroute", "apigroute", "pigrune", "pipelange", "pibroute", "migrune", "piaroute", "miarouting", "figroute", "miarune", "pigrationouting", "pipelune", "pibrouting", "pigrationote", "piarote", "pigrationroute", "pipelroute", "apigrroute", "pigrouting", "apigrouting", "fibrroute", "fibroute"], "fos": ["refos", "foes", "Fo", "Foes", " fops", "to", "pos", " fOS", "Fos", " foes", "pOS", "fo", "poes", "toc", " fo", "toes", "refOS", "Foc", "refoes", "tos", "pops", "fOS", "fops", "refops"], "foc": ["infocol", "Focol", "infoc", " focol", "infic", " fac", "infac", "Fec", "fac", "Fac", "Foc", "fec", "focol", " fec", "infec", "Fic"], "fis": ["infi", "Fi", "cig", "infic", "fics", "Fis", "infis", "Fics", "Fig", " fi", "cis", "fi", "Fic", " fig", "cic", "fig", " fics", "cics", "infics"], "fic": ["rfics", "Fisc", "cfoc", "infoc", "Fico", " fico", " fisc", "rfoc", "poc", "cfic", "infic", " fac", "fico", "cfics", "fics", "pis", "Fis", "cfico", "rfic", "pic", "Fics", "cfis", "fac", "Fac", "pac", "Foc", "fisc", "Fic", "rfis", "infisc", " fics", "infics"]}}
{"id1": "5977352", "id2": "8182932", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyDir", "copyfile", " copyDir", "CopyFile", "copyFiles", " copyFiles", "transferfile", "transferFile", "transferDir", "Copyfile", "CopyFiles", " copyfile", "CopyDir"], "src": ["source", "filename", "sb", "uri", "fp", "path", "config", "s", "this", "buf", "view", "input", "ource", "conn", "inst", "loc", "data", "loader", "resource", "proxy", "img", "url", "tmp", "b", "proc", "obj", "files", "sel", "sc", "sl", "dist", "rc", "rb", "ins", "gb", "stream", "file", "slice"], "dest": ["source", "cache", "output", "table", "st", "path", " destination", "config", "home", "store", "this", "master", " Dest", "txt", "d", "de", "trans", "project", "rest", "cdn", "folder", "done", "dep", "later", "img", "class", "url", "tmp", "name", "cont", "null", "die", "obj", "destroy", "zip", "dist", "cp", "thin", "orig", "desc", "file", "temp", "route", "wb", "Dest", "part", "dir", "parent", "opt", "target", "delete", "dc"], "bufSize": ["buf2", "ufSize", "bufferSize", "buffersize", " bufsize", "bufLen", "uf2", "queueSize", "ufLen", " buf2", " bufLen", "queuesize", "queueLen", "buffer2", "ufsize", "bufsize", "bufferLen"], "force": ["ride", "p", "source", "Force", "remote", "ist", "sync", "push", "dirty", "load", "forces", "front", "f", "store", "use", "place", "hard", "urse", "count", "base", "deep", "rc", "require", "write", "only", "auto", "replace", "like", "file", "parent", "forcing", "pull", "route", "id", "forced", "apply", "flush", "delete", "no"], "buffer": ["source", "result", "cache", "length", "memory", "load", "buff", "fb", "buf", "seed", "bytes", "uffer", "border", "padding", "data", "binary", "zero", "limit", "url", "base", "b", "null", "transfer", "split", "address", "append", "Buffer", "queue", "write", "raw", "batch", "reference", "iter", "value", "request", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "text", "ride", "seek", "create", "select", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "lex", "len", "use", "view", "pass", "show", "level", "READ", "i", "input", "send", "skip", "ed", "count", "k", "sleep", "ind", "data", "build", "close", "ad", "open", "play", "find", "ip", "io", "n", "connect", "next", "b", "add", " write", "allow", "exec", "reads", "index", "size", "write", "raw", "block", "iter", "wait", "feed", "id", "reader", "end", "get", "start", "d", "fill", "run"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "c", "ac", "f", "pass", "ex", "i", "input", "socket", "conn", "image", "sin", "inside", "serv", "IN", "m", "con", "win", "ini", "up", "n", "isin", "a", "url", "base", "din", "b", "nin", "min", "ins", "connection", "cin", "thin", "In", "inc", "again", "rin", "kin", "lib", "part", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "ac", "at", "home", "this", "with", "w", "ex", "i", "one", "max", "socket", "conn", "OUT", "line", "image", "by", "writer", "n", "io", "up", "bin", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "nin", "connection", "exp", "plain", "Out", "write", "outs", "again", "off", "lib", "part", "err", "key", "o", "id", "user", "inc", "co", "can", "no"]}}
{"id1": "13852596", "id2": "20924119", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"execute": ["call", "create", "copy", "parse", "ute", "invoke", "load", "all", "process", "install", "evaluate", "server", "code", "exec", "transfer", "report", " invoke", " perform", "Exec", "submit", "test", "register", "apply", "start", "handle", "run"], "resources": ["relations", "workers", "types", "rules", "chains", "apps", "locks", "writers", "groups", "issues", "services", "projects", "strings", "resource", "cells", "flows", "archives", "works", "rings", "objects", "series", "thumbnails", "params", "files", "stores", "reports", "features", "models", "pages", "scripts", "plugins", "users", "rates", "results", "Resources", "items", "maps", "classes", "ions", "events", "ids", "stars", "images", "roots"], "i": ["p", "ani", "uri", "ai", "f", "gi", "ii", "info", "ori", "s", "e", "vi", "ie", "l", "I", "k", "wei", "ci", "abi", "ini", "we", "ami", "ir", "multi", "ip", "iu", "bi", "io", "si", "ti", "u", "is", "ui", "pi", "oi", "isi", "j", "li", "iri", "h", "hi", "di", "qi", "eni", "xi", "cli", "mu", "o", "id", "v", "esi", "ri", "ic", "phi"], "classFile": ["classFILE", "ruleLine", "staticfile", "classEntry", "CLASSFile", "connectionFile", "sessionFILE", "ClassGlobal", "customEntry", "sessionFile", "classClass", "Classfile", "filefile", "lassFiles", " classFILE", " classPage", "baseFile", "lassClass", "lassGlobal", "fileFiles", "finalFILE", "serviceLine", "CLASSEntry", "classGlobal", "staticFILE", "packEntry", "fileLoader", "CLASSFILE", "connectionfile", "ClassFactory", "ClassPage", "ClassImage", "sessionfile", " classEntry", "finalfile", "CLASSLoader", " classLoader", "ClassFiles", "baseUrl", "classLoader", "ClassClass", "customFILE", "classfile", "ClassFilename", "servicefile", "staticLine", "classesPath", "objectFiles", "ClassEntry", "objectfile", " classFiles", "classFactory", " classLine", "finalUrl", "ClassDir", " classGlobal", "classImage", "fileImage", "packFile", "classFiles", "ruleFile", "classPage", "classUrl", "ClassStream", "classesFile", "packFILE", "fileFile", " classFactory", " classStream", "classesFiles", "finalFile", "classStream", "CLASSLine", "classesfile", "classDirectory", "classPath", "classDir", " classFilename", "sessionEntry", " classClass", "CLASSDirectory", "connectionFiles", "baseFILE", "ruleFiles", "customFiles", " classDir", "ruleFilename", "CLASSfile", "ClassFile", "packfile", "serviceFile", "customFile", "classFilename", "CLASSImage", "ClassPath", "ClassLine", "fileDirectory", "basefile", "ClassDirectory", "fileLine", "staticFile", "sessionFactory", "CLASSUrl", "CLASSPage", "CLASSFiles", "objectDir", "classLine", "lassFile", "connectionStream", "objectFile", "sessionFiles", " classPath", " classfile", "serviceFILE", "ClassFILE"], "inputStream": ["InputFile", "initSteam", "InputStreamer", "uploadstream", "binaryFile", "importSteam", "inputContext", "outputStreamer", " inputstream", "rawFile", "inputFile", "importStream", "childstream", "inputSw", "childContext", "activeSteam", "outputContext", "binaryStream", "activeStream", "outputReader", "childStream", "uploadStream", "Inputstream", "rawStream", "activeStreamer", "rawSteam", "initStreamer", "inputReader", "inputstream", "InputStream", "outputSw", "InputSw", "importStreamer", "uploadSw", " inputFile", "InputSteam", "binaryStreamer", "inputStreamer", " inputStreamer", " inputSteam", "outputstream", "inputSteam", "rawStreamer", "childReader", "outputFile", "uploadFile", "importstream", "activestream", " inputContext", "initStream", "outputSteam", "initstream", " inputReader", "binarySteam"], "reader": ["source", "arser", "rx", "buffer", "copy", "writers", "re", "client", "reading", "sync", "inner", "author", "system", "rr", "seed", "driver", "ler", "per", "rar", "input", "owner", "manager", "war", "draft", "shared", "or", "read", "riter", "loader", "ner", "oder", "resource", "builder", "director", "ger", "Writer", "io", "editor", "reflect", "rer", "server", "book", "dr", "rc", "worker", "handler", "stream", "ee", "layer", "wrapper", "parser", "Reader", "iter", "request", "row", "key", "er", "entry", "keeper", "right", "ri", "report", "context", "http"], "oldSize": ["OldName", "oldName", "OldSc", " oldSc", "oldLength", "prevSize", "prevLength", "prevSc", " oldName", "prevName", "OldSize", " oldLength", "OldLength", "oldSc"], "writer": ["wer", "buffer", "writers", "token", "widget", "wire", "inner", "author", "written", "w", "driver", "ler", "writing", "word", "e", "war", "manager", "draft", "read", "riter", "data", "ner", "loader", "service", "resource", "builder", "format", "director", "object", "Writer", "oder", "walker", "editor", "io", "document", "player", "writ", "wr", "child", "index", "worker", "string", "rw", "handler", "element", "ee", "write", "wrapper", "winner", "parser", "iter", "creator", "Reader", "maker", "row", "r", "er", "her", "engine", "report", "dc"], "b": ["p", "ab", "buffer", "bar", "br", "abc", "c", "f", "bb", "fb", "ba", "w", "e", "pb", "l", "k", "B", "m", "object", "binary", "lb", "be", "g", "a", "base", "u", "null", "rb", "db", "h", "eb", "emb", "r", "ob", "boot", "bin", "orb", "d", "bd"], "outputStream": [" outputView", "OutputStream", "outstream", "protectedSteam", "OutputStreamer", "OutputSteam", "Outputstream", "OutputView", "outputStreamer", " outputSteam", "inputstream", "protectedStream", "protectedStreamer", "protectedstream", "dataStream", "dataStreamer", "outputContainer", " outputStreamer", "outStreamer", "inputStreamer", "inputView", "outputstream", "outSteam", "inputSteam", " outputContainer", "dataSteam", "outStream", " outputstream", "outputView", "inputContainer", "outputSteam", "dataContainer"], "injectedClasses": ["injectedWrites", "injectedClassies", "injectionClasses", "injectedClassites", "injectedclassies", "injectionclassites", "injectedWrits", "injectionClassies", "injectedProjectes", "injectionclasss", "injectedclassites", "injectedclasses", "injectionclassies", "injectedWritites", "injectionClassites", "injectedProjectites", "injectionclasses", "injectedProjecties", "injectedWrities", "injectedProjects", "injectionClasss", "injectedclasss", "injectedClasss"], "newSize": ["NewStorage", "finalSize", "NewSize", " newLength", "newStorage", "newFontSize", "finalStorage", " newFontSize", "finalFontSize", "finalLength", " newStorage", "newLength", "NewFontSize", "NewLength"]}}
{"id1": "23161545", "id2": "6301863", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomUid", "getRandomUUID", "getRandomGCID", "getRandGUID", "getRandGuid", "getRandGID", "getRandomGCUID", "getRandomGuid", "getRandUUID", "getRandUid", "getRandomIGID", "getRandGid", "getRandomIGid", "getRandomUuid", "getRandomGID", "getRandUID", "getRandomGCuid", "getRandomIGUID", "getRandomGid", "getRandomUID", "getRandomIGuid", "getRandomGCid", "getRandUuid"], "secure": ["secret", "remote", " insecure", "depth", "session", "config", "https", "use", "timeout", "seed", "unsigned", "service", "proxy", "ce", "stable", "weak", "force", "sr", "smart", "sec", "deep", "security", "random", "server", "allow", "host", "zip", "sensitive", "Secure", "external", "require", "confirmed", "encrypted", "safe", "pure", "secondary", "exclusive", "ssl", "protect", "debug", "active"], "md5": [" md500", "MDql", "md2", " md11", "md500", " md3", " MD11", " MD3", "cmd3", "cmdql", "md512", " mdql", "md3", " md2", "MD2", "cmd512", "MD5", "MD11", "cmd5", "mdql", "MD512", " MD500", " MD5", "md11", " md512", " MD2", "MD3", "MD500"], "sbValueBeforeMD5": ["sbValueBeforeMD1", "sbValueBeforeMD65", "sbValueBeforemd25", "sbValueAfterMD65", "sbValueBeforeMAC3", "sbValueBeforeMD7", "sbValueBeforeMS375", "sbValueBeforeMC5", "sbValueAfterMD7", "sbValueAfterMD0", "sbValueBeforeMD0", "sbValueBeforeMI5", "sbValueAfterMD95", "sbValueBeforeDER5", "sbValueBeforemd512", "sbValueBeforeSHA1", "sbValueBeforeDER3", "sbValueBeforeMD25", "sbValueAfterMD25", "sbValueBeforeMD20", "sbValueGivenMD375", "sbValueAfterMS0", "sbValueBeforeMAC55", "sbValueBeforeMD005", "sbValueAfterMS20", "sbValueGivenMD5", "sbValueAfterMS65", "sbValuebeforeMD1", "sbValueBeforeDER20", "sbValueBeforeMS3", "sbValueBeforeMR5", "sbValueBeforeMD75", "sbValueBeforeMAC5", "sbValueBeforeMS95", "sbValueBeforeMP3", "sbValueGivenMD512", "sbValueBeforeMI20", "sbValueBeforeMR3", "sbValuebeforeMD20", "sbValueBeforeSHA20", "sbValuebeforeMD005", "sbValueBeforeMS512", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeAMD1", "sbValueBeforeD75", "sbValueBeforemd75", "sbValueBeforemd95", "sbValueGivenmd512", "sbValueBeforeMD3", "sbValueBeforeMS65", "sbValueBeforeSD20", "sbValueAfterMP1", "sbValueGivenmd3", "sbValueBeforeMI3", "sbValueAfterMS95", "sbValueBeforeMS20", "sbValueBeforeMC512", "sbValueBeforeMD55", "sbValueAfterMD5", "sbValueBeforeDER55", "sbValueBeforeMI7", "sbValuebeforeSD1", "sbValueBeforeDER0", "sbValueBeforemd65", "sbValueBeforeMS1", "sbValueBeforeSHA5", "sbValueBeforemd3", "sbValueBeforeMR25", "sbValueBeforeAMD3", "sbValueBeforeD3", "sbValueAfterMS3", "sbValueAfterMS25", "sbValueBeforeMS25", "sbValuebeforeSD20", "sbValueBeforeD65", "sbValueBeforemd5", "sbValueBeforeMS5", "sbValueBeforeMP5", "sbValueGivenmd5", "sbValueAfterMD75", "sbValueBeforeMD375", "sbValueBeforeSD5", "sbValueBeforeMS75", "sbValueBeforemd375", "sbValueBeforeMP7", "sbValueBeforeDER005", "sbValueAfterMS55", "sbValueAfterMS5", "sbValuebeforeSD5", "sbValueBeforeSD005", "sbValueAfterMP7", "sbValueAfterMS75", "sbValueAfterMD20", "sbValueAfterMP3", "sbValueBeforeMS7", "sbValueBeforeAMD20", "sbValueGivenmd375", "sbValueBeforeMS55", "sbValueBeforeMI1", "sbValueBeforeMC375", "sbValueBeforeMR95", "sbValueBeforeDER1", "sbValueBeforeMS0", "sbValuebeforeMD5", "sbValueBeforeSD1", "sbValueGivenMD3", "sbValueBeforeAMD5", "sbValueBeforeMC3", "sbValueAfterMD55", "sbValueBeforeMP1", "sbValueAfterMD3", "sbValueBeforeMD512", "sbValuebeforeSD005", "sbValueBeforeSHA005", "sbValueBeforeMAC0", "sbValueBeforeMD95", "sbValueBeforeD5", "sbValueAfterMP5"], "time": ["work", "mode", "depth", "timer", "length", "date", "etime", "event", "tz", "timeout", "seed", "Time", "tim", "count", "loc", "year", "duration", "hour", "money", "speed", "TIME", "name", "random", "host", "counter", "ime", "delay", "race", "times", "size", "clock", "value", "version", "cost", "slice", "id", "rate", "type", "user", "start", "error", "offset"], "rand": ["right", "ro", "depth", "clean", "risk", "reg", "rr", "seed", "root", "Rand", "max", "raid", "rank", "count", "year", "q", "pick", "win", "bot", "round", "bit", "random", "gen", "cr", "mid", "res", "chance", "index", "rc", "delay", "rule", "lang", "min", "alpha", "ng", "range", "rage", "serial", "winner", "version", "r", "id", "rate", "type", "rh", "error", "rol", "order"], "valueBeforeMD5": ["valueBeforeAMD53", "valueInsideMD5", "valueInsideMD85", "valueBeforeMP53", "valueBeforeAMD5", "valueBeforemd3", "valueBeforemd85", "valueBeforemd5", "valueBeforeMD85", "valueBeforeAMD2", "valueInsideMD3", "valueAfterMD53", "valueAfterAMD53", "valueBeforemd2", "valueBeforeMC85", "valueBeforeMC3", "valueBeforeAMD3", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueBeforeMC5", "valueBeforeMD53", "valueBeforeMC2", "valueAfterAMD3", "valueBeforeMP2", "valueBeforeMP5", "valueInsideMD2"], "array": ["vector", "message", "app", "result", "shape", "expression", "arr", "cache", "ray", "feature", "instance", "our", "archive", "view", "area", "angle", "image", "data", "record", "object", "binary", "storage", "air", "integer", "database", "allow", "function", "number", "address", "api", "string", "list", "arrow", "element", "range", "batch", "sample", "value", "collection", "Array", "row", "any", "section", "error", "audio", "pair"], "sb": ["lp", "sbm", "bh", "buffer", "ab", "xb", "SB", "obb", "bb", "fb", "s", "buf", "lab", "bj", "sg", "pb", "src", "bl", "mb", " SB", "bp", "kb", "ib", "zb", "binary", "bf", "lb", "sth", "sa", "nn", "si", "bc", "rob", "bt", "usb", "nb", "bs", "sl", "rb", "eb", "gb", "bm", "BB", "lr", "orb", "sq", "ruby", "bsp", "wb", "sf", "ob", "sv", "cb", "abb", "stab"], "j": ["p", "x", "out", "ij", "length", "z", "br", "c", "jl", "f", "bj", "ii", "e", "i", "ie", "l", "k", "aj", "q", "n", "g", "job", "v", "jj", "num", "ja", "code", "obj", "ji", "ch", "li", "index", "dy", "jp", "pr", "y", "part", "key", "adj", "uj", "o", "end", "J", "js", "d", "jo"], "b": ["p", "x", "ab", "bar", "br", "cb", "c", "f", "bb", "fb", "e", "i", "pb", "l", "k", "mb", "B", "ib", "binary", "bf", "lb", "n", "bi", "be", "a", "bit", "bc", "job", "nb", "bs", "eb", "rb", "BB", "orb", "y", "bug", "ob", "bin", "db", "d"], "valueAfterMD5": ["valueAfterMP2", "valueAfterMP3", "valueAfterVM2", "valueAfterVM3", "valueAfterVM5", "valueAfterMD7", "valueBeforeMD7", "valueAfterAMD7", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterMP7", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueAfterVM7", "valueAfterAMD3", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMP5", "valueBeforeMP7"]}}
{"id1": "8801436", "id2": "18696387", "code1": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "source", "create", "sync", "paste", "load", "download", "cat", "update", "cross", "archive", "link", "Cop", "move", "image", "process", "open", "cop", " copying", "clone", "rm", "clip", "share", "change", "ge", "transfer", " transfer", "zip", "split", "upload", "Copy", "cp", "attach", "opy", "ize", "write", " Copy", "save", "ignore", "type", "delete"], "from_file": ["from67auto", " from_connection", "fromingclass", "to_files", "from_parent", "fromfsingle", " from_folder", "from2file", " from_directory", "from_cache", "from_class", " from_function", "source_parent", "to_File", "fromffiles", "from2File", " from_money", "from_function", "from_directory", " from_files", "fromingmoney", "to_user", "from_files", "fromffolder", "from67file", "from_folder", "from_single", "from_money", " from_single", "from_user", "source_file", "from2source", " from_auto", "from_auto", " from_File", "from67directory", "fromffile", "from67files", "from_connection", "source_cache", "fromingfile", "from_File", "to_source", "from2files", "from_source", " from_class"], "to_file": ["to_files", "to_letter", "from_model", "toPfiles", "to_string", "to_global", "to_get", "to_name", "To_resource", "To_directory", " to_path", "to_resource", "to_path", " to_string", "to_model", "totheglobal", " to_get", "toPname", "to_folder", "tothefile", "to_image", "from_name", " to_source", "from_filename", "toPfile", " to_resource", "from_files", "To_mail", "from_folder", "tothefolder", "to_filename", " to_directory", " to_global", "to_directory", "to_mail", " to_folder", "from_image", "to_source", " to_letter", "To_file", "tothesource"], "parent": ["source", "remote", "cache", "current", "session", "ca", "loc", "location", "ip", "directory", "url", "name", "search", "null", "pool", "rule", "div", "size", "pid", "key", "any", "type", "section", "uri", "client", "ppa", "home", "root", "po", "tree", "data", "pa", "term", "api", "layer", "parser", "test", "Parent", "anc", "partial", "id", "unit", "path", "point", "folder", "resource", "and", "container", "par", "pr", "inc", "content", "p", "pt", "port", "ac", "memory", "page", "pointer", "manager", "parents", "old", "it", "host", "function", "child", "address", "connection", "patch", "handler", "file", "part", "fat"], "dir": ["group", "cache", "out", "dict", "dec", "path", "Dir", " directory", "mod", "f", "config", "home", "ver", "wd", "per", "root", "po", "tree", "keep", "manager", "or", "build", "loc", "data", "folder", "object", "director", "ir", "directory", "base", "name", "url", "nav", "fd", "die", "container", "dr", "cur", "div", "dev", "di", "coll", "block", "iter", "def", "file", "part", "entry", "dis", "pkg", "id", "user", "db", "d", "doc", "rel", "dc"], "from": ["source", "form", "normal", "who", "so", "se", "out", "parse", "client", "path", "clean", "empty", "with", "this", "component", "link", "e", "one", "per", "vol", "po", "conn", "or", "get", "by", "data", "left", "con", "in", "ce", "self", "on", "io", "up", "flo", "find", "url", "base", "name", "bean", "low", "add", "pe", "code", "cr", "hand", "query", "address", "ch", "api", "without", "connection", "From", "stream", "range", "auto", "un", "file", "part", "o", "start", "can", "http"], "to": ["source", "tto", "top", "cache", "token", "TO", "out", "so", "output", "sync", "thro", "session", "tool", "ver", "with", "store", "page", "not", "via", "this", "per", "one", "po", "socket", "too", "about", "or", "by", "on", "io", "be", "flo", "url", "name", "b", "server", "until", "pi", "api", "see", "will", "connection", "two", "size", "To", "auto", "tom", "office", "value", "file", "temp", "made", "t", "key", "op", "o", "fat", "type", "db", "target", "co", "http"], "buffer": ["message", "position", "shape", "result", "length", "available", "memory", "buff", "buf", "page", "texture", "seed", "uffer", "border", "padding", "default", "read", "data", "duration", "total", "resource", "binary", "comment", "document", "character", "base", "device", "null", "server", "capacity", "pool", "transfer", "number", "address", "Buffer", "variable", "header", "channel", "queue", "layer", "batch", "reference", "iter", "block", "value", "row", "slice", "reader", "flush", "offset"], "bytes_read": ["es_used", "bytes_load", "bytes0write", "bytes0pass", " bytes_pass", "bytes_write", " bytes_received", "bytes___found", "bytes___read", " bytes_write", "bytes_pass", "keys___read", "bytes0read", "bytes_used", "keys_written", "bytes0received", "keys_found", "keys___found", "bytes_allow", "es_read", "bytes___written", "es_allow", "bytes_received", "bytes_written", "keys___written", "bytes_found", "keys_read", "es_load"]}}
{"id1": "9647576", "id2": "19235551", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"Reserve": ["Resolve", "Rolve", " Resolve", "Serve", "Rerves", "Rend", "Solve", "Rerve", "Resend", "Serves", " Reserves", "Reserves", " Resend", "Send"], "stbookings": ["ssbooksies", "ssbookings", "stbooksies", "stauthorifications", "ssbookies", "ssbookifications", "stBookies", "stbooksifications", "ssbooksings", "stbookies", "stBookalls", "stBookifications", "stauthories", "ssbooksifications", "stbookifications", "ssbookalls", "stbooksings", "stauthorings", "stBookings", "ssbooksalls", "stbookalls", "stauthoralls", "stbooksalls"], "stchartwl": ["st_ls", "STchartml", "stplotls", "STconfigml", "stconfigml", "stplotml", "st_wl", "STchartowl", "STconfigwl", "st_ml", "stconfigwl", "stplotowl", "stconfigowl", "stconfigls", "stchartml", "stplotwl", "STchartwl", "stchartowl", "st_owl", "STchartls", "STconfigls", "stchartls", "STconfigowl"], "sp": ["p", "text", "source", "tp", "span", "ps", "yp", "ss", "str", "mp", "session", "script", "isp", "rap", "spl", "page", "pl", "arp", "sg", "sil", "inst", "amp", " esp", "service", "bp", "email", "ip", "pace", "si", "name", "spr", "SP", "sc", "esp", "sl", "Sp", "sk", "scope", "ipp", "profile", "pr", "jp", "ap", " sc", "html", " SP", "space", "bsp", "spe", "pp", "op", "sf", " Sp", "type", "ig", "xml", "osp"], "userbooksql": ["userbookearch", "usersbookQL", "usersbooksearch", "userreadskl", "otherbookQL", "userordersQL", "userbanksil", "useraveskl", "otherbookql", "usersbooksprintf", "userreadsil", "userbookskl", "usersbooksql", "userbooksprintf", "userpagesqs", "userordersqs", "userpagesql", "userbooksQL", "userordersql", "useravesil", "userpagessql", "userorderssql", "userreadsprintf", "userlocksQL", "useravesql", "userreadsearch", "userbookprintf", "usersbookql", "usersbookprintf", "userbooksil", "userbookskel", "useraveskel", "usersbooksQL", "userbanksql", "userpagesQL", "userbookqs", " userbooksil", " useraveskl", "userbookQL", "userbooksqs", "userreadsql", "otherbooksQL", "otherbooksqs", "usersbookearch", " useravesql", "otherbookqs", "userreadsQL", "userlocksprintf", " userbookskel", "otherbooksql", " useraveskel", " userbookskl", "userbankskl", " useravesil", "userlocksql", "userreadskel", "userbookql", "userbooksearch", "userlocksearch", "otherbookssql", "userbookssql", "userbankskel"], "agentbooksql": ["userpagesci", "agentbooksci", "agentbooksqu", "agentpagesql", "userbooksli", "agentgroupssql", "agentbookssql", "agentpluginsQL", "agentgroupsql", "agentstylesql", "userpagesql", "userbooksQL", "agentstylesqu", "userpagessql", "agentgroupsQL", "userbooksil", "agentbookli", "agentbookQL", "agentpagesli", "agentpagesci", "userpagesQL", "userbooksqu", "agentpagesQL", "agentpagessql", "agentBooksql", "agentbooksQL", "agentBooksqu", "userbooksci", "agentgroupsli", "agentBooksil", "agentstylessql", "agentBookssql", "agentstylesil", "agentbookql", "agentpluginssql", "agentbooksil", "agentpluginsql", "agentbooksli", "userpagesli", "userbookssql", "agentpluginsci"], "bookingid": ["bookINGinfo", "booksingsname", "bookinginfo", "bookINGurl", "booksingsid", "bookINGname", "bookingurl", "bookillingid", "bookillinginfo", "booksingsinfo", "bookINGid", "bookillingurl", "bookingsurl", "bookingsname", "booksingname", "booksingurl", "booksingid", "bookingsid", "bookillingname", "booksingsurl", "booksinginfo", "bookingsinfo", "bookingname"], "currentcoach": ["currentlypoach", "currentCOam", "currentboach", "currentloached", "currentpoaching", "currentboache", " currentcoache", "currentcoached", "currentgoach", "currentCOach", " currentpoach", " currentcoah", "currentboached", "currentpoah", "currentnoache", "currentlycoaching", "currentchoac", "currentnoac", "currentcoache", "currentgoac", " currentloache", " currentcoached", "currentcoah", "currentlypoache", "currentchoach", "currentloach", " currentloached", "currentcoase", "currentgoaching", "currentnoaching", "currentchoam", "currentgoache", "currentcoaching", "currentcoam", "currentpoase", "currentloache", "currentboah", " currentloah", "currentCOase", " currentpoac", " currentcoac", " currentcoam", "currentchoase", "currentpoach", " currentpoam", "currentpoac", "currentpoache", " currentpoase", "currentlycoac", "currentCOac", "currentcoac", "currentnoach", "currentloah", "currentpoached", "currentlypoaching", "currentlypoac", " currentcoase", "currentpoam", " currentloach", "currentlycoach", "currentlycoache"], "currentseat": [" currentseason", "currentlyseason", "currentcomponent", "currentticket", "activecourse", " currentcomponent", " currentcourse", "currentlyslave", "Currentcourse", "currentseason", "Currentseason", "Currentticket", " currentslave", "Currentcomponent", "activeticket", "Currentsex", "currentlyseat", "currentslave", "currentsex", "currentlysex", "currentcourse", " currentsex", " currentticket", "activeseat", "Currentseat", "Currentslave", "activecomponent"], "tickpos": ["ickpo", "trialpos", "ickPos", "tickpo", "helloPOS", "tickPos", " tickposition", "ickpointer", "crosspos", "ickpose", "tickpointer", "tickpose", "ickpos", "trialpose", "helloPos", "hellopointer", " tickPOS", " tickpo", "hellopos", " tickPos", "ickerpos", "trialPOS", "crossPos", "ickposition", "stickpos", "ickerposition", "tickPOS", " tickpose", "trialPos", "stickposition", "ickPOS", "crosspo", "helloposition", "stickPos", "ickerPos", "tickposition", "ickerpointer"], "chartavailupdsql": ["chartavailupdsqs", "chartavailupsssql", "chartavailupcssql", "chartavailumpdsql", "chartavailupssqs", "chartavailupdssql", "chartavailupssql", "chartavailupcsql", "chartavailupdatesql", "chartavailumpssqs", "chartavailumpdssql", "chartavailupcsqs", "chartavailupdatessql", "chartavailumpdsqs", "chartavailumpsssql", "chartavailumpssql", "chartavailupdatesqs"]}}
{"id1": "494226", "id2": "536614", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"linesep": [" linespace", "linyp", "linseps", "linesupp", " linespec", "nseps", "linerspec", "linsep", "linespace", "ineseper", "codesew", " lineseps", "timespe", "linerseps", "linep", "linersep", "lineseps", "gesep", "linerseter", "linespec", "timeseps", "linpace", "lineseng", "linerseng", "codesip", "linespe", "nseper", "linesew", "linedew", "gesyp", "linesip", "lineseper", "linspec", " linesaper", "ringspec", "linesaper", "gespe", "nsep", "inesaper", "lineps", "linseter", "linspace", "linesyp", "lineeps", "linsew", "ringspace", "timesep", "linesearch", "linersip", "lineep", "ineseps", "lineearch", "linedep", "linpe", "ringsep", "lineseter", "linersew", "linedip", "inesep", " lineseter", " linesew", "linepace", " linesearch", "linepec", "linseng", "codesep", "codeseps", "timesyp", " lineseper", "lineupp", "geseps", "linersearch", "linedeps", "ringsupp", "linpec", " lineseng", "nsaper", " linesupp"], "fos": ["foS", " foser", "Fats", "FOS", " fops", "pos", "Fes", "zol", " fats", "pols", "Fis", " foes", "zos", "gocks", "fios", "Foser", "zotes", " fios", "poos", "fes", "go", "forOS", "fingocks", "infos", "eol", " foses", "infios", "loados", "Fo", "info", "coos", "foos", "fol", "fingos", "infis", "cols", " fes", "infoos", "fo", "infotes", "cos", "fulloes", "Focks", "infols", "fulloser", " foS", "Fios", "loadops", "fols", "foros", " fOS", " fis", "foss", "foes", " fOs", "Foss", "infoes", "foser", "FOs", "forats", "Fos", "gos", "zo", "eos", "fis", "fullis", "fOS", "fats", "foses", "Foes", "coes", "FoS", "foroses", "infops", "Foses", "infoses", "Fops", "goss", "poes", "loadoS", "fotes", " fo", "eotes", "fingo", "fingoss", "fullos", "infes", "loadOs", "infol", "fops", "fOs", "eo", "focks"], "files": ["ls", "workers", "tests", "rules", "tools", "apps", "locks", "lines", "jobs", "bugs", "keys", "f", "groups", "scenes", "l", "services", "books", "projects", "resources", "balls", "data", "iles", "names", "strings", "lets", "archives", "objects", "boxes", "docs", "thumbnails", "fs", "facts", "members", "bs", "features", "Files", "ins", "models", "states", "pages", "plugins", "users", "file", "headers", "results", "obs", "items", "classes", "ports", "blocks", "events", "ids", "images", "rows", "http"], "i": ["p", "uri", "current", "z", "inner", "c", "f", "ai", "gi", "ii", "info", "ix", "e", "d", "ie", "I", "count", "ci", "yi", "m", "ini", "multi", "ip", "iu", "io", "si", "b", "u", "it", "col", "ui", "pi", "oi", "ji", "index", "li", "j", "hi", "di", "qi", "eni", "y", "xi", "fi", "t", "slice", "id", "type", "v", "start", "ri", "ti", "phi"], "metaprops": ["metapprop", "metaprop", "metoprops", "metapPropps", "metapprope", "metaprobpe", "metopropp", "metaprobps", "metoppropps", "metaprobpps", "metaprobpp", "meteprope", "metaprobpes", "metepprope", "metoprope", "metaprps", "metaprospps", "metepropps", "metaparpps", "metapprops", "metopropps", "metopproperties", "metoppropes", "metaporepe", "metappropps", "metapPropes", "metaprobp", "metapropp", "meteppropes", "metaprpes", "metoppropp", "metopprop", "metopropes", "metaprosps", "metaparpp", "meteppropps", "metapPrope", "metopprops", "metoproperties", "metappropp", "metapropps", "metaporeps", "metapproperties", "metaparp", "metepropes", "metaprobperties", "metaprosperties", "metaprope", "metaporepes", "metaprpe", "metaparps", "metappropes", "metapropes", "metapProps", "metaporepps", "metaproperties", "metoprop", "metepprops", "metaprospes", "meteprops", "metaprpps", "metopprope"], "itsect": ["litrupt", "itsection", "itssect", "itrupt", "itect", "Itna", " itrupt", "Itsection", "itssection", "iterconnect", "Itsect", "Itsector", "itersect", "iterect", "Itect", "litsect", "iterrupt", " itsection", " itect", " itconnect", "litna", " itna", "itsector", "itconnect", "itssector", "Itconnect", "litect", "itna", "Itrupt", " itsector"], "section": ["account", "text", "closure", "sector", "set", " sections", "script", "config", "environment", "page", "ection", "ie", "area", "line", "loc", "year", "service", "sect", "ect", "description", "division", "job", "sections", "name", "sec", "array", "search", "sub", "function", "child", " subsection", "rc", "j", "header", "string", "esc", " Section", "element", "mission", "second", "protection", "version", "edition", "part", "step", "key", "route", "entry", "ion", "vision", "Section"]}}
{"id1": "3375724", "id2": "11933797", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitULosFe", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitulosFe", " importarEmissoresDosTituloF", " importarEmissoresDosTitulosf", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitularF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitulof", " importarEmissoresDosTituloFe", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTituloPF", " importarEmissoresDosTitulasF", " importarEmissoresDosTitULoPF", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitularf", " importarEmissoresDosTitulasf", " importarEmissoresDosTitulosF", " importarEmissoresDosTitulosPF", " importarEmissoresDosTitulasPF"], "pArquivoTXT": ["pArquivoBEMP", "pArquivaTxt", "pArquivTxt", "pArquivoFEXT", "pArquivoBLS", "pArquivoOTXT", "pArquivoOTTP", "pArquivDBT", "pArquivoLXT", "pArquivDXT", "pArquivoFxt", "pArquivTLS", "pArquivaTXT", "pArquivoTEMP", "pArquivaTBT", "pArquivoTBT", "pArquivaFEMP", "pArquivaFTP", "pArquivoBXT", "pArquivTBT", "pArquivoBTP", "pArquivaFXT", "pArquivaTTP", "pArquivoQXT", "pArquivDLS", "pArquivoTLS", "pArquivoQBT", "pArquivoFTP", "pArquivDxt", "pArquivTXT", "pArquivoBBT", "pArquivaTEMP", "pArquivoDLS", "pArquivoLBT", "pArquivoLLS", "pArquivoOTEMP", "pArquivoFXT", "pArquivaFEXT", "pArquivoDxt", "pArquivoQxt", "pArquivaFxt", "pArquivaTEXT", "pArquivoBxt", "pArquivoLxt", "pArquivoTxt", "pArquivoTTP", "pArquivoDXT", "pArquivoOTxt", "pArquivoDEXT", "pArquivoFEMP", "pArquivoTEXT", "pArquivoDBT", "pArquivaFBT", "pArquivoFBT", "pArquivoQEXT"], "pAndamento": [" pAndmentoo", " pAndementO", " pOramentoo", " pAndentionO", " pOrementO", " pOrementoo", " pAndamentO", " pAndentionoo", " pOramentos", " pOramento", " pAndamentos", " pAndmento", " pAndemento", " pAndamentoo", " pAndmentO", " pAndentionos", " pAndmentos", " pOrementos", " pAndentiono", " pAndementoo", " pAndementos", " pOremento", " pOramentO"], "numeroDoRegistro": ["numeroDoregestros", "numeroDoRegiftro", "numeroDoRegestros", "numeroDoRegistrano", "numeroDoregestro", "numeroDoregistrano", "numeroDoRegestro", "numeroDoRegpectro", "numeroDoRegiftrano", "numeroDoregistorno", "numeroDoregistros", "numeroDoRegestrano", "numeroDoRegpectros", "numeroDoregistro", "numeroDoregestorno", "numeroDoRegistros", "numeroDoRegestorno", "numeroDoRegiftorno", "numeroDoRegpectorno", "numeroDoRegiftros", "numeroDoregestrano", "numeroDoRegpectrano", "numeroDoRegistorno"], "in": ["ln", "span", "inn", "out", "session", "c", "f", "config", "s", "with", " out", "ex", "i", "l", "IN", "data", "m", "con", "ini", "ner", "n", "g", "bin", "url", " IN", "b", "is", "query", "nin", "conf", "ins", "connection", "cin", "scan", "cl", "In", "again", "rin", "kin", "part", "err", "r", "t", "login", "slice", "reader", "inc"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialCombario", "stmtLimpezaInicialDestario", "stmtLimpezaInicialCombania", "stmtLimpezaInicialdestario", "stmtLimpezaInicioDestario", "stmtLimpezaInicioCombario", "stmtLimpezaInicialdestino", "stmtLimpezaInicialDesaco", "stmtLimpezaInicialDestao", "stmtLimpezaIniciaDestination", "stmtLimpezaInicioDestino", "stmtLimpezaInicioCombao", "stmtLimpezaInicioCombino", "stmtLimpezaIniciaDestania", "stmtLimpezaInicialdestao", "stmtLimpezaInicialDesao", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombao", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDestination", "stmtLimpezaInicialDesario", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestaco", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestania", "stmtLimpezaInicialdestania", "stmtLimpezaInicioDestao"], "sql": ["ls", "eps", "software", "filename", "result", "sb", "util", "json", "csv", " SQL", "kl", "ql", "s", "seed", "cmd", "sg", "sol", "expr", "l", "socket", "install", "data", "sys", "nl", "lua", "where", "dl", "comment", "statement", "description", "shell", "url", "log", "SQL", "search", "spec", "params", "setup", "rl", "msg", "stat", "sl", "query", "zip", "body", "term", "string", "fn", "details", "el", "sq", "acl", "html", "sn", "QL", "err", "ssl", "sf", "id", "sv", "layout", "db", "select", "liquid", "http"], "stmtDestino": ["stmtDistino", "stmtCamporno", "stmCamporno", "stmtDistaco", "stmtdestorno", "stmCampino", "stmtDestaco", "stmtDestorno", "stmtDestin", "stmtCampania", "stmtdestinos", "stmCampaco", "stmCampania", "stmtCampaco", "stmdDestorno", "stmtDistin", "stmtDestinos", "stmtdestania", "stmtDistorno", "stmDestania", "stmtdestaco", "stmtDistinos", "stmtdestin", "stmtCampino", "stmdDestinos", "stmdDestin", "stmDestorno", "stmdDestino", "stmtDestania", "stmDestino", "stmDestaco", "stmtDistania", "stmtdestino"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABECALSHI", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABECALLHOU"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPJTO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAPE_TO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADANDOSAD", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADADIES___"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_EGIS", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_POR_RegIES", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_RegIS"], "tamanhoDosArquivos": ["tamanhoDosArqIVlos", "tamanhoDosArQUivos", "tamanhoDosArquivalos", "tamanhoDosArqIVo", "tamanhoDosArQUivo", "tamanhoDosArquievOs", "tamanhoDosArqIVoes", "tamanhoDosArquivaloes", "tamanhoDosArquivalo", "tamanhoDosArquIVos", "tamanhoDosArquIVoes", "tamanhoDosArquivOs", "tamanhoDosArquivoes", "tamanhoDosArquervlos", "tamanhoDosArquervoes", "tamanhoDosArQUervlos", "tamanhoDosArQUivlos", "tamanhoDosArqivos", "tamanhoDosArquIVo", "tamanhoDosArquIVOs", "tamanhoDosArquIVlos", "tamanhoDosArQUervos", "tamanhoDosArquievos", "tamanhoDosArquervo", "tamanhoDosArqivo", "tamanhoDosArquivo", "tamanhoDosArquivallos", "tamanhoDosArquivlos", "tamanhoDosArquievo", "tamanhoDosArquervos", "tamanhoDosArqivoes", "tamanhoDosArquervOs", "tamanhoDosArQUervOs", "tamanhoDosArqivlos", "tamanhoDosArQUivOs", "tamanhoDosArquievlos", "tamanhoDosArQUervo", "tamanhoDosArqIVos"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimmada"], "registro": ["regastros", "regastration", "regustros", "registros", "regestro", "regustro", " regestro", " registulo", " regestros", "regustulo", " regestration", " regestulo", "regestros", " registros", "regestration", "regustration", "regastulo", "registration", "regastro", "regestulo", " registration", "registulo"], "campos": ["CampOS", " campas", " caso", "Campo", "Campas", " campOS", "campOS", "campo", " campo", " casos", "Campos", " casOS", "campas", " casas"]}}
{"id1": "12055086", "id2": "9449064", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeleing", " copyDeleging", " copyDeleteing", " copyDeleing", " copydeleter", " copydeleting", " copyDeletting", " copyDeleter", " copyDeletter", " copyDeleteting", " copyDequeter", " copyDeletging", " copydeletter", " copyDequeging", " copydeletting", " copyDeleteging", " copyDequeting", " copyDeleteter", " copyDequeing", " copydeletging", " copydeleging"], "source": ["remote", "copy", "cache", "path", "inner", "f", "config", "s", "archive", "view", "master", "use", "e", "ie", "i", "input", "ources", "ource", "src", "image", "sin", "SOURCE", "down", "Source", "service", "from", "resource", "storage", "base", "connection", "stream", "iter", "file", "route", "site", "reader", "target"], "dest": ["flat", "result", "path", " destination", "home", "master", "slave", "de", "trans", "src", "default", "folder", "done", "destruct", "later", "img", "class", "tmp", "null", "die", "destroy", "dist", "comb", "thin", "exit", "orig", "desc", "file", "temp", "wb", "Dest", "dir", "slice", "pipe", "bin", "opt", "target", "content"], "buf": ["cv", "bh", "buffer", "result", "uf", "seq", "port", "uc", "length", "br", "bag", "feat", "config", "pad", "buff", "fb", "len", "bytes", "cmd", "txt", "src", "pos", "ff", "loc", "data", "bp", "bf", "img", "base", "tmp", "bc", "b", "code", "append", "Buffer", "rc", "rb", "cp", "queue", "raw", "batch", "off", "vec", "feed", "ctx", "cb", "bd"], "in": ["p", "init", "inn", "gin", "pin", "inner", "c", "f", "plus", "i", "input", "src", "inside", "conn", "sin", "socket", "image", "read", "IN", "data", "con", "win", "ini", "up", "n", "isin", "io", "url", "din", "b", "is", "exec", "nin", "min", "ins", "thin", "stream", "In", "inc", "again", "rin", "file", "login", "id", "reader", "bin", "tin"], "out": ["app", "buffer", "output", "client", "sync", "inner", "f", "at", "w", "ex", "i", "socket", "conn", "OUT", "image", "down", "writer", "win", "img", "n", "io", "bin", "up", "b", "outer", "ext", "exec", "obj", "pool", "exp", "Out", "outs", "again", "file", "lib", "part", "err", "o", "parent", "inc"], "count": ["buffer", "cache", "current", "depth", "length", "path", "c", "f", "all", "len", "use", "max", "val", "read", "ind", "close", "n", "limit", "base", "name", "b", "num", "allow", "code", "pool", "number", "zip", "child", "ch", "index", "size", "cond", "Count", "lock", "coll", "sum", "weight", "part", "key", "feed", "id", "type", "parent", "start", "handle", "offset"]}}
{"id1": "9796161", "id2": "16063533", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"getMD5": ["getmd4", "getmd512", "getmdHash", "getHTML5", "getMD4", " getMDHash", "getHTML512", "getSHAHash", "getSHA4", "getSHA512", " getSHA4", "getHTMLHash", " getSHAHash", " getSHA5", "getMDHash", "getmd5", "getMD512", "getHTML4", " getMD512", " getSHA512", "getSHA5", " getMD4"], "s": ["p", "ls", "source", "tests", "parts", " fails", "cs", "sb", "ps", "ts", "ss", "str", "lines", "sync", "ends", "styles", "c", "ips", "f", "its", "als", "sym", "bytes", "e", "i", "input", "l", "services", "ds", "data", "in", "strings", "rs", "ws", "self", "n", "g", "a", "si", "ses", "ms", "b", "os", "is", "ates", "bs", "string", "scripts", "gs", "ings", " ads", "sets", "ns", "ows", "es", "abs", "ssl", "comments", "S", "v", "js"], "m": ["p", "me", "mand", "hm", "mut", "md", "im", "mm", "c", "f", "mr", "e", "i", "M", "dm", "l", "manager", "fm", "nm", "module", "mac", "em", "v", "rm", "sm", "ms", "vm", "um", "man", "gm", "tm", "h", "om", "machine", "mi", "bm", "arm", "cm", "am", "wm", "mc", "t", "mu", "ym", "pm", "d"]}}
{"id1": "22993368", "id2": "8932510", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "13852596", "id2": "338852", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "label": 0, "substitutes": {"execute": ["call", "create", "copy", "parse", "ute", "invoke", "load", "all", "process", "install", "evaluate", "server", "code", "exec", "transfer", "report", " invoke", " perform", "Exec", "submit", "test", "register", "apply", "start", "handle", "run"], "resources": ["relations", "workers", "types", "rules", "chains", "apps", "locks", "writers", "groups", "issues", "services", "projects", "strings", "resource", "cells", "flows", "archives", "works", "rings", "objects", "series", "thumbnails", "params", "files", "stores", "reports", "features", "models", "pages", "scripts", "plugins", "users", "rates", "results", "Resources", "items", "maps", "classes", "ions", "events", "ids", "stars", "images", "roots"], "i": ["p", "ani", "uri", "ai", "f", "gi", "ii", "info", "ori", "s", "e", "vi", "ie", "l", "I", "k", "wei", "ci", "abi", "ini", "we", "ami", "ir", "multi", "ip", "iu", "bi", "io", "si", "ti", "u", "is", "ui", "pi", "oi", "isi", "j", "li", "iri", "h", "hi", "di", "qi", "eni", "xi", "cli", "mu", "o", "id", "v", "esi", "ri", "ic", "phi"], "classFile": ["classFILE", "ruleLine", "staticfile", "classEntry", "CLASSFile", "connectionFile", "sessionFILE", "ClassGlobal", "customEntry", "sessionFile", "classClass", "Classfile", "filefile", "lassFiles", " classFILE", " classPage", "baseFile", "lassClass", "lassGlobal", "fileFiles", "finalFILE", "serviceLine", "CLASSEntry", "classGlobal", "staticFILE", "packEntry", "fileLoader", "CLASSFILE", "connectionfile", "ClassFactory", "ClassPage", "ClassImage", "sessionfile", " classEntry", "finalfile", "CLASSLoader", " classLoader", "ClassFiles", "baseUrl", "classLoader", "ClassClass", "customFILE", "classfile", "ClassFilename", "servicefile", "staticLine", "classesPath", "objectFiles", "ClassEntry", "objectfile", " classFiles", "classFactory", " classLine", "finalUrl", "ClassDir", " classGlobal", "classImage", "fileImage", "packFile", "classFiles", "ruleFile", "classPage", "classUrl", "ClassStream", "classesFile", "packFILE", "fileFile", " classFactory", " classStream", "classesFiles", "finalFile", "classStream", "CLASSLine", "classesfile", "classDirectory", "classPath", "classDir", " classFilename", "sessionEntry", " classClass", "CLASSDirectory", "connectionFiles", "baseFILE", "ruleFiles", "customFiles", " classDir", "ruleFilename", "CLASSfile", "ClassFile", "packfile", "serviceFile", "customFile", "classFilename", "CLASSImage", "ClassPath", "ClassLine", "fileDirectory", "basefile", "ClassDirectory", "fileLine", "staticFile", "sessionFactory", "CLASSUrl", "CLASSPage", "CLASSFiles", "objectDir", "classLine", "lassFile", "connectionStream", "objectFile", "sessionFiles", " classPath", " classfile", "serviceFILE", "ClassFILE"], "inputStream": ["InputFile", "initSteam", "InputStreamer", "uploadstream", "binaryFile", "importSteam", "inputContext", "outputStreamer", " inputstream", "rawFile", "inputFile", "importStream", "childstream", "inputSw", "childContext", "activeSteam", "outputContext", "binaryStream", "activeStream", "outputReader", "childStream", "uploadStream", "Inputstream", "rawStream", "activeStreamer", "rawSteam", "initStreamer", "inputReader", "inputstream", "InputStream", "outputSw", "InputSw", "importStreamer", "uploadSw", " inputFile", "InputSteam", "binaryStreamer", "inputStreamer", " inputStreamer", " inputSteam", "outputstream", "inputSteam", "rawStreamer", "childReader", "outputFile", "uploadFile", "importstream", "activestream", " inputContext", "initStream", "outputSteam", "initstream", " inputReader", "binarySteam"], "reader": ["source", "arser", "rx", "buffer", "copy", "writers", "re", "client", "reading", "sync", "inner", "author", "system", "rr", "seed", "driver", "ler", "per", "rar", "input", "owner", "manager", "war", "draft", "shared", "or", "read", "riter", "loader", "ner", "oder", "resource", "builder", "director", "ger", "Writer", "io", "editor", "reflect", "rer", "server", "book", "dr", "rc", "worker", "handler", "stream", "ee", "layer", "wrapper", "parser", "Reader", "iter", "request", "row", "key", "er", "entry", "keeper", "right", "ri", "report", "context", "http"], "oldSize": ["OldName", "oldName", "OldSc", " oldSc", "oldLength", "prevSize", "prevLength", "prevSc", " oldName", "prevName", "OldSize", " oldLength", "OldLength", "oldSc"], "writer": ["wer", "buffer", "writers", "token", "widget", "wire", "inner", "author", "written", "w", "driver", "ler", "writing", "word", "e", "war", "manager", "draft", "read", "riter", "data", "ner", "loader", "service", "resource", "builder", "format", "director", "object", "Writer", "oder", "walker", "editor", "io", "document", "player", "writ", "wr", "child", "index", "worker", "string", "rw", "handler", "element", "ee", "write", "wrapper", "winner", "parser", "iter", "creator", "Reader", "maker", "row", "r", "er", "her", "engine", "report", "dc"], "b": ["p", "ab", "buffer", "bar", "br", "abc", "c", "f", "bb", "fb", "ba", "w", "e", "pb", "l", "k", "B", "m", "object", "binary", "lb", "be", "g", "a", "base", "u", "null", "rb", "db", "h", "eb", "emb", "r", "ob", "boot", "bin", "orb", "d", "bd"], "outputStream": [" outputView", "OutputStream", "outstream", "protectedSteam", "OutputStreamer", "OutputSteam", "Outputstream", "OutputView", "outputStreamer", " outputSteam", "inputstream", "protectedStream", "protectedStreamer", "protectedstream", "dataStream", "dataStreamer", "outputContainer", " outputStreamer", "outStreamer", "inputStreamer", "inputView", "outputstream", "outSteam", "inputSteam", " outputContainer", "dataSteam", "outStream", " outputstream", "outputView", "inputContainer", "outputSteam", "dataContainer"], "injectedClasses": ["injectedWrites", "injectedClassies", "injectionClasses", "injectedClassites", "injectedclassies", "injectionclassites", "injectedWrits", "injectionClassies", "injectedProjectes", "injectionclasss", "injectedclassites", "injectedclasses", "injectionclassies", "injectedWritites", "injectionClassites", "injectedProjectites", "injectionclasses", "injectedProjecties", "injectedWrities", "injectedProjects", "injectionClasss", "injectedclasss", "injectedClasss"], "newSize": ["NewStorage", "finalSize", "NewSize", " newLength", "newStorage", "newFontSize", "finalStorage", " newFontSize", "finalFontSize", "finalLength", " newStorage", "newLength", "NewFontSize", "NewLength"]}}
{"id1": "6371607", "id2": "20208819", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"removeRealm": ["delRealm", "removeLocalM", "delBroadms", "delBroadm", "deleterealm", "removeLocalm", "deleterealM", "removeRelM", "removeRelms", "delBroadme", "deleteRealM", "removeSchems", "deleterealms", "deleteRealam", "removeScheme", "removeBroadM", "removeLocalms", "removerealM", "delRealme", "removeRealM", "removerealam", "removeRealms", "removeBroadms", "removerealm", "removeRealam", "deleteRealms", "deleteRealm", "removeRealme", "removeScheM", "delBroadM", "removerealms", "removeSchem", "removeBroadm", "removeBroadme", "delRealM", "removeLocalam", "removerealme", "deleterealam", "delRealms", "removeRelam", "removeRelm"], "realmIds": ["realmPaths", "realmRefids", "realmInts", "realmIdes", "realMPathids", "realmIdls", "realMIdos", "realMIdes", "realMPaths", "realmRefs", "realmPathids", "realMByIds", "realmPathes", "realMIdls", "realmIdList", "realMByIdls", "realmByIdList", "realMIdids", "realmIdids", "realmIntes", "realmByIdes", "realMPathes", "realmRefList", "realmIDs", "realMIds", "realmByIdls", "realmRefes", "realmIdos", "realMIdList", "realmIntos", "realmIntids", "realMByIdList", "realmIDls", "realmByIds", "realmRefls", "realMByIdes", "realmIDList", "realmIDes", "realmPathos", "realmRefos", "realMPathos"], "psImpl": ["csimpl", "epsHelper", "psIter", "qsHelper", "psHelper", "cssIter", " psIter", "csImpl", "epsimpl", "qsImpl", "epsIter", "qsimpl", "cssExpl", " psHelper", "dsHelper", "epsImpl", "psExpl", "cssimpl", "psimpl", " psExpl", " psimpl", "cssImpl", "dsimpl", "epsExpl", "dsImpl", "csHelper"], "iter": ["itter", "init", "parse", "apper", "inner", "finder", "ite", "ter", "page", "cher", "e", "i", "ie", "ler", "enter", "upper", "gener", "line", "loc", "ner", "walker", "in", "ir", "limit", "next", "it", "izer", "outer", "Iter", "ator", "index", "list", "former", "coll", "el", "cer", "sort", "loop", "err", "er", "entry", "end", "reader", "inter", "iterator", "inc"], "realmId": ["realmnConfig", "realmPath", "realfID", "realarmID", "realdmOffset", "ironmaID", "ironmaId", "RealmsID", "RealmId", "realmInt", "realfid", "RealmPath", "realmaRef", " realmnHash", " realmnConfig", "realdmId", "workfId", "realmaID", "realmID", "realmHash", "ironmID", "realfId", "realarmPath", "realarmId", " realmConfig", "realmeId", "realamId", "realdmConfig", "realmsId", "realamID", " realmnOffset", "workmNum", "realmaInt", "workfNum", "realmsName", "RealmID", "realmaId", "realmrID", "ironmaInt", "realmid", "realmnId", "realrmId", "ironmRef", " realmnId", "realmcInt", "realrmInt", "realfNum", "realmName", "realmNum", "realmeName", "realmrId", "workfID", " realmOffset", "realmrOffset", "realmcId", "realmsID", "realmsPath", "RealmsId", " realmHash", "realarmName", "realmrHash", "realamNum", "realmcID", "realmePath", "realmeID", "RealmsName", "realmConfig", "realmOffset", "realmrid", "realmrConfig", "realamid", "ironmId", "realdmHash", "realrmID", "ironmInt", "RealmsPath", "realmrNum", "ironmaRef", "workfid", "realmnHash", "workmid", "realmnOffset", "RealmName", "workmID", "realmRef", "realrmRef", "workmId", "realmcRef"]}}
{"id1": "20939940", "id2": "17116123", "code1": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"createJavaProject": ["getjavaFolder", "createJavaFolder", "createJSProject", "createjavaFolder", "getJavaApplication", "createjavaApplication", "getjavaProject", "createRubyFolder", "createJavaConnector", "getjavaConnector", "getJavaFolder", "getJavaProject", "createjavaConnector", "createJavaApplication", "createjavaProject", "createJSApplication", "getJavaConnector", "createJSConnector", "createJSFolder", "createRubyConnector", "createRubyApplication", "getjavaApplication", "createRubyProject"], "proj": ["suk", "perjp", "PROz", " prob", "project", "upJ", "upj", "projp", "produjo", "produuj", " probj", "conjc", " proJ", "perj", "produjc", "produjs", "PROJ", "pejp", " project", "conJ", "cojo", "Prok", "propje", "pez", "rouj", "prouj", "parj", "suje", " proaj", "profjs", "Proz", "ProJ", "roud", "cobj", "coj", "projs", " projs", "produjp", "Prod", "prob", "perjs", "projo", "roujs", "rouaj", "promj", "conjp", "propjo", "projet", "proJ", "profJ", "prejo", "sujet", " projo", "produJ", "roujc", "Proaj", "proje", "parb", "profject", "promz", "Prouj", "propjet", "peJ", "Projp", "proaj", " proje", "coJ", "suz", "upbj", "prej", "produb", " projp", "pej", "Projc", "profj", "PROjp", "Projs", "conj", " prouj", "parjc", "prod", "sujo", "proz", "projc", "parjet", "preuj", "upjo", "propj", " projc", "rouJ", "produjet", "pejo", "promjo", "suj", "suuj", "prok", "perJ", "PROj", "perz", "promjp", "prez", "Proj", " projet", "Projo", "perject", "probj", "produj", "produz", " prok", " prod", " proz"], "desc": ["text", "attr", "rec", "summary", "str", "out", "Desc", "dec", "config", "info", "txt", "de", "ca", "Description", "loc", "des", "dep", "comment", "description", "sup", " description", "name", "sec", "asc", "obj", "sub", "sc", "dist", "rc", "neg", "struct", "esc", "div", "dev", "details", "def", "anc", "pro", "id", "contract", "doc", "dc"], "javaProject": ["javaApp", "rubyFolder", "pythonServer", " javaPlugin", "JavaModule", "nativeProject", "jarProject", "javaModule", " javaServer", "jaUnit", " javaModule", "jarModule", "javaFolder", "pythonFolder", "pythonProject", "nativePlugin", "javaUnit", "jaFolder", "rubyApp", " javaFolder", "pythonModule", "JavaFolder", "JavaApp", "jarFolder", " javaApp", "jaModule", "JavaPlugin", "rubyUnit", "jarServer", "nativeApp", "javaServer", "rubyProject", "jaProject", "javaPlugin", "JavaProject", "JavaUnit", " javaUnit", "nativeFolder"], "srcFolder1": ["srcPath1", "srcPath2", "srcDirectory0", "srcFile1", "rcDirectory2", "rcDirectoryOne", "rcFolder2", "rcDirectory81", "rcFolder0", "srcDirectory2", "srcPath0", "rcDirectory0", "srcLocation2", "srcLocation0", "srcDirectory81", "srcFolderOne", "srcFileOne", "rcFolder81", "srcfolder2", "srcFolder81", "srcFile81", "srcFile2", "srcPathOne", "srcfolder81", "srcDirectoryOne", "srcfolderOne", "srcLocation1", "srcFolder0", "rcFolderOne", "srcfolder0", "rcDirectory1", "srcDirectory1", "srcfolder1", "rcFolder1"], "srcFolder2": ["srcFile1", "srcfolderTwo", "rcDirectory2", "srcDirectory4", "rcFolder2", "srcfolder5", "srcDirectory2", "srcfolder4", "srcArea2", "srcFile5", "rcFolder4", "srcDirectoryTwo", "rcFolder5", "srcFileTwo", "srcArea4", "srcfolder2", "srcFile2", " srcfolder4", "rcDirectory4", "srcAreaTwo", " srcFolder4", " srcfolder2", "srcFolderTwo", " srcfolderTwo", "srcFolder4", "rcDirectoryTwo", "srcArea1", " srcfolder1", "rcDirectory1", "srcFolder5", "srcDirectory1", "srcDirectory5", "rcFolderTwo", "rcDirectory5", " srcFolderTwo", "srcfolder1", "rcFolder1"], "classpathEntries": ["classnameEntries", "classpathEnrs", "classpathEntryEntry", "classpathEnries", "classpathEntryrs", "classPathAddrys", "classnameEntrs", "classpathEntrs", "classnameEntrys", "classpathAddEntry", "classpathentEntry", "classnameEnories", "classnameEnrs", "classpathEntories", "classPathAddEntry", "classpathAddry", "classpathEntryries", "classpathentrys", "classnameEntories", "classnameEnrys", "classpathEnories", "classpathentry", "classpathAddrys", "classpathentrs", "classnameEnries", "classPathAddries", "classPathAddry", "classpathEntryry", "classPathEntry", "classpathEnrys", "classPathEntrys", "classPathEntries", "classpathentries", "classpathEntEntry", "classPathEntEntry", "classpathAddries", "classpathEntryories", "classpathEntryrys", "classpathEntry", "classpathentories", "classpathEntrys"], "binFolder": ["baseProject", "baseLoader", " binLoader", "winDirectory", "binaryfolder", "binLoader", "winUrl", "workDir", " binfolder", "basefolder", "binaryProject", " binLoop", "resultfolder", "workfolder", "binaryFolder", "resultLoop", "winfolder", "binUrl", "baseDir", "binaryDir", "binDirectory", "binProject", "binaryUrl", " binDirectory", "resultUrl", "binaryLoader", "workFolder", "binDir", "binaryDirectory", "baseFolder", "workProject", "winFolder", " binUrl", "binLoop", "binaryLoop", "binfolder"], "testFolder": ["resultPath", "matchPath", "mainLoop", "matchFolder", "testPath", "testfolder", " testOrg", "resultfolder", " testfolder", "resultLoop", "matchOrg", "mainFolder", " testPath", "resultDirectory", "mainfolder", " testLoop", "mainDirectory", "testDirectory", " testDirectory", "testOrg", "resultOrg", "testLoop"], "resultFolder": ["resultPath", " resultLayer", "testLayer", "testfolder", "testSection", "messageFolder", "testingSection", "resultfolder", "testingfolder", "returnLayer", "testingLayer", "ResultLayer", " resultSection", "ResultFolder", "messageLayer", "resultLayer", " resultfolder", "testingFolder", "messagePath", "resultDirectory", "returnPath", "ResultDirectory", "returnFolder", "ResultPath", "returnDirectory", "resultSection", "messageDirectory"]}}
{"id1": "1097146", "id2": "6987642", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessageDigests", "getMessageEncest", "getMessageDigester", "getMessageEncests", "getMessageEncester", "getContentDigifier", "getContentdigest", "getMessageSignester", "getMessageDigifier", "getContentDigester", "getContentdigifier", "getMessagedigifier", "getMessagedigests", "getContentDigest", "getContentdigester", "getMessagedigester", "getContentDigests", "getMessagedigest", "getMessageEncifier", "getMessageSignifier", "getContentdigests", "getMessageSignests", "getMessageSignest"], "input": ["text", "source", "form", "message", "buffer", "output", "str", "out", "parse", "empty", "inner", "instance", "config", "this", "model", "state", "plus", "Input", "i", "image", "data", "amp", "definition", "in", "argument", "object", "context", "binary", "self", "accept", "document", "inf", "array", "null", "password", "address", "container", "string", "list", "now", "target", "stream", "element", "submit", "raw", "temp", "request", "reader", "type", "parent", "xml", "audio", "content"], "md": ["me", "mand", "mm", "mp", "mod", "amd", "wd", "cmd", "M", "dm", "mb", "meta", "mg", "m", "nm", "metadata", "mad", "mac", "bf", "rm", "sm", "ms", "vd", "um", "sha", "gd", "dr", " MD", "od", "mn", "dd", "di", "cm", "mo", "mt", "bm", "am", "MD", "mc", "ma", "df", "mag", "pm", "d", "rpm", "bd", "dc"], "bytes": ["parts", "bles", "Bytes", "units", "words", "lines", "bits", "keys", "s", "its", "seconds", "groups", "vals", "les", "data", "ipes", "strings", "binary", "bps", "odes", "values", "pieces", "base", "b", "null", "ies", "files", "bs", "address", "body", "string", "gb", "pages", "codes", "outs", "es", "tes", "classes", "blocks", "rows"]}}
{"id1": "11477906", "id2": "6171406", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationConfiguration", "getDefaultParameters", "loadApplicationSettings", "getDefaultConfiguration", "getdefaultParameters", "loadGlobalSettings", "loaddefaultsettings", "loadGlobalParameters", "loadDefaultConfiguration", "getDefaultsettings", "loadApplicationParameters", "loadGlobalsettings", "getDefaultSettings", "loadApplicationsettings", "loadGlobalConfiguration", "loadDefaultParameters", "loadDefaultsettings", "getdefaultConfiguration", "loaddefaultConfiguration", "getdefaultSettings", "loaddefaultParameters", "getdefaultsettings", "loaddefaultSettings"], "configFileName": ["configModuleLocation", "configPlaceUrl", "configFullUrl", "configPlaceString", "configFilesType", "configFilesLocation", "configFileUrl", "configFullLocation", "fileFILETime", "configFILEName", "configFILETime", "fileFILEType", "configFilesTime", "fileFileType", "ConfigFileLocation", "configFileString", "configFullName", "configFilenameName", "configFileLocation", "configModuleString", "ConfigFileString", "configPlaceName", "configFilenameType", "fileFILEName", "configModuleUrl", "ConfigModuleLocation", "configPlaceLocation", "configFileType", "ConfigFileName", "configModuleName", "fileFileTime", "configFILELocation", "configFILEType", "configFilesName", "fileFILELocation", "ConfigModuleName", "configFilenameLocation", "ConfigFileUrl", "fileFileLocation", "configFullString", "configFilenameTime", "ConfigModuleString", "configFileTime", "fileFileName", "ConfigModuleUrl"], "in": ["work", "source", "as", "init", "inn", "pin", "inner", "f", "config", "this", "plus", "pass", "i", "input", "socket", "conn", "inside", "read", "IN", "data", "m", "con", "ini", "resource", "n", "up", "a", "url", "base", "din", "pc", "log", "it", "is", "nin", "ins", "cin", "stream", "In", "inc", "again", "pull", "err", "r", "login", "ssl", "id", "reader", "diff", "bin"], "out": [" output", "copy", "output", "set", "sync", "client", " back", "net", "c", "instance", " file", "point", "config", "all", "back", "f", "view", "timeout", "s", "ex", "one", "this", "to", "socket", "OUT", "conn", "image", "default", "data", "writer", "object", "able", "up", "io", "and", "log", "name", "null", "ou", "ext", "server", "it", "exec", "obj", "password", "string", "connection", "exp", "prefix", "Out", "write", "outs", "inc", "again", "off", "file", "lib", "version", "err", "t", "o", "user", "parent", "bin", "error", "d"]}}
{"id1": "14168494", "id2": "539195", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyClass", "copyfile", "copyFiles", "copyClass", "transferfile", "transferFile", "transferClass", " copiedClass", " copiedFiles", " copiedfile", " copyfile", " copiedFile", " copyFiles"], "dest": ["source", "output", "out", "st", "path", " destination", "this", " Dest", "txt", "loc", "data", "resource", "done", "later", "sup", "class", "tmp", "name", "null", "obj", "transfer", "destroy", "dist", "target", "comb", "true", "orig", "desc", "file", "temp", "wb", "Dest", "dir", "d"], "src": ["source", "filename", "sb", "copy", "sync", "st", "download", "config", "s", "master", "ds", "inst", "sin", "loc", "storage", "img", "sup", "rob", "tmp", "url", "sel", "sit", "sub", "sc", "sl", "split", "dist", "rc", "rb", "upload", "gb", "stream", "sq", "file", "Dest", "ssl", "slice", "bin", "cb", "target"], "srcChannel": ["destConnection", "srcSection", "destchannel", "rcButton", "rcChan", " srcSection", "rcchannel", "destChannel", "distStream", "inputChannel", "srcButton", "distChan", "sourceChan", "srcchannel", " srcChan", "inputConnection", "srcCh", "rcStream", "distChannel", "srcConnection", " srcchannel", "sourceChannel", " srcConnection", " srcCh", "rcConnection", " srcStream", "inputSection", "srcChan", "rcSection", "sourceButton", "sourcechannel", " srcButton", "rcChannel", "distCh", "srcStream", "destChan", "rcCh", "inputchannel"], "dstChannel": ["dstVideo", "DstVideo", " drdContext", "dstChan", " dstStream", " dstsStream", " dstContext", " dstConnection", "dstsStream", " dstchannel", "dDestStream", "dstsChannel", "dsrcChannel", " dstChan", "dstConnection", "dstschannel", "dDestchannel", "ddestVideo", "dstContext", " drdChannel", "DstChannel", " dstsChannel", "drcchannel", " drdchannel", "drcChan", "drcVideo", "ddestchannel", "ddestStream", "dDestConnection", "dstStream", " dstschannel", "drcContext", "dsrcchannel", "ddestConnection", "DdestChannel", "dDestChannel", "Ddestchannel", "ddestContext", "DdestVideo", "Dstchannel", "dstchannel", "dstsConnection", " dstsConnection", "drdContext", "drdChannel", "ddestChan", "drdChan", " drdChan", "ddestChannel", "drdchannel", "dsrcVideo", "drcChannel"]}}
{"id1": "16572931", "id2": "4750967", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"unJar": ["copyTar", "updateJava", "copyJava", "addServer", "updateTar", "addjar", "copyjar", "updateServer", "updatejar", "putjar", "putTar", "addTar", "addJava", "copyServer", "putServer", "putJava"], "jarPath": [" jarUrl", "jarPo", "relFile", "browserEntry", "javaPath", " jarpath", "JarPath", "JarDir", "browserpath", "jarLog", "Jarpath", " jarName", "erbPath", "JarFile", "garPath", "relEntry", "JarUrl", "javaDir", "erbName", "javaLog", "garpath", " jarFile", " jarLog", "garEntry", "garLog", "javaUrl", "relDir", "erbPo", "jarUrl", "jarpath", "javapath", "javaName", "browserPath", "javaPo", " jarDir", "erbEntry", "javaEntry", "jarName", "jarDir", "browserName", "jarFile", "JarEntry", "javaFile", " jarPo", "JarName"], "jarEntry": [" jarInfo", " jarUrl", "javaPath", "zipUrl", " jarJar", "jarEnt", "cookEntry", "JarPath", "aliasInfo", "javaentry", "jarLog", " jarName", " jarEnt", "dropEntry", "dropentry", "cookDir", "cookPath", "javaLog", "javaDir", "javaJar", " jarentry", "aliasName", " jarLog", "jarInfo", "jarJar", "javaUrl", "xmlInfo", "zipDir", "javaInfo", "jarUrl", "Jarentry", "dropInfo", "dropPath", "javaName", "irEntry", "irentry", "irName", "JarInfo", " jarDir", "javaEntry", "jarName", "xmlPath", "jarDir", "jarentry", "xmlEntry", "zipEntry", "JarEntry", "aliasEntry", "aliasEnt", "cookEnt", "zipName", "javaEnt", "irJar", "xmlLog"], "path": ["work", "text", "source", "out", "config", "PATH", "project", "image", "cel", "default", "loc", "left", "location", "dest", "directory", "core", "url", "base", "log", "name", "code", "zip", "temp", "key", "dir", "entry", "type", "ion", "zone", "pattern", "mode", "uri", "sync", "clean", "home", "this", "model", "root", "ath", "po", "conn", "data", "binary", "test", "mount", "id", "parent", "prop", "str", "Path", "not", "wd", "skip", "folder", "resource", "next", "string", "prefix", "step", "content", "p", "th", "inner", "cat", "archive", "pass", "src", "ph", "it", "host", "address", "patch", "lock", "file", "request", "part", "route", "end", "right", "context"], "relPath": ["relativeName", "relativePath", " relName", "RelUrl", "Relpath", " relEntry", "revpath", "revType", "RelEntry", "relEntry", "revPath", " relType", " relpath", "relType", "revEntry", "RelType", "relName", "relpath", "relativeUrl", " relUrl", "RelName", "RelPath", "relUrl", "relativepath"], "jar": ["browser", "bar", "z", "py", "bag", "gi", "ball", "archive", "entry", "java", "rar", "ler", "war", "Jar", "drop", "folder", "module", "gap", "open", "binary", "ar", "job", "base", "url", "cook", "ja", "b", "fire", "zip", "sl", "j", "gar", "dr", "cur", "plugin", "tar", "file", "lib", " Jar", "pack", "er", "dir", "keeper", "le", "tab", "pkg", "zone", "xml", "her", "jo", "car"], "ze": ["se", "z", "zee", "zed", "zer", "aze", "e", "ie", "de", "kee", "pse", "ele", "oe", "ZE", "zy", "za", "zzy", "ce", "ke", "be", "ja", "pe", "te", "ge", "zip", " je", "sl", "zie", "je", "zes", "ine", "zen", "sle", "entry", "ipe", "le", "zi", "zin"], "bin": ["cookie", "init", "brain", "bed", "abin", "pin", "inner", "bb", "gi", "len", "bas", "sin", "ban", "data", "abi", "web", "in", "win", "bot", "resource", "binary", "proxy", "bian", "bi", "isin", "bit", "base", "log", "bon", "b", "gen", "zip", "jin", "lock", "cin", "plugin", "spin", "lib", "file", "kin", "pack", "login", "boot", "bis"]}}
{"id1": "5977352", "id2": "12766394", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyDir", "copyfile", " copyDir", "CopyFile", "copyFiles", " copyFiles", "transferfile", "transferFile", "transferDir", "Copyfile", "CopyFiles", " copyfile", "CopyDir"], "src": ["source", "filename", "sb", "uri", "fp", "path", "config", "s", "this", "buf", "view", "input", "ource", "conn", "inst", "loc", "data", "loader", "resource", "proxy", "img", "url", "tmp", "b", "proc", "obj", "files", "sel", "sc", "sl", "dist", "rc", "rb", "ins", "gb", "stream", "file", "slice"], "dest": ["source", "cache", "output", "table", "st", "path", " destination", "config", "home", "store", "this", "master", " Dest", "txt", "d", "de", "trans", "project", "rest", "cdn", "folder", "done", "dep", "later", "img", "class", "url", "tmp", "name", "cont", "null", "die", "obj", "destroy", "zip", "dist", "cp", "thin", "orig", "desc", "file", "temp", "route", "wb", "Dest", "part", "dir", "parent", "opt", "target", "delete", "dc"], "bufSize": ["buf2", "ufSize", "bufferSize", "buffersize", " bufsize", "bufLen", "uf2", "queueSize", "ufLen", " buf2", " bufLen", "queuesize", "queueLen", "buffer2", "ufsize", "bufsize", "bufferLen"], "force": ["ride", "p", "source", "Force", "remote", "ist", "sync", "push", "dirty", "load", "forces", "front", "f", "store", "use", "place", "hard", "urse", "count", "base", "deep", "rc", "require", "write", "only", "auto", "replace", "like", "file", "parent", "forcing", "pull", "route", "id", "forced", "apply", "flush", "delete", "no"], "buffer": ["source", "result", "cache", "length", "memory", "load", "buff", "fb", "buf", "seed", "bytes", "uffer", "border", "padding", "data", "binary", "zero", "limit", "url", "base", "b", "null", "transfer", "split", "address", "append", "Buffer", "queue", "write", "raw", "batch", "reference", "iter", "value", "request", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "text", "ride", "seek", "create", "select", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "lex", "len", "use", "view", "pass", "show", "level", "READ", "i", "input", "send", "skip", "ed", "count", "k", "sleep", "ind", "data", "build", "close", "ad", "open", "play", "find", "ip", "io", "n", "connect", "next", "b", "add", " write", "allow", "exec", "reads", "index", "size", "write", "raw", "block", "iter", "wait", "feed", "id", "reader", "end", "get", "start", "d", "fill", "run"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "c", "ac", "f", "pass", "ex", "i", "input", "socket", "conn", "image", "sin", "inside", "serv", "IN", "m", "con", "win", "ini", "up", "n", "isin", "a", "url", "base", "din", "b", "nin", "min", "ins", "connection", "cin", "thin", "In", "inc", "again", "rin", "kin", "lib", "part", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "ac", "at", "home", "this", "with", "w", "ex", "i", "one", "max", "socket", "conn", "OUT", "line", "image", "by", "writer", "n", "io", "up", "bin", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "nin", "connection", "exp", "plain", "Out", "write", "outs", "again", "off", "lib", "part", "err", "key", "o", "id", "user", "inc", "co", "can", "no"]}}
{"id1": "1769771", "id2": "3801655", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyChannel", "copyfile", "CopyChannel", "copyFiles", "CopyFile", "copyChannel", "transferfile", "transferFile", "transferChannel", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "in": ["work", "source", "inn", "pin", "inner", "c", "f", "config", "ex", "i", "input", "l", "image", "IN", "data", "m", "win", "io", "bin", "url", "base", "name", "query", "min", "index", "ins", "lock", "lin", "In", "again", "file", "login", "id", "reader", "diff", "inc"], "out": ["p", "x", "dot", "call", "cache", "output", "c", "point", "extra", "w", "ex", "OUT", "conn", "image", "default", "writer", "resource", "io", "n", "up", "base", "name", "b", "ext", "server", "exec", "string", "external", "plain", "prefix", "Out", "write", "outs", "again", "off", "file", "o", "user", "v", "target"], "inChannel": ["insChannel", "Inchannel", "outchannel", "inClient", "inChan", "InClient", "insClient", "InChan", " inchannel", "inputChan", "inputChannel", "INChannel", "INChan", "INStream", "binClient", "winChan", "binChannel", "winChannel", "InStream", "binchannel", "outClient", "inputchannel", " inChan", " inClient", "InChannel", "inchannel", "insChan", " inStream", "insStream", "winchannel", "inputStream", "outChan", "outStream", "winStream", "binChan", "INchannel", "inStream", "binStream"], "outChannel": [" outCh", "outchannel", "OutChan", "inChan", " outStream", "inputChan", "inputChannel", "outCh", "outputchannel", "nChannel", "nChan", "outController", "outputController", "outManager", "Outchannel", "inputController", "inConnection", "inManager", "outConnection", "inController", "inCh", "outputCh", " outChan", " outchannel", "outputStream", "nStream", "inchannel", " outManager", "outputChannel", "OutConnection", "outChan", "outStream", " outConnection", "outputChan", "nManager", "OutChannel", "inStream", "inputchannel"]}}
{"id1": "8665649", "id2": "4468255", "code1": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"_getImage": ["_readimage", "_downloadImage", "_downloadImages", "_downloadThumbnail", "_getimage", "_readImage", "_parseThumbnail", "_parseImages", "_parseImage", "_readImages", "_getThumbnail", "_downloadimage", "_readThumbnail", "_getImages", "_parseimage"], "urlStr": ["imageSt", "urlText", "imageString", " urlText", "imagestr", "strStr", "urlstr", "urlSt", "imageStr", " urlSt", " urlSTR", "strString", "fileSTR", " urlString", "fileSt", " urlstr", "fileString", "urlString", "imageText", "fileStr", "imageSTR", "strstr", "urlSTR", "strText"], "url": ["ls", "org", "uri", "str", "client", "browser", "path", "Url", "c", "f", "config", "bb", "page", "l", "image", "build", "blog", "loader", "loc", "web", "object", "resource", "www", "job", "log", "b", "lc", "server", "host", "URL", "rl", "fl", "sl", "ch", "connection", "channel", "ll", "impl", "ssl", "r", "feed", "user", "http"], "conn": ["ls", "out", "sync", "client", "c", "Connection", "cmd", "nt", "socket", "Conn", "ci", "con", "close", "ad", "open", "act", "n", "connect", "pc", "conv", "exec", "conf", "ch", "api", "cur", "connection", "h", "nc", "cp", "enc", "impl", "cn", "rt", "cli", "err", "ssl", "ct", "ctx", "cb", "co", "http"], "in": ["source", "as", "init", "rec", "gin", "inn", "out", "token", "pin", "inner", "c", "ac", "f", "ax", "s", "gz", "ex", "i", "input", "socket", "image", "inas", "IN", "data", "m", "con", "ini", "win", "n", "isin", "bin", "din", "pc", "b", "null", "fd", "is", "nin", "min", "ins", "connection", "cin", "stream", "In", "again", "rin", "kin", "r", "err", "login", "ssl", "id", "reader", "inc"]}}
{"id1": "2834524", "id2": "7468819", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"write": ["create", "output", "out", "parse", "sync", "check", "load", "download", "update", "all", "println", "process", "writer", "open", "post", "zip", "append", "rite", "delete", "save", "file", "end", "after", "flush", "Write", "handle", "run", " rewrite"], "jarOut": ["tarOUT", "garIn", "garout", "JarOUT", "jarout", "jarOUT", "javaOut", "Jarout", "javaIn", "javaOUT", " jarout", "javaout", " jarOUT", "garOut", " jarOutput", "serOUT", "serout", "sheetOUT", "serIn", "jarCatalog", "JarIn", "javaOutput", "garOUT", "JarOut", "JarCatalog", "tarOut", "serOut", "javaCatalog", " jarCatalog", "sheetOut", "JarOutput", "jarIn", "tarout", " jarIn", "sheetOutput", "sheetIn", "tarOutput", "jarOutput"], "allEntries": ["AllEntries", "allAddry", "allEntrys", "allTries", "AllEntry", "Allentrs", "AllEntrys", "AllEntrs", "allEntories", "Allentries", "allChries", "allChies", " allEnties", "allEnties", "allentry", "Allentry", "allentories", " allEntories", "allTry", "allChrys", "allEntry", "allentrys", "allAddries", "allEntrs", "Allentrys", "allChories", "allentrs", "allTrs", "allTrys", "allAddrys", "allentries", " allEntrys", "allenties"], "iterator": ["pie", "cmp", "init", "uri", "set", "starter", "inner", "basic", "finder", "instance", "river", "ter", "consider", "i", "ie", "processor", "running", "skip", "inst", "gener", "or", "loader", "walker", "done", "started", "later", "ators", "division", "next", "Iterator", "runner", "outer", "Iter", "query", "oper", "ator", "list", "now", "size", "former", "section", "stream", "handler", "engine", "filter", "parser", "iter", "creator", "eni", "heid", "collection", "loop", "step", "er", "slice", "entry", "end", "reader", "inter", "keeper", "start", "ski", "order"], "jar": ["cookie", "style", "ssl", "json", "pod", "bar", "browser", "parse", "bag", "config", "archive", "java", "ler", "war", "image", "Jar", "drop", "ski", "sheet", "magic", "folder", "in", "record", "star", "binary", "module", "ar", "docker", "job", "base", "url", "jam", "zip", "container", "tag", "plugin", "tar", "file", "space", "ser", "er", "dir", "entry", "keeper", "pkg", "tab", "mag", "start", "pack", "audio", "jo", "zone"], "jarEntries": ["jarAories", "jarTires", "jarAires", "parseEntriers", "jarIntrs", "parseErs", "jarErorts", "jarEntriers", "jarEnories", "jarIntries", "jarIntriers", "jarErries", "parseEntries", "jarEntryorts", " jarEnties", " jarEnires", "jarEntires", "jarEntorts", "JarEntorts", "jarTries", "jarErrys", "jarEntryies", "jarEntryrys", "parseEntories", "parseEories", "jarEories", "jarErs", "jarEnies", "jarEnties", "jarEntrys", "parseEriers", "jarEriers", "jarTories", "JarEnties", "jarAies", "jarEnries", " jarEnries", "jarEnires", "jarTies", "jarAries", " jarEntires", "JarEntrys", "jarEries", " jarEntories", "parseEntrs", " jarEnories", "jarEntrs", "JarEntries", "jarEntryries", " jarEnies", "jarEntories", "parseEries", "jarIntories"], "o1": ["o0", "oainf", "oa1", "oa91", "oaOne", "O3", "po11", "po1", "opOne", "o3", "oa0", "op3", "oe11", "oinf", "so3", "oaone", "oeinf", "oOne", "OOne", "oe91", " oinf", "o4", "soOne", "oe3", " o4", "oepart", "oone", " o0", "O1", "Opart", "o11", " opart", "op1", "po4", "O11", "o91", " o91", "opart", " oone", "so1", " o3", "oe1", "oeone", " o11", "O0", "oa4", "oa11", " oOne"], "entryStream": ["zipString", " entryString", "entryString", "Entrystream", " entrystream", "EntryStream", "inputReader", " entryReader", "EntrySteam", "EntryString", "entrySteam", "connectionReader", "connectionSteam", "zipstream", "inputSteam", "inputStream", " entrySteam", "zipSteam", "entrystream", "zipStream", "connectionStream", "entryReader"]}}
{"id1": "1005107", "id2": "364438", "code1": "    public void googleImageSearch() {\n        if (artist.compareToIgnoreCase(previousArtist) != 0) {\n            MusicBoxView.googleImageLocation = 0;\n            try {\n                String u = \"http://images.google.com/images?q=\" + currentTrack.getArtist() + \" - \" + currentTrack.getAlbum() + \"&sa=N&start=0&ndsp=21\";\n                if (u.contains(\" \")) {\n                    u = u.replace(\" \", \"+\");\n                }\n                URL url = new URL(u);\n                HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n                httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n                BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n                String text = \"\";\n                String lin = \"\";\n                while ((lin = readIn.readLine()) != null) {\n                    text += lin;\n                }\n                readIn.close();\n                if (text.contains(\"\\n\")) {\n                    text = text.replace(\"\\n\", \"\");\n                }\n                String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n                for (String s : array) {\n                    if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                        String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                        googleImages.add(s1);\n                    }\n                }\n            } catch (Exception ex4) {\n                MusicBoxView.showErrorDialog(ex4);\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"googleImageSearch": [" googleFileScan", "googleMediaSearch", "googleImagesSearch", "googleFilesearch", " googleImageScan", " googleImagesearch", "googleImagesearch", "googleImagessearch", "googleMediaScan", "googleImagesScan", "googleMediasearch", "googleImageScan", " googleFileSearch", "googleFileSearch", "googleFileScan", " googleFilesearch"], "MusicBoxView": ["MusicBOXClient", "musicBoxDisplay", "MusicBookDisplay", "musicBoxClient", "MusicBoxUI", "musicBoxView", "MusicBOXContainer", "musicboxUI", "MusicBOXUI", "MusicBoxContainer", "musicboxContainer", "musicboxView", "MusicBOXView", "MusicFieldView", "MusicboxContainer", "musicboxClient", "MusicBoxClient", "musicBoxUI", "MusicBookView", "MusicboxView", "MusicboxDisplay", "MusicboxUI", "MusicBookClient", "musicboxDisplay", "MusicFieldDisplay", "MusicFieldContainer", "musicBoxContainer", "MusicboxClient", "MusicBOXDisplay", "MusicBoxDisplay", "MusicBookUI", "MusicFieldUI"], "googleImageLocation": ["googleUploadPosition", "remotePictureAddress", "googlePictureLoc", "googlePictureAddress", "googlePicturePosition", "googleUploadAddress", "remoteImageLoc", "googleUrlPosition", "remoteImageLocation", "googleUrlLoc", "remoteImageAddress", "googleUrlLocation", "googleUploadLocation", "googleImagePosition", "remotePicturePosition", "remotePictureLoc", "googleImageAddress", "googlePictureLocation", "googleUploadLoc", "remotePictureLocation", "googleUrlAddress", "remoteImagePosition", "googleImageLoc"], "u": ["p", "uv", "util", "su", "fu", "uri", "fp", "ku", "username", "c", "f", "s", "back", "plus", "e", "i", "input", "l", "pu", "data", "q", "tu", "ru", "ua", "ut", "up", "iu", "n", "yu", "a", "base", "ou", "b", "ui", "nu", "string", "bu", "ur", "ul", "lu", "universal", "un", "cu", "file", "hu", "t", "uu", "U", "o", "mu", "user", "ue", "d", "http"], "url": ["ls", "org", "util", "uri", "path", "Url", "download", "f", "fb", "page", "l", "conn", "image", "blog", "web", "www", "base", "log", "bc", "b", "server", "host", "URL", "fl", "sl", "api", "connection", "string", "fr", "ur", "stream", "ul", "ll", "impl", "file", "pull", "ssl", "user", "http"], "httpcon": ["httpconn", "httpsConn", "httpconnection", " httpconn", "perconn", "webconn", "weburl", "webcon", " httpcn", "webconnection", "httpCon", "webcn", "webCon", " httpConn", " httpCon", "urlCon", "webconf", "urlcon", "urlconn", "urlurl", "httpcn", "perCon", " httpurl", "webConn", "percon", "httpscn", " httpconf", "perconf", "httpConn", "httpurl", "httpsconnection", " httpconnection", "httpscon", "httpconf"], "readIn": ["parseRef", "runin", "loadIN", " readStream", "readedIn", "loadIn", "readerIn", " readin", "playRef", "readIN", "ReadStream", " readedIn", "readin", "loadin", "readIns", "parseIn", "readeredIn", "parseIN", "runedIn", "runIn", "readStream", " readIns", "ReadIn", "runIN", " readIN", "loadedIn", "readerIns", "readRef", "playIn", "ReadIns", "playIN", "readerStream", "playin", "parsein", "ReadedIn", " readRef"], "text": ["source", "message", "form", "concept", "lines", "str", "out", "output", "path", "translation", "inner", "config", "f", "info", "lex", "font", "event", "title", "pass", "txt", "word", "input", "l", "image", "line", "tx", "pattern", "data", "TEXT", "left", "in", "object", "format", "context", "act", "img", "ut", "vert", "editor", "ip", "log", "name", "b", "it", "ext", "Text", "code", "letter", "fruit", "body", "term", "string", "struct", "lit", "test", "feed", "layout", "id", "contract", "delete", "content"], "lin": ["ls", "lp", " line", "ln", "Line", "lines", "str", "ml", "pin", "kl", "lex", "lt", "len", "hl", "pl", "lic", "Lin", "txt", "lim", "l", "bl", "line", "ele", "val", "inline", "in", "dl", "lb", "base", "log", "lc", "vin", "sel", "rl", "fl", "sl", "li", "lang", "string", "ins", "lock", "coll", "el", "lu", "ll", "lit", "Lu", "lins", "kin", "late", "liner", "le", "LIN", "la"], "array": ["vector", "group", "ab", "arr", "ray", "all", "our", "archive", "page", "area", "angle", "image", "record", "object", "air", "ar", "database", "address", "api", "index", "string", "list", "stack", "arrow", "queue", "element", "coll", "range", "collection", "Array", "part", "row", "r", "v", "section", "audio", "pair"], "s1": ["g2", "s2", "s81", " s81", "gOne", "sOne", "c1", " sOne", "c2", "g0", "c0", " s2", "cOne", "s0", " s0", "g1", "c81"], "ex4": ["EX4", "ex8", "ception4", "ext04", "ceptionfour", "ext4", "ception04", " ex384", "EX8", "extfour", "expfour", "ex2", "Exfour", "exp4", "exp2", "ex384", " exfour", "Ex8", "ception384", "EX2", "EXfour", "exp8", "ext384", "exfour", "Ex4", "ex04", "Ex2", " ex04"]}}
{"id1": "4618237", "id2": "10451698", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFilesAsFile", "writeFileAsChannel", "writeFilesToFile", "writeFileAndFiles", "writeFile2File", "writeFileAsFiles", "writeFile2Stream", "writeFile2Files", "writeFileAsFile", "writeFilesToStream", "writeFileToStream", "writeFile2Channel", "writeFilesToChannel", "writeFileToChannel", "writeFileAndChannel", "writeFilesAsFiles", "writeFileAsStream", "writeFilesAsStream", "writeFileAndStream", "writeFileToFiles", "writeFileAndFile", "writeFilesToFiles", "writeFilesAsChannel"], "fin": ["fine", "init", "ris", "ln", "inn", "fp", "pin", "f", "ori", "conn", "ini", "fm", "fen", "Fin", "arin", "inf", "din", "pins", "fd", "inv", "fn", "fr", "fa", "thin", "rf", "lin", "FIN", "en", "rt", "file", "nir", "rin", "kin", "fi", "include", "fat", "raf"], "fout": ["fOut", "Foff", "rfin", "rfint", "bout", "rfOut", "Fout", "bOut", " fOut", "boff", "Fint", "Fin", "bin", " foff", " fint", "foff", "rfout", "FOut", "fint"], "append": ["text", "adjust", "app", "flat", "pend", "opp", "push", "want", "leaf", "pad", "update", "spread", "send", "padding", "open", "ended", "vert", "except", "add", "null", "ext", "password", "printf", "string", "future", "enc", "only", "batch", "fail", "atten", "save", "protect", "pack", "remove", "end", "apply", "flush", "ending", "optional"], "inChannel": ["innerConnection", "Inchannel", "outchannel", "outQueue", "innerChan", "inChan", "loginStream", "InChan", " inchannel", "loginChannel", "inputChannel", "inputChan", "INChannel", "loginchannel", " inQueue", "INChan", "innStream", "INStream", "inputConnection", "inQueue", "innerchannel", "inConnection", "InChannel", "innchannel", "innerStream", "INConnection", "inchannel", "innerChannel", "inputStream", " inStream", "innChannel", "outChan", "outStream", "INchannel", "INQueue", "inStream", "InStream"], "outChannel": ["outSocket", "OutContext", "outchannel", "OutChan", "inChan", "iochannel", "outputchannel", "ioChan", "outContext", "Outchannel", "externalchannel", "externalChannel", " outChan", " outchannel", "ioChannel", "inContext", "externalChan", "inchannel", "OutStream", "ioStream", "outputChannel", "externalSocket", "outChan", " outContext", "outStream", "outputChan", "OutChannel", "outputSocket", "inStream", "inSocket"]}}
{"id1": "1966310", "id2": "8665321", "code1": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"init": ["create", "reset", "set", "clean", "empty", "load", "basic", "config", "info", "construct", "ci", "build", "ini", "close", "open", "done", "act", "action", "connect", "bin", "base", "core", "initialized", "initial", "it", "setup", "gen", "exec", "conf", "prep", "Init", " initialize", "ize", "plugin", "alloc", "pack", "boot", "start", " Init", "clear"], "doActions": [" animationCaactions", " animationAaction", " plotCaactions", " animationAAction", " plotCaaction", " plotCactions", " plotActionctions", " animationCaaction", " plotCaAction", " plotAaction", " plotAlaction", " plotAAction", " animationCaAction", " plotActionactions", " animationActions", " plotAlctions", " plotAlAction", " plotActions", " plotActionaction", " animationCactions", " animationAactions", " plotActionAction", " plotAactions", " plotAlactions"], "_plot": ["_chart", "_pl", "_log", "_fit", "_project", "_patch"], "width": ["flow", "work", "dim", "crop", "wn", "filename", "style", "shape", "Width", "idth", "port", "widget", "length", "large", "amount", "fb", "page", "w", "hop", "wp", "area", "border", "padding", "image", "high", "lon", "west", "writer", "duration", "left", "down", "age", "platform", "gender", "speed", "window", "wa", "name", "fw", "capacity", "number", "index", "size", "write", "weight", "wait", "value", "fall", "space", "density", "pull", "layout", "fill", "draw"], "height": ["th", "crop", "style", "shape", " heights", "grow", "depth", "port", "bottom", "length", "gravity", "inches", "pad", "head", "level", "image", "padding", "rank", "upper", "build", "data", "duration", "gap", "ip", "shadow", "window", "deep", "capacity", "thumbnails", "index", "h", "rows", "size", "alpha", "arrow", "thin", "wrap", "radius", "stroke", "weight", "resolution", "y", "density", "pull", "quality", "row", "slice", "id", "layout", "right", "draw", "Height", "volume"], "widthspec": ["lengthspec", "weightpec", "widthstring", " widthpec", "widthparse", "sizescale", "widthscale", "widthset", "lengthSpec", "lengthparse", "weightspec", "poolset", "weightstring", "widthstyle", "sizespec", " widthstring", "poolspec", " widthstyle", "widthSpec", "sizeSpec", " widthset", "weightstyle", " widthSpec", "weightscale", "Widthstyle", "Widthpec", "lengthset", "sizestring", "WidthSpec", "widthpec", " widthscale", "poolSpec", " widthparse", "Widthspec", "weightSpec", "poolparse"], "heightspec": ["weightsSpec", "heatspec", "heightsspec", "heaksspec", "weowsspec", "weowspec", "heakspect", "heowsync", "heckspec", "weowsSpec", "heightsync", "heowsspec", "heatslip", "hecksspec", "heatsspec", "weightspec", "heightslip", "heetsspec", "heetslip", "heetspec", "hecksSpec", "heatspect", "weightspect", "heetspe", "peightsync", "peatspec", "heatsSpec", "heowspec", "heightsSpec", "peatspect", "peatspe", "heekspe", "peatsspec", "peightspe", "heightspect", "heakspec", "heckspect", "heightspe", "weowspect", "heekspec", "heeksspec", "heatspe", "heowsSpec", "peightslip", "heaksync", "peatsync", "peightspect", "heowspect", "heatsync", "peightsspec", "peatslip", "peightspec", "heekslip", "weightsspec"], "background": ["buffer", "summary", "large", "color", "ba", "back", "shield", "ghost", "gradient", "area", "Background", "border", "image", "black", "panel", "default", "resource", "comment", "shadow", "shell", "description", "callback", "base", "clip", "bc", "null", "theme", "pool", "foundation", "bg", "ground", "fill", "rc", "brush", "gold", "blue", "prefix", "gray", "profile", "regular", "brown", "alpha", "wrapper", "ruby", "reference", "ha", "sound", "collection", "pull", "ignore", "support", "pattern", "draw", "focus"], "colorspec": ["collorespec", "colororespect", "colonslip", "Colorsnp", "coloresnp", "Colorspace", "Colorespec", "colonship", "colonspec", "colorspect", "coloreslip", "Colonsspec", "colandsspec", "colorespir", "colororsspec", "colourspace", "Colorspir", "colorespect", "collectionspec", "colionspace", "colionsnp", "colonsSpec", "colloresspec", "Colorespir", "colarship", "Colorspect", "colandspect", "colororspect", "colandsSpec", "colorslip", "colorsnp", "colourspect", "colorsSpec", "colandspec", "colourspir", "Colonspec", "Colorship", "colionslip", "colonsspec", "collorsspec", "colororsSpec", "colorespace", "collorspec", "colorspace", "colarspec", "coloresSpec", "colororesspec", "colarsspec", "colionsspec", "colionspir", "Coloresspec", "Coloreship", "Colorslip", "colorspir", "coloursspec", "colorship", "colororspec", "collorespace", "Colorsspec", "colarspect", "colorsspec", "Colonspace", "collectionspect", "collorespect", "colionspec", "Coloresnp", "coloursnp", "colororespec", "coloresspec", "collorspect", "Colonslip", "collorspace", "Colorespect", "colonspace", "colourspec", "Colorspec", "coloreship", "colorespec", "colonspect", "collectionsspec", "colororesSpec"], "foreground": ["roughfill", "forefill", "fterGROUND", "broadcast", " forebackground", "broadfill", "ftercast", "foreGROUND", "flyfill", "Foreparent", " foreGROUND", "Forecast", "roughground", "underbackground", "backbackground", "Forepoint", " foreparent", "backmission", "foremission", "forecast", "flyground", "foreparent", "Foremission", "roughcast", "undercast", "ForeGROUND", "roughellow", "underparent", "forepoint", "roughpoint", "fterground", "foreellow", "Foreground", "Forebackground", "broadellow", " forecast", "broadground", "underground", "backpoint", "flyellow", "roughbackground", "forebackground", "roughmission", "flycast", "fterbackground"], "dataurlspec": [" datalogspec", "dataurlspace", "datastringspe", "dataURLspec", "datalogstr", " dataurlparse", "dataUrlSpec", "dataurlspe", " dataurlstr", "datafilestr", " dataUrlspec", "dataUrlspec", "datalogspec", "datastringSpec", " dataurlSpec", " dataUrlSpec", "datalogparse", "dataUrlspe", "datafeedSpec", " dataurlspace", " dataurlspe", "datafilespace", "dataurlstr", "dataURLparse", "datafilespec", "dataurlSpec", "dataURLspe", "datafeedspec", " dataUrlspe", "dataURLspace", "dataurlparse", " datalogstr", "datastringspec", "datalogspace", "datafileparse", "dataURLSpec", " datalogspace", "dataURLstr", " datalogparse"], "dataurl": ["DataUrl", "thisURL", "Dataurl", "ataurl", "ataURL", "Database", "thisfile", "datafile", "atabase", "database", "DataURL", "thisUrl", "thisurl", " datafile", "ataUrl", " dataURL", "Datafile", "dataURL", " dataUrl", "dataUrl", " database"], "in": ["p", "source", "as", "inn", "out", "inner", "c", "f", "i", "input", "serv", "inas", "image", "socket", "IN", "data", "con", "record", "resource", "win", "ini", "isin", "bin", "a", "url", "din", "b", "server", "body", "ins", "h", "stream", "In", "r", "t", "login", "err", "reader", "inc", "d"]}}
{"id1": "17337238", "id2": "10391753", "code1": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"create": ["created", "make", "init", "copy", "instance", "update", "config", "store", "construct", "one", "Create", "record", "open", "add", "setup", "destroy", " Create", "write", "replace", "creation", "creator", "save", "insert", "request", "type", "start", " recreate"], "IOException": ["TimeoutException", "TimeoutError", "DatabaseError", "IOception", " IOError", "IOError", " IOception", "Timeoutception", "Databaseception", "DatabaseException"], "conn": ["p", "ht", "client", "oss", "sync", "session", "c", "apt", "Coll", "reg", "wd", "Connection", "ens", "nt", "po", "ca", "Conn", "ci", "ds", "loc", "con", "pg", "ad", "act", "pub", "n", "connect", "error", "ann", "log", "os", "col", "cr", "conf", "ch", "res", "rc", "connection", "h", "nc", "cc", "lock", "cp", "enc", "coll", "pr", "Connect", "sql", "en", "rt", "cn", "dh", "r", "err", "dn", "ob", "ct", "ctx", "db"], "st": ["St", "ste", "est", "sb", "sw", "ts", "pt", "str", "ist", "se", "sync", "ss", "s", "ast", "nt", "src", "ds", "rest", "inst", "con", "ust", "ess", "ST", "sth", "sa", "ut", "rd", "cr", "sc", "nd", "sl", "ft", "sp", "stop", "fr", "ld", "sts", "dd", "cl", "pr", "mt", "sh", "sn", "rt", "std", "put", "step", "t", "sta", "r", "ct", "ost", "db", "td"], "query": ["form", "result", "select", "question", "table", "str", "uri", "parse", "json", "push", "script", "clean", "update", "ql", "rr", "seed", "timeout", "command", "how", "qq", "build", "q", "resource", "iq", "where", "comment", "statement", "description", "database", "search", "code", "cr", "term", "index", "scope", "string", "rule", " Query", "pr", "sum", "sql", "qu", "sq", "test", "eries", "filter", "value", "request", "join", "dq", "error", "Query", "report"], "rs": ["ls", "ris", "rx", "cs", "ps", "result", "ts", "ys", "s", "reg", "ars", "rr", "mr", "ers", "issues", "ds", "ues", "hs", "ans", "req", "RS", "vs", "ras", "sr", "ges", "ws", "ros", "ks", "rm", "ms", "hr", "rd", "rl", "cr", "res", "ack", "rss", "dr", "Rs", "rc", "acks", "ins", "arms", "asts", "rys", "xs", "repl", "pr", "vers", "runs", "rt", "ows", "ns", "row", "r", "results", "rows", "rg"], "genId": ["libInt", "gId", "GenID", " genInt", "winId", "genType", "ginID", "generType", "generInt", "winid", "libId", " genById", "GenId", " genID", "genInt", " genid", "winById", "ginId", "genById", "gID", "ginid", "libType", "generId", "winID", "ginById", " genType", "gid", "Genid", "genid", "genID"], "ret": ["ref", "RET", "success", "Pub", "pb", "val", "default", "fit", "auth", "proxy", "base", "search", "ext", " Ret", "true", "let", "general", "grid", "desc", "def", "entry", " result", "result", "reg", "det", "data", "pub", "job", "proc", "utils", "obj", "res", "Ret", "ft", "rc", "repl", "REG", "rt", "vet", "id", "db", "att", "match", "gt", "fun", "back", "place", "bot", "Reg", "gen", "arg", "detail", "tr", "response", "login", "reply", "re", "seq", "cat", "f", "alt", "vr", "resp", "bf", "class", "num", "server", "rets", "usr", "part", "pro", "r", "rev", "v", "active"]}}
{"id1": "12146394", "id2": "15166511", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["MD2crypt", "md4Hash", "md2Hash", "md2Crypt", "md6Hash", "MD2Hash", "MD2Key", "md2Key", "MD5Crypt", "MD5Hash", "md4Key", "md4Crypt", "md6Crypt", "md4crypt", "md5Key", "md6Key", "md2crypt", "md5crypt", "MD2Crypt", "md6crypt", "MD5crypt", "md5Hash", "MD5Key"], "key": ["x", "source", "text", "message", "cookie", "cache", "k", "image", "money", "ip", "air", "core", "base", "name", "code", "power", "zip", "time", "rule", "size", "cer", "y", "temp", "any", "type", "go", "char", "copy", "token", "ace", "sync", "shift", "this", "hash", "use", "seed", "phrase", "root", "word", "none", "data", "magic", "req", "other", "kw", "here", "self", "password", "id", "user", "parent", "order", "pair", "secret", "kid", "call", "cy", "fee", "point", "state", "input", "year", "cert", "ce", "ke", "blow", "number", "proof", "string", "element", "value", "version", "KEY", "my", "no", "length", "wire", "empty", "ask", "date", "material", "kh", "m", "service", "server", "transfer", "ch", "list", "scope", "connection", "lock", "ee", "full", "trust", "row", "ssl", "sign", "carry", "Key"], "salt": ["asalt", "sodium", "southift", "southALT", " sodium", "svort", "asal", "southart", "sval", "osalt", "sessecret", "sesALT", "southalt", "sass", "sal", " ssecret", "sift", "sesalt", "seskey", "asALT", "sesol", "sol", "ssol", "Sal", "osul", "ssALT", "Sodium", "sesort", "assecret", "sesart", " skey", "skey", " sol", "sesift", "southsecret", " sift", "ssass", "SALT", "Salt", "southodium", "sart", " sart", "sALT", " sass", "sort", "osALT", "svalt", "sesal", "osift", " sALT", "svALT", "sesul", "sul", "sesass", "ssecret", "Ssecret", "ssalt"], "_md": ["Newdm", "_key", "_mand", "copycmd", "_mb", "localmd", "localcmd", " _key", "__dm", " _dm", "_dm", "Newcmd", "Newmd", "\u00a0mand", "\u00a0mode", "_cmd", "copydm", "copymd", "\u00a0dm", "_mg", "Newamd", " _cmd", "copykey", " _amd", "_MD", " _nm", " _MD", "_db", "__md", "\u00a0cmd", "_m", " _db", "__amd", "_nm", "_amd", "_mode", "\u00a0md", " _m", "__cmd", "\u00a0nm", "localmb", "localmg", "\u00a0m"], "md2": [" md02", "amd4", "cmd02", "md32", "md4", "md62", "cmd3", "md5", "hdTwo", "MD4", "cmd1", " md1", "amd32", "cmd2", "MD2", " mdTwo", " md5", "cmd4", "amd2", "amd62", " md62", "MD5", "cmd5", "cmd62", "hd62", "MD62", " md32", "amdTwo", " md4", "md1", "hd2", "md02", "hd32", "amd02", "mdTwo", "MD3", "MD1"], "abyFinal": ["saySpecial", "andyFinal", "Babyfinal", "sayInitial", "amyFinal", "BabyFinal", "BabyFinish", "abiesFull", "abyLast", "BabyFull", "abyTotal", "sayFinal", "aberfinal", "abySuccess", "andyLast", "aberInitial", "abiesSuccess", "abyResult", "BabyLast", "butLast", "rayLast", "abiesFinal", "andyInitial", "babyTotal", "babyInitial", "abeFinal", "abeLast", "abySpecial", "babyLast", "amySuccess", "abyfinal", "butInitial", "andyTotal", "amySpecial", "aberFinal", "amyResult", "butFinal", "babyfinal", "andyfinal", "babySpecial", "abeFinish", "rayInitial", "abyFinish", "babyFinal", "babyResult", "abiesResult", "amyInitial", "babySuccess", "aberTotal", "abyFull", "rayFinal", "abiesLast", "abeFull", "abyInitial", "abiesFinish"], "n": ["p", "x", "gn", "span", "inn", "byn", "net", "z", "br", "c", "ni", "f", "yn", "all", "not", "len", "np", "nt", "l", "conn", "k", "none", "N", "nor", "nan", "m", "ner", "ne", "g", "nn", "a", "on", "name", "don", "num", "b", "nb", "number", "na", "nu", "min", "nc", "fn", "pn", "mn", "ng", "nw", "en", "un", "sn", "ns", "y", "cn", "ny", "syn", "t", "non", "dn", "adj", "o", "r", "network", "v", "node", "d", "no"], "j": ["p", "x", "ij", "z", "c", "ni", "jl", "bj", "ii", "dj", "ie", "l", "I", "k", "aj", "ci", "ind", "yi", "q", "ne", "io", "si", "v", "jj", "b", "u", "num", "ja", "ji", "jc", "li", "index", "fr", "di", "qi", "jp", "y", "xi", "adj", "uj", "o", "J", "section", "js", "d"], "i": ["p", "ani", "c", "ni", "ai", "gi", "ii", "e", "ie", "I", "ci", "yi", "ini", "chi", "multi", "iu", "bi", "io", "si", "mini", "ui", "pi", "ji", "ki", "li", "index", "oi", "mi", "di", "qi", "gu", "eni", "y", "xi", "fi", "ali", "mu", "o", "zi", "ri", "ti", "phi"], "sbPasswd": ["sfPasswords", "cbPassword", "sbCrWD", "sbPassw", "sfPassw", "bbParrc", "bbParwd", "bbParword", "cbParphrase", "rbCrw", "sbParwords", "rbPassWD", "cbParwd", "sbCrrc", "cbPassw", "rbCrwd", "sfSecretwd", "sbPassWD", "sbCrwords", "bbPassw", "sbSecretwords", "sbPassrc", "cbParw", "sfSecretword", "sbPassphrase", "sfPasswd", "sbParwd", "sbFailphrase", "sbCrwd", "bbPassword", "sbParrc", "cbPasswd", "rbPassw", "sbPasswords", "sfSecretw", "sbSecretwd", "sbFailw", "sbParWD", "bbPasswd", "sbCrw", "sfSecretwords", "sbParword", "bbPassrc", "sbPassword", "sbParphrase", "cbPassphrase", "cbParword", "rbCrWD", "sbParw", "rbPasswd", "rbPassword", "sbSecretw", "sbCrword", "sbSecretword", "sbFailwd", "bbParw", "sbFailword", "rbCrword", "sfPassword"], "md3": ["md03", "mand3", " md53", "md53", "mand15", "mand23", "cmd3", "md512", "cmd1", " md1", "mdthree", "mag512", "cmd23", "amd15", "amd23", "amd512", "amd3", "cmd2", "MD2", "amdthree", " md23", "md23", "ms3", "mag15", "MD23", "MD53", " md03", " mdthree", "cmd53", "mand512", "md1", "mdthird", "mag23", "amd03", "msthird", "md15", " mdthird", "mag3", "amdthird", "msthree", "MD3", "ms03", "MD1"]}}
{"id1": "15799935", "id2": "19467540", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    @Override\n    public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) {\n        Connection conexion = null;\n        PreparedStatement select = null;\n        PreparedStatement update = null;\n        ResultSet rs = null;\n        boolean exito = false;\n        try {\n            conexion = pool.getConnection();\n            conexion.setAutoCommit(false);\n            select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\");\n            update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\");\n            String codigoProd;\n            int filasAfectadas = 0;\n            Iterator<String> iterador = carro.keySet().iterator();\n            while (iterador.hasNext()) {\n                codigoProd = iterador.next();\n                select.setString(1, codigoProd);\n                rs = select.executeQuery();\n                if (rs.next() == false) {\n                    Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\");\n                    iterador.remove();\n                    conexion.rollback();\n                } else {\n                    Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\"));\n                    select.clearParameters();\n                    if (carro.get(codigoProd) > prod.getStock()) {\n                        Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\");\n                        iterador.remove();\n                        conexion.rollback();\n                    } else {\n                        update.setInt(1, prod.getStock() - carro.get(codigoProd));\n                        update.setString(2, codigoProd);\n                        filasAfectadas = update.executeUpdate();\n                        if (filasAfectadas != 1) {\n                            Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\");\n                            conexion.rollback();\n                        }\n                        update.clearParameters();\n                        listado.put(prod, carro.get(codigoProd));\n                    }\n                }\n            }\n            conexion.commit();\n            exito = true;\n        } catch (SQLException ex) {\n            logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex);\n            try {\n                conexion.rollback();\n            } catch (SQLException ex1) {\n                logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1);\n            }\n        } finally {\n            cerrarConexionYStatement(conexion, select, update);\n            cerrarResultSet(rs);\n        }\n        return exito;\n    }\n", "label": 0, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAttachmentPart", "saveAttPartbody", "saveAttachedBody", "saveAppachmentBody", "saveAppensionPart", "saveAppachmentFile", "saveAttensionbody", "saveAttachmentFile", "saveAttPartPart", "saveAttachedbody", "saveAttensionPart", "saveAppachmentPart", "saveAppensionBody", "saveAttachedPart", "saveAppensionbody", "saveAppensionFile", "saveAttPartFile", "saveAttPartBody", "saveAttachmentbody", "saveAppachmentbody", "saveAttensionBody", "saveAttensionFile"], "context": ["text", "contact", "message", "concept", "media", "cache", "current", "client", "cf", "translation", "c", "config", "front", "system", "environment", "kernel", "state", "component", "event", "view", "driver", "processor", "content", "input", "ca", "manager", "project", "Context", "present", "definition", "service", "resource", "ce", "document", "subject", "host", "center", "container", "connection", "channel", "queue", "coll", "cca", "collection", "mc", "request", "version", "template", "community", "support", "reader", "ctx", "parent", "network", "cms"], "part": ["p", "pre", "source", "message", "parts", " Part", "app", "position", "media", "pod", "translation", "point", "component", "place", "state", "event", "per", " parts", "po", "area", "to", "image", "or", "PART", "object", "from", "service", "comment", "base", "name", "phase", "chapter", "body", "upload", "connection", "patch", "channel", "section", "mission", "plan", "block", "html", "Part", "file", "Parts", "partial", "art", "type", "parent", "start"], "localAttachment": [" localAttachachment", "LocalAttention", " localAttment", "localAddachment", "localExtacher", "localAttachacement", " localAttacement", " localExtacement", " localExtacher", " localAttrollment", "localAssachment", "localInstension", "localAttension", " localPartention", " localAttension", "LocalAttachment", "localAssail", "LocalAttail", "LocalAssachment", "localattment", "localattention", "localAvachment", "localArtail", "localAddail", "localPartachment", " localPartension", " localAttribution", "localAvention", "localAddention", "localAvacher", "localattrollment", "localArtment", "localAttment", "localAttachachment", "localInstachment", "localAttacher", " localExtachment", "localAttachension", "localAddment", " localPartachment", "localAttachribution", " localAttachrollment", "LocalAssment", "localPartention", "localAssment", "localInstention", "localPartension", " localAttacher", " localPartribution", "localAttribution", "localAttacement", "localArtention", "localAvacement", "localInstribution", "localAttention", "localAttachention", "LocalAssail", "localAddrollment", "LocalAssention", "localattachment", "localAttachrollment", "localAssention", "localAttachacher", "localAttrollment", " localExtention", "localExtention", "localPartribution", " localAttention", "localAttail", "LocalAttment", "localExtachment", " localAttachention", "localArtachment", "localExtacement"], "accountId": ["jobid", "AccountID", " accountName", "appID", " accountid", "accId", "appId", "jobId", " accountInfo", "accInfo", "contactid", "accountInfo", " accountID", "accid", "AccountId", "feedid", "contractName", "Accountid", "accID", "appid", "appInfo", "AccountName", "contractid", "contactName", "feedID", "accountName", "accountID", "contractId", "feedName", "feedId", "jobID", "jobName", "contactId", "accountid"], "attachmentId": ["attociationReference", "atociationID", "extachmentID", "adentionID", "attentionSource", "attachmentReference", "attachedId", "attmentReference", "addentionID", "addentionUrl", "attachmentIndex", "attociationId", "atachmentReference", "adachmentID", "attachmentName", "extensionSource", "atachmentId", "attmentID", "attentionIndex", "attensionSource", "attachedUrl", "extensionid", "attociationID", "attentionUrl", "attentionId", "adachmentIndex", "attptionIndex", "attentionid", "addachmentId", "atachmentID", "attlementId", "attlementReference", "attmissionId", "atociationId", "attmissionID", "extachmentSource", "addachmentType", "attentionInfo", "addentionId", "attptionInfo", "attociationUrl", "attlementID", "attmissionSource", "attptionId", "addentionType", "attlementName", "attociationType", "attachmentUrl", "extensionId", "attensionID", "attptionID", "attentionID", "attmentId", "attensionid", "attmentName", "adachmentId", "adentionIndex", "attentionType", "adentionId", "attachmentInfo", "attagramIndex", "addachmentID", "extensionID", "attachmentSource", "attachmentid", "extachmentId", "extachmentid", "attensionId", "attagramInfo", "adentionInfo", "atachmentName", "attmissionid", "atociationReference", "attachmentID", "atociationName", "attagramId", "attachmentType", "adachmentInfo", "attachedType", "attociationName", "addachmentUrl", "attachedID", "attagramID"], "in": ["p", "source", "as", "init", "copy", "gin", "inn", "pin", "inner", "ac", "load", "f", "info", "plus", "pass", "i", "input", "socket", "inside", "image", "conn", "or", "IN", "data", "ini", "con", "up", "a", "url", "din", "it", "is", "nin", "ins", "cin", "In", "inc", "again", "file", "pull", "err", "login", "slice", "id", "reader", "bin"], "saveIn": ["SaveAs", "savOut", "writeOut", " saveOut", "aveAs", "stageIns", "saveIN", "aveOut", "stageOut", "SaveIns", "savein", "SaveOut", "savIn", "writeIn", " saveIN", "saveOut", "savin", "avein", "stageIn", "saveIns", "aveIn", "writein", " saveIns", " savein", "stageAs", "savAs", "writeIN", "aveIN", "SaveIn"], "saveAs": ["SaveAs", "openAS", "saveAS", "writeOut", " saveOut", "copyas", "copyAS", "saveFile", "writeAs", "writeAS", "createFile", "SaveAS", "saveas", " saveAS", "SaveOut", "copyIn", "writeIn", "openAt", "openFile", "createAs", "saveOut", "saveAt", " saveFile", "createAt", "openAs", " saveas", " saveAt", "Saveas", "createAS", "copyAs", "SaveIn"], "out": ["flow", "source", "as", "init", "copy", "cache", "output", "client", "sync", "path", "inner", "c", "at", "s", "this", "page", "plus", "ex", "to", "OUT", "conn", "line", "image", "default", "data", "writer", "other", "up", "io", "a", "name", "null", "outer", "ext", "exec", "string", "Out", "outs", "inc", "again", "off", "file", "temp", "err", "o", "v", "bin"], "copySize": ["copyAddress", "lesize", "copyTime", "CopyTime", "openSize", "leLength", "bytesize", "saveSize", "opensize", "byteTime", "leSize", " copyLength", "openSIZE", " copyAddress", "leSIZE", "byteSize", "saveAddress", "copysize", "copySIZE", "Copysize", "saveLength", "byteLength", "byteAddress", " copysize", "openLength", " copyTime", "savesize", "copyLength", "CopyLength", " copySIZE", "CopySize"], "contentUriString": ["contentIrisStr", "contentUiniByte", "contentUrisStr", "contentUrisstring", "contentIriByte", "contentUriByte", "contentUpiInt", "contentUiNumber", "contentIrisstring", "contentUuriString", "contentUristring", "contentUrisString", "contentUioStr", "contentUrisInt", "contentUioString", "contentIriString", "contentUridStr", "contentUioInt", "contentIrisInt", "contentIriNumber", "contentIrisUnit", "contentIiByte", "contentIristring", "contentUridString", "contentUriNumber", "contentUriStr", "contentUpiStr", "contentIriInt", "contentUuriByte", "contentUuriNumber", "contentIiString", "contentUrisUnit", "contentUriUnit", "contentIrisString", "contentUuriStr", "contentIriUnit", "contentUriInt", "contentUiniString", "contentIiNumber", "contentIriStr", "contentIiStr", "contentUiStr", "contentUiByte", "contentUpiString", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUiostring", "contentUiUnit", "contentUpistring", "contentUiString"], "mSize": ["cCount", "cName", "pCount", "iLength", "iName", "iSize", "pSize", "mCount", "mLength", "mName", "pLength", "cLength", "iCount", "cSize", "pName"], "mContentUri": ["mContentUric", "mContentOUri", "mContentIric", "mResourceUri", "mResourceUris", "mContentUrric", "mContentIci", "mResourceIris", "mContentUrris", "mContentUris", "mContentOUci", "mResourceIci", "mContentIri", "mContentIris", "mResourceIric", "mResourceIri", "mContentUrri", "mContentUci", "mResourceUci", "mContentOUris", "mContentOUric", "mContentUrci", "mResourceUric"], "cv": ["uv", "cs", "xc", "fp", "uc", "cf", "ctrl", "nv", "cover", "csv", "c", "buf", "CV", "ov", "vr", "pb", "ca", "keep", "loc", "vp", "iq", "vs", "GV", "core", "bc", "av", "conv", "lc", "vm", "iv", "um", "cr", "sc", "rc", "cc", "nc", "VC", "cp", "enc", "cm", "coll", "auc", "fc", "cd", "cu", "lv", "vc", "mc", "cap", "que", "vv", "sv", "ctx", "v", "cb", "co", "content"], "uri": ["uni", "uid", "path", "username", "point", " ur", "environment", "i", " URI", "ci", "data", "resource", "proxy", "format", "location", "metadata", "storage", "url", "base", " url", "iv", "ui", "query", "address", "api", "pi", "iri", " Uri", " scheme", "string", "gb", "mi", "prefix", "oid", "qi", "range", "universal", "attribute", "route", "cli", "href", "URI", "id", "ri", "http"]}}
{"id1": "7169984", "id2": "19378010", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"connRemote": ["execIP", "invokeURL", "execLocal", " execRemote", " executeURL", "invokeIP", " executeRemote", " executeLocal", " executeIP", " execLocal", "execURL", " execURL", "execRemote", " execIP", "invokeRemote", "invokeLocal"], "jsonObject": ["JSONArray", "jsonObj", "jsonOperation", "httpOperation", " jsonString", "JSONBody", "httpObject", "httpArray", "customArray", "jsonArray", "customObject", "jsonBody", "jsonOb", " jsonBody", "javaBody", " jsonOb", "customObj", "JSONOb", "JSONOperation", "javaObject", "jsonString", "httpObj", "JSONString", "javaString", "customOperation", "javaOb", "JSONObject", "JSONObj"], "OPCode": ["OPcode", " OPcode", "OpCode", "OPName", "opName", " OPName", "opCode", "OPAction", "OpAction", " OPAction", "opAction", "opcode", "Opcode", "OPERCode", "OpName", "OPERcode", "OPERName"], "retSrc": [" retSsrc", "retOsrt", "retInrc", "retSrt", "RetAsrc", "retDRC", "retOsRC", "retInuc", "retSuc", " retSrt", "retDrc", "retNRC", "retDuc", "RetAsuc", "RetAsck", "retInck", "retSck", "retSRC", "retPvc", " retSvc", "retSsrc", "RetSuc", "retDck", " retDrc", "retOssrc", "retNrc", "retPRC", "retNsrc", "retNvc", "RetAsRC", "RetSrc", " retDsrc", "retNrt", "retOsrc", "retAsRC", "retPsrc", "RetSRC", " retDRC", " retSRC", "retDrt", "retPrc", " retDrt", "retInRC", "retAsck", "retAsuc", "RetSck", "retAsrc", "retSvc", "retDsrc"], "httpClient": ["HttpClient", "httpsClient", "HttpConnection", "httpsCall", "apiPost", "phpCall", "httpProxy", "httpConnection", "apiCall", "HttpProxy", "xmlClient", " httpProxy", " httpConnection", "httpCall", "httpCase", "xmlProxy", "phpclient", "httpsPost", "xmlCase", "apiclient", "apiClient", "phpPost", "HttpCase", "phpClient", " httpCase", "xmlConnection", "httpclient", "httpsclient"], "httpPost": ["webPost", "workpost", "autoPost", "HttpCopy", "workPre", "HttpPost", " httpPOST", "webpost", "httpPre", "httpsPOST", "htmlPOST", "httpDo", "httpPOST", " httpPre", " httpCopy", "HttpDo", " httpRequest", "autoPOST", "httppost", "httpsPre", "workPost", "httpsPost", "phpPost", "httpRequest", "autoPre", "phpPOST", "workDo", "phpRequest", "httpsCopy", "HttpPOST", "webDo", "HttpPre", "httpCopy", "phpDo", "htmlPost", "autoCopy", "webPre", "htmlDo", "HttpRequest", " httppost", " httpDo", "htmlCopy"], "httpParams": ["httpArgms", "hrParars", "hrPam", "httpCatars", "httpPms", "hrPams", " httpParums", "httpPeram", " httpParars", "httpPerars", "httpCatms", " httpPums", "httpVariums", "httpParums", " httpPam", "httpCatams", "httpPerums", "httpParars", " httpPars", "httpParms", "httpVariars", " httpPams", "hrParams", "httpPars", "httpArgams", "hrPars", "httpPams", "httpVariams", "httpParam", "httpArgam", "httpArgars", "httpPerams", "hrPms", "httpVariam", " httpParam", "hrParam", "httpPam", "httpCatam", "httpPums", "hrParms"], "nameValuePair": ["nameNamePenter", "nameNameLair", "nameValueLolder", "nameValuePhair", "nameValuePatch", "nameVPait", "nameValueSair", "nameNamePiece", "nameNameLolder", "nameValueParait", "nameValueFiece", "nameValueProtenter", "nameValuePointair", "nameValueCait", "nameNamePatch", "nameValueLair", "nameVPair", "nameValuePait", "nameNameProtenter", "nameValueProtpair", "nameNamePore", "nameValueportion", "nameValuepiece", "nameValuePerair", "nameValuepatch", "nameNamePolder", "nameNamepiece", "nameValueProtore", "nameValueFair", "nameValueProtair", "nameNamepair", "nameValuePiece", "nameValueParpair", "nameNameProtair", "nameNameProtpair", "nameValuePeratch", "nameVPpair", "nameValuepolder", "nameValuePpair", "nameValuePore", "nameValueParair", "nameValueSore", "nameValuepair", "nameNameProtore", "nameNamePair", "nameValuepait", "nameValueLatch", "nameValuePointpair", "nameValueFortion", "nameValuePhiece", "nameValueCair", "nameVCait", "nameValuePenter", "nameValueppair", "nameNamePpair", "nameValuePointenter", "nameValueSenter", "nameNameLatch", "nameNameportion", "nameVCair", "nameValuePortion", "nameVCpair", "nameValueCpair", "nameValuePhortion", "nameNamePortion", "nameValuePolder", "nameValuePerolder", "nameValueSpair", "nameValuePointore"], "response": ["message", "method", "result", "output", "json", "session", "f", "environment", "status", "page", "view", " Response", "e", "i", "success", "tree", "application", "resp", "data", "throw", "object", "resource", "reply", "server", "Response", "entity", "api", "res", "body", "jet", "connection", "respond", "channel", "full", "block", "request", "wave", "feed", "site", "v", "http"]}}
{"id1": "8132219", "id2": "14231545", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "inFile": ["INSourceFile", "outFiles", "INFilename", "inputFile", "InFilename", " infile", "inPlace", " inFilename", "InFile", "inSourceFile", "binfile", " inSourceFile", "binFiles", "INfile", "outPlace", "inFiles", "inputfile", "binPlace", "InSourceFile", "INFile", "binFile", "outfile", "infile", "inputFiles", "inputPlace", "Infile", "inFilename"], "outFile": ["outFiles", " outFiles", " outfile", "outputFilename", "againPlace", " outPlace", "againFile", "outputPlace", "againfile", "outPlace", "inFiles", "outputfile", "outFilename", "againFilename", "outputFile", "outfile", "infile", " outFilename", "outputFiles", "inFilename"], "in": ["work", "x", "source", "as", "inn", "pin", "inner", "c", "f", "config", "i", "input", "image", "IN", "data", "m", "ini", "n", "io", "a", "url", "base", "name", "din", "is", "index", "ins", "connection", "In", "inc", "again", "like", "rin", "file", "part", "id", "reader", "bin", "ic"], "out": ["p", "x", "dot", "call", "buffer", "copy", "cache", "output", "client", "c", "w", "ex", "to", "OUT", "conn", "line", "image", "default", "data", "writer", "resource", "io", "n", "log", "name", "b", "null", "ext", "obj", "exec", "string", "external", "plain", "prefix", "Out", "write", "outs", "Output", "file", "version", "part", "o", "user", "v", "bin"], "inChannel": ["sinChan", "outchannel", " inConnection", "inChan", "iniLanguage", " inchannel", "inputChan", "inputChannel", "INChannel", "inLanguage", "INChan", "INStream", "outLanguage", "winChannel", "INSocket", "iniChannel", "inConnection", "outConnection", "winLanguage", "inichannel", " inChan", "sinChannel", "sinSocket", "iniStream", "INConnection", "inFlow", "sinFlow", "inchannel", "inputStream", "winchannel", " inSocket", "outChan", "INFlow", "outStream", "winStream", " inFlow", "INchannel", "inStream", "inSocket", "inputchannel"], "outChannel": ["outPath", "OutContext", "newStream", "outchannel", "OutChan", "inChan", " outStream", "againChan", "outputchannel", "outContext", "Outchannel", "newContext", "inPath", "inConnection", "outConnection", " outChan", " outchannel", "againChannel", "inchannel", "OutStream", "newChan", "outputChannel", "OutConnection", "newChannel", " outPath", "outChan", " outContext", "outStream", "outputChan", "OutChannel", "againPath", " outConnection", "againchannel"]}}
{"id1": "15896098", "id2": "12744653", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Chchecksam", "getSHA256Chcksam", "getSHA256Cheicksums", "getSHA256Cheicksam", "getSHA256Chechecksam", "getSHA256Checsumber", "getSHA256Chchecksum", "getSHA256Checksumber", "getSHA256Cheicksumber", "getSHA256Chcksum", "getSHA256Checsam", "getSHA256Chcksums", "getSHA256Chcksumber", "getSHA256Cheicksum", "getSHA256Chchecksumber", "getSHA256Chechecksums", "getSHA256Checsums", "getSHA256Chechecksumber", "getSHA256Checksums", "getSHA256Chchecksums", "getSHA256Chechecksum", "getSHA256Checksam", "getSHA256Checsum"], "source": ["text", "message", "buffer", "result", "cache", "output", "uri", "fp", "length", "path", "config", "seed", "input", "ources", "ource", "src", "SOURCE", "data", "Source", "service", "object", "resource", "from", "format", "dest", "url", "base", "code", "string", "connection", "size", "file", "slice", "reader", "target", "content"], "checksum": ["cs256", "hexumption", "checkum", "ckset", "hsums", "checks256", " checks256", "csup", "hssum", "checksup", "cksums", "checksam", " checkset", "cksum", "hsam", "checkssum", "cksam", "hsum", " checksums", "cssum", "csum", " checksam", "checkset", " checkssum", "cksumption", " checksup", "ckssum", "checksums", "check256", "checksumption", "hexsum", "hexet", "hexum", " checksumption", "checkup"], "md": ["mand", "hm", "mm", "mp", "amd", "Cmd", "f", "hash", "wd", "dig", "cmd", "dm", "M", "mb", "ind", "m", "nm", "metadata", "mac", "bf", "grad", "rm", "sm", "ms", "vm", "vd", "um", "pd", "gd", " MD", "od", "dd", "cm", "mo", "MB", "hd", "mt", "am", "MD", "dh", "mc", "df", "mag", "pm", "d", "rpm", "bd"], "byteData": ["characterText", "ByteArray", "ByteData", "pixeldata", " byteBytes", "bitData", " byteText", "wordData", "connectionDATA", "wordArray", "bytedata", "ByteDATA", "characterArray", " byteDATA", "numberDATA", "byteBytes", "pixelData", "ByteSize", "byteText", "pixelString", " byteArray", " byteList", "connectionArray", "numberdata", " byteInfo", "connectionSize", "byteSize", "ipNumber", "byteArray", "ByteInfo", "bitList", "bitNumber", "ipData", "characterData", "bitDATA", " byteNumber", " byteString", "ipArray", "pixelDATA", "byteDATA", "byteList", "connectionData", "byteNumber", "bitText", "characterList", "bitArray", "byteString", "ByteBytes", "ipDATA", "byteInfo", " byteSize", " bytedata", "numberData", "wordInfo", "numberString", "wordBytes"], "sb": ["ls", "bh", "buffer", "ab", "xb", "SB", "cb", "bb", "buff", "fb", "buf", "ub", "sg", "pb", "src", "mb", " SB", "bp", "kb", "binary", "ws", "lb", "bf", "si", "bc", "bt", "b", "usb", "nb", "bs", "bg", "rb", "eb", "gb", "bm", "BB", "sq", "bsp", "wb", "sf", "ob", "sv", " eb", "db", "abb", "bd"], "i": ["p", "x", "uri", "c", "ni", "ai", "f", "gi", "ii", "info", "ix", "ori", "w", "e", "d", "ie", "l", "I", "k", "ci", "data", "abi", "ini", "q", "in", "multi", "ip", "n", "bi", "iu", "io", "si", "u", "b", "it", "is", "ui", "pi", "oi", "ji", "li", "j", "index", "h", "hi", "mi", "di", "qi", "y", "xi", "r", "key", "slice", "o", "id", "v", "ri", "ti", "phi"], "hexString": ["hexArray", "crossBuffer", " hexstring", "charString", "shortString", "formService", "hexCode", "rawService", "exFile", "checkArray", "charBuffer", "hexBuffer", " hexService", " hexBuffer", "checkCode", "shortStr", "hexstring", " hexCode", "checkService", "hashService", "crossFile", "shortArray", "hexFile", "formstring", "charArray", "hexService", "exString", "charStr", " hexStr", "formString", "exBuffer", "checkString", "rawstring", " hexFile", "exStr", "crossString", "hexStr", "crossStr", "shortBuffer", "hashString", " hexArray", "hashCode", "rawString", "hashArray", "rawArray", "formArray"], "hex": ["text", "form", "nexus", "closure", "cookie", "char", "str", "sync", "length", "color", "shift", "buff", "hash", "cross", "ex", "none", "data", "format", "transform", "ip", "pixel", "bit", "character", "num", "null", "zip", "letter", "oct", "wh", "string", "exp", "alpha", "digit", "comp", "sum", "raw", "lit", "pex", "coord", "serial", "rex", "temp", "utf", "pack", "id", "sex", "rh", "bin", "cmp", "http"]}}
{"id1": "10218878", "id2": "15445861", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFileFile", "DecodeMapfile", "DecodemapFile", "DecodeFileFiles", "DecodeFilefile", "DecodeDataFiles", "DecoderMapFiles", "DecodemapFiles", "DecoderFileFile", "Decodemapfile", "DecoderMapFile", "DecoderFileFiles", "DecoderFilefile", "DecodeDataFile", "DecodeMapFiles", "DecodeDatafile", "DecoderMapfile"], "mapFile": ["addressFull", "MapLog", "loadfile", "batchUrl", "loadFull", "fileFile", "mapFull", "MapUrl", "mapfile", "MapFile", "mapLog", "loadTable", "filefile", "apperUrl", "addressTable", "fileTable", "apperLog", "loadFile", "mapTable", "addressfile", "mapUrl", "batchFile", "fileFull", "batchLog", "addressFile", "apperFile"], "outputFile": ["OutputStream", " outputfile", "outputDir", "inputFiles", "inputFile", "responseStream", "inputFolder", "inputDir", "responsefile", "responseFiles", " outputStream", " outputFiles", "outputFolder", "Outputfile", "responseFile", "outputStream", "OutputDir", "outputfile", " outputDir", "OutputFile", "OutputFiles", "OutputFolder", "outputFiles", " outputFolder"], "magicKey": ["MagicKey", "magicLink", "specialkey", "specialSecret", " magicK", "magicSecret", "prefixLink", "MagicLetter", "cacheKey", "cacheChar", " magicSecret", " magicLink", "Magickey", "magicK", " magickey", " specialKey", "prefixKey", " specialkey", "specialKey", " specialLetter", "cachekey", "techLink", " magicKEY", "magickey", " specialK", "cacheSecret", "prefixKEY", " magicChar", "techkey", "techKEY", "magicChar", "specialChar", "MagicK", "magicLetter", "magicKEY", "techKey", "prefixkey", " magicLetter"], "buffer": ["source", "message", "shape", "position", "cache", "result", "token", "bar", "length", "memory", "pad", "buff", "bb", "buf", "seed", "input", "uffer", "count", "read", "FFER", "data", "writer", "binary", "comment", "document", "url", "base", "array", "b", "null", "code", "transfer", "address", "Buffer", "variable", "header", "stack", "queue", "layer", "batch", "reference", "iter", "pause", "row", "wave", "feed", "slice", "reader", "offset"], "nread": ["nreads", "Nload", "Nfind", " nRead", "pload", "NRead", "Nread", " nload", "enreads", "nwrite", "enwrite", " nwrite", "enread", "pread", "nereader", "nfind", "neread", "neRead", "nload", "enfind", "nreader", "newrite", "pRead", "Nreader", "pwrite", "Nreads", " nfind", "nRead", "enRead", "Nwrite", " nreads", " nreader"], "map": ["work", "pre", "source", "flow", "group", "make", "message", "create", "app", "bridge", "copy", "cache", "media", "out", "parse", "client", "apper", "cover", "config", "pad", "use", "master", "per", "one", "input", "image", "m", "data", "module", "resource", "MAP", "open", "core", "code", "pool", "transfer", "address", "index", "list", "header", "lock", "over", "stream", "cm", "layer", "ap", "write", "block", "file", "wave", "pack", "key", "maps", "pair"], "output": ["flow", "cut", "cache", "out", "update", "config", "model", "page", "control", "console", "input", "image", "global", "pot", "data", "web", "module", "object", "other", "resource", "export", "core", "document", "log", "ou", "outer", "utils", "function", "operation", "address", "number", "connection", "external", "exit", "queue", "layer", "write", "reference", "Output", "sort", "put", "file", "office", "ilo", "response", "o", "unit", "oper", "error", "target", "run", "application"], "i": ["p", "x", "uri", "length", "z", "c", "f", "ai", "gi", "ii", "info", "e", "l", "I", "ci", "uli", "m", "ini", "in", "multi", "ip", "io", "bi", "a", "si", "u", "b", "it", "ui", "pi", "oi", "ji", "li", "j", "di", "qi", "xi", "t", "mu", "slice", "id", "o", "zi", "v", "ri", "ti", "phi"]}}
{"id1": "1180878", "id2": "13783549", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchJSONData", "frieveURLData", "fetchUrldata", "frieveURLDATA", "frieveURLdata", "fetchUrlData", "fetchJSONdata", "fetchHTTPData", "fetchURLDATA", "frieveUrlDATA", "fetchHTTPdata", "fetchHTTPDATA", "fetchUrlDATA", "fetchURLdata", "fetchJSONDATA", "frieveUrldata", "frieveUrlData"], "url": ["ls", "source", "text", "filename", "gl", "uri", "path", "username", "Url", "download", "f", "page", "view", "l", "src", "image", "loc", "data", "resource", "location", "www", "base", "name", "server", "host", "URL", "fl", "address", "sl", "api", "string", "connection", "ur", "el", "html", "file", "ssl", "href", "feed", "user", "xml", "http"], "proxyHost": ["ProxyHost", "remoteHead", "proxyHead", "ProxyPath", "serverHost", "remoteHost", "serverServer", "proxyPath", "serverAddress", "remoteDomain", "baseHead", "ProxyHead", "proxyServer", "Proxyhost", "proxyDomain", "cacheAddress", "baseHost", " proxyAddress", " proxyPath", "proxyhost", "remoteAddress", "serverPath", "proxyAddress", "baseDomain", "cacheHost", "ProxyPort", "cachePort", "baseAddress", " proxyServer", " proxyhost", "ProxyServer", "cachehost", "ProxyDomain", "ProxyAddress"], "proxyPort": ["ProxyHost", " proxyport", "httpHost", "cacheport", "httpAddress", "Proxyport", "proxyServer", "cacheAddress", "httpServer", " proxyAddress", "proxyAddress", "cacheHost", "ProxyPort", "cachePort", "httpPort", " proxyServer", "ProxyServer", "proxyport", "ProxyAddress"], "con": ["x", "remote", "cache", "uc", "out", "ai", "ca", "ci", "close", "act", "Con", "conf", "cur", "cc", "cp", "fc", "un", "run", "can", "go", "http", "pre", "rec", "sync", "ctrl", "pin", "ocon", "ver", "com", "cone", "conn", "win", "pub", "n", "don", "rc", "mc", "cons", "ls", "pen", "fun", "cf", "socket", "cas", "bc", "pc", "gen", "cr", "sub", "fl", "cm", "en", "syn", "login", "inc", "fan", "xc", "re", "ac", "c", "f", "per", "func", "an", "open", "ec", "on", "connect", "conv", "change", "fac", "exec", "ran", "ch", "min", "canon", "connection", "fa", "cl", "cn", "part", "CON", "common", "co"], "is": ["p", "mis", "as", "ris", "cs", "ps", "im", "IS", "out", "oss", "us", "isa", "was", "ai", "info", "s", "its", "state", "ori", "il", "isu", "iss", "are", "i", "ie", "Is", "ri", "conn", "serv", "ci", "or", "iso", "in", "ib", "lis", "does", "vs", "ws", "ir", "act", "isin", "ar", "si", "os", "cos", "it", "isc", "fs", "bs", "isl", "api", "isi", "sp", "ais", "ios", "ics", "es", "abs", "iris", "id", "bis", "get", "has", "js", "cms", "can", "ops"], "u": ["p", "uv", "su", "fu", "uri", "uc", "client", "us", "c", "f", "i", "l", "conn", "m", "q", "tu", "ru", "ut", "yu", "iu", "io", "up", "ou", "os", "b", "ui", "api", "nu", "h", "uci", "ur", "ul", "lu", "un", "cu", "file", "hu", "U", "o", "user", "v", "ue", "http"], "proxy": ["p", "x", "create", "remote", "copy", "cache", "uri", "phone", "port", "client", "pin", "c", "config", "f", "plus", "timeout", "l", "socket", "pse", "web", "prot", " Proxy", "resource", "cop", "force", "ip", "pa", "shadow", "bean", "clone", "pc", "pe", "server", "host", "pool", "zip", "fe", "address", "api", "xy", "connection", "XY", "wrapper", "lib", "roxy", "ssl", "Proxy", "type", " proxies", "http"], "baos": ["aOS", "BAo", "abros", "BAOS", "baOs", "boas", "abos", "caos", "BAis", "boOS", "pao", "alos", "BAOs", "baas", "calos", "haos", "BaOs", "baOS", "Baros", "balos", "paOS", "bolos", "Baos", "haOS", "caOS", "BAros", "caas", "baros", "bais", "hao", "abOs", "hais", "aos", "boos", "Bais", "pais", "abis", "bao", "BAos", "paos", "aas"]}}
{"id1": "8490710", "id2": "4593012", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"actualizar": ["actualizerada", " actualizear", "actualizerado", " actualizada", " actualizas", "actualizeada", "actualizeras", "actualizas", "actualizado", " actualizado", " actualizeada", "actualisiar", "actualisias", "actualizada", "actualizeado", "actualizear", "actualizeas", "actualizerar", " actualizeado", "actualisiada", "actualisiado", " actualizeas"], "ClassNotFoundException": ["ClassNotPresentES", "ClassNotFoundError", "ClassNotSupportedException", "ClassNotPresentError", "ClassNotSupportedError", "ClassNotFoundES", "ClassNameFoundError", "ClassNameFoundES", "ClassNotSupportedES", "ClassNameFoundException", "ClassNotFindError", "ClassNameSupportedES", "ClassNotPresentException", "ClassNotFindException", "ClassNameSupportedException", "ClassNameSupportedError", "ClassNotFindES"], "Exception": ["F", "Element", "Ex", "Information", "Error", "Engine", "Connection", "Exp", "Adapter", "Exc", "Context", "E", "Interface", "W", "Failure", "IO", "Transaction", "X", "Throw", "Warning", "Except", "Problem", "Fail", "Un", "Null", "Document", "ERROR", "Unknown", "Class", "T", "Event", "Application", "EX", "Abstract", "ceptions", " exception", "Default", "ception", "Request", "Entity", "except"], "conn": ["p", "cs", "util", "client", "oss", "mm", "session", "cb", "c", "cat", "config", "reg", "Connection", "state", "ens", "nt", "ca", "Conn", "ci", "loc", "con", "pg", "pub", "n", "connect", "ann", "col", "ou", "cr", "conf", "ch", "jc", "rc", "connection", "nc", "h", "cc", "cp", "enc", "cm", "coll", "Connect", "oci", "sql", "en", "ok", "sn", "cn", "dh", "mc", "cli", "ob", "ct", "comm", "ctx", "db", "dc"], "ms": ["me", "ls", "ums", "hm", "mis", "cs", "ps", "md", "ts", "mm", "mp", "ml", "mod", "ys", "keys", "s", "DS", "mos", "ens", "pse", "mb", "ds", "ans", "sem", "m", "mes", "rs", "vs", "ws", "mx", "oms", "ks", "em", "mas", "os", "qs", "is", "fs", "ims", "bs", "Ms", "gm", "res", "cus", "tm", "ins", "models", "ems", "mi", "bm", "mn", "details", "mo", "mt", "gs", "sql", "ns", "mc", "MS", "es", "ma", "pm", "js", "cms", "ops"], "fechaSystem": ["fechlaSTEM", "febaService", "fechasSys", "fechtaSystem", "fekasSystem", "fechasService", "fichlaSys", "febaSystem", "febasService", "fichlaSystem", "fichaSystem", "fetchaSTEM", "febaSys", "fechasSystem", "fechmaSys", "fechaSys", "fechlaSys", "fekaSystem", "fechmaSystem", "fechasSTEM", "fechasServer", "fechosystem", "fekaSTEM", "fetchasystem", "fechtasystem", "fekasSTEM", "fechtaSys", "fechmaSTEM", "fechaSTEM", "fetchmaSTEM", "fichasystem", "fekaSys", "fechoSTEM", "fechaServer", "fechaService", "febasSys", "fechetaService", "fechlasystem", "fechmaService", "fechasystem", "febasServer", "fichaSys", "febasSystem", "fechoSystem", "fechetaSys", "febaServer", "fichlasystem", "fetchaSystem", "fechetaServer", "fechmaServer", "fechetaSystem", "fechassystem", "fechmasystem", "fetchmaSystem", "fekasSys", "fetchmasystem", "fechlaSystem"], "aaaammdd": ["aaaasmds", "aaaasmd", "aaaamd", "aaaamtz", "aaaymmd", "aaaaammd", "aaaamdd", "aaaammds", "aaaammtz", "aaammsd", "aaaaamtz", "aaammdd", "aaaymmsd", "aaaasmdd", "aaaaammds", "aaaaamd", "aaaaammsd", "aaaamsd", "aaammtz", "aaaymmds", "aaaaammdd", "aaaymmdd", "aaaaamsd", "aaammds", "aaaaammtz", "aaaamds", "aaaammsd", "aaaasmtz", "aaaaamdd", "aaaammd", "aaammd", "aaaaamds"], "fzafsis": ["fzafsi", "fzahs", "fzafs", "fzahsi", "fzAFs", "fzhafs", "fzaphsi", "fzhafsi", "fzhahsi", "fzaphsis", "fzaftics", "fzAFsis", "fzaphs", "fzaphtics", "fzhafsis", "fzhahs", "fzhahsis", "fzAFsi", "fzhahtics", "fzhaftics", "fzAFtics", "fzahtics"], "hhmmss": ["hhMMds", "hhmds", "hhMMms", "HHmms", "hhhmms", "HHMMs", "hhhmmms", "hhmdess", "hhmss", "hhhmmmess", "hhmmmds", "HHmmds", "HHMMds", "hhmmmess", "hhmms", "hhms", "hhmmds", "hhmdss", "HHMMss", "hhhmmess", "hhmdds", "hhhmmds", "hhhmmmss", "hhmmess", "HHMMms", "hhmmmss", "hhMMss", "hhMMs", "hhmls", "hhmmms", "HHmmss", "hhMMess", "hhhmmss", "HHmmms", "hhmlms", "hhmlds", "hhmlss", "hhhmmmds"], "sss": ["rsss", "\u00dfss", "ssls", "ssp", "ssns", "rssp", "\u00dfls", "usss", " ssp", " ssss", " ssses", "ussss", "ussp", "rssls", "ssses", "ussses", "hessss", "rssns", "hessns", "hessls", "ssss", "rssss", "\u00dfs", "\u00dfns", "hesss", "rssses"], "ss": ["account", "ls", "eps", "cs", "su", "hess", "ps", "ts", "str", "hh", "oss", "st", "styles", "s", "less", "tz", "pass", "iss", "\u00df", "ds", "pps", "pg", "rs", "vs", "ws", "ess", "nn", "si", "ses", "fs", "bs", "sl", "ross", "rss", "string", "struct", "ng", "sq", "settings", "ns", "css", "WS", "xx", "ssl", "SS", "ssh", "sf", "sv", "js", "uss", "ass"], "fzahsis": ["fzeajsis", "fzajses", "fzafsi", "fzeafses", "fzahsi", "fzavses", "fzahses", "fzavtics", "fzaftics", "fzeafsis", "fzajtics", "fzajsis", "fzafses", "fzajsi", "fzeajses", "fzavsi", "fzeafsi", "fzeaftics", "fzeajtics", "fzavsis", "fzeajsi", "fzahtics"], "afectados": ["rafctado", "afecanos", "afectionadas", "afectionados", "afemptadas", "afectadas", "afctados", "AFecados", "afescantes", "afemptados", "afectionado", "afescados", "AFecantes", "afecados", "afectionantes", "AFecanos", "afecadas", "AFectantes", "afecantes", "rafctadas", "rafectado", "rafectatos", "afectado", "afctatos", "AFectadas", "afescadas", "AFecadas", "AFectanos", "AFectados", "afctadas", "rafectados", "afectionanos", "afemptado", "rafectadas", "afctado", "afectantes", "afectanos", "rafctados", "afectatos", "afectionatos", "rafctatos", "afescanos", "afemptatos"]}}
{"id1": "12066447", "id2": "16825994", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"truncate": ["trrenate", "trunational", "trrenator", "truncator", "trunator", "autuncator", "truncation", "autuncational", "autatenation", "autuncation", "trrenation", "truncational", "autatenational", "autuncate", "tratenate", "trrenational", "tratenational", "tratenator", "autatenator", "trunate", "tratenation", "trunation", "autatenate"], "file": ["source", "local", "filename", "File", "fp", "cache", "out", "uri", "current", "path", "f", "info", "this", "model", "page", "ile", "plus", "archive", "e", "one", "per", "l", "image", "single", "line", "or", "get", "data", "folder", "object", "resource", "format", "binary", "FILE", "directory", "io", "class", "url", "base", "log", "name", "document", "it", "files", "function", "zip", "address", "body", "time", "string", "connection", "future", "handler", "stream", "queue", "full", "type", "parent", " File", "db", "http"], "backupRoot": ["BackupPath", "backupsDirectory", "backbaseRoot", "backbackDirectory", "backupDir", "backbasePath", "frontupDir", "backupHome", "frontdownroot", "backbackRoot", "backflowDir", "backdownDirectory", "backdownFolder", "backupDirectory", "backureHome", "BackbackFile", "backUpDir", "frontdownDir", "backUpFolder", "backdownHome", "backupsroot", "BackureDirectory", "backupPath", "BackdownRoot", "backupFile", "backUproot", "BackdownDirectory", "backbackDir", "backdownRoot", "backUpRoot", "frontupFolder", "BackupDirectory", "backureDirectory", "backbackHome", "backdownroot", "backbaseroot", "backupsPath", "BackbackDir", "BackdownPath", "backbackFile", "backflowFile", "backflowRoot", "frontdownRoot", "backflowroot", "BackupHome", "BackupDir", "backupFolder", "frontupRoot", "backdownFile", "backureDir", "Backuproot", "backupsFolder", "backupsDir", "frontdownFolder", "backbaseDirectory", "BackureDir", "BackbackRoot", "backuproot", "BackupFile", "backupsRoot", "backdownDir", "backdownPath", "Backbackroot", "backureRoot", "frontuproot", "Backdownroot", "BackureHome", "BackureRoot", "backbackroot", "BackupRoot"], "df": ["flow", "DF", "md", "fp", "dict", "cf", "f", "fb", "CF", "dm", "de", "ds", "func", "data", "da", " def", "format", "dl", "bf", "pdf", "af", "io", "deb", "fd", "dt", "fs", "fe", "pd", "fn", "fr", "di", "dd", "tf", "dp", "fc", "def", "dn", "sf", "xf", "dq", "db", "d", "raf", "dc"], "date": ["work", "x", "pre", "created", "form", "message", "create", "style", "ate", "days", "re", "output", "str", "out", "fee", "sync", "day", "update", "back", "use", "ale", "input", "dates", "complete", "atom", "data", "m", "updated", "year", "module", "format", "open", "age", "valid", "url", "name", "log", "stage", "pe", "modified", "dt", "code", "ge", "dat", "time", "min", "j", "string", "tag", "dose", "rule", "Date", "D", "value", " Date", "version", "bug", "custom", "diff", "type", "db", "d"], "zipFile": ["sqlModel", "ZipFile", "zipfile", "ressFile", "Zipfile", "ressfile", "zipFiles", "zipSection", "zFiles", "ressModel", " zipFiles", "zipModel", " zipfile", "zFile", "ZipFiles", "zfile", "zModel", "zSection", "ZipEntry", "ressSection", "zipEntry", "sqlFile", "sqlfile", "sqlSection", " zipEntry", "zEntry"], "zos": ["ls", "closure", "dos", "hess", "bos", "z", "chini", "obb", "iffs", "zer", "zl", "gz", "zik", "tz", "robe", "han", "zona", "nz", "cash", "zy", "zb", "proxy", "zzy", "bitcoin", "eros", "ros", "zero", "ses", " sands", "os", "cos", "los", "ZA", "inos", "dylib", "zip", "fits", "zo", "address", "webkit", "uz", "zag", "budget", "zes", "zh", "zn", "exit", "las", "liquid", "rez", "outs", "settings", "zen", "kos", "lins", "ils", "css", "ozo", "zan", "ssl", "asio", "her", "osi", "zi", "zx", "jas", "nox", "js", "forge", "zon", "zar", "bes", "ops"], "fis": ["lids", "rafris", "fliss", "infias", "flids", "fiz", "infiss", "Fiss", "fiss", "lias", "rafis", "rafias", "flias", "flis", " fits", "flris", "vils", "bos", " fiss", "rafiss", " fiz", " fos", "biss", "bisl", "fris", "fisl", "fias", "infits", "Fos", "Fias", "lis", "liss", "Fis", "infis", " fils", "vits", "Fris", "fits", "fils", "vis", "Fisl", "Fisp", " fias", " fisp", "fisp", "infiz", "infils", "fos", " fisl", "flisp", "fids", "bis", "infids", " fris", "viz"], "entry": [" Entry", "style", "the", "uri", "se", "ace", "so", "z", "ry", "cell", "ion", "Entry", "info", "archive", "event", "extra", "e", "ie", "per", "de", "card", "image", "cel", "or", "data", "record", "array", "comment", "and", "next", "si", "ries", "lc", "add", "it", "server", "obj", "ui", "zip", "ge", "address", "term", "letter", "index", "zo", "exp", "element", "auto", "row", "r", "feed", "key", "her", "reader", "offset"], "buffer": ["vector", "sequence", "position", "shape", "cache", "result", "length", "available", "memory", "pad", "buff", "bb", "buf", "page", "seed", "bytes", "uffer", "padding", "border", "FFER", "data", "writer", "binary", "comment", "b", "device", "null", "server", "transfer", "number", "address", "Buffer", "beta", "header", "channel", "queue", "layer", "batch", "reference", "iter", "row", "wave", "feed", "slice", "reader", "flush"], "readed": ["inputED", " ReadED", "inputled", "inted", "intED", "textized", "readled", "textED", "readended", " readable", "readned", " Readed", " Readered", "readable", "bootered", "inputned", " readered", " readED", "bootable", "textended", "inputed", " readended", "texted", " Readned", " Readable", "intended", " readized", "readED", " Readled", " readled", "readered", "readized", "bootED", " readned", "booted", "intized"]}}
{"id1": "1141361", "id2": "1005108", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    public void googleImageSearch(String search, String start) {\n        try {\n            String u = \"http://images.google.com/images?q=\" + search + start;\n            if (u.contains(\" \")) {\n                u = u.replace(\" \", \"+\");\n            }\n            URL url = new URL(u);\n            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n            httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n            BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n            googleImages.clear();\n            String text = \"\";\n            String lin = \"\";\n            while ((lin = readIn.readLine()) != null) {\n                text += lin;\n            }\n            readIn.close();\n            if (text.contains(\"\\n\")) {\n                text = text.replace(\"\\n\", \"\");\n            }\n            String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n            for (String s : array) {\n                if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                    String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                    googleImages.add(s1);\n                }\n            }\n        } catch (Exception ex4) {\n            MusicBoxView.showErrorDialog(ex4);\n        }\n        MusicBoxView.jButton7.setEnabled(true);\n        ImageIcon icon;\n        try {\n            icon = new ImageIcon(new URL(googleImages.elementAt(MusicBoxView.googleImageLocation)));\n            ImageIcon ico = new ImageIcon(icon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH));\n            MusicBoxView.albumArtLabel.setIcon(ico);\n        } catch (MalformedURLException ex1) {\n            MusicBoxView.showErrorDialog(ex1);\n        }\n    }\n", "label": 0, "substitutes": {"makeRead": [" makeAdd", " makeREAD", "executeAdd", "executeREAD", " executeAdd", " executeREAD", " executeRead", " makePut", "doREAD", "doRead", "doPut", "executeRead", "executePut", " executePut", "doAdd"], "user": ["human", "uid", "mode", "token", "pod", "username", "field", "author", "date", "alias", "use", "word", "owner", "project", "meta", "USER", "item", "blog", "install", "comment", "job", "url", "log", "name", "server", "host", "password", "post", "admin", "string", "write", "usr", "creator", "users", "bug", "row", "custom", "db", "User"], "databaseID": ["DatabaseName", "tableID", "tableKey", "dbName", "tableid", "connectionID", "DatabaseUID", "databaseId", "dbUID", "connectionKey", "connectionid", "DatabaseId", " databaseUID", "dbId", " databaseId", "databaseUID", " databaseName", "databaseKey", "dbID", " databaseid", "databaseid", " databaseKey", "databaseName", "DatabaseID"], "time": ["text", "source", "message", "month", "mode", "table", "set", "str", "timer", "length", "path", "port", "depth", "instance", "date", "home", "tz", "timeout", "Time", "tim", "read", "year", "hour", "money", "comment", "TIME", "name", "host", "post", "ime", "string", "times", "size", "clock", "value", "end", "id", "rate", "type"], "query": ["work", "sequence", "message", "call", "question", "table", "script", "update", "ql", "timeout", "command", "q", "module", "comment", "error", "database", "name", "execute", "search", "code", "post", "function", "string", "connection", "sql", "qu", "sq", "eries", "filter", "request", "Query", "join", "id", "commit", "db", "select", "report"], "statement": ["ment", "message", "init", "style", "result", "expression", "media", "table", "str", "st", "Statement", "language", "session", "instance", "memory", "alias", "s", "this", "state", "use", "study", "slave", "command", "i", "note", "agent", "builder", "journal", "comment", "storage", "document", "si", "database", "execute", "server", "opened", "post", "function", "stat", "password", "connection", "string", "rule", "usage", "machine", "di", "mt", "general", "sql", "batch", "parser", "ma", "response", "join", "unit", "commit", "section", "joined", "jo", "status", "volume"], "count": ["cache", "table", "depth", "length", "check", "state", "process", "found", "total", "force", "expected", "limit", "base", "log", "code", "counter", "number", "child", "index", "list", "connection", "cc", "Count", "cond", "size", "sum", "batch", "inc", "more", "part", "err", "diff", "id", "type", "start", "error", "handle", "offset", "content"]}}
{"id1": "15799935", "id2": "8024375", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAttachmentPart", "saveAttPartbody", "saveAttachedBody", "saveAppachmentBody", "saveAppensionPart", "saveAppachmentFile", "saveAttensionbody", "saveAttachmentFile", "saveAttPartPart", "saveAttachedbody", "saveAttensionPart", "saveAppachmentPart", "saveAppensionBody", "saveAttachedPart", "saveAppensionbody", "saveAppensionFile", "saveAttPartFile", "saveAttPartBody", "saveAttachmentbody", "saveAppachmentbody", "saveAttensionBody", "saveAttensionFile"], "context": ["text", "contact", "message", "concept", "media", "cache", "current", "client", "cf", "translation", "c", "config", "front", "system", "environment", "kernel", "state", "component", "event", "view", "driver", "processor", "content", "input", "ca", "manager", "project", "Context", "present", "definition", "service", "resource", "ce", "document", "subject", "host", "center", "container", "connection", "channel", "queue", "coll", "cca", "collection", "mc", "request", "version", "template", "community", "support", "reader", "ctx", "parent", "network", "cms"], "part": ["p", "pre", "source", "message", "parts", " Part", "app", "position", "media", "pod", "translation", "point", "component", "place", "state", "event", "per", " parts", "po", "area", "to", "image", "or", "PART", "object", "from", "service", "comment", "base", "name", "phase", "chapter", "body", "upload", "connection", "patch", "channel", "section", "mission", "plan", "block", "html", "Part", "file", "Parts", "partial", "art", "type", "parent", "start"], "localAttachment": [" localAttachachment", "LocalAttention", " localAttment", "localAddachment", "localExtacher", "localAttachacement", " localAttacement", " localExtacement", " localExtacher", " localAttrollment", "localAssachment", "localInstension", "localAttension", " localPartention", " localAttension", "LocalAttachment", "localAssail", "LocalAttail", "LocalAssachment", "localattment", "localattention", "localAvachment", "localArtail", "localAddail", "localPartachment", " localPartension", " localAttribution", "localAvention", "localAddention", "localAvacher", "localattrollment", "localArtment", "localAttment", "localAttachachment", "localInstachment", "localAttacher", " localExtachment", "localAttachension", "localAddment", " localPartachment", "localAttachribution", " localAttachrollment", "LocalAssment", "localPartention", "localAssment", "localInstention", "localPartension", " localAttacher", " localPartribution", "localAttribution", "localAttacement", "localArtention", "localAvacement", "localInstribution", "localAttention", "localAttachention", "LocalAssail", "localAddrollment", "LocalAssention", "localattachment", "localAttachrollment", "localAssention", "localAttachacher", "localAttrollment", " localExtention", "localExtention", "localPartribution", " localAttention", "localAttail", "LocalAttment", "localExtachment", " localAttachention", "localArtachment", "localExtacement"], "accountId": ["jobid", "AccountID", " accountName", "appID", " accountid", "accId", "appId", "jobId", " accountInfo", "accInfo", "contactid", "accountInfo", " accountID", "accid", "AccountId", "feedid", "contractName", "Accountid", "accID", "appid", "appInfo", "AccountName", "contractid", "contactName", "feedID", "accountName", "accountID", "contractId", "feedName", "feedId", "jobID", "jobName", "contactId", "accountid"], "attachmentId": ["attociationReference", "atociationID", "extachmentID", "adentionID", "attentionSource", "attachmentReference", "attachedId", "attmentReference", "addentionID", "addentionUrl", "attachmentIndex", "attociationId", "atachmentReference", "adachmentID", "attachmentName", "extensionSource", "atachmentId", "attmentID", "attentionIndex", "attensionSource", "attachedUrl", "extensionid", "attociationID", "attentionUrl", "attentionId", "adachmentIndex", "attptionIndex", "attentionid", "addachmentId", "atachmentID", "attlementId", "attlementReference", "attmissionId", "atociationId", "attmissionID", "extachmentSource", "addachmentType", "attentionInfo", "addentionId", "attptionInfo", "attociationUrl", "attlementID", "attmissionSource", "attptionId", "addentionType", "attlementName", "attociationType", "attachmentUrl", "extensionId", "attensionID", "attptionID", "attentionID", "attmentId", "attensionid", "attmentName", "adachmentId", "adentionIndex", "attentionType", "adentionId", "attachmentInfo", "attagramIndex", "addachmentID", "extensionID", "attachmentSource", "attachmentid", "extachmentId", "extachmentid", "attensionId", "attagramInfo", "adentionInfo", "atachmentName", "attmissionid", "atociationReference", "attachmentID", "atociationName", "attagramId", "attachmentType", "adachmentInfo", "attachedType", "attociationName", "addachmentUrl", "attachedID", "attagramID"], "in": ["p", "source", "as", "init", "copy", "gin", "inn", "pin", "inner", "ac", "load", "f", "info", "plus", "pass", "i", "input", "socket", "inside", "image", "conn", "or", "IN", "data", "ini", "con", "up", "a", "url", "din", "it", "is", "nin", "ins", "cin", "In", "inc", "again", "file", "pull", "err", "login", "slice", "id", "reader", "bin"], "saveIn": ["SaveAs", "savOut", "writeOut", " saveOut", "aveAs", "stageIns", "saveIN", "aveOut", "stageOut", "SaveIns", "savein", "SaveOut", "savIn", "writeIn", " saveIN", "saveOut", "savin", "avein", "stageIn", "saveIns", "aveIn", "writein", " saveIns", " savein", "stageAs", "savAs", "writeIN", "aveIN", "SaveIn"], "saveAs": ["SaveAs", "openAS", "saveAS", "writeOut", " saveOut", "copyas", "copyAS", "saveFile", "writeAs", "writeAS", "createFile", "SaveAS", "saveas", " saveAS", "SaveOut", "copyIn", "writeIn", "openAt", "openFile", "createAs", "saveOut", "saveAt", " saveFile", "createAt", "openAs", " saveas", " saveAt", "Saveas", "createAS", "copyAs", "SaveIn"], "out": ["flow", "source", "as", "init", "copy", "cache", "output", "client", "sync", "path", "inner", "c", "at", "s", "this", "page", "plus", "ex", "to", "OUT", "conn", "line", "image", "default", "data", "writer", "other", "up", "io", "a", "name", "null", "outer", "ext", "exec", "string", "Out", "outs", "inc", "again", "off", "file", "temp", "err", "o", "v", "bin"], "copySize": ["copyAddress", "lesize", "copyTime", "CopyTime", "openSize", "leLength", "bytesize", "saveSize", "opensize", "byteTime", "leSize", " copyLength", "openSIZE", " copyAddress", "leSIZE", "byteSize", "saveAddress", "copysize", "copySIZE", "Copysize", "saveLength", "byteLength", "byteAddress", " copysize", "openLength", " copyTime", "savesize", "copyLength", "CopyLength", " copySIZE", "CopySize"], "contentUriString": ["contentIrisStr", "contentUiniByte", "contentUrisStr", "contentUrisstring", "contentIriByte", "contentUriByte", "contentUpiInt", "contentUiNumber", "contentIrisstring", "contentUuriString", "contentUristring", "contentUrisString", "contentUioStr", "contentUrisInt", "contentUioString", "contentIriString", "contentUridStr", "contentUioInt", "contentIrisInt", "contentIriNumber", "contentIrisUnit", "contentIiByte", "contentIristring", "contentUridString", "contentUriNumber", "contentUriStr", "contentUpiStr", "contentIriInt", "contentUuriByte", "contentUuriNumber", "contentIiString", "contentUrisUnit", "contentUriUnit", "contentIrisString", "contentUuriStr", "contentIriUnit", "contentUriInt", "contentUiniString", "contentIiNumber", "contentIriStr", "contentIiStr", "contentUiStr", "contentUiByte", "contentUpiString", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUiostring", "contentUiUnit", "contentUpistring", "contentUiString"], "mSize": ["cCount", "cName", "pCount", "iLength", "iName", "iSize", "pSize", "mCount", "mLength", "mName", "pLength", "cLength", "iCount", "cSize", "pName"], "mContentUri": ["mContentUric", "mContentOUri", "mContentIric", "mResourceUri", "mResourceUris", "mContentUrric", "mContentIci", "mResourceIris", "mContentUrris", "mContentUris", "mContentOUci", "mResourceIci", "mContentIri", "mContentIris", "mResourceIric", "mResourceIri", "mContentUrri", "mContentUci", "mResourceUci", "mContentOUris", "mContentOUric", "mContentUrci", "mResourceUric"], "cv": ["uv", "cs", "xc", "fp", "uc", "cf", "ctrl", "nv", "cover", "csv", "c", "buf", "CV", "ov", "vr", "pb", "ca", "keep", "loc", "vp", "iq", "vs", "GV", "core", "bc", "av", "conv", "lc", "vm", "iv", "um", "cr", "sc", "rc", "cc", "nc", "VC", "cp", "enc", "cm", "coll", "auc", "fc", "cd", "cu", "lv", "vc", "mc", "cap", "que", "vv", "sv", "ctx", "v", "cb", "co", "content"], "uri": ["uni", "uid", "path", "username", "point", " ur", "environment", "i", " URI", "ci", "data", "resource", "proxy", "format", "location", "metadata", "storage", "url", "base", " url", "iv", "ui", "query", "address", "api", "pi", "iri", " Uri", " scheme", "string", "gb", "mi", "prefix", "oid", "qi", "range", "universal", "attribute", "route", "cli", "href", "URI", "id", "ri", "http"]}}
{"id1": "20247400", "id2": "7006052", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"in": ["p", "source", "gin", "inn", "token", "client", "inner", "c", "f", "config", "s", "this", "pass", "i", "input", "l", "socket", "image", "IN", "data", "con", "win", "n", "isin", "a", "din", "b", "nin", "ins", "h", "connection", "stream", "In", "inc", "again", "parent", "part", "r", "login", "diff", "reader", "bin"], "out": ["flow", "source", "group", "call", "style", "cache", "output", "str", "client", "inner", "page", "w", "ex", "i", "word", "console", "dump", "OUT", "image", "line", "socket", "conn", "writer", "sys", "comment", "print", "io", "up", "window", "log", "name", "outer", "server", "ext", "obj", "exec", "msg", "pool", "list", "connection", "exp", "channel", "lock", "prefix", "Out", "write", "again", "off", "file", "temp", "err", "r", "o", "debug", "user", "v", "inc", "error"], "buffer": ["flow", "source", "result", "cache", "output", "length", "bar", "f", "config", "buff", "pad", "buf", "fb", "slave", "input", "uffer", "count", "border", "read", "data", "writer", "loader", "abi", "binary", "limit", "document", "base", "window", "b", "null", "server", "transfer", "Buffer", "header", "channel", "size", "queue", "layer", "batch", "reference", "iter", "pause", "wave", "feed", "slice", "reader", "flush", "bin", "offset", "context"]}}
{"id1": "742465", "id2": "8011262", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doVersioncheck", "doVersionScan", "doFeatureScan", " doVersionScan", "doVersionUpdate", "doFeaturecheck", "doFeatureCheck", "doVersioncheck", "doChangeCheck", "doFeatureUpdate", "doversioncheck", " doversionCheck", " doversioncheck", "doversionScan", " doversionUpdate", "doChangeUpdate", " doVersionUpdate", "doChangecheck", "doversionCheck", "doChangeScan", " doversionScan", "doversionUpdate"], "view": ["video", "cache", "out", "session", "config", "head", "event", "vol", "image", "comment", "base", "display", "pool", "see", "div", "views", "fail", "can", "http", "group", "form", "im", "client", "check", "ve", "this", "model", "use", "show", "by", "object", "self", "up", "ou", "user", "edit", "style", "update", "View", "link", "e", "input", "screen", "box", "VIEW", "sel", "container", "gu", "block", "html", "value", "widget", "port", "cell", "page", "manager", "review", "window", "server", "change", "ui", "query", "body", "index", "vis", "list", "lock", "el", "full", "row", "layout", "v"], "url": ["ls", "source", "gl", "buffer", "uri", "browser", "length", "path", "Url", "download", "f", "bb", "link", "l", "socket", "image", "blog", "loader", "loc", "web", "resource", "open", "hub", "builder", "location", "email", "www", "base", "log", "name", "b", "null", "server", "host", "URL", "zip", "sl", "address", "string", "fr", "stream", "ul", "ll", "impl", "file", "bug", "ssl", "ob", "id", "rel", "http"], "in": ["source", "as", "init", "buffer", "inn", "out", "pin", "inner", "ac", "s", "input", "socket", "sin", "IN", "data", "m", "ini", "win", "con", "resource", "binary", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "again", "rin", "file", "err", "login", "reader", "bis", "din", "doc"], "bin": ["init", "buffer", "gin", "inn", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "ban", "IN", "abi", "loader", "ini", "win", "record", "con", "binary", "bot", "bi", "arin", "b", "vin", "bn", "fin", "nb", "is", "body", "lock", "cin", "lin", "spin", "ruby", "file", "lib", "oin", "login", "reader", "din", "run"], "line": ["text", "lf", "look", "Line", "lines", "str", "out", "parse", "pin", "cell", "page", "link", "e", "one", "word", "l", "val", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "base", "name", "log", "b", "lc", "job", "pe", "code", "ge", "zip", "letter", "sl", "string", "LINE", "el", "lin", "range", "cl", "ine", "block", "write", "file", "part", "row", "key", "entry", "end", "le", "unit", "type", "id", "user", "jo"], "version": ["secret", "python", "video", "position", "license", "cover", "feature", "update", "download", "date", "ver", "author", "model", "versions", "VERSION", "driver", "project", "image", "install", "release", "format", "latest", "vert", "name", "device", "null", "server", "host", "code", "beta", "string", "Version", "patch", "dev", "option", "plugin", "value", "bug", "pull", "support", "id", "unit", "type", "v", "section", "vision", "user"], "build": ["work", "make", "style", "clean", "load", "update", "home", "ver", "built", "info", "use", "lease", "link", "show", "how", "image", "install", "follow", "release", "Build", "builder", "help", "print", "valid", "job", "log", "add", "building", "uild", "hold", "post", "tag", "patch", "lock", "block", "mount", "bug", "pull", "row", "feed", "boot", "unit", "get", "run", "rel", "http"]}}
{"id1": "14168494", "id2": "659316", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyClass", "copyfile", "copyFiles", "copyClass", "transferfile", "transferFile", "transferClass", " copiedClass", " copiedFiles", " copiedfile", " copyfile", " copiedFile", " copyFiles"], "dest": ["source", "output", "out", "st", "path", " destination", "this", " Dest", "txt", "loc", "data", "resource", "done", "later", "sup", "class", "tmp", "name", "null", "obj", "transfer", "destroy", "dist", "target", "comb", "true", "orig", "desc", "file", "temp", "wb", "Dest", "dir", "d"], "src": ["source", "filename", "sb", "copy", "sync", "st", "download", "config", "s", "master", "ds", "inst", "sin", "loc", "storage", "img", "sup", "rob", "tmp", "url", "sel", "sit", "sub", "sc", "sl", "split", "dist", "rc", "rb", "upload", "gb", "stream", "sq", "file", "Dest", "ssl", "slice", "bin", "cb", "target"], "srcChannel": ["destConnection", "srcSection", "destchannel", "rcButton", "rcChan", " srcSection", "rcchannel", "destChannel", "distStream", "inputChannel", "srcButton", "distChan", "sourceChan", "srcchannel", " srcChan", "inputConnection", "srcCh", "rcStream", "distChannel", "srcConnection", " srcchannel", "sourceChannel", " srcConnection", " srcCh", "rcConnection", " srcStream", "inputSection", "srcChan", "rcSection", "sourceButton", "sourcechannel", " srcButton", "rcChannel", "distCh", "srcStream", "destChan", "rcCh", "inputchannel"], "dstChannel": ["dstVideo", "DstVideo", " drdContext", "dstChan", " dstStream", " dstsStream", " dstContext", " dstConnection", "dstsStream", " dstchannel", "dDestStream", "dstsChannel", "dsrcChannel", " dstChan", "dstConnection", "dstschannel", "dDestchannel", "ddestVideo", "dstContext", " drdChannel", "DstChannel", " dstsChannel", "drcchannel", " drdchannel", "drcChan", "drcVideo", "ddestchannel", "ddestStream", "dDestConnection", "dstStream", " dstschannel", "drcContext", "dsrcchannel", "ddestConnection", "DdestChannel", "dDestChannel", "Ddestchannel", "ddestContext", "DdestVideo", "Dstchannel", "dstchannel", "dstsConnection", " dstsConnection", "drdContext", "drdChannel", "ddestChan", "drdChan", " drdChan", "ddestChannel", "drdchannel", "dsrcVideo", "drcChannel"]}}
{"id1": "9872346", "id2": "20011285", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readExternaldocument", "loadLocaldocument", "readLocalDocuments", "readExternalDocument", "readRemoteDocuments", "readExternalDocuments", "loadLocalDocuments", "readLocalDocument", "loadRemotedocument", "readLocaldocument", "loadRemoteDocuments", "loadRemoteDocument", "loadLocalDocument", "readServerDocuments", "readServerDocument", "readRemotedocument", "readServerdocument"], "url": ["source", "org", "remote", "position", "filename", "uri", "client", " URL", "path", "username", "Url", "load", "download", "config", "f", "store", "page", "link", "l", "socket", "image", "loc", "service", "location", "email", "resource", "www", "base", "name", "lc", "server", "host", "URL", "rl", "address", "sl", "string", "channel", "ur", "layer", "ll", "file", "version", "ssl", "feed", "entry", "user", "xml", "http"], "validate": ["verated", "Valating", "Valate", "validating", " validated", "Valation", "verate", "validated", " validation", "verating", " validating", "Valated", "validation", "veration"], "document": ["text", "source", "message", "result", "video", "media", "expression", "output", "port", "dict", "language", "session", "degree", "f", "system", "model", "page", "view", "word", "project", "ocument", "image", "material", "design", "data", "record", "object", "resource", "metadata", "location", "node", "service", "valid", "database", "graph", "null", "Document", "function", "index", "container", "office", "value", "collection", "request", "df", "response", " documentation", "parent", "xml", "doc", "content", "application"], "factory": ["infuture", "hiller", "affactory", "diller", "fsactory", "fade", " fFactory", "pixture", "fsFactory", "duture", "sfluent", "pluent", "dade", "biller", "fFactory", "sfactory", "bluent", "efixture", "Factory", "Folver", "sfixture", "efactory", "fsiller", "pault", "efiller", "fault", "pactory", "bactory", "fluent", "filler", "hactory", "folver", "affixture", "dactory", "infade", "infactory", "Filler", "infiller", "future", "FFactory", "sfault", "hade", " folver", "affault", "huture", "piller", "fixture", "bixture", "fsolver", " filler", "efluent", "affluent"], "connection": ["relation", "position", "cache", "uri", "current", "client", "out", "connected", "port", "session", "translation", "c", "union", "config", "system", "info", "Connection", "use", "link", "driver", "socket", "conn", "image", "default", "application", "condition", "writer", "con", "service", "resource", "builder", "proxy", "open", "communication", "io", "connect", "database", "character", "server", "password", "function", "index", "container", "channel", "handler", "wrapper", "creator", "version", "collection", "response", "reader", "common", "user", "section", "error", "context", "http"], "stream": ["source", "form", "result", "sw", "video", "media", "output", "out", "client", "path", "translation", "load", "f", "system", "model", "view", "per", "input", "trans", "image", "or", "data", "writer", "loader", "object", "resource", "transform", "io", "cont", "server", "sc", "sl", "body", "container", "upload", "Stream", "string", "channel", "stack", "handler", "coll", "raw", "file", "version", "row", "response", "feed", "entry", "reader", "v", "context"]}}
{"id1": "22536033", "id2": "5299276", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"setPayload": ["setWorkload", "parsePayloads", "setPayloads", " setPayloads", "setWorkContent", "setPayContent", "setMessageLoad", "parsePayContent", "setPayLoad", "setShiploads", "setShipContent", "setRawContent", "setWorkloads", "setMessageloads", "parseShipLoad", "parseShipload", "setRawloads", "setWorkLoad", "setMessageContent", " setPayLoad", "setShipload", "parseShiploads", "parsePayLoad", "setMessageload", " setPayContent", "parseShipContent", "setShipLoad", "setRawLoad", "parsePayload", "setRawload"], "fos": ["cfoc", "bos", "cfics", "Fos", "fics", "Fis", "bics", "Fics", "cfis", "Foc", "boc", "cfos", "bis", " fics"], "fis": [" fib", "forics", "fib", "FIS", "eis", "eoc", "fics", "Fis", "Fics", "eIS", "forib", "fIS", "Foc", "Fib", " fIS", "foris", "Fic", "foric", " fics", "eic"], "fic": ["elfics", "firc", "elfik", "cfoc", "cfac", " firc", "cfic", "elfic", "infic", "Fik", " fac", "cfics", "Fos", "fics", " fik", "ufos", "elfci", "Fics", "fac", "Fac", "cfirc", "fci", "infci", "Foc", "ufik", "Firc", "ufic", "ufoc", "Fci", "fik", "Fic", "infik", " fics", "infics"], "foc": ["infos", "infocol", "Focol", "Fisc", "infocon", "infoc", " fisc", " foca", "troc", " focol", "infic", " fac", "infac", "Fos", "toca", "Froc", " focon", "infisc", "focon", "toc", "fac", " froc", "Fac", "tic", "Focon", "Foc", "froc", "focol", "foca", "fisc", "Fic", "Foca"], "Index": ["x", "Number", "Num", "Mass", "Pull", "Element", "Start", "Address", "Offset", "Width", "Found", "Location", "Header", "Path", "Value", "Length", "Weight", "Url", "Level", "Depth", "Client", "Entry", "Insert", "Counter", "Body", "Connection", "Input", "Exp", "Order", "Pos", "I", "Loop", "Loc", "Row", "X", "First", "Size", "Instance", " index", "Label", "Page", "Code", "index", "Link", "Version", "Count", "Flag", "Inf", "ID", "Position", "Rank", "Len", "Content", "Array", "Dim", "Stage", "Interest", "Section", "Key"]}}
{"id1": "7169984", "id2": "189963", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"connRemote": ["execIP", "invokeURL", "execLocal", " execRemote", " executeURL", "invokeIP", " executeRemote", " executeLocal", " executeIP", " execLocal", "execURL", " execURL", "execRemote", " execIP", "invokeRemote", "invokeLocal"], "jsonObject": ["JSONArray", "jsonObj", "jsonOperation", "httpOperation", " jsonString", "JSONBody", "httpObject", "httpArray", "customArray", "jsonArray", "customObject", "jsonBody", "jsonOb", " jsonBody", "javaBody", " jsonOb", "customObj", "JSONOb", "JSONOperation", "javaObject", "jsonString", "httpObj", "JSONString", "javaString", "customOperation", "javaOb", "JSONObject", "JSONObj"], "OPCode": ["OPcode", " OPcode", "OpCode", "OPName", "opName", " OPName", "opCode", "OPAction", "OpAction", " OPAction", "opAction", "opcode", "Opcode", "OPERCode", "OpName", "OPERcode", "OPERName"], "retSrc": [" retSsrc", "retOsrt", "retInrc", "retSrt", "RetAsrc", "retDRC", "retOsRC", "retInuc", "retSuc", " retSrt", "retDrc", "retNRC", "retDuc", "RetAsuc", "RetAsck", "retInck", "retSck", "retSRC", "retPvc", " retSvc", "retSsrc", "RetSuc", "retDck", " retDrc", "retOssrc", "retNrc", "retPRC", "retNsrc", "retNvc", "RetAsRC", "RetSrc", " retDsrc", "retNrt", "retOsrc", "retAsRC", "retPsrc", "RetSRC", " retDRC", " retSRC", "retDrt", "retPrc", " retDrt", "retInRC", "retAsck", "retAsuc", "RetSck", "retAsrc", "retSvc", "retDsrc"], "httpClient": ["HttpClient", "httpsClient", "HttpConnection", "httpsCall", "apiPost", "phpCall", "httpProxy", "httpConnection", "apiCall", "HttpProxy", "xmlClient", " httpProxy", " httpConnection", "httpCall", "httpCase", "xmlProxy", "phpclient", "httpsPost", "xmlCase", "apiclient", "apiClient", "phpPost", "HttpCase", "phpClient", " httpCase", "xmlConnection", "httpclient", "httpsclient"], "httpPost": ["webPost", "workpost", "autoPost", "HttpCopy", "workPre", "HttpPost", " httpPOST", "webpost", "httpPre", "httpsPOST", "htmlPOST", "httpDo", "httpPOST", " httpPre", " httpCopy", "HttpDo", " httpRequest", "autoPOST", "httppost", "httpsPre", "workPost", "httpsPost", "phpPost", "httpRequest", "autoPre", "phpPOST", "workDo", "phpRequest", "httpsCopy", "HttpPOST", "webDo", "HttpPre", "httpCopy", "phpDo", "htmlPost", "autoCopy", "webPre", "htmlDo", "HttpRequest", " httppost", " httpDo", "htmlCopy"], "httpParams": ["httpArgms", "hrParars", "hrPam", "httpCatars", "httpPms", "hrPams", " httpParums", "httpPeram", " httpParars", "httpPerars", "httpCatms", " httpPums", "httpVariums", "httpParums", " httpPam", "httpCatams", "httpPerums", "httpParars", " httpPars", "httpParms", "httpVariars", " httpPams", "hrParams", "httpPars", "httpArgams", "hrPars", "httpPams", "httpVariams", "httpParam", "httpArgam", "httpArgars", "httpPerams", "hrPms", "httpVariam", " httpParam", "hrParam", "httpPam", "httpCatam", "httpPums", "hrParms"], "nameValuePair": ["nameNamePenter", "nameNameLair", "nameValueLolder", "nameValuePhair", "nameValuePatch", "nameVPait", "nameValueSair", "nameNamePiece", "nameNameLolder", "nameValueParait", "nameValueFiece", "nameValueProtenter", "nameValuePointair", "nameValueCait", "nameNamePatch", "nameValueLair", "nameVPair", "nameValuePait", "nameNameProtenter", "nameValueProtpair", "nameNamePore", "nameValueportion", "nameValuepiece", "nameValuePerair", "nameValuepatch", "nameNamePolder", "nameNamepiece", "nameValueProtore", "nameValueFair", "nameValueProtair", "nameNamepair", "nameValuePiece", "nameValueParpair", "nameNameProtair", "nameNameProtpair", "nameValuePeratch", "nameVPpair", "nameValuepolder", "nameValuePpair", "nameValuePore", "nameValueParair", "nameValueSore", "nameValuepair", "nameNameProtore", "nameNamePair", "nameValuepait", "nameValueLatch", "nameValuePointpair", "nameValueFortion", "nameValuePhiece", "nameValueCair", "nameVCait", "nameValuePenter", "nameValueppair", "nameNamePpair", "nameValuePointenter", "nameValueSenter", "nameNameLatch", "nameNameportion", "nameVCair", "nameValuePortion", "nameVCpair", "nameValueCpair", "nameValuePhortion", "nameNamePortion", "nameValuePolder", "nameValuePerolder", "nameValueSpair", "nameValuePointore"], "response": ["message", "method", "result", "output", "json", "session", "f", "environment", "status", "page", "view", " Response", "e", "i", "success", "tree", "application", "resp", "data", "throw", "object", "resource", "reply", "server", "Response", "entity", "api", "res", "body", "jet", "connection", "respond", "channel", "full", "block", "request", "wave", "feed", "site", "v", "http"]}}
{"id1": "3731077", "id2": "19868933", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copySourceFile", "transferFiles", "importfile", "importSourceFile", "copyfile", "copyFiles", "transferfile", "transferFile", "importFiles", "copySourceFile", "transferSourceFile", " copyfile", "importFile", " copyFiles"], "from": ["source", "form", "as", "remote", "of", "about", "se", "client", "path", "c", "f", "front", "with", "before", "back", "this", "config", "at", "src", "ca", "or", "by", "data", "left", "resource", "ce", "old", "io", "original", "a", "url", "base", "name", "add", "address", "without", "origin", " form", "From", "range", "file", "part", "o", "id", "user", "start", "d"], "to": ["p", "source", "as", "top", "into", "of", "about", "output", "TO", "so", "client", "copy", "token", "at", "f", "with", "this", "point", "one", "root", "po", "too", "socket", "or", "by", "object", "location", "storage", "dest", "io", "base", "database", "name", "toc", "null", "b", "os", "until", "api", "two", "size", "To", "auto", "again", "office", "file", "temp", "t", "o", "site", "type", "parent", "target", "eto"], "parentDir": ["parentDirectory", " parentFile", "ParentFile", "currentDir", " parentFolder", "currentFile", "outFile", "rootFile", " parentdir", "currentdir", "ParentDirectory", "outFolder", "ParentDir", "outDir", "outDirectory", " parentDirectory", "parentdir", "parentFile", "parentFolder", "rootDirectory", "ParentFolder", "Parentdir", "currentFolder", "rootFolder", "rootDir"], "in": ["work", "pre", "source", "form", "init", "rec", "inn", "gin", "sync", "pin", "inner", "ac", "with", "i", "ie", "input", "l", "conn", "image", "inside", "or", "IN", "m", "con", "win", "ini", "on", "io", "isin", "arin", "url", "pc", "din", "it", "vin", "exec", "nin", "min", "rc", "ins", "cin", "plugin", "lin", "In", "fc", "inc", "again", "rin", "kin", "trial", "part", "err", "r", "login", "o", "reader", "id", "diff", "bin"], "out": ["p", "org", "call", "init", "app", "cy", "about", "ot", "output", "gin", "sync", "client", "net", "inner", "ac", "c", "at", "w", "ex", "input", "OUT", "conn", "or", "writer", "win", "other", "on", "io", "vert", "ou", "outer", "exec", "ico", "channel", "cin", "option", "Out", "plugin", "auto", "outs", "inc", "again", "off", "op", "o", "user", "bin", "co", "can"], "ic": ["IC", "cs", "xc", "uc", "sync", "iac", "c", "ac", "ai", "ix", "ex", "i", "irc", "input", "conn", "acs", "ci", "or", "loc", "ec", "io", "bc", "pc", "pic", "lc", "ik", "ico", "cus", "rc", "cc", "cin", "enc", "cl", "fc", "ics", "icc", "nic", "auto", "cu", "vc", "mc", "anc", "aic", "op", "ct", "voc", "ig", "o", "inc", "co", "dc"], "oc": ["og", "org", "cy", "oco", "xc", "uc", "c", "ac", "ocon", "aco", "oca", "wic", "i", "ca", "acs", "ci", "AC", "or", "loc", "ec", "io", "ocol", "OC", "bc", "pc", "toc", "sc", "ack", "cus", "cur", "cc", "soc", "mic", "enc", "oci", "fc", "nic", "alloc", "vc", "anc", "mc", "aic", "op", "ob", "o", "voc", "circ", "inc", "co", "can", "roc", "dc"]}}
{"id1": "22401746", "id2": "7296597", "code1": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["processResponse", "submitRequest", " sendrequest", "processObject", "sendrequest", "processrequest", "submitResponse", " sendResponse", " sendObject", "sendResponse", "processRequest", "submitrequest", "submitObject", "sendObject"], "servletName": ["servletsNames", "servlename", "servLETNames", "servleNames", " servleNames", "servLETUrl", "servletsVersion", " servletname", "servlePath", "servletPath", "servletNames", " servletVersion", "servLETPath", "servLETname", " servleUrl", "servletonName", "servletsname", "servletonNames", "servletonVersion", " servletUrl", "servleVersion", " servletNames", "servletsName", "servletsPath", "servletonPath", " servleName", "servletUrl", "servletVersion", "servLETVersion", "servLETName", "servleUrl", " servleVersion", "servletname", " servletPath", " servlePath", " servlename", "servleName", "servletsUrl"], "request": ["text", "python", "message", "method", "create", "buffer", "result", "uri", "json", "path", "hello", "frame", "config", "info", "input", "complete", "req", "data", "q", "object", "resource", "document", "name", "server", "query", "address", "string", "header", "queue", "response", "type", "xml", "Request", "report", "content", "application"], "reqxml": ["reqdocument", " reqdoc", "requestdocument", "Requestxml", "Requestdocument", "requestdoc", "Requestdoc", "requestxml", "reqdoc", " reqdocument"], "retdoc": [" resultdata", "retconf", " resultxml", " resultdoc", "retdata", " retxml", "retxml", " backdoc", " retdata", " backconf", " retconf", " backdata", " resultconf", " backxml"], "myurl": ["yourUrl", "MyUrl", "yourhost", " myURL", "myaddress", "serveraddress", "serverhost", "myURL", "myhost", "serverurl", " myhost", "yourURL", "Myhost", "Myurl", "myUrl", "MyURL", "Myaddress", " myaddress", " myUrl", "yoururl", "youraddress"], "myport": ["yourPort", "someort", "somehost", "myPort", "yourphone", " myphone", "Myport", "MyPORT", "memberurl", " myPORT", "somePort", "yourport", "Myort", "MYport", "serverphone", "myphone", "MYurl", "myhost", "serverurl", " myhost", "myort", "Myhost", "myip", "MYPort", "memberip", "memberPort", "Myurl", "someport", "someurl", " myPort", "serverport", "MYPORT", "serverPort", "MYhost", " myort", "MyPort", "somePORT", "memberport", "someip", "yoururl", "myPORT", "yourip"], "codebase": [" codebas", "CodeBase", "codBase", "codeurl", "codeb", "foreBase", " codeurl", "Codebase", "Codebas", "codebas", "foreurl", "foreb", "codb", "Codeb", "Codeurl", "codeBase", "forebase", "forebas", " codeb", "codbase", " codeBase"], "serverURL": ["remoteURI", "serverBUG", " serverJSON", "localhostURL", "slaveFolder", "localhostUrl", "serverAddress", "localhostDirectory", " serverURI", "siteurl", "erverLevel", " serverID", "myURL", "siteFolder", "serverurl", "myUrl", "erverURL", "remoteURL", "slaveUrl", "serverPage", "erverUrl", "serverLocation", "siteLocation", "testurl", "hostURL", "erverFolder", "testLocation", " serverBUG", "erverurl", "sitePage", "erverDirectory", "siteURI", "databaseURL", "siteID", "remoteUrl", "serverUrl", " serverLocation", "remoteurl", " serverurl", " serverLevel", "erverJSON", "testUrl", "serverLevel", "serverID", "erverPage", "myURI", " serverUrl", "serverDirectory", "hosturl", "siteUrl", "siteDirectory", "testURI", "erverAddress", "databaseURI", "myJSON", "serverURI", "serverFolder", "myID", "slaveURL", "databaseUrl", "hostUrl", "siteURL", "myLevel", "serverJSON", "slaveAddress", "remoteBUG", "testURL", "siteAddress", "localhostPage", "hostURI", "erverBUG"], "ipdig": ["IPdone", " ipgen", "IPplug", "ipcr", "ipcomb", "ipgen", "ppplug", "opcomb", " ipdone", "ppDig", "IPgen", "ppcr", " ipcomb", "ipsdb", " ipdb", " ipDig", "IPdig", "IPcomb", "iddone", " ipdiff", "ipdone", "idDig", "ipsDig", "opdig", "ipsdig", "ppdig", "idplug", "IPdiff", "ipdb", "ipplug", "ipsgen", "opDig", "IPcr", "iddig", " ipplug", "ipdiff", "IPdb", "opdiff", "ipDig", " ipcr", "IPDig"], "url": ["ls", "org", "util", "gl", "uri", "str", "client", "browser", "path", "Url", "update", "config", "f", "page", "event", "l", "conn", "req", "web", "object", "resource", " http", "www", " curl", "class", "name", "log", "server", "host", "URL", "fl", "sl", "connection", "cl", "coll", "ll", "file", "pull", "ssl", "key", "twitter", "user", "rel", "http"], "urlconn": ["httpconn", "flConn", "slclient", " urlclient", "httpconnection", "sslcon", "flconnection", "sslconn", " urlconnection", "webconn", " urlcon", "sslConn", "webcon", " urlconv", "slcon", "flcn", "webclient", "urlConn", "urlconf", "httpconf", "urlcon", "httpcn", "flcon", "urlclient", "llconnection", " urlconf", "httpcon", "llconn", "sslconf", "llcon", " urlcn", "flconn", "httpConn", "webconv", "llConn", "urlconv", "urlcn", "urlconnection", "slconn", " urlConn", "slconv"], "os": ["ls", "OS", "as", "ps", "ot", "so", "oss", "us", "ips", "ds", "pos", "or", "rs", "vs", "io", "ms", "is", "fs", "obj", "bs", "res", "ns", "es", "op", "Os", "o", "ops"], "req1xml": ["req_txt", "req_x", "req_xml", "request2xml", "req2xml", "request2request", "req1txt", "request1txt", "req2request", "request2txt", "req0request", "req2txt", "req2x", "req1request", "req_request", "req1x", "request1request", "req0txt", "request2x", "req0x", "request1x", "req0xml", "request1xml"], "cos": [" bytes", " pos", " cs", "cs", " compress", " socks", " enc", " temp", " iss", " ss", " downloads", " cc", " contents", " dd", "pos", " zipper", "is", " fo", " rc", " tar", " ro", "outs", " outs", " po", " compression", " bos", " repo", " ze"]}}
{"id1": "9718328", "id2": "7372311", "code1": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["actionIned", "actionExecuted", "buttonPeruted", "buttonPerformed", "actionInmitted", "actionInformed", "actionProcessed", "buttonPered", "actionProcessuted", "buttonExecuted", "actionProcessformed", "buttonExecmitted", "actionPered", "buttonExeced", "buttonExecformed", "buttonPermitted", "actionPermitted", "actionProcessmitted", "actionExecformed", "actionExecmitted", "actionPeruted", "actionExeced", "actionInuted"], "e": ["p", "x", " ev", "click", "eve", "c", "f", "this", " en", "event", "ed", "enter", "E", "q", "ze", "ec", " Event", "g", "a", "em", "u", "esi", "change", "exec", "handler", "element", "ee", "el", "ae", "en", " pe", " event", "es", "ev", "t", "er", "o", "type", "v", "events", "Event", "ea"], "buttonClicked": ["clickclickable", "buttonRequestED", "buttonLinked", "buttonclickOn", "buttonRequested", "buttonRequestable", "clickClickable", "buttonclickable", "buttonLinkable", "buttonclickED", "clickclickED", "clickClickOn", "clickclicked", "buttonClickOn", "buttonclicked", "clickClickED", "buttonClickED", "buttonLinkOn", "buttonClickable", "buttonLinkED", "clickClicked", "clickclickOn", "buttonRequestOn"], "data": ["text", "message", "buffer", "cache", "json", "config", "s", "extra", "txt", "options", "to", "base", "name", "add", "code", "post", "msg", "zip", "li", "div", "size", "key", "type", "result", "arr", "uri", "info", "with", "i", "one", "da", "ata", "multi", "api", "batch", "sample", "id", "parent", "style", "media", "output", "str", "DATA", "update", "input", "format", "done", "description", "valid", "action", "a", "next", "string", "alpha", "dd", "html", "value", "version", "space", "step", "results", "response", "o", "no", "content", "p", "script", "empty", "complete", "record", "ad", "missing", "database", "it", "ui", "function", "body", "dat", "part", "layout", "after", "xml"], "url": ["source", "org", "uri", "str", "browser", "path", "Url", "download", "f", "config", "ver", "page", "l", "build", "blog", "loc", "web", "service", "resource", "open", "www", "base", "log", "bel", "b", "server", "host", "URL", "fl", "sl", "connection", "channel", "ur", "pull", "ssl", "r", "user", "orb", "http"], "conn": ["p", "init", "sw", "fp", "sync", "client", "c", "reg", "Connection", "w", "nt", "socket", "Conn", "serv", "loc", "resp", "con", "close", "open", "act", "ws", "pub", "n", "connect", "ann", "conv", "col", "exec", "stat", "conf", "ch", "ack", "connection", "nc", "h", "fn", "lock", "enc", "coll", "nw", "pr", "sn", "cn", "rt", "syn", "r", "ssl", "err", "comm", "ctx", "db", "co", "dc"], "wr": ["wer", "kr", "Wr", "rx", "sw", "wire", "dc", "wt", "rr", "w", "wp", "mr", "war", "writer", "ws", "Writer", "sr", "wa", "wx", "raft", "hr", "fw", "fd", "rss", "dr", "fr", "rw", "shr", "wrap", "WR", "nw", "wm", "WS", "r", "wb", "wl", "RW", " writer", "rh", "wal", "wcs"], "rd": ["rx", "bh", "sb", "arr", "rr", "mr", "irc", "rs", "ru", "sr", "hr", "rl", "cr", "rss", "rb", "dr", "rc", "fr", "rn", "lr", "usr", "ruby", "ra", "rt", "tr", "rh", "ri", "raf", "rg"], "line": ["Bytes", "Url", "s", "HTTP", "Type", "_", "feed", "http"]}}
{"id1": "1954410", "id2": "20375440", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecutes", "doexecuteApply", "doexecuteutes", "submitExecApply", "doSendApply", "doSendRun", "submitexecuteutes", "doExecRun", "submitExecRun", "doExecutes", "submitexecuteRun", "submitexecuteApply", "doSendute", "doexecuteRun", "submitExecute", "doSendutes", "submitexecuteute", "doExecApply", "doexecuteute"], "mapping": ["fapper", "matching", "fapping", "minding", "aminding", "amapping", "amapper", "finding", "mapper", " mapper", " minding", " matching", "amatching", "fatching"], "form": ["flow", "method", "app", "FORM", "forms", "field", "Form", "config", "component", "page", "command", "control", "owner", "definition", "object", "format", "builder", "transform", "url", " forms", "formation", "post", "submit", "dom", "feed", "template", "xml", "pattern"], "request": ["message", "method", "create", "call", "Bytes", "result", "re", "uri", "json", "client", "current", "path", "hello", "session", "Accept", "instance", "frame", "Upload", "s", "this", "model", "use", "view", "HTTP", "input", "complete", "req", "data", "q", "object", "resource", "format", "QUEST", "self", "ware", "url", "name", "add", "server", "requ", "Response", "query", "address", "worker", "queue", "submit", "Reply", "_", "parent", "route", "pull", "reader", "user", "type", "xml", "Request", "report", "context", "application"], "response": ["message", "result", "output", "json", "client", "status", "model", "page", "view", " Response", " responses", "application", "resp", "data", "req", "object", "resource", "Resp", "server", "Response", "res", "handler", "v", "xml", "report", "reply"], "errors": [" status", " flashes", " payload", " translations", " Messages", " session", " commands", " logger", " error", " this", " responses", " warnings", " changes", " replies", " management", " managers", "mess", " acc", " updates", " mess", " messages", " messaging", " problems", " calls", " messenger", " failures", " events", " logs", " streams"], "isMultipart": ["isMultipparts", "isMultippedost", "isMultIPound", "isMultompost", "isMultipost", "isMultipound", "isMultompPart", "isMultipage", "isMultiipound", "isMultIPPart", "isMultompound", "isMultitage", "isMultiipPart", "isMultippart", "isMultIPart", "isMultiIPart", "isMultiated", "isMultippedound", "isMultompart", "isMultiparts", "isMultiipart", "isMultippated", "isMultitart", "isMultiIPost", "isMultippedart", "isMultiIPPart", "isMultIPost", "isMultitarts", "isMultipPart", "isMultippedPart", "isMultiarts", "isMultitated", "isMultippage", "isMultiIPound", "isMultiipost", "isMultiage", "isMultiart", "isMultipated"], "mailInstance": ["fileManager", "fileinstance", "fileInstance", "mailUsage", "emailinstance", " emailinstance", " mailUsage", "emailInstance", "fileUsage", " emailInstance", "mailinstance", " emailUsage", "mailInst", "emailManager", " emailInst", " mailInst", " mailinstance", "mailManager", "emailInst", " mailManager", "fileInst"], "fields": ["types", "parts", "rules", "holders", "locks", "words", "lines", "forms", "field", "lists", "keys", "forces", "s", "groups", "input", "services", "atts", "dates", "data", "gets", "strings", "checks", "cells", "flows", "archives", "objects", "qs", "boxes", "params", "ments", "files", "facts", "utils", "members", "features", "states", "links", "acks", "models", "tags", "pages", "uploads", "views", "details", "loads", "plugins", "packs", "users", "properties", "headers", "changes", "maps", "classes", "comments", "events", "ids", "rows", "posts"], "attachments": ["Attachments", "payments", "attachers", "Attachees", "extions", "exters", "attions", "attees", "attachresses", "attps", "attachlements", "payment", "achresses", "Attachps", "Attachlements", "suppees", "achments", "attachps", "attments", "attachment", " attachment", " attachparts", "attachparts", "attachions", "attment", "Attachions", "extps", "achparts", "atters", "attlements", "achment", "supplements", "payparts", "payresses", "Attachers", "extments", "suppment", "suppments", " attachresses", "attachees", "Attachment"], "items": ["types", "parts", "apps", "locks", "lines", "orders", "lists", "Items", "keys", "ips", "its", "ers", "groups", "data", "names", "objects", "apters", "qs", "files", "reports", "list", "ins", "links", "models", "pages", "plugins", "es", "results", "children", "events", "ids", "alls", "rows", "phones", "ops"], "iter": ["itter", "edit", "inner", "finder", "ver", "ite", "ter", "page", "event", "master", "cher", "i", "keep", "enter", "skip", "upper", "gener", "loc", "ner", "walker", "ir", "ip", "Iterator", "it", "izer", "outer", "Iter", "zip", "altern", "ator", "li", "list", "exp", "former", "chain", "coll", "el", "ul", "inc", "file", "loop", "err", "er", "ser", "end", "reader", "inter", "slice", "iterator", "oper", "order", "http"], "item": ["source", "current", "instance", "event", "extra", "image", "val", "ip", "url", "base", "name", "post", "Item", "li", "temp", "slice", "entry", "type", "section", "volume", "result", "token", "load", "info", "all", "i", "area", "or", "data", "example", "object", "other", "up", "original", "obj", "entity", "api", "layer", "coll", "plugin", "art", "site", "user", "order", "update", "hop", "atom", "issue", "folder", "resource", "next", "container", "element", "attribute", "more", "reader", "get", "app", "widget", "album", "inner", "page", "complete", "anything", "service", "missing", "storage", "it", "server", "index", "handler", "full", "file", "custom", "er"], "aux": ["offs", " auxiliary", "uc", "ups", "uf", "frac", "union", "alias", "buf", "aus", "extra", "etc", " Aux", "data", "des", "ux", "aff", "strings", "amp", "af", "ras", "cas", "ru", "sup", "aw", "array", "lc", "asc", "ext", "ou", "ants", "sub", "lang", "imp", "prefix", "axe", "aos", "fax", "auc", "ox", "off", "abs", "anc", "au", "pkg", "packages", "cmp", "abc", "except"], "part": ["p", "pre", "group", "parts", " Part", "ref", "field", "instance", "f", "point", "info", "back", "component", "per", "one", "word", "po", "l", "pos", "area", "joined", "val", "data", "PART", "object", "format", "act", "on", "action", "and", "class", "error", "base", "name", "b", "add", "change", "fact", "obj", "player", "pi", "ch", "connection", "list", "patch", "but", "layer", "comp", "element", "full", "plugin", "block", "html", "Part", "file", "start", "step", "partial", "key", "art", "diff", "join", "id", "type", "parent", "section", "user", "co", "no", "pair"], "baos": ["BAo", "baoss", "baOs", "baot", "paot", "baoS", "abaosi", " baoS", "BAis", "Bao", " baoss", "baosh", "boOS", "pao", "boo", "BAOs", "BAoss", "haos", "BaOs", " bao", "baOS", "bois", "paOS", "Baos", "BAoS", "Baosi", "abais", "abaOs", " baOS", "BaoS", "bais", "hao", "boosh", "hais", "abaos", "BAosi", "baosi", " bais", "boos", "Bais", "pais", "boot", "bao", "BAos", "paos", "paosh", " baot", "BAosh", "haoss"], "body": ["text", "source", "message", "parts", "media", "summary", "output", "port", "json", "length", "fee", "translation", "flash", "Body", "state", "pass", "options", "tree", "data", "object", "resource", "binary", "comment", "description", "shell", "document", "url", "name", "b", "null", "params", "zip", "query", "string", "header", "connection", "size", "full", "html", "value", "headers", "template", "end", "type", "common", "content", "reply"], "preferencesInstance": ["preffeesinstance", "prefeesinstance", "prefiesinstance", "preffeesClient", "prefirmsClient", "preferencesClient", "prefirmsInstance", "prefeesClient", "prefiesClient", "prefiesInstance", "prefeesInstance", "preffeesInstance", "preferencesinstance", "prefferencesClient", "prefirmsinstance", "prefferencesInstance", "prefferencesinstance"]}}
{"id1": "13757855", "id2": "19251426", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["call", "create", "output", "parse", "path", "load", "processing", "update", "construct", "view", "processor", "project", "build", "evaluate", "resource", "transform", "proc", "code", "exec", "Process", "submit", "request", "cess", "handle", "run"], "tpl": [" tplates", " tper", "atplug", "qtcp", "tplate", "tcp", "itpl", "tbl", "tper", "Tper", "pPL", "stpp", "Tplates", "tcl", "ttemplate", "qtfc", "tsl", "qtple", " tcl", "tfc", "qtyl", " tfc", "Tpp", "Tplate", "stpl", "qtpl", "Tpl", "itplate", "tplates", "atplate", "ppl", "lple", " tbl", "Tple", "templates", "atml", "templ", "latcp", "itPL", "fplate", " tple", "temPL", "Tcl", "stplate", " tPL", "Tipl", " tsl", "itplates", "tmpl", "lper", "lplate", " tplug", "Tbl", "tml", "tmyl", " ttemplate", "qtbl", "TPL", "pipl", " tml", "psl", "latyl", "lml", "fpl", "pcl", "lPL", "tpp", "temtemplate", "tmcp", " tpp", "tplug", "latpl", "tPL", "lpl", "Tsl", " tplate", "tyl", "Ttemplate", "Tml", "Tfc", "latple", "atpl", "lcl", "stPL", "tmple", "fml", " tipl", "tipl", "fplug", "tple"], "model": ["message", "result", "media", "copy", "json", "language", "config", "param", "command", "project", "Model", "data", "m", "module", "location", "where", "node", "document", "log", "graph", "params", "conf", "body", "models", "xml", "doc"], "packageName": ["PackageName", "groupUrl", "PackageNames", "packageInfo", "projectKey", "contextName", "groupname", "projectname", "modulename", "projectName", "packageUrl", "contextInfo", "contextname", "moduleName", "moduleUrl", "contextNames", " packageNames", "packageNames", " packagename", " packageInfo", "moduleKey", "groupName", "groupKey", "packageKey", "packagename", "projectUrl", "PackageInfo", "Packagename"], "outFileName": ["OutFileName", "inDirEnd", "outfileOnce", " outDirLine", "outFilenameMode", "outFilenamePath", "outFullname", "outDirEnd", "outFileInfo", "outFileOnce", "outfileEnd", "outDirLine", "difffileName", "difffileTime", "outFullTime", " outDirPath", "outStreamInfo", "outStreamType", "outBufferName", "OUTBufferName", "outDirname", "OUTFileMode", "inDirCopy", "diffFileName", "inDirPath", "outFullInfo", " outFilePath", "OUTFileNames", " outFullType", "OUTBufferNames", "outFullPath", "outBufferHalf", "OutFilename", "OUTFileName", " outFileType", "outfileName", " outFullName", "outFileMode", "outBufferNames", "outfileHalf", "outFileNames", "outFilenameCopy", "outLineTime", "outFileTime", "outFilesTime", "diffFileTime", "outBufferMode", "outFilenameEnd", "outRuleName", "outLineInfo", "outRuleInfo", "outFullNames", " outFileLine", "OutDirLine", "outfileCopy", "outFilename", "outLinename", "outfileNames", "inFilePath", "outStreamName", "OutDirNames", " outDirName", "outFilesName", "OutFileNames", "outDirName", "OUTBufferHalf", "difffileOnce", "outFileType", "outFilenameHalf", "difffileInfo", "OUTFileHalf", "outLineLine", "outFullName", "diffFileInfo", "outFilenameName", "outRuleType", "outFileCopy", "outFileHalf", "outLineNames", "OutFileLine", "outfileInfo", "diffFileOnce", "outfilePath", " outDirTime", "outDirInfo", "OUTBufferMode", "outFilesPath", "outDirTime", "OutDirName", "outFileEnd", " outFileTime", "outLineOnce", "outDirCopy", "outfileMode", " outFullInfo", "outLineName", "outFilesLine", "inFileEnd", "OutDirname", "outFullType", "inDirName", "outDirPath", "inFileCopy", "outDirOnce", "outDirNames", "outFilePath", " outFileInfo", "outFileLine", "inFileName", "outFilenameNames", "outfileTime", "outFullLine"], "xsltParam": ["xldMode", "xslpParam", "xsltVal", "xslicVal", "xslicparam", "xldparam", "xsldparam", "xsldVal", "xslpVal", "xltMode", "xslicParam", "xsltparam", "xltVal", "xslicMode", "xslpMode", "xldParam", "xsltMode", "xsldParam", "xslpparam", "xsldMode", "xltParam", "xldVal", "xltparam"], "artifact": ["ARTifest", "Arturation", "aratfact", "ARTifacts", "aratifacts", " artribution", " arturation", "Artifact", "advertifacts", "Artfact", "artfact", " artifacts", "aratifest", "aratifact", "advertribution", "Artifest", "arturation", "advertifact", "artifacts", "artifest", "ARTfact", "ARTifact", "Artifacts", "Artribution", "artribution", "adverturation"], "destinationPath": ["distinatorKey", "destiationLog", "DestinatingPoint", "destinationAuth", "destinateDir", "datinatePath", "destinatorLocation", "restificationLocation", "destificationPoint", "constinationWidth", "constinationPath", "destinationString", "distinationFile", "desturationHandler", " destificationLog", "destificationPart", "destributionDir", "destificationName", "DestinationText", "tempinatedPath", "distinationCase", "destinatingLocation", "DestinationPart", "datinateLocation", "destationTime", "tempinationDir", "distributionDir", "restinationpath", "destinationLocation", "desticationName", "constinatorDir", "desticationFile", "destinatedPath", "DestinationName", "DestificationPath", "destinateLocation", "destinatorStep", "destiationDir", "destinateTime", "restinationString", "tempinationPath", "destinatorFile", "destinatedDir", "tempinationpath", "destinationsPath", "destplingAuth", "destplingPath", "tempinationHalf", "destinatedPoint", "combinatorPath", "destcreationUrl", "destinatePath", "tempinatedpath", "destributionName", "destplingDir", "destinatorKey", "destignmentPath", "destinationName", "constinationsName", "destinationFile", "destinatedFile", "destensionPoint", "destificationpath", "restinatorPath", "destinationHandler", "constinatorContext", "restinationPoint", "destinatingpath", "distinatorPath", "DestinationPath", "desticationKey", "desticationStep", "destplingWidth", "combinatorName", "distinationpath", "constinationName", "destinationTime", "destinatingName", "destinatingText", "restinatorPoint", "datinationLocation", "distinationName", "constinatorUrl", "destinationPart", "destributionCase", "destinatorPath", " destificationDir", "destinationHalf", "destinationDir", "destinationsPoint", "destinatingPoint", "distinatorStep", "DestinatingText", "restificationPoint", "constinationPoint", "destinationKey", "distinatorName", "destationPath", "destinatorCase", "destificationPath", "destificationLog", "destplingUrl", "distinationCry", "combinationHandler", "destinationpath", "destinatePoint", "distinatorCase", "desticationPart", "destinatorString", "DestinatingName", "destinatorContext", "destinatedHalf", "destinatePart", "restinatorString", "destinationCase", "destinatorName", "destinerContext", "destinateHandler", "destiationPath", "combinationPath", "destificationDir", "destributionPath", "restificationpath", "constinationpath", "destinatorHandler", "DestinationPoint", "distinationDir", "destensionPath", "destiningPoint", "combinatorpath", "destinationStep", "destinateString", "destinerpath", "constinationsPath", "distributionPath", "distinationStep", "destinatorHalf", "destationLocation", " destificationAuth", "constinationDir", "destributionpath", "desturationName", "constinatorPath", "destcreationPath", "destiningPath", "DestinatingPath", "destensionText", "destinateText", "constinatorWidth", "destinatorPoint", "destiningpath", "desturationpath", "destinerPath", "combinationName", "destinatedCase", "destinerDir", "destinatedString", "destinatorCry", "destensionName", "destiningContext", "DestificationPart", "destinatorTime", "destignmentCry", "destinationCry", "destationpath", "distinationKey", "distinatorFile", "constinatorpath", "destinationText", " destinationLog", "datinateTime", "destinationPoint", "restinationHalf", "constinationspath", "restinationLocation", "destinationWidth", "datinationTime", "destplingLog", "desturationPath", "destinatorpath", "datinatepath", "distinationPath", "datinationpath", "destinatedpath", "constinationsPoint", "destinatorDir", "destinatingPath", "destributionCry", "destiationAuth", "destiningDir", "destificationAuth", "combinatorHandler", "combinationpath", "destignmentCase", "destinationContext", "destinatorUrl", "distributionCase", "destinatorWidth", "destinateHalf", "constinationContext", "desticationPath", "destcreationWidth", "DestificationName", "tempinatedHalf", "destinationsName", "destiningName", "tempinatedDir", "restinationPath", " destificationPath", "restificationPath", "destificationLocation", " destinationAuth", "destinatedKey", "destinationUrl", "datinationPath", "destignmentName", "destinationLog", "distinatorCry", "destinatepath", "restinatorHalf", "distributionpath", " destinationDir", "destinatedStep", "constinationUrl", "destinateName", "destinationspath"], "in": ["x", "source", "cache", "c", "config", "ex", "i", "input", "image", "IN", "data", "con", "n", "bin", "name", "min", "ins", "connection", "In", "inc", "r", "t", "reader", "din", "d", "doc"], "out": ["source", "group", "result", "copy", "cache", "output", "str", "client", "path", "session", "point", "with", "store", "page", "state", "w", "ex", "all", "manager", "OUT", "dump", "line", "conn", "writer", "sys", "comment", "ne", "io", "up", "log", "name", "outer", "server", "gen", "obj", "post", "msg", "exec", "pool", "index", "list", "string", "connection", "free", "lock", "prefix", "Out", "write", "full", "outs", "again", "Output", "file", "lib", "temp", "version", "part", "err", "cli", "key", "o", "user", "parent", "bin", "error", "doc"], "root": ["history", " roots", "cache", "json", "path", "instance", "cat", "options", "tree", "meta", "xml", "resources", "loader", "module", "format", "Root", "transform", "values", "url", "graph", "params", "modules", "query", "index", "_", "collection", "include", "r", "results", "id", "parent", "node", "pattern", "roots", " result"]}}
{"id1": "8047989", "id2": "12172485", "code1": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getHashedID": ["getHashingID", "getHachedId", "getHashingUID", "getHashUID", "getShashedIP", "getShashedID", "getHachedID", "getHashingId", "getShashIP", "getShashedUID", "getShashUID", "getHashID", "getHashId", "getShashedId", "getHashedId", "getHachedUID", "getHachedIP", "getHashIP", "getHashedIP", "getHashedUID", "getHashingIP", "getShashID", "getShashId"], "ID": ["JSON", "Id", "Address", "Path", "DB", "IR", "DATA", "IDS", "NAME", "hash", "UID", "VERSION", "IDs", "Name", "INFO", "AD", "STR", "IN", "ENT", "RI", "TEXT", "INT", "name", "SHA", "Hash", "code", "URL", "ED", "Code", "string", "MAC", "prefix", "GET", "API", "MD", "EXT", "URI", "id", "KEY", "IP"], "md5": ["sha2", "sha7", "md4", "md2", "sha4", "id512", "id8", "MD4", "cmd25", "MD8", "md512", " md7", "md8", "sha512", "md7", "sha5", " md2", "MD2", " md25", "cmd512", "MD5", "cmd5", "sha25", "id2", "MD512", "md25", " md4", "cmd7", "id5", " md8", " md512", "MD7"], "digest": ["Digpe", "mdHash", "codse", "digace", "Digester", "Digests", "signace", "mdested", "codpe", "mdse", "longse", "digested", " digests", "mdester", " digse", "mdace", "DigHash", "codests", "digHash", "signested", " digpe", "digests", "Digse", "signester", "Digest", "longests", "longHash", "Digested", "mdest", "digester", "Digace", "digpe", "longest", "signest", "codest", "mdests", "digse"], "bytes": ["ls", "parts", "Bytes", "ps", "units", "words", "lines", "out", "bits", "ips", "keys", "bb", "its", "seconds", "devices", "issues", "services", "ones", "data", "errors", "strings", "proxy", "binary", "vs", "cells", "values", "pieces", "letters", "base", "objects", "files", "is", "zip", "bs", "address", "body", "string", "pages", "codes", "details", "outs", "es", "results", "tes", "items", "maps", "classes", "id", "blocks", "ids", "rows", "content"], "i": ["p", "x", "uri", "z", "field", "c", "inner", "f", "ai", "s", "ii", "info", "gi", "e", "l", "I", "k", "pos", "ci", "val", "uli", "abi", "m", "in", "multi", "n", "bi", "io", "si", "u", "b", "ti", "it", "ui", "pi", "oi", "index", "li", "h", "j", "hi", "di", "qi", "xi", "fi", "r", "t", "mu", "slice", "id", "o", "end", "type", "v", "ri", "d", "phi"]}}
{"id1": "2521141", "id2": "335223", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "source", "create", "sync", "paste", "load", "update", "download", "config", "cat", "ame", "archive", "link", "dump", "move", "image", "open", "cop", "directory", "clone", "rm", "clip", "share", "pe", "change", "ge", "transfer", "zip", "upload", "Copy", "attach", "cp", "opy", "ize", "write", "file", "ignore", "diff", "type", "get", "delete"], "from_name": ["fromFpath", "fromMname", "from__name", "fromFmemory", "fromMfile", "from_Name", "source_path", " from_names", "to_path", "from__filename", " from_key", "fromFfilename", "from_memory", "fromMnames", "source_filename", "from_filename", "from_key", "fromFname", "from_names", " from_Name", "from__memory", "from__path", "to_filename", "source_name", "from_path", "source_memory"], "to_name": ["to_path", "to_filename", "from_filename", "toampath", "toamfile", " to_home", "to_Name", "from_path", "to_home", "toamname", "toamhome", " to_path", " to_Name"], "from_file": ["from___auto", "remote_function", "from__directory", "remote_lane", "from__name", " from_folder", "from___file", "source_brain", "remote_log", "source_resource", " from_directory", "fromCfile", "fromappfunction", "from_log", "fromCname", "from_lane", "source_files", "from__files", "from___name", "from__filename", "remote_file", "from_resource", "fromapplane", "fromapplog", "source_filename", "from_function", "from_directory", "fromCbrain", "from_filename", " from_files", "from__auto", "fromappfile", "from_files", " from__file", "from_brain", " from__filename", "from_folder", " from__auto", "source_directory", "from__file", "fromCfilename", " from_source", "source_file", "source_name", "from___filename", " from_auto", " from__name", "from__resource", "from_auto", "from_source", " from_filename"], "to_file": ["from_stream", "to_files", "to64function", "to64name", "from_bar", " to_class", "eto___name", "from_model", "to_bar", " to_model", "tojuse", "eto___remote", "toJname", "from_load", "to___name", "to64file", "into_use", "toJstream", "source_files", "intojfunction", "to_model", "eto_file", "from_binary", "tojname", "to__load", " to_queue", "source_filename", "toJfile", "tojfunction", "intojfile", "to67load", "to___file", "eto_name", "to___remote", "to__dir", "into_file", "to__file", "intojname", "from_files", "to_queue", " to_filename", "to__name", "to_server", "to67name", "to_filename", "tojfile", "source_server", "to_binary", "source_file", "into_name", "to64use", " to_files", "to67file", "to_load", "to_use", "to67dir", "into_function", "toJbar", "eto_remote", "to_function", "to_remote", "to_stream", "intojuse", "to_class", "to_dir", "eto___file", "from_dir"], "parent": ["source", "remote", "cache", "current", "out", "session", "owner", "global", "loc", "location", "ip", "directory", "url", "name", "null", "search", "pool", "rule", "div", "size", "temp", "any", "type", "target", "uri", "client", "ppa", "home", "root", "po", "tree", "or", "pa", "term", "api", "test", "Parent", "id", "unit", "user", "path", "point", "mother", "folder", "resource", "container", "string", "par", "am", "inc", "content", "p", "port", "ac", "memory", "author", "page", "per", "manager", "complete", "parents", "old", "server", "host", "function", "child", "address", "connection", "patch", "handler", "full", "file", "part", "fat"], "dir": ["group", "md", "cache", "out", "dec", "dict", "path", "Dir", " directory", "cat", "f", "home", "ver", "wd", "per", "root", "keep", "manager", "global", "or", "build", "loc", "data", "folder", "object", "module", "in", "dep", "ir", "director", "directory", "io", "class", "url", "name", "nav", "die", "container", "dr", "cur", "exp", "div", "lock", "dev", "di", "coll", "block", "iter", "def", "file", "tr", "part", "r", "entry", "id", "dis", "user", "db", "d", "doc", "rel", "dc"], "from": ["source", "form", "normal", "who", "cache", "so", "se", "client", "parse", "cf", "empty", "cor", "with", "this", "component", "view", "link", "e", "one", "per", "vol", "conn", "or", "get", "by", "left", "con", "ce", "self", "find", "io", "bean", "flo", "url", "base", "name", "low", "add", "pe", "server", "ou", "cr", "fe", "address", "api", "ch", "without", "connection", "two", "fr", "From", "stream", "cm", "range", "auto", "ra", "file", "start", "part", "when", "feed", "entry", "can", "context", "http"], "to": ["tto", "as", "top", "su", "token", "TO", "so", "client", "out", "output", "session", "thro", "sync", "ver", "fb", "store", "not", "with", "via", "per", "one", "po", "socket", "conn", "too", "about", "or", "by", "proxy", "storage", "dest", "io", "on", "flo", "base", "server", "until", "pi", "api", "see", "db", "connection", "two", "will", "size", "write", "To", "auto", "office", "value", "file", "t", "op", "o", "fat", "type", "that", "target", "co", "http"], "buffer": ["source", "message", "position", "shape", "length", "memory", "bb", "buff", "buf", "page", "texture", "seed", "uffer", "border", "padding", "default", "read", "data", "writer", "duration", "total", "resource", "binary", "comment", "document", "window", "character", "url", "b", "null", "server", "transfer", "number", "address", "variable", "Buffer", "header", "channel", "queue", "layer", "batch", "reference", "iter", "block", "row", "wave", "feed", "slice", "reader", "flush"], "bytes_read": ["bytes___pass", "bytesXload", " bytes_en", "bytes_load", "bytesXcurrent", "byte_load", "byte_before", "gets___pass", "gets___read", "byteslexread", "bytes_write", "byteslexbefore", "bytes_reads", "bytesXread", "gets___reads", "bytes_current", "bytes___read", " bytes_write", "byteslexload", "bytes_pass", "bytes_before", "bytes_en", "gets_allow", "gets_reads", "byteslexcurrent", "byte_read", "bytes___reads", "byte_current", "gets___allow", "bytes_allow", "gets_read", "bytesXbefore", " bytes_found", "bytes_found", "gets_pass", "bytes___allow"]}}
{"id1": "22441244", "id2": "1180878", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "160739", "id2": "3024992", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createByteReader", " createInputStream", " createByteFile", " createIOReader", " createIOFile", " createInputReader", " createInputSteam", " createInputFile", "createInputSteam", "createOutputReader", "createOutputSteam", " createByteStream", "createOutputFile", " createOutputReader", "createInputStream", " createOutputSteam", "createInputFile", " createOutputFile", " createByteSteam", " createIOSteam", " createIOStream", "createInputReader"], "inFile": ["outFiles", "inputFile", "insFile", "incfile", "insfile", "incFile", "inFiles", "inputfile", "insFiles", "sourcefile", "incStream", "sourceFiles", "inputStream", "insStream", "outfile", "infile", "sourceStream", "outStream", "sourceFile", "inputFiles", "inStream", "incFiles"], "outFile": ["workingFile", "outTime", "workingDirectory", "targetfile", " outfile", "inputFile", " outStream", "workDir", "inputTime", "inputDir", " outDirectory", "targetDirectory", "outDir", "outDirectory", "targetFile", "workingStream", "inputfile", "inTime", "workTime", "outfile", "infile", "outStream", "workfile", "workFile", "targetStream", "inDir", "workingfile"], "k_blockSize": ["k_lockCount", "k_blockLength", "k_byteCode", "k_lineCount", "k_bitSize", "k_byteSize", "k_blocksSize", "k_lockLength", "k_BlockCode", "k_byteCount", "k_lineSize", "k_bitInfo", "k_lockSize", "k_byteLen", "k_lineInfo", "k_blockCount", "k_BlockCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksCount", "k_blockCode", "k_blockLen", "k_blocksLen", "k_BlockSize", "k_blocksLength", "k_byteInfo", "k_BlockLength", "k_bitCount", "k_blockInfo"], "byteCount": ["characterLen", "flushcount", "byteLen", "characterSize", "ByteCount", "bytecount", "ByteLength", "flushSize", "blockCount", "ByteSize", "blockSize", " byteLen", "byteSize", " byteSum", "characterLength", "Bytecount", "byteSum", "ByteSum", "byteLength", "ByteLen", " byteLength", "blockLength", " bytecount", "blockSum", "characterCount", "flushCount", " byteSize", "flushLength"], "buf": ["cv", "bh", "buffer", "result", "uf", "seq", "bag", "feat", "config", "buff", "fb", "len", "font", "bytes", "cmd", "src", "border", "exc", "brace", "loc", "data", "background", "bf", "cas", "img", "tmp", "base", "b", "fd", "Buffer", "append", "rc", "rb", "ucc", "queue", "batch", "alloc", "vec", "cap", "feed", "Buff", "ctx", "flush", "cb", "la"], "ofp": ["afp", "fort", "ofl", "OFnp", "afnp", "OFc", "ofc", "Ofnp", "Ofl", "OFtp", "oft", "Oftp", "ofnp", "Ofc", "OFl", "OFp", "forc", "Ofp", "afl", "oftp", "Oft", "forp", "fortp", "OFt", "afc"], "zos": ["ogl", "iframe", "bos", "zik", "tz", "zona", "abi", "zb", "core", "los", "inos", "zip", "zn", "lins", "css", "ozo", "zin", "zx", "nox", "forge", "oses", "liquid", "uz", "iffs", "zl", "gz", "rons", "nz", "zy", "za", "hz", "ossus", "os", "oS", "utils", "cos", "ZA", "dylib", "fits", "ZI", "zag", "budget", "zes", "outs", "jas", "js", "kos", "zon", "ls", "zers", "oda", "ros", "modules", "bs", "zo", "zh", "rez", "lol", "osi", "zi", "owicz", "soon", "z", "obb", "zer", "robe", "cfg", "zyk", "ws", "enos", "ses", "webkit", "zig", "zen", "packs", "obs", "bitcoin", "zar", "bes", "ops"], "osw": [" osow", "osx", "oswd", "ossnow", "osws", "lsw", "osnow", "isy", "bx", "ossy", " osfw", "lswo", "bws", "iswd", "ossow", "bwo", "ossw", "esww", "eshell", "esfw", "isd", "eswd", "issw", "osshell", "osd", "ossd", "lsws", "oswo", "osfw", "oshell", "osow", "esd", "esw", "essw", "bsx", "isw", "ossfw", "bsw", "isnow", "esnow", "osww", "esow", "ishell", "bsws", "osssw", "lsx", "osy", "bswo", "osswd", " osww", "ossww", "esy"], "bw": ["fsw", " bws", "bbwh", " bwu", "owu", "ebwd", "lsw", " bz", "fx", "bbaw", "Bw", "bx", "lbwh", "lbz", "bW", "abW", "bbz", "ebW", "bwe", "lw", "bz", "bws", "fbwe", "lbw", "baw", "fwa", "lbws", "bew", "bbwa", "Bwa", "fbw", " baw", "bbew", "owa", "fbwd", "bbwu", "fw", "oaw", "abw", "Bew", "lbwa", "abwe", "bbw", "fr", "abwd", "ebwe", " bwh", "ebw", "bsw", "lbx", "lbsw", " bew", "lwa", "lx", "fwh", "bwu", "ow", "fbW", "bwd", "bwa", "bbws", "lbr", "bwh", " bwa", "Bws"], "zot": ["azit", "zott", "zerita", "jos", "Zit", "Zott", "zerori", " zori", " zor", "ziot", "zor", "jit", "azot", "zita", "azor", "Ziot", "jot", "azott", "Zot", "zerot", "zeros", "azita", "Zita", "zerit", "Zor", "zori", "zerott", "jori", " ziot", "aziot"], "ifp": ["IFl", "IFi", "ifl", " ifl", "IFb", "IFf", "ipb", "iff", "ifb", "ifc", " ifi", "ipc", "ifi", "Ifp", "Ifc", "ipp", " iff", " ifb", "IFp", "Ifi", "Iff", " ifc", "IFc", "ipl"], "zis": ["zeis", "Zits", "xits", "Ziss", "zeip", "jits", "zipis", "xisi", "zenais", " zIS", "zIS", "xIS", "zipits", "jisi", "jit", "zenIS", "zits", "xis", "zisi", "zeiss", "ziss", " zais", "zib", "zipip", "zip", "jis", "zais", " zib", " zits", "zeits", "zenib", " zisi", "xib", "zipiss", "xit", "xais", "Zis", "zenis", "Zip"], "isr": ["irrb", " iscr", "ISrc", "issrs", "ISpr", "rispr", "irr", "risrc", "ISsr", "isrb", "issr", " isrs", "iscr", "ISrs", "ISr", "risrb", "risr", "irpr", "ISrb", "isrs", "isscr", "isssr", "irrc", "IScr", "ispr", " issr", "isrc"], "br": ["kr", "bh", "rib", "bro", "arr", "str", "ibr", "browser", "bar", "obl", "HR", " BR", "mr", "BR", "bl", "bp", "Br", "rs", " Br", "sr", "img", "bc", "ber", "obi", "b", "hr", "ocr", "ch", "gr", "cro", "rb", "body", "sp", "ibl", "div", "fr", "yr", "shr", "lr", "ctr", " dr", "tr", "bsp", " fr", "r", "err", "ob"], "zit": ["jith", "zipit", "jite", "zeit", "zipIT", "zeitter", " zip", "jits", "zitter", "zith", "jip", "zipite", "jIT", "zipita", "zipitter", " zith", "zenits", "zipits", "zic", "zeith", "jit", "zits", " zite", "zeita", "zita", "xic", "zipip", "zip", " zi", "zenith", "ji", " zits", "xith", "zIT", "zeits", "jic", "zeIT", "xi", "zenitter", "jita", "zenit", "zipith", "zi", "zite", "xit", " zic"]}}
{"id1": "14688886", "id2": "3187685", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"populateResources": ["popractResource", "compureResources", "popureRelations", "compulateResources", "poputeRelations", "populateRelations", "poputeResources", "popureFiles", "popureResources", "poputeResource", "popureResource", "compureRelations", "popractFiles", "compulateRelations", "compureFiles", "compulateFiles", "popractResources", "poputeFiles", "compureResource", "compulateResource", "populateFiles", "populateResource", "popractRelations"], "templates": ["templateplates", "tempps", "temps", "filpl", "templateples", "Template", "tompl", "tomplate", "Temeters", "tomplates", "tometers", "Templates", "tempplates", " temens", "templateps", "temeters", "Templ", "typs", "stemps", "temppl", "templ", "Temens", "stemplates", "stempl", "Temures", "temens", "typl", "prometers", "temures", "tempplate", "promplate", "templatepl", " temures", "filures", "filplates", "stemples", "promplates", "filens", "Temples", "prompl", "Temps", "typlates", "template", "temples", " templ", "typlate"], "url": ["source", "filename", "buffer", "uri", " URL", "path", "Url", "download", "f", "config", "page", "pl", "il", "link", "e", "l", "image", "data", "service", "object", "resource", "email", "location", "base", "name", "job", "server", "host", "URL", "fl", "sl", "address", "string", "connection", "channel", "el", "html", "file", "route", "r", "template", "ssl", "entry", "feed", "ob", "href", "xml", "pattern", "http"], "fileName": ["filenameLength", " filePath", "FileInfo", "folderPath", "resourceName", "filePart", " fileSync", " fileType", "FileDir", "FILELocation", "sourcename", "folderPart", "modelLocation", "FILEname", "fileString", " fileLength", "stringName", "modelname", "fileDir", "FILESystem", "fileLocation", "stringDirectory", "fileType", "stringType", "fname", "resourcename", "objectTime", "sourceLength", "resourcePart", "FileDirectory", "Filename", "fileFull", "FileFull", "foldername", " fileLocation", "objectname", "resourcePath", "filenameType", "sourceString", "FileString", "fKey", " filePart", "objectSync", " filename", "sourceInfo", "FILESync", "sourceName", "FileName", "modelName", "FILEName", "FileType", "FILETime", "filenameFull", "fileSync", " fileTime", " fileDir", "fileDirectory", " fileSystem", "filename", "fName", "filePath", "filenamename", "fileTime", "fileKey", " fileDirectory", "fileInfo", " fileFull", " fileKey", "fileLength", "folderName", "filenameString", " fileInfo", "modelSystem", "filenameName", "fileSystem", "objectName", "FileKey", "fDir", " fileString"], "templateResource": ["eventresource", " templateRole", "xmlFile", "xmlResource", "privateresource", "plateContent", "translationResource", "privateResource", "tempFile", "eventResource", "templateRing", "translationContent", "layoutContainer", "templateReader", "xmlType", "privateUrl", "privateReader", "eventReader", "templateFile", "tempResource", " templateType", "xmlRole", "translationRing", "copyReader", " templateFile", "templateContainer", "plateResource", "templateRole", "templateUrl", "copyResource", "tempType", "layoutResource", "copyUrl", "layoutRing", "templateContent", "templateType", "eventUrl", "layoutContent", "copyresource", "templateresource", "plateRing", "tempRole", "translationContainer", "plateContainer"], "is": ["as", "ris", "app", "uri", "isa", "IS", "out", "im", "was", "s", "its", "ori", "iss", "Is", "irc", "serv", "src", "iso", "in", "ib", "lis", "ir", "ip", "io", "ar", "os", "it", "isc", "isl", "isi", "api", "rss", "ais", "ios", "abs", "iris", "r", "nis", "bis", "has", "ri", "cms"], "strBuff": ["StrTab", "brBuff", "strbuff", "rbuff", "brGrab", "arrTab", " strTab", "StrPref", "strGrab", " strFlow", " strPref", "stringBuffer", "brBuffer", "rBuff", "arrBuff", "strFlow", "stringGrab", "rBuffer", "strBuffer", "StrBuff", "StrBuffer", " strBuffer", " strText", "brFlow", "arrPref", "stringBuff", "stringFlow", "rText", "Strbuff", "StrText", " strGrab", "strPref", "arrBuffer", "strText", " strbuff", "strTab"], "br": ["text", "result", "bro", "arr", "browser", "bar", "cb", "buf", "ori", "mr", "BR", "bl", "data", "Br", "sr", "io", "bc", "ber", "b", "hr", "cr", "nr", "res", "gr", "sp", "rb", "brush", "dr", "div", "fr", "yr", "stream", " reader", "ctr", "Reader", "tr", "r", "er", "err", "reader", "orb"], "str": ["p", "text", "kr", "strike", "char", "style", "arr", "st", "Str", "f", "line", "STR", "stri", "or", "data", "star", "sr", "name", "sec", "lc", "spec", "hr", "cr", "sc", "wr", "sl", "oct", "sp", "dr", "cur", "string", "div", "fr", "enc", "coll", "pr", "cl", "iter", "tr", "r", "er", "t", "err", "key", "type"], "images": ["frames", "holes", "videos", "types", "people", "png", "tests", "bands", "apps", "media", "words", "ups", "agents", "photos", "styles", "inches", "ips", "sites", "assets", "versions", "groups", "shows", "services", "icons", "image", "dates", "resources", "games", "rooms", "ages", "opens", "flows", "letters", "pieces", "objects", "boxes", "thumbnails", "picture", "files", "ims", "Images", "features", "ins", "models", "tags", "pages", "views", "xs", "scripts", "quarters", "gif", "plugins", "users", "gallery", "lights", "classes", "ions", "events", "stars", "jobs"], "i": ["x", "ai", "config", "s", "I", "image", "ci", "chi", "ip", "u", "add", "li", "y", "key", "slice", "d", "ti", "http", "uri", "info", "this", "ini", "multi", "iu", "bi", "io", "n", "lc", "pi", "j", "eni", "_", "cli", "mu", "id", "diff", "hi", "ii", "e", "ind", "format", "si", "b", "ji", "mi", "di", "qi", "gu", "html", "xi", "phi", "p", "uni", "app", "ij", "z", "Url", "ni", "f", "gi", "ie", "yi", "in", "it", "ui", "index", "fi", "v", "xml"], "img": ["p", "png", "ani", "app", "iframe", "arr", "im", "cb", "f", "config", "info", "fb", "ie", "input", "src", "bl", "image", "inst", "ff", "aut", "norm", "data", "m", "map", "aff", "tmp", "small", "hr", "ext", "tif", "fw", "bg", "ch", "sl", "li", "gd", "exp", "imp", "ng", "gif", "file", "gallery", "lib", "icon", "jpg", "v", "fig", "att", "abc"], "imgProperty": ["imgImage", "bgPro", "bgProp", "cacheImage", "bgImage", "cacheProperty", "imgProp", " imgImage", " imgProp", "cacheProp", "imgPro", "cachePro", "bgProperty", " imgPro"]}}
{"id1": "5551393", "id2": "8064604", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"getMD5": [" getM5", " getM4", "getmd4", "getmd512", " getM512", "getMD4", "getM256", " getMD256", " getM256", "getSHA4", "getSHA512", "getM512", "getmd5", "getMD256", "getSHA256", "getMD512", "getmd256", " getMD512", "getM5", "getSHA5", " getMD4", "getM4"], "source": ["text", "message", "style", "result", "buffer", "output", "length", "config", "info", "bytes", "seed", "input", "src", "ource", "SOURCE", "data", "Source", "service", "object", "resource", "proxy", "dest", "expected", "url", "name", "base", "sm", "security", "code", "address", "secure", "string", "size", "file", "temp", "template", "slice", "unit", "start", "target", "content"], "tmp": ["stuff", "result", "sb", "copy", "output", "cache", "fp", "mp", "current", "buffer", "py", "emp", "vt", "buf", "txt", "src", "var", "meta", "default", "data", "nm", "metadata", "binary", "Temp", "bf", "storage", "tt", "dest", "foo", "b", "array", "vm", "params", "code", "obj", "zip", "body", "rb", "cpp", "test", "html", "temp", "part", "ignore", "cb", "cmp"], "md": ["mand", "mmm", "mm", "mp", "mod", "amd", "wd", "cmd", "dm", "mb", "meta", "oda", "mg", "ind", "sd", "m", "nm", "ad", "mad", "mac", "bf", "editor", "rm", "ms", "vd", "nd", "zip", "pd", "gd", " MD", "mi", "od", "di", "dd", "mn", "mo", "cm", "mt", "hd", "ld", "cd", "MD", "mc", "ma", "mu", "mag", "pm", "d", "rpm", "bd"]}}
{"id1": "13233761", "id2": "20939940", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"executeUpdateTransaction": ["executeInsertSession", "executeInsertStatement", "executeInsertTransaction", " executeDatabaseSession", "executeInsertTx", "executeDatabaseTx", "executeUpdateTx", "executeQuerySession", "executeUpdateStatement", "executeQueryTx", "executeDatabaseTransaction", "executeUpdateSession", " executeDatabaseTx", " executeUpdateStatement", " executeUpdateSession", " executeDatabaseTransaction", "executeDatabaseSession", " executeUpdateTx", "executeQueryTransaction", "executeQueryStatement", " executeDatabaseStatement", "executeDatabaseStatement"], "queries": ["commips", "quands", "squests", "compips", "commeries", "questips", "blests", "commires", "quires", "questires", "questeries", "commands", "quests", "questands", "blips", "blands", "squands", "comperies", "compests", "quips", "squeries", "compands", "squires", "bleries", "squips"], "autoCommit": ["autoComits", "autoDebrit", "AutoCommits", " autoComits", "autoCommrit", "AutoDebrit", "autoommit", "autoCompmit", "autoComitted", "autoCommitted", "autoComit", "AutoDebmit", "autoommitted", "autoCompit", "autocommits", " autoComit", "AutoCommmit", " autoComitted", "autoDebits", "autoommmit", "autocommit", "AutoCommrit", "AutoDebits", " autoCommmit", "autocommrit", "autoCommits", "autoCompits", "autoComrit", "autoCompitted", "AutoCommit", " autoCommitted", "autocommmit", "autoommits", " autoCommits", "autoCommmit", "AutoDebit", "autoDebmit", "autoDebit"], "iterator": ["vector", "sequence", "init", "internet", "set", "starter", "inner", "instance", "finder", "info", "ter", "cher", "consider", "i", "ie", "pointer", "inst", "gener", "population", "data", "walker", "loader", "encer", "metadata", "done", "started", "later", "division", "next", "Iterator", "database", "interstitial", "series", "runner", "outer", "ator", "index", "list", "string", "connection", "size", "former", "section", "handler", "stream", "filter", "parser", "iter", "creator", "runners", "collection", "loop", "step", "slice", "entry", "end", "reader", "inter", "start", "ski", "adder", "context"], "query": ["sequence", "message", "call", "press", "style", "result", "select", "expression", "question", "uri", "str", "table", "script", "update", "ql", "command", "condition", "data", "q", "record", "comment", "action", "next", "name", "search", "string", "connection", "rule", "sql", "qu", "sq", "filter", "value", "row", "key", "entry", "join", "commit", "Query"], "statement": ["ment", "sequence", "style", "result", "expression", "table", "Statement", "script", "session", "s", "state", "use", "command", "conn", "inst", "condition", "data", "comment", "storage", "action", "next", "si", "database", "document", "execute", "function", "stat", "connection", "string", "usage", "element", "mt", "sql", "parser", "start", "response", "join", "unit", "commit", "flush", "section"]}}
{"id1": "5274228", "id2": "23310397", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "label": 0, "substitutes": {"put": ["create", "cache", "output", "client", "parse", "st", "Put", "update", "PUT", "build", "data", "resource", "format", "transform", "add", "UT", "transfer", "post", "operation", "string", "patch", "write", "submit", "replace", "file", "pull", "get"], "resourceID": ["serviceIDs", "responseKey", "resourceId", "serviceId", "objectIDs", "ResourceURL", "responseID", "responseURL", "objectId", "resourceid", "resourceURL", "objectid", "resourceIDs", "resourceKey", "ResourceID", "responseId", "Resourceid", "requestId", "ResourceId", "objectID", "ResourceKey", "serviceID", "requestURL", "serviceid", "requestID", "ResourceIDs", "requestKey"], "headersMap": [" headersFile", "httpMap", "httpSet", "headersSet", "ersFile", "headersFile", "headerSet", "httpArray", "httpList", " headersSet", "headerList", "headerFile", "headerMap", "ersArray", "headerArray", "ersMap", "ersList"], "httpClient": ["HttpClient", "httpsClient", "ttpClient", "httpContext", " httpContext", "phpCall", "httpConnection", "httpsPut", " httpCall", "ttpConnection", "httpsBase", "HttpContext", " httpConnection", "httpServer", "httpsConnection", "HttpPut", "httpCall", "httpsServer", "httpCase", "httpBase", "ttpPut", "HttpServer", "HttpCase", "phpClient", " httpCase", " httpBase", "phpCase", "ttpBase", "HttpCall", " httpServer", "httpsContext", "phpPut"], "httpPut": ["HttpClient", "HttpPush", "phpPush", "phpSplit", "httpsClient", "phpGet", "viewPUT", " httpGet", "viewPut", " httpPUT", "phpAdd", " httpWrite", "httpsPut", "httpsPUT", "httpDo", "webPush", "httpGet", "httpsSplit", "webPut", "httpSplit", "httpPush", "httpsAdd", "HttpDo", "HttpPut", "internalPut", " httpAdd", "Httpput", "httpWrite", "internalGet", "internalPush", "httpput", "internalWrite", " httpPush", "httpAdd", "phpWrite", "webPUT", "httpsPush", "HttpPUT", "HttpGet", "httpsput", "httpPUT", "viewPush", "httpsGet", "viewput", " httpSplit", " httpDo", "httpsDo", "webGet", "phpPut"], "headersList": ["driversMap", " headersL", "headersSet", "ersL", "headerSet", " headersSet", "driversL", "headerList", "headerMap", "ersArray", "headerArray", "driversArray", "ersList", "headersL", "headerL", "driversList", "ersSet"], "iterator": ["vector", "sequence", "init", "set", "starter", "inner", "basic", "finder", "instance", "ter", "driver", "processor", "ie", "pointer", "gener", "loader", "walker", "writer", "done", "started", "later", "multi", "operator", "division", "next", "Iterator", "interstitial", "runner", "outer", "random", "Iter", "ator", "append", "li", "former", "size", "handler", "engine", "stream", "kick", "parser", "iter", "creator", "eni", "loop", "collection", "start", "step", "slice", "entry", "end", "reader", "inter", "oper", "ski", "adder"], "headersArray": ["filesAr", "headsList", "filesArray", "headsLength", "ersAr", " headersAr", "hersAr", "filesMap", " headersHash", "headsArray", "headersLength", " headersLength", "ersArray", "hersList", "ersMap", "hersArray", "filesHash", "headersHash", "ersHash", "hersLength", "headsAr", "headersAr"], "fields": ["FIELD", "types", "lines", "json", "field", "keys", "dates", "data", "errors", "format", "values", "params", "files", "zip", "body", "region", "prefix", "codes", "details", "Field", "properties", "dir", "comments", "pattern", "rows", "content"], "occiHeaders": ["occiBuilders", "occiBuilderers", "ocsiHeadlers", "ocsiBufflers", "occiHostlers", "occiBuffers", "ocsiHeaders", "occiHoster", "occiBuffer", "ocsiHeader", "ocsiBuffer", "occiBufflers", "occiHosterers", "occiHeader", "occiHeadlers", "occiHeaderers", "occiBuilder", "ocsiHeaderers", "ocsiBufferers", "occiBufferers", "occiHosters", "occiBuildlers", "ocsiBuffers"], "H": ["Hop", "F", "J", "HC", "L", "HT", "Header", "Length", "HR", "HS", "HTTP", "TH", "M", "I", "SH", "N", "B", "OH", "NH", "G", "W", "X", "C", "Index", "HH", "R", "DH", "HE", "HM", "T", "EH", "V", "ID", "HI", "K", "MH", "D", "Q", "Handler", "CH", "HB", "Y", "U", "S", "rh", "P", "Head"], "header": ["message", "bridge", "result", "buffer", "token", "Header", "feature", "cover", "inner", "frame", "f", "info", "back", "head", "ter", "event", "extra", "cher", "driver", "per", "ler", "ker", "manager", " request", "writer", "definition", "service", "consumer", "builder", "metadata", "later", "comment", "document", "outer", "server", "player", "dr", "string", "rule", "holder", "former", "detail", "handler", "layer", "second", "block", "value", "file", "request", "row", "key", "er", "response", "her", "entry", "reader", "liner", "http"], "statusLine": ["responseLine", "statusBody", "StatusLine", "statusFile", "StatusText", "StatusFile", "StatusString", " statusBody", " statusText", " statusString", "StatusCode", "responseFile", "responseText", "StatusBody", " statusFile", "errorLine", "statusString", "statusText", "errorCode", "errorBody", "responseCode", "errorString"], "httpResponse": ["Httpresponse", "httpresponse", "HttpEnvironment", "ttpResult", " httpPage", "HttpBlock", "statusBody", " httpEnvironment", "statusResponse", "httpResp", "HttpBody", "statusResult", "actualResponse", " httpResult", "httpsRequest", " httpBody", "actualresponse", "actualLine", "HttpLine", "httpBlock", "ttpResponse", "HttpStatus", " httpResp", "httpPage", "httpsPage", "httpsResponse", " httpStatus", "statusBlock", " httpRequest", " httpLine", "ttpResp", "httpResult", "HttpResponse", "templateResponse", "HttpPage", "httpRequest", "templateLine", "httpLine", "httpsEnvironment", "actualRequest", "httpStatus", "httpsBody", "httpEnvironment", " httpresponse", "HttpResp", "httpsResult", "HttpResult", "httpBody", "ttpRequest", "HttpRequest", "templateStatus", " httpBlock", "templateResp"], "statusCode": [" statusType", "StatusCount", "responseLine", " statuscode", "StatusLine", "errorType", "StatusType", "StatusData", "StatusText", "statusData", " StatusLine", " statusCount", "responseType", "StatusCode", "resultcode", "responseText", " StatusData", "statuscode", "errorText", "resultCode", "statusType", " StatusCode", "statusCount", "errorLine", "resultCount", " StatusType", "statusText", "resultLine", " statusData", "errorCode", "responseCode", "Statuscode"]}}
{"id1": "5274228", "id2": "14194234", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"put": ["create", "cache", "output", "client", "parse", "st", "Put", "update", "PUT", "build", "data", "resource", "format", "transform", "add", "UT", "transfer", "post", "operation", "string", "patch", "write", "submit", "replace", "file", "pull", "get"], "resourceID": ["serviceIDs", "responseKey", "resourceId", "serviceId", "objectIDs", "ResourceURL", "responseID", "responseURL", "objectId", "resourceid", "resourceURL", "objectid", "resourceIDs", "resourceKey", "ResourceID", "responseId", "Resourceid", "requestId", "ResourceId", "objectID", "ResourceKey", "serviceID", "requestURL", "serviceid", "requestID", "ResourceIDs", "requestKey"], "headersMap": [" headersFile", "httpMap", "httpSet", "headersSet", "ersFile", "headersFile", "headerSet", "httpArray", "httpList", " headersSet", "headerList", "headerFile", "headerMap", "ersArray", "headerArray", "ersMap", "ersList"], "httpClient": ["HttpClient", "httpsClient", "ttpClient", "httpContext", " httpContext", "phpCall", "httpConnection", "httpsPut", " httpCall", "ttpConnection", "httpsBase", "HttpContext", " httpConnection", "httpServer", "httpsConnection", "HttpPut", "httpCall", "httpsServer", "httpCase", "httpBase", "ttpPut", "HttpServer", "HttpCase", "phpClient", " httpCase", " httpBase", "phpCase", "ttpBase", "HttpCall", " httpServer", "httpsContext", "phpPut"], "httpPut": ["HttpClient", "HttpPush", "phpPush", "phpSplit", "httpsClient", "phpGet", "viewPUT", " httpGet", "viewPut", " httpPUT", "phpAdd", " httpWrite", "httpsPut", "httpsPUT", "httpDo", "webPush", "httpGet", "httpsSplit", "webPut", "httpSplit", "httpPush", "httpsAdd", "HttpDo", "HttpPut", "internalPut", " httpAdd", "Httpput", "httpWrite", "internalGet", "internalPush", "httpput", "internalWrite", " httpPush", "httpAdd", "phpWrite", "webPUT", "httpsPush", "HttpPUT", "HttpGet", "httpsput", "httpPUT", "viewPush", "httpsGet", "viewput", " httpSplit", " httpDo", "httpsDo", "webGet", "phpPut"], "headersList": ["driversMap", " headersL", "headersSet", "ersL", "headerSet", " headersSet", "driversL", "headerList", "headerMap", "ersArray", "headerArray", "driversArray", "ersList", "headersL", "headerL", "driversList", "ersSet"], "iterator": ["vector", "sequence", "init", "set", "starter", "inner", "basic", "finder", "instance", "ter", "driver", "processor", "ie", "pointer", "gener", "loader", "walker", "writer", "done", "started", "later", "multi", "operator", "division", "next", "Iterator", "interstitial", "runner", "outer", "random", "Iter", "ator", "append", "li", "former", "size", "handler", "engine", "stream", "kick", "parser", "iter", "creator", "eni", "loop", "collection", "start", "step", "slice", "entry", "end", "reader", "inter", "oper", "ski", "adder"], "headersArray": ["filesAr", "headsList", "filesArray", "headsLength", "ersAr", " headersAr", "hersAr", "filesMap", " headersHash", "headsArray", "headersLength", " headersLength", "ersArray", "hersList", "ersMap", "hersArray", "filesHash", "headersHash", "ersHash", "hersLength", "headsAr", "headersAr"], "fields": ["FIELD", "types", "lines", "json", "field", "keys", "dates", "data", "errors", "format", "values", "params", "files", "zip", "body", "region", "prefix", "codes", "details", "Field", "properties", "dir", "comments", "pattern", "rows", "content"], "occiHeaders": ["occiBuilders", "occiBuilderers", "ocsiHeadlers", "ocsiBufflers", "occiHostlers", "occiBuffers", "ocsiHeaders", "occiHoster", "occiBuffer", "ocsiHeader", "ocsiBuffer", "occiBufflers", "occiHosterers", "occiHeader", "occiHeadlers", "occiHeaderers", "occiBuilder", "ocsiHeaderers", "ocsiBufferers", "occiBufferers", "occiHosters", "occiBuildlers", "ocsiBuffers"], "H": ["Hop", "F", "J", "HC", "L", "HT", "Header", "Length", "HR", "HS", "HTTP", "TH", "M", "I", "SH", "N", "B", "OH", "NH", "G", "W", "X", "C", "Index", "HH", "R", "DH", "HE", "HM", "T", "EH", "V", "ID", "HI", "K", "MH", "D", "Q", "Handler", "CH", "HB", "Y", "U", "S", "rh", "P", "Head"], "header": ["message", "bridge", "result", "buffer", "token", "Header", "feature", "cover", "inner", "frame", "f", "info", "back", "head", "ter", "event", "extra", "cher", "driver", "per", "ler", "ker", "manager", " request", "writer", "definition", "service", "consumer", "builder", "metadata", "later", "comment", "document", "outer", "server", "player", "dr", "string", "rule", "holder", "former", "detail", "handler", "layer", "second", "block", "value", "file", "request", "row", "key", "er", "response", "her", "entry", "reader", "liner", "http"], "statusLine": ["responseLine", "statusBody", "StatusLine", "statusFile", "StatusText", "StatusFile", "StatusString", " statusBody", " statusText", " statusString", "StatusCode", "responseFile", "responseText", "StatusBody", " statusFile", "errorLine", "statusString", "statusText", "errorCode", "errorBody", "responseCode", "errorString"], "httpResponse": ["Httpresponse", "httpresponse", "HttpEnvironment", "ttpResult", " httpPage", "HttpBlock", "statusBody", " httpEnvironment", "statusResponse", "httpResp", "HttpBody", "statusResult", "actualResponse", " httpResult", "httpsRequest", " httpBody", "actualresponse", "actualLine", "HttpLine", "httpBlock", "ttpResponse", "HttpStatus", " httpResp", "httpPage", "httpsPage", "httpsResponse", " httpStatus", "statusBlock", " httpRequest", " httpLine", "ttpResp", "httpResult", "HttpResponse", "templateResponse", "HttpPage", "httpRequest", "templateLine", "httpLine", "httpsEnvironment", "actualRequest", "httpStatus", "httpsBody", "httpEnvironment", " httpresponse", "HttpResp", "httpsResult", "HttpResult", "httpBody", "ttpRequest", "HttpRequest", "templateStatus", " httpBlock", "templateResp"], "statusCode": [" statusType", "StatusCount", "responseLine", " statuscode", "StatusLine", "errorType", "StatusType", "StatusData", "StatusText", "statusData", " StatusLine", " statusCount", "responseType", "StatusCode", "resultcode", "responseText", " StatusData", "statuscode", "errorText", "resultCode", "statusType", " StatusCode", "statusCount", "errorLine", "resultCount", " StatusType", "statusText", "resultLine", " statusData", "errorCode", "responseCode", "Statuscode"]}}
{"id1": "15445861", "id2": "16142024", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyfile", "CopyFile", "copyFiles", "transferfile", "transferFile", "copyDirectory", "transferDirectory", "CopyDirectory", " copyDirectory", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "srcFile": ["rcTime", "destDirectory", "sourceDir", "srcfile", "rcFiles", "supfile", "rcFile", " srcPlace", " srcDirectory", "destDir", "supStream", "supPath", "rcDir", "sourceDirectory", "srcPath", "ourceFile", "ourceTime", "rcStream", "rcPlace", "rcfile", "sourcePath", " srcDir", " srcFiles", " srcStream", "destTime", "sourcefile", "srcTime", " srcfile", " srcPath", " srcTime", "srcFiles", "srcDirectory", "ourcePath", "sourceFiles", "srcPlace", "rcPath", "rcDirectory", "srcDir", "ourcePlace", "srcStream", "sourceFile", "supFile"], "destFile": ["destDirectory", "endFile", "endFilename", "destfile", "stdfile", " destFilename", "stdFile", " destPath", "endTime", "tempFiles", "tempFile", "inationFile", "inationFiles", "sourceDirectory", "targetFilename", "vertFilename", "destFilename", "inationFilename", "DestFiles", "vertFile", "destPath", " destFiles", " destTime", " destDirectory", "targetFile", "targetTime", "destTime", "sourcefile", "tempfile", "vertPath", "endPath", "targetPath", "sourceTime", "stdDirectory", " destfile", "DestFile", "inationPath", "vertFiles", "DestPath", "tempPath", "sourceFile", "stdTime", "destFiles", "DestFilename", "Destfile"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "ac", "f", "ex", "i", "input", "socket", "inside", "serv", "image", "or", "read", "IN", "get", "m", "con", "win", "ini", "io", "up", "bin", "a", "isin", "base", "url", "b", "is", "nin", "min", "ins", "h", "cin", "In", "inc", "again", "rin", "kin", "pull", "r", "login", "id", "reader", "din"], "out": ["work", "cache", "output", "gin", "sync", "client", "net", "inner", "w", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "by", "writer", "other", "n", "io", "up", "bin", "base", "ext", "exec", "obj", "exp", "Out", "outs", "again", "off", "file", "err", "o", "user", "parent", "inc"], "buffer": ["source", "position", "result", "length", "memory", "buff", "buf", "bytes", "phrase", "input", "uffer", "border", "padding", "read", "data", "binary", "limit", "document", "base", "url", "b", "null", "server", "transfer", "address", "Buffer", "variable", "header", "channel", "size", "queue", "layer", "batch", "block", "iter", "reference", "pause", "wave", "feed", "slice", "reader", "flush", "offset"], "no": ["x", "nothing", " mo", "so", "was", " lo", "lo", "info", "nt", "i", "po", "to", "pos", "ko", "none", "nor", "data", "from", "maybe", "which", "nos", "io", "zero", "wa", "eno", "num", "NO", "os", "nr", "number", "na", "index", "size", "yes", " none", "mo", "only", "auto", "off", "ino", " NO", "o", "id", "type", "No", "error", " number", "co", "go"]}}
{"id1": "4501356", "id2": "4118412", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"calculateProfileDiffDigest": ["calculateProfilediffdigests", "calculateProfileDiffdigr", "calculateProfileDiffMDHash", "calculateProfileDiffCodests", "calculateProfilediffdigHash", "calculateProfilediffDigests", "calculateProfileDiffMDr", "calculateProfilediffdigr", "calculateProfileDiffCodest", "calculateProfileDiffdigests", "calculateProfileDiffCodr", "calculateProfileDiffMDest", "calculateProfileDiffMDests", "calculateProfileDiffDigr", "calculateProfilediffdigest", "calculateProfilediffDigr", "calculateProfileDiffDigests", "calculateProfilediffDigest", "calculateProfileDiffCodHash", "calculateProfilediffDigHash", "calculateProfileDiffdigest", "calculateProfileDiffdigHash", "calculateProfileDiffDigHash"], "profileDiff": ["picturediff", "settingsDiff", "messageDiff", " profilePath", "familyInf", " profileName", "stylediff", "profileName", "pictureInfo", "profilePath", "summaryDiff", "imageDelta", "profPath", "profdiff", "profileEdit", "styleInfo", "imageDust", "summaryEdit", " profileEdit", "pictureName", "familyInfo", " profileInfo", "profDiff", "settingsDelta", "profileInf", "settingsDust", "imageDiff", "messageInfo", "settingsDie", "familyDiff", "styleName", "styleDiff", "profInfo", "messagePath", "messagediff", "profileDust", "profilediff", "profileDelta", " profilediff", " profileDie", " profileInf", "summaryInfo", " profileDelta", "summaryInf", "profileDie", " profileDust", "pictureDiff", "profileInfo", "familyEdit", "imageDie"], "normaliseWhitespace": ["normaliseWpacesspace", "normaliseWhickspaced", "normaliseWhipsspace", "normaliseWpacespaced", "normaliseWhpacespaces", "normaliseWhitespaced", "normaliseWhickspace", "normaliseWhickspaces", "normaliseWhipspace", "normaliseWhpacesspace", "normaliseWhitespaces", "normaliseWhipespace", "normaliseWhitesSpace", "normaliseWhitesspace", "normaliseWpacesSpace", "normaliseWitespaces", "normaliseWhipespaces", "normaliseWhpacespaced", "normaliseWhipsSpace", "normaliseWhicksspace", "normaliseWhpaceSpace", "normaliseWhpacesSpace", "normaliseWhipspaces", "normaliseWitespace", "normaliseWhipesspace", "normaliseWitesSpace", "normaliseWhpacespace", "normaliseWhpacepace", "normaliseWpacespaces", "normaliseWhipespaced", "normaliseWitesspace", "normaliseWitespaced", "normaliseWhpacepaces", "normaliseWpacespace"], "md": ["me", "mand", "message", "mm", "mp", "amd", "f", "Cmd", "hash", "wd", "dig", "cmd", "dm", "ds", "mb", "meta", "mg", "sd", "m", "metadata", "mad", "mac", "bf", "editor", "rm", "b", "msg", "sha", "pd", "gd", " MD", "od", "dd", "mt", "hd", "cd", "MD", "mc", "df", "ma", "diff", "mag", "pm", "db", "d", "bd"]}}
{"id1": "6987642", "id2": "7761195", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"encodePassword": ["enressString", "encodeString", "enodePass", " encodeAuth", " enodePassword", "enodePassword", "enressAuth", "enodedPassword", "enressPassword", "enodeAuth", " enodeAuth", "encodeAuth", " encodePass", "enodedAuth", "enodedString", "enodedPass", " encodeString", " enodeString", "enodeString", "encodePass", " enodePass", "enressPass"], "password": ["p", "text", "secret", " passwords", "message", "words", "token", "out", "path", "username", "hash", "wd", "pass", "phrase", "word", "input", "pattern", "padding", "data", "auth", "PASS", "database", "name", "sword", "SHA", "code", "number", "address", "sha", "string", "Pass", "crypt", "prefix", "confirmed", "Password", "value", "user", " Password", "content"], "md": ["me", "mand", "hm", "mm", "mp", "mod", "amd", "Cmd", "hash", "dig", "cmd", "dm", "mb", "mg", "ind", "data", "m", "metadata", "mad", "ad", "mac", "grad", "rm", "sm", "ms", "vd", "nd", "sha", "pd", "gd", "dr", " MD", "od", "mn", "dd", "di", "mo", "ng", "mt", " Md", "hd", "am", "MD", "dh", "mc", "ma", "mag", "pm", "d", "bd"], "encodedPassword": ["encodedSecret", "encodeString", "encodingText", "encodedString", "enccodedpassword", "encodingPassword", "encryptedUser", "Enccodedpassword", "enodedPassword", "encodepassword", "encachedString", "encachedText", "EncodedPassword", "encryptedString", "encryptedSecret", "Encodedpassword", "enccodedUser", "enryptedString", "encodingSecret", "enodedString", "encryptedPassword", "EncodedUser", "EnccodedPassword", "encodeUser", "encodedUser", "enryptedPassword", "encryptedText", "enccodedString", "EncodedString", "enryptedSecret", "encodedText", "encodingString", "encachedSecret", "enryptedText", "EnccodedUser", "enodedSecret", "enccodedPassword", "encryptedpassword", "enodedText", "encodedpassword", "EnccodedString", "encachedPassword"]}}
{"id1": "293167", "id2": "14038176", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"doVersionCheck": [" doVersioncheck", "doVersionScan", "doFeatureScan", " doVersionScan", "doVersionUpdate", "doFeaturecheck", "doFeatureCheck", "doVersioncheck", "doChangeCheck", "doFeatureUpdate", "doversioncheck", " doversionCheck", " doversioncheck", "doversionScan", " doversionUpdate", "doChangeUpdate", " doVersionUpdate", "doChangecheck", "doversionCheck", "doChangeScan", " doversionScan", "doversionUpdate"], "view": ["video", "cache", "out", "session", "config", "head", "event", "vol", "image", "comment", "base", "display", "pool", "see", "div", "views", "fail", "can", "http", "group", "form", "im", "client", "check", "ve", "this", "model", "use", "show", "by", "object", "self", "up", "ou", "user", "edit", "style", "update", "View", "link", "e", "input", "screen", "box", "VIEW", "sel", "container", "gu", "block", "html", "value", "widget", "port", "cell", "page", "manager", "review", "window", "server", "change", "ui", "query", "body", "index", "vis", "list", "lock", "el", "full", "row", "layout", "v"], "url": ["ls", "source", "gl", "buffer", "uri", "browser", "length", "path", "Url", "download", "f", "bb", "link", "l", "socket", "image", "blog", "loader", "loc", "web", "resource", "open", "hub", "builder", "location", "email", "www", "base", "log", "name", "b", "null", "server", "host", "URL", "zip", "sl", "address", "string", "fr", "stream", "ul", "ll", "impl", "file", "bug", "ssl", "ob", "id", "rel", "http"], "in": ["source", "as", "init", "buffer", "inn", "out", "pin", "inner", "ac", "s", "input", "socket", "sin", "IN", "data", "m", "ini", "win", "con", "resource", "binary", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "again", "rin", "file", "err", "login", "reader", "bis", "din", "doc"], "bin": ["init", "buffer", "gin", "inn", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "ban", "IN", "abi", "loader", "ini", "win", "record", "con", "binary", "bot", "bi", "arin", "b", "vin", "bn", "fin", "nb", "is", "body", "lock", "cin", "lin", "spin", "ruby", "file", "lib", "oin", "login", "reader", "din", "run"], "line": ["text", "lf", "look", "Line", "lines", "str", "out", "parse", "pin", "cell", "page", "link", "e", "one", "word", "l", "val", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "base", "name", "log", "b", "lc", "job", "pe", "code", "ge", "zip", "letter", "sl", "string", "LINE", "el", "lin", "range", "cl", "ine", "block", "write", "file", "part", "row", "key", "entry", "end", "le", "unit", "type", "id", "user", "jo"], "version": ["secret", "python", "video", "position", "license", "cover", "feature", "update", "download", "date", "ver", "author", "model", "versions", "VERSION", "driver", "project", "image", "install", "release", "format", "latest", "vert", "name", "device", "null", "server", "host", "code", "beta", "string", "Version", "patch", "dev", "option", "plugin", "value", "bug", "pull", "support", "id", "unit", "type", "v", "section", "vision", "user"], "build": ["work", "make", "style", "clean", "load", "update", "home", "ver", "built", "info", "use", "lease", "link", "show", "how", "image", "install", "follow", "release", "Build", "builder", "help", "print", "valid", "job", "log", "add", "building", "uild", "hold", "post", "tag", "patch", "lock", "block", "mount", "bug", "pull", "row", "feed", "boot", "unit", "get", "run", "rel", "http"]}}
{"id1": "1954410", "id2": "5299276", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecutes", "doexecuteApply", "doexecuteutes", "submitExecApply", "doSendApply", "doSendRun", "submitexecuteutes", "doExecRun", "submitExecRun", "doExecutes", "submitexecuteRun", "submitexecuteApply", "doSendute", "doexecuteRun", "submitExecute", "doSendutes", "submitexecuteute", "doExecApply", "doexecuteute"], "mapping": ["fapper", "matching", "fapping", "minding", "aminding", "amapping", "amapper", "finding", "mapper", " mapper", " minding", " matching", "amatching", "fatching"], "form": ["flow", "method", "app", "FORM", "forms", "field", "Form", "config", "component", "page", "command", "control", "owner", "definition", "object", "format", "builder", "transform", "url", " forms", "formation", "post", "submit", "dom", "feed", "template", "xml", "pattern"], "request": ["message", "method", "create", "call", "Bytes", "result", "re", "uri", "json", "client", "current", "path", "hello", "session", "Accept", "instance", "frame", "Upload", "s", "this", "model", "use", "view", "HTTP", "input", "complete", "req", "data", "q", "object", "resource", "format", "QUEST", "self", "ware", "url", "name", "add", "server", "requ", "Response", "query", "address", "worker", "queue", "submit", "Reply", "_", "parent", "route", "pull", "reader", "user", "type", "xml", "Request", "report", "context", "application"], "response": ["message", "result", "output", "json", "client", "status", "model", "page", "view", " Response", " responses", "application", "resp", "data", "req", "object", "resource", "Resp", "server", "Response", "res", "handler", "v", "xml", "report", "reply"], "errors": [" status", " flashes", " payload", " translations", " Messages", " session", " commands", " logger", " error", " this", " responses", " warnings", " changes", " replies", " management", " managers", "mess", " acc", " updates", " mess", " messages", " messaging", " problems", " calls", " messenger", " failures", " events", " logs", " streams"], "isMultipart": ["isMultipparts", "isMultippedost", "isMultIPound", "isMultompost", "isMultipost", "isMultipound", "isMultompPart", "isMultipage", "isMultiipound", "isMultIPPart", "isMultompound", "isMultitage", "isMultiipPart", "isMultippart", "isMultIPart", "isMultiIPart", "isMultiated", "isMultippedound", "isMultompart", "isMultiparts", "isMultiipart", "isMultippated", "isMultitart", "isMultiIPost", "isMultippedart", "isMultiIPPart", "isMultIPost", "isMultitarts", "isMultipPart", "isMultippedPart", "isMultiarts", "isMultitated", "isMultippage", "isMultiIPound", "isMultiipost", "isMultiage", "isMultiart", "isMultipated"], "mailInstance": ["fileManager", "fileinstance", "fileInstance", "mailUsage", "emailinstance", " emailinstance", " mailUsage", "emailInstance", "fileUsage", " emailInstance", "mailinstance", " emailUsage", "mailInst", "emailManager", " emailInst", " mailInst", " mailinstance", "mailManager", "emailInst", " mailManager", "fileInst"], "fields": ["types", "parts", "rules", "holders", "locks", "words", "lines", "forms", "field", "lists", "keys", "forces", "s", "groups", "input", "services", "atts", "dates", "data", "gets", "strings", "checks", "cells", "flows", "archives", "objects", "qs", "boxes", "params", "ments", "files", "facts", "utils", "members", "features", "states", "links", "acks", "models", "tags", "pages", "uploads", "views", "details", "loads", "plugins", "packs", "users", "properties", "headers", "changes", "maps", "classes", "comments", "events", "ids", "rows", "posts"], "attachments": ["Attachments", "payments", "attachers", "Attachees", "extions", "exters", "attions", "attees", "attachresses", "attps", "attachlements", "payment", "achresses", "Attachps", "Attachlements", "suppees", "achments", "attachps", "attments", "attachment", " attachment", " attachparts", "attachparts", "attachions", "attment", "Attachions", "extps", "achparts", "atters", "attlements", "achment", "supplements", "payparts", "payresses", "Attachers", "extments", "suppment", "suppments", " attachresses", "attachees", "Attachment"], "items": ["types", "parts", "apps", "locks", "lines", "orders", "lists", "Items", "keys", "ips", "its", "ers", "groups", "data", "names", "objects", "apters", "qs", "files", "reports", "list", "ins", "links", "models", "pages", "plugins", "es", "results", "children", "events", "ids", "alls", "rows", "phones", "ops"], "iter": ["itter", "edit", "inner", "finder", "ver", "ite", "ter", "page", "event", "master", "cher", "i", "keep", "enter", "skip", "upper", "gener", "loc", "ner", "walker", "ir", "ip", "Iterator", "it", "izer", "outer", "Iter", "zip", "altern", "ator", "li", "list", "exp", "former", "chain", "coll", "el", "ul", "inc", "file", "loop", "err", "er", "ser", "end", "reader", "inter", "slice", "iterator", "oper", "order", "http"], "item": ["source", "current", "instance", "event", "extra", "image", "val", "ip", "url", "base", "name", "post", "Item", "li", "temp", "slice", "entry", "type", "section", "volume", "result", "token", "load", "info", "all", "i", "area", "or", "data", "example", "object", "other", "up", "original", "obj", "entity", "api", "layer", "coll", "plugin", "art", "site", "user", "order", "update", "hop", "atom", "issue", "folder", "resource", "next", "container", "element", "attribute", "more", "reader", "get", "app", "widget", "album", "inner", "page", "complete", "anything", "service", "missing", "storage", "it", "server", "index", "handler", "full", "file", "custom", "er"], "aux": ["offs", " auxiliary", "uc", "ups", "uf", "frac", "union", "alias", "buf", "aus", "extra", "etc", " Aux", "data", "des", "ux", "aff", "strings", "amp", "af", "ras", "cas", "ru", "sup", "aw", "array", "lc", "asc", "ext", "ou", "ants", "sub", "lang", "imp", "prefix", "axe", "aos", "fax", "auc", "ox", "off", "abs", "anc", "au", "pkg", "packages", "cmp", "abc", "except"], "part": ["p", "pre", "group", "parts", " Part", "ref", "field", "instance", "f", "point", "info", "back", "component", "per", "one", "word", "po", "l", "pos", "area", "joined", "val", "data", "PART", "object", "format", "act", "on", "action", "and", "class", "error", "base", "name", "b", "add", "change", "fact", "obj", "player", "pi", "ch", "connection", "list", "patch", "but", "layer", "comp", "element", "full", "plugin", "block", "html", "Part", "file", "start", "step", "partial", "key", "art", "diff", "join", "id", "type", "parent", "section", "user", "co", "no", "pair"], "baos": ["BAo", "baoss", "baOs", "baot", "paot", "baoS", "abaosi", " baoS", "BAis", "Bao", " baoss", "baosh", "boOS", "pao", "boo", "BAOs", "BAoss", "haos", "BaOs", " bao", "baOS", "bois", "paOS", "Baos", "BAoS", "Baosi", "abais", "abaOs", " baOS", "BaoS", "bais", "hao", "boosh", "hais", "abaos", "BAosi", "baosi", " bais", "boos", "Bais", "pais", "boot", "bao", "BAos", "paos", "paosh", " baot", "BAosh", "haoss"], "body": ["text", "source", "message", "parts", "media", "summary", "output", "port", "json", "length", "fee", "translation", "flash", "Body", "state", "pass", "options", "tree", "data", "object", "resource", "binary", "comment", "description", "shell", "document", "url", "name", "b", "null", "params", "zip", "query", "string", "header", "connection", "size", "full", "html", "value", "headers", "template", "end", "type", "common", "content", "reply"], "preferencesInstance": ["preffeesinstance", "prefeesinstance", "prefiesinstance", "preffeesClient", "prefirmsClient", "preferencesClient", "prefirmsInstance", "prefeesClient", "prefiesClient", "prefiesInstance", "prefeesInstance", "preffeesInstance", "preferencesinstance", "prefferencesClient", "prefirmsinstance", "prefferencesInstance", "prefferencesinstance"]}}
{"id1": "13499897", "id2": "3024970", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "label": 1, "substitutes": {"CopyFile": [" CopyFolder", " copyFile", " copyDir", " copyFolder", "CreateFolder", "CopyFolder", "CreateFile", " Copyfile", "Copyfile", " copyfile", "CreateDir", "Createfile", " CopyDir", "CopyDir"], "sourcefile": ["configstream", "destlog", "Sourcefilename", "sourcef", "sourcelog", "Sourcef", "sinfile", "configfile", "configlog", "destFile", "destf", " sourcefilename", "sinFile", "SourceFile", "destfilename", " sourcef", "configFile", " sourceFile", "sourcestream", "sinstream", "sinlog", "sourcefilename", "sourceFile", "deststream", "Sourcefile"], "destfile": [" destfilename", "Destfilename", "destroypath", "srcfile", "tempfilename", "srcFile", "Destpath", "targetfile", "Destfp", "destpath", "srcpath", "tempFile", "targetfilename", " destpath", " deststring", "newfile", "destfp", "targeturl", " destfp", "destroyfile", "deststring", "sourcestring", "destroystream", "buildfile", "destroyfilename", "Desturl", "destFile", "targetpath", "targetFile", "newfp", " desturl", "srcfilename", "tempfile", " destFile", "srcstream", "destfilename", "buildstring", "DestFile", "sourcepath", "newFile", "temppath", "buildFile", "sourcefilename", "buildfilename", "sourceFile", "desturl", "deststream", "tempstream", "Destfile", "newfilename"], "last": ["right", "style", "current", "depth", "se", "length", "path", "first", "empty", "cat", "recent", "event", "use", "ast", "real", "max", "count", "or", "left", "total", "from", "latest", "old", "prev", "later", "core", "next", "base", "code", "nd", "child", "cur", "size", "range", "Last", "full", "value", "route", "part", "key", " Last", "end", "after", "start", "ending", "offset"], "parent": ["p", "text", "source", "filename", "remote", "cache", "current", "port", "ppa", "path", "ac", "home", "point", "root", "pointer", "po", "line", "shared", "loc", "data", "parents", "location", "mac", "ip", "dest", "valid", "and", "next", "url", "base", "name", "pa", "null", "search", "post", "function", "child", "api", "string", "exp", "patch", "ant", "test", "Parent", "file", "temp", "anc", "part", "partial", "key", "id", "unit", "fat", "section", "target", "content"], "f": ["p", "lf", "F", "flat", "ref", "of", "fp", "cf", "c", "s", "fb", "e", "i", "l", "found", "m", "folder", "af", "self", "g", "base", "inf", "b", "fd", "fs", "fe", "j", "h", "fa", "full", "fc", "file", "df", "t", "feed", "dir", "sf", "r", "o", "v", "d"], "srcChannel": ["destConnection", "destchannel", "rcChan", "rcchannel", "sourceConnection", "destClient", "destChannel", "sourceChan", "srcchannel", " srcChan", "rcClient", " srcchannel", "sourceChannel", "srcConnection", " srcConnection", "rcConnection", "srcChan", " srcClient", "sourcechannel", "rcChannel", "srcClient", "destChan"], "dstChannel": ["idstChannel", "DstBuffer", "destchannel", "dstChan", "dsrcButton", "DestChan", "dntBuffer", "destChannel", "dstsChannel", "dsrcChannel", "dsrcChan", "dstButton", "dstschannel", "dstContext", "DestBuffer", "dstsChan", "DstChannel", "destContext", "drcchannel", "drcChan", "idrcChan", "ddestChannel", "dntChannel", "DstChan", "dntContext", "ddestContext", "idrcButton", "idstChan", "dsrcchannel", "destButton", "DestContext", "idstButton", "Dstchannel", "idrcchannel", "drcButton", "DstContext", "destBuffer", "idstchannel", "idrcChannel", "dstchannel", "dntChan", "ddestChan", "destChan", "dstBuffer", "ddestBuffer", "DestChannel", "Destchannel", "drcChannel"]}}
{"id1": "2324868", "id2": "14093044", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["actionOccuted", "actionCalled", "actionExecuted", "actionPeralled", "actionExecalled", " actionPeruted", " actionExecuted", "actionExecressed", " actionExecformed", " actionExecressed", "actionCuted", "actionPerressed", " actionExecalled", " actionPeralled", "actionExecformed", "actionOccalled", "actionOccressed", "actionPeruted", " actionPerressed", "actionCformed", "actionOccformed", "actionCressed"], "e": ["x", "me", "se", "c", "f", "event", "de", "exc", "et", "an", "E", "q", "ec", "self", "g", "a", "name", "te", "ee", "ae", "es", "ev", "t", "ctx", "v", "events", "type", "ception"], "delim": ["selam", "delcm", " delimmer", " delcm", "elim", "delam", "selim", "Delem", "selm", " delam", "selem", "flimmer", "delimmer", "Delcm", "flim", "delem", "Delam", "flcm", "flam", "Delimmer", "elem", "Delm", "elam", "Delim", "delm", "elm"], "r": ["p", "kr", "rx", "re", "br", "c", "f", "rr", "w", "rar", "i", "l", "writer", "rs", "ir", "ws", "sr", "ru", "n", "ar", "hr", "adr", "R", "cr", "rl", "res", "rss", "rb", "dr", "rc", "fr", "rw", "pr", "lr", "iter", "rt", "tr", "err", "er", "reader", "rh", "nr"], "line": ["text", "source", "lf", "look", "style", "Line", "re", "lines", "str", "cell", "page", "pass", "link", "one", "word", "l", "inline", "val", "data", "nl", "comment", "job", "name", "log", "col", "pe", "lc", "code", "sel", "rl", "number", "split", "sl", "time", "string", "rule", "header", "LINE", "el", "lin", "cl", "block", "value", "file", "row", "response", "key", "entry", "id", "reader", "end", "le", "feed", "fin", "no"], "url": ["ls", "org", "uri", "client", "path", "Url", "f", "link", "l", "loc", "blog", "web", "nl", "resource", "sr", "www", "base", "log", "server", "host", "URL", "rl", "fl", "sl", "connection", "string", "fr", "ur", "lr", "file", "pull", "ssl", "err", "ob", "jar", "http"], "conn": ["p", "fp", "out", "sync", "cf", "ctrl", "client", "cb", "c", "f", "dc", "Connection", "w", "nt", "l", "socket", "Conn", "loc", "con", "open", "pub", "n", "io", "connect", "ann", "conv", "cr", "ch", "gr", "api", "rc", "cur", "connection", "nc", "lock", "cp", "rn", "enc", "coll", "pr", "cl", "cm", "sql", "cn", "rt", "ssl", "err", "ct", "ctx", "db", "co", "http"], "wr": ["wer", "wy", "kr", "Wr", "rx", "out", "wk", "wd", "rr", "w", "wt", "mr", "vr", "rar", "war", "riter", "writer", "rs", "sr", "Writer", "wa", "wx", "hr", "fw", "cr", "res", "gr", "rss", "dr", "rb", "wh", "fr", "rw", "shr", "wrap", "WR", "pr", "write", "nw", "wm", "rt", "err", "wb", "wave", "wl", "RW", "rh", "nr", "wal", "ew"], "tokens": ["pargen", "Tokoks", "tokenens", "takos", "targens", "Taken", "itokenets", "token", "targelines", "tokenets", "Tokens", "pargens", "takets", "takelines", "tkicks", "takens", "takoks", "targen", "toyen", "tokos", "tokoks", "tokets", "Takicks", "Takens", "torkicks", "Tokicks", "pargets", "itokenos", "toyets", "tokenos", "tokicks", "Token", "tkens", "pokets", "torken", "targets", "toyens", "itokens", "tkoks", "torkens", "tken", "itoken", "takicks", "tOKelines", "tokelines", "tOKen", "tokenen", "poken", "tOKens", "torkoks", "pargelines", "itokenens", "toyos", "itokenen", "taken", "pokelines", "itokets", "Takoks", "itokos", "tOKets", "pokens"], "in": ["init", "ln", "inn", "str", "out", "gin", "pin", "inner", "ina", "i", "input", "inas", "sin", "IN", "data", "ini", "win", "con", "n", "isin", "bin", "arin", "io", "vin", "it", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "kin", "pull", "err", "oin", "reader", "zin", "din", "tin", "ic"]}}
{"id1": "1769771", "id2": "9261777", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyChannel", "copyfile", "CopyChannel", "copyFiles", "CopyFile", "copyChannel", "transferfile", "transferFile", "transferChannel", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "in": ["work", "source", "inn", "pin", "inner", "c", "f", "config", "ex", "i", "input", "l", "image", "IN", "data", "m", "win", "io", "bin", "url", "base", "name", "query", "min", "index", "ins", "lock", "lin", "In", "again", "file", "login", "id", "reader", "diff", "inc"], "out": ["p", "x", "dot", "call", "cache", "output", "c", "point", "extra", "w", "ex", "OUT", "conn", "image", "default", "writer", "resource", "io", "n", "up", "base", "name", "b", "ext", "server", "exec", "string", "external", "plain", "prefix", "Out", "write", "outs", "again", "off", "file", "o", "user", "v", "target"], "inChannel": ["insChannel", "Inchannel", "outchannel", "inClient", "inChan", "InClient", "insClient", "InChan", " inchannel", "inputChan", "inputChannel", "INChannel", "INChan", "INStream", "binClient", "winChan", "binChannel", "winChannel", "InStream", "binchannel", "outClient", "inputchannel", " inChan", " inClient", "InChannel", "inchannel", "insChan", " inStream", "insStream", "winchannel", "inputStream", "outChan", "outStream", "winStream", "binChan", "INchannel", "inStream", "binStream"], "outChannel": [" outCh", "outchannel", "OutChan", "inChan", " outStream", "inputChan", "inputChannel", "outCh", "outputchannel", "nChannel", "nChan", "outController", "outputController", "outManager", "Outchannel", "inputController", "inConnection", "inManager", "outConnection", "inController", "inCh", "outputCh", " outChan", " outchannel", "outputStream", "nStream", "inchannel", " outManager", "outputChannel", "OutConnection", "outChan", "outStream", " outConnection", "outputChan", "nManager", "OutChannel", "inStream", "inputchannel"]}}
{"id1": "19934218", "id2": "23335922", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"doCrypt": [" runMac", " runExt", "murDec", " doDec", "murExt", "DoMac", "DoCrypt", "murMac", " doMac", "murCrypt", "DoDec", " doExt", "DoExt", " runDec", " runCrypt"], "text": [" TEXT", "source", "message", "secret", "buffer", "token", "str", " Text", "length", "path", "config", "this", "font", "seed", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "context", "format", "binary", "editor", "class", "url", "name", "ext", "Text", "obj", "password", "code", "letter", "hex", "string", "connection", "struct", "crypt", "value", "key", "EXT", "contract", "pattern", "content"], "UnsupportedEncodingException": ["UnsupportedEncodedEx", "UnsupportedEncoderError", "UnsupportedEncoderException", "UnsupportedEncodingEx", "UnsupportedEncodingError", "UnsupportedEncasingException", "UnsupportedEncodedError", "UnsupportedEncasingError", "UnsupportedEncodedException", "UnsupportedEncasingEx", "UnsupportedEncoderEx"], "md": ["me", "message", "method", "mand", "hm", "mode", "mm", "mp", "mod", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", "mb", "meta", "mg", "sd", "data", "m", "map", "nm", "ad", "mad", "metadata", "mac", "bf", "valid", "rm", "ud", "ms", "vd", "code", "pd", "sha", "body", "gd", "dr", " MD", "ld", "mn", "dd", "od", "mo", "bm", "mt", " Md", "hd", "am", "def", "MD", "mc", "ma", "df", "mag", "pm", "d", "bd"], "sha1hash": ["SHA1hex", "sha5hex", "md6h", "md1sha", "SHA1sum", "sha6hash", "md6sha", "shaonesha", "sha1hex", "sha0hex", "sha2sha", "sha1sha", "SHA2h", "sha6h", "sha5sha", "sha5Hash", "SHA2sha", "SHA1sha", "md1hash", "SHA2hex", "sha256hex", "sha6sha", "sha2h", "sha2Hash", "sha1Hash", "sha256sum", "sha2hash", "sha256sha", "SHA1h", "md1h", "sha5hash", "sha5h", "sha256Hash", "SHA2hash", "sha6hex", "SHA1Hash", "sha2hex", "sha2sum", "SHA1hash", "shaonehash", "sha1h", "sha0sha", "md1hex", "sha1sum", "sha0sum", "shaoneh", "shaonehex", "SHA2sum", "md6hash", "sha256h", "sha256hash", "SHA2Hash", "sha0hash", "md6hex"]}}
{"id1": "19050432", "id2": "13852596", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openParamingresource", "openNamedResources", "openNnamedResources", "openNamingResources", "openNestedresource", "openNamingresource", "openParamedResources", "openParamingResources", "openNestedResource", "openParamingURI", "openNamingURI", "openParamingResource", "openNnamedResource", "openParamedresource", "openNamedresource", "openNamingResource", "openNnamedresource", "openNnamedURI", "openNamedURI", "openNestedURI", "openParamedURI", "openParamedResource", "openNestedResources"], "name": ["source", "filename", "uri", "str", "path", "username", "ame", "NAME", "info", "word", "Name", "data", "names", "definition", "resource", "old", "n", "class", "url", "base", "address", "string", "size", "prefix", "full", "named", "file", "value", "version", "part", "key", "sea", "id", "type", "parent"], "in": ["source", "as", "result", "rec", "inn", "gin", "out", "token", "pin", "inner", "ac", "f", " out", "i", "input", "socket", "conn", "val", "get", "IN", "data", "con", "win", "resource", "ini", "url", "din", "pc", "b", "vin", "nin", "ins", "connection", "cin", "thin", "In", "fc", "inc", "again", "rin", "kin", "r", "oin", "login", "err", "reader", "edIn", "bin", "ic"], "propsURL": ["proopsLL", " propsUR", "proportsELF", "proppsUR", "prosUL", " propsSSL", "prorsUrl", "prorsurl", "propsCL", "prodsUrl", "proportsUL", " propsLL", "perrsurl", " propsUrl", "prosUrl", "propsLL", "propsUrl", " propsUL", "prosSSL", " prodsURI", "proopsURI", "PropsSSL", "probsURL", "proopsUrl", "probsLL", "procsSSL", " prodsURL", "procsURL", "prodsLL", "pronsURL", "protsURL", "protsurl", "prosLL", "perrsFile", " propsELF", " prolsSSL", "propdsUR", "prodsCL", "propsSSL", " prolsurl", "proopsUR", " propsurl", " prodsurl", "prodsSSL", "prosURL", "propdsUrl", "prodsURI", " propsCL", "prodsURL", "prodsFile", "progsURI", "ProsURI", " proportsUR", "protsFile", "proppsURL", "proppsLL", "prolsurl", "perpsURL", "propsELF", "prolsSSL", "PropsUrl", "probsUL", "prorsFile", "procsurl", "probsUrl", " proportsLL", " proportsUrl", " propsURI", "perpsFile", "propdsURL", " prodsCL", " proportsUL", "perrsURL", "prolsURI", "propsUR", "proportsURL", "propsUL", "prodsurl", "ProsSSL", "prorsELF", "proportsurl", "PropsURL", "propsFile", "propdsLL", "proportsUR", "pronsUrl", "propsurl", "procsURI", "proopsURL", "ProsURL", "proopsurl", "progsURL", "progsurl", "procsUrl", " prolsURL", "progsCL", "prodsUR", "proportsLL", " prolsURI", "prosURI", "proportsSSL", "prorsURL", "pronsLL", "proppsUrl", "propsURI", "proportsUrl", "proopsELF", "PropsURI", "proportsURI", "pronsUR", "prolsURL", " proportsURL", " proportsELF", "proopsCL", "ProsUrl", "perpsurl", "prorsUR"], "urlConn": ["httpconn", "URLConnect", "httpContext", "sslconn", "sslCod", "urlContext", "sslConn", "fileConn", "httpConnect", "urlCod", "sslCond", "URLConn", "URLContext", "httpCod", " urlCond", "urlconn", " urlConnect", "URLConf", "urlCond", "fileConnect", "httpConn", "urlCmd", "urlConnect", "sslCmd", " urlContext", " urlConf", "fileCond", "fileCmd", "sslConnect", " urlCmd", "urlConf", " urlconn", "httpConf", " urlCod"], "httpURL": ["httpsURI", "apiUR", "HttpUrl", "HttpURI", "autoUrl", "httpURI", "httpsUR", "httpsUrl", "apiML", "HttpURL", "httpSSL", " httpurl", " httpSSL", " httpML", "httpUrl", "apiURL", "httpsURL", "httpsurl", "httpurl", "httpsSSL", "HttpUR", " httpUR", "autoURL", "autoSSL", "apiUrl", "httpUR", " httpUrl", " httpURI", "autourl", "HttpML", "httpML"], "hdrVal": [" hheaderVal", "hrStr", "hhrval", "HhrVal", "hdValues", "Hhrval", "hreqStr", "hdrValues", "hrVol", "hDRval", "hndValue", "hdrVol", "hreqVal", " hdrStr", "HdrBu", "hdValue", "HdrValues", "hndBu", " hheaderVol", "HdrDef", "hdval", "hDRValue", "hhrDef", "hhrVal", "hrValue", "HhrBu", "hrcVal", "hrVal", "HhrValues", "Hdrval", "hrcValue", "hhrValues", "hhrValue", "hdVal", "hreqValue", "hheaderVal", " hheaderStr", "hheaderStr", "hndDef", "HhrDef", "hheaderValue", "HdrValue", "hdrDef", "HdrVal", "hDRValues", "hDRVal", "hdrStr", "hrcBu", "hndVal", " hheaderValue", "HhrValue", " hdrVol", " hdrValue", "hrcDef", "hdrval", "hreqVol", "hdrValue", "hheaderVol", "hhrBu", "hdrBu"], "code": ["text", "message", "result", "mode", "ode", "check", "c", "cat", "info", "status", "charge", "state", "success", "e", "one", "level", "ie", "count", "line", "data", "const", "age", "ce", "comment", "ec", "expected", "core", "class", "no", "url", "pc", "reason", "pe", "ge", "zip", "number", "grade", "msg", "Code", "index", "see", "ack", "cc", "category", "rule", "rc", "header", "string", "codes", "fail", "score", "test", "desc", "cod", "value", "version", "xx", "key", "response", "id", "rate", "type", "zone", "error", "co", "go", "content", "coded"]}}
{"id1": "1133123", "id2": "7458833", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"openConnection": ["createChannel", "closeConn", "openConnector", "OpenConnect", "closeConnect", "createConnector", "OpenConnector", "OpenConn", "closeConnector", "openChannel", "openConnect", "OpenChannel", "closeChannel", "createConnect", "createConn", "OpenConnection", "createConnection", "openConn", "closeConnection"], "url": ["source", "buffer", "uri", "str", "path", "Url", "config", "f", "this", "link", "options", "l", "image", "loc", "data", "service", "object", "location", "resource", "proxy", "limit", "base", "name", "log", "bel", "null", "server", "host", "URL", "address", "sl", "connection", "channel", "el", "ll", "iter", "file", "ssl", "id", "http"]}}
{"id1": "6966398", "id2": "14877116", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 1, "substitutes": {"reader": ["p", "source", "buffer", "se", "client", "reading", "ry", "load", "instance", "rake", "config", "rr", "driver", "per", "ler", "rar", "input", "manager", "k", "or", "read", "loader", "writer", "ner", "oder", "resource", "builder", "df", "io", "pe", "server", "book", "reads", "rc", "dr", "connection", "rw", "handler", "stream", "cer", "parser", "Reader", "iter", "file", "row", "r", "er", "pp", "keeper", "feed", "her", "o", "ri", "cms", "raf", "context"], "ks": ["ls", "inks", "powers", "cs", "ps", "ss", "se", "kies", "ku", "ips", "keys", "KS", "DS", "ko", "k", "ds", "hs", "ans", "books", "acs", "gets", "kb", "rs", "checks", "vs", "ges", "ke", "opens", "kes", "works", "ms", "qs", "orks", "cks", "fs", "acts", "bs", "reads", "icks", "ki", "sk", "acks", "akes", "ches", "ics", "ns", "es", "CS", "ck", "ctx", "co", "rows", "ops"], "key": ["p", "secret", "char", "cache", "client", "ring", "c", "keys", "point", "state", "court", "seed", "ca", "k", "read", "service", "pg", "ce", "ke", "io", "base", "pe", "server", "code", "transfer", "ki", "lock", "ee", "trust", "value", "file", "sign", "ssl", "type", "user", "co", "Key", "pair"], "chain": ["sequence", "secret", "chains", "cache", "table", "set", "path", "c", "config", "store", "family", "root", "image", "none", "box", "object", "wheel", "base", "code", "Chain", "cr", "container", "list", "rule", "stack", "lock", "crypt", "wrap", "enc", "coll", "range", "scale", "block", "collection", "file", "mc", "slice", "network", "circle", "pair"], "os": ["p", "OS", "ps", "ot", "oss", "bos", "s", "options", "pos", "ds", " o", "iso", "object", "rs", "ol", "opens", "io", "ros", "ms", "ou", "los", "cos", "is", "fs", "res", "rss", "oid", "ios", "aos", "outs", "es", "op", "Os", "o", "osi", "ob", " bos", "oses", "ops"], "stamper": ["stammper", "spAMler", " nostampper", "spAMpe", "stAMler", "spAMper", "streampe", "stameper", "path", "stammpper", "stameple", "stammler", "this", "s", "spammer", "streamper", " nostameple", "starmler", "stample", "stammer", "streammer", "data", "stamepper", "stammmer", "starmper", "g", " nostample", "stammple", "stAMpe", " nostamper", " nostamler", "function", "starmpper", "stAMmer", "stAMper", "stameler", " nostamepper", "starmple", "spampe", "spamper", "stampe", "spamler", "_", "streamler", "stampper", " nostameper", "stammpe", "stamler", "spAMmer", " nostameler"], "appearance": [" applier", "askence", "installasion", "signearance", "formearance", "appfacing", "suppearing", "ppaser", "suppointment", "byearance", " appeared", "ppearance", "ppasion", "signearing", " appear", " appence", "suppearance", "byearing", "ppear", "feedointment", "formismo", " appismo", "signears", "Appearance", "appaser", " appaser", "appearing", "applier", " appearing", "appear", "attearance", "formearing", "askearance", "appence", "appismo", "byismo", " appfacing", "appasion", "formear", "byear", "signointment", "appeared", "signear", " appears", "appears", "suppasion", "atteared", "formaser", "installear", "ppearing", "feedfacing", "signfacing", "attfacing", "feedear", "Appearing", "attence", "askeared", "signlier", "appointment", "suppear", "installearing", "suppfacing", "Appears", "installearance", "Applier", "feedearance", "askfacing"]}}
{"id1": "838844", "id2": "19206412", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["oconverted", "subversion", "unverted", "unversion", "converted", "CONverted", " deconverted", "subverted", "Convert", "CONception", "unception", "subvert", " deconversion", "Conversion", "CONvert", "oconverting", "Converting", "Converted", "Conception", "CONverting", "conception", "conversion", "oconvert", "subverting", "converting", " deconverting", "unvert", "oconversion", " deconvert", "CONversion"], "src": ["attr", "source", "ref", "filename", "video", "sb", "fp", "uri", "secure", "st", "path", "username", "feat", "load", "download", "config", "s", "back", "buf", "component", "gz", "input", "ource", "inst", "sin", "loc", "RC", "req", "Source", "sys", "prot", "resource", "img", "storage", "sth", "url", "tmp", "name", "stage", "proc", "spec", "code", "obj", "sel", "sc", "rl", "sit", "supp", "scene", "SourceFile", "rc", "upload", "string", "fn", "rb", "gb", "dist", "stream", "cpp", "impl", "sn", "file", "Dest", "ssl", "slice", "href", "reader", "ctx", "cb", "cmp"], "dest": ["disk", "source", "path", " destination", "home", "txt", "img", "class", "tmp", "null", "cont", "obj", "dist", "dat", "fn", "di", "orig", "test", "std", "temp", "lib", "Dest", "dir", "bin", " dst", "target", "dc"], "in": ["source", "as", "ps", "inn", "pin", "f", "pass", "ex", "i", "input", "inas", "val", "IN", "data", "ini", "win", "n", "up", "isin", "a", "io", "inf", "din", "is", "ins", "stream", "In", "inc", "file", "r", "t", "err", "login", "reader", "bin", "d", "doc"], "p": ["lp", "pre", "tp", "ps", "fp", "py", "c", "f", "np", "s", "wp", "per", "i", "e", "pb", "po", "l", "bp", "m", "pg", "cop", "pa", "g", "v", "pc", "b", "pe", "pd", "pi", "sp", "j", "h", "cp", "pr", "jp", "parser", "part", "t", "pp", "op", "r", "o", "pm", "d", "P"], "ds": ["ts", "ups", "s", "DS", "hs", "ans", "ipes", "ded", "dds", "ins", "xs", "ns", "d", "ays", "dos", "ps", "words", "sync", "styles", "ys", "groups", "data", "da", "des", "rs", "ths", " ps", "os", "utils", "pd", "icks", "dist", "els", "models", "points", "sts", "scripts", "plugins", "js", "db", "cons", "posts", "ls", "parts", "tools", "cs", "ss", "lines", "dm", "vals", "sys", "ges", "ks", "qs", "docs", "ants", "bs", "nas", "amps", "Ds", "di", "dd", " props", "gs", "ads", "ils", " sd", "lp", "uds", "tests", "eps", "services", "dates", "dl", "vs", "dt", "dat", "gd", "ld", " DS", "dp", "df", "obs", "dc"], "format": ["source", "nat", "form", "style", "filename", "fp", "table", "path", "language", "feat", "frame", "config", "f", "at", "model", "data", "magic", "record", "act", "class", "url", "name", "spec", "Format", "host", "fd", "function", "letter", "api", "tag", "string", "struct", "sche", "fn", "prefix", "handler", "plugin", "scale", "filter", "parser", "file", "version", "part", "t", "template", "atter", "layout", "unit", "type", "ant", "pattern"], "hasPixelData": ["hasPixelSize", "haspixeldata", "hasByteData", "haspixelData", "hasByteStyle", "showsByteDATA", "hasPictureSize", "hasPixelStyle", "hasPixelDATA", "haspixelSize", "showsPixelDATA", "hasPictureData", "showsPixelData", "hasBytedata", "showsPixeldata", " hasPixelSize", "showsPixelStyle", "hasPixeldata", "hasByteSize", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPicturedata", " hasPixeldata", "showsByteData"], "inflate": ["infloated", "infolode", "insvenode", "insflode", "infface", "inFlation", "insvenATE", "insvenating", "invenating", "inadequode", "inadequATE", "insflATE", "Inflation", "infloation", "invenATE", "insflate", "infolate", "inflode", "inflATE", "invenate", "invenode", "inflace", "Inflate", "inFlace", "inadequating", "inadequate", "inFlate", "InFlate", "infolATE", "infolating", "InFlace", "inffated", "insflating", "inFlated", "infloace", "infloate", "inflated", "inflation", "InFlated", "inffate", "inflating", "inffation", "insvenate", "InFlation", "Inflated", "Inflace"], "pxlen": ["pcln", "xplength", "pglen", "txln", "pnglen", "fxpos", "fxlen", "mxpos", "xpcount", "pxlength", "mxdata", "pxln", "pxpos", "ppl", "campos", "mxlen", "txlen", "fxdata", "pxcount", "mxlength", "axlon", "pclin", "pgLen", "txlin", "xplen", "axlen", "axlin", "pxlin", "mxsize", "pxdata", "pxlon", "pclen", "axln", "pgden", "mxln", "pxsize", "pngsize", "camdata", "txlon", "pnglength", "pngcount", "camlen", "ppLen", "fxLen", "xpsize", "mxcount", "fxln", "camln", "fxl", "pxLen", "pplen", "pgl", "pclon", "pxl", "ppden", "pxden", "fxden"], "out": ["work", "group", "copy", "cache", "output", "re", "session", "point", "pad", "store", "page", "state", "dump", "OUT", "conn", "line", "sys", "io", "up", "v", "log", "server", "gen", "obj", "post", "query", "list", "lock", "Out", "outs", "again", "lib", "step", "cli", "err", "inter", "user", "parent", "error", "co"]}}
{"id1": "19050432", "id2": "6457199", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openParamingresource", "openNamedResources", "openNnamedResources", "openNamingResources", "openNestedresource", "openNamingresource", "openParamedResources", "openParamingResources", "openNestedResource", "openParamingURI", "openNamingURI", "openParamingResource", "openNnamedResource", "openParamedresource", "openNamedresource", "openNamingResource", "openNnamedresource", "openNnamedURI", "openNamedURI", "openNestedURI", "openParamedURI", "openParamedResource", "openNestedResources"], "name": ["source", "filename", "uri", "str", "path", "username", "ame", "NAME", "info", "word", "Name", "data", "names", "definition", "resource", "old", "n", "class", "url", "base", "address", "string", "size", "prefix", "full", "named", "file", "value", "version", "part", "key", "sea", "id", "type", "parent"], "in": ["source", "as", "result", "rec", "inn", "gin", "out", "token", "pin", "inner", "ac", "f", " out", "i", "input", "socket", "conn", "val", "get", "IN", "data", "con", "win", "resource", "ini", "url", "din", "pc", "b", "vin", "nin", "ins", "connection", "cin", "thin", "In", "fc", "inc", "again", "rin", "kin", "r", "oin", "login", "err", "reader", "edIn", "bin", "ic"], "propsURL": ["proopsLL", " propsUR", "proportsELF", "proppsUR", "prosUL", " propsSSL", "prorsUrl", "prorsurl", "propsCL", "prodsUrl", "proportsUL", " propsLL", "perrsurl", " propsUrl", "prosUrl", "propsLL", "propsUrl", " propsUL", "prosSSL", " prodsURI", "proopsURI", "PropsSSL", "probsURL", "proopsUrl", "probsLL", "procsSSL", " prodsURL", "procsURL", "prodsLL", "pronsURL", "protsURL", "protsurl", "prosLL", "perrsFile", " propsELF", " prolsSSL", "propdsUR", "prodsCL", "propsSSL", " prolsurl", "proopsUR", " propsurl", " prodsurl", "prodsSSL", "prosURL", "propdsUrl", "prodsURI", " propsCL", "prodsURL", "prodsFile", "progsURI", "ProsURI", " proportsUR", "protsFile", "proppsURL", "proppsLL", "prolsurl", "perpsURL", "propsELF", "prolsSSL", "PropsUrl", "probsUL", "prorsFile", "procsurl", "probsUrl", " proportsLL", " proportsUrl", " propsURI", "perpsFile", "propdsURL", " prodsCL", " proportsUL", "perrsURL", "prolsURI", "propsUR", "proportsURL", "propsUL", "prodsurl", "ProsSSL", "prorsELF", "proportsurl", "PropsURL", "propsFile", "propdsLL", "proportsUR", "pronsUrl", "propsurl", "procsURI", "proopsURL", "ProsURL", "proopsurl", "progsURL", "progsurl", "procsUrl", " prolsURL", "progsCL", "prodsUR", "proportsLL", " prolsURI", "prosURI", "proportsSSL", "prorsURL", "pronsLL", "proppsUrl", "propsURI", "proportsUrl", "proopsELF", "PropsURI", "proportsURI", "pronsUR", "prolsURL", " proportsURL", " proportsELF", "proopsCL", "ProsUrl", "perpsurl", "prorsUR"], "urlConn": ["httpconn", "URLConnect", "httpContext", "sslconn", "sslCod", "urlContext", "sslConn", "fileConn", "httpConnect", "urlCod", "sslCond", "URLConn", "URLContext", "httpCod", " urlCond", "urlconn", " urlConnect", "URLConf", "urlCond", "fileConnect", "httpConn", "urlCmd", "urlConnect", "sslCmd", " urlContext", " urlConf", "fileCond", "fileCmd", "sslConnect", " urlCmd", "urlConf", " urlconn", "httpConf", " urlCod"], "httpURL": ["httpsURI", "apiUR", "HttpUrl", "HttpURI", "autoUrl", "httpURI", "httpsUR", "httpsUrl", "apiML", "HttpURL", "httpSSL", " httpurl", " httpSSL", " httpML", "httpUrl", "apiURL", "httpsURL", "httpsurl", "httpurl", "httpsSSL", "HttpUR", " httpUR", "autoURL", "autoSSL", "apiUrl", "httpUR", " httpUrl", " httpURI", "autourl", "HttpML", "httpML"], "hdrVal": [" hheaderVal", "hrStr", "hhrval", "HhrVal", "hdValues", "Hhrval", "hreqStr", "hdrValues", "hrVol", "hDRval", "hndValue", "hdrVol", "hreqVal", " hdrStr", "HdrBu", "hdValue", "HdrValues", "hndBu", " hheaderVol", "HdrDef", "hdval", "hDRValue", "hhrDef", "hhrVal", "hrValue", "HhrBu", "hrcVal", "hrVal", "HhrValues", "Hdrval", "hrcValue", "hhrValues", "hhrValue", "hdVal", "hreqValue", "hheaderVal", " hheaderStr", "hheaderStr", "hndDef", "HhrDef", "hheaderValue", "HdrValue", "hdrDef", "HdrVal", "hDRValues", "hDRVal", "hdrStr", "hrcBu", "hndVal", " hheaderValue", "HhrValue", " hdrVol", " hdrValue", "hrcDef", "hdrval", "hreqVol", "hdrValue", "hheaderVol", "hhrBu", "hdrBu"], "code": ["text", "message", "result", "mode", "ode", "check", "c", "cat", "info", "status", "charge", "state", "success", "e", "one", "level", "ie", "count", "line", "data", "const", "age", "ce", "comment", "ec", "expected", "core", "class", "no", "url", "pc", "reason", "pe", "ge", "zip", "number", "grade", "msg", "Code", "index", "see", "ack", "cc", "category", "rule", "rc", "header", "string", "codes", "fail", "score", "test", "desc", "cod", "value", "version", "xx", "key", "response", "id", "rate", "type", "zone", "error", "co", "go", "content", "coded"]}}
{"id1": "4686922", "id2": "14617444", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourceInFiles", "extractResourceAndfile", "extractResourcesAsfile", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceAsFiles", "extractResourceAndFiles", "extractResourceAndFile", "extractResourcesToFile", "extractResourcesAsFile", "extractResourcesAsResource", "extractResourceAsfile", "extractResourcesAsFiles", "extractResourceToResource", "extractResourceInFile", "extractResourcesToResource", "extractResourceInfile", "extractResourceAsFile", "extractResourceTofile", "extractResourceAndResource", "extractResourceInResource", "extractResourceAsResource", "extractResourceToFiles"], "resourcePath": ["sourceId", "stringFolder", "servicepath", "stringpath", "resourceId", " resourceUrl", " resourceId", " resourceFolder", "servicePath", "stringPath", "ResourceUrl", "sourcePath", " resourcepath", "resourceUrl", "ResourceId", "serviceFolder", "sourceUrl", "sourcepath", "resourcepath", "resourceFolder", "ResourcePath", "Resourcepath"], "dest": ["source", "filename", "result", "flat", "prop", "output", "sac", "path", " destination", "config", "home", "store", " Dest", "txt", "de", "trans", "src", "project", "default", "resources", "data", "const", "folder", "resource", "done", "later", "img", "sup", "class", "tmp", "die", "transfer", "destroy", "dist", "comb", "desc", "file", "temp", "route", "wb", "Dest", "contract", "target", "content"], "in": ["source", "as", "init", "rec", "re", "gin", "inn", "inner", "c", "f", "this", "plus", "pass", "i", "input", "socket", "inside", "conn", "image", "sin", "IN", "ini", "con", "resource", "win", "n", "up", "isin", "arin", "url", "din", "b", "is", "nin", "ins", "connection", "cin", "thin", "lin", "In", "inc", "again", "like", "rin", "file", "kin", "r", "login", "id", "reader", "bin"], "out": ["source", "cookie", "app", "copy", "cache", "output", "sync", "client", "net", "f", "at", "s", "this", "all", "ax", "w", "ex", "i", "one", "socket", "conn", "OUT", "image", "norm", "writer", "up", "n", "io", "a", "b", "null", "outer", "server", "ext", "cos", "exec", "obj", "ins", "Out", "In", "auto", "outs", "inc", "again", "off", "file", "temp", "lib", "parent", "err", "o", "boot", "user", "bin", "outside", "co"]}}
{"id1": "949327", "id2": "20735941", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"f": ["p", "x", "form", "lf", "F", "flat", "filename", "ref", "of", "fp", "fun", "fx", "cf", "path", "c", "s", "this", "w", "e", "l", "ff", "m", "fm", "folder", "fen", "bf", "self", "io", "g", "n", "a", "fo", "inf", "name", "b", "fd", "fs", "fe", "function", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "file", "df", "t", "feed", "r", "sf", "fi", "fold", "v", "d"], "in": ["source", "init", "gin", "session", "config", "w", "image", "con", "isin", "ins", "In", "d", "rec", "inn", "token", "pin", "with", "or", "IN", "data", "ini", "win", "n", "g", "up", "nin", "thin", "lin", "t", "diff", "bin", "str", "input", "socket", "serv", "a", "b", "gen", "is", "login", "reader", "get", "inc", "din", "p", "inner", "c", "ac", "pass", "ex", "l", "m", "it", "vin", "exec", "fe", "min", "connection", "fa", "lock", "cin", "again", "rin", "part", "r", "err", "ssl", "v", "ic"], "cbuf": ["cfuc", "rbbuf", "bcul", "bbuf", "bbuff", "ebuff", "fbuf", "rbux", "fbbuf", "bburs", "bbull", "rbuff", "cbutf", "bcur", "cbault", "rbul", "bcux", "buff", "buf", "dbuc", "rbuc", "fbuc", "cbuc", "dbuff", "zbuu", "cbux", "zbuf", "bcuff", "rbault", "rbutf", "cbuff", "ebuf", "bcuf", "CBuc", "bcull", "bux", "bault", "CBuf", "fbuff", "bcurs", "CBul", "ebuu", "cfuf", "dbur", "zbuff", "cfuff", "dbuf", "cbur", "rbull", "cfbuf", "cbull", "cbul", "CBuff", "rbuu", "rbuf", "rburs", "cburs", "cbuu", "ebutf", "cfur", "bcuc", "zbutf", "cbbuf", "bcault"], "read": ["work", "text", "x", "buffer", "Read", "parse", "want", "config", "w", "k", "cel", "val", "build", "close", "name", "log", "add", "pe", "report", "reads", "ack", "size", "stream", "repeat", "write", "ak", "ok", "iter", "un", "y", "key", "feed", "type", "start", "error", "d", "run", "last", "sync", "check", "load", "use", "view", "level", "ed", "count", "data", "play", "io", "g", "allow", "rc", "raw", "used", "ing", "insert", "id", "select", "know", "call", " reading", "reading", "update", "lex", "READ", "input", "send", "skip", "socket", "sleep", "ind", "readable", "print", "valid", "bit", " write", "each", "ize", "only", "en", "orig", "wait", " READ", "loop", "put", "reader", "bind", "get", "inc", "fill", " Read", "ride", "seek", "create", "re", "se", "length", "pass", "q", "record", "open", "old", "find", "connect", "ink", "num", "it", "change", "child", "hex", "oct", "index", "full", "r", "er", "end", "draw"], "totRead": ["totoRead", "totReading", "tobyLoad", " totLink", "notLoad", "totiBuild", "octotoReading", "tazonLoad", "TotWrite", "totSearch", " totalBuild", "TotaWrite", "totalBuild", "ntotWrite", "intotRead", "nottRead", "intottLoad", "tottSearch", "totaReading", "totiLink", "TottLoad", "totalAccept", "totaRead", "tobyUse", "tottFind", "totoLength", " totalWrite", "nottWrite", "dottLoad", "tottClose", "TotaLoad", "towWrite", "tetRead", "dotLoad", "tottedFollow", "totoConnect", "tottReader", "TottReader", "towReading", "tntWrite", "TottSearch", "dottReading", "totoUse", "intottBuild", "totingGet", "tottUse", "totaLink", "ntotRead", "totClose", "totGet", "tottBuild", "octotRead", "totoFind", "tottAccept", "dotReader", "TottFollow", "totalRead", "TotConnect", "towRead", "totAccept", "totoLoad", "towLoad", "totaBuild", "dottReader", "totoReading", "dotUse", "octotLength", "nottLoad", "tochLoad", "ntottLoad", "tottConnect", "TotSearch", "tatReader", "totingWrite", "TottRead", "tottLoad", "dottWrite", "totUse", "TotLoad", "dottUse", "TotFollow", "ntottReader", " totalLink", "totingSearch", "tottDraw", "totLoad", "totReader", " totalRead", "toyWrite", "tetWrite", "dottRead", "totLink", "tottGet", "toyDraw", "tntRead", "ntottRead", "intotLoad", "tottWrite", "totiRead", "TotaRead", "tochWrite", "TotDraw", "TotGet", "totaWrite", "tochRead", "intotBuild", "toyLoad", "tottedRead", "tochReader", "totingRead", "notWrite", "notAccept", "tollWrite", "ntottWrite", "TotaDraw", "tntReader", "tottRead", "TottConnect", "totoWrite", "ntotReader", "intottClose", "TottWrite", "tcotBuild", " totBuild", "tatRead", "tobyRead", "TottGet", "tcotLoad", "TotReader", " totWrite", "octotReading", "tollRead", "totalLink", "tollLoad", "totBuild", "ntotLoad", "tntLoad", "totingConnect", "tobyFind", "tcotClose", "tazonBuild", "tottLength", "nottAccept", "tollReading", "tottedWrite", "notRead", "dotReading", "tottFollow", "totalLoad", "tatLoad", "totingFollow", "tazonClose", "towLength", "TotReading", "totaLoad", "tottReading", "totDraw", "dotWrite", "totoSearch", "totLength", "totWrite", "octotoWrite", "totConnect", "tottedGet", "tatWrite", "dotRead", "octotWrite", "tetReading", "intottRead", "dottFind", "dotFind", "intotClose", "totaDraw", "totalWrite", "octotoLength", "TottReading", "totFind", "totaReader", "tetLoad", "toyRead", "tcotRead", "tazonRead", "TotRead", "totFollow", "totiWrite", "octotoRead", "towAccept"], "out": ["p", "x", "init", "output", "client", "sync", "net", "c", "ac", "s", "w", "plus", "ex", "l", "socket", "conn", "OUT", "writer", "n", "g", "io", "a", "up", "b", "outer", "ext", "exec", "obj", "conf", "h", "fn", "exp", "connection", "Out", "In", "outs", "inc", "again", "off", "file", "parent", "part", "t", "err", "r", "o", "v", "bin", "d"], "i": ["x", "source", "init", "buffer", "current", "ai", "I", "k", "ci", "abi", "chi", "ip", "name", "u", "li", "y", "key", "slice", "start", "d", "ti", "uri", "info", "ei", "one", "data", "ini", "multi", "iu", "bi", "io", "g", "pi", "api", "j", "eni", "id", "hi", "me", "ii", "e", "input", "ind", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "zi", "ri", "my", "phi", "p", "length", "z", "c", "ni", "gi", "ix", "ori", "ie", "l", "yi", "m", "q", "it", "ui", "ik", "oi", "index", "fi", "r", "v", "ic"]}}
{"id1": "11865906", "id2": "12242903", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 1, "substitutes": {"testIdentification": ["Testidentifier", "Testidentity", "testidentify", "TestIdentify", "testPersonity", "testPersonifier", "testIdentity", "testPersonification", "testAuthentification", "testAuthentity", "testidentity", "testAuthentifier", "TestIdentity", "Testidentification", "testIdentifier", "testidentifier", "Testidentify", "testidentification", "TestIdentification", "TestIdentifier", "testAuthentify", "testPersonify", "testIdentify"], "username": ["account", "month", "uid", "whatever", "filename", "property", "ug", "uri", "token", "hello", "ame", "rue", "home", "company", "ername", "purpose", "driver", "person", "word", "nick", "USER", "uno", "uin", "consumer", "email", "sudo", "job", "database", "name", "subject", "character", "sword", "url", "host", "ui", "verb", "address", "your", "string", "prefix", "profile", "plugin", "usr", "staff", "creator", "users", "utf", "nil", "login", "uu", "mobile"], "password": ["account", "p", "secret", " passwords", "text", "filename", "words", "cache", "token", "session", "pad", "hash", "wd", "pass", "seed", "phrase", "driver", "w", "word", "padding", "auth", "email", "PASS", "sudo", "mac", "description", "database", "name", "sword", "security", "null", "params", "picture", "address", "wallet", "string", "Pass", "patch", "crypt", "prefix", "profile", "fax", "Password", "attribute", "value", "key", "login", "diff"], "md5": ["ddob", "md4", "md2", "sha4", " md3", "dd2", "MD4", "md512", " md1", "sha512", "mdob", "dd512", "md3", " md75", "dd5", "sha5", " md2", "MD2", " mdob", "MD5", "sha75", "sha3", "MD512", "sha1", " md4", "md75", "md1", " md512", "MDob", "MD3", "MD75", "MD1"], "logServiceMock": ["logServicemocks", "logServicePick", "logServiceAMock", "logServiceMick", "logServiceManagerocker", "logClientBOCK", "logServiceMocked", "logModuleManOCK", "logServicemock", "logServiceBock", "logServiceBck", "logServiceMocker", "logServiceAMocker", "logModuleMock", "logServicePock", "logServiceVck", "logClientMock", "logServiceFock", "logModulePick", "logClientMck", "logServicePOCK", "logServiceVocks", "logClientBock", "logServiceBocker", "logModulePocks", "logServiceManock", "logServiceFck", "logServiceFocks", "logServiceVOCK", "logServicemOCK", "logServiceFOCK", "logServiceManagerock", "logServicePocks", "logServiceBOCK", "logServiceMocks", "logServiceMOCK", "logModuleMocks", "logModulePock", "logServiceManocked", "logServiceBocks", "logModuleMick", "logModuleMocker", "logModulePOCK", "logServiceManOCK", "logServiceFocker", "logServicemick", "logServiceFocked", "logServiceManagerocks", "logServiceMck", "logServiceVocker", "logServiceBick", "logServiceManocker", "logServiceManocks", "logClientMocker", "logModuleMOCK", "logServiceAMocked", "logModuleManocker", "logClientBck", "logServiceVock", "logServiceAMOCK", "logModuleManocks", "logClientBocker", "logClientMOCK", "logServiceManagerOCK", "logModuleManock"], "dbServiceMock": ["dbClientFocker", "dbServiceManagerock", "dbServicesMocker", "dbServiceMick", "dbServiceBox", "dbClientMock", "dbServicesManox", "dbServiceFOCK", "dbServicemocked", "dbservicemox", "dbServiceDOCK", "dbServicemocker", "dbServiceManick", "dbservicemocker", "dbServiceFick", "dbServiceManagerick", "dbserviceMock", "dbClientMOCK", "dbServiceVocker", "dbServiceMOCK", "dbServicesMox", "dbServiceFocker", "dbServiceDocker", "dbServiceManagerOCK", "dbServiceDock", "dbserviceMOCK", "dbServiceManagerocker", "dbservicemock", "dbServiceFocked", "dbservicemOCK", "dbServiceMocker", "dbServiceVox", "dbServiceMox", "dbServicesMick", "dbServiceCMick", "dbServicemox", "dbServiceCMock", "dbServiceBOCK", "dbServicemock", "dbServiceManox", "dbServicemOCK", "dbServiceVick", "dbClientMocked", "dbServiceBock", "dbserviceMox", "dbServiceManock", "dbserviceMocker", "dbServiceVock", "dbServicesManick", "dbServicesMock", "dbServiceFox", "dbServiceManocker", "dbServiceVOCK", "dbClientMick", "dbClientFOCK", "dbServiceFock", "dbClientFock", "dbServicesManocker", "dbServiceDick", "dbServicemick", "dbServiceCMocked", "dbClientFocked", "dbServicesManock", "dbServiceMocked", "dbServiceCMocker", "dbClientFick", "dbClientMocker", "dbServiceBocker"], "user": ["account", "me", "match", "result", "role", "token", "current", "client", "instance", "author", "config", "info", "model", "use", "page", "pass", "person", "per", "real", "usa", "project", "or", "USER", "blog", "data", "by", "follow", "record", "object", "proxy", "auth", "resource", "other", "up", "class", "job", "name", "log", "server", "you", "api", "connection", "rule", "lock", "profile", "plugin", "ee", "usr", "creator", "bug", "key", "row", "login", "type", "member", "db", "User"]}}
{"id1": "20623709", "id2": "742465", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"split": ["match", "cmp", "init", "copy", "set", "sync", "parse", "update", "archive", "build", "process", "format", "open", "share", "add", "execute", "exec", "transfer", "append", "sort", "part", "diff", "join", "start", "delete", "run", "Split"], "targetDirectory": ["destDirectory", "currentDir", "basePath", " targetFolder", "currentDirectory", "outputDir", "currentPath", "currentRoot", "baseDatabase", " targetRoot", "TargetFolder", "destDir", "targetRoot", "targetDatabase", "outputDirectory", "TargetRoot", "baseDir", "targetDir", "destFile", "masterDatabase", "masterPath", "outputFolder", "targetFile", "TargetFile", "TargetDir", "masterDir", "targetFolder", "baseFile", "baseDirectory", "masterDirectory", "targetPath", "outputFile", " targetDir", "TargetDirectory", " targetFile", "baseFolder", "TargetPath", "currentFolder", "TargetDatabase", "destFolder", " targetPath"], "prefix": ["pre", "sequence", "filename", "cache", "uri", "fp", "path", "username", "first", "FIX", "Pref", "config", "ix", "domain", "timeout", "txt", "root", "padding", "fixed", "folder", "prot", "format", "resource", "fix", "directory", "base", "name", "number", "append", "index", "string", "patch", " suffix", "queue", "resolution", "temp", "template", "unit", "type", "pattern", "offset"], "maxUnitBases": ["maxUnitPlails", "maxUnitBues", "maxUnitAliaches", "maxUnitQueues", "maxunitAliases", "maxunitBues", "maxunitAliase", "maxunitBaches", "maxUnitAliues", "maxunitBails", "maxUnitAliails", "maxUnitChasing", "maxUnitChues", "maxunitAliails", "maxUnitBails", "maxUnitPlases", "maxUnitEaches", "maxUnitChases", "maxunitBases", "maxUnitPlase", "maxUnitBasing", "maxunitBase", "maxUnitBase", "maxUnitPlaches", "maxUnitQueases", "maxUnitEails", "maxunitAliasing", "maxUnitAliases", "maxUnitEase", "maxUnitAliasing", "maxunitAliues", "maxUnitAliase", "maxUnitChase", "maxUnitQueasing", "maxUnitEases", "maxUnitQuease", "maxUnitBaches", "maxunitAliaches", "maxunitBasing"], "maxUnitEntries": ["maxUnitAddresses", "maxUnitOrdrations", "maxUnitEntry", "maxUnitOrdines", "maxUnitIntrys", "maxLineEntry", "maxLineOrdines", "maxUnitOrdies", "maxUnitOrdresses", "maxUnitCountrations", "maxUnitEntryures", "maxUnitEntryry", "maxLineOrdries", "maxunitEntrys", "maxunitEntryrys", "maxUnitErries", "maxUnitEntrys", "maxUnitAddry", "maxUnitAddures", "maxUnitEntryrys", "maxunitEntresses", "maxUnitIntresses", "maxUnitEntines", "maxUnitCountry", "maxUnitAddries", "maxUnitIntries", "maxunitEnties", "maxUnitEntresses", "maxUnitEnties", "maxUnitOrdries", "maxunitEntryies", "maxLineOrdry", "maxUnitErry", "maxUnitOrdry", "maxLineOrdrations", "maxLineEntrations", "maxUnitEntryries", "maxUnitErines", "maxLineEntries", "maxunitEntryries", "maxUnitErrations", "maxUnitEntryresses", "maxunitEntries", "maxUnitEntryies", "maxunitEntryresses", "maxUnitOrdrys", "maxLineEntines", "maxUnitCountines", "maxUnitEntures", "maxUnitInties", "maxUnitEntrations", "maxUnitCountries"], "fis": ["fai", "Fisc", "Fiss", "fiss", "forIs", " fisc", "forisa", " fiss", "foriss", "fris", "Fis", "visa", " fIs", "forris", "fisa", "Fris", "vis", "vai", "forisc", " fai", "foris", " fisa", "fisc", "vIs", "fIs", "forai", " fris"], "fci": ["dco", "fai", "bco", "Fai", "fii", "efcos", "vci", "hci", "bci", " fii", "Fis", "fcos", "Fco", "efai", "efci", "vco", "vai", "doci", " fai", "dii", " foci", "vcos", "hai", "Fci", "bai", "Fii", "Foci", "hco", "hcos", "bis", "efco", "dci", "foci"], "fos": ["infos", "foss", "tis", "fso", " fcos", "ifcos", "foes", "Foss", "infoes", "Foes", "ifios", "Fos", "infoss", "Fis", "infis", "fsos", "fo", "fcos", "ifos", " fo", "toes", "fios", "ifo", "tos", "toss", "fsios", "fscos", " fios"], "fco": ["dco", "fro", " fcos", "filebo", "Fico", "fileico", " fico", "hci", "lro", "lco", "lgo", "fgo", "fbo", "fico", "fileco", " fbo", "fileci", "lcos", "fcos", "Fco", "Fbo", "hgo", " fro", "dcos", "Fci", "lci", "hco", "dro", "hcos", " fgo", "dci"], "buffer": ["source", "message", "result", "copy", "cache", "expression", "position", "bar", "length", "translation", "memory", "pad", "buff", "info", "buf", "texture", "timeout", "view", "input", "uffer", "border", "image", "read", "data", "writer", "loader", "resource", "binary", "comment", "zero", "document", "window", "base", "callback", "bc", "device", "null", "server", "capacity", "transfer", "counter", "Buffer", "header", "channel", "size", "queue", "layer", "scale", "batch", "block", "reference", "iter", "pause", "request", "response", "feed", "entry", "reader", "rate", "flush", "bin", "offset", "context"], "currentBasesCount": ["currentBasingNum", "currentChasecount", "currentChasescount", "currentBasingCounter", "currentBatchesCount", "currentBatchesCounter", "currentBasingCount", "currentChaseCount", "currentBaseNum", "currentChaseNum", "currentBatchesNum", "currentChasesCount", "currentBaseCount", "currentBatchescount", "currentBaseCounter", "currentBasescount", "currentChasesNum", "currentBasecount", "currentBasingcount", "currentChasesCounter", "currentChaseCounter", "currentBasesNum", "currentBasesCounter"], "currentEntriesCount": ["currentAdduresOffset", "currentAddriesLimit", "currentEntursLimit", "currentEntursSize", "currentAdduresSize", "currentAddriesSize", "currentEntriesLimit", "currentAddriesCount", "currentEntriesSize", "currentEntursOffset", "currentEnturesCount", "currentAddriesOffset", "currentEntriesOffset", "currentEntrasSize", "currentEntrasLimit", "currentEntursCount", "currentEnturesSize", "currentEntrasCount", "currentAdduresLimit", "currentEnturesLimit", "currentEntrasOffset", "currentEnturesOffset", "currentAdduresCount"], "targetCount": ["targetSum", "patternCount", "TargetSize", "argetcount", "patternSum", "argetSize", "targetSize", "TargetCount", "argetSum", "patterncount", "TargetSum", "patternSize", "targetcount", "argetCount", "Targetcount"], "fastaChannel": [" fastAChannel", " fastAColumn", "fastAContainer", "fastAConnection", " fastAContainer", "fastaqChannel", "fastasContainer", "fastasContext", "fastaContext", "fastAColumn", "fastasChannel", " fastaConnection", "fastanContext", " fastaContainer", "fastaqConnection", "fastaqBuffer", " fastaContext", " fastAContext", "fastaConnection", "fastAContext", "fastABuffer", "fastasConnection", "fastanContainer", "fastaColumn", "fastanChannel", " fastABuffer", "fastanBuffer", " fastaColumn", "fastAChannel", " fastAConnection", "fastasBuffer", "fastasColumn", "fastaContainer", "fastaqColumn"], "totalSeqCount": ["totalSeQcount", "totalQueqCounter", "totalSeqNum", "totalSeQNum", "totalSeqsCounter", "totalSeqscount", "totalQueqNum", "totalSeuxCounter", "totalSeuxCount", "totalSeqcount", "totalQueQCount", "totalSeQCounter", "totalQueQNum", "totalSeqsCount", "totalSeQCount", "totalSeqsNum", "totalQueqCount", "totalSeuxNum", "totalQueQCounter", "totalQueqcount", "totalQueQcount", "totalSeuxcount", "totalSeqCounter"], "totalResiduesCount": ["totalResidurescount", "totalResiduesSize", "totalResiduingSize", "totalResiduesNum", "totalResqueurescount", "totalResiduingcount", "totalResiduescount", "totalResiduingNum", "totalResqueuresCount", "totalResqueuresSize", "totalResqueuesNum", "totalResiduationCount", "totalResqueuescount", "totalResiduresSize", "totalResqueuesCount", "totalResiduingCount", "totalResiduresCount", "totalResiduationNum", "totalResqueuresNum", "totalResiduationSize", "totalResiduresNum", "totalResqueuesSize", "totalResiduationcount"], "prevTime": ["PrevValue", " prevValue", "prevSize", "prevFile", "commitValue", "commitFile", "PrevTime", "PrevFile", " prevSize", "commitSize", "commitTime", "PrevSize", " prevFile", "prevValue"], "fastaFileSize": ["fastaBufferLength", "fastasHeaderAddress", "fastasFileAddress", "fastaLineSize", "fastaBlockLength", "fastaFilesName", "fastasHeaderName", "fastaFileName", "fastaLineAddress", "fastaHeaderAddress", "fastaFilesLength", "fastaBlockCount", "fastasFileLength", "fastasFileName", "fastaFilesAddress", "fastAFileLength", "fastABufferCount", "fastasHeaderSize", "fastABufferAddress", "fastaPageSize", "fastAFileAddress", "fastaBlockSize", "fastABufferSize", "fastAFileCount", "fastaHeaderName", "fastaFilesSize", "fastaFileLength", "fastaBufferCount", "fastaHeaderLength", "fastABufferLength", "fastaFileAddress", "fastasHeaderLength", "fastaLineCount", "fastaFileCount", "fastaBufferSize", "fastaBufferAddress", "fastAFileSize", "fastaBlockAddress", "fastaPageLength", "fastaPageAddress", "fastaLineLength", "fastaPageName", "fastaHeaderSize", "fastasFileSize"], "fastaFileReadOffset": ["fastaFileWriteLength", "fastaBufferWriteLength", "fastaFileRunoffset", "fastaFileStartoffset", "fastaFilereadOff", "fastaBufferReadAmount", "fastaFileWriteoffset", "fastaFileStartOffset", "fastaBufferReadOffset", "fastaFilereadOffset", "fastaFileRunEntry", "fastaFilesWriteOff", "fastaFileLoadOffset", "fastaFileLoadoffset", "fastaFileWriteOffset", "fastaFileRunOff", "fastaDirectoryWriteOffset", "fastaDirectoryReadEntry", "fastaDirectoryReadoffset", "fastaDirectoryWriteEntry", "fastaFileStartOff", "fastaFilereadoffset", "fastaFileReadOff", "fastaFilesWriteOffset", "fastaFilesReadOff", "fastaFileRunOffset", "fastaFilesReadOffset", "fastaFilesWriteoffset", "fastaFilereadLength", "fastaFileWriteOff", "fastaFileLoadLength", "fastaDirectoryReadOffset", "fastaBufferWriteAmount", "fastaFileLoadAmount", "fastaFilesReadoffset", "fastaBufferWriteoffset", "fastaFileWriteAmount", "fastaDirectoryReadOff", "fastaFileLengthOffset", "fastaFilesWriteLength", "fastaFileLengthOff", "fastaFileLengthoffset", "fastaFileWriteEntry", "fastaDirectoryWriteoffset", "fastaBufferReadLength", "fastaFileLengthAmount", "fastaFileReadEntry", "fastaFileReadAmount", "fastaDirectoryWriteOff", "fastaFileLengthLength", "fastaFileStartEntry", "fastaBufferReadoffset", "fastaFilesReadLength", "fastaFileReadoffset", "fastaFileReadLength", "fastaBufferWriteOffset"], "partitionStartOffset": ["partitionStartOrder", "partitionBufferOffset", "partitionsStartOffset", "partitionBufferRange", "partitionsEndOrder", "partitionStartRange", "partitionsEndOff", "partitionsStartOff", "partitionsEndRange", "partitionEndOrder", "partitionStopOffset", "partitionStopRange", "partitionBufferOrder", "partitionStopOff", "partitionStopOrder", "partitionEndRange", "partitionsStartOrder", "partitionEndOff", "partitionsEndOffset", "partitionStartOff", "partitionsStartRange", "partitionBufferOff"], "bufferSize": ["processType", "BufferC", " bufferCount", "BufferSize", "BufferSIZE", "processC", "bufferType", " bufferC", "processSIZE", "queueSize", "processSize", "bufferC", "bufferCount", "BufferCount", "BufferType", " bufferSIZE", "bufferSIZE", " bufferType", "queueCount"], "fastaBuffer": ["FastasStream", "fastacePtr", " fastAChannel", "fastasPtr", " fastasBuffer", "fastAContainer", "FastaBuffer", " fastasContainer", "FastasBuff", "FastasPtr", "fastaaBuff", "fastasContainer", "fastAPtr", "fastaStream", "fastasQueue", "fastaPtr", "fastaBuff", "fastanFile", "fastanStream", "FastasBuffer", "fastaaBuffer", "fastanBuff", "fastasChannel", "fastaaStream", "fastABuff", " fastABuff", "FastasChannel", "fastanQueue", "fastaQueue", " fastaContainer", "FastaChannel", " fastaBuff", " fastAFile", "fastaceChannel", "fastAQueue", " fastaQueue", "fastaaPtr", "fastasBuff", " fastAQueue", "fastABuffer", "FastaPtr", "fastasStream", "fastAFile", "fastanContainer", "fastaceBuff", "fastanChannel", " fastaFile", "FastaBuff", "FastaStream", " fastABuffer", "fastanBuffer", "fastAChannel", "fastasBuffer", "fastaFile", "fastanPtr", " fastasFile", " fastasChannel", "fastaceBuffer", "fastaContainer", "fastasFile"], "fastaReadState": ["fastaFilestate", "fastaFileMode", "fastaReaderType", "fastaReaderState", "fastasReaderType", "fastaReaderstate", "fastaReadingType", "fastasReadMode", "fastasReaderMode", "fastaFileState", "fastaReadingState", "fastasReadstate", "fastaReadType", "fastasReadType", "fastaReadingstate", "fastasReadState", "fastasReaderState", "fastaReaderMode", "fastaReadingMode", "fastasReaderstate", "fastaReadMode", "fastaFileType", "fastaReadstate"], "nBytes": ["nFiles", "obytes", "lenBytes", "pBytes", "oBytes", "oParts", " nParts", "NByte", "NParts", "Nbytes", "lenbytes", "numBytes", "nbytes", "lenFiles", "lenFrames", "NBytes", "numFrames", "numbytes", "pParts", " nFrames", "oFiles", " nbytes", "pbytes", "numFiles", "nFrames", " nFiles", "pByte", "nByte", "nParts", " nByte", "NFiles"]}}
{"id1": "7809093", "id2": "665420", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"getContent": ["GetData", "requestBody", "GetBody", "GetEntity", " getData", "getBody", " getBody", "setBody", "responseEntity", "setData", "setContent", "responseOutput", "GetOutput", "requestEntity", "GetContent", "getOutput", "responseBody", "requestOutput", "setEntity", "getEntity", " getEntity", "getData", "responseContent", "requestContent"], "request": ["message", "method", "result", "position", "uri", "current", "path", "instance", "http", "e", "input", "req", "data", "q", "object", "resource", "QUEST", "url", "name", "server", "query", "address", "operation", "string", "connection", "handler", "queue", "reference", "route", "r", "user", "type", "xml", "Request", "report", "application"], "sb": ["lp", "ls", "bh", "buffer", "su", "ab", "fp", "xb", "SB", "cb", "obb", "bb", "fb", "bj", "lab", "sg", "pb", "src", "abi", "bp", "ib", "zb", "binary", "bf", "lb", "sa", "sup", "bc", "bt", "b", "vm", "usb", "nb", "bs", "bg", "rb", "eb", "gb", "sk", "bm", "BB", "amb", "bsp", "wb", "sf", "db", "abb", "bd"], "client": ["p", "contact", "call", "app", "remote", "util", "cache", "output", "current", "uri", "Client", "session", "net", "c", "config", "tc", "https", "per", "console", "apache", "conn", "project", "bird", "default", "application", "con", "web", "service", "proxy", "builder", "ce", "resource", "force", "connect", "url", "server", "host", "api", "container", "connection", "channel", "handler", "cl", "plugin", "queue", "cli", "ssl", "context", "http"], "httpParams": ["HttpParamas", "httpArums", "httpPamer", "HTTPPoparams", "httpPARams", "httpPareters", "httpPoamer", "HTTPPARam", "httpPramer", "HTTPPARams", "HTTPParparams", "httpPeram", "HTTPPareters", "HTTPParamer", "httpPreters", "httpPARamas", "httpArams", "httpPrams", "httpPeramas", "httpParums", "HttpParparams", "httpPoams", "HTTPPoams", "httpPrparams", "httpPARums", "HttpParam", "httpParcs", "HTTPPARcs", "httpParamer", "httpPoeters", "httpPeters", "httpPams", "HTTPPoeters", "HTTPPARums", "httpParparams", "httpArcs", "HTTPParams", "httpParam", "HTTPParcs", "httpPerams", "httpPARparams", "httpPoparams", "httpPerparams", "httpParamas", "httpPARam", "HTTPParam", "HTTPParums", "HTTPPoamer", "httpPparams", "httpAram", "HttpParams", "httpPARcs"], "response": ["message", "relation", "result", "output", "json", "successful", "model", "http", "view", "page", "success", "resp", "data", "object", "resource", "reply", "document", "server", "Response", "api", "body", "onse", "connection", "respond", "received", "collection", "feed", "results", "error", "report", "status", "application"], "entity": ["source", "ent", "result", "media", "output", "json", "translation", "instance", "company", "environment", "model", "event", "component", "person", "e", "conn", "xml", "application", "data", "writer", "agent", "object", "resource", "ce", "node", "document", "em", "pe", "server", "article", "address", "api", "body", "connection", "channel", "element", "coll", "creator", "file", "collection", "entry", "type", "Entity", "content", "http"], "reader": ["source", "rx", "buffer", "reading", "ry", "inner", "rr", "rar", "ler", "i", "per", "input", "driver", "bird", "read", "loader", "writer", "oder", "ner", "in", "io", "editor", "rer", "server", "worker", "stream", "handler", "parser", "Reader", "iter", "row", "r", "er", "ser", "feed", "iterator", "ri"], "line": ["source", "message", "lf", "char", "Line", "lines", "str", "sync", "cell", "non", "len", "page", "model", "pass", "link", "word", "l", "inline", "val", "data", "definition", "comment", "ip", "url", "character", "name", "base", "no", "lc", "job", "code", "ge", "sel", "sl", "li", "string", "header", "LINE", "cl", "lin", "el", "layer", "block", "iter", "row", "key", "r", "feed", "entry", "id", "end", "le", "user", "unit", "content"]}}
{"id1": "237493", "id2": "22442270", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 0, "substitutes": {"url": ["source", "ref", "filename", "buffer", "uri", "path", "Url", "f", "config", "link", "l", "image", "loc", "loader", "service", "location", "resource", "www", "io", "base", "name", "bel", "null", "server", "host", "URL", "rl", "sl", "address", "string", "connection", "fr", "ur", "el", "ll", "lr", "html", "file", "ssl", "feed", "href", "ob", "id", "xml", "http"], "in": ["source", "as", "init", "inn", "gin", "out", "token", "pin", "inner", "c", "f", "config", "this", "ex", "i", "input", "socket", "serv", "conn", "inside", "image", "val", "or", "IN", "data", "m", "ini", "con", "resource", "n", "io", "isin", "a", "bin", "din", "is", "nin", "min", "ins", "In", "impl", "again", "rin", "file", "part", "err", "r", "login", "ssl", "id", "reader", "inc", "xml", "cms"]}}
{"id1": "4938100", "id2": "19276022", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"sha1": [" SHA64", "SHA1", " SHAOne", "SHAOne", "hash1", "sha256", "shaOne", "hash256", "SHA256", "sha64", "hash64", "hashOne", " SHA1", " SHA256", "SHA64"], "text": [" TEXT", "source", "message", "secret", "output", "str", " Text", "token", "path", "translation", "config", "this", "font", "bytes", "txt", "word", "input", "image", "data", "TEXT", "object", "format", "editor", "class", "url", "name", "ext", "Text", "code", "password", "number", "letter", "hex", "string", "connection", "struct", "test", "value", "version", "key", "EXT", "template", "contract", "pattern", "content"], "UnsupportedEncodingException": ["UnsupportedEncodedEx", "UnsupportedEncodedception", "UnsupportedEncoderException", "UnsupportedEncodingEx", "UnsupportedEncasingception", "UnsupportedEncoderception", "UnsupportedEncodingception", "UnsupportedEncasingException", "UnsupportedEncodedException", "UnsupportedEncasingEx", "UnsupportedEncoderEx"], "md": ["me", "message", "mand", "mode", "mm", "mp", "mod", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", "mb", "meta", "mg", "ind", "data", "m", "map", "nm", "metadata", "ad", "mad", "mac", "bf", "editor", "valid", "rm", "ms", "sm", "vd", "code", "pd", "sha", "body", "gd", " MD", "ld", "mn", "dd", "di", "mo", "od", "mt", "hd", "cd", "am", "MD", "mc", "ma", "df", "mag", "pm", "d", "bd"], "sha1hash": ["sha41address", "SHA2check", "sha1address", "sha001sum", "sha256Hash", "SHA1sum", "sha4sum", "wa1sum", "sha1check", "sha2address", "wa3hash", "SHA1address", "sha1hex", "sha001hash", "SHA1check", "sha2sha", "sha1sha", "wa1dash", "sha5sha", "wa3sum", "sha5Hash", "SHA2sha", "sha3hash", "SHA1sha", "sha4dash", "sha41sum", "sha2Hash", "sha91hash", "sha1Hash", "sha256sum", "sha2hash", "sha256sha", "sha5sum", "sha5hash", "sha91sum", "sha4hex", "sha4hash", "sha3sum", "sha41hash", "sha91check", "SHA2hash", "wa1hex", "SHA1Hash", "sha2sum", "sha2check", "SHA1hash", "sha41check", "sha91address", "wa3hex", "sha1sum", "SHA2address", "sha1dash", "wa1hash", "SHA2sum", "sha001dash", "sha001hex", "sha3dash", "sha256hash", "SHA2Hash", "wa3dash", "sha3hex"]}}
{"id1": "11546108", "id2": "3756429", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"run": ["call", "output", "load", "download", "update", "println", "running", "input", "Run", "build", "process", "read", "evaluate", "print", "action", "execute", "runner", "exec", "submit", "write", "test", "loop", "request", "apply", "start"], "in": ["source", "init", "buffer", "inn", "token", "out", "client", "inner", "c", "f", "s", "e", "input", "l", "socket", "serv", "IN", "data", "loader", "ini", "con", "io", "isin", "bin", "b", "server", "fin", "is", "pool", "nin", "min", "ins", "h", "fr", "stream", "lin", "In", "inc", "again", "rin", "r", "t", "login", "ssl", "reader", "din", "cms"], "ligneEnCours": ["ligneEnScOUR", "ligneEnAcour", "ligneEnScore", "ligneENcrosse", "ligneEnTore", "ligneOpenAcurs", "ligneOpenCOUR", "ligneEnAcours", "ligneenAcours", "ligneENcour", "ligneenCour", "ligneEnScrosse", "ligneEnLCrosse", "ligneEnTour", "ligneEnAcurs", "ligneEnCour", "ligneENCOUR", "ligneEnLCOUR", "ligneEnCore", "ligneenCore", "ligneENCore", "ligneEnFCOUR", "ligneEncourses", "ligneOpenAcour", "ligneEncOUR", "ligneOpenAcours", "ligneEncurs", "ligneENCrosse", "ligneEnTours", "ligneEnSours", "ligneOpenCour", "ligneOpenAcOUR", "ligneEnTourses", "ligneEnLCour", "ligneEnSour", "ligneENAcour", "ligneenCours", "ligneEnAcore", "ligneEnFCours", "ligneEncours", "ligneEnFCurs", "ligneEnFCour", "ligneEnScour", "ligneENAcourses", "ligneenAcore", "ligneENCourses", "ligneEnTurs", "ligneENAcore", "ligneEncrosse", "ligneEnCOUR", "ligneEncore", "ligneENCurs", "ligneEnTOUR", "ligneEncour", "ligneEnScourses", "ligneENcOUR", "ligneEnAcOUR", "ligneenAcourses", "ligneOpenCours", "ligneEnAcourses", "ligneENcours", "ligneEnCrosse", "ligneENcurs", "ligneEnLCours", "ligneENCours", "ligneEnCurs", "ligneEnSurs", "ligneenCourses", "ligneENCour", "ligneENAcours", "ligneOpenCurs", "ligneEnSOUR", "ligneenAcour", "ligneEnScours", "ligneEnCourses"], "i": ["p", "x", "uri", "c", "ai", "f", "gi", "ii", "info", "e", "l", "I", "k", "count", "ci", "yi", "m", "ini", "ip", "io", "iu", "bi", "n", "si", "u", "b", "col", "esi", "counter", "ui", "pi", "oi", "li", "index", "j", "di", "qi", "eni", "xi", "t", "o", "id", "zi", "type", "v", "start", "ti", "ski", "phi"], "informations": ["incstrumentations", "instrumentation", "inceptionats", "incformations", "incstrumentation", "informators", "inpectats", "inparators", "inpectations", "informsats", "inparats", "inparations", "information", "informsators", "inpectators", "insformations", "invocation", "instrumentings", "informsations", "invocations", "inparals", "incstrumentats", "informals", "insformals", "informsals", "incformats", "inceptionation", "incstrumentings", "informings", "inceptionations", "invocats", "inspectations", "instrumentations", "informats", "incformation", "inspectators", "inspectals", "instrumentats", "inspectats", "inpectals", "insformats", "insformators", "invocings", "incformings", "inceptionings"], "version": ["source", "position", "uri", "feature", "language", "versions", "download", "ver", "model", "page", "VERSION", "install", "release", "resource", "comment", "ip", "description", "v", "server", "number", "index", "Version", "channel", "prefix", "unit", "parent"], "url": ["text", "source", "position", "uri", "json", "output", "path", "language", "download", "config", "page", "image", "resource", "location", "comment", "base", "server", "URL", "number", "address", "channel", "prefix", "ssl", "href", "xml", "status", "http"], "texteErreur": ["texteErreeur", "texteErrecurs", "texteErreurs", "texteErregour", "texteErrenour", "texteErruries", "texteErrorreur", "texteErreau", "texteErrecure", "texteErrenure", "texteCurreUR", "texteErruaser", "texteErregurs", "texteErrecour", "texteErrur", "texteErrenau", "texteIrreour", "texteErrenur", "texteErreeau", "texteErrorreour", "texteCurrecurred", "texteErrourred", "texteErrecur", "texteErritour", "texteErrecUR", "texteErbreur", "texteErbreuries", "texteErreeuries", "texteErrecurred", "texteIrraser", "texteArreour", "texteErrorreau", "texteIrreaser", "texteErpreurred", "texteArrenurs", "texteErrorrenur", "texteErreuries", "texteErrecaur", "texteErregure", "texteArreurs", "texteErraser", "texteErreurred", "texteCurrecUR", "texteCurreur", "texteErrenuries", "texteErreure", "texteErreour", "texteErreUR", "texteErbreaser", "texteCurrecur", "texteErbreour", "texteErritau", "texteErruuries", "texteErpreur", "texteCurreaur", "texteErrorrenuries", "texteIrreuries", "texteErpreaur", "texteArrenure", "texteErreaur", "texteArreur", "texteErruur", "texteErrorrenour", "texteErrituries", "texteErrenurs", "texteErroUR", "texteArrenur", "texteErregur", "texteCurreurred", "texteIrrur", "texteErroaur", "texteIrruries", "texteArreure", "texteArrenour", "texteErpreUR", "texteIrreur", "texteIrrour", "texteCurrecaur", "texteErrorrenau", "texteErrour", "texteErrorreuries", "texteErreeour", "texteErruour", "texteErritur", "texteErreaser"], "numErreur": ["numSerreurs", "numErREurs", "numErroUR", "numSerrenUR", "numErroure", "numErrenur", "numEreure", "numErrecUR", "numErreure", "numErREur", "numErrecurs", "numErrours", "numEREurs", "numErroeur", "numEREur", "numEreur", "numErrecur", "numErreceur", "numErreUR", "numSerrenur", "numErrour", "numEreurs", "numSerreure", "numEREeur", "numErrecure", "numErREeur", "numErREure", "numErrenUR", "numSerreUR", "numEREure", "numEreeur", "numErrenurs", "numSerreur", "numSerrenure", "numErreeur", "numSerrenurs", "numErreurs", "numErrenure"], "al": [" signal", " fal", " ale", " bell", " AL", "hal", "f", "sal", "all", "back", "Al", "ale", "il", "cal", "ala", " ul", "unal", "stal", "als", "l", "pal", "val", "alist", "mal", "af", "alis", "alled", "bal", "alf", "ar", "dal", " Al", " nil", "aler", " cal", " hal", " all", " rel", "list", "tal", "el", "ul", " ab", "ali", "AL", "oper", "ral"]}}
{"id1": "3330944", "id2": "2936678", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"extractImage": ["compractImage", "extractText", "extvertImage", "compressFile", "extractLayer", "extrateFile", "compractFile", "extractFile", "extrateImage", "extressFile", "compractText", "extrateText", "extvertText", "extvertLayer", "extvertFile", "extressImage", "extressText", "compressText", "extrateLayer", "compressLayer", "compressImage", "compractLayer", "extressLayer"], "input": ["work", "text", "source", "form", "init", "media", "current", "out", "path", "DATA", "inner", "empty", "PUT", "config", "view", "Input", "command", "i", "src", "OUT", "image", "sin", "SOURCE", "inside", "IN", "data", "amp", "ini", "img", "url", "base", "inf", "tmp", "null", "ink", "standard", "picture", "address", "rc", "string", "prefix", "qa", "API", "raw", "In", "inc", "RAW", "file", "temp", "include", "request", "pull", "id", "reader", "type", "parent", "bin", "xml", "audio", "dc"], "output": ["source", "secret", "message", "text", "filename", "result", "current", "out", "generated", "path", "config", "page", "image", "format", "resource", "document", "name", "password", "address", "string", "external", "prefix", "exit", "write", "Output", "file", "version", "temp", "response", "dir", "unit", "parent", "target", "STDOUT"], "params": ["p", "attr", "lp", "rules", "parts", "ps", "words", "json", "mm", "photos", "py", "Param", "styles", "config", "s", "Par", "param", "mos", "phrase", "processor", "options", "i", "fps", "services", "manager", "resources", "data", "names", "lis", "afi", "vs", "ras", "pixel", "si", "base", "pins", "lc", "proc", "spec", "server", "obj", "theme", "conf", "pi", "ams", "features", "api", "models", "par", "las", "details", "Parameters", "settings", "batch", "plugins", "properties", "pro", "phys", "results", "dis", "reader", "ctx", "bis", "xml", "http"], "w": ["work", "p", "sw", "widget", "out", "world", "f", "wd", "wt", "wp", "wic", "war", "hw", "writer", "m", "wi", "web", "W", "we", "kw", "ws", "wa", "wx", "aw", "fw", "wh", "worker", "rw", "nw", "write", "wm", "temp", "wb", "wave", "ow", "wl", "reader", "pipe", "xml", "wal", "wcs"], "in": ["p", "source", "init", "ani", "gin", "inn", "out", "pin", "ac", "f", "config", "ai", "ex", "i", "socket", "conn", "image", "inside", "src", "inas", "IN", "data", "m", "ini", "win", "con", "binary", "img", "n", "bin", "mc", "arin", "isin", "din", "b", "null", "vin", "nin", "min", "index", "ins", "connection", "fa", "cin", "thin", "qa", "lin", "In", "again", "rin", "file", "kin", "include", "temp", "part", "r", "cgi", "login", "ssl", "id", "cli", "err", "inc"], "dest": ["source", "doc", "style", "flat", "remote", "prop", "st", "path", "config", "home", "wd", "gui", "txt", " Dest", "de", "src", "project", "rest", "default", "loc", "folder", "resource", "done", "decl", "dep", "img", "sup", "tmp", "name", "cont", "null", "die", "destroy", "dat", "dist", "beta", "target", "comb", "di", "exit", "test", "nam", "desc", "coord", "dom", "temp", "route", "wb", "Dest", "dis", "dir", "id", "parent", "din", "d", "delete", "dc"], "bi": ["bh", "sb", " bio", "pin", "ni", "ai", "ba", "gi", "ii", "info", "bas", "ori", "vi", "i", "wei", "ci", "abi", "ini", "wi", "chi", "bid", "ib", "ga", "si", "bc", "obi", "b", "Bi", "mini", "nb", "BI", "bs", "pi", "ji", "ki", "li", "isi", "oi", "dat", "gb", "bank", "fa", "bm", "di", "agi", "qi", "oci", "eni", "umi", "cu", "xi", "fi", "cli", "mu", "zi", "bis", "bin", "ti", "phi"], "os": ["ors", "OS", "as", "cs", "dos", "ot", "so", "out", "oss", "us", "bos", "oes", "s", "i", "ds", "pos", "des", "vs", "ws", "oa", "nos", "io", "ks", "oS", "los", "ou", "cos", "is", "fs", "bs", "fits", "oos", "xs", "ios", "aos", "outs", "co", "ns", "es", "obs", "Os", "o", "osi", "ob", " bos", "oses", "ops"]}}
{"id1": "13122204", "id2": "1769771", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackFile", "UnzipProject", "unpatchProject", "unpackProject", "unzipProject", "unzipFile", "unarchiveProject", "unpackmodel", "unarchiveFile", "Unarchivemodel", "UnzipModel", "UnarchiveProject", "unpatchModel", "UnzipFile", "unarchiveModel", "unarchivemodel", "unzipmodel", "unpatchFile", "unpatchmodel", "UnarchiveModel", "unpackModel", "Unzipmodel", "UnarchiveFile"], "filename": ["source", "File", "fp", "uri", "path", "username", "kl", "download", "f", "model", "title", "il", "fil", "txt", "l", "src", "loc", "folder", "module", "location", "bf", "FILE", "directory", "url", "database", "name", "fd", "files", "fits", "jet", "SourceFile", "string", "fn", "Filename", "file", "utf", "nil"], "tempdir": ["TempDir", "TempDIR", " tempDir", " tempDIR", " temppath", "Tempdirectory", "Tempdir", "tempfolder", "tmpDir", "tmpdirectory", "tempDIR", "tmppath", "tmpdir", "temfolder", "tempDir", " tempfolder", "temdir", " tempdirectory", "tempath", "Tempfolder", "temppath", "temDir", "temdirectory", "tmpfolder", "tmpDIR", "tempdirectory"], "dest": ["source", "flat", "result", "prop", "output", "sync", "st", "session", "inner", "home", "store", " Dest", "nt", "txt", "de", "trans", "src", "rest", "cdn", "default", "loc", "walker", "folder", "done", "builder", "transform", "later", "export", "sup", "tmp", "log", "cont", "proc", "die", "transfer", "ui", "zip", "obj", "gen", "dist", "dat", "comb", "di", "exit", "handler", "usr", "test", "desc", "tar", "file", "temp", "std", "wb", "Dest", "walk", "dir", "opt", "target", "delete", "dc"], "fis": ["fsis", "fliss", "fiss", "filei", "flis", "fileis", " fid", " fiss", "fileisa", "fsbis", "filebis", "liss", "fileid", "lis", "flisa", "fid", "fisa", " fi", "li", "fbis", "fileiss", "fi", "lid", "flbis", "fsisa", "fsiss"], "BUFFER": ["MAFIX", "CUFF", "BUVEN", "MAFER", " BUFF", "SAPER", "TAVER", "BUVER", "MAPER", " BUFER", "SAUCK", "BOFIX", "UPVER", "UPVEN", "BOFFER", "BUFIX", "BOFER", " BUFIX", "TAPER", " BUUCK", "BOPER", "UPFF", "CUUCK", "BUPER", "CUFFER", "CUVEN", "SAFFER", "UPFFER", "BUFF", " BUPER", "TAFFER", "CUPER", "SAVER", "CUVER", " BUVER", " BUVEN", "BUFER", "BUUCK", "TAUCK", "MAFFER"], "zis": [" zas", "dbis", "zins", "jos", "zipis", "zii", "zipisa", " zIS", "xos", "zisa", " zii", "zipin", "xiss", "zIS", "yIS", "xii", "zipins", " zos", "Zisa", "zists", "jists", "yin", "diss", "zas", "xis", "ziss", "zos", "Zas", "jis", "zbis", "zipas", "ji", " zi", " zists", " zins", " ziss", "zipIS", "dii", "xbis", "xists", "xi", "yisa", "dis", " zbis", "Zins", "zin", "zi", "Zis", " zin", "yis", " zisa"], "entry": ["match", "ent", "source", "result", "se", "ace", "ry", "inner", "cat", "Entry", "info", "archive", "e", "ie", "nt", "de", "ident", "enter", "image", "cel", "line", "or", "record", "module", "ce", "la", "valid", "next", "si", "name", "ries", "pe", "ou", "lc", "spec", "ge", "server", "zip", "je", "rc", "li", "connection", "element", "file", "way", "porter", "part", "row", "pack", "feed", "her", "reader", "id", "end", "iterator", "inc", "jo"], "count": ["last", "buffer", "cache", "current", "length", "c", "f", "len", "use", "e", "i", "max", "pos", "line", "val", "read", "ind", "writer", "in", "core", "limit", "next", "base", "name", "log", "b", "allow", "add", "low", "code", "counter", "number", "time", "index", "list", "size", "Count", "cond", "coll", "write", "sum", "_", "weight", "iter", "file", "part", "key", "feed", "id", "end", "type", "start"], "data": ["message", "buffer", "result", "media", "str", "length", "DATA", "load", "shift", "info", "len", "bytes", "input", "pos", "image", "read", "record", "format", "zero", "next", "a", "base", "name", "array", "number", "dat", "body", "index", "size", "alpha", "write", "raw", "batch", "block", "value", "pack", "feed", "id", "reader", "start", "d", "la", "content"], "fos": ["xops", "bos", "foes", "xos", "dfos", "dfops", "afops", "foos", " fops", "dfoos", " fOS", "bops", " foes", "afis", "afOS", "afos", "xoes", " foos", "xoos", "fOS", "bOS", "bis", "fops", "dfoes"]}}
{"id1": "21491791", "id2": "22442270", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 0, "substitutes": {"run": ["work", "call", "create", "app", "invoke", "all", "command", "running", "Run", "func", "build", "process", "spawn", "fork", "job", "log", "execute", "runner", "code", "exec", "worker", "test", "loop", "unit", "apply", "start"], "input": ["work", "text", "source", "flow", "form", "out", "reading", "client", "inner", "instance", "config", "state", "view", "Input", "driver", "control", "conn", "image", "read", "readable", "data", "loader", "in", "resource", "internal", "storage", "up", "io", "initial", "address", "index", "connection", "worker", "stream", "raw", "parser", "file", "request", "feed", "entry", "user", "iterator", "audio", "context", "active"], "output": ["source", "text", "filename", "cache", "writers", "out", "generated", "path", "config", "written", "environment", "page", "writing", "console", "control", "image", "data", "web", "object", "resource", "later", "Writer", "document", "job", "log", "outer", "operation", "letter", "index", "connection", "exit", "queue", "write", "Output", "office", "put", "file", "temp", "response", "end", "unit", "user", "parent", "network", "target", "application"], "reader": ["source", "client", "reading", "inner", "author", "system", "view", "slave", "driver", "owner", "manager", "image", "read", "riter", "loader", "oder", "ner", "in", "resource", "builder", "io", "rer", "server", "peer", "book", "worker", "handler", "stream", "wrapper", "rator", "parser", "Reader", "request", "row", "r", "er", "entry", "ri", "audio", "context"], "writer": ["work", "wer", "writers", "out", "wire", "inner", "author", "written", "ter", "w", "driver", "writing", "word", "war", "manager", "or", "riter", "data", "ner", "builder", "ws", "Writer", "editor", "wa", "outer", "player", "writ", "wr", "worker", "connection", "rw", "nw", "write", "wrapper", "wan", "creator", "maker", "office", "request", "wb", "r", "er", "entry", "her", "engine", "ew"], "pump": ["Pumps", "humper", "cump", "pamp", "cumper", " pamp", " pdump", " pumps", "mumper", "mump", "pram", "pumper", "cumping", "pumping", "Pmp", "Pam", "humps", "dump", "ppump", "hprint", "dmp", "prump", "ppumping", " pumper", "mprint", "pdump", " pam", " pmp", "ppumps", "pumps", "Pump", "dumps", "hump", "pam", "Pprint", "Pumper", "prumper", "ppumper", "dumper", " pumping", "Pumping", "pprint", "Pdump", "prdump", "Pamp", "mumps", "pmp", "camp"], "counter": ["sequence", "ener", "cookie", "result", "meter", "current", "timer", "starter", "hello", "inner", "continue", "instance", "author", "rew", "ver", "Counter", "ter", "page", "master", "seed", "processor", "pointer", "keep", "enter", "count", "loader", "ner", "walker", "const", "consumer", "builder", "comment", "ger", "progress", "trace", "zero", "currency", "url", "num", "runner", "server", "outer", "code", "center", "number", "index", "race", "worker", "now", "clock", "repeat", "second", "lr", "layer", "loop", "collection", "version", "row", "step", "er", "r", "entry", "keeper", "inter", "parent", "ception", "offset", "order"], "buffer": ["text", "source", "message", "position", "uf", "port", "length", "buff", "buf", "page", "uffer", "data", "loader", "resource", "binary", "limit", "url", "document", "base", "server", "address", "Buffer", "header", "channel", "queue", "layer", "batch", "reference", "iter", "file", "entry"], "off": ["flow", "offs", "ref", "Off", "own", "Offset", "of", "set", "out", "inner", "info", "head", "ord", "less", "area", "offer", "ff", "pos", "down", "unknown", "addr", "left", "open", "oa", "on", "eno", "low", "ui", "now", "OFF", "fail", "auto", "art", "end", "o", "start", "opt", "offset"], "len": ["lf", "ref", "ln", "length", "all", "lt", "den", "lan", "ler", "lim", "l", "pos", "count", "line", "val", "lon", "loc", "elt", "in", "on", "n", "limit", "url", "name", "log", "width", "lc", "fd", "gen", "fin", "fl", "body", "li", "size", "lock", "ld", "layer", "el", "lin", "ll", "en", "lit", "Len", "lib", "end", "bin"], "rd": ["rx", "rid", "ord", "rr", "RD", "ds", "raid", "RR", "val", "ind", "rs", "ru", " r", "rob", "rm", "ud", "adr", "fd", "hr", "nd", "cr", "rl", "nr", "rss", "rb", "rc", "dr", "db", "fr", "ld", "rw", "dd", "rn", "lr", "rf", "ra", "rt", "xd", "rod", "r", "rh", " prod", "d", "dra", "red", "rand"]}}
{"id1": "16308040", "id2": "15166511", "code1": "    public boolean update(String dbName, Query[] queries) throws ServiceException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        int rows = 0;\n        try {\n            con = getDbConnection().getConnection(dbName);\n            con.setAutoCommit(false);\n            for (int i = 0; i < queries.length; i++) {\n                Query query = queries[i];\n                System.out.println(query.getSql());\n                pstmt = con.prepareStatement(query.getSql());\n                addParametersToQuery(query, pstmt);\n                rows += pstmt.executeUpdate();\n            }\n            con.commit();\n            return rows > 0;\n        } catch (DbException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } catch (SQLException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } finally {\n            closeConnection(con, pstmt, null);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"update": ["method", "create", "result", "set", "sync", "ql", "all", "build", "updated", "where", "Update", "database", "execute", "add", "UPDATE", "write", "sql", "replace", "save", "insert", "end", "id", "apply", "db", "delete", "run"], "dbName": ["dbFamily", " dbRef", "databaseRef", "tablename", "dbname", "dbNames", "connectionNames", "dbRef", "tableName", "databasename", " dbname", "connectionName", " dbNames", "DBname", "DBName", "DbName", "connectionRef", "DBFamily", "tableFamily", "Dbname", "DbFamily", "databaseNames", "databaseName", "connectionname"], "queries": ["shos", "quands", "quos", "quources", "qands", "shands", "questos", "quotes", "veries", "Quicks", "questeries", "vands", "Quands", "questands", "Quotes", "qqs", "qotes", "questqs", "Quqs", "shqs", "sheries", "quicks", "qeries", "qicks", "votes", "qos", "Quources", " quicks", "vqs", "Queries", " quqs", "qources", " quources", "quqs"], "con": ["pen", "xc", "cache", "fun", "uc", "client", "cf", "session", "c", "ac", "ver", "com", "reg", "pl", "ca", "conn", "Conn", "ci", "socket", "an", "close", "win", "act", "pub", "cas", "connect", "core", "bc", "pc", "ann", "conv", "col", "cos", "log", "fac", "cr", "ran", "exec", "Con", "conf", "cur", "rc", "connection", "cc", "h", "mon", "fa", "cond", "cp", "lock", "cm", "coll", "cons", "fc", "en", "un", "cl", "cn", "mc", "row", "crit", "non", "CON", "syn", "user", "db", "co", "can"], "pstmt": ["pactmt", "Pstql", "pqmt", "pctql", " pstut", "psthmd", "Pstm", "pstql", "pprnt", "pqamp", "pctmd", "psthmp", " pactlt", "pptmit", "pppmd", "pastut", "pstrdt", " pactmp", "pctmit", "pprql", "pctlt", "psthmt", "pactamp", "Pstnt", "pprmt", " pppmd", "Pstmt", "pptmt", "pptmd", "pppm", "pstmd", "pstmit", "pstlt", "pssmt", "pctm", "pstnt", "pstrmt", " pstlt", "Pctmt", "pastmd", "Pctql", " pactamp", " pstmp", "pactlt", " pppm", "pactmp", "pctdt", "Pctmd", "ppput", " pactmt", "pstut", " ppput", "Pctdt", "Pstdt", "pstrm", "Pctm", "Pctmit", " pstmd", "psthmit", "pssm", "pctmt", "pctnt", "pqmp", "Pstmp", "pstm", "pssnt", "pctamp", " pstm", " pstamp", "pptmp", "Pctnt", "pctmp", "pastmt", "Pstmd", "pssdt", "Pctmp", "pprm", "pastm", " pppmt", "pqlt", "pctut", "pstamp", "pstdt", "pstmp", "Pstmit", "pppmt", "pstrnt"], "rows": ["tests", "ends", "locks", "lines", "orders", "bugs", "length", "ips", "keys", "s", "issues", "heads", "ues", "count", "projects", "rors", "errors", "gets", "rs", "checks", "rown", "odes", "values", "flows", "ks", "roots", "ries", "objects", "files", "ails", "reads", "times", "ins", "acks", "pages", "blocks", "ches", "loads", "ures", "ings", "runs", "users", "ows", "row", "results", "tracks", "fields", "posts"], "i": ["p", "x", "uri", "z", "c", "ni", "ai", "f", "gi", "ii", "info", "ori", "e", "l", "I", "k", "ci", "yi", "m", "q", "in", "ini", "multi", "ip", "n", "bi", "io", "si", "u", "b", "ui", "pi", "oi", "li", "index", "j", "h", "hi", "mi", "di", "qi", "y", "xi", "part", "slice", "o", "id", "type", "v", "ri", "ti"], "query": ["call", "result", "select", "question", "table", "sync", "parse", "script", "feature", "check", "f", "ql", "model", "e", "command", "qq", "condition", "m", "q", "service", "module", "ic", "iq", "comment", "statement", "action", "database", "name", "eight", "search", "quer", "server", "exec", "code", "sc", "child", "connection", "rule", "scan", "qi", " Query", "general", "sq", "qu", "eries", "block", "sql", "parent", "request", "bug", "row", "key", "entry", "unit", "ctx", "engine", "dq", "error", "Query", "user", "commit"]}}
{"id1": "2324868", "id2": "8182932", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"actionPerformed": ["actionOccuted", "actionCalled", "actionExecuted", "actionPeralled", "actionExecalled", " actionPeruted", " actionExecuted", "actionExecressed", " actionExecformed", " actionExecressed", "actionCuted", "actionPerressed", " actionExecalled", " actionPeralled", "actionExecformed", "actionOccalled", "actionOccressed", "actionPeruted", " actionPerressed", "actionCformed", "actionOccformed", "actionCressed"], "e": ["x", "me", "se", "c", "f", "event", "de", "exc", "et", "an", "E", "q", "ec", "self", "g", "a", "name", "te", "ee", "ae", "es", "ev", "t", "ctx", "v", "events", "type", "ception"], "delim": ["selam", "delcm", " delimmer", " delcm", "elim", "delam", "selim", "Delem", "selm", " delam", "selem", "flimmer", "delimmer", "Delcm", "flim", "delem", "Delam", "flcm", "flam", "Delimmer", "elem", "Delm", "elam", "Delim", "delm", "elm"], "r": ["p", "kr", "rx", "re", "br", "c", "f", "rr", "w", "rar", "i", "l", "writer", "rs", "ir", "ws", "sr", "ru", "n", "ar", "hr", "adr", "R", "cr", "rl", "res", "rss", "rb", "dr", "rc", "fr", "rw", "pr", "lr", "iter", "rt", "tr", "err", "er", "reader", "rh", "nr"], "line": ["text", "source", "lf", "look", "style", "Line", "re", "lines", "str", "cell", "page", "pass", "link", "one", "word", "l", "inline", "val", "data", "nl", "comment", "job", "name", "log", "col", "pe", "lc", "code", "sel", "rl", "number", "split", "sl", "time", "string", "rule", "header", "LINE", "el", "lin", "cl", "block", "value", "file", "row", "response", "key", "entry", "id", "reader", "end", "le", "feed", "fin", "no"], "url": ["ls", "org", "uri", "client", "path", "Url", "f", "link", "l", "loc", "blog", "web", "nl", "resource", "sr", "www", "base", "log", "server", "host", "URL", "rl", "fl", "sl", "connection", "string", "fr", "ur", "lr", "file", "pull", "ssl", "err", "ob", "jar", "http"], "conn": ["p", "fp", "out", "sync", "cf", "ctrl", "client", "cb", "c", "f", "dc", "Connection", "w", "nt", "l", "socket", "Conn", "loc", "con", "open", "pub", "n", "io", "connect", "ann", "conv", "cr", "ch", "gr", "api", "rc", "cur", "connection", "nc", "lock", "cp", "rn", "enc", "coll", "pr", "cl", "cm", "sql", "cn", "rt", "ssl", "err", "ct", "ctx", "db", "co", "http"], "wr": ["wer", "wy", "kr", "Wr", "rx", "out", "wk", "wd", "rr", "w", "wt", "mr", "vr", "rar", "war", "riter", "writer", "rs", "sr", "Writer", "wa", "wx", "hr", "fw", "cr", "res", "gr", "rss", "dr", "rb", "wh", "fr", "rw", "shr", "wrap", "WR", "pr", "write", "nw", "wm", "rt", "err", "wb", "wave", "wl", "RW", "rh", "nr", "wal", "ew"], "tokens": ["pargen", "Tokoks", "tokenens", "takos", "targens", "Taken", "itokenets", "token", "targelines", "tokenets", "Tokens", "pargens", "takets", "takelines", "tkicks", "takens", "takoks", "targen", "toyen", "tokos", "tokoks", "tokets", "Takicks", "Takens", "torkicks", "Tokicks", "pargets", "itokenos", "toyets", "tokenos", "tokicks", "Token", "tkens", "pokets", "torken", "targets", "toyens", "itokens", "tkoks", "torkens", "tken", "itoken", "takicks", "tOKelines", "tokelines", "tOKen", "tokenen", "poken", "tOKens", "torkoks", "pargelines", "itokenens", "toyos", "itokenen", "taken", "pokelines", "itokets", "Takoks", "itokos", "tOKets", "pokens"], "in": ["init", "ln", "inn", "str", "out", "gin", "pin", "inner", "ina", "i", "input", "inas", "sin", "IN", "data", "ini", "win", "con", "n", "isin", "bin", "arin", "io", "vin", "it", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "kin", "pull", "err", "oin", "reader", "zin", "din", "tin", "ic"]}}
{"id1": "22268798", "id2": "8801436", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["createContent", "buildResource", "buildContent", "loadResource", "getContents", "loadcontent", "getcontent", "createContents", "buildContents", "getResource", "buildcontent", "loadContent", "createResource", "loadContents", "createcontent"], "principal": ["prunctential", "prercipal", "Princunctential", "pruncteter", "princeter", "prerceter", "Princincipal", "prunctipal", "Princincificate", "pricipificate", "Princuncteter", "pricipeter", "Princunctipal", "pricipipal", "princificate", "prunctificate", "prercificate", "prercential", "Princunctificate", "Princincential", "princential", "Princinceter", "pricipential"], "path": ["text", "source", "method", "property", "prop", "uri", "client", "Path", "instance", "info", "link", "PATH", "ath", "root", "pointer", "project", "data", "loader", "object", "location", "resource", "format", "context", "class", "next", "name", "api", "string", "prefix", "file", "request", "part", "user", "parent", "node", "pattern"], "version": ["current", "json", "depth", "str", "out", " versions", "vision", "versions", "date", "ver", "model", "VERSION", "level", "project", "val", "release", "object", "resource", "format", "server", "string", "Version", "value", "parent", "v", "node", "target"], "properties": ["types", "property", "ps", "prop", "perties", "json", "ips", "state", "options", "resources", "data", "metadata", "values", "Property", "objects", "params", "address", "features", "details", "settings", "Pro", "plugins", "pro", "results", "items", "classes", "fields"], "uniqueName": ["stringName", " uniquename", " uniqueTime", "basePath", "filename", "basename", "blockPath", " uniqueType", "uniqueKey", "filePath", "UniqueTime", "Uniquename", "fileTime", "stringKey", "UniquePath", "uniqueType", "baseKey", "UniqueName", "stringPath", "blockType", "stringname", "uniquePath", "fileName", "baseName", " uniqueKey", " uniquePath", "UniqueType", "uniqueTime", "blockName", "UniqueKey", "blockKey", "uniquename"], "url": ["ls", "source", "position", "uri", "client", "Url", "download", "f", "bb", "this", "page", "link", "l", "conn", "image", "build", "loc", "found", "web", "object", "location", "resource", "proxy", "open", "www", "base", "name", "log", "server", "host", "URL", "address", "sl", "string", "channel", "layer", "el", "ll", "coll", "html", "file", "ssl", "feed", "ob", "user", "parent", "error", "http"], "content": ["source", "message", "create", "remote", "result", "copy", "media", "output", "current", "client", "cache", "cf", "cover", "c", "load", "instance", "config", "ac", "this", "model", "page", "update", "ca", "conn", "image", "complete", "default", "condition", "data", "const", "object", "resource", "proxy", "ce", "location", "comment", "core", "document", "cont", "lc", "ext", "host", "code", "server", "change", "child", "address", "container", "section", "handler", "cm", "layer", "wrapper", "full", "coll", "creator", "Content", "temp", "file", "key", "response", "reader", "user", "parent", "common", "node"], "connection": ["relation", "position", "uri", "client", "connected", "session", "c", "config", "Connection", "http", "control", "conn", "image", "loc", "data", "con", "object", "resource", "context", "open", "proxy", "communication", "io", "directory", "connect", "character", "database", "server", "pool", "number", "container", "string", "channel", "handler", "coll", "creator", "response", "reader", "section", "application"], "mimeType": ["mmimeInfo", "mimesType", "mIMEInfo", "miveInfo", "MimeType", "mangPath", "mimeName", "mmimeType", "MIMEtype", "mimePath", "mimeInfo", "mimetype", "Mimetype", "mIMEName", "metyInfo", "mmiveType", "mIMEtype", "metyType", "mimestype", "MimeName", "mmimetype", "mIMEPath", "mangName", "MIMEPath", "mangType", "mmivetype", "MIMEName", "mangtype", "mivetype", "miveType", "mmiveInfo", "mimesPath", "MimePath", "MIMEType", "mIMEType", "metytype", "mimesName"]}}
{"id1": "10218878", "id2": "732800", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFileFile", "DecodeMapfile", "DecodemapFile", "DecodeFileFiles", "DecodeFilefile", "DecodeDataFiles", "DecoderMapFiles", "DecodemapFiles", "DecoderFileFile", "Decodemapfile", "DecoderMapFile", "DecoderFileFiles", "DecoderFilefile", "DecodeDataFile", "DecodeMapFiles", "DecodeDatafile", "DecoderMapfile"], "mapFile": ["addressFull", "MapLog", "loadfile", "batchUrl", "loadFull", "fileFile", "mapFull", "MapUrl", "mapfile", "MapFile", "mapLog", "loadTable", "filefile", "apperUrl", "addressTable", "fileTable", "apperLog", "loadFile", "mapTable", "addressfile", "mapUrl", "batchFile", "fileFull", "batchLog", "addressFile", "apperFile"], "outputFile": ["OutputStream", " outputfile", "outputDir", "inputFiles", "inputFile", "responseStream", "inputFolder", "inputDir", "responsefile", "responseFiles", " outputStream", " outputFiles", "outputFolder", "Outputfile", "responseFile", "outputStream", "OutputDir", "outputfile", " outputDir", "OutputFile", "OutputFiles", "OutputFolder", "outputFiles", " outputFolder"], "magicKey": ["MagicKey", "magicLink", "specialkey", "specialSecret", " magicK", "magicSecret", "prefixLink", "MagicLetter", "cacheKey", "cacheChar", " magicSecret", " magicLink", "Magickey", "magicK", " magickey", " specialKey", "prefixKey", " specialkey", "specialKey", " specialLetter", "cachekey", "techLink", " magicKEY", "magickey", " specialK", "cacheSecret", "prefixKEY", " magicChar", "techkey", "techKEY", "magicChar", "specialChar", "MagicK", "magicLetter", "magicKEY", "techKey", "prefixkey", " magicLetter"], "buffer": ["source", "message", "shape", "position", "cache", "result", "token", "bar", "length", "memory", "pad", "buff", "bb", "buf", "seed", "input", "uffer", "count", "read", "FFER", "data", "writer", "binary", "comment", "document", "url", "base", "array", "b", "null", "code", "transfer", "address", "Buffer", "variable", "header", "stack", "queue", "layer", "batch", "reference", "iter", "pause", "row", "wave", "feed", "slice", "reader", "offset"], "nread": ["nreads", "Nload", "Nfind", " nRead", "pload", "NRead", "Nread", " nload", "enreads", "nwrite", "enwrite", " nwrite", "enread", "pread", "nereader", "nfind", "neread", "neRead", "nload", "enfind", "nreader", "newrite", "pRead", "Nreader", "pwrite", "Nreads", " nfind", "nRead", "enRead", "Nwrite", " nreads", " nreader"], "map": ["work", "pre", "source", "flow", "group", "make", "message", "create", "app", "bridge", "copy", "cache", "media", "out", "parse", "client", "apper", "cover", "config", "pad", "use", "master", "per", "one", "input", "image", "m", "data", "module", "resource", "MAP", "open", "core", "code", "pool", "transfer", "address", "index", "list", "header", "lock", "over", "stream", "cm", "layer", "ap", "write", "block", "file", "wave", "pack", "key", "maps", "pair"], "output": ["flow", "cut", "cache", "out", "update", "config", "model", "page", "control", "console", "input", "image", "global", "pot", "data", "web", "module", "object", "other", "resource", "export", "core", "document", "log", "ou", "outer", "utils", "function", "operation", "address", "number", "connection", "external", "exit", "queue", "layer", "write", "reference", "Output", "sort", "put", "file", "office", "ilo", "response", "o", "unit", "oper", "error", "target", "run", "application"], "i": ["p", "x", "uri", "length", "z", "c", "f", "ai", "gi", "ii", "info", "e", "l", "I", "ci", "uli", "m", "ini", "in", "multi", "ip", "io", "bi", "a", "si", "u", "b", "it", "ui", "pi", "oi", "ji", "li", "j", "di", "qi", "xi", "t", "mu", "slice", "id", "o", "zi", "v", "ri", "ti", "phi"]}}
{"id1": "6963063", "id2": "11005804", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"mas": ["ls", "images", "mis", "as", "ums", "rules", "cs", "parts", "cats", "phas", "mm", "MA", "forms", "marks", "bas", "mos", "mast", "astics", "ama", "ta", "mat", "inas", "asa", "meta", "pos", "data", "names", "mes", "afi", "mad", "missing", "ras", "cas", "asm", "pa", "ages", "sa", "ga", "a", "ms", "Las", "os", "spec", " ma", "lambda", "amas", "ia", "ima", "params", "sha", "ams", "faces", "central", "features", "nas", "ins", "amps", "ias", "fa", "alpha", "las", "lam", "xs", "ra", "mc", "asia", "space", "ma", "months", "mag", "la", "phi"], "sort": ["pre", "ort", "edit", "adjust", "init", "style", "position", "ist", "lower", "Sort", "seq", "parse", "orient", "update", "alias", "alt", "ii", "s", "use", "place", "master", "l", "pos", "default", "ind", "loc", "vert", "g", "axis", "num", "search", "label", "split", "ji", "min", "index", "list", "size", "par", "alpha", "ul", "scale", "filter", "replace", "lib", "offset", "part", "err", "sign", "slice", "diff", "o", "id", "type", "parent", "start", "cmp", "hide", "order"], "j": ["p", "x", "J", "ij", "z", "f", "ii", "ie", "l", "I", "k", "ci", "ind", "m", "q", "n", "bi", "a", "si", "b", "num", "u", "it", "is", "ui", "pi", "ji", "oi", "li", "jc", "h", "jp", "y", "xi", "o", "v", "js", "d"], "i": ["x", "init", "uri", "ij", "z", "inner", "c", "ni", "ai", "f", "gi", "ii", "info", "ix", "ori", "e", "ie", "I", "k", "ci", "uli", "yi", "abi", "m", "ini", "in", "data", "multi", "ip", "io", "bi", "iu", "a", "si", "u", "b", "it", "lc", "ui", "ik", "pi", "oi", "ji", "li", "api", "index", "h", "hi", "mi", "di", "qi", "jp", "xi", "temp", "fi", "cli", "mu", "slice", "o", "id", "v", "ri", "ti", "phi"]}}
{"id1": "15745420", "id2": "300397", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"download": ["source", "copy", "output", "load", "update", "gz", "archive", "dump", "process", "data", "release", "open", "binary", " upload", "transfer", "Download", "zip", " Download", "exec", " transfer", "append", "upload", "save", "register", " downloading", "handle"], "address": ["source", "message", "remote", "position", "Address", "mode", "uri", "output", "port", "ace", "path", "config", "point", "page", "pointer", "enter", "image", "localhost", "addr", "data", "service", "object", "location", "resource", "email", "ip", "base", "name", "array", "host", "server", "number", "index", "string", "region", "prefix", "order", "reference", "ress", "attribute", "request", "route", "key", "type", "target", "content"], "localFileName": [" localPlaceName", "LocalSourceFileName", "localDirAddress", "globalFileAddress", "localFilePath", "LocalFileLocation", "localDirInfo", "localStreamLocation", " localFilename", " localPageSize", "localImageType", "localStreamPath", "localPlaceLocation", "localDirPath", "localPagePath", "localFilesName", " localFileInfo", "localSourceFilePath", "localImageName", "LocalSourceFileType", "localStreamname", "globalFileName", "localFilesPath", "globalSourceFileName", "localSourceFileNames", "LocalSourceFileNames", "localImageInfo", "localFilenameLocation", "localFilenameType", "LocalFileName", "localfileName", "localPageInfo", "localfileType", "localPlaceName", "localSourceFileName", " localFileSize", " localPlacename", "localfileNames", "localfileLocation", "localFileType", "localFileInfo", "localFilesInfo", "globalSourceFileAddress", " localFileType", "localPagename", "globalFileInfo", "localSourceFileType", "localPageName", "localSourceFileInfo", "localFilenameName", "localFileLocation", " localPlacePath", "localStreamName", "localFileSize", " localPlaceLocation", "globalSourceFileInfo", "localPageType", "localFilesAddress", "localFilenameNames", "localFileNames", "globalSourceFilePath", "localSourceFileLocation", "LocalFileType", "localFileAddress", "localDirName", "LocalSourceFileLocation", " localPageInfo", " localPageName", "localSourceFileSize", "LocalFileNames", " localPageType", " localFilePath", "localFilename", "localImageSize", "localPlacename", "globalFilePath", "localPageLocation", "localPageSize", " localFileLocation", "localPlacePath", "localSourceFileAddress"], "ext": ["text", "x", "fort", "app", "str", "fx", "path", "config", "f", "info", "expl", "alt", "extra", "ex", "txt", "word", "qt", "addr", "data", "req", "prot", "format", "ect", "xp", "name", "zip", "dist", "Ext", "string", "exp", "enc", "test", "file", "err", "EXT", "xt", "type", "content"], "temp": ["p", "ht", "local", "source", "form", "tp", "flat", "cache", "output", "session", "clean", "empty", "emp", "memory", "f", "home", "c", "store", "this", "wp", "porary", "ex", "txt", "w", "input", "loc", "data", "folder", "tem", "Temp", "stable", "old", "Tem", "valid", "original", "tmp", "base", "fake", " temporary", "null", "it", "server", "zip", "api", "now", "lock", "cp", "wrap", "full", "iter", "test", "file", "mount", "parent", "t", "template", "er", "wl", "unit", "pipe", "v"], "out": ["call", "init", "copy", "output", "sync", "client", "net", "inner", "s", "not", "this", "w", "ex", "i", "socket", "OUT", "line", "image", "or", "writer", "con", "other", "on", "io", "up", "and", "log", "name", "b", "null", "outer", "server", "obj", "exec", "password", "connection", "exp", "lock", "prefix", "plain", "Out", "write", "In", "outs", "inc", "again", "Output", "off", "file", "lib", "part", "parent", "ssl", "cli", "err", "o", "login", "key", "bin"], "conn": ["init", "cache", "fp", "uc", "client", "sync", "Url", "c", "ac", "ai", "config", "Connection", "cmd", "nt", "l", "socket", "Conn", "ci", "func", "con", "close", "open", "act", "n", "connect", "nn", "conv", "b", "server", "URL", "exec", "obj", "ch", "connection", "nc", "fr", "cp", "enc", "cm", "coll", "ll", "impl", "cn", "ssl", "cli", "ct", "inc"], "in": ["source", "init", "inn", "client", "sync", "pin", "inner", "ac", "f", "s", "i", "input", "l", "socket", "image", "or", "get", "IN", "data", "by", "ini", "con", "win", "n", "up", "isin", "din", "it", "is", "exec", "nin", "min", "index", "ins", "connection", "lock", "cin", "lin", "In", "inc", "again", "lib", "kin", "part", "pull", "r", "cli", "login", "id", "reader", "diff", "bin"], "url": ["ls", "source", "uri", "client", "path", "Url", "f", "i", "l", "socket", "image", "cdn", "loc", "blog", "web", "open", "www", "n", "base", "bel", "b", "server", "host", "URL", "rl", "sl", "connection", "string", "channel", "layer", "ll", "impl", "file", "ssl", "r", "ob", "db", "http"], "buffer": ["sequence", "message", "position", "result", "cache", "uf", "length", "memory", "pad", "buff", "bb", "buf", "bytes", "slave", "input", "uffer", "padding", "border", "read", "FFER", "data", "binary", "comment", "limit", "b", "null", "transfer", "number", "Buffer", "queue", "layer", "batch", "block", "iter", "reference", "value", "row", "wave", "feed", "slice", "reader", "flush", "bin", "offset"], "numRead": ["numread", "numberWritten", "NumWritten", "NumReader", "numWrite", "numberRead", " numReader", " numBuild", " numread", "numberBuild", "nread", "numberread", "NumWrite", "numBuild", " numWrite", "commonWrite", "commonReader", "commonWritten", "Numread", "umWrite", "nWritten", "commonRead", "nWrite", "numReader", "nBuild", "nRead", "NumRead", "umRead", "umWritten"], "numWritten": [" numOutput", "numberWritten", "multiWrite", "NumWritten", "numberOutput", "multiWritten", "numWrite", "numberRead", "numberWrite", "Numwritten", " numwritten", "NumWrite", "NumWrit", " numWrit", "multiwritten", " numWrite", "multiWrit", "NumOutput", "numOutput", "NumRead", "numwritten", "numWrit"], "oldArq": ["oldARque", "OldARque", " oldArQ", "oldarqu", "oldDarqu", "OldAcQ", "oldParg", "oldParq", "oldAcqs", "oldArtp", "OldArQ", "oldAcq", "OldArqu", "oldDarque", "OldArque", "OldARp", "oldAcque", "oldArtQ", "oldarg", "OldAcqs", "OldArq", "oldArtqs", "OldArch", "OldArp", " oldParque", "oldArp", " oldArg", "OldARch", "oldARqu", "oldArtquest", "OldAcquest", "oldArch", " oldParq", "oldArtque", "oldArquest", "oldARch", " oldParQ", "oldArqs", "oldDarq", "oldArtq", "oldArQ", "oldarch", "oldParQ", "oldarQ", "OldARq", "oldDarch", "oldarque", "oldAcquest", "OldAcq", "oldARquest", "oldARqs", "oldARg", "oldAcQ", "oldARQ", "oldAcp", "oldParque", "OldArquest", "OldARqu", "oldarq", "oldArg", "oldARp", "oldARq", "oldArque", "OldARQ", "oldArqu", " oldArque", " oldParg", "OldArqs"], "nomeFinal": ["noeFinal", " nomesfinal", "nomesFin", "noefinal", "nomenFin", "Nomefinal", " nomefinal", "nukeFin", "nomenfinal", "Nomesfinal", "nomeFin", "nomesfinal", "nomenFinal", "navefinal", "nomesFinal", "nukefinal", "NomesFinal", " nomeFin", " nomesFin", "naveFinal", "nomefinal", " nomesFinal", "NomeFinal", "nukeFinal"]}}
{"id1": "810342", "id2": "22734545", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doVersioncheck", "doVersionScan", "doFeatureScan", " doVersionScan", "doVersionUpdate", "doFeaturecheck", "doFeatureCheck", "doVersioncheck", "doChangeCheck", "doFeatureUpdate", "doversioncheck", " doversionCheck", " doversioncheck", "doversionScan", " doversionUpdate", "doChangeUpdate", " doVersionUpdate", "doChangecheck", "doversionCheck", "doChangeScan", " doversionScan", "doversionUpdate"], "view": ["video", "cache", "out", "session", "config", "head", "event", "vol", "image", "comment", "base", "display", "pool", "see", "div", "views", "fail", "can", "http", "group", "form", "im", "client", "check", "ve", "this", "model", "use", "show", "by", "object", "self", "up", "ou", "user", "edit", "style", "update", "View", "link", "e", "input", "screen", "box", "VIEW", "sel", "container", "gu", "block", "html", "value", "widget", "port", "cell", "page", "manager", "review", "window", "server", "change", "ui", "query", "body", "index", "vis", "list", "lock", "el", "full", "row", "layout", "v"], "url": ["ls", "source", "gl", "buffer", "uri", "browser", "length", "path", "Url", "download", "f", "bb", "link", "l", "socket", "image", "blog", "loader", "loc", "web", "resource", "open", "hub", "builder", "location", "email", "www", "base", "log", "name", "b", "null", "server", "host", "URL", "zip", "sl", "address", "string", "fr", "stream", "ul", "ll", "impl", "file", "bug", "ssl", "ob", "id", "rel", "http"], "in": ["source", "as", "init", "buffer", "inn", "out", "pin", "inner", "ac", "s", "input", "socket", "sin", "IN", "data", "m", "ini", "win", "con", "resource", "binary", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "again", "rin", "file", "err", "login", "reader", "bis", "din", "doc"], "bin": ["init", "buffer", "gin", "inn", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "ban", "IN", "abi", "loader", "ini", "win", "record", "con", "binary", "bot", "bi", "arin", "b", "vin", "bn", "fin", "nb", "is", "body", "lock", "cin", "lin", "spin", "ruby", "file", "lib", "oin", "login", "reader", "din", "run"], "line": ["text", "lf", "look", "Line", "lines", "str", "out", "parse", "pin", "cell", "page", "link", "e", "one", "word", "l", "val", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "base", "name", "log", "b", "lc", "job", "pe", "code", "ge", "zip", "letter", "sl", "string", "LINE", "el", "lin", "range", "cl", "ine", "block", "write", "file", "part", "row", "key", "entry", "end", "le", "unit", "type", "id", "user", "jo"], "version": ["secret", "python", "video", "position", "license", "cover", "feature", "update", "download", "date", "ver", "author", "model", "versions", "VERSION", "driver", "project", "image", "install", "release", "format", "latest", "vert", "name", "device", "null", "server", "host", "code", "beta", "string", "Version", "patch", "dev", "option", "plugin", "value", "bug", "pull", "support", "id", "unit", "type", "v", "section", "vision", "user"], "build": ["work", "make", "style", "clean", "load", "update", "home", "ver", "built", "info", "use", "lease", "link", "show", "how", "image", "install", "follow", "release", "Build", "builder", "help", "print", "valid", "job", "log", "add", "building", "uild", "hold", "post", "tag", "patch", "lock", "block", "mount", "bug", "pull", "row", "feed", "boot", "unit", "get", "run", "rel", "http"]}}
{"id1": "4686922", "id2": "23672408", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceInFiles", "extractResourceAndfile", "extractResourcesAsfile", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceAsFiles", "extractResourceAndFiles", "extractResourceAndFile", "extractResourcesToFile", "extractResourcesAsFile", "extractResourcesAsResource", "extractResourceAsfile", "extractResourcesAsFiles", "extractResourceToResource", "extractResourceInFile", "extractResourcesToResource", "extractResourceInfile", "extractResourceAsFile", "extractResourceTofile", "extractResourceAndResource", "extractResourceInResource", "extractResourceAsResource", "extractResourceToFiles"], "resourcePath": ["sourceId", "stringFolder", "servicepath", "stringpath", "resourceId", " resourceUrl", " resourceId", " resourceFolder", "servicePath", "stringPath", "ResourceUrl", "sourcePath", " resourcepath", "resourceUrl", "ResourceId", "serviceFolder", "sourceUrl", "sourcepath", "resourcepath", "resourceFolder", "ResourcePath", "Resourcepath"], "dest": ["source", "filename", "result", "flat", "prop", "output", "sac", "path", " destination", "config", "home", "store", " Dest", "txt", "de", "trans", "src", "project", "default", "resources", "data", "const", "folder", "resource", "done", "later", "img", "sup", "class", "tmp", "die", "transfer", "destroy", "dist", "comb", "desc", "file", "temp", "route", "wb", "Dest", "contract", "target", "content"], "in": ["source", "as", "init", "rec", "re", "gin", "inn", "inner", "c", "f", "this", "plus", "pass", "i", "input", "socket", "inside", "conn", "image", "sin", "IN", "ini", "con", "resource", "win", "n", "up", "isin", "arin", "url", "din", "b", "is", "nin", "ins", "connection", "cin", "thin", "lin", "In", "inc", "again", "like", "rin", "file", "kin", "r", "login", "id", "reader", "bin"], "out": ["source", "cookie", "app", "copy", "cache", "output", "sync", "client", "net", "f", "at", "s", "this", "all", "ax", "w", "ex", "i", "one", "socket", "conn", "OUT", "image", "norm", "writer", "up", "n", "io", "a", "b", "null", "outer", "server", "ext", "cos", "exec", "obj", "ins", "Out", "In", "auto", "outs", "inc", "again", "off", "file", "temp", "lib", "parent", "err", "o", "boot", "user", "bin", "outside", "co"]}}
{"id1": "14390569", "id2": "17729554", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"title": ["itle", "text", "message", " Title", "filename", "summary", "ppa", "license", "page", "phrase", "notes", "image", "data", "format", "resource", "heading", "description", "url", "name", "subject", "TIT", "label", "theme", "msg", "chapter", "Title", "body", "term", "string", "header", "size", "prefix", "alpha", "details", "html", "desc", "itles", "version", "part", "layout", "id", "type", "section", "content"], "imageURL": ["imgURL", "imgUrl", "imgPath", "fileURL", "filePath", "imageUrl", "imageurl", "fileURI", "ImagePath", "imageURI", "mediaUrl", "pictureurl", "pictureURL", "imagePath", "pictureUrl", "fileurl", "fileUrl", "mediaURL", " imageurl", " imageURI", " imageUrl", "ImageURI", "imgURI", "pictureURI", "ImageURL", "mediaURI", "ImageUrl"], "jd": ["ssd", "adjdos", "adjd", "jsd", "jdo", "Jb", "ajdo", "ssdo", "argdl", "qdo", "ajdh", "zd", "jackb", "jsb", "jobd", "zb", "jjdo", "qd", "jds", "je", "zf", "qdom", "Jdo", "jdos", "Je", "jjb", " jdo", "Jf", "qdh", "jobdo", "zl", "ajdos", "Jds", "zds", "JD", "ajd", "jdom", "qb", " jf", "jobD", "jjd", " jdom", "jsdo", "zdo", "jackd", "jdd", "argf", "jdl", "ajf", " jD", "jsdh", " jds", "ssdi", "ze", "jD", "Jdos", "jackf", "jf", "jdh", "zdd", "Jdom", " jdi", " jdd", "Jl", "jobb", "ajD", "ajdl", "jackdd", "jdi", "argdo", "adjdo", "ajdi", " je", "adjb", "ssD", " jdl", "Jd", " jdh", "argd", "ajb", "jjdh"], "jl": ["iji", "lp", "lf", "iol", "chal", "igl", "fp", "kl", "zl", "bj", "hl", "elly", "il", "dj", "oji", "l", "bl", "elt", "nl", "jon", "dl", "lb", "JM", "NJ", "kj", "jj", "ja", "kn", "vd", "label", "Label", "ji", "li", "j", "jc", "kel", "eb", "ld", "el", "ll", "lu", "lv", "syn", "cli", "adj", "uj", "wl", "bn"], "icon": ["gn", "text", "uni", "png", "iao", "token", "uri", "alias", "info", "note", "icons", "image", "artist", "resource", "img", "on", "io", "n", "action", "core", "url", "ann", "pic", "label", "picture", "ui", "ico", "Icon", " image", "header", "size", "plugin", "fc", "cha", "eye", "cn", "css", " Icon", "ion", "ic", "bn", "content"], "chooser": ["Chooses", " chooder", "Choose", "joose", "closer", "Choosen", "clressor", "closen", "chooder", "choosen", "choose", "choressor", "chooses", "Chooder", "close", "boose", "jooser", "Chooser", " choressor", "cler", "choer", "dialoser", "jooses", "dialer", "Choer", "dialosen", " choosen", " choose", "boressor", "jooder", "booser", " chooses", "boosen", "dialose"], "jp": [" cp", " pic", " bar", " app", " pa", "bj", " plugin", " mp", " cm", "ja", " gp", " pane", " sp", " dock", " dj", " je", "ji", "Panel", "j", " robot", " js", " j", " bridge", " tmp", " JM", "JP", " obj", " np", " ax"], "jb": ["djbb", "qf", "jsd", "ajf", " jcb", " jsb", "djd", "jsb", "qsb", "djb", "qb", "djcb", " jbb", " jf", "jcb", "jsbb", "jf", "ajsb", "jbb", "qcb", "ajb", "ajcb", "jscb"], "e": ["x", "c", " E", "f", "event", "ie", "de", "exc", "et", "E", "in", "ce", "ec", " Event", "a", "pe", " ate", "te", " fe", "je", "ee", "ae", "ev", "t", "ctx", "v", "ception"], "returnVal": ["resultval", "ReturnValue", "ReturnVAL", "replyVAL", "replyVal", "returnValue", "Returnval", " returnValue", "returnNum", " returnVAL", "resultValue", "ReturnVal", "resultNum", " returnval", "returnVAL", " returnNum", "replyValue", "replyval", "ReturnNum", "returnval", "resultVal"], "file": ["work", "message", "buffer", "File", "out", "parse", "ile", "il", "image", "build", "comment", "directory", "core", "url", "base", "name", "log", "pe", "picture", "pool", "zip", "rule", "queue", "dir", "type", "http", "load", "home", "info", "model", "use", "show", "po", "data", "module", "object", "binary", "play", "force", "io", "book", "files", "live", "future", "auto", "lib", "unit", "user", "parent", "db", "path", "single", "line", "ban", "folder", "FILE", "document", "b", "die", "get", "local", "filename", "fp", "f", "page", "l", "function", "letter", "body", "lock", "handler", "full", "part"], "fileName": [" filePath", "resourcePath", "FileInfo", "filename", "imageName", "imageInfo", "resourceName", "filePath", "fileType", "imageUrl", "binaryPath", " fileType", "binaryName", "resourceInfo", "fileInfo", "imagePath", "FilePath", "resourcename", " filename", "fileUrl", "binaryUrl", "FileName", "imagename", "singlename", " fileInfo", "singleType", "Filename", "FileType", "singleInfo", "singlePath", " fileUrl", "singleName"], "ext": ["p", "alg", "ace", "path", "feat", "f", "ax", "fb", "extra", "ex", "txt", "phrase", "word", "qt", "format", " Ext", "class", " extension", "name", "xp", "sec", "pe", "obj", "ension", "ch", "oct", "Ext", "exp", "enc", "eng", "orig", "desc", "version", "lib", "t", "EXT", "xt", "ct", "type", "v", "abc"], "i": ["p", "ment", "uri", "z", "c", "ni", "ai", "gi", "ii", "info", "I", "ci", "m", "ini", "multi", "ip", "io", "iu", "bi", "a", "si", "v", "u", "b", "mini", "is", "ui", "pi", "api", "li", "j", "mi", "di", "y", "xi", "cli", "o", "id", "bis", "ion", "ri", "ti", "phi"], "doIt": ["diIts", " doNot", "DOIt", "poYou", "skipIts", "hoit", "skipIT", "DOit", "doWhich", "doYou", " doWhich", "diIT", "addNot", "diIt", "doit", "addIt", "skipit", " doIT", "doNot", "odoIT", "doIts", "diit", "addIT", "odoit", "odoIt", " doit", "hoYou", "odoNot", " doYou", "poIt", "hoIT", "doIT", "hoIt", "poIT", "addit", "skipIt", "odoWhich", "DOIT", "DOWhich", " doIts", "poit"], "src": ["attr", "source", "rx", "sb", "uc", "sync", "st", "us", "path", "bb", "gz", "buf", "ources", "input", "ource", "inst", "socket", "cdn", "ff", "rest", "loc", "RC", "rs", "img", "sth", "storage", "sup", "url", "tmp", "bc", "b", "cos", "conv", "sel", "sc", "split", "sl", "secure", "dist", "sub", "rc", "rb", "gb", "cur", "upload", "stream", "impl", "sq", "fc", "desc", "sn", "pull", "fi", "r", "ssl", "Dest", "slice", "ctx", "cb", "target", "cmp", "rel"], "dest": ["source", "uv", "prop", "output", "uc", "st", "config", "home", "wd", " Dest", "trans", "rest", "inst", "cdn", "loc", "done", "dep", "later", "img", "sup", "tmp", "cont", "proc", "die", "gen", "destroy", "dist", "gd", "dat", "comb", "dev", "di", "exit", "ctr", "usr", "desc", "std", "route", "wb", "Dest", "dir", "target", "dc"]}}
{"id1": "12146394", "id2": "9996334", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["MD2crypt", "md4Hash", "md2Hash", "md2Crypt", "md6Hash", "MD2Hash", "MD2Key", "md2Key", "MD5Crypt", "MD5Hash", "md4Key", "md4Crypt", "md6Crypt", "md4crypt", "md5Key", "md6Key", "md2crypt", "md5crypt", "MD2Crypt", "md6crypt", "MD5crypt", "md5Hash", "MD5Key"], "key": ["x", "source", "text", "message", "cookie", "cache", "k", "image", "money", "ip", "air", "core", "base", "name", "code", "power", "zip", "time", "rule", "size", "cer", "y", "temp", "any", "type", "go", "char", "copy", "token", "ace", "sync", "shift", "this", "hash", "use", "seed", "phrase", "root", "word", "none", "data", "magic", "req", "other", "kw", "here", "self", "password", "id", "user", "parent", "order", "pair", "secret", "kid", "call", "cy", "fee", "point", "state", "input", "year", "cert", "ce", "ke", "blow", "number", "proof", "string", "element", "value", "version", "KEY", "my", "no", "length", "wire", "empty", "ask", "date", "material", "kh", "m", "service", "server", "transfer", "ch", "list", "scope", "connection", "lock", "ee", "full", "trust", "row", "ssl", "sign", "carry", "Key"], "salt": ["asalt", "sodium", "southift", "southALT", " sodium", "svort", "asal", "southart", "sval", "osalt", "sessecret", "sesALT", "southalt", "sass", "sal", " ssecret", "sift", "sesalt", "seskey", "asALT", "sesol", "sol", "ssol", "Sal", "osul", "ssALT", "Sodium", "sesort", "assecret", "sesart", " skey", "skey", " sol", "sesift", "southsecret", " sift", "ssass", "SALT", "Salt", "southodium", "sart", " sart", "sALT", " sass", "sort", "osALT", "svalt", "sesal", "osift", " sALT", "svALT", "sesul", "sul", "sesass", "ssecret", "Ssecret", "ssalt"], "_md": ["Newdm", "_key", "_mand", "copycmd", "_mb", "localmd", "localcmd", " _key", "__dm", " _dm", "_dm", "Newcmd", "Newmd", "\u00a0mand", "\u00a0mode", "_cmd", "copydm", "copymd", "\u00a0dm", "_mg", "Newamd", " _cmd", "copykey", " _amd", "_MD", " _nm", " _MD", "_db", "__md", "\u00a0cmd", "_m", " _db", "__amd", "_nm", "_amd", "_mode", "\u00a0md", " _m", "__cmd", "\u00a0nm", "localmb", "localmg", "\u00a0m"], "md2": [" md02", "amd4", "cmd02", "md32", "md4", "md62", "cmd3", "md5", "hdTwo", "MD4", "cmd1", " md1", "amd32", "cmd2", "MD2", " mdTwo", " md5", "cmd4", "amd2", "amd62", " md62", "MD5", "cmd5", "cmd62", "hd62", "MD62", " md32", "amdTwo", " md4", "md1", "hd2", "md02", "hd32", "amd02", "mdTwo", "MD3", "MD1"], "abyFinal": ["saySpecial", "andyFinal", "Babyfinal", "sayInitial", "amyFinal", "BabyFinal", "BabyFinish", "abiesFull", "abyLast", "BabyFull", "abyTotal", "sayFinal", "aberfinal", "abySuccess", "andyLast", "aberInitial", "abiesSuccess", "abyResult", "BabyLast", "butLast", "rayLast", "abiesFinal", "andyInitial", "babyTotal", "babyInitial", "abeFinal", "abeLast", "abySpecial", "babyLast", "amySuccess", "abyfinal", "butInitial", "andyTotal", "amySpecial", "aberFinal", "amyResult", "butFinal", "babyfinal", "andyfinal", "babySpecial", "abeFinish", "rayInitial", "abyFinish", "babyFinal", "babyResult", "abiesResult", "amyInitial", "babySuccess", "aberTotal", "abyFull", "rayFinal", "abiesLast", "abeFull", "abyInitial", "abiesFinish"], "n": ["p", "x", "gn", "span", "inn", "byn", "net", "z", "br", "c", "ni", "f", "yn", "all", "not", "len", "np", "nt", "l", "conn", "k", "none", "N", "nor", "nan", "m", "ner", "ne", "g", "nn", "a", "on", "name", "don", "num", "b", "nb", "number", "na", "nu", "min", "nc", "fn", "pn", "mn", "ng", "nw", "en", "un", "sn", "ns", "y", "cn", "ny", "syn", "t", "non", "dn", "adj", "o", "r", "network", "v", "node", "d", "no"], "j": ["p", "x", "ij", "z", "c", "ni", "jl", "bj", "ii", "dj", "ie", "l", "I", "k", "aj", "ci", "ind", "yi", "q", "ne", "io", "si", "v", "jj", "b", "u", "num", "ja", "ji", "jc", "li", "index", "fr", "di", "qi", "jp", "y", "xi", "adj", "uj", "o", "J", "section", "js", "d"], "i": ["p", "ani", "c", "ni", "ai", "gi", "ii", "e", "ie", "I", "ci", "yi", "ini", "chi", "multi", "iu", "bi", "io", "si", "mini", "ui", "pi", "ji", "ki", "li", "index", "oi", "mi", "di", "qi", "gu", "eni", "y", "xi", "fi", "ali", "mu", "o", "zi", "ri", "ti", "phi"], "sbPasswd": ["sfPasswords", "cbPassword", "sbCrWD", "sbPassw", "sfPassw", "bbParrc", "bbParwd", "bbParword", "cbParphrase", "rbCrw", "sbParwords", "rbPassWD", "cbParwd", "sbCrrc", "cbPassw", "rbCrwd", "sfSecretwd", "sbPassWD", "sbCrwords", "bbPassw", "sbSecretwords", "sbPassrc", "cbParw", "sfSecretword", "sbPassphrase", "sfPasswd", "sbParwd", "sbFailphrase", "sbCrwd", "bbPassword", "sbParrc", "cbPasswd", "rbPassw", "sbPasswords", "sfSecretw", "sbSecretwd", "sbFailw", "sbParWD", "bbPasswd", "sbCrw", "sfSecretwords", "sbParword", "bbPassrc", "sbPassword", "sbParphrase", "cbPassphrase", "cbParword", "rbCrWD", "sbParw", "rbPasswd", "rbPassword", "sbSecretw", "sbCrword", "sbSecretword", "sbFailwd", "bbParw", "sbFailword", "rbCrword", "sfPassword"], "md3": ["md03", "mand3", " md53", "md53", "mand15", "mand23", "cmd3", "md512", "cmd1", " md1", "mdthree", "mag512", "cmd23", "amd15", "amd23", "amd512", "amd3", "cmd2", "MD2", "amdthree", " md23", "md23", "ms3", "mag15", "MD23", "MD53", " md03", " mdthree", "cmd53", "mand512", "md1", "mdthird", "mag23", "amd03", "msthird", "md15", " mdthird", "mag3", "amdthird", "msthree", "MD3", "ms03", "MD1"]}}
{"id1": "13757855", "id2": "23672408", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"process": ["call", "create", "output", "parse", "path", "load", "processing", "update", "construct", "view", "processor", "project", "build", "evaluate", "resource", "transform", "proc", "code", "exec", "Process", "submit", "request", "cess", "handle", "run"], "tpl": [" tplates", " tper", "atplug", "qtcp", "tplate", "tcp", "itpl", "tbl", "tper", "Tper", "pPL", "stpp", "Tplates", "tcl", "ttemplate", "qtfc", "tsl", "qtple", " tcl", "tfc", "qtyl", " tfc", "Tpp", "Tplate", "stpl", "qtpl", "Tpl", "itplate", "tplates", "atplate", "ppl", "lple", " tbl", "Tple", "templates", "atml", "templ", "latcp", "itPL", "fplate", " tple", "temPL", "Tcl", "stplate", " tPL", "Tipl", " tsl", "itplates", "tmpl", "lper", "lplate", " tplug", "Tbl", "tml", "tmyl", " ttemplate", "qtbl", "TPL", "pipl", " tml", "psl", "latyl", "lml", "fpl", "pcl", "lPL", "tpp", "temtemplate", "tmcp", " tpp", "tplug", "latpl", "tPL", "lpl", "Tsl", " tplate", "tyl", "Ttemplate", "Tml", "Tfc", "latple", "atpl", "lcl", "stPL", "tmple", "fml", " tipl", "tipl", "fplug", "tple"], "model": ["message", "result", "media", "copy", "json", "language", "config", "param", "command", "project", "Model", "data", "m", "module", "location", "where", "node", "document", "log", "graph", "params", "conf", "body", "models", "xml", "doc"], "packageName": ["PackageName", "groupUrl", "PackageNames", "packageInfo", "projectKey", "contextName", "groupname", "projectname", "modulename", "projectName", "packageUrl", "contextInfo", "contextname", "moduleName", "moduleUrl", "contextNames", " packageNames", "packageNames", " packagename", " packageInfo", "moduleKey", "groupName", "groupKey", "packageKey", "packagename", "projectUrl", "PackageInfo", "Packagename"], "outFileName": ["OutFileName", "inDirEnd", "outfileOnce", " outDirLine", "outFilenameMode", "outFilenamePath", "outFullname", "outDirEnd", "outFileInfo", "outFileOnce", "outfileEnd", "outDirLine", "difffileName", "difffileTime", "outFullTime", " outDirPath", "outStreamInfo", "outStreamType", "outBufferName", "OUTBufferName", "outDirname", "OUTFileMode", "inDirCopy", "diffFileName", "inDirPath", "outFullInfo", " outFilePath", "OUTFileNames", " outFullType", "OUTBufferNames", "outFullPath", "outBufferHalf", "OutFilename", "OUTFileName", " outFileType", "outfileName", " outFullName", "outFileMode", "outBufferNames", "outfileHalf", "outFileNames", "outFilenameCopy", "outLineTime", "outFileTime", "outFilesTime", "diffFileTime", "outBufferMode", "outFilenameEnd", "outRuleName", "outLineInfo", "outRuleInfo", "outFullNames", " outFileLine", "OutDirLine", "outfileCopy", "outFilename", "outLinename", "outfileNames", "inFilePath", "outStreamName", "OutDirNames", " outDirName", "outFilesName", "OutFileNames", "outDirName", "OUTBufferHalf", "difffileOnce", "outFileType", "outFilenameHalf", "difffileInfo", "OUTFileHalf", "outLineLine", "outFullName", "diffFileInfo", "outFilenameName", "outRuleType", "outFileCopy", "outFileHalf", "outLineNames", "OutFileLine", "outfileInfo", "diffFileOnce", "outfilePath", " outDirTime", "outDirInfo", "OUTBufferMode", "outFilesPath", "outDirTime", "OutDirName", "outFileEnd", " outFileTime", "outLineOnce", "outDirCopy", "outfileMode", " outFullInfo", "outLineName", "outFilesLine", "inFileEnd", "OutDirname", "outFullType", "inDirName", "outDirPath", "inFileCopy", "outDirOnce", "outDirNames", "outFilePath", " outFileInfo", "outFileLine", "inFileName", "outFilenameNames", "outfileTime", "outFullLine"], "xsltParam": ["xldMode", "xslpParam", "xsltVal", "xslicVal", "xslicparam", "xldparam", "xsldparam", "xsldVal", "xslpVal", "xltMode", "xslicParam", "xsltparam", "xltVal", "xslicMode", "xslpMode", "xldParam", "xsltMode", "xsldParam", "xslpparam", "xsldMode", "xltParam", "xldVal", "xltparam"], "artifact": ["ARTifest", "Arturation", "aratfact", "ARTifacts", "aratifacts", " artribution", " arturation", "Artifact", "advertifacts", "Artfact", "artfact", " artifacts", "aratifest", "aratifact", "advertribution", "Artifest", "arturation", "advertifact", "artifacts", "artifest", "ARTfact", "ARTifact", "Artifacts", "Artribution", "artribution", "adverturation"], "destinationPath": ["distinatorKey", "destiationLog", "DestinatingPoint", "destinationAuth", "destinateDir", "datinatePath", "destinatorLocation", "restificationLocation", "destificationPoint", "constinationWidth", "constinationPath", "destinationString", "distinationFile", "desturationHandler", " destificationLog", "destificationPart", "destributionDir", "destificationName", "DestinationText", "tempinatedPath", "distinationCase", "destinatingLocation", "DestinationPart", "datinateLocation", "destationTime", "tempinationDir", "distributionDir", "restinationpath", "destinationLocation", "desticationName", "constinatorDir", "desticationFile", "destinatedPath", "DestinationName", "DestificationPath", "destinateLocation", "destinatorStep", "destiationDir", "destinateTime", "restinationString", "tempinationPath", "destinatorFile", "destinatedDir", "tempinationpath", "destinationsPath", "destplingAuth", "destplingPath", "tempinationHalf", "destinatedPoint", "combinatorPath", "destcreationUrl", "destinatePath", "tempinatedpath", "destributionName", "destplingDir", "destinatorKey", "destignmentPath", "destinationName", "constinationsName", "destinationFile", "destinatedFile", "destensionPoint", "destificationpath", "restinatorPath", "destinationHandler", "constinatorContext", "restinationPoint", "destinatingpath", "distinatorPath", "DestinationPath", "desticationKey", "desticationStep", "destplingWidth", "combinatorName", "distinationpath", "constinationName", "destinationTime", "destinatingName", "destinatingText", "restinatorPoint", "datinationLocation", "distinationName", "constinatorUrl", "destinationPart", "destributionCase", "destinatorPath", " destificationDir", "destinationHalf", "destinationDir", "destinationsPoint", "destinatingPoint", "distinatorStep", "DestinatingText", "restificationPoint", "constinationPoint", "destinationKey", "distinatorName", "destationPath", "destinatorCase", "destificationPath", "destificationLog", "destplingUrl", "distinationCry", "combinationHandler", "destinationpath", "destinatePoint", "distinatorCase", "desticationPart", "destinatorString", "DestinatingName", "destinatorContext", "destinatedHalf", "destinatePart", "restinatorString", "destinationCase", "destinatorName", "destinerContext", "destinateHandler", "destiationPath", "combinationPath", "destificationDir", "destributionPath", "restificationpath", "constinationpath", "destinatorHandler", "DestinationPoint", "distinationDir", "destensionPath", "destiningPoint", "combinatorpath", "destinationStep", "destinateString", "destinerpath", "constinationsPath", "distributionPath", "distinationStep", "destinatorHalf", "destationLocation", " destificationAuth", "constinationDir", "destributionpath", "desturationName", "constinatorPath", "destcreationPath", "destiningPath", "DestinatingPath", "destensionText", "destinateText", "constinatorWidth", "destinatorPoint", "destiningpath", "desturationpath", "destinerPath", "combinationName", "destinatedCase", "destinerDir", "destinatedString", "destinatorCry", "destensionName", "destiningContext", "DestificationPart", "destinatorTime", "destignmentCry", "destinationCry", "destationpath", "distinationKey", "distinatorFile", "constinatorpath", "destinationText", " destinationLog", "datinateTime", "destinationPoint", "restinationHalf", "constinationspath", "restinationLocation", "destinationWidth", "datinationTime", "destplingLog", "desturationPath", "destinatorpath", "datinatepath", "distinationPath", "datinationpath", "destinatedpath", "constinationsPoint", "destinatorDir", "destinatingPath", "destributionCry", "destiationAuth", "destiningDir", "destificationAuth", "combinatorHandler", "combinationpath", "destignmentCase", "destinationContext", "destinatorUrl", "distributionCase", "destinatorWidth", "destinateHalf", "constinationContext", "desticationPath", "destcreationWidth", "DestificationName", "tempinatedHalf", "destinationsName", "destiningName", "tempinatedDir", "restinationPath", " destificationPath", "restificationPath", "destificationLocation", " destinationAuth", "destinatedKey", "destinationUrl", "datinationPath", "destignmentName", "destinationLog", "distinatorCry", "destinatepath", "restinatorHalf", "distributionpath", " destinationDir", "destinatedStep", "constinationUrl", "destinateName", "destinationspath"], "in": ["x", "source", "cache", "c", "config", "ex", "i", "input", "image", "IN", "data", "con", "n", "bin", "name", "min", "ins", "connection", "In", "inc", "r", "t", "reader", "din", "d", "doc"], "out": ["source", "group", "result", "copy", "cache", "output", "str", "client", "path", "session", "point", "with", "store", "page", "state", "w", "ex", "all", "manager", "OUT", "dump", "line", "conn", "writer", "sys", "comment", "ne", "io", "up", "log", "name", "outer", "server", "gen", "obj", "post", "msg", "exec", "pool", "index", "list", "string", "connection", "free", "lock", "prefix", "Out", "write", "full", "outs", "again", "Output", "file", "lib", "temp", "version", "part", "err", "cli", "key", "o", "user", "parent", "bin", "error", "doc"], "root": ["history", " roots", "cache", "json", "path", "instance", "cat", "options", "tree", "meta", "xml", "resources", "loader", "module", "format", "Root", "transform", "values", "url", "graph", "params", "modules", "query", "index", "_", "collection", "include", "r", "results", "id", "parent", "node", "pattern", "roots", " result"]}}
{"id1": "15737836", "id2": "646016", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["del", "create", "sync", "update", "de", "drop", "process", "close", "release", "where", " update", "Delete", "connect", "execute", "exec", "destroy", " destroy", " Delete", "write", "sql", "replace", "save", " create", "remove", "id", "get", "select", "clear"], "site": ["source", "course", "remote", "result", "cache", "set", "sync", "se", "license", "session", "sites", "config", "environment", "ite", "model", "page", "domain", "isite", "note", "conn", "project", "line", "image", "item", " Site", "blog", "data", "install", "module", "object", "location", "node", "class", "si", "base", "name", "database", "edge", "null", "server", "sit", "theme", "db", "target", "profile", "plugin", "sql", "sample", "space", "Site", "unit", "type", "zone", "section", "xml", "network", "status"], "dbo": ["rdBo", " dBo", "rdbc", "drbc", "Dbo", "jBO", "dBO", "pba", "dBo", "pBo", "rdbo", "idebo", " dbi", "pbo", "idebl", "gBO", "pBO", "idbo", " dbos", "Dho", "fBo", "jba", "fbo", "ideho", " dBO", "idho", "gBo", "gbo", "gbos", "jbo", "ideBo", "rdbi", "drbo", " dbc", "DBO", "dbl", "Dba", "drBo", "dbos", "idBo", "jBo", "idbl", "fBO", " dba", "Dbl", "dba", "Dbos", "dho", "drbi", "fba", "dbi", "DBo", "dbc"], "connection": ["relation", "management", "result", "position", "cache", "table", "client", "connected", "session", "translation", "c", "union", "config", "instance", "environment", "Connection", "use", "component", "driver", "manager", "conn", "image", "ci", "condition", "loc", "con", "resource", "builder", "node", "communication", "statement", "directory", "io", "connect", "document", "database", "bc", "subject", "character", "graph", "log", "server", "pool", "function", "query", "index", "container", "machine", "channel", "lock", "handler", "engine", "sql", "reference", "creator", "collection", "ongo", "response", "unit", "ctx", "ion", "section", "db", "library", "context", "application"], "preparedStatement": ["prehedStatement", "prepperDocument", "PreparedParent", "prearedDatabase", "preparableStatement", "PrearedStatement", "prearedHeader", "prearedStat", "eculatedStatement", "psefixedStatement", "preciseStatement", "preppedStatement", "eparedTransaction", "caparedStatement", "preculatedTransaction", "preamedStatement", "previousConnection", "preutedQuery", "previousTransaction", "preachedStatement", "preciseParent", "PrearedStat", "psefixedComment", "previousComment", "proparableStatement", "proparableStat", "calyingStatement", "preplacedStat", "preparedInstance", "PrearedString", "prearedScope", "PreparedTransaction", "PreparedComment", "eparedstatement", "prepperTransaction", "eculatedstatement", "preparedScope", "pseparedComment", "prequalifiedStatement", "partvisedStatement", "prequalifiedStat", "preutedOperation", "preachedString", "proparedStatement", "preformedTransaction", "preachedDatabase", "prefixedStatement", "preferredQuery", "partvisedComment", "preparedDatabase", "preamedParent", "preplacedComment", "preparedService", "preparedConnection", "preppedQuery", "preutedStatement", "previsedStatement", "prehedComment", "preamedString", "preferredStatement", "preciseString", "partparedStatement", "prelyingStatement", "calyingTransaction", "preparedParent", "PrearedComment", "PreppedStatement", "eparedStatement", "previousDocument", "PrearedService", "preculatedStatement", "PreparedService", "calyingComment", "preformedService", "PreppedConnection", "PreppedTransaction", "preparedStat", "prehedScope", "PreppedDocument", "PreparedConnection", "PreparedHeader", "caparedTransaction", "preformedString", "prehedQuery", "prefixedOperation", "prearedComment", "PreparedOperation", "preamedStat", "PreparedString", "prequalifiedInstance", "calyingstatement", "prearedQuery", "proparableInstance", "proparablestatement", "eparedConfiguration", "psefixedQuery", "pseparedStatement", "preparedComment", "preformedConfiguration", "preparedstatement", "PreparedStatement", "preparedHeader", "preparedOperation", "partvisedQuery", "preculatedConfiguration", "prepperConnection", "preutedHeader", "preciseStat", "preformedstatement", "PreparedStat", "preplacedStatement", "caparedstatement", "PrearedParent", "proparedStat", "preformedDatabase", "preparedQuery", "preculatedstatement", "previsedComment", "prearedInstance", "preppedString", "partparedQuery", "eculatedConfiguration", "preppedConnection", "proparedstatement", "preparableStat", "preppedTransaction", "preplacedQuery", "preppedComment", "PreparedQuery", "PrearedDatabase", "previousstatement", "PrearedHeader", "PrearedOperation", "prearedService", "prefixedHeader", "pseparedQuery", "pseparedScope", "prepperStatement", "prearedTransaction", "prearedstatement", "prearedString", "caparedComment", "preppedDocument", "partparedComment", "prequalifiedstatement", "eculatedTransaction", "proparedInstance", "preferredComment", "PrearedQuery", "prefixedComment", "partparedStat", "PreparedDocument", "prelyingComment", "prefixedQuery", "PreparedDatabase", "prearedOperation", "preformedStatement", "prearedConfiguration", "psefixedScope", "previsedQuery", "preachedService", "prelyingTransaction", "preparedTransaction", "prearedParent", "preparableInstance", "previsedStat", "preparedString", "preparedConfiguration", "previousStatement", "prelyingstatement", "prearedStatement", "partvisedStat", "preparedDocument", "preferredString", "prefixedScope", "preparablestatement"], "resultSet": ["responseList", "responseLine", "resultsLine", " resultSize", "ResultSize", "ResultSource", "responseSet", " resultList", "resultGet", "rowSet", "resultSize", "ResultLine", "ResultGet", "ResultSet", "responseSource", " resultGet", "resultList", "rowSize", "resultSource", "resultsList", "resultsSource", "ResultList", " resultSource", "resultsSet", "rowSource", "resultLine", "rowGet", " resultLine"], "chkSql": ["chksSql", "chkRsq", "chkSQL", "chkSsql", "chkPresq", "chkOssl", "chkPssl", "chKSq", "chkPssql", "chkPresQL", "chkOsq", "chksAsql", "chksAssql", "chksSq", "chKRssl", "chkAssql", "chkPresql", "chksAsq", "chkPsql", "chkOsQL", "chKSsl", "chKRsql", "chkOsql", "chksAsQL", "chksSsql", "chkPressql", "chKRsq", "chkRsql", "chksSQL", "chKSsql", "chkRssql", "chkSsl", "chkRssl", "chkSq", "chKRssql", "chkAsq", "chkAsQL", "chkOssql", "chkAsql", "chkPsq", "chKSql"], "selfDefinePath": ["selfDefinedKey", "selfDefinepath", "selfDefiningpath", "selfDefinedPath", "selfDefenPath", "selfDefineName", "selfDeclineKey", "selfDefiningPath", "selfDefineKey", "selfDefineUrl", "selfDefinesUrl", "selfDeclinedPath", "selfDefenLocation", "selfDefiningKey", "selfDefinesLocation", "selfDeclinedpath", "selfDefinedUrl", "selfDefineLocation", "selfDeclinepath", "selfDefenName", "selfDefinedLocation", "selfDefiningUrl", "selfDefinesKey", "selfDeclinedKey", "selfDefinespath", "selfDeclineUrl", "selfDeclinedUrl", "selfDefinedpath", "selfDefinesPath", "selfDefinedName", "selfDeclinePath", "selfDefinesName", "selfDefenpath"], "sqlStr": ["sqlBr", "querystr", "sqlText", "queryDec", "sqlWr", "SQLString", "SQLStr", " sqlDec", "queryStr", " sqlString", "qlString", "SQLWr", "SQLDec", "sqlDec", "SQLBr", "sqlstr", " sqlstr", " sqlWr", "SQLText", "sqlString", "queryText", "qlStr", "qlWr", " sqlText", "SQLstr", "qlBr", " sqlBr"]}}
{"id1": "3558512", "id2": "2521141", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["serialization", "finalized", " serialization", "finalify", "Serialization", "serialify", "serialze", "normalze", " serializable", "erialze", "Serializable", "Serialize", " serialze", "normalized", "normalify", "Serialized", "erialization", "serializable", "serialized", "Serialify", "erializable", "finalze", "normalize", "finalize", "Serialze", "erialize"], "out": ["source", "png", "filename", "buffer", "copy", "cache", "output", "client", "archive", "page", "w", "ex", "i", "dump", "OUT", "image", "conn", "data", "writer", "loader", "io", "up", "a", "name", "server", "gen", "obj", "pool", "exec", "string", "Out", "raw", "outs", "file", "temp", "err", "o", "parent", "bin", "report", "content"], "parser": ["p", "lp", "arser", "as", "copy", "cache", "ss", "parse", "instance", "system", "seed", "master", "rar", "per", "processor", "txt", "manager", "loader", "writer", "Parser", "builder", "tt", "up", "class", "base", "pe", "server", "upload", "worker", "cp", "handler", "plugin", "wrapper", "php", "test", "file", "er", "pp", "reader", "pkg", "parent", "xml", "pillar"], "on_disk": ["onnetdrive", "onJdemand", "onJdisk", "on_storage", "onbookdisk", "off_drive", "onjdisk", "on_lock", "on_demand", "onJdrive", "onbootstorage", "onbootdrive", "onbookdrive", "on_space", "off_space", "onbootlock", "onjdrive", "onnetdisk", "on_file", "onnetfile", "on_drive", "off_delete", "onJlock", "onnetspace", "off_disk", "onjspace", "off_storage", "off_file", "off_lock", "onjfile", "onbootdisk", "onnetdemand", "onbookdelete", "on_delete", "off_demand"], "in": ["source", "as", "copy", "inn", "pin", "inner", "c", "ac", "f", "ax", "info", "pass", "i", "input", "socket", "conn", "inas", "IN", "data", "ini", "win", "con", "din", "min", "ins", "connection", "thin", "stream", "lin", "In", "inc", "again", "rin", "file", "kin", "r", "login", "o", "reader", "bin"]}}
{"id1": "12766394", "id2": "7761195", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"testReadHelloWorldTxt": ["testReadHelloWordMtxt", "testReadHelloWorldMXT", "testReadHelloWordText", "testReadHelloWordMXT", "testReadHelloWorldMxt", "testReadHelloWorldMext", "testReadHelloWorldFXT", "testReadHelloWorldMtxt", "testReadHelloWorldText", "testReadHelloWordTxt", "testReadHelloWordTtxt", "testReadHelloWordMxt", "testReadHelloWorldTXT", "testReadHelloWorldFtxt", "testReadHelloWordMext", "testReadHelloWorldTtxt", "testReadHelloWordTXT", "testReadHelloWorldFxt", "testReadHelloWorldFext"], "helloWorldIS": [" helloWorldIDE", " helloCityIR", "helloCityIR", "helloCityIs", "helloWorldIR", "helloCommunityIS", "helloWestIS", " helloCityAS", "helloWestAS", "helloCityIS", "helloCityAS", "helloCityIDE", " helloWorldIs", "helloWorldIDE", " helloWorldis", "helloWorldis", "helloWestIs", "helloCommunityIDE", "helloCommunityIs", "helloWorldIs", " helloCityIs", "helloWestIR", "helloWorldAS", "helloCityis", " helloCityIS", " helloWorldAS", " helloWorldIR"], "helloWorldPath": ["hiWebUrl", "helloCommunityLocation", "officeCommunityCorp", "helloWorldFile", "officeWorldCorp", "hiWorldpath", "hiWebpath", "helloCommunityPath", "helloWorldCorp", "hiWorldFile", "helloWebPath", "helloworldCorp", "officeWorldLocation", "officeWorldPath", "helloCommunityName", "officeCommunityPath", "helloWorldDir", "helloCommunityDir", "helloWorldpath", "helloCommunityCorp", "hiWorldPath", "helloWallpath", "helloWebUrl", "helloWallDir", "officeWorldPATH", " helloWorldpath", "helloWorldLocation", " helloWorldName", "helloWorldUrl", " helloWorldDir", "helloWallPath", "hiWorldUrl", "helloCommunityPATH", "helloworldPATH", "helloWebpath", "hiWebFile", "helloWorldPATH", "officeCommunityPATH", "helloworldPath", "officeCommunityLocation", "helloWebFile", "helloworldLocation", "helloCommunitypath", "helloWallName", "hiWebPath", "helloWorldName"], "fileOutputStream": ["FileInputSteam", "resourceInputSteam", "fileWriteStream", "resourceOutputStream", "resourceOutputSteam", "fileOutputHandler", "fileInputPath", "resourceOutputFile", "fileoutputStream", "FileOutputSteam", "FileInputStream", "fileoutputSteam", "fileOutputSteam", "FileInputstream", "fileInputSteam", "fileInputstream", "FileOutputHandler", "fileWriteFile", "fileOutputPath", "fileOutputFile", "FileOutputStream", "FileOutputstream", "fileOutPath", "resourceInputPath", "fileoutputHandler", "fileOutSteam", "fileOutFile", "fileWritePath", "fileOutputstream", "fileOutStream", "resourceOutputPath", "resourceInputFile", "FileOutputFile", "fileWritestream", "FileInputFile", "FileInputHandler", "fileInputFile", "fileInputHandler", "fileoutputstream", "fileInputStream", "resourceInputStream", "fileWriteSteam"], "contentResolver": [" contentresolve", "contentRoser", "contentResponseolver", " contentResistor", "contentReslier", "ContentRoser", "resourceRolution", "resourceResolve", "contentResolves", "messageResultlier", "contentResultolve", " contentresolves", " contentresolution", "messageResultolve", "contentAbsolution", "ContentResoser", "resourceRolved", "contentResolution", "contentAbsolver", "contentresolving", "contentResolve", "contentRolve", " contentresolver", "contentResoser", "contentRevolves", "ContentResolution", "ContentRolution", "ContentRolver", "contentResolved", "contentRevolution", "messageResultolution", "contentResultolved", " contentRevolved", "contentresolution", "contentRolver", " contentResolution", "contentResultolver", "contentAbsolve", "ContentResolving", "contentRlier", " contentRevolve", "resourceRolver", "contentResponseolve", "ContentResolver", "contentRevolve", "contentresolves", "contentresolved", "contentresolver", "contentResultlier", "contentResolving", "contentResistor", "messageResultolver", "contentreslier", "ContentRolve", "contentRolving", "resourceRolve", "contentRolves", "contentRolution", " contentResolved", "contentResponseistor", "contentResultolution", "resourceResolution", " contentResolve", "messageReslier", "resourceResolved", " contentRevistor", "contentRevolver", "ContentResolve", "messageResolver", "messageResolution", "messageResolve", "contentRevolved", "contentResultistor", "contentRevistor", "contentAbsoser", "resourceResolver", "contentResponseolved", "contentRolved", "contentresolve", " contentResolves", " contentRevolver", "ContentRolving"], "content": ["work", "text", "ontent", "message", "column", "result", "media", "cache", "output", "json", "copy", "current", "path", "script", "empty", "load", "update", "config", "activity", "model", "page", "title", "java", "word", "draft", "conn", "image", "complete", "default", "read", "data", "example", "resource", "comment", "play", "children", "valid", "core", "document", "url", "next", "name", "job", "cont", "lc", "ext", "server", "code", "handle", "password", "address", "child", "body", "string", "connection", "header", "size", "layer", "write", "full", "html", "Content", "value", "file", "version", "css", "temp", "response", "feed", "any", "parent", "xml", "fill", "status"]}}
{"id1": "5237257", "id2": "310182", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"download": ["output", "paste", "load", "update", "archive", "dump", "complete", "process", "release", "open", "url", "log", "transfer", "Download", "zip", "exec", "upload", "run", "submit", "file", "register", " downloading", "pack", "start", "select", "delete", "report"], "fileName": ["fileCode", "resourcePath", "fileDirectory", "resourceName", "fileType", "FileCode", " fileType", " fileDirectory", "FilePath", "fileFolder", "resourceDirectory", " fileFolder", "fileUrl", "FileFolder", "FileName", "resourceUrl", "FileUrl", "FileDirectory", "resourceCode", "FileType", "resourceFolder", "resourceType", " fileCode", " fileUrl"], "filePath": ["resourcePath", " fileFile", "FileLocation", "fileLocation", "resourceName", "filePart", "resourceFile", "resourceLocation", "FilePart", "fileFile", " filePart", "FilePath", "Filepath", "resourcePart", "FileName", "FileFile", " filepath", "filepath", "resourcepath", " fileLocation"], "in": ["work", "x", "source", "as", "init", "copy", "re", "gin", "inn", "sync", "pin", "inner", "ac", "f", "ax", "this", "i", "input", "l", "socket", "inside", "image", "IN", "data", "m", "con", "win", "ini", "resource", "issue", "on", "n", "up", "bin", "a", "url", "io", "name", "isin", "b", "is", "nin", "ins", "cin", "spin", "In", "lin", "inc", "again", "rin", "file", "r", "err", "login", "cgi", "id", "reader", "din"], "out": ["x", "source", "call", "copy", "cache", "output", "sync", "client", "path", "net", "inner", "at", "point", "with", "this", "extra", "view", "ex", "cmd", "one", "to", "socket", "OUT", "conn", "image", "line", "or", "IN", "by", "writer", "on", "n", "io", "up", "url", "base", "name", "log", "null", "outer", "ext", "server", "exec", "obj", "password", "nin", "string", "exp", "prefix", "option", "Out", "write", "In", "outs", "again", "off", "office", "file", "lib", "err", "o", "id", "user", "bin", "error"]}}
{"id1": "160739", "id2": "6171406", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createByteReader", " createInputStream", " createByteFile", " createIOReader", " createIOFile", " createInputReader", " createInputSteam", " createInputFile", "createInputSteam", "createOutputReader", "createOutputSteam", " createByteStream", "createOutputFile", " createOutputReader", "createInputStream", " createOutputSteam", "createInputFile", " createOutputFile", " createByteSteam", " createIOSteam", " createIOStream", "createInputReader"], "inFile": ["outFiles", "inputFile", "insFile", "incfile", "insfile", "incFile", "inFiles", "inputfile", "insFiles", "sourcefile", "incStream", "sourceFiles", "inputStream", "insStream", "outfile", "infile", "sourceStream", "outStream", "sourceFile", "inputFiles", "inStream", "incFiles"], "outFile": ["workingFile", "outTime", "workingDirectory", "targetfile", " outfile", "inputFile", " outStream", "workDir", "inputTime", "inputDir", " outDirectory", "targetDirectory", "outDir", "outDirectory", "targetFile", "workingStream", "inputfile", "inTime", "workTime", "outfile", "infile", "outStream", "workfile", "workFile", "targetStream", "inDir", "workingfile"], "k_blockSize": ["k_lockCount", "k_blockLength", "k_byteCode", "k_lineCount", "k_bitSize", "k_byteSize", "k_blocksSize", "k_lockLength", "k_BlockCode", "k_byteCount", "k_lineSize", "k_bitInfo", "k_lockSize", "k_byteLen", "k_lineInfo", "k_blockCount", "k_BlockCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksCount", "k_blockCode", "k_blockLen", "k_blocksLen", "k_BlockSize", "k_blocksLength", "k_byteInfo", "k_BlockLength", "k_bitCount", "k_blockInfo"], "byteCount": ["characterLen", "flushcount", "byteLen", "characterSize", "ByteCount", "bytecount", "ByteLength", "flushSize", "blockCount", "ByteSize", "blockSize", " byteLen", "byteSize", " byteSum", "characterLength", "Bytecount", "byteSum", "ByteSum", "byteLength", "ByteLen", " byteLength", "blockLength", " bytecount", "blockSum", "characterCount", "flushCount", " byteSize", "flushLength"], "buf": ["cv", "bh", "buffer", "result", "uf", "seq", "bag", "feat", "config", "buff", "fb", "len", "font", "bytes", "cmd", "src", "border", "exc", "brace", "loc", "data", "background", "bf", "cas", "img", "tmp", "base", "b", "fd", "Buffer", "append", "rc", "rb", "ucc", "queue", "batch", "alloc", "vec", "cap", "feed", "Buff", "ctx", "flush", "cb", "la"], "ofp": ["afp", "fort", "ofl", "OFnp", "afnp", "OFc", "ofc", "Ofnp", "Ofl", "OFtp", "oft", "Oftp", "ofnp", "Ofc", "OFl", "OFp", "forc", "Ofp", "afl", "oftp", "Oft", "forp", "fortp", "OFt", "afc"], "zos": ["ogl", "iframe", "bos", "zik", "tz", "zona", "abi", "zb", "core", "los", "inos", "zip", "zn", "lins", "css", "ozo", "zin", "zx", "nox", "forge", "oses", "liquid", "uz", "iffs", "zl", "gz", "rons", "nz", "zy", "za", "hz", "ossus", "os", "oS", "utils", "cos", "ZA", "dylib", "fits", "ZI", "zag", "budget", "zes", "outs", "jas", "js", "kos", "zon", "ls", "zers", "oda", "ros", "modules", "bs", "zo", "zh", "rez", "lol", "osi", "zi", "owicz", "soon", "z", "obb", "zer", "robe", "cfg", "zyk", "ws", "enos", "ses", "webkit", "zig", "zen", "packs", "obs", "bitcoin", "zar", "bes", "ops"], "osw": [" osow", "osx", "oswd", "ossnow", "osws", "lsw", "osnow", "isy", "bx", "ossy", " osfw", "lswo", "bws", "iswd", "ossow", "bwo", "ossw", "esww", "eshell", "esfw", "isd", "eswd", "issw", "osshell", "osd", "ossd", "lsws", "oswo", "osfw", "oshell", "osow", "esd", "esw", "essw", "bsx", "isw", "ossfw", "bsw", "isnow", "esnow", "osww", "esow", "ishell", "bsws", "osssw", "lsx", "osy", "bswo", "osswd", " osww", "ossww", "esy"], "bw": ["fsw", " bws", "bbwh", " bwu", "owu", "ebwd", "lsw", " bz", "fx", "bbaw", "Bw", "bx", "lbwh", "lbz", "bW", "abW", "bbz", "ebW", "bwe", "lw", "bz", "bws", "fbwe", "lbw", "baw", "fwa", "lbws", "bew", "bbwa", "Bwa", "fbw", " baw", "bbew", "owa", "fbwd", "bbwu", "fw", "oaw", "abw", "Bew", "lbwa", "abwe", "bbw", "fr", "abwd", "ebwe", " bwh", "ebw", "bsw", "lbx", "lbsw", " bew", "lwa", "lx", "fwh", "bwu", "ow", "fbW", "bwd", "bwa", "bbws", "lbr", "bwh", " bwa", "Bws"], "zot": ["azit", "zott", "zerita", "jos", "Zit", "Zott", "zerori", " zori", " zor", "ziot", "zor", "jit", "azot", "zita", "azor", "Ziot", "jot", "azott", "Zot", "zerot", "zeros", "azita", "Zita", "zerit", "Zor", "zori", "zerott", "jori", " ziot", "aziot"], "ifp": ["IFl", "IFi", "ifl", " ifl", "IFb", "IFf", "ipb", "iff", "ifb", "ifc", " ifi", "ipc", "ifi", "Ifp", "Ifc", "ipp", " iff", " ifb", "IFp", "Ifi", "Iff", " ifc", "IFc", "ipl"], "zis": ["zeis", "Zits", "xits", "Ziss", "zeip", "jits", "zipis", "xisi", "zenais", " zIS", "zIS", "xIS", "zipits", "jisi", "jit", "zenIS", "zits", "xis", "zisi", "zeiss", "ziss", " zais", "zib", "zipip", "zip", "jis", "zais", " zib", " zits", "zeits", "zenib", " zisi", "xib", "zipiss", "xit", "xais", "Zis", "zenis", "Zip"], "isr": ["irrb", " iscr", "ISrc", "issrs", "ISpr", "rispr", "irr", "risrc", "ISsr", "isrb", "issr", " isrs", "iscr", "ISrs", "ISr", "risrb", "risr", "irpr", "ISrb", "isrs", "isscr", "isssr", "irrc", "IScr", "ispr", " issr", "isrc"], "br": ["kr", "bh", "rib", "bro", "arr", "str", "ibr", "browser", "bar", "obl", "HR", " BR", "mr", "BR", "bl", "bp", "Br", "rs", " Br", "sr", "img", "bc", "ber", "obi", "b", "hr", "ocr", "ch", "gr", "cro", "rb", "body", "sp", "ibl", "div", "fr", "yr", "shr", "lr", "ctr", " dr", "tr", "bsp", " fr", "r", "err", "ob"], "zit": ["jith", "zipit", "jite", "zeit", "zipIT", "zeitter", " zip", "jits", "zitter", "zith", "jip", "zipite", "jIT", "zipita", "zipitter", " zith", "zenits", "zipits", "zic", "zeith", "jit", "zits", " zite", "zeita", "zita", "xic", "zipip", "zip", " zi", "zenith", "ji", " zits", "xith", "zIT", "zeits", "jic", "zeIT", "xi", "zenitter", "jita", "zenit", "zipith", "zi", "zite", "xit", " zic"]}}
{"id1": "23152865", "id2": "8079516", "code1": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"open": ["Open", "create", "copy", "load", "config", "info", "java", "link", " Open", "to", "read", "map", "close", "object", "resource", "opens", "next", "class", "document", "name", "opened", "append", "write", "file", "op", "type", "start"], "className": ["classname", "ClassPath", "ClassLine", "packagePath", "objectname", "instancePath", "filename", "filePath", " classFile", "fileType", "classNAME", "instancename", "CLASSFile", " classType", "objectType", "fileFile", " classString", " classname", "ClassNAME", "classString", "classFile", "instanceNAME", "ClassName", "instanceName", "classType", "Classname", "objectPath", "classPath", "classLine", "ClassType", "CLASSType", "fileName", "CLASSname", "packageLine", "fileString", " classNAME", "ClassString", "objectName", " classPath", "packagename", " classLine", "CLASSName", "ClassFile", "packageName"], "fo": ["who", "wo", "Obj", "so", "buff", "txt", "ott", "to", "tu", "wx", "fw", "tw", "fs", "conf", "fn", "zz", "ma", "jo", "go", "info", "bj", "aco", "po", "ko", "object", "kw", "za", "af", "gh", "io", "foo", "flo", "inf", "os", "oo", "obj", "abo", "ki", "wh", "xf", "odo", "vo", "tto", "shi", "ato", "cf", "lo", "bo", "oh", "prof", "eno", "zo", "olo", "php", "o", "local", "gor", "ho", "oss", "f", "fb", "gi", "umo", "oso", "ph", "ws", "FO", "fe", "fa", "Info", "mo", "ao", "fi", "osa", "fam", "co"], "cn": ["gn", "cv", "cy", "cs", "ln", "bh", "cf", "net", "csv", "c", "cat", "ca", "Name", "Ns", "cdn", "aa", "con", "act", "cas", "n", "core", "name", "ann", "kn", "lc", "col", "cr", "ain", "CN", "cc", "nc", "fn", "fa", "cp", "rn", "mn", "enc", "cl", "cm", "cin", "coll", "fc", "wcs", "sn", "ns", "anc", "cot", "hn", "css", "vc", "rt", "dn", "ct", "rev", "ctx", "cb", "bn", "abc", "dc"], "lastDot": ["lastMidot", "lastDaash", "lastDoOT", "lastDaou", " lastFOT", "lastDoash", " lastNot", "nextDollar", "lastDominott", "lastMidollar", "lastDominot", " lastDotted", " lastDitive", "lastRadollar", "lastMidash", "lastNitive", "lastDigot", "lastFOT", "lastDoot", "lastDaot", "lastDootted", "lastDash", "lastRadash", "nextDigollar", "lastDott", "lastDigotted", "nextDot", "lastDotted", "lastFot", "lastSlOT", " lastNitive", "lastDitive", "latestDaou", "lastNot", " lastFotted", "latestDash", "lastNash", "lastDou", "lastSlash", "lastNotted", "nextDigash", " lastFot", " lastDOT", " lastNash", "lastDOT", "lastMidOT", " lastDott", "latestDOT", "latestDot", "lastDominOT", "lastSlot", "nextDOT", "lastRadot", "lastMidotted", "latestDaOT", "lastSlou", "latestDaot", "lastDollar", "lastRadOT", "lastFotted", "lastDigOT", "nextDigot", "lastFott", " lastNotted", "lastDoitive", " lastFott", "lastMiditive", " lastDash", "latestDaash", "lastDoou", "nextDigOT", "latestDou", "lastDaOT", "nextDash", "lastDigott", "lastDigash", "lastDigollar", "lastDominotted"], "sfm": ["tfmm", "rffm", "fM", "tfbm", "tffm", "rfmm", "SFm", "SFbm", "tfM", "fmm", "sfmm", "SFfm", "fm", "rfM", "sfbm", "SFmm", "sffm", "tfm", "rfm", "sfM", "SFM", "fbm"], "uri": ["source", "uni", "client", "path", "Url", "ni", "gi", "domain", "timeout", "link", "i", " URI", "l", "manager", "ci", "loc", "service", "resource", "location", "hub", "io", "directory", "base", "name", "server", "URL", "ui", "query", "address", "api", "pi", "li", "iri", "connection", "string", "mi", "prefix", "range", "attribute", "route", "cli", "dir", "URI", "id", "ri", "http"], "url": ["text", "source", "filename", "str", "client", "browser", "path", "Url", "f", "config", "link", "i", "l", "manager", "image", "src", "xml", "loc", "data", "service", "object", "resource", "location", "class", "base", "name", "server", "host", "URL", "ui", "address", "sl", "li", "connection", "string", "ur", "impl", "file", "route", "cli", "ssl", "dir", "id", "ri", "http"], "conn": ["remote", "client", "out", "path", "session", "net", "c", " connection", "ai", "reg", "Connection", "timeout", "nt", "manager", "Conn", "ci", "socket", "loc", "addr", "req", "con", "n", "connect", " con", "ann", "conv", "server", "obj", "conf", "ch", "connection", "nc", "cp", "enc", "coll", "cli", "r", "ssl", "ctx", "http"], "simpleName": [" simpleNames", " classType", "fullType", " simpleType", " classPath", "fullNames", "simplePath", "fullPath", "fullName", " simplePath", "simpleType", "simpleNames", " classNames"], "kind": ["method", "kid", "style", "mode", "str", "path", "inner", "instance", "info", "state", "Kind", "k", "ind", "resource", "weak", "ke", "expected", " Kind", "iv", "spec", " kinds", "ance", "version", "part", "cost", "dir", "id", "type"], "ignoreEncodingErrors": ["ignoreEncodingPhrors", "ignoreEncodingPhrs", "ignoreEncapingMirrors", "ignoreEncodingTerrors", "ignoreEncachingMirrors", "ignoreEncachingError", "ignoreEncodingEror", "ignoreEncodingEerrors", "ignoreEncachingMirror", "ignoreEncodingError", "ignoreEncapingErrs", "ignoreEncodingERrors", "ignoreEncapingErerrors", "ignoreEncodingMiraces", "ignoreEncodingPhror", "ignoreEncachingErerrors", "ignoreEncodingEraces", "ignoreEncapingMiraces", "ignoreEncapingEraces", "ignoreEncodingErors", "ignoreEncachingMirrs", "ignoreEncapingMirrs", "ignoreEncodingErrs", "ignoreEncapingErrors", "ignoreEncodingERerrors", "ignoreEncachingErrors", "ignoreEncodingErerrors", "ignoreEncodingERrs", "ignoreEncodingTeraces", "ignoreEncodingMirror", "ignoreEncapingMirerrors", "ignoreEncodingTererrors", "ignoreEncodingMirrors", "ignoreEncodingERaces", "ignoreEncodingPherrors", "ignoreEncodingTerrs", "ignoreEncachingErrs", "ignoreEncodingMirerrors", "ignoreEncodingMirrs", "ignoreEncodingErs", "ignoreEncachingMirerrors"]}}
{"id1": "15971794", "id2": "7118860", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 0, "substitutes": {"getWave": ["readwave", "newWave", "getSound", "readWire", "readSound", " getWire", "readWave", " getwave", "newWire", " getSound", "getWire", "getwave", "newSound", "newwave"], "url": ["Ur", "source", "ref", "F", "filename", "File", "fp", "uri", "path", "Url", "field", "f", "page", "Feed", "word", "l", "image", "ff", "loc", "web", "resource", "base", "name", "inf", "b", "host", "URL", "fl", "fe", "address", "string", "fn", "fr", "lr", "fax", "file", "wave", "feed", "r", "sf", "http"], "Word": ["F", "Message", "Line", "words", "File", "Folder", "Path", "Weight", "Url", "Dir", "Feature", "Str", "Length", "Work", "wd", "Term", "word", "Time", "Name", "Rule", " word", "W", "Writer", "Wire", "Token", "Language", "Tag", "Msg", "Text", "Win", "Function", "Code", "Gender", "Class", "string", "Stream", "Letter", "Field", "Content", "Wave", "Part", "Words", "World", "Eng", "Hack", "Key", "Frame"], "FF": ["DF", "FA", "F", "FW", "fp", "FE", "IF", "FS", "AF", "Client", "Folder", "FB", "Fax", "FP", "Fi", "Feed", "TF", "ff", "DC", "RC", "FILE", "FC", " ff", "P", "IFF", "fd", "CC", "URL", "FD", "ELF", "FL", "FH", "BB", "Field", "LL", "FM", "feed", "IP", "SF"], "url2": [" url3", "l4", "url1", "l1", " urlTwo", " url1", "URLTwo", "URL2", "URLDB", "urlDB", "urlTwo", "f4", "f2", "url3", "pathTwo", "pathDB", "path2", "f1", "f3", "l3", " urlDB", " url4", "URL1", "path1", "url4", "l2"], "stream": ["flow", "source", "form", "video", "sw", "forward", "output", "steam", "client", "path", "flash", "field", "f", "view", "w", "driver", "input", "src", "socket", "ff", "draft", "loader", "writer", "in", "transform", "io", "fd", "host", "server", "thread", "sl", "live", "ack", "string", "Stream", "channel", "fr", "stack", "handler", "coll", "raw", "impl", "file", "temp", "loop", "row", "wave", "feed", "response", "ssl", "roll", "reader", "slice", "pipe", "v", "context", "http"], "Fdel": ["Fidelete", "Fdelete", "fDel", "Ffin", "fdelete", "ffin", "fdestroy", "FiDel", " Ffin", "fdel", " Fdestroy", "Fidel", "Fidestroy", " FDel", "FDel", " Fdelete", "Fdestroy", "Fifin"], "outstream": [" outreader", "outputform", "outchannel", "outputlog", "Outform", "Outfile", " outform", " outfile", "outform", " outStream", "inlog", "inputlog", "outputchannel", "Outstream", "inwriter", "inputstream", "outreader", "instream", "outmodel", " outwriter", "outputStream", "inmodel", "outputfile", "outputreader", "inchannel", "OutStream", "outputstream", "inputStream", "inreader", "outfile", "outwriter", "outStream", "outputmodel", "outputwriter", "outlog", " outmodel", "inStream", "inputchannel"], "bwriter": ["bwrite", "fwrite", "Bwrite", "bbwriters", " bbuilder", "outwriting", "bbWriter", "bbwriter", "fbwrite", "breader", " bwrite", "freader", "bbuilder", "Bbuilder", "fbwriter", " bWriter", "outreader", " bwriters", "fbuilder", " bwriting", "Breader", "fbWriter", "Bwriter", " breader", "bwriting", "bbwriting", "bWriter", "fwriter", "bwr", "bbreader", "outwriter", " bwr", "bwriters", "bbwr", "bbwrite", "fbwriters", "outwr"], "binput": ["bincut", " binstop", "output", "binsell", " binstart", "byteset", "bisplit", "winsell", " binwrite", "binpos", "bipos", "winput", "libcut", " binset", " binpos", "bitput", "binstop", "binlog", "binaryput", "binaryset", "libset", "liblog", "libput", "bitset", "binarycut", "bytesplit", "sinput", "binstart", "sinset", "biwrite", " binsell", "binarylog", "binset", "binsplit", "biset", "binwrite", "byteput", "winstart", "sincut", "winwrite", "sinlog", " binsplit", "outsell", "outstart", "bitwrite", "bitpos", "bistop", "biput", "outwrite", "bytestop"], "len": ["ls", "pre", "lf", "ln", "fun", "seq", "length", "lt", "hl", "lan", "lim", "ie", "l", "pos", "count", "line", "val", "lon", "data", "elt", " lang", "dl", "n", "limit", "base", "ann", "num", "lc", "low", "label", "fin", "fl", "split", "sl", "li", "size", "enc", "coll", "el", "lin", "en", "Len", "iter", "cap", "part", "end", "le", "id", "rev", "bin", "la"]}}
{"id1": "12783713", "id2": "17557289", "code1": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"sendErrorMessage": [" sendHeaderMsg", " sendHeaderMessage", "senderrorMsg", "sendErrorMsg", "sendErrorFile", " sendHeaderStream", "sendStatusFile", "writeErrorMsg", "sendExceptionStream", "writeErrorFile", "sendMessageMessage", "sendErrormessage", "senderrorPage", "sendMessageStream", " sendErrorMsg", "sendExceptionMessage", "sendExceptionmessage", " sendHeadermessage", "sendErrorStream", "sendErrorPage", "sendStatusMsg", "sendStatusPage", "sendExceptionPage", "writeExceptionMsg", "writeErrorMessage", "writeExceptionPage", "sendMessageMsg", "sendHeaderMsg", "sendHeaderMessage", "writeExceptionMessage", "sendExceptionMsg", "sendMessagemessage", " sendErrormessage", "sendHeaderStream", "senderrorMessage", "sendExceptionFile", "sendHeadermessage", "senderrorFile", "writeErrorPage", "writeExceptionFile", "sendStatusMessage", " sendErrorStream"], "message": ["text", "source", "method", " Message", "filename", "Message", "uri", "path", "language", "field", "page", "phrase", "note", "image", "data", "m", "email", "comment", "description", "url", "subject", "reason", "code", "msg", "address", "body", "string", "header", "queue", "value", "file", "request", "essage", "response", "user", "error", "report", "content", "application"], "NotConnectedException": ["NotConnectableException", "NotConnectedEMENT", "NotConnectsception", "NotconnectedEMENT", "NotConnectingEMENT", "NotConnectableError", "NotConnecturedception", "NotConnectingError", "NotConnectsConnection", "NotConnectedception", "NotConnecturedEMENT", "Notconnectedception", "NotConnecturedError", "NotConnectsEMENT", "NotConnecturedException", "NotconnectingConnection", "NotConnecturedConnection", "NotConnectedConnection", "NotconnectedException", "NotConnectableception", "NotConnectedError", "Notconnectingception", "NotConnectingException", "NotConnectingception", "NotConnectingConnection", "NotconnectingException", "NotconnectingEMENT", "NotConnectsException", "NotconnectedConnection"], "MessagingException": ["MessengerProblem", "MessagesException", "Messagingception", "MessindingProblem", " MessengerException", "Messindingception", "Messagesception", " MessengerProblem", " Messengerception", "MessagingProblem", "Messengerception", " MessagingProblem", "MessindingException", "MessagesProblem", " Messagingception", "MessengerException"], "recipients": ["recipinators", "recordient", "comipresses", "RecIPient", "recipientresses", "recqions", "recipientient", "recordresses", "Recipient", "recordinators", "recipient", "RecIPients", "recipientinators", "comordinators", "comipient", "recIPions", "Recipresses", "recordients", "recqresses", "Recipients", "Recipions", "recipientions", "RecIPions", "recqients", "comordients", "recipresses", "recipientients", "recIPients", "recqient", "recIPinators", "comipinators", "comordresses", "comordient", "RecIPresses", "recipions", "comipients", "recIPresses", "recIPient"], "mail": ["contact", "call", "z", "f", "event", "view", "link", "e", "send", "manager", "bird", "build", "m", "box", "proxy", "email", "reply", "multi", "shell", "Mail", "log", "server", "zip", "msg", "query", "address", "lock", "mo", "zen", "test", "mails", "file", "zz", "feed", "mu", "gmail", "pkg", "user", " email", "select", "report"], "zos": ["eps", "closure", "iframe", "dos", "bos", "z", "zer", "zl", "gz", "lab", "zers", "socket", "zona", "nz", "zy", "abi", "zb", "za", "ws", "enos", "ros", "zero", "ses", "cos", "os", "los", "ZA", "is", "inos", "zip", "fits", "zo", "webkit", "ZI", "zag", "zes", "zh", "exit", "ios", "spin", "rez", "zen", "packs", "lins", "ils", "loop", "ozo", "zan", "zon", "obs", "cgi", "her", "osi", "zi", "zin", "jas", "kos", "forge", "oses", "zar", "bes", "ops"], "fis": ["fsis", "Fisi", "ffiss", "Fisc", "Fins", "fisi", "Fiss", "fiss", " fisi", " fisc", " fiss", "lfiss", "lisi", "fris", "liss", "lis", "fsits", "Fis", "fsins", "fins", "ffis", " fIs", "Fits", "ffits", "fits", "Fris", "lfis", "lfisc", "ffins", "fisc", "fIs", "lfIs", "FIs", "lris", " fris", "fsiss"], "entry": ["source", " Entry", "uri", "se", " entries", "ry", "cell", "Entry", "info", "system", "archive", "event", "ler", "ie", "card", "line", "cel", "data", "record", "service", "object", "log", "ries", "lc", "server", " module", "obj", "zip", "zo", "letter", "address", "header", "connection", "hole", "element", " reader", "file", "row", "feed", "reader", "parent"], "buffer": ["sequence", "position", "shape", "result", "length", "pad", "buff", "bb", "buf", "bytes", "seed", "uffer", "border", "padding", "data", "resource", "binary", "limit", "document", "base", "b", "null", "transfer", "number", "address", "Buffer", "header", "queue", "layer", "batch", "block", "iter", "reference", "row", "wave", "feed", "slice", "reader", "rate", "flush"], "read": ["x", "seek", "copy", "current", "Read", "reading", "length", "sync", "check", "available", "parse", "c", "load", "pad", "lex", "len", "use", "pass", "i", "READ", "send", "input", "skip", "count", "sleep", "default", "ind", "close", "in", "open", "play", "old", "find", "b", "add", " write", "transfer", "reads", "index", "size", "lock", "ize", "write", "raw", "en", "block", "wait", "loop", "put", "feed", "pack", " count", "reader", "end", "rate", "get", "start", "fill", "run"]}}
{"id1": "19912848", "id2": "22264586", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "19549489", "id2": "14877116", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 1, "substitutes": {"copy": ["p", "source", "create", " copies", " copied", "sync", " move", "paste", "Transfer", "download", "all", "Cop", "move", "cop", "io", " copying", "clone", "transfer", " transfer", "split", "zip", "upload", "Copy", "write", " Copy", "file", "delete"], "sourceFile": ["searchFile", " sourcefile", " sourceFILE", "sourceFILE", "searchFilename", " sourceFiles", "serviceFilename", "siteFILE", "SourceFILE", "siteFile", "sourceDirectory", "searchFiles", "resourceFile", "sourceFilename", "resourceDirectory", " sourceDirectory", " sourceFilename", "SourceFile", "sourcefile", "resourcefile", "servicefile", "sourceFiles", "resourceFiles", "siteDirectory", "searchfile", "serviceFiles", "SourceDirectory", "serviceFile", "siteFiles", "Sourcefile", "SourceFiles"], "destinationFile": ["destinatedFile", "destationImage", "destationDir", "distinatedDirectory", "DestinatorDir", "destinatorDir", "distinationDirectory", "distinationFiles", "destinatedImage", "distinatedImage", "destationFile", "destationfile", "destinationFiles", "distinationFile", "DestinatorFiles", "Destinationfile", "destationFiles", "distinatedFile", "distinatedFiles", "destinatedfile", "destinatorfile", "destinationDir", "Destinatorfile", "destinatedDirectory", "DestinatorFile", "destinatorImage", "DestinationDir", "destinationImage", "destinationDirectory", "destinatorFiles", "destinatorDirectory", "distinationImage", "DestinationFiles", "DestinationFile", "destationDirectory", "destinatedFiles", "destinatorFile", "destinatedDir", "destinationfile"], "sourceFileChannel": ["sourceDirectoryChannel", " sourceFilesService", "sourceFunctionChannel", " sourceFilesContext", "sourceLibrarySocket", "ourceFileStream", "sourceStreamStream", "targetLibrarySocket", "sourceStreamService", "targetLibraryClient", "ourceStreamchannel", "targetLibraryChannel", "targetFileSocket", "sourceFilesChannel", "sourceLibraryChannel", " sourceFileService", "ourceFileChannel", "sourceStreamChan", "sourceFileConnection", "sourceFileContext", "targetFileChannel", "ourceStreamChannel", "sourceLineChannel", "sourceLineClient", "sourceFunctionContext", "ourceStreamStream", "ourceFileChan", "sourceDirectoryClient", "sourceDirStream", "sourceLineStream", " sourceFilesConnection", "sourceLinechannel", "sourceDirChan", "sourceDirectoryChan", "sourceStreamChannel", "sourceFileChan", "sourceFunctionConnection", "sourceStreamConnection", " sourceFileConnection", "sourceFileStream", "targetFileChan", "sourceLibraryChan", "sourceFilesContext", "sourceLineChan", "ourceStreamChan", "sourceFunctionService", "sourceFileService", " sourceFileContext", "ourceFilechannel", "sourceStreamContext", "sourceStreamchannel", "sourceDirchannel", "sourceDirChannel", " sourceFilesChannel", "targetFileClient", "sourceLineSocket", "targetLibraryChan", "sourceFilesConnection", "sourceFileSocket", "sourceDirectorySocket", "sourceFileClient", "sourceLibraryClient", "sourceFilesService", "sourceFilechannel"], "destinationFileChannel": ["destinationDirectoryHandler", "destinatorFileHandler", "destinationFilesCache", "destinatorFileChan", "destinationFilesClient", "destinatorFilesClient", "destinationFilesChannel", "destinationIOChannel", "destinatorFileClient", "destinationFileChan", "destinationDirectoryChannel", "destinatorFileChannel", "destinationLineHandler", "destinationLineClient", "destinationDirectoryConnection", "destinationFilesHandler", "destinatorFilesHandler", "destinationIOCache", "destinationFilesService", "destinationFileClient", "destinatorFileConnection", "destinationDirectoryChan", "destinatorFileService", "destinationLineConnection", "destinationLineChannel", "destinationDirectoryClient", "destinatorFilesCache", "destinationIOClient", "destinationFileConnection", "destinationDirectoryService", "destinationFileService", "destinatorFilesService", "destinationIOService", "destinationLineChan", "destinatorFilesConnection", "destinatorFilesChan", "destinatorFileCache", "destinationFileCache", "destinationFileHandler", "destinationDirectoryCache", "destinationFilesChan", "destinationLineService", "destinationFilesConnection", "destinatorFilesChannel"]}}
{"id1": "10158738", "id2": "19096138", "code1": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"add": ["create", "set", "parse", "push", "load", "update", "config", "store", "link", "build", "install", "process", "name", "post", "append", "index", "php", "save", "insert", "register", "end", "apply", "start", "ADD", "Add"], "language": ["source", "filename", "position", "media", "length", "translation", "username", "feature", "generation", "library", "config", "model", "title", "word", "l", "project", "image", "line", "loc", "blog", "year", "module", "location", "directory", "gender", "Language", "url", "database", "base", "log", "document", "lc", "division", "name", "number", "lang", "category", "string", "culture", "direction", "layer", "lr", "lace", "collection", "version", "file", "slice", "site", "parent", "section", "la", "product"], "tag": ["match", "month", "ro", "role", "property", "position", "ug", "token", "port", "feature", "mod", "translation", "cover", "cat", "username", "alias", "date", "reg", "model", "page", "ag", "word", "image", "line", "loc", "year", "module", "resource", "round", "comment", "face", "core", "url", "Tag", "log", "name", " module", "code", "term", "address", "lang", "rule", "string", "region", "category", "prefix", "patch", "option", "layer", "tags", "profile", "test", "attribute", "parent", "track", "bug", "TAG", "key", "slice", "id", "type", "user", "section", "rol"], "root": ["source", "month", "remote", "ro", "result", "re", "token", "depth", "bottom", "reverse", "path", "cover", "feature", "username", "author", "rew", "head", "page", "seed", "roman", "src", "rank", "or", "loc", "install", "year", "resource", "round", "Root", "transform", "location", "bot", "core", "truth", "url", "name", "array", "null", "rice", "password", "child", "rss", "rc", "race", "string", "rule", "region", "wrap", "order", "ruby", "test", "parent", "r", "id", "rate", "type", "right", "rape", "node", "user", "roots", "roc"], "surface": ["source", "method", "filename", "shape", "grow", "sur", "uri", "depth", "feature", "username", "cover", "tile", "rue", "skin", "texture", "via", "slave", "tone", "src", "area", "spring", "padding", "material", "resource", "location", "round", "face", "sr", "core", "url", "name", "stage", "theme", "password", "faces", "address", "race", "region", "scope", "string", "ur", "true", "layer", "wrapper", "grave", "ruby", "sample", "secondary", "aster", "lace", "slice", "site", "rail", "rate", "type", "rape", "node", "roots"], "conn": ["p", "org", "cmp", "sb", "cache", "client", "oss", "cf", "sync", "session", "cb", "c", "cat", "config", "ver", "Connection", "state", "nt", "serv", "Conn", "ci", "loc", "con", "close", "pg", "open", "act", "pub", "ec", "n", "connect", "core", "error", "pc", "ann", "log", "col", "ou", "server", "pool", "exec", "conf", "ch", "rc", "connection", "nc", "h", "cc", "lock", "cond", "cp", "enc", "coll", "pr", "cm", "oci", "ok", "cn", "ns", "mc", "rt", "dn", "ow", "ct", "ob", "ctx", "db", "co", "dc"], "stmt": [" stma", "scm", "STma", " stmsg", "pql", "Stnt", "Stma", "isttr", " stql", "sthmb", "sthtr", "scmd", "Stmt", "Stm", "Stmsg", "strmd", "STMT", " stmb", "istdb", " stmd", "pmb", "stamb", "shm", "scmt", "strnt", "STmt", "sthdb", "stmr", "rmt", " stmit", " sttr", "strpb", "rmd", "Stmr", "Stql", "strmt", "stm", "stmp", " stMT", "istamb", "sthmn", "strsql", "stma", "STdb", "scmit", "istmt", "astpb", "pmt", " stmn", "stpb", "stMT", " stpb", "Stpb", "astmt", "Stmd", "rsql", "astnt", " stsql", " stmp", "shmt", "stmd", "Stdb", "sttr", "stdb", "stsql", "rmp", " stm", " stmr", "sthmp", "stmn", "StMT", "rnt", "astMT", "strMT", "strql", "strmn", "Stmb", "Stmp", "sthmt", "istmn", "stql", "rql", "pmd", "shmr", "stmsg", "Stmit", "shmsg", " stnt", "stnt", " stamb", "stmit", "stmb", "stramb", "strmp", " stdb", "strdb"], "row": ["p", "ride", "month", "group", "result", "ro", " rank", "role", "port", "length", "push", "ry", "cell", "instance", "f", "rew", "our", "reg", "page", "view", "e", "line", "rank", "Row", "val", "year", "record", "round", "url", "array", "col", "pe", "server", "allow", "post", "number", "ack", "index", "rss", "rc", "race", "rows", "rw", "insert", "run", "range", "raw", "scale", "block", "test", "tr", "ows", "bug", "r", "step", "key", "ow", "roll", "feed", "entry", "slice", "user", "id", "node", "rate", "la", "offset", "type", "order"], "use": ["ride", "match", "ate", "set", "parse", "us", "union", "load", "alias", "store", "ite", "are", "enable", "skip", "Use", "ise", "resource", "play", "force", "be", "allow", "using", "ge", "see", "usage", "USE", "ize", "write", "used", "replace", "late", "ignore", "site", "end", "apply", "abuse", "user", "fill", "status"], "sql": ["ls", "eps", "util", "result", "su", "sb", "summary", "json", "generic", "session", "csv", " SQL", "update", "ql", "s", "state", "seed", "sol", "sg", "serv", "socket", "install", "sys", "nl", "where", "dl", "comment", "statement", "cop", "description", "shell", "action", "error", "url", "job", "base", "SQL", "si", "log", "params", "setup", "printf", "function", "zip", "sl", "msg", "api", "query", "term", "string", "details", "repl", "general", "pr", "sq", "serial", "html", "acl", "insert", "ssl", "ob", "id", "sv", "sf", "type", "join", "db", "select", "cmp", "http"]}}
{"id1": "22046596", "id2": "6682825", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"copy": ["p", " cp", " copies", " copied", "sync", "paste", "Transfer", "download", "all", " dup", "to", "io", " copying", "clip", "transfer", "exec", "zip", " transfer", "upload", "Copy", "cp", "write", " Copy", "put", "file", "get"], "s": ["p", "ls", "x", "source", "as", "sb", "ps", "ts", "ss", "se", "c", "f", "less", "w", "e", "i", "input", "l", "src", "ds", "services", "sin", "m", "storage", "g", "a", "si", "ses", "os", "b", "u", "files", "fs", "is", "sl", "south", "ins", "xs", "gs", "sh", "outs", "ns", "es", "ssl", "sf", "o", "sv", "S", "v"], "t": ["p", "x", "tp", "pt", "ts", "tor", "ot", "z", "c", "f", "at", "tc", "e", "i", "ta", "l", "to", "down", "ty", "m", "object", "n", "g", "tty", "b", "it", " T", "T", "tf", "file", "temp", "y", "tr", "r", "template", "o", "v", "target"], "in": ["p", "source", "as", "init", "inn", "sync", "pin", "inner", "c", "f", "e", "i", "input", "l", "socket", "conn", "sin", "IN", "m", "win", "n", "g", "io", "up", "url", "din", "b", "is", "nin", "min", "ins", "h", "In", "inc", "again", "rin", "file", "pull", "r", "ssl", "login", "id", "reader", "bin", "d"], "out": ["p", "x", "call", "output", "client", "sync", "net", "c", "f", "at", "not", "w", "ex", "l", "OUT", "conn", "image", "writer", "io", "n", "g", "b", "null", "ext", "obj", "connection", "channel", "plain", "Out", "outs", "inc", "again", "off", "file", "temp", "parent", "err", "o", "user", "v", "bin", "d"]}}
{"id1": "4468255", "id2": "22035737", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "label": 0, "substitutes": {"copy": [" cp", "create", "sync", "parse", "paste", "load", "download", "update", "cat", "info", "link", "dump", "move", "process", "cop", "clone", "log", "rm", "share", "clip", "transfer", "split", "zip", "Copy", "cp", "opy", "write", "replace", "put", "file", "save", "ignore", "ssh", "get", "delete"], "from": ["source", "form", "normal", "ate", "the", "of", "so", "se", "client", "path", "empty", "c", " file", "f", "at", "with", "before", "back", "this", "config", " the", "link", "e", "one", "vol", "or", "by", "data", "left", "resource", "ce", "missing", "old", "open", "io", "original", "url", "base", "name", "log", "os", "add", "code", "zip", "without", "connection", "string", " form", "From", "stream", "range", "html", "file", "part", "er", "dir", "o", "entry", "id", "user", "parent", "start", "context", "http"], "to": ["x", "source", "cache", "so", "TO", "son", "too", "base", "name", "toc", "pe", "null", "sp", "two", "size", "but", "tom", "temp", "template", "dir", "target", "jo", "http", "disk", "as", "token", "client", "sync", "load", "front", "all", "plus", "one", "root", "de", "po", "or", "by", "data", "process", "io", "flo", "os", "comp", "To", "auto", "t", "site", "user", "parent", "db", "eto", "me", "tto", "output", "path", "termin", "not", "back", "socket", "line", "resource", "stat", "office", "o", "no", "p", "top", "about", "se", "system", "yet", "storage", "on", "database", "connection", "file", "dis"], "result": ["work", "match", "source", "method", "mask", "ret", "cache", "current", "arr", "length", "br", "effect", "continue", "ver", "info", "date", "math", "use", "event", "pass", "plus", "success", "card", "var", "count", "default", "val", "found", "follow", "data", "comment", "force", "up", "valid", "accept", "url", "search", "allow", "mer", "die", "function", "term", "res", "rc", "cur", "Result", "lock", "true", "future", "sum", "fail", "replace", "test", "ok", "ure", "part", "err", "results", "r", "compl", "diff", "entry", "sign", "member", "error", "ult", "report", "status"], "subFiles": [" subContents", "ubfiles", "singFiles", "subParts", "partFiles", "partFs", "ubContents", "subPages", "newsFiles", "newParts", "ubFiles", "ubPages", "SubFiles", " subDir", "subParents", " subfiles", "SubPages", "SubContents", "SubTokens", "subFile", "SubParts", "subDir", "newFiles", "singParents", "newsParts", "subContents", "Subfiles", " subFile", "subTokens", "partfiles", "singfiles", "singFs", "newPages", "subFs", "SubFile", "partParents", "newsTokens", "newsfiles", "newFile", " subPages", "subfiles", " subParents", "ubFile", "newfiles", " subFs", " subTokens", "ubDir", " subParts"], "i": ["p", "x", "uri", "inner", "c", "ai", "f", "s", "ii", "gi", "ori", "ix", "e", "d", "ie", "l", "I", "k", "ci", "ini", "q", "multi", "ip", "n", "io", "iu", "bi", "si", "a", "name", "u", "b", "it", "iv", "is", "ui", "pi", "oi", "li", "index", "j", "h", "hi", "mi", "di", "y", "xi", "key", "slice", "o", "id", "v", "ri", "ti", "phi"], "newDir": ["oldFile", "newFolder", "newJar", "nowDIR", "oldDIR", " newDIR", "nextQu", "NewFolder", "oldDirectory", "nowDirectory", " newFolder", "nowFolder", "subFile", "subDir", "subD", "nextDirectory", "nowDir", "oldDir", "nextDir", " newD", "nextFolder", "newQu", "NewJar", "subQu", "NewDirectory", " newDirectory", " newQu", "NewD", " newJar", "subJar", "newDIR", "nextFile", "newD", "newFile", "oldFolder", " newFile", "NewFile", "newDirectory", "subDirectory", "subFolder", "NewDir"], "in": ["source", "init", "re", "inn", "gin", "pin", "inner", "c", "f", "this", "ex", "e", "ie", "input", "l", "socket", "conn", "serv", "image", "IN", "data", "m", "con", "win", "ini", "up", "isin", "on", "a", "url", "din", "b", "it", "is", "nin", "min", "index", "ins", "lock", "cin", "thin", "lin", "In", "inc", "again", "file", "pull", "part", "r", "err", "login", "o", "reader", "id", "diff", "bin"], "out": ["call", "cy", "output", "sync", "client", "net", "inner", "c", "cat", "at", "all", "with", "w", "ex", "one", "word", "socket", "OUT", "conn", "line", "serv", "writer", "img", "on", "n", "io", "up", "base", "log", "name", "b", "ou", "ext", "exec", "post", "obj", "ch", "exp", "lock", "Out", "write", "sum", "outs", "again", "inc", "off", "file", "lib", "err", "op", "o", "bin", "co", "can"], "fileLength": ["linelength", "Filelength", "FileLength", "pagelength", "FileLen", "baselength", "lineSize", "FileSize", "lineLength", " filelength", "pageSize", "pageName", " fileSize", "baseSize", "fileName", "baseLen", " fileLen", " fileName", "fileSize", "baseLength", "fileLen", "pageLength", "lineName", "filelength"], "charBuff": ["pairMatrix", "stringMatrix", "stringBuffer", "charBuffer", "pairBuffer", " charBuffer", " charMatrix", "stringBuff", "pairBuff", "charMatrix"], "len": [" pos", "lf", "ln", "ni", "nt", "l", "pos", "line", "val", "n", "bin", " Len", "name", "fin", "fl", "split", "li", "en", "lit", "Len", "iter", "part", " split", "id", "rev", "start", "cmp"], "oneChar": [" oneCharacter", "eachCor", "nextCar", "singleCh", "fourchar", "zeroChar", " oneCor", "singleCor", "nextCh", "singlechar", "eachCharacter", "oneCar", " oneCh", "zerochar", "singleChar", "oneCor", "onechar", "oneCharacter", "eachChar", "fourCharacter", "nextCor", "fourChar", " oneCar", "oneCh", "zeroCharacter", "singleCar", "eachchar", "singleCharacter", "zeroCor", "fourCor", " onechar", "nextChar"]}}
{"id1": "255765", "id2": "12306305", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"f": ["p", "x", "form", "lf", "F", "flat", "filename", "ref", "of", "fp", "fun", "fx", "cf", "path", "c", "s", "this", "w", "e", "l", "ff", "m", "fm", "folder", "fen", "bf", "self", "io", "g", "n", "a", "fo", "inf", "name", "b", "fd", "fs", "fe", "function", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "file", "df", "t", "feed", "r", "sf", "fi", "fold", "v", "d"], "in": ["source", "init", "gin", "session", "config", "w", "image", "con", "isin", "ins", "In", "d", "rec", "inn", "token", "pin", "with", "or", "IN", "data", "ini", "win", "n", "g", "up", "nin", "thin", "lin", "t", "diff", "bin", "str", "input", "socket", "serv", "a", "b", "gen", "is", "login", "reader", "get", "inc", "din", "p", "inner", "c", "ac", "pass", "ex", "l", "m", "it", "vin", "exec", "fe", "min", "connection", "fa", "lock", "cin", "again", "rin", "part", "r", "err", "ssl", "v", "ic"], "cbuf": ["cfuc", "rbbuf", "bcul", "bbuf", "bbuff", "ebuff", "fbuf", "rbux", "fbbuf", "bburs", "bbull", "rbuff", "cbutf", "bcur", "cbault", "rbul", "bcux", "buff", "buf", "dbuc", "rbuc", "fbuc", "cbuc", "dbuff", "zbuu", "cbux", "zbuf", "bcuff", "rbault", "rbutf", "cbuff", "ebuf", "bcuf", "CBuc", "bcull", "bux", "bault", "CBuf", "fbuff", "bcurs", "CBul", "ebuu", "cfuf", "dbur", "zbuff", "cfuff", "dbuf", "cbur", "rbull", "cfbuf", "cbull", "cbul", "CBuff", "rbuu", "rbuf", "rburs", "cburs", "cbuu", "ebutf", "cfur", "bcuc", "zbutf", "cbbuf", "bcault"], "read": ["work", "text", "x", "buffer", "Read", "parse", "want", "config", "w", "k", "cel", "val", "build", "close", "name", "log", "add", "pe", "report", "reads", "ack", "size", "stream", "repeat", "write", "ak", "ok", "iter", "un", "y", "key", "feed", "type", "start", "error", "d", "run", "last", "sync", "check", "load", "use", "view", "level", "ed", "count", "data", "play", "io", "g", "allow", "rc", "raw", "used", "ing", "insert", "id", "select", "know", "call", " reading", "reading", "update", "lex", "READ", "input", "send", "skip", "socket", "sleep", "ind", "readable", "print", "valid", "bit", " write", "each", "ize", "only", "en", "orig", "wait", " READ", "loop", "put", "reader", "bind", "get", "inc", "fill", " Read", "ride", "seek", "create", "re", "se", "length", "pass", "q", "record", "open", "old", "find", "connect", "ink", "num", "it", "change", "child", "hex", "oct", "index", "full", "r", "er", "end", "draw"], "totRead": ["totoRead", "totReading", "tobyLoad", " totLink", "notLoad", "totiBuild", "octotoReading", "tazonLoad", "TotWrite", "totSearch", " totalBuild", "TotaWrite", "totalBuild", "ntotWrite", "intotRead", "nottRead", "intottLoad", "tottSearch", "totaReading", "totiLink", "TottLoad", "totalAccept", "totaRead", "tobyUse", "tottFind", "totoLength", " totalWrite", "nottWrite", "dottLoad", "tottClose", "TotaLoad", "towWrite", "tetRead", "dotLoad", "tottedFollow", "totoConnect", "tottReader", "TottReader", "towReading", "tntWrite", "TottSearch", "dottReading", "totoUse", "intottBuild", "totingGet", "tottUse", "totaLink", "ntotRead", "totClose", "totGet", "tottBuild", "octotRead", "totoFind", "tottAccept", "dotReader", "TottFollow", "totalRead", "TotConnect", "towRead", "totAccept", "totoLoad", "towLoad", "totaBuild", "dottReader", "totoReading", "dotUse", "octotLength", "nottLoad", "tochLoad", "ntottLoad", "tottConnect", "TotSearch", "tatReader", "totingWrite", "TottRead", "tottLoad", "dottWrite", "totUse", "TotLoad", "dottUse", "TotFollow", "ntottReader", " totalLink", "totingSearch", "tottDraw", "totLoad", "totReader", " totalRead", "toyWrite", "tetWrite", "dottRead", "totLink", "tottGet", "toyDraw", "tntRead", "ntottRead", "intotLoad", "tottWrite", "totiRead", "TotaRead", "tochWrite", "TotDraw", "TotGet", "totaWrite", "tochRead", "intotBuild", "toyLoad", "tottedRead", "tochReader", "totingRead", "notWrite", "notAccept", "tollWrite", "ntottWrite", "TotaDraw", "tntReader", "tottRead", "TottConnect", "totoWrite", "ntotReader", "intottClose", "TottWrite", "tcotBuild", " totBuild", "tatRead", "tobyRead", "TottGet", "tcotLoad", "TotReader", " totWrite", "octotReading", "tollRead", "totalLink", "tollLoad", "totBuild", "ntotLoad", "tntLoad", "totingConnect", "tobyFind", "tcotClose", "tazonBuild", "tottLength", "nottAccept", "tollReading", "tottedWrite", "notRead", "dotReading", "tottFollow", "totalLoad", "tatLoad", "totingFollow", "tazonClose", "towLength", "TotReading", "totaLoad", "tottReading", "totDraw", "dotWrite", "totoSearch", "totLength", "totWrite", "octotoWrite", "totConnect", "tottedGet", "tatWrite", "dotRead", "octotWrite", "tetReading", "intottRead", "dottFind", "dotFind", "intotClose", "totaDraw", "totalWrite", "octotoLength", "TottReading", "totFind", "totaReader", "tetLoad", "toyRead", "tcotRead", "tazonRead", "TotRead", "totFollow", "totiWrite", "octotoRead", "towAccept"], "out": ["p", "x", "init", "output", "client", "sync", "net", "c", "ac", "s", "w", "plus", "ex", "l", "socket", "conn", "OUT", "writer", "n", "g", "io", "a", "up", "b", "outer", "ext", "exec", "obj", "conf", "h", "fn", "exp", "connection", "Out", "In", "outs", "inc", "again", "off", "file", "parent", "part", "t", "err", "r", "o", "v", "bin", "d"], "i": ["x", "source", "init", "buffer", "current", "ai", "I", "k", "ci", "abi", "chi", "ip", "name", "u", "li", "y", "key", "slice", "start", "d", "ti", "uri", "info", "ei", "one", "data", "ini", "multi", "iu", "bi", "io", "g", "pi", "api", "j", "eni", "id", "hi", "me", "ii", "e", "input", "ind", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "zi", "ri", "my", "phi", "p", "length", "z", "c", "ni", "gi", "ix", "ori", "ie", "l", "yi", "m", "q", "it", "ui", "ik", "oi", "index", "fi", "r", "v", "ic"]}}
{"id1": "23273706", "id2": "7468819", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"getProjectTreeData": ["getProjectTreeInfo", "getprojecttreeInfo", "getProjecttreeDATA", "getProjectDocumentData", "getProjectPageDATA", "getprojectTreeData", "getProjectDocumentMeta", "getProjecttreeInfo", "getProjectPageData", "getprojecttreeDATA", "getProjectPageMeta", "getprojecttreeMeta", "getProjectDocumentInfo", "getprojectTreeMeta", "getProjectTreeMeta", "getProjectTreeDATA", "getProjecttreeData", "getProjectPageInfo", "getProjectDocumentDATA", "getProjecttreeMeta", "getprojectTreeInfo", "getprojecttreeData", "getprojectTreeDATA"], "treeData": ["TreeList", "contentInfo", "TreeArray", "TreeData", "treeArray", "monkeyData", "monkeyDec", "reeText", "treeDec", "contentText", " treeInfo", "treeText", "bodyDat", "storyDat", "reeDat", "reeInfo", "treeDat", "monkeyArray", "reeList", " treeDat", "storyData", " treeDec", "storyDec", "storyArray", "contentData", "contentDat", "reeArray", "bodyList", "bodyData", "reeString", " treeArray", "reeData", " treeText", "treeList", " treeString", " treeList", "bodyString", "TreeString", "treeString", "TreeInfo", "monkeyDat", "treeInfo"], "filename": ["figure", "whatever", "uri", "fp", "ppa", "path", "username", "kl", "wav", "title", "ername", "fil", "txt", "sheet", "data", "folder", "location", "metadata", "dll", "journal", "framework", "directory", "FILE", "url", "database", "name", "tmp", "kn", "kj", "fd", "files", "password", "dylib", "SourceFile", "upload", "string", "fn", "prefix", "Filename", "file", "nil", "jpg", "xml"], "urlString": [" urlURL", "URLString", "addressStr", "URLURL", "URLstring", "urlStr", "addressString", "URLStr", "addressURL", "urlUrl", "locationUrl", " urlstring", "urlURL", "locationString", "URLUrl", "urlstring", " urlUrl", "addressstring", "locationStr", "locationstring", " urlStr"], "urldata": ["urlledATA", "URldat", "urlledata", "urlledta", "urlfat", " urLDdata", " urLDta", "urldat", "urLDat", "urleddata", "urledATA", "urllata", "urledta", " urldATA", "urledata", "urLDta", " urLDATA", "URlddata", "urLData", "urldATA", "URlfata", "URlfat", " urldta", " urLData", "urlldata", "urlfATA", "urlfata", "urlfdata", "urllat", "urldta", "URlfATA", "URldata", "urLDATA", "urllATA", "URldATA", "urlleddata", " urlddata", "urlddata", "urLDdata", "URlfdata"], "factory": ["cFactory", " fault", "confFactory", " fFactory", "conflier", "confiller", "liller", "cflier", "fuild", "ciller", "lactory", "fFactory", "ufactory", "luild", "cault", "cfFactory", "pFactory", "ufuild", "cfiller", "flier", " flier", "lictionary", " fictionary", "pault", "ufictionary", "fault", "pactory", "filler", "confactory", " fuild", "ufiller", "piller", "cfactory", "cactory", "fictionary", " filler"], "parser": ["p", "lp", "arser", "util", "uri", "se", "json", "parse", "instance", "s", "driver", "root", "l", "manager", "loader", "writer", "ph", "Parser", "builder", "pdf", "ger", "up", "b", "utils", "monkey", "fruit", "api", "string", "jack", "handler", "plugin", "auto", "t", "er", "r", "reader", "parent", "xml", "raf", "library", "http"], "u": ["p", "uni", "uv", "util", "su", "uri", "uf", "us", "c", "plug", " ur", "eu", "s", "l", "tu", "ru", "yu", "io", "iu", "url", "ou", "b", "ui", "nu", "ur", "ul", "lu", "universal", "cu", "hu", "uu", "U", "o", "d", "http"], "is": ["p", "mis", "as", "ris", "init", "uri", "IS", "isa", "us", "ai", "info", "s", "its", "ori", "isu", "iss", "are", "ie", "Is", "serv", "or", "iso", "gets", "in", "ib", "lis", "ir", "ip", "io", "ar", "it", "fs", "ui", "isl", "pi", "api", "ais", "ios", "es", "abs", "iris", "obs", "ob", "bis", "has", "ri", "ops", "http"], "os": ["OS", "ops", "as", "dos", "ps", "so", "oss", "us", "bos", "s", "oes", "ens", "pos", "or", "iso", "ose", "gets", "sys", "ol", "oa", "opens", "io", "ros", "ms", "cos", "los", "fs", "bs", "fits", "oos", "ios", "aos", "ils", "es", "obs", "Os", "o", "ob", "osi", "bis", "oses", "http"], "iBufSize": ["iBufsize", "iBbufsize", "iBlfLength", "iBbufSize", "iByteufLength", "iBytebufSize", "iLlfLength", "iBytebufLength", "iByteufsize", "iLlfSt", "iBbufLength", "iByteufSize", "iBufLength", "iLufSt", "iLlfSize", "iBuffLen", "iLufSize", "iBbufLen", "iBlfsize", "iBufferSt", "iBufferSize", "iBuffLength", "iLlfsize", "iBlfLen", "iBuffersize", "iBytebufLen", "iBuffSt", "iLufLength", "iBytebufsize", "iBuffsize", "iBufSt", "iBuffSize", "iByteufLen", "iBufLen", "iBlfSt", "iLufsize", "iBufferLength", "iBlfSize"], "inBuf": ["inBluf", " inFbuf", "inbuf", " inFaf", "inDuff", "inBunk", "inFuf", "inFuff", "inDbuf", "outBuffub", "outBuffump", "inBump", "outBump", "inCbuf", "inCunk", " inBuff", "inBlunk", " inBaf", "inCuf", " inBump", "inPluf", "outBuf", "outBuffbuf", "inBuffuf", "inPlump", "inDuf", "inBub", "inDaf", " inBunk", " inCunk", " inCuf", "outBbuf", "inbub", "inBuffump", " inCbuf", "inCuff", " inCump", "inPlunk", "inFaf", "inBbuf", "inbump", "inFbuf", "outBuffuf", "inBuff", "inBuffbuf", "inBlbuf", " inFuff", "inbbuf", "inBlub", "inBuffub", "inBaf", "inCaf", "inBlump", "outBub", "inPlbuf", "inCump", " inFuf", " inBbuf"], "iNumRead": ["pNumberRead", "inumWritten", "qiNumREAD", "iChanBuild", "qiNumread", "pNumberWritten", "iValREAD", "iNumread", "inumread", "iLenRead", "iNumREAD", "iNumberBuild", "pNumberread", "pNumWritten", "iLenWritten", "iFatWritten", "inumWrite", " iFatWritten", "iChanREAD", "qiValread", " iFatRead", "pNumRead", "iNumWritten", "iNumberWrite", "iValRead", "iFatRead", " iNumWrite", "inumRead", "iValBuild", "iNumberread", "qiValREAD", "qiValBuild", " iFatWrite", "pNumread", "iNumberREAD", "iValread", "iNumberWritten", "qiNumBuild", "iChanRead", "qiNumRead", "iFatWrite", "iNumberRead", "iChanread", "pNumWrite", "iNumWrite", "qiValRead", "iLenWrite", " iNumWritten", "pNumberWrite", "iNumBuild"], "f": ["p", "F", "fp", "uf", "c", "s", "e", "l", "ff", "m", "n", "g", "io", "b", "fd", "fs", "fe", "j", "h", "fn", "fr", "fa", "handler", "rf", "full", "fc", "file", "df", "t", "r", "fi", "sf", "o", "feed", "v", "d"], "inputstream": ["Inputsw", " inputsw", "Inputchannel", " inputchannel", "outputchannel", "Inputstream", "contentStream", "InputStream", " inputStream", "inputsystem", "contentsw", "contentstream", "outputStream", "Inputsystem", "inputsw", "outputstream", "inputStream", "contentsystem", " inputsystem", "inputchannel"], "document": ["p", "source", "DOM", "media", "output", "language", "info", "page", "e", "l", "tree", "project", "ocument", "xml", "data", " documents", "m", "record", "object", "context", "director", "n", "directory", "window", "null", "docs", "Document", "Documents", "container", "list", "html", "dom", "office", "file", "collection", "t", "response", " documentation", "parent", "node", "d", "doc", "content"], "nodelist": ["nodedestyle", "nodemark", "nodestate", "nodata", "anodedeme", " nodesels", "nondestate", "nodedestate", "nodedeme", "snodseline", "NODelist", "nonedelist", "nozette", " nodesename", "Nodelist", "nozelist", "nODesh", "nodeeme", "snodselist", "nozename", "nodels", "snodsette", "nODelist", "nodette", "Nodestyle", "nodeestate", "nODeline", "nodedemark", "nodesename", "nODestyle", "anodedata", "anodestate", "snodslist", "nodedelist", "nondeme", " nodename", "nodeme", "snodlist", "nodesh", "nodestyle", "Nodemark", "anodelist", "snodelist", "Nodesh", "nonedette", "nodlist", "nodeline", "NODesh", "nodesels", "nozemark", "NODemark", "nondelist", "nondata", "nodedette", "snodette", "nozels", "nodeelist", " nodeselist", "nODette", "anodeme", "nodseline", "nodedlist", "nodsette", " nodette", " nodels", "nodedeline", "anodedestate", "nozestyle", " nodesette", "nodslist", "nodename", "nodeata", "nodedesh", "anodata", "nodeselist", "nODlist", "nodselist", "nozesh", "nonedels", "nonedename", "NODestyle", "nODemark", "nodedata", "anodedelist", "nodesette", "snodeline"], "num": ["Num", "dim", "uni", "init", "span", "uri", "net", "np", "len", "nom", "lim", "max", "pos", "count", "norm", "loc", "m", "NUM", "con", "total", "multi", "n", "zero", "col", "um", "nb", "nr", "number", "nu", "index", "om", "mon", "div", "comb", "ul", "tri", "sum", "en", "nam", "dom", "umi", "temp", "part", "mu", "unit", "inc", "node", "mult"], "i": ["p", "x", "uri", "c", "ai", "info", "ii", "gi", "ori", "ix", "ie", "d", "l", "I", "ci", "yi", "m", "chi", "in", "ini", "multi", "ip", "iu", "g", "io", "bi", "si", "a", "b", "col", "it", "iv", "ui", "ik", "pi", "oi", "ji", "j", "li", "index", "isi", "hi", "mi", "di", "qi", "eni", "y", "xi", "part", "fi", "cli", "mu", "slice", "id", "o", "v", "start", "ri", "ti", "phi"]}}
{"id1": "18489832", "id2": "3330944", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" doLoadZippedDir", " doLoadZaggedDir", " doLoadzippingFile", " doLoadzippedContent", " doLoadZaggedContent", " doLoadZippingContent", " doLoadzippingFiles", " doLoadZippingDir", " doLoadZedDir", " doLoadZaggedFile", " doLoadZaggedFiles", " doLoadzippedFile", " doLoadzippedFiles", " doLoadZedFiles", " doLoadZippedFiles", " doLoadZippingFile", " doLoadZippedFile", " doLoadZedContent", " doLoadZippingFiles", " doLoadZedFile", " doLoadZippedContent", " doLoadzippedDir", " doLoadzippingContent", " doLoadzippingDir"], "url": ["source", "uri", "client", "Url", "c", "download", "config", "f", "update", "store", "page", "event", "link", "i", "l", "image", "or", "loader", "web", "proxy", "resource", "open", "base", "log", "b", "server", "URL", "zip", "sl", "connection", "ur", "lr", "ll", "file", "lib", "pull", "bug", "r", "ssl", "route", "http"], "destDir": ["outputDIR", "destDirectory", "tempFolder", "tmpDirectory", "outputDir", "tempFile", " destdir", "DestDir", "tmpDir", " destDIR", "outputDirectory", "outputdir", "tempDIR", "destFile", "outputFolder", "tmpdir", " destDirectory", "tempDir", "DestFolder", " destFolder", " destFile", "destdir", "DestFile", "outputFile", "tmpDIR", "destFolder", "destDIR", "DestDIR"], "urlConnection": ["downloadConnection", "urlChannel", "URLConnect", "URLChannel", " urlconnection", "downloadFactory", "httpConnection", "httpFactory", "fileConn", "webconnection", "downloadConn", "fileFactory", "httpNetwork", "URLConnection", "urlConn", " urlChannel", "webConnection", " urlConnect", "downloadNetwork", "fileConnection", "urlNetwork", "httpConn", "fileNetwork", "urlConnect", "urlFactory", "URLconnection", "webConnect", "urlconnection", "webChannel"], "tmpFile": ["Tempfile", "partDir", "destfile", "destWorld", "destFolder", "TempWorld", "tmpPath", "partfile", "zipfile", "tempFiles", "mpPath", "mpFolder", "tempFile", "mpfile", "zipLine", "tmpFiles", " tmpEntry", "tmpDir", "mpFile", "destPath", " tmpfile", " tmpFiles", "tmpWorld", " tmpPath", "destFile", "TempPath", "destEntry", "tempDir", "tempfile", "partFolder", " tmpWorld", "tmpFolder", " tmpDir", "tmpfile", " tmpLine", "zipFile", "partFile", " tmpFolder", "tempEntry", "tmpEntry", "tempLine", "TempFile", "mpDir", "tempPath", "tmpLine", "zipFiles", "mpFiles"], "in": ["work", "source", "as", "init", "copy", "gin", "inn", "sync", "token", "pin", "inner", "c", "ac", "f", "ax", "info", "ex", "i", "input", "l", "socket", "conn", "IN", "data", "ini", "win", "con", "up", "n", "arin", "a", "din", "is", "nin", "min", "ins", "connection", "cin", "Out", "lin", "In", "inc", "en", "again", "rin", "kin", "file", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "copy", "output", "sync", "client", "check", "inner", "download", "at", "point", "this", "ex", "cmd", "i", "one", "socket", "OUT", "conn", "line", "IN", "writer", "up", "n", "bin", "io", "name", "null", "outer", "server", "ext", "exec", "obj", "nin", "min", "index", "connection", "Out", "In", "outs", "again", "off", "file", "err", "login", "o", "op", "inc", "co", "no"], "localURL": ["LocalAPI", "remoteURI", "localURI", "baseURI", "localAPI", "LocalUrl", "localUrl", "externalUrl", "externalCL", "externalAPI", " localFile", "LocalCL", " localURI", "remoteFile", "baseUrl", "localCL", "baseFile", "localFile", " localAPI", "remoteURL", " localUrl", "LocalURL", " localCL", "baseURL", "remoteUrl", "externalURL"]}}
{"id1": "1769771", "id2": "8754809", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyChannel", "copyfile", "CopyChannel", "copyFiles", "CopyFile", "copyChannel", "transferfile", "transferFile", "transferChannel", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "in": ["work", "source", "inn", "pin", "inner", "c", "f", "config", "ex", "i", "input", "l", "image", "IN", "data", "m", "win", "io", "bin", "url", "base", "name", "query", "min", "index", "ins", "lock", "lin", "In", "again", "file", "login", "id", "reader", "diff", "inc"], "out": ["p", "x", "dot", "call", "cache", "output", "c", "point", "extra", "w", "ex", "OUT", "conn", "image", "default", "writer", "resource", "io", "n", "up", "base", "name", "b", "ext", "server", "exec", "string", "external", "plain", "prefix", "Out", "write", "outs", "again", "off", "file", "o", "user", "v", "target"], "inChannel": ["insChannel", "Inchannel", "outchannel", "inClient", "inChan", "InClient", "insClient", "InChan", " inchannel", "inputChan", "inputChannel", "INChannel", "INChan", "INStream", "binClient", "winChan", "binChannel", "winChannel", "InStream", "binchannel", "outClient", "inputchannel", " inChan", " inClient", "InChannel", "inchannel", "insChan", " inStream", "insStream", "winchannel", "inputStream", "outChan", "outStream", "winStream", "binChan", "INchannel", "inStream", "binStream"], "outChannel": [" outCh", "outchannel", "OutChan", "inChan", " outStream", "inputChan", "inputChannel", "outCh", "outputchannel", "nChannel", "nChan", "outController", "outputController", "outManager", "Outchannel", "inputController", "inConnection", "inManager", "outConnection", "inController", "inCh", "outputCh", " outChan", " outchannel", "outputStream", "nStream", "inchannel", " outManager", "outputChannel", "OutConnection", "outChan", "outStream", " outConnection", "outputChan", "nManager", "OutChannel", "inStream", "inputchannel"]}}
{"id1": "21092340", "id2": "2668634", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToArchIVE", "addToAsively", "addtoArchives", "addToAdaptive", "addtoArchIVE", "addToAsives", "addToSlively", "addtoAsIVE", "addtoAsives", "addtoAsively", "addtoAsive", "addToAdaptIVE", "addToSlIVE", "addtoArchively", "addToAsIVE", "addtoArchive", "addToAdaptives", "addToSlive", "addToArchively", "addToSlives", "addToAsive", "addToArchives", "addToAdaptively"], "pod": ["p", "cache", "table", "plug", "pad", "component", "pl", "per", "po", "project", "pot", "loader", "module", "object", "ad", "ce", "bean", "Pod", "tmp", "pc", "pe", "proc", "peer", "host", "post", "zip", "child", "pi", "od", "plugin", "cer", "ods", "pid", "part", "pkg", "node", "product"], "podArchiveOutputStream": ["podArchiveIOFile", "podArchiveWriteFile", "podArchivesFileStream", "podArchIVEOutputDirectory", "podArchiveFileSteam", "podArchiveInputPath", "podArchIVEInputStream", "podArchIVEOutputFile", "podArchivesOutputStream", "podArchivesOutputResource", "podArchiveInputFile", "podArchiveOperationResource", "podArchiveIOResource", "podArchiveOutputFile", "podArchivesOutputFile", "podArchiveInputSteam", "podArchiveOperationFile", "podArchiveIOSteam", "podArchiveByteDirectory", "podArchiveByteFile", "podArchIVEInputFile", "podArchivesFileSteam", "podArchIVEOutputStream", "podArchIVEOutputSteam", "podArchivesFileFile", "podArchIVEInputSteam", "podArchivesFileResource", "podArchivingWriteSteam", "podArchiveWritePath", "podArchivingWritePath", "podArchiveOperationStream", "podArchiveFileDirectory", "podArchiveIODirectory", "podArchivingOutputStream", "podArchiveFileResource", "podArchiveOutputDirectory", "podArchivingOutputFile", "podArchiveOutputSteam", "podArchiveOutputPath", "podArchiveByteStream", "podArchiveInputDirectory", "podArchiveWriteSteam", "podArchiveByteSteam", "podArchiveIOStream", "podArchIVEInputDirectory", "podArchivesOutputSteam", "podArchiveInputStream", "podArchiveFileFile", "podArchivingOutputPath", "podArchiveFileStream", "podArchiveOutputResource", "podArchivingWriteFile", "podArchivingWriteStream", "podArchivingOutputSteam", "podArchiveFilePath", "podArchiveWriteStream", "podArchiveOperationSteam"], "filename": ["sequence", "property", "fp", "uri", "ppa", "path", "username", "kl", "download", "f", "alias", "archive", "title", "il", "fil", "word", "l", "loader", "folder", "module", "location", "binary", "which", "dll", "directory", "FILE", "platform", "url", "database", "name", "subject", "kn", "label", "files", "SourceFile", "string", "fn", "ename", "prefix", "Filename", "named", "file", "route", "nil", "sf", "application"], "source": ["text", "result", "copy", "output", "uri", "path", "config", "archive", "use", "seed", "slave", "driver", "input", "ource", "src", "image", "SOURCE", "loader", "Source", "service", "resource", "proxy", "document", "url", "zip", "sl", "string", "connection", "stack", "stream", "file", "slice", "reader", "unit", "parent", "target"], "entry": ["result", "se", "path", "Entry", "this", "archive", "event", "e", "ie", "pointer", "image", "line", "or", "data", "record", "object", "resource", "add", "it", "article", "ge", "obj", "post", "zip", "child", "address", "letter", "index", "string", "connection", "stream", "element", "auto", "file", "parent", "row", "r", "feed", "reader", "iterator"]}}
{"id1": "18989018", "id2": "17947246", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"doSetInput": [" doGetInput", " doSetContent", "dosetOutput", "dosetContent", "doGetContent", "doGetOutput", " doGetOutput", "doSetOutput", "doProcessInput", " doSetText", "dosetInput", " doGetText", "doGetInput", "doProcessOutput", "doProcessContent", "doProcessText", " doGetContent", " doSetOutput", "doSetContent", "doSetText", "doGetText", "dosetText"], "input": ["text", "form", "method", "util", "select", "remote", "expression", "output", "current", "client", "session", "inner", "field", "instance", "config", " inputs", "model", "head", "view", "Input", "command", "enter", "image", "present", "project", "install", "IN", "magic", "definition", "agent", "q", "argument", "act", "resource", "storage", "operator", "progress", "img", "error", "inf", "initial", "null", "exec", "child", "upload", "container", "list", "element", "submit", "raw", "impl", "parser", "insert", "request", "pull", "temp", "key", "entry", "reader", "type", "inc", "xml", "audio", "context", "active"], "monitor": ["p", "method", "meter", "summary", "out", "timer", "client", "pin", "mod", "config", "system", "state", "param", "timeout", "processor", "watch", "dm", "console", "manager", " monitors", "condition", "loader", "m", "module", "resource", "metadata", "progress", "mx", "directory", "callback", "subject", "counter", " Monitor", "mon", "channel", "mi", "Monitor", "bm", "handler", "cm", " monitoring", "wm", "mc", "reader", "unit", "pm", "report"], "root": ["work", "p", "remote", "result", "media", "output", "table", "out", "cover", "instance", "config", "home", "system", "this", "store", "archive", "slave", "owner", "manager", "src", "tx", "or", "process", "writer", "m", "folder", "resource", "Root", "location", "storage", "n", "directory", "base", "array", "null", "server", "host", "container", "target", "region", "plugin", "mount", "collection", "r", "parent", "node", "cms", "roots", "library", "http"], "format": ["form", "style", "filename", "util", "output", "FORM", "feature", "f", "config", "at", "model", "title", "event", "image", "et", "data", "magic", "writer", "service", "object", "location", "record", "transform", "act", "class", "base", "name", "spec", "Format", "function", "term", "api", "string", "fn", "handler", "element", "plugin", "filter", "parser", "attribute", "temp", "version", "template", "atter", "unit", "type", "ant", "pattern"], "source": ["text", "remote", "result", "output", "token", "client", "session", "inner", "instance", "config", "info", "component", "view", "use", "via", "driver", "src", "ource", "image", "SOURCE", "data", "Source", "service", "object", "resource", "proxy", "storage", "description", "spec", "secure", "container", "string", "connection", "scope", "channel", "size", "rule", "reference", "slice", "id", "reader", "unit", "rate", "parent", "node", "target", "content"], "in": ["text", "init", "buffer", "gin", "out", "session", "config", "image", "con", "isin", "name", "ins", "In", "slice", "inn", "token", "pin", "i", "conn", "or", "IN", "data", "ini", "win", "img", "n", "io", "nin", "include", "pull", "id", "parent", "bin", "str", "update", "socket", "ource", "resource", "from", "is", "container", "element", "value", "version", "login", "reader", "get", "din", "inc", "doc", "p", "inner", "c", "download", "f", "pass", "src", "inside", "read", "m", "on", "it", "min", "body", "index", "connection", "again", "r", "err"], "path": ["work", "text", "remote", "out", "session", "config", "alias", "PATH", "image", "loc", "location", "directory", "core", "base", "name", "log", "code", "true", "key", "template", "dir", "slice", "type", "pattern", "token", "sync", "this", "model", "component", "ath", "one", "data", "loader", "object", "binary", "password", "api", "thin", " Path", "mount", "id", "parent", "method", "str", "Path", "point", "link", "folder", "resource", " filename", "container", "string", "value", "step", "reader", "node", "content", "p", "filename", "port", " string", "pointer", "src", "host", "child", "index", "full", "route", "part", "walk"], "s": ["p", "ls", "sb", "ps", "ss", "sync", "session", "c", "f", "store", "sym", "e", "i", "l", "services", "src", "ds", "an", "m", "sys", "folder", "service", "ws", "storage", "n", "g", "sa", "si", "b", "share", "spec", "os", "fs", "sl", "secure", "stores", "h", "scope", " storage", "gs", "settings", "ns", "space", "abs", "sharing", "r", "ssl", "slice", "sf", "o", "sv", "S", "v", "js", "d", "http"], "file": ["p", "Image", "x", "filename", "remote", "copy", "File", "fp", "port", "output", "media", "f", "info", "store", "archive", "use", "il", "ile", "e", "l", "image", "xml", "data", "folder", "object", "resource", "binary", "open", "storage", "up", "directory", "FILE", "io", "base", "name", "b", "pe", "files", "string", "fn", "future", "full", " File", "value", "lib", "feed", "dir", "slice", "sf", "unit", "icon", "section", "node", "audio", "content"], "uri": ["text", "uni", "uid", "filename", "util", "username", "Url", "gi", "i", " URI", "image", "data", "abi", "service", "object", "location", "resource", "storage", "io", "base", "name", "database", "server", "URL", "ui", "query", "pi", "api", "address", "term", "iri", "connection", "rule", "prefix", "qi", "handler", "range", "attribute", "route", "cli", "dir", "URI", "id", "entry", "ri", "http"], "url": ["text", "ref", "str", "Url", "config", "store", "link", "l", "src", "ource", "image", "data", "object", "resource", "location", "sr", "io", "base", "name", "URL", "address", "sl", "string", "channel", "fr", "layer", "ul", "ssl", "key", "id", "user", "ri", "rel", "http"], "cd": ["CE", "cy", "cs", "CR", "md", "xc", "cf", "clean", "c", "lab", "de", "ca", "ds", "ci", "DC", "ce", "CD", "vd", "C", "CC", "cr", "nd", "pd", "gd", "dr", "rc", "cc", "arch", "cp", "dd", "cm", "co", "def", "xd", "CS", "ct", "cand", "ck", "cb", "d", "CF", "dc"], "valid": ["local", "Invalid", "normal", "style", "current", "Valid", "available", "empty", "successful", "all", "compatible", " invalid", "vals", "visible", "val", "present", "defined", "data", "required", "vari", " Valid", "allowed", "cert", "missing", "stable", "supported", "good", "multi", "VAL", "complete", "array", "standard", "multiple", "post", "secure", "list", "regular", "full", "legal", "iter", "bad", "value", "def", "sign", "id", "acceptable", "broken", "v", "correct", "pattern", "active"], "stream": ["flow", "message", "form", "video", "sw", "output", "client", "clean", "model", "content", "trans", "image", "read", "data", "writer", "object", "resource", "transform", "body", "container", "string", "Stream", "channel", "handler", "raw", "serial", "temp", "row", "feed", "response", "reader", "v", "draw", "context"], "document": ["text", "style", "filename", "video", "media", "output", "author", "system", "model", "this", "ocument", "image", "material", "data", "writer", "Source", "record", "object", "resource", "metadata", "description", "io", "Document", "Filename", "_", "Reader", "collection", "response", "template", "feed", "reader", "parent", "xml", "doc", "content"]}}
{"id1": "5951610", "id2": "5989666", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"testNetworkHTTP": ["testNETHTML", " testInternetHTTP", "testnetworkHTTP", "testNetworkHttp", "testnetworkSSL", "testInternetHTML", "testNETHTTP", "testNetworkSSL", " testInternetHttp", "testInternetSSL", "testNETSSL", "testInternetHTTP", "testnetworkHTML", " testNetworkHTML", " testNetworkHttp", "testInternetHttp", "testNetworkHTML", " testInternetHTML", " testInternetSSL", "testNETHttp", " testNetworkSSL", "testnetworkHttp"], "url": ["text", "gl", "buffer", "ml", "config", "hl", "event", "il", "bl", "image", "build", "loc", "left", "location", "ol", "base", "log", "rl", "channel", "key", "feed", "entry", "http", "group", "util", "uri", "tool", "load", "use", "view", "control", "loader", "email", "job", "lc", "coll", "layer", "impl", "lib", "pull", "user", "ls", "org", "call", "cloud", "output", "path", "update", "pl", "nl", "resource", "shell", "URL", "fl", "sl", "ul", "ll", "rel", "mail", "large", "Url", "page", "l", "blog", "github", "web", "service", "dl", "bf", "www", "server", "host", "connection", "ur", "cl", "lr", "el", "file", "ssl", "r", "ob"], "urlConnection": ["emailconnection", "flConstruction", "lengthConnection", "termConn", "UrlConnect", "ulUnit", "urlConstruction", "urlFunction", "urlConn", "blogConnect", "implReference", "UrlContainer", "webConnection", " urlConnect", "numberconnection", "termComputer", "serviceConnect", "resourceGate", "httpConn", "emailConnect", "httpComputer", "urlFactory", " urlConnector", " urlPool", "emailClient", "urFunction", "lconnection", " urlEnvironment", "viewConnect", "httpFactory", "httpConnection", "uriComputer", "urlPool", "urlUnit", "ulConn", "uriFunction", " urlClient", "htmlconnection", "urFactory", "flConnect", "webPool", " urlComputer", " urlReference", "emailConstruction", "serviceConn", "implEnvironment", "urlConnect", "UrlEnvironment", "uriUnit", "UrlConn", " urlConn", "serviceConnection", "numberConnector", "sslConnection", "urlComputer", "ulConnection", "resourceconnection", "urlConnector", "UrlConnection", "sslConn", "implConnection", "UrlComputer", "urConn", "htmlConnection", "URLConn", "lConnect", "emailConnection", "urlEnvironment", "lConnection", "urlReference", "URLConnection", "sslUnit", "viewConnection", "urlGate", "blogconnection", "glFunction", "numberConnection", " urlGate", "viewConstruction", "blogConnector", "ulConnector", "glConn", "urlClient", "serviceconnection", "glConnection", "URLConnect", "flconnection", "UrlReference", " urlconnection", "glConnect", "numberConnect", "sslConnector", "lengthconnection", "lConn", "urlContainer", "termContainer", "httpFunction", "urConnection", "emailGate", "resourceClient", "webconnection", "viewconnection", "lengthConstruction", " urlFactory", "termConnection", "flConnector", "htmlConstruction", "UrlFunction", "URLPool", "flConnection", " urlFunction", "uriConnection", "blogConnection", "URLconnection", "urlconnection", " urlContainer", "resourceConnection", " urlUnit", "lengthConnect", "httpUnit"], "rd": ["ird", "lf", "rx", "own", "rid", "arr", "lt", "wd", "rr", "RD", "dig", "rowd", "d", "dj", "bl", "ds", "RR", "nor", "addr", "nl", "rs", "ru", "director", "rown", "sr", "bf", "sth", "rob", "vd", "adr", "DR", "fd", "hr", "rl", "R", "nd", "RF", "wr", "pd", "gd", "rb", "dr", "rss", "respond", "fr", "ld", "rw", "dd", "rn", "ng", " reader", "lr", "usr", "rf", "Reader", "rt", "RL", "std", "xd", "td", "rod", "r", "dh", "tr", "reader", "RW", "rg", "rh", "db", "erd", "dra", "red", "bd", "rand"], "line": ["source", "lf", "Line", "lines", "cell", "lo", "frame", "day", "len", "page", "pass", "link", "word", "l", "skip", "val", "inline", "loc", "data", "nl", "comment", "ne", "limit", "log", "name", "lc", "col", "code", "ge", "rl", "sel", "number", "sl", "letter", "msg", "li", "string", "ld", "cl", "LINE", "lin", "el", "write", "block", "file", "part", "row", "key", "response", "login", "entry", "end", "le", "unit", "id", "user", "error", "d", "la", "status"]}}
{"id1": "19934218", "id2": "22752444", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"doCrypt": [" runMac", " runExt", "murDec", " doDec", "murExt", "DoMac", "DoCrypt", "murMac", " doMac", "murCrypt", "DoDec", " doExt", "DoExt", " runDec", " runCrypt"], "text": [" TEXT", "source", "message", "secret", "buffer", "token", "str", " Text", "length", "path", "config", "this", "font", "seed", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "context", "format", "binary", "editor", "class", "url", "name", "ext", "Text", "obj", "password", "code", "letter", "hex", "string", "connection", "struct", "crypt", "value", "key", "EXT", "contract", "pattern", "content"], "UnsupportedEncodingException": ["UnsupportedEncodedEx", "UnsupportedEncoderError", "UnsupportedEncoderException", "UnsupportedEncodingEx", "UnsupportedEncodingError", "UnsupportedEncasingException", "UnsupportedEncodedError", "UnsupportedEncasingError", "UnsupportedEncodedException", "UnsupportedEncasingEx", "UnsupportedEncoderEx"], "md": ["me", "message", "method", "mand", "hm", "mode", "mm", "mp", "mod", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", "mb", "meta", "mg", "sd", "data", "m", "map", "nm", "ad", "mad", "metadata", "mac", "bf", "valid", "rm", "ud", "ms", "vd", "code", "pd", "sha", "body", "gd", "dr", " MD", "ld", "mn", "dd", "od", "mo", "bm", "mt", " Md", "hd", "am", "def", "MD", "mc", "ma", "df", "mag", "pm", "d", "bd"], "sha1hash": ["SHA1hex", "sha5hex", "md6h", "md1sha", "SHA1sum", "sha6hash", "md6sha", "shaonesha", "sha1hex", "sha0hex", "sha2sha", "sha1sha", "SHA2h", "sha6h", "sha5sha", "sha5Hash", "SHA2sha", "SHA1sha", "md1hash", "SHA2hex", "sha256hex", "sha6sha", "sha2h", "sha2Hash", "sha1Hash", "sha256sum", "sha2hash", "sha256sha", "SHA1h", "md1h", "sha5hash", "sha5h", "sha256Hash", "SHA2hash", "sha6hex", "SHA1Hash", "sha2hex", "sha2sum", "SHA1hash", "shaonehash", "sha1h", "sha0sha", "md1hex", "sha1sum", "sha0sum", "shaoneh", "shaonehex", "SHA2sum", "md6hash", "sha256h", "sha256hash", "SHA2Hash", "sha0hash", "md6hex"]}}
{"id1": "19050432", "id2": "19006212", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openParamingresource", "openNamedResources", "openNnamedResources", "openNamingResources", "openNestedresource", "openNamingresource", "openParamedResources", "openParamingResources", "openNestedResource", "openParamingURI", "openNamingURI", "openParamingResource", "openNnamedResource", "openParamedresource", "openNamedresource", "openNamingResource", "openNnamedresource", "openNnamedURI", "openNamedURI", "openNestedURI", "openParamedURI", "openParamedResource", "openNestedResources"], "name": ["source", "filename", "uri", "str", "path", "username", "ame", "NAME", "info", "word", "Name", "data", "names", "definition", "resource", "old", "n", "class", "url", "base", "address", "string", "size", "prefix", "full", "named", "file", "value", "version", "part", "key", "sea", "id", "type", "parent"], "in": ["source", "as", "result", "rec", "inn", "gin", "out", "token", "pin", "inner", "ac", "f", " out", "i", "input", "socket", "conn", "val", "get", "IN", "data", "con", "win", "resource", "ini", "url", "din", "pc", "b", "vin", "nin", "ins", "connection", "cin", "thin", "In", "fc", "inc", "again", "rin", "kin", "r", "oin", "login", "err", "reader", "edIn", "bin", "ic"], "propsURL": ["proopsLL", " propsUR", "proportsELF", "proppsUR", "prosUL", " propsSSL", "prorsUrl", "prorsurl", "propsCL", "prodsUrl", "proportsUL", " propsLL", "perrsurl", " propsUrl", "prosUrl", "propsLL", "propsUrl", " propsUL", "prosSSL", " prodsURI", "proopsURI", "PropsSSL", "probsURL", "proopsUrl", "probsLL", "procsSSL", " prodsURL", "procsURL", "prodsLL", "pronsURL", "protsURL", "protsurl", "prosLL", "perrsFile", " propsELF", " prolsSSL", "propdsUR", "prodsCL", "propsSSL", " prolsurl", "proopsUR", " propsurl", " prodsurl", "prodsSSL", "prosURL", "propdsUrl", "prodsURI", " propsCL", "prodsURL", "prodsFile", "progsURI", "ProsURI", " proportsUR", "protsFile", "proppsURL", "proppsLL", "prolsurl", "perpsURL", "propsELF", "prolsSSL", "PropsUrl", "probsUL", "prorsFile", "procsurl", "probsUrl", " proportsLL", " proportsUrl", " propsURI", "perpsFile", "propdsURL", " prodsCL", " proportsUL", "perrsURL", "prolsURI", "propsUR", "proportsURL", "propsUL", "prodsurl", "ProsSSL", "prorsELF", "proportsurl", "PropsURL", "propsFile", "propdsLL", "proportsUR", "pronsUrl", "propsurl", "procsURI", "proopsURL", "ProsURL", "proopsurl", "progsURL", "progsurl", "procsUrl", " prolsURL", "progsCL", "prodsUR", "proportsLL", " prolsURI", "prosURI", "proportsSSL", "prorsURL", "pronsLL", "proppsUrl", "propsURI", "proportsUrl", "proopsELF", "PropsURI", "proportsURI", "pronsUR", "prolsURL", " proportsURL", " proportsELF", "proopsCL", "ProsUrl", "perpsurl", "prorsUR"], "urlConn": ["httpconn", "URLConnect", "httpContext", "sslconn", "sslCod", "urlContext", "sslConn", "fileConn", "httpConnect", "urlCod", "sslCond", "URLConn", "URLContext", "httpCod", " urlCond", "urlconn", " urlConnect", "URLConf", "urlCond", "fileConnect", "httpConn", "urlCmd", "urlConnect", "sslCmd", " urlContext", " urlConf", "fileCond", "fileCmd", "sslConnect", " urlCmd", "urlConf", " urlconn", "httpConf", " urlCod"], "httpURL": ["httpsURI", "apiUR", "HttpUrl", "HttpURI", "autoUrl", "httpURI", "httpsUR", "httpsUrl", "apiML", "HttpURL", "httpSSL", " httpurl", " httpSSL", " httpML", "httpUrl", "apiURL", "httpsURL", "httpsurl", "httpurl", "httpsSSL", "HttpUR", " httpUR", "autoURL", "autoSSL", "apiUrl", "httpUR", " httpUrl", " httpURI", "autourl", "HttpML", "httpML"], "hdrVal": [" hheaderVal", "hrStr", "hhrval", "HhrVal", "hdValues", "Hhrval", "hreqStr", "hdrValues", "hrVol", "hDRval", "hndValue", "hdrVol", "hreqVal", " hdrStr", "HdrBu", "hdValue", "HdrValues", "hndBu", " hheaderVol", "HdrDef", "hdval", "hDRValue", "hhrDef", "hhrVal", "hrValue", "HhrBu", "hrcVal", "hrVal", "HhrValues", "Hdrval", "hrcValue", "hhrValues", "hhrValue", "hdVal", "hreqValue", "hheaderVal", " hheaderStr", "hheaderStr", "hndDef", "HhrDef", "hheaderValue", "HdrValue", "hdrDef", "HdrVal", "hDRValues", "hDRVal", "hdrStr", "hrcBu", "hndVal", " hheaderValue", "HhrValue", " hdrVol", " hdrValue", "hrcDef", "hdrval", "hreqVol", "hdrValue", "hheaderVol", "hhrBu", "hdrBu"], "code": ["text", "message", "result", "mode", "ode", "check", "c", "cat", "info", "status", "charge", "state", "success", "e", "one", "level", "ie", "count", "line", "data", "const", "age", "ce", "comment", "ec", "expected", "core", "class", "no", "url", "pc", "reason", "pe", "ge", "zip", "number", "grade", "msg", "Code", "index", "see", "ack", "cc", "category", "rule", "rc", "header", "string", "codes", "fail", "score", "test", "desc", "cod", "value", "version", "xx", "key", "response", "id", "rate", "type", "zone", "error", "co", "go", "content", "coded"]}}
{"id1": "20181656", "id2": "7764011", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "label": 0, "substitutes": {"sortRows": ["sortSlows", "ortROWS", "sortSlrows", "sortPRow", "sortSlRow", "ortLRow", "sortLrows", "sortProws", "ortRRow", "sortLows", "ortLrows", "ortRrows", "sortPows", "sortRRow", "ortLows", "sortRrows", "sortPOWS", "sortLOWS", "sortLRow", "sortSlOWS", "ortRows", "sortROWS", "ortLOWS"], "rows": ["frames", "relations", "holes", "right", "uds", "rules", "tests", "types", "result", "ends", "lines", "orders", "ss", "forms", "ips", "keys", "groups", "shows", "heads", "boards", "rank", "projects", "errors", "cases", "rs", "checks", "rooms", "cells", "multi", "flows", "values", "ros", "ks", "roads", "array", "docs", "files", "members", "rss", "index", "times", "models", "fields", "pages", "acks", "views", "points", "vers", "raw", "runs", "grid", "users", "ows", "rates", "grades", "headers", "row", "results", "tracks", "items", "maps", "breaks", "ports", "slice", "blocks", "diff", "ids", "roots", "posts", "builders"], "i": ["p", "x", "ij", "z", "c", "ai", "f", "ii", "ix", "l", "I", "ci", "ind", "m", "ip", "iu", "bi", "io", "a", "si", "b", "u", "ui", "ik", "pi", "ji", "ki", "li", "index", "mi", "y", "xi", "id", "v", "ri", "phi"], "j": ["p", "x", "json", "ij", "jan", "z", "br", "jl", "f", "ii", "ix", "e", "dj", "l", "k", "aj", "ind", "q", "jit", "n", "next", "job", "v", "jj", "ja", "u", "b", "obj", "ui", "oj", " dj", "ik", "ji", "jc", "li", "h", "index", "fr", "qi", "jp", "y", "key", "adj", "uj", "o", "J", "js", "d", "jo"], "temp": ["flow", "pre", "flat", "cache", " Temp", "z", "cell", "empty", "emp", "shift", "tc", "this", "extra", "needed", "input", "max", "area", "k", "get", "tem", "Temp", "stable", "ip", "n", "tmp", "fake", "col", "null", "index", " tmp", "dev", "orig", "iter", "test", "parent", "partial", "err", "circ", "diff", "unit", "id", "v", "offset", "except"]}}
{"id1": "5998352", "id2": "4468255", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["testStandardTae", "testStandardFae", "teststandardTee", "testStandardBees", "teststandardMee", "testStandardBae", "testStandardMae", "teststandardTae", "teststandardTeed", "testStandardMee", "testStandardBee", "teststandardTees", "testStandardFees", "teststandardMae", "testStandardTees", "teststandardMees", "testStandardTeed", "testStandardFee", "testStandardMees", "testStandardBeed", "testStandardFeed", "testStandardMeed", "teststandardMeed"], "reference": ["primary", "sequence", "message", "ref", "relation", "filename", "buffer", "remote", "copy", "re", "output", "forward", "uri", "length", "path", "hello", "c", "memory", "archive", "compatible", "pointer", "single", "resource", "location", "binary", "format", "proxy", "References", "description", "directory", "document", "url", "database", "name", "rice", "server", "relative", "code", "number", "address", "variable", "index", "see", "string", "connection", "external", "specified", "prefix", "test", "distance", "attribute", "collection", " Reference", "Reference", "version", "request", "ference", "REF", "type", "target", "report", "order", "pair"], "source": ["text", "ref", "buffer", "result", "copy", "output", "se", "table", "config", "view", "driver", "e", "i", "ie", "input", "ource", "src", "SOURCE", "writer", "Source", "service", "object", "resource", "proxy", "ce", "io", "g", "url", "server", "code", "fe", "string", "connection", "iter", "temp", "r", "slice", "reader", "parent", "target", "context"], "destination1": ["destinate1", "constinationOne", "destination01", "Destension1", "destensionOne", "DestinateOne", "constinator2", "destinationOnce", "destinationOne", "destentionOne", "destension0", "destinations01", "destaration1", "destinator1", "Destension0", "constinator01", "destaration0", "destention1", "destinatorOne", "destinator01", "destentionOnce", "constination2", "destribution1", "Destination1", "destinate01", "destinateOnce", "constinator1", "constinatorOne", "Destinate1", "destension1", "destinations2", "constination1", "destribution0", "destinationsOne", "Destination0", "destinateOne", "destinations1", "constination01", "destributionOne", "destinator2", "DestinateOnce", "destarationOne", "DestinationOne", "DestensionOne", "destinate2", "destinatorOnce", "destination0", "DestinationOnce"], "destination2": ["destication8", "destinate1", "destributionSecond", "destignment1", "desticationSecond", "destinating4", "destinating1", "destinationtwo", "coordinate8", "destinating2", "destinate8", "Destinatetwo", "destinatetwo", "descinations2", "destication22", "Destinationtwo", "descinations02", "destinationsSecond", "destination02", "descination2", "destribution2", "descinationsSecond", "destation2", "coordination2", "coordinate22", "destinate22", "destinatingtwo", "destination8", "Destination1", "destinate02", "Destination2", "descination1", "destination22", "coordination22", "descinations1", "destinate4", "Destinate1", "coordinate2", "destinations2", "destinations02", "destignment02", "destignment2", "destinationSecond", "descinationSecond", "destignmentSecond", "Destination4", "destation1", "destribution22", "coordinateSecond", "destinations1", "destationtwo", "destication2", "destinateSecond", "coordination8", "Destinate4", "destribution8", "descination02", "destinate2", "coordinationSecond", "destation4", "destination4", "Destinate2"], "tee": ["ceea", "lei", "tepe", "TEea", "seae", "TEc", "chef", "leee", "leffe", "teffe", "seee", "tec", "cec", "TEe", "ettee", "teec", "chepe", "eeee", "etteee", " tepe", "teee", "ettef", "TEee", "etteae", "lepe", " tef", "tei", " teae", "teea", "see", " teee", " teea", "tef", "eeec", " teec", "teae", "leec", "chei", "chee", " tei", "cee", "sef", "eeffe", "eee", "lef", " teffe", "lee", "ceee", " tec"]}}
{"id1": "19910627", "id2": "19147281", "code1": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"getData": ["readdata", "readContent", "postData", "printData", "postContent", "readData", "getContent", "postdata", "getFeed", "postFeed", "getdata", "readFeed", "printFeed", "printContent", "printdata"], "httpclient": ["httpserver", "HttpClient", "httpconnection", "httpsClient", "ttpClient", "httpsserver", "Httpserver", "phpconnection", "phpserver", "httpClient", "Httpclient", "Httpconnection", "ttpcache", " httpserver", "ttpclient", "httpcache", "phpclient", "phpClient", " httpcache", "httpscache", " httpconnection", " httpClient", "ttpserver", "httpsclient"], "get": ["method", "make", "call", "init", "create", "remote", "json", "set", "parse", "generic", "client", "check", "invoke", "load", "update", "use", "show", "e", "i", "enable", "send", "single", "read", "build", "service", "resource", "open", "find", "g", "base", "add", "it", "ge", "exec", "query", "api", "body", "GET", "Get", "write", "full", "like", "put", "request", "pull", "start", "handle", "http"], "response": ["message", "result", "output", "json", "client", "out", "event", "page", "success", "e", "application", "resp", "data", "resource", "reply", "document", "server", "Response", "api", "body", "onse", "connection", "respond", "ception", "received", "collection", "request", "feed", "error", "report", "status", "http"], "entity": ["ent", "message", "result", "media", "output", "json", "client", "activity", "environment", "event", "component", "person", "http", "e", "image", "issue", "data", "object", "resource", "ce", "document", "em", "pe", "server", "article", "api", "body", "connection", "element", "el", "file", "collection", "unit", "xml", "Entity", "content", "application"], "instream": ["Inprogress", "Inchannel", "outstream", "outchannel", "Inform", "outprogress", "outform", " inchannel", "inschannel", " infile", "inprogress", "inputstream", " inform", "Instream", "insfile", "inform", "inchannel", "insstream", "inputform", " inStream", "insStream", "inputStream", "outfile", "infile", "inputprogress", "outStream", "Infile", "inStream", "InStream"], "responseMessage": ["responseMsg", "ResponseBody", " responseBody", " responseContent", " responseMsg", "respondMsg", "ResponseMessage", "respondBody", "responsemessage", "Responsemessage", "responseBody", "ResponseMsg", "respondMessage", " responsemessage", "respondContent", "ResponseContent", "responseContent", "respondmessage"]}}
{"id1": "6371580", "id2": "7044685", "code1": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"insertDomain": [" insertHost", "updateHost", "insertdomain", "updateDomain", " insertdomain", "insertDom", "addDom", " insertDom", "updatedomain", "adddomain", "addDomain", "updateDom", "addHost", "insertHost"], "domains": ["demains", "messances", "Domands", "domands", "demances", "Domages", "commances", "domales", "dimains", "domages", "demain", "messands", "dimages", "dimands", "dimales", "commands", "domances", "demales", "commains", "demands", "commain", "Domales", "messain", "demages", "messains", "Domains"], "psImpl": ["ipsManager", "osFactory", "paramsInterface", "PSOrg", "paramsManager", "upsUl", "psEl", "qsImpl", "osImpl", "osEl", "upsimpl", " psOrg", "psManager", "qsimpl", "osimpl", "upsImpl", "ipsEl", " psManager", " psInterface", "PSImpl", "qsUl", " psInstance", "ipsInstance", "PSFactory", "PSimpl", " psFactory", "ipsInterface", "psimpl", "ipsImpl", "PSUl", " psimpl", "ipsOrg", "psInterface", "psFactory", "paramsImpl", " psEl", "paramsInstance", "psInstance", "psUl", "ipsimpl", "psOrg", "PSEl"], "iter": ["inse", "itter", "set", "parse", "apper", "inner", "finder", "ite", "ter", "page", "cher", "e", "i", "enter", "upper", "gener", "ner", "walker", "in", "ir", "ider", "ip", "next", "Iterator", "it", "izer", "Iter", "is", "ator", "index", "former", "over", "chain", "coll", "el", "cer", "inc", "sort", "loop", "err", "er", "feed", "entry", "end", "reader", "inter", "iterator", "oper", "order"], "domain": ["message", "remote", "result", "role", "country", "str", "brand", "feature", "company", "model", "page", "command", "root", "Domain", "data", "agent", "example", "module", "folder", "format", "description", "division", "url", "base", "name", "host", "query", "address", "index", "string", "rule", "region", "origin", "prefix", "range", "dom", "value", "version", "file", "route", "key", "id", "site", "unit", "type", "zone", "node", "pattern", "product"]}}
{"id1": "20924119", "id2": "12172485", "code1": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"gzip": ["GZip", "gsZip", "Gzip", "gpack", "Gpack", "ggz", " ggz", "Ggz", "gszip", "gsgz", "gspack", " gZip", " gpack", "gZip"], "zipout": ["zOUT", "zipOut", "zensize", "Zipsize", "zipin", " zipin", " zipOUT", "zengen", "zOut", "gzOut", " zipgen", "zsize", "zipsize", "zout", "gzout", "Zipin", "zgen", " zipsize", "zipgen", "zenin", "zenout", " zipOut", "ZipOut", "gzin", "gzOUT", "Zipout", "zin", "zipOUT"], "buffer": ["text", "source", "sequence", "message", "position", "result", "cache", "uf", "memory", "bb", "buff", "pad", "buf", "bytes", "input", "uffer", "line", "padding", "read", "data", "binary", "limit", "document", "base", "url", "b", "null", "server", "code", "transfer", "number", "address", "Buffer", "variable", "string", "header", "stack", "queue", "layer", "batch", "block", "reference", "iter", "pause", "wave", "slice", "reader", "bin"], "dir": ["source", "rec", "md", " Dir", " manager", " cur", "path", "Dir", " directory", "download", "f", "home", "wd", "archive", "manager", "project", "area", " direction", "loc", "data", "folder", "DIR", " db", "director", "ir", "dep", "directory", "url", " d", " url", "fd", " module", "zip", "direct", "dist", "container", "dr", "direction", " director", "di", "coll", "plugin", "iter", "desc", "file", "lib", "parent", "dn", "id", "pkg", "entry", " folder", " project", "db", "d", "jar", "dc"], "in": ["as", "init", "into", "rec", "gin", "inn", "out", "token", "inner", "ac", "f", "ex", "per", "i", "input", "serv", "conn", "inside", "image", "socket", "IN", "data", "ini", "win", "con", "io", "isin", "din", "b", "is", "nin", "min", "ins", "h", "connection", "cin", "stream", "lin", "In", "impl", "inc", "again", "rin", "file", "kin", "err", "login", "id", "reader", "bin"], "length": ["sequence", "filename", "position", "shape", "Length", "path", "available", "point", "f", "len", "level", "i", "l", "angle", "count", "line", "ength", "build", "data", "ph", "duration", "total", "limit", "url", "character", "job", "width", "code", "number", "zip", "string", "size", "lock", "block", "ish", "weight", "distance", "off", "part", "row", "partial", "feed", "slice", "entry", "id", "reader", "end", "type", "section", "ob", "join"]}}
{"id1": "10451698", "id2": "9109613", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "create", "remote", "sync", "py", "paste", "load", "update", "download", "cat", "archive", "dump", "move", "drop", "process", "cop", "clone", "rm", "clip", "share", "change", "transfer", "split", "zip", "Copy", "list", "lock", "cp", "write", "replace", "file", "parent", "part", "ignore", "ssh", "type", "get", "delete", "run"], "source": ["filename", "result", "flat", "cache", "current", "client", "remote", "path", "config", "info", "model", "view", "seed", "slave", "use", "plus", "root", "ie", "ource", "src", "project", "SOURCE", "image", "data", "Source", "service", "object", "from", "resource", "ce", "proxy", "folder", "storage", "directory", "class", "document", "url", "name", "null", "server", "secure", "string", "scope", "connection", "section", "stream", "iter", "file", "slice", "sf", "reader", "site", "unit", "parent", "start", "archive", "target"], "destinationDirectory": ["destificationDir", "destributionPath", "destributionHome", "destinationFile", "DestributionDirectory", "DestributionDir", "DestinationPoint", "DestinationDirectory", "destarationDirectory", "destructionDir", " destinationsFolder", "DestinationPath", "destinationPath", "DestinationHome", "DestinationFolder", "destinationsFile", "destinationsDirectory", "destificationHome", "DestributionPath", "destippingHome", "destructionFile", "destributionDir", "destinatorPath", "destinationDir", "destinatorPoint", "destributionFile", "destarationPoint", "DestributionHome", " destinationsDirectory", "destippingFolder", "destificationFolder", " destinationFolder", " destinationsFile", "destarationPath", "DestinationDir", "destributionDirectory", "destinationFolder", " destinationFile", "destructionFolder", "destinationsFolder", "destippingDirectory", "destructionDirectory", "destinatorDirectory", "DestributionPoint", "destinationsDir", "destributionFolder", "DestributionFolder", " destinationDir", "destificationDirectory", " destinationsDir", "destippingDir", "destributionPoint", "destinationPoint", "destinationHome"], "newDir": ["newFolder", " newdir", "NewFolder", " newFolder", "nextDirectory", "nextDir", "nextFolder", "nextdir", "NewDirectory", " newDirectory", "nextFile", "NewFile", "newDirectory", "newdir", "Newdir", "NewDir"], "children": ["ren", "tests", "ums", "rules", "filename", " Children", "words", "uc", "current", "father", "kids", "iblings", "scenes", "Children", "ools", "balls", "projects", "loc", "data", "names", "web", "parents", "other", "which", "opens", "values", "url", "roots", "iv", "files", "sub", "members", "child", "each", "ins", "list", "pages", "blocks", "begin", "ul", "sort", "collection", "mount", "when", "items", "pes", "parent", "events", "packages", "rows", "content"], "i": ["p", "x", "uri", "inner", "ai", "f", "gi", "ii", "info", "ori", "ix", "e", "ie", "I", "k", "ci", "m", "ini", "in", "q", "multi", "ip", "iu", "n", "io", "si", "u", "b", "ti", "it", "iv", "lc", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "mi", "di", "qi", "y", "xi", "part", "fi", "key", "slice", "mu", "o", "id", "end", "type", "v", "start", "ri", "d"], "newFile": ["newSource", " newSourceFile", "oldFile", "Newfile", "createFile", "nextfile", "oldDirectory", "newfile", "nextSourceFile", "createfile", "nextSource", " newFiles", "newFiles", "oldDir", "nextDir", "NewFiles", " newfile", "NewDirectory", " newDirectory", "NewSource", "createDir", "nextFile", "createSource", "newSourceFile", "NewSourceFile", "NewFile", "newDirectory", "nextFiles", "oldFiles", "NewDir"], "output": ["flow", "result", "current", "out", "generated", "generation", "update", "config", "kernel", "page", "four", "console", "control", "socket", "image", "complete", "writer", "web", "service", "object", "resource", "other", "binary", "core", "display", "ou", "outer", "change", "operation", "address", "connection", "external", "option", "write", "again", "Output", "put", "file", "temp", "ilo", "response", "o", "unit", "after", "parent", "oper", "error", "target", "application"], "input": ["flow", "work", "text", "form", "buffer", "current", "out", "client", "inner", "instance", "config", "before", "this", "plus", "Input", "socket", "keep", "image", "data", "in", "resource", "storage", "self", "operator", "print", "ink", "inf", "exec", "child", "index", "ack", "connection", "stream", "raw", "temp", "request", "pull", "feed", "reader", "parent", "inc", "error", "audio", "context", "http"], "buff": ["text", "char", "buffer", "shape", "uf", "length", "cf", "hello", "load", "f", "bb", "pad", "fb", "gz", "buf", "info", "back", "cmd", "txt", "count", "ff", "cast", "data", "ph", "comment", "b", "bound", "fe", "oct", "rb", "cur", "gb", "comb", "uff", "cp", "batch", "cod", "bug", "feed", "slice", "pack", "ob", "boot", "Buff", "bind", "flush", "bin", "cb"], "read": ["text", "x", "seek", "buffer", "se", "Read", "sync", "length", "reading", "check", "parse", "load", "ask", "f", "config", "lex", "len", "use", "pass", "READ", "send", "skip", "k", "count", "ind", "readable", "get", "close", "open", "play", "find", "io", "ip", "n", "and", "ink", "next", " load", "b", " write", "add", "allow", "transfer", "exec", "reads", "index", "size", "write", "en", "iter", "wait", "ok", "loop", "feed", "slice", " count", "end", "id", "type", "reader", "start", "rate", "select", "fill", "run"]}}
{"id1": "3024987", "id2": "16572931", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_encode"], "in": ["source", "init", "buffer", "rec", "re", "inn", "reading", "inner", "with", "pass", "i", "input", "inside", "image", "inas", "or", "read", "IN", "data", "m", "ini", "win", "n", "io", "bin", "a", "url", "arin", "is", "min", "ins", "In", "inc", "Reader", "again", "rin", "file", "include", "r", "err", "login", "entry", "id", "slice", "din"], "reader": ["x", "source", "rx", "buffer", "reading", "inner", "rr", "rar", "ler", "i", "per", "input", "driver", "pointer", "or", "read", "loader", "writer", "oder", "ner", "io", "ink", "b", "rer", "worker", "iner", "handler", "stream", "parser", "Reader", "iter", "ra", "file", "r", "er", "feed", "her"], "baout": ["waoutput", "aaout", "abaOut", "Baout", "BAparent", "bain", "BAout", "wain", "vaparent", "waout", "aaoutput", "daOUT", "vaOut", "baparent", "BAoutput", "aaOut", "baoutput", "BAin", "BAOut", "abain", "vaout", "vain", "abaout", "waOut", "baOUT", "daout", "abaOUT", "baOut", "BaOut", "dain", "daOut", "aain", "Baparent", "Bain", "BAOUT"], "out": ["ref", "buffer", "cache", "output", "arr", "client", "inner", "with", "to", "OUT", "image", "line", "inas", "writer", "object", "builder", "up", "io", "base", "array", "null", "ext", "server", "exec", "obj", "pool", "Out", "write", "outs", "again", "file", "lib", "parent", "err", "o", "user", "inc"], "bytes": ["ls", "text", "parts", "Bytes", "units", "output", "lines", "bits", "android", "ips", "its", "seconds", "les", "ones", "data", "ipes", "strings", "binary", "bps", "cells", "odes", "values", "pieces", "os", "objects", "null", "ies", "files", "zip", "bs", "reads", "body", "string", "pages", "size", "codes", "outs", "ns", "css", "es", "tes", "items", "classes", "comments", "blocks", "rows", "content"]}}
{"id1": "4618237", "id2": "21308543", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFilesAsFile", "writeFileAsChannel", "writeFilesToFile", "writeFileAndFiles", "writeFile2File", "writeFileAsFiles", "writeFile2Stream", "writeFile2Files", "writeFileAsFile", "writeFilesToStream", "writeFileToStream", "writeFile2Channel", "writeFilesToChannel", "writeFileToChannel", "writeFileAndChannel", "writeFilesAsFiles", "writeFileAsStream", "writeFilesAsStream", "writeFileAndStream", "writeFileToFiles", "writeFileAndFile", "writeFilesToFiles", "writeFilesAsChannel"], "fin": ["fine", "init", "ris", "ln", "inn", "fp", "pin", "f", "ori", "conn", "ini", "fm", "fen", "Fin", "arin", "inf", "din", "pins", "fd", "inv", "fn", "fr", "fa", "thin", "rf", "lin", "FIN", "en", "rt", "file", "nir", "rin", "kin", "fi", "include", "fat", "raf"], "fout": ["fOut", "Foff", "rfin", "rfint", "bout", "rfOut", "Fout", "bOut", " fOut", "boff", "Fint", "Fin", "bin", " foff", " fint", "foff", "rfout", "FOut", "fint"], "append": ["text", "adjust", "app", "flat", "pend", "opp", "push", "want", "leaf", "pad", "update", "spread", "send", "padding", "open", "ended", "vert", "except", "add", "null", "ext", "password", "printf", "string", "future", "enc", "only", "batch", "fail", "atten", "save", "protect", "pack", "remove", "end", "apply", "flush", "ending", "optional"], "inChannel": ["innerConnection", "Inchannel", "outchannel", "outQueue", "innerChan", "inChan", "loginStream", "InChan", " inchannel", "loginChannel", "inputChannel", "inputChan", "INChannel", "loginchannel", " inQueue", "INChan", "innStream", "INStream", "inputConnection", "inQueue", "innerchannel", "inConnection", "InChannel", "innchannel", "innerStream", "INConnection", "inchannel", "innerChannel", "inputStream", " inStream", "innChannel", "outChan", "outStream", "INchannel", "INQueue", "inStream", "InStream"], "outChannel": ["outSocket", "OutContext", "outchannel", "OutChan", "inChan", "iochannel", "outputchannel", "ioChan", "outContext", "Outchannel", "externalchannel", "externalChannel", " outChan", " outchannel", "ioChannel", "inContext", "externalChan", "inchannel", "OutStream", "ioStream", "outputChannel", "externalSocket", "outChan", " outContext", "outStream", "outputChan", "OutChannel", "outputSocket", "inStream", "inSocket"]}}
{"id1": "14188043", "id2": "1508161", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["getHTTPRequest", "getHTTPresult", "openUrlresult", "openHttpMessage", "openNetworkRequest", "openSocketResponse", "openUrlMessage", "openHTTPSource", "closeHttpresult", "openUrlResponse", "openhttpRequest", "openRouteSource", "closeHTTPResponse", "closeHttpMessage", "openhttpResult", "closeHTTPresult", "closeHttpResult", "closeHttpResponse", "openHTTPRequest", "openSocketRequest", "getHttpResult", "openHTTPMessage", "getHTTPResult", "openSocketSource", "openRouteResponse", "openRouteResult", "closeHTTPResult", "openhttpresult", "openttpResponse", "getHTTPResponse", "openHttpResponse", "closeHttpRequest", "openNetworkresult", "openHttpRequest", "openHTTPResult", "openHttpresult", "openSocketResult", "closeHTTPSource", "openttpresult", "openNetworkResult", "closeHttpSource", "openttpMessage", "getHttpRequest", "openttpResult", "getHttpresult", "openRouteRequest", "openNetworkResponse", "openHTTPResponse", "openHTTPresult", "openHttpSource", "closeHTTPMessage", "getHttpResponse", "openhttpResponse", "closeHTTPRequest", "openUrlResult"], "urlPath": ["URLPath", "resourcePath", "urlName", "urlText", "URLpath", "runPath", "httpPath", " urlCase", "resourceName", "filePath", " urlText", "uriPath", "UrlText", " urlpath", "runInfo", "resourceFile", "UrlPath", "fileFile", "URLText", "UrlHome", "uriFile", "UrlCase", " urlHome", "httpCase", " urlPoint", "urlHome", "URLPoint", "uriName", "runpath", "httppath", "Urlpath", "fileName", "lInfo", "urlPoint", "uripath", "filepath", "urlFile", "UrlPoint", "urlpath", "lpath", "resourcepath", "lPath", "urlInfo", " urlInfo", "httpHome", "urlCase"], "retry": ["refri", "retone", "rtry", "retrow", "Retried", "pretri", " retone", "rerying", " retried", "Retrying", "retried", "refried", "rtri", "Retri", " retrying", "refrying", "detrying", "detry", "relone", "rtrow", "rery", "rtried", " retri", "pretrow", "pretried", " rettry", "rettry", "pretry", "relrying", " retrow", "Retry", "reltry", "relry", "retri", "detri", "retrying", "detried", "refry", "reone"], "url": ["source", "org", "relation", "util", "uri", "client", "path", "Url", "c", "f", "config", "page", "link", "l", "conn", "image", "loc", "web", "service", "con", "resource", "proxy", "www", "connect", "base", "log", "lc", "server", "URL", "sl", "li", "string", "channel", "file", "ssl", "entry", "user", "http"], "connection": ["text", "relation", "cache", "uri", "client", "connected", "session", "ion", "c", "f", " Connection", "config", "info", "union", "Connection", "use", "event", "link", "driver", "component", "l", "socket", "conn", "image", "application", "loc", "condition", "con", "object", "proxy", "resource", "close", "communication", "io", "connect", "nn", "database", "character", "b", "lc", "server", "function", "number", "body", "index", "nc", "channel", "handler", "wrapper", "creator", "cli", "response", "user", "section", "error", "co", "context", "http"], "code": ["x", "message", "call", "create", "last", "mode", "ode", "se", "dec", "check", "c", "charge", "state", "content", "success", "level", "ie", "one", "e", "count", "line", "complete", "close", "pri", "age", "ce", "done", "force", "cycle", "expected", "stage", "sec", "reason", "change", "zip", "sc", "grade", "Code", "see", "index", "fe", "cc", "nc", "rc", "size", "codes", "cm", "cause", "score", "go", "desc", "cod", "test", "coord", "version", "orig", "bug", "xx", "key", "response", "id", "type", "zone", "error", "ception", "co", "status", "order", "coded"], "redirect": ["Redirect", "transirect", "transef", "codedirection", " redanch", "refirect", " redition", "transition", " redirection", " redrict", "codedition", "Redrict", "redirection", "redrict", "codedirect", "refrict", "redition", "Redirection", "redanch", "Redanch", "redef", "codedef", "refirection", "refanch", "transirection", " redef"], "result": ["work", "match", "source", "message", "ret", "buffer", "cache", "output", "str", "dict", "continue", "load", "instance", "page", "success", "image", "default", "data", "record", "object", "resource", "comment", "up", "array", "grade", "rc", "Result", "string", "value", "answer", "request", "df", "err", "response", "r", "results", "diff", "entry", "error", "report", "status", "content"]}}
{"id1": "21921000", "id2": "665420", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"parse": ["init", " parser", "load", "construct", " setup", " discover", "build", "process", "Parser", "print", " init", "next", " parsed", "execute", "add", " load", " analyze", " feed", " convert", "ize", "parser", " analyse", "end", " parsing", "run"], "url": ["ls", "source", "org", "uri", "client", "path", "Url", "f", "bb", "this", "l", "conn", "data", "web", "service", "resource", "open", "www", "base", "log", "b", "server", "host", "URL", "zip", "sl", "address", "connection", "string", "ur", "file", "ssl", "user", "http"], "con": ["out", "client", "sync", "c", "f", "com", "Connection", " conn", "socket", "conn", "Conn", "func", "ca", "in", "close", "resource", "open", "pub", "n", "connect", "bc", "log", "pc", "b", "conv", "ann", "exec", "cr", "Con", "conf", "connection", "channel", "fa", "coll", "fc", "un", "cn", "file", "r", "CON", "login", "ctx", "plain", "cons", "can", "http"], "bStream": ["bsstream", "aRead", "bsConnection", "rbstream", "rbFile", "bW", "bbConnection", "astream", " bReader", " bW", "bConnection", "bbstream", " bFile", " bstream", "rbReader", "aStream", "bbW", "bFile", "bRead", "bbStream", " bRead", "bsStream", "aFile", "rbStream", "aReader", "bstream", "bbRead", " bConnection", "bsW", "bbReader", "bReader"], "str": ["p", "text", "kr", "char", "result", "arr", "st", "dec", "br", "c", "Str", "f", "s", "pass", "i", "input", "l", "line", "STR", "stri", "data", "in", "strip", "sr", "n", "name", "spec", "obj", "cr", "sl", "res", "sp", "cur", "string", "div", "fr", "enc", "coll", "pr", "tr", "part", "step", "r", "er", "err", "key", "id", "doc", "status"], "tokens": ["pokenents", "tarsen", "tokenens", "topents", "tokes", "takos", "Taken", "token", "tokenets", "tractents", "Tokens", "Tokents", "takets", "tractens", "takens", "Tokes", "Tokets", "tokos", "Takents", "tokets", "toks", "taks", "Takicks", "Takens", "Tokicks", "poks", "tokicks", "topets", "Takos", "Token", "topens", "pokets", "tarses", "takents", "tarsens", "Takes", "Tokos", "tokenes", "takicks", "tractos", "tarsicks", "pokenets", "tokenen", "tokenicks", "takes", "tokenents", "tractets", "toksets", "taken", "pokents", "toksens", "pokenens", "tops", "Takets", "toksents", "tokents", "pokens", "toksos"], "charCode": [" charcode", "charNumber", "characterNumber", "CharName", "characterType", "characterCode", "CharNumber", "charcode", " charNumber", "charName", "charCount", "characterName", "CharCount", "charactercode", "characterCount", "Charcode", "CharCode", " charType", " charCount", " charName", "CharType", "charType"], "value": ["flow", "result", "current", "Value", "amount", "VALUE", "count", "val", "default", "data", "object", "money", "format", "dollar", "values", "flo", "base", "name", "num", "number", "function", "grade", "fe", "string", "size", "element", "range", "scale", "weight", "version", "key", "entry", "rate", "v", "type", "price", "volume"], "unit": ["flow", "uni", "position", "units", "output", "out", "union", "instance", "point", "component", "item", "data", "factor", "format", "class", "currency", "base", "num", "u", "it", "number", "split", "letter", "term", "string", "category", "size", "option", "element", "scale", "un", "version", "Unit", "rate", "type", "target"]}}
{"id1": "13946197", "id2": "1235538", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"transformByMD5": [" transformWithMSecret", " transformByMC5", " transformBymd5", " transformWithM3", " transformByM3", " transformByMC3", " transformWithM4", " transformBymd4", " transformBymdSecret", " transformByMD3", " transformByMDSecret", " transformByMD4", " transformByMCSecret", " transformBymd3", " transformWithMD5", " transformByM5", " transformByMC4", " transformWithMD4", " transformWithMDSecret", " transformByM4", " transformByMSecret", " transformWithM5", " transformWithMD3"], "password": ["p", "text", "secret", " passwords", "message", "account", "source", "filename", "token", "path", "username", "config", "hash", "wd", "phrase", "word", "pattern", "padding", "data", "object", "auth", "PASS", "resource", "email", "database", "name", "device", "sword", "params", "address", "wallet", "string", "connection", "channel", "prefix", "crypt", "Password", "attribute", "login", "user", " Password"], "md5": ["mand3", " MD45", "materialfive", "mdfive", "MDql", "md4", "md2", "mand5", " md3", "MDdown", " MD3", "mdse", "mddown", " md45", "md512", "mandse", " MDdown", " mdql", " MDok", "md3", "mdok", "amd512", "amd3", "md55", "mand45", " md2", "MD2", " MD55", "MDse", "amd2", "MDok", "MD5", "mand2", "amd5", " mddown", " mdok", "mdql", "MD512", "materialql", "material5", "md45", " MD5", " md4", " MD4", " md512", "mand4", "mand55", "MDfive", " md55", " mdfive", " mdse", "MD3", "material2"], "output": ["dot", "secret", "text", "message", "sequence", "style", "buffer", "property", "result", "generated", "out", "generation", "config", "written", "page", "word", "console", "input", "image", "complete", "data", "resource", "format", "foo", "document", "character", "display", "width", "reason", "outer", "array", "letter", "address", "beta", "string", "prefix", "queue", "exit", "write", "full", "reference", "Output", "response", "o", "unit", "hidden", "target", "offset"], "bufferPass": ["BufferPass", " bufferPush", " bufferCopy", "ufferFeed", "bufPush", "bufferpass", "bufPass", " bufferPack", "ufferLine", "ufferCopy", " bufferLine", "bufferFeed", "BufferComp", "bufferPush", " bufferComp", "bufFeed", "ufferPush", "BufferLink", "bufLink", "Bufferpass", "bufferScan", "ufferPass", " bufferpass", "bufferPack", " bufferFeed", "bufCopy", "bufferLine", " bufferScan", "BufferFeed", "bufferComp", "bufLine", "bufferLink", "bufComp", " bufferLink", "bufpass", "ufferPack", "bufferCopy", "bufScan", "bufPack", "ufferScan"], "b": ["p", "x", "ab", "buffer", "sb", "br", "c", "f", "bb", "ba", "fb", "s", "bytes", "w", "e", "i", "l", "bl", "k", "line", "B", "binary", "lb", "bf", "n", "be", "bi", "a", "url", "base", "u", " a", "null", "obj", "bs", "body", "rb", "eb", "h", "db", "abb", "orb", "y", "wb", "r", "t", "ob", "v", " eb", "cb", "d"]}}
{"id1": "9805906", "id2": "16719805", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"dump": ["ump", " dumping", "ln", "copy", "out", "Dir", "load", "update", "download", "f", "info", "store", "all", "println", "data", " dumped", "export", " dumps", "transfer", "files", "zip", "save", "df", "dir", "diff", "flush", "db"], "source": ["remote", "uri", "se", "current", "s", "this", "use", "view", "slave", "ources", "input", "ource", "src", "SOURCE", "sin", "Source", "service", "from", "resource", "core", "base", "series", "server", "address", "scene", "string", "connection", "stream", "iter", "file", "slice", "site", "unit", "parent", "start", "http"], "target": ["top", "result", "goal", "output", "port", "out", "table", "path", "effect", "large", "alias", "master", "root", "pointer", "to", "arget", "project", "src", "follow", "object", "Target", "resource", "force", "dest", "platform", "next", "base", "database", "null", "it", "host", "address", "connection", "settings", "replace", "office", "file", "enemy", "template", "parent"], "is": ["ls", "mis", "as", "ris", "cs", "ps", "im", "IS", "isa", "was", "us", "oss", "bos", "ai", "ists", "s", "info", "its", "ori", "ens", "iss", "i", "Is", "or", "iso", "gets", "in", "lis", "ws", "ip", "opens", "io", "ses", "ui", "bs", "isl", "isi", "ins", "ais", "ios", "ics", "es", "abs", "iris", "nis", "obs", "bis", "has", "oses", "ois", "ops"], "os": ["OS", "as", "cs", "dos", "ps", "ss", "ols", "oss", "bos", "us", "ips", "s", "oes", "its", "ori", "ens", "i", "ues", "acs", "pos", "ds", "or", "ose", "vs", "oa", "nos", "io", "ros", "ks", "cos", "los", "ies", "fs", "bs", "oos", "ais", "ios", "aos", "outs", "ows", "es", "obs", "Os", "o", "osi", "boot", "oses", "ops"], "done": ["gone", " Done", "dad", "enabled", "last", "current", "ready", "dirty", "loaded", "empty", "doing", "running", "one", "de", "due", "complete", "none", "defined", "disabled", "got", "once", "data", "nice", "checked", "started", "later", "progress", "foo", "expected", "next", " finished", "die", "finished", "future", "confirmed", "yes", "Done", "did", "always", "made", "part", "after", "odo"]}}
{"id1": "804637", "id2": "19113613", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "19549489", "id2": "6379126", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["p", "source", "create", " copies", " copied", "sync", " move", "paste", "Transfer", "download", "all", "Cop", "move", "cop", "io", " copying", "clone", "transfer", " transfer", "split", "zip", "upload", "Copy", "write", " Copy", "file", "delete"], "sourceFile": ["searchFile", " sourcefile", " sourceFILE", "sourceFILE", "searchFilename", " sourceFiles", "serviceFilename", "siteFILE", "SourceFILE", "siteFile", "sourceDirectory", "searchFiles", "resourceFile", "sourceFilename", "resourceDirectory", " sourceDirectory", " sourceFilename", "SourceFile", "sourcefile", "resourcefile", "servicefile", "sourceFiles", "resourceFiles", "siteDirectory", "searchfile", "serviceFiles", "SourceDirectory", "serviceFile", "siteFiles", "Sourcefile", "SourceFiles"], "destinationFile": ["destinatedFile", "destationImage", "destationDir", "distinatedDirectory", "DestinatorDir", "destinatorDir", "distinationDirectory", "distinationFiles", "destinatedImage", "distinatedImage", "destationFile", "destationfile", "destinationFiles", "distinationFile", "DestinatorFiles", "Destinationfile", "destationFiles", "distinatedFile", "distinatedFiles", "destinatedfile", "destinatorfile", "destinationDir", "Destinatorfile", "destinatedDirectory", "DestinatorFile", "destinatorImage", "DestinationDir", "destinationImage", "destinationDirectory", "destinatorFiles", "destinatorDirectory", "distinationImage", "DestinationFiles", "DestinationFile", "destationDirectory", "destinatedFiles", "destinatorFile", "destinatedDir", "destinationfile"], "sourceFileChannel": ["sourceDirectoryChannel", " sourceFilesService", "sourceFunctionChannel", " sourceFilesContext", "sourceLibrarySocket", "ourceFileStream", "sourceStreamStream", "targetLibrarySocket", "sourceStreamService", "targetLibraryClient", "ourceStreamchannel", "targetLibraryChannel", "targetFileSocket", "sourceFilesChannel", "sourceLibraryChannel", " sourceFileService", "ourceFileChannel", "sourceStreamChan", "sourceFileConnection", "sourceFileContext", "targetFileChannel", "ourceStreamChannel", "sourceLineChannel", "sourceLineClient", "sourceFunctionContext", "ourceStreamStream", "ourceFileChan", "sourceDirectoryClient", "sourceDirStream", "sourceLineStream", " sourceFilesConnection", "sourceLinechannel", "sourceDirChan", "sourceDirectoryChan", "sourceStreamChannel", "sourceFileChan", "sourceFunctionConnection", "sourceStreamConnection", " sourceFileConnection", "sourceFileStream", "targetFileChan", "sourceLibraryChan", "sourceFilesContext", "sourceLineChan", "ourceStreamChan", "sourceFunctionService", "sourceFileService", " sourceFileContext", "ourceFilechannel", "sourceStreamContext", "sourceStreamchannel", "sourceDirchannel", "sourceDirChannel", " sourceFilesChannel", "targetFileClient", "sourceLineSocket", "targetLibraryChan", "sourceFilesConnection", "sourceFileSocket", "sourceDirectorySocket", "sourceFileClient", "sourceLibraryClient", "sourceFilesService", "sourceFilechannel"], "destinationFileChannel": ["destinationDirectoryHandler", "destinatorFileHandler", "destinationFilesCache", "destinatorFileChan", "destinationFilesClient", "destinatorFilesClient", "destinationFilesChannel", "destinationIOChannel", "destinatorFileClient", "destinationFileChan", "destinationDirectoryChannel", "destinatorFileChannel", "destinationLineHandler", "destinationLineClient", "destinationDirectoryConnection", "destinationFilesHandler", "destinatorFilesHandler", "destinationIOCache", "destinationFilesService", "destinationFileClient", "destinatorFileConnection", "destinationDirectoryChan", "destinatorFileService", "destinationLineConnection", "destinationLineChannel", "destinationDirectoryClient", "destinatorFilesCache", "destinationIOClient", "destinationFileConnection", "destinationDirectoryService", "destinationFileService", "destinatorFilesService", "destinationIOService", "destinationLineChan", "destinatorFilesConnection", "destinatorFilesChan", "destinatorFileCache", "destinationFileCache", "destinationFileHandler", "destinationDirectoryCache", "destinationFilesChan", "destinationLineService", "destinationFilesConnection", "destinatorFilesChannel"]}}
{"id1": "18731843", "id2": "20619879", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"doBody": [" doBytes", "handleFile", "handleBody", "DoResponse", "doBytes", "DoFile", "handleResponse", "doResponse", "DoBody", " doFile", "doFile", "handleBytes", "DoBytes", " doResponse"], "req": ["ref", "rx", "rec", "download", "config", "info", "this", "reg", "rr", "src", "conn", "serv", "qt", "qq", "q", "data", "resource", "proc", "requ", "spec", "obj", "query", "res", "rss", "respond", "fr", "jp", "comp", "def", "request", "r", "err", "crit", "cgi", "reader", "rh", "sem", "Request", "report", "http"], "resp": ["p", "pre", "ref", "ret", "result", "rec", "re", "cache", "download", "bb", "rr", "serv", "pos", "exc", "val", "data", "prot", "Resp", "job", "b", "proc", "Response", "obj", "rep", "res", "api", "sp", "inv", "respond", "jp", "respons", "comp", "html", "request", "part", "err", "response", "r", "rev", "cb", "cmp", "report", "reply"], "bis": ["phis", "uds", "mis", "tis", "ris", "bh", "sb", "bits", "obb", "bb", "fb", "bas", "sis", "ori", "iss", "ubis", "sin", "abi", "bian", "lis", "bid", "bps", "binary", "alis", "bi", "isin", "ses", "pins", "b", "os", "obi", "los", "usb", "is", "oris", "bs", "rots", "obos", "ais", "ios", "atis", "lins", "iris", "nis", "obs", "boot", "bin", "ois", "bes"], "bos": ["phis", "tis", "uds", "bh", "bits", "opus", "bones", "obb", "bris", "bas", "mos", "bo", "oops", "ubis", "antis", "bott", "abi", "obo", "bps", "bi", "ros", "bin", "obi", "os", "oks", "los", "oS", "zos", "oros", "bs", "zo", "fits", "obos", "las", "oos", "ios", "aos", "lol", "lins", "osa", "obs", "osi", "boot", "oses", "ois", "bes", "ops"]}}
{"id1": "5620792", "id2": "7948308", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"SHA1": ["HA64", "SHAOne", "sha256", "shaOne", "SHA256", "HA256", "sha64", "HA1", "HAOne", "SHA64", "sha1"], "text": ["secret", "source", "message", "buffer", "token", "str", "out", "length", "path", "config", "font", "bytes", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "format", "context", "binary", "class", "url", "name", "ext", "Text", "code", "password", "transfer", "address", "hex", "letter", "string", "connection", "struct", "prefix", "value", "key", "template", "id", "contract", "pattern", "content"], "HASH_VALUE_SIZE": ["HASH_VALUE_Size", "HASH_VALUEFsize", "HASH_VALUE2size", "HASH_VALUEFVALUE", "HASH_VALUE2VALUE", "HASH_SIZE_LOAD", "HASH_Value_SIZE", "HASH_SIZE_SIZE", "HASH_VALUE_LOAD", "HASH_SIZE_size", "HASH_VALUE_VALUE", "HASH_VALUE2LOAD", "HASH_VALUE_size", "HASH_SIZE_VALUE", "HASH_VALUEFSIZE", "HASH_Value_Size", "HASH_VALUEFLOAD", "HASH_VALUE2SIZE", "HASH_Value_VALUE", "HASH_Value_size"], "md": ["me", "message", "method", "mand", "hm", "mp", "mm", "mod", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "mb", "meta", "mg", "ind", "data", "m", "nm", "metadata", "mad", "mac", "bf", "editor", "valid", "em", "rm", "ms", "sm", "um", "gen", "code", "sha", "pd", "body", " MD", "ld", "od", "dd", "ng", "mo", "mt", "sum", "am", "MD", "mc", "ma", "mu", "pkg", "mag", "pm", "d", "bd"], "sha1hash": ["ha1str", "SHA1hex", "sha1dot", "sha0h", "ha2hash", "sha9dig", "sha64Hash", "sha0hex", "sha1hex", "ha2dig", "sha2str", "ha1hash", "sha64str", "SHA2h", "ha1Hash", "ha2Hash", "sha9hash", "ha1dig", "sha256dot", "sha2Hash", "sha64dig", "sha2h", "SHA2hex", "sha256hex", "SHA2dot", "sha1Hash", "sha2hash", "sha0dot", "SHA1h", "ha2sum", "SHA2hash", "sha2hex", "sha9str", "sha2sum", "sha64sum", "SHA1hash", "sha1dig", "sha2dig", "sha1h", "sha1sum", "sha64hash", "ha2str", "ha1sum", "sha2dot", "SHA1dot", "sha1str", "sha9Hash", "sha256h", "sha256hash", "sha0hash"]}}
{"id1": "14053882", "id2": "17947247", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "label": 0, "substitutes": {"encrypt": ["enccode", " encryptcode", "decrypt", " encryptrypt", "decryption", " enipher", " encryptryption", "deccode", "decipher", "encipher", " enrypt", " enryption", "encryption", " encode", " encryptipher"], "plaintext": ["plainsource", " plaincontent", "encryptedstruct", "givenfont", " plainText", "protectedText", "plainstring", "batsource", "plainfont", "givenstring", "encryptedtext", " plainstring", "plainstruct", "batfont", "protectedstruct", "givensource", " plainfont", "protectedtext", "plaincontent", "plainText", " plainsource", "battext", "batstring", "encryptedText", "protectedcontent", "giventext", " plainstruct", "encryptedcontent"], "md": ["mand", "hm", "alg", "mm", "mp", "mod", "amd", "Cmd", "wd", "dig", "cmd", "dm", "po", "mb", "meta", "material", "mg", "data", "m", "ph", "da", "pg", "mage", "metadata", "ad", "mad", "mac", "nm", "sm", "ms", "code", "kg", "pd", "sha", "dr", " MD", "od", "dd", "cm", "mo", "mt", "hd", "cd", "am", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "cb", "d", "bd", "dc"], "raw": ["text", "buffer", "json", "dec", "clean", "empty", "load", "instance", "rew", " RAW", "buf", "unsigned", "input", "image", "shared", "Raw", "data", "unknown", "auth", "binary", "original", "array", "null", "initial", "sha", "hex", "ack", "rc", "string", "stream", "enc", "wrapper", "full", "block", "serial", "pure", "row", "wave", "pack", "response", "feed", "partial", "RAW"], "hash": ["secret", "message", "buffer", "cache", "ashes", "length", "ash", "image", "kh", "data", "auth", "mac", "url", "base", "log", "array", "Hash", "password", "sha", "hex", "index", "h", "header", "sum", "sh", "block", "ha", "html", "version", "key", "response", "href", "her", "id", "rh"]}}
{"id1": "364438", "id2": "20128728", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconverted", "subversion", "unverted", "unversion", "converted", "CONverted", " deconverted", "subverted", "Convert", "CONception", "unception", "subvert", " deconversion", "Conversion", "CONvert", "oconverting", "Converting", "Converted", "Conception", "CONverting", "conception", "conversion", "oconvert", "subverting", "converting", " deconverting", "unvert", "oconversion", " deconvert", "CONversion"], "src": ["attr", "source", "ref", "filename", "video", "sb", "fp", "uri", "secure", "st", "path", "username", "feat", "load", "download", "config", "s", "back", "buf", "component", "gz", "input", "ource", "inst", "sin", "loc", "RC", "req", "Source", "sys", "prot", "resource", "img", "storage", "sth", "url", "tmp", "name", "stage", "proc", "spec", "code", "obj", "sel", "sc", "rl", "sit", "supp", "scene", "SourceFile", "rc", "upload", "string", "fn", "rb", "gb", "dist", "stream", "cpp", "impl", "sn", "file", "Dest", "ssl", "slice", "href", "reader", "ctx", "cb", "cmp"], "dest": ["disk", "source", "path", " destination", "home", "txt", "img", "class", "tmp", "null", "cont", "obj", "dist", "dat", "fn", "di", "orig", "test", "std", "temp", "lib", "Dest", "dir", "bin", " dst", "target", "dc"], "in": ["source", "as", "ps", "inn", "pin", "f", "pass", "ex", "i", "input", "inas", "val", "IN", "data", "ini", "win", "n", "up", "isin", "a", "io", "inf", "din", "is", "ins", "stream", "In", "inc", "file", "r", "t", "err", "login", "reader", "bin", "d", "doc"], "p": ["lp", "pre", "tp", "ps", "fp", "py", "c", "f", "np", "s", "wp", "per", "i", "e", "pb", "po", "l", "bp", "m", "pg", "cop", "pa", "g", "v", "pc", "b", "pe", "pd", "pi", "sp", "j", "h", "cp", "pr", "jp", "parser", "part", "t", "pp", "op", "r", "o", "pm", "d", "P"], "ds": ["ts", "ups", "s", "DS", "hs", "ans", "ipes", "ded", "dds", "ins", "xs", "ns", "d", "ays", "dos", "ps", "words", "sync", "styles", "ys", "groups", "data", "da", "des", "rs", "ths", " ps", "os", "utils", "pd", "icks", "dist", "els", "models", "points", "sts", "scripts", "plugins", "js", "db", "cons", "posts", "ls", "parts", "tools", "cs", "ss", "lines", "dm", "vals", "sys", "ges", "ks", "qs", "docs", "ants", "bs", "nas", "amps", "Ds", "di", "dd", " props", "gs", "ads", "ils", " sd", "lp", "uds", "tests", "eps", "services", "dates", "dl", "vs", "dt", "dat", "gd", "ld", " DS", "dp", "df", "obs", "dc"], "format": ["source", "nat", "form", "style", "filename", "fp", "table", "path", "language", "feat", "frame", "config", "f", "at", "model", "data", "magic", "record", "act", "class", "url", "name", "spec", "Format", "host", "fd", "function", "letter", "api", "tag", "string", "struct", "sche", "fn", "prefix", "handler", "plugin", "scale", "filter", "parser", "file", "version", "part", "t", "template", "atter", "layout", "unit", "type", "ant", "pattern"], "hasPixelData": ["hasPixelSize", "haspixeldata", "hasByteData", "haspixelData", "hasByteStyle", "showsByteDATA", "hasPictureSize", "hasPixelStyle", "hasPixelDATA", "haspixelSize", "showsPixelDATA", "hasPictureData", "showsPixelData", "hasBytedata", "showsPixeldata", " hasPixelSize", "showsPixelStyle", "hasPixeldata", "hasByteSize", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPicturedata", " hasPixeldata", "showsByteData"], "inflate": ["infloated", "infolode", "insvenode", "insflode", "infface", "inFlation", "insvenATE", "insvenating", "invenating", "inadequode", "inadequATE", "insflATE", "Inflation", "infloation", "invenATE", "insflate", "infolate", "inflode", "inflATE", "invenate", "invenode", "inflace", "Inflate", "inFlace", "inadequating", "inadequate", "inFlate", "InFlate", "infolATE", "infolating", "InFlace", "inffated", "insflating", "inFlated", "infloace", "infloate", "inflated", "inflation", "InFlated", "inffate", "inflating", "inffation", "insvenate", "InFlation", "Inflated", "Inflace"], "pxlen": ["pcln", "xplength", "pglen", "txln", "pnglen", "fxpos", "fxlen", "mxpos", "xpcount", "pxlength", "mxdata", "pxln", "pxpos", "ppl", "campos", "mxlen", "txlen", "fxdata", "pxcount", "mxlength", "axlon", "pclin", "pgLen", "txlin", "xplen", "axlen", "axlin", "pxlin", "mxsize", "pxdata", "pxlon", "pclen", "axln", "pgden", "mxln", "pxsize", "pngsize", "camdata", "txlon", "pnglength", "pngcount", "camlen", "ppLen", "fxLen", "xpsize", "mxcount", "fxln", "camln", "fxl", "pxLen", "pplen", "pgl", "pclon", "pxl", "ppden", "pxden", "fxden"], "out": ["work", "group", "copy", "cache", "output", "re", "session", "point", "pad", "store", "page", "state", "dump", "OUT", "conn", "line", "sys", "io", "up", "v", "log", "server", "gen", "obj", "post", "query", "list", "lock", "Out", "outs", "again", "lib", "step", "cli", "err", "inter", "user", "parent", "error", "co"]}}
{"id1": "14819747", "id2": "3958807", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 0, "substitutes": {"debug": ["Debug", "enabled", " debugging", "remote", "cache", "depth", "DEBUG", "develop", "production", " debugger", "config", "date", "store", "reg", "show", "enable", "root", "real", "console", "dump", " Debug", "github", "build", "module", "help", "play", "trace", "ger", "comment", "print", "progress", " DEBUG", "error", "export", "log", "display", "die", "admin", "tag", "quiet", "dev", "details", "plugin", "test", "file", "development", "bug", "err", "db", "doc", "status", "active"], "prologFile": ["prologPath", "PrologString", "proLogFiles", "prolangFull", "probaseFile", "prologFiles", "proconfigPath", "procatSource", "prolexFile", "prologFull", "proversionFile", "deflogSourceFile", "deflogFILE", "prolexfile", "proLogFull", "defblogFile", "proconfigModule", "prolexString", " prologFiles", "proLogSource", "problogDir", "proversionFILE", "proLogSourceFile", "proconfigString", "ProLogFile", "Prologfile", "proconfigfile", "prologSource", "proLogHeader", "roLogfile", "deflogDir", "proversionSourceFile", "prologfile", "problogHeader", "proflowfile", "procatfile", " problogSourceFile", "problogfile", "rologSource", "probaseHeader", "ProLogfile", " proLogFiles", "prollSource", "deflogFile", "defblogfile", "prologHeader", "proLogfile", "defLogFile", " proLogFile", "prologSourceFile", "defLogFILE", "rologfile", " prologFull", "prologFILE", "proflowDir", "roLogFile", "problogStream", "prologDir", "propathfile", "deflogPath", "propathFile", "prologModule", "probaseStream", "proLogFILE", "proLogString", "rologFile", "PrologFile", " problogfile", " proLogHeader", "problogFull", "defLogPath", "prolexModule", "roLogPath", "prollPath", " problogFull", "defLogSourceFile", "prollfile", "propathDir", "proflowFile", "procatFile", "ProLogString", "problogFiles", "prologString", "ProLogModule", "probaseFiles", " problogFile", "defblogSourceFile", "defblogDir", "prolangFile", "proLogFile", " prologHeader", "roLogSource", "deflogfile", "proLogPath", "proconfigFILE", "proLogModule", "propathSourceFile", " prologfile", "problogSourceFile", "rologPath", " prologSourceFile", "procatPath", " prologStream", "proconfigFile", "PrologModule", "proversionPath", "problogFile", "prologStream", "proconfigSourceFile", "prolangSourceFile", "prollFile", " proLogStream", "proLogStream", "proflowSourceFile", "prolangfile"], "targetFile": ["sourceDir", "outputPath", "outputDir", "targetfile", "sourceDirectory", " targetfile", "targetDirectory", "targetDir", "TargetFiles", "targetFiles", " targetDirectory", "sourcePath", "TargetFile", "TargetDir", "outputfile", "sourcefile", "sourceFiles", "targetPath", "Targetfile", "outputFile", "TargetDirectory", "sourceFile", "TargetPath", " targetFiles"], "source": ["text", "message", "style", "result", "position", "buffer", "uri", "str", "json", "parse", "language", "session", "config", "use", "view", "model", "i", "options", "input", "src", "ource", "SOURCE", "data", "Source", "service", "resource", "format", "proxy", "comment", "description", "class", "name", "zip", "sl", "term", "body", "string", "scope", "stack", "file", "template", "slice", "id", "unit", "type", "target", "content"], "myParser": [" myReader", " myJar", "yourJar", "MyParser", "MyJar", "yourReader", "myJar", "yourParser", "yourProgram", "MyReader", "MyProgram", "myReader"], "myProgram": ["Myprogram", "MYprogram", "myprogram", "yourParser", "MyProgram", " myPlan", "theParser", "yourMath", "MYParser", "theMath", "yourPlan", "MyPlan", "myPlan", "yourProgram", " myMath", "yourprogram", " myprogram", "theprogram", "MyParser", "myMath", "theProgram", "MYProgram"], "myVisitor": ["myDesignitable", "Myvisiter", "myExiter", "MyVisitors", "myVisIT", " myVisitors", "myAuditable", "mySignitor", "mySigniter", "myvisiter", " myvisitor", " myvisitors", " myVisitable", "myVISitable", "myvisulator", "myVISit", "myDesignIT", " myvisit", "Myvisulator", "mySignulator", "myDesignit", "myvisitable", "myVisititable", "myExulator", "myvisIT", " myVisIT", "myVISIT", "myVisiter", "myAudit", "myDesignitor", "Myvisitors", "myVisititor", " myVisit", "myExitor", "myVisit", " myvisIT", "myAuditors", "MyVisitor", "myVisitable", "MyVisiter", "myVISitor", "myAuditor", "myVisitors", "MyVisulator", "myVisulator", "myExitors", "myvisitor", " myvisitable", "myvisitors", "myvisit", "myVisititors", "Myvisitor", "mySignitors", "myVisitit"], "adapterLayer": ["adviceContainer", "adaptersFactory", "adptionLayer", "acaptersInfo", "adviceBuffer", "adaptersBuffer", "acapterLayer", "adaptersLayer", "acapterBuffer", "acaptersLanguage", "adviceLanguage", "adviceLayer", "admissionContainer", "admissionLayer", "acapterInfo", "acaptersBuffer", "acaptersLayer", "acapterLanguage", "acapterContainer", "adptionBuffer", "adviceFactory", "acaptersFactory", "admissionLanguage", "acaptersContainer", "adaptersContainer", "acapterFactory", "adaptersLanguage", "adptionFactory", "adptionInfo", "adapterLanguage", "adapterBuffer", "adviceInfo", "adapterContainer", "adaptersInfo", "adapterInfo", "adapterFactory"], "classLoader": ["ClassLoader", "classPath", "ClassPath", "classloader", "classDir", " classDir", "staticDir", " classPath", "ClassDir", "staticPath", "staticloader", "staticLoader", "Classloader", " classloader"], "adapterWriter": ["attapterswriter", "admissionWriter", "adaptersWrite", "adAdapterWriter", "attaptersWrite", "attaptersReader", "adapterswriter", "adAdapterWrite", "adapterwriter", "attapterWrite", "attapterWriter", "admissionwriter", "adAdapterReader", "adaptersWriter", "attaptersWriter", "adAdapterwriter", "attapterwriter", "adaptersReader", "adapterWrite", "admissionReader", "adapterReader", "admissionWrite", "attapterReader"], "annotationGenerator": ["annnotationGencer", "annnotationGenerator", "annnotationGenators", "annnotationGenerators", "annotationGcer", "annotationGators", "annotationGoder", "annotationgencer", "annnotationGeneroder", "annotationgenoder", "annnotationGenoder", "annotationGenators", "annnotationGenercer", "annotationGator", "annotationGencer", "annotationgenator", "annotationGenoder", "annotationGeneroder", "annotationgenators", "annnotationGenator", "annotationGenator", "annotationGenercer", "annotationGenerators"], "out": ["flow", "pre", "group", "copy", "cache", "output", "bar", "sync", "net", "point", "store", "page", "state", "cmd", "dump", "OUT", "conn", "line", "down", "sys", "in", "up", "print", "io", "n", "v", "log", "array", "outer", "server", "code", "obj", "post", "gen", "query", "list", "lock", "prefix", "chain", "Out", "raw", "outs", "again", "temp", "cli", "err", "diff", "user", "parent", "error"]}}
{"id1": "21152728", "id2": "10436471", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"authenticate": ["authication", "Authentication", " authenticated", "authicate", "authenticating", "Authenticated", "authentication", "authenticated", "authicated", "Authenticate", "authicating", " authentication", " authenticating", "Authenticating"], "module": ["course", "message", "method", "role", "mode", "table", "str", "script", "pin", "mod", "py", "instance", " Module", "config", "model", "domain", "component", "input", "manager", "conn", "project", "data", "m", "object", "resource", "service", "io", "class", "base", "name", "device", "vm", "server", "modules", "msg", "query", "address", "connection", "rule", "require", "scope", "lock", "prefix", "header", "chain", "mi", "element", "plugin", "cm", "mission", "file", "pm", "entry", "site", "unit", "Module", "ctx", "member", " modules"], "rand": ["init", "ro", "re", "token", "out", "push", "pad", "reg", "seed", "rar", "Rand", "max", "gram", "conn", "raid", "bird", "han", "in", "auth", "bot", "round", "rot", "grad", "NG", "random", "gen", "nd", " random", "chance", "gd", "rc", "min", "alpha", "crypt", "dd", "ng", "range", "sum", "rage", "winner", "r", "right", "pattern"], "challenge": ["Challenge", "challise", "passise", "buckenge", " challge", "passenges", "scheise", " challchall", "challge", "passenge", "scheaine", "chalenge", "challonge", "chalge", "challaine", "challenges", "chge", " challonge", "Challge", "chalenges", "buckge", "chise", "challchall", "buckchall", "chenge", "Challise", "chaine", "Challaine", "schege", "Challonge", "chalise", "Challchall", "scheenge", "scheenges", "passge", "buckonge"], "b64": ["base62", "B16", "base58", "B64", "base16", " bbl", "bb64", "xbbl", "bbl", " b48", " b4", "b58", "b4", "mb64", "b48", "basebl", "xb62", "bb58", "xb64", " b16", "b36", "bb16", "base48", "base36", "mb58", "b16", "base64", "mb4", "mb16", "bb36", " b62", "B58", "xb48", " b36", "b62", "B4", " b58"], "reply": ["text", "secret", "message", "remote", "result", "buffer", "reset", "uri", "out", "sync", "parse", "py", "frame", "info", "back", "http", "rr", "link", "notice", " replies", "resp", "data", "service", "comment", "voice", "next", "related", "base", "reason", "server", "Response", "query", "address", "body", "string", "respond", "connection", "prefix", "queue", "repl", "range", "Reply", "write", "received", "replace", "answer", "request", "route", "ridge", "part", "template", "entry", "id", "error", "report"], "user": ["account", "text", "match", "secret", "me", "uid", "source", "result", "role", "token", "client", "out", "username", "cover", "field", "session", "pin", "author", "ver", "date", "use", "person", "pass", "per", "word", "manager", "project", "USER", "by", "data", "service", "object", "resource", "proxy", "consumer", "open", "comment", "force", "valid", "url", "character", "name", "device", "allow", "server", "using", "host", "password", "query", "address", "string", "rule", "lock", "profile", "plugin", "write", "full", "used", "replace", "creator", "users", "parent", "request", "bug", "key", "route", "entry", "id", "login", "type", "error", "User"], "response": ["account", "secret", "message", "result", "uri", "json", "output", "token", "session", "model", "resp", "data", "service", "object", "resource", "format", "description", "url", "server", "Response", "host", "password", "address", "api", "body", "string", "header", "respond", "connection", "profile", "respons", "version", "answer", "request", "error", "status"], "secrets": ["Secures", "secret", "securs", "securityures", "secures", "regurs", "securityurs", "Secrets", "regards", " secret", "secards", "secredits", "SECrets", "securityrets", "SECures", " secredits", "Securs", "SECret", "Secret", "SECards", "subret", "SECurs", "Secredits", "subredits", "regret", "regrets", "Secards", "subrets", "securityret"], "md4": [" md44", "sha2", "md2", "sha4", "MD6", " md256", " md6", "madfour", "sha04", "md5", "mc6", "MD4", " md04", "mad4", "mc4", "md256", "MD256", "mdfour", "sha5", "MD2", " md2", "MD04", " md5", "mad04", "mad2", "mc5", "shafour", "sha6", " mdfour", " MD6", "md44", "md6", " MDfour", "mad256", " MD4", "MDfour", " MD2", "sha44", "MD44", "md04", "mcfour"], "line": ["text", "message", "lf", "style", "look", "Line", "lines", "str", "sync", "parse", "out", "cell", "lo", "frame", "model", "page", "pass", "link", "l", "inline", "data", "definition", "record", "object", "strip", "comment", "shell", "url", "log", "name", "lc", "pe", "server", "code", "letter", "body", "string", "header", "rule", "lock", "profile", "LINE", "cl", "lin", "range", "block", "value", "file", "part", "row", "entry", "end", "le", "error", "status"], "passwd": ["assw", " passpassword", "ppass", " passpass", "asspass", "pw", "asswd", "assWD", "Passpassword", "passwordpassword", "Passpass", "PassWD", "passwordword", "passwordpass", "Passw", "password", "passw", " password", "passpass", "pwd", "Passwd", "passpassword", "Password", "passWD", "passwordwd", "pWD"], "hash": ["match", "secret", "style", "hed", "cache", "check", "flash", "cover", "ash", "image", "build", "kh", "object", "shadow", "url", "base", "array", "Hash", "server", "sha", "hex", "body", "h", "tag", "header", "sum", "sh", "block", "html", "ha", "value", "version", "key", "sign", "her", "id", "rh"]}}
{"id1": "5142039", "id2": "22442270", "code1": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 0, "substitutes": {"uncompress": [" uncompressed", " unompress", "uncopzip", "unCompressed", "uncopress", "unompression", "uncompzip", " uncompression", "unCompression", "uncopression", "unompress", " unompression", " unompressed", "unCompzip", "uncompression", "unompzip", " unompzip", "uncopressed", "uncompressed", "unCompress", " uncompzip", "unompressed"], "readPath": ["readDir", "writeFile", "workPath", " readFile", "loadpath", "loadCase", "scanCase", "readerTree", "workTree", "scanDir", " readpath", "readWith", "baseWith", "checkFile", "writePo", "scanpath", "checkDir", "baseTree", "readerpath", "readCase", "loadDir", " readWith", "checkPo", "writeCase", "writeDir", "scanPath", "readerPath", "loadFile", "loadPo", "writepath", "baseFile", "readPo", "basepath", "readFile", "readerFile", "readTree", "workpath", "readpath", "workFile", "checkPath", "loadWith", "loadPath"], "mkdir": ["mkdb", "muturl", "mutdb", "ckdb", "MKrel", " mkzip", "ckdir", "kkDir", "ckDir", "kkrel", "mkzip", "kkdir", "ckurl", "kkzip", " mkurl", "MKzip", "mkDir", "mkrel", "MKdir", "mutdir", "mkurl", " mkDir", " mkrel", "mutDir", " mkdb", "MKDir"], "arcInputStream": ["ancInputstream", "arcOutputSync", "arcReadStream", "arcReaderChannel", "arcReadForm", "cOutputSt", "cInputSync", "ancOutputSteam", "cOutputSync", "arcFileSteam", "arcHttpStream", "ancOutputFile", "arcOutputChannel", "ancInputChannel", "arcReadstream", "arcImportStream", "cInputSt", "ancOutputChannel", "arcOutputForm", "ancOutputStream", "arcReaderStream", "arcReadSt", "arcInputChannel", "arcReadSync", "ancOutputForm", "ancInputFile", "arcReaderFile", "arcInputSt", "cInputStream", "cOutputStream", "arcFileStream", "cInputSteam", "arcInputForm", "arcOutputstream", "arcFileSt", "arcHttpSteam", "arcFileSync", "arcOutputFile", "arcImportFile", "arcOutputSt", "arcHttpForm", "arcOutputStream", "ancInputSteam", "arcReadSteam", "ancInputStream", "arcInputSteam", "arcImportstream", "arcInputSync", "arcReaderstream", "arcInputFile", "arcOutputSteam", "arcInputstream", "ancInputForm", "cOutputSteam", "arcImportChannel", "arcHttpstream", "ancOutputstream"], "bis": ["ls", "phis", "uds", "mis", "parts", "ris", "oss", "bits", "BUS", "obb", "bb", "fb", "sis", "ubis", "lus", "abi", "bid", "bps", "vs", "alis", "binary", "ras", "isin", "bi", "ros", "ses", "pins", "cos", "os", "usb", "is", "oris", "bs", "ours", "ubs", "ins", "bus", "idis", "ios", "kos", "lins", "abs", "phys", "banks", "obs", "boot", "onis", "cb", "raf", "ois"], "baseDir": ["fileDirectory", "fileDir", "basedir", "Basedir", "rootPath", "BaseFolder", " basedir", "fileFolder", " baseFolder", " baseDirectory", "BaseDirectory", "rootDirectory", "BaseDir", "baseDirectory", "filedir", "baseFolder", "BasePath", "rootFolder", "rootDir"], "basePath": ["readDir", "outPath", "readInfo", "resourcePath", "fileDir", "viewOrder", "buildHost", "basedHost", "writeStream", "basedType", "resourceName", "baseInfo", "filePath", " baseStream", "viewPath", "Basepath", "outUrl", "basicDir", "parentName", "baseType", "BaseCondition", "BaseFile", " baseHome", "basicInfo", "readName", "baseCondition", "basedPath", " baseFile", "BaseName", "viewStream", "outDir", "basicCondition", "readCondition", "baseHost", "fileUrl", "baseUrl", "buildType", "parentFile", "fileName", "BaseDir", "baseFile", "readUrl", "baseHome", "writeHome", "BaseUrl", "baseOrder", " baseOrder", "parentPath", "basepath", "BaseInfo", " baseType", "resourceDir", "buildPath", " basepath", " baseUrl", "viewHome", "buildDir", "basedDir", "parentUrl", "outName", "basicPath", "resourcepath", " baseHost", "BasePath", "writeOrder", "baseStream"], "schema": ["chema", "mame", "issma", "cheaga", "scheme", "mapa", "Schemar", "isspa", "mama", "syaga", "scheaga", "schemar", " schemas", "syma", "issme", " schemar", "Schemas", "syme", "Scheme", "schemas", "mamas", " scheme", "chemar", "issmas", "Scheaga", "symas", "cheme", "chemas", "Schepa", "schepa", "Schema"], "baseName": ["normalKey", "basDir", "normalName", "coreName", "baseInfo", "basicName", "BaseKey", "corePath", " baseTitle", "normalPath", "baseKey", "basName", "BaseName", "coreDir", "baseTitle", "basInfo", "areaName", "areaPath", "BaseTitle", "basPath", " baseKey", "basicKey", "normalTitle", " baseInfo", "coreInfo", "basicPath", "BasePath", "areaKey"], "entry": ["ent", "style", "result", "uri", "se", "ace", "parse", "path", "ry", "inner", "add", "Entry", "info", "system", "archive", "extra", "e", "ie", "nt", "de", "card", "enter", "cel", "line", "or", "install", "data", "record", "object", "service", "journal", "comment", "editor", "valid", "next", "si", "base", "name", "ries", "pe", "lc", "it", "server", "ge", "obj", "entity", "zip", "article", "letter", "child", "post", "je", "index", "connection", "exp", "element", "ae", "inc", "office", "part", "row", "key", "feed", "sea", "her", "reader", "le", "iterator", "section", "la", "no"], "writePath": ["readDir", "writerDir", "writerPath", "basePoint", "writeStream", "writerCh", "WriteCh", " writeEx", "readCase", "writePoint", "writingPoint", "readName", " writeDir", "WriteEx", "WriteDir", "writeCase", "writeCh", "writeDir", "writeEx", " writeCh", " writePoint", "readStream", " writeCase", "writingDir", "writingPath", "writingCase", "readPoint", "WritePath", "writeName", "writtenPath", "writtenName", "baseStream", "writtenPoint", "writerEx", "writtenStream"], "dirName": ["Dirname", "orderName", "DirUrl", "ordername", "dirname", "dirPath", "DIRAlias", "DIRDef", "DirName", "dirAlias", " dirUrl", " dirPath", "DirAlias", "DirDef", "DIRPath", "dirUrl", "dirDef", "DIRName", " dirname", "orderUrl", "DirPath", " dirAlias", " dirDef"], "bos": ["uds", "obb", "bones", "opus", "bb", "bas", "bo", "ubis", "boards", "ko", "bott", "obo", "bies", "bi", "ros", "bc", "oids", "obi", "os", "oks", "los", "zos", "bs", "fits", "zo", "rots", "ubs", "gb", "nas", "obos", "las", "oos", "ios", "aos", "atis", "lins", "dies", "asio", "banks", "obs", "osa", "boot", "osi", "kos", "ois", "bes"], "i": ["p", "x", "uri", "length", "z", "inner", "c", "ni", "ai", "f", "info", "ii", "s", "e", "l", "I", "ci", "abi", "chi", "ini", "in", "multi", "ip", "io", "bi", "limit", "si", "a", "b", "it", "you", "mini", "is", "ui", "exec", "pi", "ji", "li", "index", "j", "hi", "di", "qi", "batch", "xi", "r", "slice", "id", "o", "zi", "v", "start", "ri", "phi"]}}
{"id1": "18793482", "id2": "22977189", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyapplicationMsg", "modifyApplicationContent", "modifyApplicationMsg", "modifyExternalContent", "modifiedapplicationContent", "modifiedapplicationMsg", "modifyApplicationmessage", "modifyExternalMsg", "modifyapplicationMessage", "modifyExternalmessage", "modifyExternalMessage", "modifyapplicationmessage", "modifiedApplicationmessage", "modifiedapplicationmessage", "modifyAppContent", "modifiedApplicationMessage", "modifiedApplicationMsg", "modifyAppMsg", "modifyAppmessage", "modifyAppMessage", "modifiedApplicationContent", "modifiedapplicationMessage", "modifyapplicationContent"], "locale": ["placeame", "locationALE", "placeale", "localame", "localale", "Locame", " locales", "LocALE", "locue", "localALE", "localator", "localales", "Locales", "Locue", "locationue", "locALE", "locame", "Locator", " locame", "locales", "Locale", "locationale", "placeALE", "locator", "locationales", "localue", "placeales", " locator"], "messageName": ["MessageKey", " messageKey", "messageType", "reasonValue", " messageType", "MessageValue", "phraseName", "MessageType", "messagename", " messagename", "Messagename", "reasonName", "msgValue", "msgName", "msgType", "reasonname", "phraseValue", "reasonType", "MessageName", "phraseType", "phraseKey", "msgKey", "messageKey"], "messageValue": ["messageVal", "messageType", " messageType", "MessageValue", "MessageType", " messageVal", "responseVal", "responseName", "msgValue", "responseType", "MessageVal", "msgName", "msgType", "msgVal", "MessageName", "responseValue"], "properties": ["property", "ps", "prop", "perties", "json", "py", "ips", "config", "txt", "options", "pb", "resources", "data", "metadata", " Properties", "Property", "tmp", "params", "obj", "conf", "api", "stats", " props", "settings", "Pro", "pro", "xml", "ops"], "i18nPath": ["i18nPart", "i18onUrl", "i11fUrl", "i18nFile", "i16nPath", "i32nPath", "i32ninPath", "i18npath", "i16nspath", "i16nStr", "i18ninLocation", "i18nUrl", "i18ninFile", "i11fPath", "i32ninLocation", "i11nUrl", "i18onFile", "i18fCorp", "i16nsPath", "i18naStr", "i18nLocation", "i18nsPath", "i32nFile", "i18ninUrl", "i18fUrl", "i18naPart", "i16nsPart", "i18nsFile", "i16npath", "i18fpath", "i18onPath", "i18nsPart", "i32ninUrl", "i18neUrl", "i11nCorp", "i18bpath", "i32nLocation", "i32nUrl", "i18nepath", "i16nPart", "i18ninPath", "i18nsStr", "i11npath", "i18bPath", "i18nspath", "i18nsLocation", "i11fpath", "i11nPath", "i16nsStr", "i18nePath", "i18napath", "i18nsCorp", "i18onLocation", "i32ninFile", "i18bStr", "i18naPath", "i18nStr", "i18fPath", "i11fCorp", "i18nsUrl", "i18bPart", "i18neCorp", "i18nCorp"], "englishFile": ["englishPath", "examplePath", "Englishfile", "EnglishFiles", "ianaJar", "propertiesPath", "englishFiles", " englishFiles", "exampleFile", "englishDir", "ianaPath", " englishJar", "ianaDir", "languageFile", "propertiesFolder", "EnglishFile", "propertiesfile", " englishDir", "EnglishFolder", " englishfile", "languageDir", "englishFolder", "languageFiles", "EnglishPath", " englishPath", "examplefile", "languagePath", "languagefile", "ianaFile", "propertiesFile", "exampleFolder", "englishJar", "languageJar", "englishfile"], "propertiesFilePath": ["pertiesFilepath", "propertiesfilePath", "pertiesfileURL", "propertiesFilepath", "propertiesFilespath", "pertiesFilePath", "propertiesfilepath", "propertiesSourceFileURL", "pertiesDirName", "propertiesDirName", "propertiesDirUrl", "pertiesFileName", "pertiesfilepath", "propertiesFileURL", "pertiesFileUrl", "propertiesfileUrl", "propertiesSourceFileName", "propertiesSourceFilepath", "propertiesfileName", "pertiesDirPath", "pertiesDirUrl", "pertiesfileName", "propertiesFileUrl", "propertiesDirPath", "propertiesFilesUrl", "propertiesFileName", "propertiesfileURL", "propertiesFilesURL", "pertiesDirpath", "propertiesFilesName", "propertiesFilesPath", "propertiesSourceFilePath", "pertiesFileURL", "pertiesfilePath", "propertiesDirpath"], "file": ["text", "source", "message", "buffer", "property", "File", "ile", "directory", "url", "base", "name", "log", "pe", "zip", "stream", "http", "application", "model", "use", "show", "one", "word", "or", "data", "module", "object", "binary", "play", "force", "up", "files", "book", "entity", "future", "unit", "parent", "media", "path", "language", "field", "socket", "single", "folder", "resource", "format", "FILE", "b", "die", "string", "h", "php", "reader", "content", "p", "filename", "fp", "f", "page", "l", "class", "it", "fe", "function", "letter", "child", "connection", "lock", "handler", "full", "part", "le"], "in": ["p", "init", "into", "inn", "gin", "pin", "inner", "f", "s", "plus", "i", "input", "l", "inside", "image", "sin", "or", "IN", "ic", "con", "ini", "win", "io", "n", "isin", "din", "b", "it", "nin", "ins", "cin", "lin", "In", "inc", "again", "rin", "kin", "r", "er", "login", "err", "reader", "bin", "ri", "d"], "out": ["p", "work", "output", "sync", "net", "inner", "f", "home", "s", "w", "ex", "i", "word", "one", "to", "socket", "OUT", "image", "by", "builder", "n", "io", "bin", "up", "and", "b", "ou", "outer", "ext", "exec", "string", "exp", "plain", "Out", "write", "full", "outs", "again", "lib", "part", "r", "err", "cli", "o", "end", "v", "inc", "error", "co"], "c": ["p", "x", "cy", "char", "xc", "uc", "dec", "cf", "ac", "f", "w", "i", "pointer", "l", "k", "ci", "con", "ce", "ice", "ec", "n", "a", "arc", "bc", "pc", "character", "b", "col", "lc", "C", "code", "cr", "cont", "sc", "ch", "rc", "cur", "h", "cc", "esc", "size", "enc", "cl", "cu", "t", "r", "ct", "o", "v", "d", "abc", "dc"], "is": ["as", "ris", "ps", "re", "IS", "str", "us", "isa", "info", "s", "its", "isu", "iss", "are", "i", "Is", "serv", "iso", "ib", "does", "ir", "si", "os", "it", "ui", "res", "api", "ins", "stream", "ais", "ios", "iter", "es", "id", "bis", "get", "has", "ri"], "breader": ["breaders", "feedamer", "breadr", "brewer", "webamer", " BreadER", "weber", " Breader", " Breaders", "webiter", "feediter", "feeder", " cakeers", " cakeER", " cakeler", " breadler", "webr", "brewamer", "breaditer", " cakeer", "feedr", "breadamer", " Breadler", "breadER", " breaders", " breadER", "brewr", "brewiter", "breadler"], "line": ["text", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "lined", "sync", "cell", "lo", "frame", "day", "model", "page", "pass", "link", "phrase", "one", "word", "l", "item", "inline", "data", "definition", "nl", "strip", "comment", "ip", "next", "url", "base", "name", "log", "character", "lc", "band", "code", "split", "letter", "sl", "body", "li", "side", "string", "header", "rule", "LINE", "el", "lin", "write", "plugin", "block", "value", "part", "row", "key", "response", "feed", "entry", "end", "le", "liner", "section", "error", "status", "no"], "strBuilder": ["brbuilder", "brBuilder", "brBuild", "brBlock", "StrBuilder", "stringBuild", "brBuilding", "stringBuffer", " strBuilding", "strBuild", "brBuffer", "strBuilding", "StrBuilding", "StrBlock", " strBlock", "strBuffer", "StrBuffer", "stringBuilder", " strBuffer", " strBuild", "strBlock", "stringbuilder", "stringBuilding", "Strbuilder", " strbuilder", "strbuilder", "StrBuild"], "pieces": ["parts", "nets", "apps", "words", "lines", "bits", "forms", "marks", "bones", "lists", "keys", "ips", "styles", "bytes", "pots", "seconds", "groups", "services", "vals", "cards", "tips", "names", "strings", "cells", "flows", "values", "rings", "letters", "sections", "pins", "objects", "boxes", "files", "split", "cuts", "features", "steps", "pages", "places", "packs", "planes", "tops", "items", "blocks", "circle", "piece", "phones", "ops"], "found": ["created", "normal", "result", "Found", "identified", "loaded", "first", "successful", "f", "all", "not", "filled", "built", "lost", "printed", "l", "given", "still", "count", "successfully", "val", "defined", "updated", "left", "got", "required", "fixed", "missing", "old", "find", "matched", "valid", "expected", "null", "search", "sent", "fl", "letter", "true", "confirmed", "based", "full", "used", "failed", "fall", "temp", "made", "finding", "err", "broken", "changed", " Found"]}}
{"id1": "20751378", "id2": "7981642", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": [" hashPass", "signpassword", "hashPass", "signPass", " hashpassword", "cryptpassword", "hashWord", " hashWord", "signPassword", "cryptWord", "signWord", "hashpassword", "cryptPassword", "cryptPass"], "password": ["p", "text", "secret", " passwords", "message", "python", "words", "cache", "token", "path", "username", "pad", "wd", "pass", "w", "phrase", "command", "seed", "word", "input", "pattern", "padding", "data", "auth", "PASS", "mac", "description", "database", "name", "security", "sword", "code", "number", "address", "sha", "string", "crypt", "prefix", "encrypted", "Password", "key", "user", "plain", " Password", "content"], "hash": ["work", "text", "message", "cache", "json", "ash", "dig", "build", "auth", "url", "base", "log", "search", "code", "pool", "msg", "sha", "height", "replace", "key", "rh", "error", "result", "copy", "ashes", "check", "phrase", "root", "dump", "addr", "gh", "uild", "sum", "her", "id", "pkg", "user", "match", "secret", "call", "history", "style", "hed", "update", "oh", "format", "array", "security", "number", "proof", "h", "string", "tag", "sh", "html", "put", "version", "value", "bolt", "square", "length", "mod", "memory", "math", "alt", "kh", "mac", "Hash", "host", "address", "hex", "index", "ruby", "ha", "ssh", "handle"], "md": ["mand", "hm", "mm", "ME", "mod", "amd", "f", "Cmd", "wd", "dig", "cmd", "dm", "mb", "meta", "mg", "sd", "m", "nm", "metadata", "mad", "mac", "grad", "der", "sm", "ms", "vd", "kg", "nd", "sha", "pd", "gd", " MD", "gb", "od", "dd", "mt", "hd", "am", "km", "MD", "dh", "mc", "xd", "ma", "df", "mag", "pm", "d", "bd"]}}
{"id1": "14764852", "id2": "20100809", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doRequest": ["DoResponse", "DoOperation", "runRequest", "doOperation", " doOperation", "doResponse", "doQuery", "DoQuery", "DoRequest", "runResponse", " doResponse", "runQuery", " doQuery", "runOperation"], "method": ["text", "source", "attr", "message", "mode", "uri", "port", "client", "METHOD", "path", "session", "head", "view", "project", "process", "record", "object", "resource", "format", "module", "transform", "class", "url", "subject", "name", "host", "header", "connection", "stream", "cl", "tr", "version", "request", "route", "crit", "ssl", "sign", "type", "Method", "content", "http"], "headers": ["frames", "relations", "workers", "types", "parts", "words", "writers", "lines", "ppers", "agents", "keys", "head", "ers", "ters", "groups", "options", "heads", "limits", "vals", "breakers", "caps", "resources", "names", "parents", "strings", "authors", "checks", "values", "qs", "boxes", "drivers", "params", "files", "docs", "members", "features", "header", "fields", "codes", "settings", "tails", "users", "properties", "blocks"], "auth": ["token", "authent", "port", "anon", "ac", "author", "config", "home", "info", "head", "pass", "uth", "conn", "aut", "act", "host", "password", "stat", "secure", "api", "guard", "oct", "upload", "header", "Auth", "arch", "lock", "enc", "acl", "auto", "ant", "block", "ssl", "art", "user", "parent", "type", "cb", "att", "http"], "target": ["source", "remote", "result", "uri", "current", "client", "port", "path", "root", "owner", "arget", "manager", "object", "Target", "resource", "location", "proxy", "next", "url", "base", "subject", "server", "host", "address", "ARGET", "connection", "external", "request", "route", "response", "href", "template", "parent", "context", "reply"], "body": ["text", "secret", "source", "message", " payload", "buffer", "media", "output", "port", "Body", "load", "config", "view", " bodies", "pass", " content", "one", "ODY", "odies", "data", " Body", "object", "resource", "binary", "proxy", "comment", "storage", "other", " object", " data", "url", "log", "b", "reason", "params", "code", "query", "connection", "header", "h", "lock", "stream", "full", "block", "file", "part", "response", "ob", " message", "plain", "db", " response", "content", "reply"], "con": ["xc", "uc", "client", "cf", "clean", "c", "ac", "cat", "ocon", "ca", "conn", "an", "cas", "connect", "pc", "ann", "conv", "col", "cos", "fac", "exec", "ran", "cr", "Con", "conf", "ch", "cur", "rc", "connection", "fn", "ain", "fa", "cond", "cp", "enc", "cons", "cm", "cl", "fc", "en", "un", "dom", "cn", "mc", "request", "crit", "CON", "ct", "co", "can", "dc"], "res": ["parts", "ret", "result", "ps", "cs", "re", "arr", "out", "s", "vals", "val", "resp", "data", "des", "req", "rs", "vs", "RES", "os", "qs", "params", "obj", "bs", "rep", "pres", "details", "resolution", "Res", "es", "pers", "r", "results", "err", "rel", "response", "js", "cons", "content"]}}
{"id1": "300397", "id2": "20920051", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "16820041", "id2": "16549995", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"encodePassword": ["encodeString", "enodePassword", "enodedPassword", "enccodepassword", "encodepassword", "enoderSecret", "enodedpassword", "enccodeString", "enodedString", "enoderpassword", "enodeSecret", "enccodePassword", "enoderPassword", "enodeString", "enccodeSecret", "enodedSecret", "enodepassword", "enoderString", "encodeSecret"], "_originalPassword": ["_Originalpassword", "_OriginalPass", " _actualPassword", "_actualPass", "theoriginalpassword", "_encryptedPass", "theorigPass", "_originalPass", "theorigpassword", "_OriginalPassword", "_originalSalt", "_actualSecret", "theorigPassword", "_encryptedPassword", "_encryptedpassword", "theoriginalSalt", "theoriginalPass", "_editedPass", " _originalSecret", "_origSalt", "_origpassword", " _actualSecret", "_OriginalSalt", "_originalSecret", "_editedPassword", " _actualPass", "_actualPassword", "_origPassword", "theorigSalt", " _originalPass", "_originalpassword", "theoriginalPassword", "_encryptedSalt", "_origPass", "_editedSecret", "_OriginalSecret"], "md": ["mand", "hm", "alg", "mm", "mp", "mod", "amd", "Cmd", "pad", "hash", "dig", "cmd", "dm", "mb", "meta", "mg", "sd", "data", "m", "ph", "ad", "metadata", "mad", "mac", "sm", "ms", "vd", "code", "kg", "pd", "sha", "gd", "dr", " MD", "gb", "ld", "od", "dd", "mn", "cm", "mo", "mt", "hd", "cd", "MD", "dh", "mc", "ma", "df", "id", "mag", "pm", "db", "d", "bd", "dc"], "encodedPassword": ["encapedPassword", "encodedSecret", "encoderPassword", "encoredSecret", "ecodedPassword", "encodedString", "ecodedSecret", "enccodedpassword", "encoderpassword", "enodedPassword", "encachedString", "encapedPass", "encryptedString", "enoderSecret", "ecryptedPassword", "encapedpassword", "enoderPass", "enryptedpassword", "enodedpassword", "encoredPassword", "encryptedSecret", "enryptedString", "encryptedPass", "enodedString", "encryptedPassword", "encoderString", "encodedPass", "ecodedString", "enoderpassword", "enodedPass", "encidedPassword", "encoredString", "encidedPass", "enryptedPass", "enryptedPassword", "enccodedSecret", "encapedString", "enoderPassword", "encidedSecret", "enccodedPass", "encoderPass", "ecryptedSecret", "encachedSecret", "encidedpassword", "ecryptedString", "enccodedPassword", "enodedSecret", "encodedpassword", "encoderSecret", "encryptedpassword", "encachedPassword"]}}
{"id1": "17580775", "id2": "471804", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"runInternal": ["processInternal", "runImpl", " runImpl", "doSync", "processSync", "runSync", "runExternal", "processImpl", "doImpl", "doExternal", "processExternal", "doInternal", " runExternal", " runSync"], "connection": ["source", "message", "relation", "remote", "cache", "current", "connected", "session", "translation", "config", "Connection", "event", "image", "default", "loc", "con", "location", "proxy", "builder", "directory", "log", "operation", "channel", "wrapper", "creator", "entry", "ion", "section", "error", "volume", "application", "position", "client", "component", "use", "command", "object", "statement", "lc", "graph", "password", "entity", "layer", "expression", "environment", "timeout", "driver", "socket", "condition", "resource", "communication", "description", "document", "character", "container", "option", "version", "reader", "engine", "port", "inner", "c", "service", "connect", "database", "server", "function", "body", "index", "machine", "handler", "collection", "request", "context"], "visited": ["VISited", "visITED", "viewITED", "VisITED", "visitted", "VISITED", "visalled", "vised", "invitted", "invITED", "Vised", "viewited", "invalled", "Visitted", "Visalled", "Visited", "viewitted", "VISalled", "VISed", "viewed", "VISitted", "invited"], "startTimeStamp": ["startTimestamp", "startTimeEstamped", "startTimeestng", "startTimeEstamps", "startTimeStamped", "startLineStng", "startTimeestamp", "startTimestamped", "startTimestamps", "startLineStamps", "startTimeEstamp", "startLineStamp", "startTimeEstng", "startTimeestamps", "startTimeStng", "startLineEstamp", "startTimeestamped", "startLineEstng", "startLineEstamps", "startLineStamped", "startTimeStamps", "startTimestng", "startLineEstamped"], "delayedProgress": ["deladedStatus", "elayedComplete", "eladedStatus", "deladedComplete", "eladedComplete", "deliverComplete", "eladedContent", "delivedContent", "elayedProgress", "delayedComplete", "eladedProgress", "deliverContent", "elayedContent", "deliverProgress", "deladedProgress", "delayedStatus", "delivedProgress", "delayedContent", "delivedComplete", "deliverStatus", "deladedContent", "elayedStatus", "delivedStatus"], "conn": ["ls", "cmp", "uc", "client", "sync", "cf", "connected", "c", "config", "dc", "Connection", "nt", "l", "Conn", "ci", "loc", "con", "open", "ad", "act", "io", "n", "connect", " con", "ann", "conv", "lc", "obj", "exec", "ch", "rc", "db", "nc", "h", "cc", "channel", "cp", "enc", "cn", "mc", "ssl", "cli", "ct", "comm", "ctx", "cb", "co", "att", "http"], "fileName": [" filePath", " fileSpace", "urlName", "filename", "imageName", "FileArea", "filePath", "urlKey", "imageSpace", "contentPath", "fileKey", " fileArea", "fileArea", "FilePath", "imagePath", " filename", " fileKey", "FileName", "imagename", "fileSpace", "urlPath", "contentName", "FileKey", "urlArea", "contentSpace", "contentname"], "disp": [" dispe", "interpatch", "dispose", "interp", "disP", "detpatch", "Dispr", "detP", "prop", "scheap", "prope", "dispart", "dispend", "disap", "Dispatch", "dispp", "interap", "defpend", "dispe", "Disp", "schepe", "DisP", "broadpend", "dispatch", "Disps", "defps", "dispr", "broadpart", "schep", "Dispp", "propr", "defp", "interpe", "Dispart", "defpart", "broadp", "Dispend", " dispr", "detp", "Dispose", "schepatch", "disps", "detpp", "Disap", "broadps", "interP", " dispose", "propose", "Dispe", "interpp"], "p": ["pre", "lp", "tp", "c", "ping", "f", "point", "at", "np", "pl", "e", "i", "l", "po", "pos", "loc", "m", "q", "bp", "vp", "pa", "n", "ip", "g", "b", "pe", "col", "rep", "pi", "api", "index", "j", "sp", "h", "patch", "pr", "ap", "jp", "y", "part", "pat", "r", "t", "op", "pp", "end", "o", "after", "v", "d", "P"], "response": ["message", "result", "reset", "uri", "json", "output", "path", "successful", "model", "page", "timeout", "success", "pointer", "image", "complete", "resp", "data", "found", "prot", "resource", "reply", "description", "next", "server", "Response", "code", "function", "api", "body", "index", "respond", "ception", "respons", "radius", "received", "en", "value", "version", "collection", "request", "feed", "site", "id", "error", "status", "http"], "contentType": ["ContentName", " contentTyp", "contentInfo", "ContentInfo", "messageType", "messageLength", "documentName", "contentLength", " contentLength", "documentLength", "messageInfo", "messageLen", "ContentLen", "documentTyp", "contentName", "contentTyp", "ContentLength", "ContentType", " contentName", "documentType", " contentInfo", "ContentTyp"], "contentEncoding": ["contentEncocol", "loadEncoding", "contentLocoding", "contentEnasing", "contentLocryption", "ContentEncoding", "loadEncaring", "loadEncryption", "ContentDecocol", "contentEoding", "ContentEncocol", "contentEnryption", "contentCryption", "contentencocol", "ContentEncoder", "contentEncReading", "contentencoding", "contentencReading", "contentCoding", "loadEnasing", "contentLocaring", "contentCasing", "contentEncoder", "ContentDecReading", "contentEncryption", "contentEnaring", "contentDecoder", "contentencoder", "loadEncasing", "contentDecReading", "ContentDecoding", "contentDecoding", "contentEnoding", "contentEncaring", "ContentDecoder", "ContentEncReading", "contentDecocol", "contentCaring", "contentLocasing", "contentEocol", "contentEoder", "contentEncasing", "loadEnryption", "loadEnaring", "loadEnoding", "contentEReading"], "contentLen": ["activityLen", "contentSl", "contentSize", " contentlen", "Contentlen", "resourceLen", "contentLength", " contentLength", "activityLength", "ContentLen", "resourceSize", "activitySl", "activitySize", "ContentSl", " contentSl", "ContentSize", "ContentLength", "resourcelen", " contentSize", "resourceLength", "contentlen"], "is": ["mis", "ot", "im", "IS", "ss", "out", "us", "net", "isp", "ys", "not", "are", "iss", "ub", "ync", "ip", "os", "it", "isc", "isl", "igh", "ios", "un", "version", "ion", "ig", "can"], "url": ["text", "source", "org", "buffer", "uri", "json", "client", "str", "path", "username", "Url", "download", "config", "page", "link", "socket", "image", "service", "resource", "email", "location", "document", "log", "server", "host", "URL", "address", "sl", "string", "channel", "layer", "html", "file", "ssl", "feed", "user", "status", "context", "http"], "loadNext": ["loadsNext", "checkNext", "loadFirst", "checkFirst", "loadsFirst", "loadsPrevious", "checkPrevious", "loadsLast", "loadingLast", "loadingPrevious", "checkLast", "loadLast", "loadingFirst", "loadingNext", "loadPrevious"], "itemsLoadedPartially": ["itemsLoadedPARTials", "itemsLoadippedpartially", "itemsLoadedpartial", "itemsLoadippedPartally", "itemsLoadedCopial", "itemsLoadedPartial", "itemsLoadedPartials", "itemsLoadippedpartally", "itemsLoadippedpartials", "itemsLoadedpartials", "itemsLoadedPartally", "itemsLoadedCopials", "itemsLoadedpartally", "itemsLoadedCopally", "itemsLoadippedPartials", "itemsLoadedPARTally", "itemsLoadippedpartial", "itemsLoadippedPartially", "itemsLoadedCopially", "itemsLoadedPARTially", "itemsLoadedpartially", "itemsLoadedPARTial", "itemsLoadippedPartial"]}}
{"id1": "17716716", "id2": "12783713", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"plainToMD": [" stringTOString", " stringToString", " input2DER", " stringTOHash", " stringtoString", " string2Hash", " stringtoHash", " inputToHash", " string2MD", " inputToString", " stringToDER", " stringtoMD", " stringToHash", " input2Hash", " inputToMD", " stringToMD", " input2MD", " string2DER", " inputToDER", " stringTOMD", " stringTODER", " string2String", " stringtoDER", " input2String"], "loggerCol": ["loglerCol", "loggingColumn", "pluggerCor", "logorerCol", "progingCollection", "logorercol", "pluggerCol", "pluggerDr", "progercol", "loggeeCor", "loggingDr", "loggeCor", "loggercol", "logorerColumn", "loggingCor", "loggerDr", "pluggingCol", "loggerColumn", "loglerCollection", "pluggercol", "loglerColumn", "pluggingCor", "progerCol", "progerColumn", "loggingCollection", "progingcol", "loggeecol", "progerCollection", "pluggingDr", "pluggingcol", "loggerCollection", "progingColumn", "loggeDr", "loggeCol", "progingCol", "loggingCol", "loggerCor", "loggeeCol", "loggeeDr", "loggingcol", "logorerCollection", "loggecol", "loglercol"], "input": ["text", "source", "form", "buffer", "output", "str", "dict", "path", "empty", "instance", "config", "model", "state", "plus", "Input", "cmd", "image", "IN", "data", "in", "format", "url", "base", "inf", "null", "password", "container", "string", "list", "connection", "alpha", "raw", "file", "temp", "request", "ssl", "reader", "xml", "audio", "context"], "byteHash": ["bytesHash", "byteSalt", "wordArray", "wordHash", "ByteBlock", " bytehash", "bytesSalt", "bitBlock", "bitSum", "Bytehash", "wordhash", "wordSum", "bytesArray", " byteArray", "bithash", "stringhash", "bitHash", " byteBlock", "blockHash", "byteArray", " byteSum", "ByteHash", "byteshash", "byteSum", "ByteSum", "blockhash", "stringArray", "stringSalt", " byteSalt", "byteBlock", "blockSum", "bitArray", "blockBlock", "stringHash", "bytehash"], "md": ["mand", "hm", "mm", "mp", "mod", "amd", "f", "Cmd", "hash", "dig", "cmd", "dm", "mb", "meta", "mg", "ph", "m", "nm", "metadata", "ad", "mac", "rm", "sm", "ms", "Msg", "um", "msg", "pd", "dr", " MD", "cc", "mn", "dd", "di", "cm", "mo", "mt", "cd", "am", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "d", "doc", "rpm", "bd"], "md5result": ["md25result", "md25package", "md305runner", "md7result", "md4runner", "md305results", "md305result", " md7Result", "md5package", "mddownpackage", " md7results", "md7Result", "md4results", "md5Result", "md6results", " md5Result", "md25data", "md6report", " md25result", "md25Result", "md305response", " md25data", "md53runner", " md305runner", "mddowndata", "md6Result", " md7result", "md5response", "md53results", " md305results", "md53result", "mddownresult", " md25Result", "md5data", "mddownResult", " md5data", " md5package", "md6package", "md7results", "md512results", "md4response", "md512Result", "md7report", "md5report", "md6result", " md5runner", "md53response", " md305result", " md5report", "md5runner", " md7report", "md4result", " md25package", " md5response", "md6data", "md512result", " md305response", "md512report", "md5results", " md5results"], "i": ["p", "x", "uri", "length", "z", "c", "f", "ai", "s", "ii", "gi", "e", "d", "l", "I", "ci", "multi", "n", "bi", "io", "si", "u", "b", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "di", "qi", "xi", "fi", "r", "key", "mu", "o", "id", "zi", "v", "ri", "ti"]}}
{"id1": "2396191", "id2": "1954410", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksfromURLSafe", "getLinksFromURLSlow", "getLinksFromURLSafe", "getLinksfromURLSlow", "getLinksFromURLfast", "getLinksFromUrlSlow", "getLinksFromUrlfast", "getLinksfromUrlFast", "getLinksfromURLfast", "getLinksFromSSLfast", "getLinksfromUrlSafe", "getLinksfromUrlfast", "getLinksFromUrlSafe", "getLinksFromStringfast", "getLinksFromSSLSafe", "getLinksFromUrlFast", "getLinksfromUrlSlow", "getLinksFromSSLSlow", "getLinksFromStringSlow", "getLinksFromSSLFast", "getLinksFromStringSafe", "getLinksFromStringFast", "getLinksfromURLFast"], "p_url": ["p6url", "eklink", "pfpage", "p6config", "pamlayer", "p6line", "p24link", "pfline", "pfurl", "p_service", "p64url", "pkhtml", "p24root", "pamurl", " p_line", "pipfile", "p6root", "pxline", "p24url", "x_service", "pflink", "p_root", "pklayer", "x_domain", "pe_url", "tp24file", "pe_root", "p__name", "tp_root", "p25layer", "p_link", "e_layer", "p_path", "tp_url", "p_html", "p9resource", "e_link", "p25link", "p25url", "p__resource", "p_file", "tp24root", "pe_config", "tp_file", "p_layer", "e_html", "p64path", "pfpath", "ekhtml", "p25html", "pxroot", "pe_line", "pklink", "p__path", "x_resource", "pxurl", "p_name", "pxconfig", " p_path", "pkurl", "ekurl", "p_domain", "p64page", " p_page", "pfroot", "p_line", "p9service", "pamhtml", "p_resource", "tp24link", "tp_link", "piproot", "pamlink", "p9url", "p_config", " p_resource", "p_page", " p_name", "e_url", "eklayer", "p9domain", "pffile", "tp24url", "pipurl", "piplink", "p__url", "p24file", "p64line"], "x_url": ["p_host", " x_log", "x_loc", " x_resource", "p_loc", " x_ssl", "x_ssl", "p_conn", "x_resource", "x_log", "x_host"], "x_conn": ["x_con", "p_con", "x_client", "p_client", "wx_conv", "x___client", "wx_conn", "x___db", "wx_cat", "wx_con", "x___conn", "x_conv", "x_cat", "x_db", "p_conn", "x___con", "p_db"], "x_is_reader": ["x_is_stream", "x_ismldraft", "x_is_draft", "x_ismlmanager", "x_is_pointer", "x_is_resource", "x_ismlreader", "x_is_writer", "x_ismlstream", "x_is_manager"], "x_reader": ["cross_url", "x8root", "X_reader", "cross_parser", "x8parser", "cross8reader", "X_result", "x8url", "x67root", "x_stream", "x24result", "cross8url", "x_parser", "x67url", "x67parser", "cross_root", "x24stream", "cross8parser", "X_stream", "X_parser", "x24reader", "cross8root", "x67reader", "x24parser", "x8reader", "cross_reader"], "x_line": ["x_record", "xingcell", "x__line", "xingline", "p_line", "xx_comment", "x_lin", "x_cell", "p_link", "x24line", "ex_line", "ex_cell", "x__link", "xingpage", "p_page", "x__page", "x24link", "x__url", "x24lin", "ex_record", "ex_page", "xx_lin", "xx_line", "xingrecord", "x24comment", "xx_link", "x_comment"], "e": ["p", "me", "match", "eps", "eve", "re", "se", "ace", "c", " E", "eu", "f", "event", "eur", "ie", "driver", "l", "line", "oe", "ele", "E", "m", "ce", "ze", "ec", "ne", "n", "g", "error", "ente", "b", "pe", "edge", "te", "code", "ge", "exec", "fe", "entity", "body", "je", "eb", "he", "element", "ee", "el", "engine", "ae", "en", "file", "es", "y", "ev", "r", "er", "t", "entry", "o", "le", "end", "v", "esi", "ue", "d", "ea"], "x_match": ["xlmatch", "e_match", "x5case", "p__pattern", "x__case", "xlgroup", "ax5link", " x_tag", "xamslice", "p_matched", "x___check", "extJmatch", "xjurl", "x__url", "p__matched", " x_case", "x5match", "xldate", " x__slice", "x_info", "x_group", "xJmatch", " x_group", "x_date", "x_matched", "ax5case", " x_replace", "x___matched", "xlsearch", "x__match", "x_replace", "ax5info", "x_meet", "x5link", "x__replace", "xlpattern", "ext_search", "xjmatch", "extJpattern", "x_search", "p_pattern", "e_matched", "x__matched", "ext_member", " x_date", "ax_link", "ax_match", "xamcase", "x___match", "p_match", "xJpattern", "e___matched", "e_meet", " x_slice", "e_check", "x_pattern", "x___meet", "xJsearch", "ext_pattern", "x_member", "extJsearch", "xjmatched", "x_check", "x5info", "e___meet", "xJmember", " x__case", "x_case", "xammatch", "p__match", "x_slice", " x__replace", "ax_info", "x_tag", "ext_match", "xamreplace", "xltag", "e___check", "e___match", "x__pattern", "x__slice", "xjpattern", " x__match", "xlmember", "p__url", "ax5match", "extJmember", "ax_case"], "x_dir": ["x_group", "xnetgroup", " x_group", "x6url", " x_file", "xneturl", "x6group", "xnetfile", "x_file", "x6file", "xnetdir", "x6dir"], "x_root": ["x7alias", "x7root", "xml_directory", "x7path", "xml_path", "x_path", "x7directory", "xml_root", "xml_alias", "x_alias", "x_directory"], "x_links": [" x_ids", " x_points", " x_lines", "x67ids", "x_ids", "x67lines", "x67links", "x_lines", "x67points", "x_points"], "x_texts": ["x_pathes", "x_paths", "x_logches", "x_urls", "x_pathls", "x_loges", "x_textches", "x_logls", "x_urlches", "x_logs", "x_urlls", "x_textes", "x_pathches", "x_urles", "x_textls"], "x_buf": ["y_rc", "x_bag", "y__rc", "x1buf", "x__tmp", "X_buf", "x__buff", "ex__tmp", "x___bag", "x64rc", "x_wb", "X_buffer", "x_uf", "x___buf", "x__buffer", "x_tmp", "x__cb", "x1buff", "x64uf", "X_buff", "x1tmp", "x64bag", "y_buf", "x__buf", "x64buf", "ex__cb", "ex_cb", "X_wb", "ex__buff", "y_bag", "y__uf", "x__wb", "x__rc", "ex_tmp", "x___uf", "ex_buff", "x___rc", "y__bag", "x_cb", "x1cb", "x__uf", "ex_buf", "ex__buf", "x_rc", "y_uf", "x_buffer", "x__bag", "x_buff", "y__buf"], "x_matches": ["x_attched", "x_patcks", "x_bathes", "x_matures", "x_Matures", "x_calhes", "x_mathes", "x_matchers", "x_patchers", "x_matchches", "x_attcks", "x_matchcher", "x_matched", "xKtextings", "x_batches", "x_batures", "x_Matches", "x_textches", "xKtexthes", "x_matchched", "x_matcher", "x_morched", "x_matchchers", "x_patched", "x_attches", "x_atthes", "x__matches", "x__matures", "x_matoms", "xKmatings", "x_pathes", "x_loches", "x_matcks", "xKmatches", "x_locting", "x_morches", "x_matings", "x_matting", "xKtextches", "x_calches", "xKtextoms", "x_textoms", "x_textings", "x__mathes", "x_patches", "x_Matchers", "x_locches", "x_caloms", "x_matchings", "x_batchers", "x_matchhes", "x_Matcher", "x_calings", "x_locched", "x_morting", "xKmatoms", "x_Mathes", "x_patcher", "x__matchers", "x_morhes", "xKmathes", "x_matchcks", "x_matchting", "x_texthes", "x_matchoms"], "x_page": ["xerline", "x_feed", "X_page", "X_url", "x67page", "X_line", "x_loc", "ex_link", "ex_file", "tx_feed", "xerlink", "x67file", "x67link", "x_file", "tx_line", "x67loc", "tx_page", "ex_loc", "x_path", "ex_page", "xerfeed", "X_path", "xerpage", "tx_link"], "x_link": ["xpubline", " x_loc", "ex_link", "x_loc", "xpublink", "xpubtarget", "ex_line", "ex_url", " x_target", "ex_page", "xpubloc", "x_target"], "i": ["p", "x", "uri", "z", "c", "f", "ai", "gi", "ii", "info", "ori", "ix", "ie", "I", "k", "count", "ci", "ini", "in", "chi", "multi", "n", "io", "iu", "a", "si", "bi", "u", "b", "it", "iv", "ui", "pi", "oi", "ji", "index", "li", "j", "hi", "di", "qi", "eni", "y", "xi", "r", "key", "o", "id", "zi", "v", "ri", "ti", "phi"]}}
{"id1": "7891509", "id2": "13644375", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"pageAddress": ["urlLocation", "resourceAddress", "resourceaddress", "PageAddress", "pageLocation", "siteLocation", "Pageaddress", "resourceLocation", "urlAddress", " pageUrl", " pageName", "pageUrl", "urlUrl", "pageName", "resourceUrl", "siteUrl", "siteName", "urladdress", "PageLocation", "siteAddress", "pageaddress", "PageName", " pageLocation", "PageUrl"], "url": ["ls", "source", "uri", "out", "browser", "client", "Url", "f", "bb", "this", "page", "i", "l", "socket", "image", "loader", "data", "web", "object", "resource", "open", "service", "base", "b", "server", "host", "URL", "address", "sl", "string", "connection", "channel", "stream", "element", "plugin", "file", "r", "feed", "ssl", "reader", "user", "http"], "in": ["source", "as", "init", "buffer", "into", "rec", "gin", "inn", "out", "client", "token", "inner", "c", "f", "s", "i", "input", "l", "socket", "inside", "conn", "line", "read", "IN", "data", "ini", "win", "resource", "isin", "bin", "b", "nin", "min", "ins", "stream", "In", "impl", "inc", "again", "file", "kin", "r", "err", "login", "ssl", "id", "reader", "din"], "inputLine": ["InputFile", "InputLine", "imageFile", "inputline", " inputUrl", "inputContent", "InputL", "rawLine", "pageLine", "rawFile", "inputFile", "rawContent", "pageline", "InputCell", "rawUrl", "rawline", " inputL", "rawPage", "selectFile", " inputContent", " inputline", "pageUrl", "inputL", "selectContent", " inputString", "inputCell", " inputPage", "selectLine", " inputCell", "inputString", " inputFile", "inputUrl", "imageCell", "imageLine", "rawString", "imageL", "inputPage", "pageString", "selectPage"]}}
{"id1": "19912848", "id2": "3806532", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "4852691", "id2": "21827619", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"hash": ["text", "copy", "str", "check", "update", "component", "dig", "dump", "build", "read", "print", " fingerprint", "log", "add", "SHA", "Hash", "code", "password", " Hash", "h", "string", "sum", "pack", " hashes", " hashing", "get"], "data": ["p", "text", "source", "message", "result", "buffer", "video", "media", "output", "json", "str", "length", "DATA", "memory", "info", "s", "bytes", "input", "dump", "image", "padding", "format", "binary", "storage", "a", "base", "database", "address", "hex", "dat", "body", "string", "connection", "key", "response", "reader", "audio", "content"], "digest": ["loger", "bigest", "Digit", "Digester", "Digests", "bigester", "DigEST", "digEST", "logest", " digests", "Digener", "bigger", "Diger", "bigEST", " digse", " digener", "logester", "Digger", "signger", "digger", " digger", "signEST", " digit", "logener", "digests", " digEST", "diger", "biger", "Digse", "signester", " diger", "Digest", "digit", "signests", "signer", "signse", "digener", "signit", "digester", "signest", " digester", "digse"]}}
{"id1": "5061606", "id2": "20602651", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 0, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNeceseless", "createSettingsIfNequessary", "createSettingsIfNequessarily", "createSettingsIfNececary", "createSettingsIfNecccesseless", "createSettingsIfNequesseless", "createSettingsIfNequccessary", "createSettingsIfNecesnecessary", "createSettingsIfNequccesseless", "createSettingsIfNecessnecessary", "createSettingsIfNecccessnecessary", "createSettingsIfNececarily", "createSettingsIfNequccessnecessary", "createSettingsIfNececeless", "createSettingsIfNecccessarily", "createSettingsIfNequccessarily", "createSettingsIfNecesseless", "createSettingsIfNequessnecessary", "createSettingsIfNecesarily", "createSettingsIfNececnecessary", "createSettingsIfNecesary", "createSettingsIfNecccessary", "createSettingsIfNecessarily"], "out": ["source", "group", "init", "app", "result", "cookie", "copy", "cache", "output", "sync", "client", "path", "net", "at", "config", "this", "model", "page", "timeout", "ex", "i", "socket", "OUT", "conn", "image", "by", "data", "writer", "object", "io", "up", "editor", "a", "window", "url", "log", "name", "array", "null", "server", "obj", "pool", "exec", "password", "index", "connection", "channel", "lock", "prefix", "plain", "exit", "Out", "write", "plugin", "outs", "again", "off", "file", "parent", "err", "o", "user", "flush", "bin", "error"], "fSettings": ["Fsettings", "fsSetup", "sfSettings", "FConfig", " fConfig", "FSetting", "sfsettings", " fSetting", "sfettings", "fsSetting", "fileSetting", "FSetup", "fmSetup", " fJs", "fmConfig", "fettings", "rfConfig", "fsConfig", "filesettings", "rfFs", "fSetting", "fmSetting", "rfSetting", "fsSettings", " fsettings", "fConfig", "sfJs", "fmSettings", "fsFs", " fettings", "sfSetting", "FJs", "rfSettings", "fSetup", "fFs", "FSettings", "fJs", "fileettings", "fileSettings", "fsettings", " fFs"], "src": ["attr", "source", "text", "ref", "filename", "sb", "lower", "fp", "str", "uri", "st", "uc", "path", "config", "ource", "loc", "req", "prot", "img", "dest", "sr", "storage", "url", "base", "tmp", "b", "sel", "sc", "sub", "sl", "dist", "rc", "rb", "ins", "string", "gb", "cur", "stream", "ctr", "settings", "file", "route", "ssl", "cb"], "in": ["source", "init", "copy", "gin", "inn", "path", "inner", "c", "f", "s", "i", "input", "l", "image", "sin", "IN", "data", "ini", "win", "con", "n", "bin", "url", "b", "index", "ins", "connection", "thin", "stream", "In", "inc", "again", "rin", "file", "kin", "r", "err", "login", "id", "reader", "din"]}}
{"id1": "16623181", "id2": "411595", "code1": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"srcDir": ["destDirectory", "sourceDir", "srcFile", "rcFile", " srcDirectory", "destDir", "rcDir", "sourceDirectory", " srcFolder", "destFile", " srcFile", "srcDirectory", "sourceFolder", "srcFolder", "rcFolder", "rcDirectory", "sourceFile", "destFolder"], "dstDir": ["dstPath", "dotDir", "dotPath", "dptFile", "DrcDirectory", "dptDIR", "drcPath", "ddestDir", "DstPath", "ddestPath", "dndDirectory", "DstDirectory", "DrcPath", "DrcFile", "dndDir", "dstDIR", "drcDir", "dotFile", "dotDirectory", "ddestFile", "drcDIR", "dndDIR", "DstDir", "dstFile", "dndFile", "dptDir", "DstFile", "drcFile", "ddestDirectory", "drcDirectory", "dptDirectory", "DstDIR", "DrcDir", "DrcDIR", "dstDirectory"], "srcFiles": ["sourceDir", "rcfiles", "srcFile", "rcFiles", "rcFile", "scPoints", "rcDir", "scFiles", "scFile", "sourcePoints", "srcFs", "srcPoints", " srcPoints", "srcfiles", "scFs", " srcFile", "sourcefiles", "sourceFiles", " srcfiles", "sourceFile", " srcFs", "sourceFs"], "f": ["p", "x", "form", " F", "F", "filename", "ref", "flat", "lf", "of", "fp", "fx", "path", "c", "info", "fb", "s", "w", "e", "i", "l", "m", "folder", "bf", "self", "n", "io", "directory", "url", "name", "b", "u", "fd", "files", "fs", "fe", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "fed", "file", "fi", "r", "t", "dir", "sf", "feed", "o", " df", "v", "d"], "srcChannel": ["destConnection", "sourceBuffer", "distGate", "rcChan", "srcGate", "rcchannel", "sourceConnection", "sourceClient", "destChannel", "srcBuffer", "distChan", "sourceChan", "srcchannel", " srcChan", " srcGate", "destContext", "srcContext", "rcGate", "rcClient", " srcchannel", "srcConnection", "sourceChannel", "distChannel", " srcConnection", "rcBuffer", " srcBuffer", " srcContext", "rcConnection", "sourceContext", "srcChan", "distchannel", " srcClient", "sourcechannel", "rcChannel", "srcClient", "destChan", "rcContext"], "dstChannel": ["dscChan", "Drcchannel", "destConnection", "DstBuffer", "ddstchannel", "destchannel", "drcHandler", "dstChan", "DrcBuffer", " destchannel", "dblChannel", " dstConnection", " destChannel", "dscChannel", "ddstChannel", " dstchannel", " destConnection", "DrcChannel", "destChannel", "dstsChannel", "dscButton", "dstButton", "dstConnection", "dstschannel", "drcConnection", "ddrcButton", "dscBuffer", "dblchannel", "drcBuffer", "DstChannel", "drcchannel", "dscchannel", "drcChan", " dstHandler", "dblBuffer", "ddrcChannel", "destHandler", "ddrcChan", "destButton", "dstsHandler", "ddstChan", "Dstchannel", "dstHandler", "drcButton", "dstchannel", "dstsConnection", " destHandler", "ddstButton", "destChan", "dstBuffer", "ddrcchannel", "drcChannel"], "buffer": ["message", "result", "copy", "cache", "position", "out", "bar", "length", "pad", "buff", "bb", "buf", "fb", "seed", "uffer", "border", "image", "FFER", "read", "data", "writer", "loader", "abi", "resource", "binary", "comment", "zero", "limit", "url", "base", "document", "job", "b", "null", "bc", "server", "transfer", "Buffer", "cur", "header", "stack", "size", "queue", "layer", "batch", "block", "iter", "reference", "request", "row", "r", "wave", "feed", "reader", "flush", "bin", "cb", "offset"], "nr": ["uni", "rx", "orr", "result", " NR", "br", "cb", "ni", "rr", "mr", "vr", "pointer", "i", "pos", "nor", "ner", "nm", "nl", "ru", "sr", " sr", "n", "nn", "eno", "num", "adr", "nb", "number", "counter", "wr", "obj", "nu", "rl", "rb", "gr", "cur", "nc", "fr", "rw", "rn", "ng", "nw", "radius", "rf", "lr", "usr", "iter", "sn", " ni", "row", "err", "r", "NR", "ri"]}}
{"id1": "8329093", "id2": "13886238", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" parser", "se", "arse", "info", " assemble", " build", " setup", " discover", " parsing", "process", " scan", "Parser", " explode", " merge", " sniff", " dissect", "patch", " extract", "parser", "replace", " analyse", " serve", "pack", " split", "apply", "handle", " patch", " read"], "event": ["flow", "x", "source", "text", "message", "style", "app", "result", "cache", "instance", "update", "actual", "load", "info", "author", "config", "view", "environment", "this", "e", "input", "image", "vent", "item", "data", "object", "context", "resource", "other", "node", "comment", "ce", "open", "action", "g", "document", "error", "original", "entity", "function", "address", "handler", "element", "stream", "layer", "attribute", "version", "request", "ev", "parent", "response", "entry", "type", "v", "events", "xml", "user", "Event", "content"], "stmt": ["stct", "Stmb", " stmn", "dnt", "dmt", "adql", "Stmd", "stql", "stbl", "rql", " stct", "tmt", "tmn", "spbl", "STmt", "stmd", "admt", "adbl", "tmd", "tbl", "rmt", "adart", " stbl", "STmd", "adpt", "Stmt", "adnt", "Stm", "Stct", " stm", "STmn", "stm", "tm", "rpt", "spmd", "stmn", "STm", "Stpt", "Stbl", "rnt", "stnt", " stmb", "dql", "spart", "admd", "stpt", "tpt", "tct", "stmb", "dpt", "spmt", "start", " start", " stmd", "tmb", " stpt"], "rs": ["relations", "ls", "otes", "ats", "sels", "ris", "cs", "result", "ps", "ts", "lines", "ys", "ars", "rr", "mr", "src", "ds", "vals", "hs", "resources", "RC", "RS", "ws", "sr", "ras", "opens", "odes", "ges", "ros", "ks", "ms", "qs", "hr", "rd", "bs", "res", "stats", "rss", "rc", "Rs", "ins", "acks", "icks", "nas", "rys", "xs", "details", "pr", "vers", "gs", "repl", "runs", "eers", "rt", "ows", "r", "results", "obs", "maps", "events", "rows"], "checksum1": ["checksnum3", "checksummer91", "checksUMOne", " checkssum1", " checkssum3", "checksummOne", "checksums1", " checkssum2", "checkssum91", "checksam100", "checkssum1", "checksumOne", "checksnum61", " checkssumOne", "checksummer0", "checksam1", "checksumsOne", " checkssumOnce", "checksumm2", "checksull1", "checksque0", "checksumi2", "checksum91", "checksumb2", "checksum61", "checksumbOne", "checksum0", "checksnum1", "checkssum3", " checkssum61", "checksUM1", "checksummer2", "checkssum0", "checksumb1", "checksumOnce", "checkssum61", "checksumi1", " checksum0", " checkssum91", " checksum91", " checkssum100", " checksum3", "checksnum0", "checksnum2", "checksam0", "checksullOne", "checksum3", " checksumOnce", "checksumi3", "checkssumOnce", "checksumbOnce", "checksumm1", "checksummer1", " checksumOne", "checksUM2", "checksUM3", "checksque2", "checksull2", "checksumsOnce", "checksums2", "checkssumOne", "checksque1", "checkssum100", "checksam2", "checksque100", " checksum61", "checksull61", "checksnum91", "checksnumOne", "checkssum2", "checksum100", " checksum100", " checkssum0"], "url": ["ls", "match", "org", "message", "text", "buffer", "uri", " URL", "path", "Url", "f", "ball", "page", "link", "l", "conn", "image", "xml", "loc", "data", "blog", "web", "object", "resource", "location", "www", "error", "base", "job", "bel", "b", "server", "URL", "fl", "sl", "address", "api", "Link", "connection", "string", "channel", "stream", "layer", "el", "ll", "ul", "impl", "coll", "html", "file", "pull", "r", "ssl", "ob", "URI", "id", "user", "orb", "content", "http"], "adler32": ["adlr32", "adlr2", "adlor2", " adler16", "adle2", "aclr16", "adle16", "adlor16", " adlr16", "adlr40", " adlr2", "adlr52", "adler52", "adger16", "acler32", " adlr32", "adle32", "adger52", " adler2", " adger16", " adger40", "adder40", "adger32", " adger32", "adlr16", "aclr32", "adlor52", "adle40", "adger40", "adger31", "adler40", "adler16", "adder32", " adler31", " adlr40", "adder31", "acler2", "acler16", "adger2", "adler31", "aclr52", "adlor32", "adler2", "aclr2", "adder16", " adger31", "acler52", "adlr31", " adler40"], "nodes": ["sods", " node", "sodes", "Node", "nods", "tode", "Nubes", "nobs", "snodes", "todes", "Nods", "nents", "snobs", "snode", "Nobs", "Nodes", "nubes", "snubes", "sode", " nobs", " nubes", "tents", "node", "tods", "sents", "Nents"], "checksum2": ["checksha2", "checksha1", "checksums2", "checksub2", " checkssum1", " checkssum82", "checksum82", "checksums1", "checksub0", "checksum0", " checkssum2", "checkssum1", "checksums0", "checksub1", "checksha82", "checkssum82", "checksummer2", "checksummer0", "checkssum2", "checkssum0", "checksha0", " checksum82", "checksummer82", " checksum0", " checkssum0", "checksummer1"]}}
{"id1": "9327525", "id2": "932225", "code1": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"test02_ok": ["test02_ready", "test02tOK", "test2_ok", "test02tok", "test2_good", "test2_ready", "test02tready", "test2_OK", "test02_good", "test02tgood", "test02_OK"], "client": ["p", "contact", "app", "remote", "cloud", "media", "cache", "Client", "session", "c", "config", "tc", "this", "https", "company", "per", "manager", "conn", "project", "socket", "bird", "image", "writer", "con", "service", "resource", "ce", "self", "pc", "pe", "server", "host", "pi", "api", "secure", "container", "connection", "patch", "channel", "queue", "stream", "plugin", "php", "cod", "collection", "request", "cli", "ssl", "google", "http"], "post": ["p", "pre", "form", "create", "the", "copy", "set", "pod", "push", "c", "load", "head", "wp", "pass", "per", "send", "po", "pos", "posted", "build", "install", "process", "object", "builder", "open", "comment", "ip", "next", "add", "server", "zip", "query", "api", "upload", "patch", "dd", "submit", "Post", "test", "put", "request", "t", "feed", "type", "ost", "POST", "posts", "http"], "nameValuePairs": ["nameNameports", "nameValueFars", "nameValueTases", "nameNameparms", "nameValueTats", "nameLineFairs", "nameNameCarms", "nameLineFair", "nameLineTats", "nameLinePats", "nameValueNases", "nameValuesPair", "nameValuepases", "nameValuesFair", "nameValueHarms", "nameValuesPairs", "nameNamePacks", "nameValueForts", "nameValuePair", "nameValueNairs", "nameLineTairs", "nameLineTowers", "nameValuePorts", "nameValuePats", "nameNamePats", "nameValueTairs", "nameNameCairs", "nameValuespases", "nameValueFairs", "nameNameCair", "nameValuePacks", "nameValueFacks", "nameValueCairs", "nameValueLair", "nameValueFowers", "nameNamePars", "nameNameFair", "nameValuepinches", "nameValuesFases", "nameValueLorts", "nameValuePases", "nameValueTars", "nameValuesPases", "nameValueFinches", "nameValueparms", "nameValueCats", "nameValuePinches", "nameValuePayair", "nameValuePayairs", "nameValueLarms", "nameLineFars", "nameLinePars", "nameNameFairs", "nameValueHairs", "nameValueNarms", "nameValueTair", "nameValuePayases", "nameNameParms", "nameValueTarms", "nameValueFair", "nameValueHowers", "nameValuepowers", "nameNamePairs", "nameNamepair", "nameValuepacks", "nameLineParms", "nameValueLairs", "nameValueTowers", "nameNameCowers", "nameValuespars", "nameValueHats", "nameValuepats", "nameValueParms", "nameValueCarms", "nameNamePinches", "nameValuepairs", "nameNamePowers", "nameValuesParms", "nameValueNars", "nameNameTair", "nameNamePorts", "nameValueHair", "nameValuepair", "nameNameFinches", "nameLinePinches", "nameValueCars", "nameValuesparms", "nameValuepars", "nameValueFats", "nameLineFinches", "nameNamepairs", "nameNameFacks", "nameNamePair", "nameValueHars", "nameValueFarms", "nameNameFars", "nameValueports", "nameValuesFairs", "nameValueCair", "nameValueCowers", "nameLineFarms", "nameValuePars", "nameLinePairs", "nameNameTars", "nameValueHinches", "nameLinePair", "nameValueFases", "nameValuesPars", "nameNameTarms", "nameLinePowers", "nameNameFats", "nameValuesFars", "nameValuePayars", "nameLineFowers", "nameLineTair", "nameValuespairs", "nameValuePowers", "nameNameTairs"], "response": ["message", "result", "output", "json", "session", "successful", "environment", "status", "model", "event", "view", "page", "success", "e", "image", "default", "application", "resp", "data", "service", "object", "resource", "reply", "document", "initial", "server", "Response", "api", "body", "index", "onse", "connection", "respond", "ception", "full", "received", "value", "collection", "version", "request", "wave", "error", "report", "http"], "entity": ["ent", "message", "result", "media", "output", "json", "translation", "instance", "environment", "model", "event", "http", "person", "e", "image", "xml", "issue", "data", "agent", "object", "resource", "email", "ce", "metadata", "document", "em", "server", "article", "body", "connection", "element", "office", "value", "file", "collection", "entry", "o", "error", "Entity", "content", "application"], "instream": ["insvalid", "outstream", "incvalid", "inctransform", "outform", "incstream", "outtransform", "INstream", "INStream", " infile", "inputwriter", "inwriter", "inputstream", " inform", "instransform", "inform", "INform", "INfile", "incStream", "insstream", "inputform", " inStream", "invalid", "insStream", " inwriter", "inputStream", "intransform", "outfile", "infile", "outwriter", "outStream", "outvalid", "inStream"], "reader": ["buffer", "result", "out", "inner", "f", "rr", "rar", "ler", "i", "e", "input", "driver", "line", "bird", "read", "data", "writer", "oder", "in", "loader", "resource", "ner", "builder", "director", "ger", "io", "editor", "rer", "server", "body", "worker", "channel", "former", "stream", "handler", "parser", "Reader", "row", "r", "er", "her", "keeper"]}}
{"id1": "20735941", "id2": "4750967", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"getFile": ["openFile", "openResource", "newFile", "newfile", "newResource", "openfile", "createfile", "createFiles", "openFiles", "getFiles", "getResource", "newFiles", "createFile", "getfile", "createResource"], "home": ["bar", "path", "first", "f", "store", "this", "domain", "back", "plus", "family", "root", "owner", "project", " HOME", "default", "build", "folder", "resource", "hub", "location", "www", "directory", "HOME", "up", "class", "base", "name", "log", "search", "server", "host", "h", "house", "Home", "include", "dir", "join", "user", "parent", "library"], "fileName": [" filePath", "resourcePath", "urlName", "filename", "resourceName", "filePath", "filePart", "fileType", "urlname", " fileType", "FilePart", "FilePath", " filePart", " filename", "fileUrl", "fileNum", "remotePath", "fullPath", "fullName", "FileNum", "FileName", "singlename", "resourceUrl", "urlPath", "singleType", " fileNum", "fullname", "Filename", "fullPart", "FileType", "remoteName", "urlNum", "remoteUrl", "singlePath", " fileUrl", "singleName"], "file": ["work", "source", "local", "filename", "buffer", "File", "fp", "current", "output", "table", "path", "uri", "f", "store", "model", "use", "place", "ile", "e", "l", "image", "line", "or", "get", "data", "folder", "object", "resource", "money", "play", "up", "FILE", "be", "class", "base", "name", "log", "job", "it", "fe", "function", "child", "letter", "live", "zip", "connection", "rule", "lock", "plain", "handler", "el", "full", "lib", "part", "feed", "dir", "le", "user", "parent", "type", "db", "run", "http"], "url": ["ls", "source", "org", "uri", "path", "Url", "download", "f", "bb", "page", "il", "i", "l", "ource", "socket", "image", "conn", "loc", "data", "web", "service", "object", "resource", "location", "www", "io", "base", "name", "job", "b", "log", "server", "host", "URL", "rl", "zip", "sl", "api", "address", "string", "rule", "connection", "fr", "ur", "coll", "lr", "el", "impl", "lib", "pull", "r", "feed", "ssl", "ob", "http"], "in": ["source", "as", "init", "into", "inn", "gin", "inner", "c", "ac", "f", "s", "plus", "e", "i", "input", "l", "socket", "inside", "image", "line", "IN", "data", "ini", "resource", "io", "n", "bin", "a", "up", "din", "isin", "b", "is", "ins", "stream", "lin", "In", "again", "pull", "r", "login", "reader", "inc"], "out": ["flow", "source", "init", "copy", "output", "client", "sync", "net", "inner", "this", "ex", "i", "to", "socket", "OUT", "conn", "line", "serv", "IN", "data", "writer", "object", "resource", "io", "up", "base", "b", "null", "ext", "exec", "is", "exp", "Out", "write", "In", "outs", "inc", "again", "err", "o", "plain", "bin", "co"]}}
{"id1": "14188043", "id2": "5049453", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["getHTTPRequest", "getHTTPresult", "openUrlresult", "openHttpMessage", "openNetworkRequest", "openSocketResponse", "openUrlMessage", "openHTTPSource", "closeHttpresult", "openUrlResponse", "openhttpRequest", "openRouteSource", "closeHTTPResponse", "closeHttpMessage", "openhttpResult", "closeHTTPresult", "closeHttpResult", "closeHttpResponse", "openHTTPRequest", "openSocketRequest", "getHttpResult", "openHTTPMessage", "getHTTPResult", "openSocketSource", "openRouteResponse", "openRouteResult", "closeHTTPResult", "openhttpresult", "openttpResponse", "getHTTPResponse", "openHttpResponse", "closeHttpRequest", "openNetworkresult", "openHttpRequest", "openHTTPResult", "openHttpresult", "openSocketResult", "closeHTTPSource", "openttpresult", "openNetworkResult", "closeHttpSource", "openttpMessage", "getHttpRequest", "openttpResult", "getHttpresult", "openRouteRequest", "openNetworkResponse", "openHTTPResponse", "openHTTPresult", "openHttpSource", "closeHTTPMessage", "getHttpResponse", "openhttpResponse", "closeHTTPRequest", "openUrlResult"], "urlPath": ["URLPath", "resourcePath", "urlName", "urlText", "URLpath", "runPath", "httpPath", " urlCase", "resourceName", "filePath", " urlText", "uriPath", "UrlText", " urlpath", "runInfo", "resourceFile", "UrlPath", "fileFile", "URLText", "UrlHome", "uriFile", "UrlCase", " urlHome", "httpCase", " urlPoint", "urlHome", "URLPoint", "uriName", "runpath", "httppath", "Urlpath", "fileName", "lInfo", "urlPoint", "uripath", "filepath", "urlFile", "UrlPoint", "urlpath", "lpath", "resourcepath", "lPath", "urlInfo", " urlInfo", "httpHome", "urlCase"], "retry": ["refri", "retone", "rtry", "retrow", "Retried", "pretri", " retone", "rerying", " retried", "Retrying", "retried", "refried", "rtri", "Retri", " retrying", "refrying", "detrying", "detry", "relone", "rtrow", "rery", "rtried", " retri", "pretrow", "pretried", " rettry", "rettry", "pretry", "relrying", " retrow", "Retry", "reltry", "relry", "retri", "detri", "retrying", "detried", "refry", "reone"], "url": ["source", "org", "relation", "util", "uri", "client", "path", "Url", "c", "f", "config", "page", "link", "l", "conn", "image", "loc", "web", "service", "con", "resource", "proxy", "www", "connect", "base", "log", "lc", "server", "URL", "sl", "li", "string", "channel", "file", "ssl", "entry", "user", "http"], "connection": ["text", "relation", "cache", "uri", "client", "connected", "session", "ion", "c", "f", " Connection", "config", "info", "union", "Connection", "use", "event", "link", "driver", "component", "l", "socket", "conn", "image", "application", "loc", "condition", "con", "object", "proxy", "resource", "close", "communication", "io", "connect", "nn", "database", "character", "b", "lc", "server", "function", "number", "body", "index", "nc", "channel", "handler", "wrapper", "creator", "cli", "response", "user", "section", "error", "co", "context", "http"], "code": ["x", "message", "call", "create", "last", "mode", "ode", "se", "dec", "check", "c", "charge", "state", "content", "success", "level", "ie", "one", "e", "count", "line", "complete", "close", "pri", "age", "ce", "done", "force", "cycle", "expected", "stage", "sec", "reason", "change", "zip", "sc", "grade", "Code", "see", "index", "fe", "cc", "nc", "rc", "size", "codes", "cm", "cause", "score", "go", "desc", "cod", "test", "coord", "version", "orig", "bug", "xx", "key", "response", "id", "type", "zone", "error", "ception", "co", "status", "order", "coded"], "redirect": ["Redirect", "transirect", "transef", "codedirection", " redanch", "refirect", " redition", "transition", " redirection", " redrict", "codedition", "Redrict", "redirection", "redrict", "codedirect", "refrict", "redition", "Redirection", "redanch", "Redanch", "redef", "codedef", "refirection", "refanch", "transirection", " redef"], "result": ["work", "match", "source", "message", "ret", "buffer", "cache", "output", "str", "dict", "continue", "load", "instance", "page", "success", "image", "default", "data", "record", "object", "resource", "comment", "up", "array", "grade", "rc", "Result", "string", "value", "answer", "request", "df", "err", "response", "r", "results", "diff", "entry", "error", "report", "status", "content"]}}
{"id1": "13499897", "id2": "15645004", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"CopyFile": [" CopyFolder", " copyFile", " copyDir", " copyFolder", "CreateFolder", "CopyFolder", "CreateFile", " Copyfile", "Copyfile", " copyfile", "CreateDir", "Createfile", " CopyDir", "CopyDir"], "sourcefile": ["configstream", "destlog", "Sourcefilename", "sourcef", "sourcelog", "Sourcef", "sinfile", "configfile", "configlog", "destFile", "destf", " sourcefilename", "sinFile", "SourceFile", "destfilename", " sourcef", "configFile", " sourceFile", "sourcestream", "sinstream", "sinlog", "sourcefilename", "sourceFile", "deststream", "Sourcefile"], "destfile": [" destfilename", "Destfilename", "destroypath", "srcfile", "tempfilename", "srcFile", "Destpath", "targetfile", "Destfp", "destpath", "srcpath", "tempFile", "targetfilename", " destpath", " deststring", "newfile", "destfp", "targeturl", " destfp", "destroyfile", "deststring", "sourcestring", "destroystream", "buildfile", "destroyfilename", "Desturl", "destFile", "targetpath", "targetFile", "newfp", " desturl", "srcfilename", "tempfile", " destFile", "srcstream", "destfilename", "buildstring", "DestFile", "sourcepath", "newFile", "temppath", "buildFile", "sourcefilename", "buildfilename", "sourceFile", "desturl", "deststream", "tempstream", "Destfile", "newfilename"], "last": ["right", "style", "current", "depth", "se", "length", "path", "first", "empty", "cat", "recent", "event", "use", "ast", "real", "max", "count", "or", "left", "total", "from", "latest", "old", "prev", "later", "core", "next", "base", "code", "nd", "child", "cur", "size", "range", "Last", "full", "value", "route", "part", "key", " Last", "end", "after", "start", "ending", "offset"], "parent": ["p", "text", "source", "filename", "remote", "cache", "current", "port", "ppa", "path", "ac", "home", "point", "root", "pointer", "po", "line", "shared", "loc", "data", "parents", "location", "mac", "ip", "dest", "valid", "and", "next", "url", "base", "name", "pa", "null", "search", "post", "function", "child", "api", "string", "exp", "patch", "ant", "test", "Parent", "file", "temp", "anc", "part", "partial", "key", "id", "unit", "fat", "section", "target", "content"], "f": ["p", "lf", "F", "flat", "ref", "of", "fp", "cf", "c", "s", "fb", "e", "i", "l", "found", "m", "folder", "af", "self", "g", "base", "inf", "b", "fd", "fs", "fe", "j", "h", "fa", "full", "fc", "file", "df", "t", "feed", "dir", "sf", "r", "o", "v", "d"], "srcChannel": ["destConnection", "destchannel", "rcChan", "rcchannel", "sourceConnection", "destClient", "destChannel", "sourceChan", "srcchannel", " srcChan", "rcClient", " srcchannel", "sourceChannel", "srcConnection", " srcConnection", "rcConnection", "srcChan", " srcClient", "sourcechannel", "rcChannel", "srcClient", "destChan"], "dstChannel": ["idstChannel", "DstBuffer", "destchannel", "dstChan", "dsrcButton", "DestChan", "dntBuffer", "destChannel", "dstsChannel", "dsrcChannel", "dsrcChan", "dstButton", "dstschannel", "dstContext", "DestBuffer", "dstsChan", "DstChannel", "destContext", "drcchannel", "drcChan", "idrcChan", "ddestChannel", "dntChannel", "DstChan", "dntContext", "ddestContext", "idrcButton", "idstChan", "dsrcchannel", "destButton", "DestContext", "idstButton", "Dstchannel", "idrcchannel", "drcButton", "DstContext", "destBuffer", "idstchannel", "idrcChannel", "dstchannel", "dntChan", "ddestChan", "destChan", "dstBuffer", "ddestBuffer", "DestChannel", "Destchannel", "drcChannel"]}}
{"id1": "5237257", "id2": "7908169", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"download": ["output", "paste", "load", "update", "archive", "dump", "complete", "process", "release", "open", "url", "log", "transfer", "Download", "zip", "exec", "upload", "run", "submit", "file", "register", " downloading", "pack", "start", "select", "delete", "report"], "fileName": ["fileCode", "resourcePath", "fileDirectory", "resourceName", "fileType", "FileCode", " fileType", " fileDirectory", "FilePath", "fileFolder", "resourceDirectory", " fileFolder", "fileUrl", "FileFolder", "FileName", "resourceUrl", "FileUrl", "FileDirectory", "resourceCode", "FileType", "resourceFolder", "resourceType", " fileCode", " fileUrl"], "filePath": ["resourcePath", " fileFile", "FileLocation", "fileLocation", "resourceName", "filePart", "resourceFile", "resourceLocation", "FilePart", "fileFile", " filePart", "FilePath", "Filepath", "resourcePart", "FileName", "FileFile", " filepath", "filepath", "resourcepath", " fileLocation"], "in": ["work", "x", "source", "as", "init", "copy", "re", "gin", "inn", "sync", "pin", "inner", "ac", "f", "ax", "this", "i", "input", "l", "socket", "inside", "image", "IN", "data", "m", "con", "win", "ini", "resource", "issue", "on", "n", "up", "bin", "a", "url", "io", "name", "isin", "b", "is", "nin", "ins", "cin", "spin", "In", "lin", "inc", "again", "rin", "file", "r", "err", "login", "cgi", "id", "reader", "din"], "out": ["x", "source", "call", "copy", "cache", "output", "sync", "client", "path", "net", "inner", "at", "point", "with", "this", "extra", "view", "ex", "cmd", "one", "to", "socket", "OUT", "conn", "image", "line", "or", "IN", "by", "writer", "on", "n", "io", "up", "url", "base", "name", "log", "null", "outer", "ext", "server", "exec", "obj", "password", "nin", "string", "exp", "prefix", "option", "Out", "write", "In", "outs", "again", "off", "office", "file", "lib", "err", "o", "id", "user", "bin", "error"]}}
{"id1": "10391753", "id2": "15904772", "code1": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"encrypt": ["Encress", " encipher", "decrypt", " encress", "decress", " enccrypt", "Encipher", "decipher", "Enccrypt", "enccrypt", "encipher", "deccrypt", "Encrypt", "encress"], "text": ["source", "message", "buffer", "output", "str", "out", "token", "length", "path", "config", "bytes", "txt", "word", "input", "image", "data", "TEXT", "object", "format", "class", "name", "ext", "Text", "code", "password", "letter", "hex", "string", "connection", "prefix", "crypt", "encrypted", "test", "key", "contract", "plain", "pattern", "content"], "toEncrypt": ["toExecrypted", "toEncert", "toDecrypt", "toAcrypt", "toEncipher", "toDecCrypt", "toExecrypt", "toExecCrypt", " toExecript", "toEncCrypt", "toDecract", " toExecryption", "toCrypted", "toExecryption", "toDecrypted", "toAcert", "toCcrypt", "toCryption", "toEncryption", " toCrypt", "toExecript", "toDiscrypt", " toEncCrypt", "toAcipher", "toDecipher", " toEncrypted", "toEncript", "toCript", "toRecript", "toExeccrypt", "toDiscert", " toEncract", " toDecipher", "toCrypt", "toRecrypt", "toCCrypt", "toDecert", "toDecryption", " toExecrypt", " toEnccrypt", " toCrypted", "toDiscipher", "toEncrypted", "toEnccrypt", "toReccrypt", " toDecrypt", "toDiscract", " toExeccrypt", " toEncript", " toCCrypt", " toCryption", " toEncert", " toDecract", "toEncract", " toEncipher", "toRecryption", " toDecert", " toEncryption", "toAcract"], "hexString": ["hexArray", "shortList", " hexstring", " hexUnit", "shortString", " hexText", "hashstring", "hashList", "textUnit", "hexBuffer", "stringString", " hexBuffer", "textString", "stringstring", "indexstring", "stringUnit", "hexList", "hashBuffer", "hexstring", " hexList", "hexText", "hashText", "shortArray", "indexString", "textArray", "textstring", "stringArray", "hexUnit", "indexText", "shortBuffer", "hashString", " hexArray", "hashArray", "indexArray"], "dig": ["est", "dim", "del", "alg", "im", "dec", "push", "mod", "rand", " dec", "hash", "lab", "grab", "driver", "de", " comb", " Dig", "or", "get", "build", " mod", "destruct", "find", "and", "rob", "grad", "log", "define", "add", "du", "mix", "um", "gen", "cr", "fe", "rep", "fin", "hex", "neg", "prep", "exp", "div", "comb", "dd", "enc", "ng", "wrap", "cd", "test", "cod", "loop", "pro", "ssl", "sign", "her", "diff", "Dig", "pm", "ig", "db", "d", "draw", "dc"], "pw": [" pwa", "pws", "cws", " pye", "cw", "ppaw", "praw", "Pow", "paw", "pW", "lpow", "lpw", "ppwa", "pye", "ppye", " pW", "pwa", " pow", " pws", " paw", "lpW", " pwh", "prye", "cW", "ppw", "cwh", "prwa", "Pwh", "PW", "pwd", " pwd", "pow", "prw", "Pw", "pwh", "Pwd", "lpwd", "Pws"], "i": ["p", "x", "uri", "length", "z", "c", "ai", "f", "gi", "ii", "ix", "w", "ei", "e", "d", "l", "I", "k", "ci", "data", "m", "ini", "in", "chi", "ip", "n", "bi", "io", "a", "si", "u", "b", "it", "lc", "ui", "pi", "oi", "j", "index", "li", "h", "hi", "mi", "di", "qi", "y", "xi", "t", "key", "r", "slice", "id", "o", "end", "mu", "v", "start", "ri", "ti", "phi"], "digest": ["Digester", "labester", " digesting", "DigEST", "hashest", "debugested", "digEST", "digested", " digests", "hashested", "codester", "hashester", "codests", "labests", "signested", " digestamp", "delEST", "delestamp", "signEST", "diggest", "delest", "digests", " digEST", "signester", "Digest", "debugester", " diggest", "labesting", "Diggest", "debugest", "Digested", " digested", "codesting", "digester", "digestamp", "debuggest", "delester", "digesting", "hashEST", " digester", "codest", "signest", "Digestamp", "labest"], "digestLength": ["diffestLength", "digesterLoop", "diffesterLength", "diffesterType", "DigesterStr", "digestationLength", "digusterLine", "DigesterLine", "DigestLength", "diffestlength", "digestLine", "digesterLength", "digstLoop", "digstType", "digestType", "digestlength", "digesterLen", "diffesterLoop", "digestationLoop", "digestationlength", "DigesterLength", "digesterLine", "digusterStr", "digESTLine", "digesterlength", "digESTStr", "digesterType", "digESTLength", "digestLen", "digestStr", "digESTLen", "digesterStr", "DigestLen", "DigestLine", "diffestLoop", "DigestStr", "DigesterLen", "digestationType", "digusterLen", "diffesterlength", "digstlength", "digusterLength", "digestLoop", "diffestType", "digstLength"]}}
{"id1": "16388708", "id2": "12883117", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "8430178", "id2": "9727056", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFiles", "copyfile", "CopyFile", "copyFiles", "transferfile", "CopyPath", "transferFile", " copyPath", "copyPath", "transferPath", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "source_name": [" source_path", "sourceCalias", "Source_file", " source_names", "sourceNname", " source_key", "source_path", "src_name", " source_Name", "Source_data", "source_type", "sourceCname", "source_key", "Source_name", "src_size", "source_uri", "sourceNalias", "src_type", "src_uri", "source_alias", "sourceNfile", "source_size", "source_data", "sourceCtype", "sourceNtype", "source_names", "sourceCfile", "source_Name", "src_file", "src_alias"], "dest_name": [" dest_word", "dest_path", " destination_info", "dest_named", "Dest_id", "destFilename", " dest_file", "destRdefinition", " dest_named", " destination_path", "Dest_Name", " destinationFresource", " dest_label", "destappnames", "destPmodel", "source_path", "dest_word", "destflabel", "destJword", "destPname", " dest_definition", "destappname", "dest_names", "dest_resource", "destfname", " destinationFinfo", "destPpath", "target_names", "destFinfo", " destinationFpath", "destPtype", "dest_id", "destPName", "destPword", " dest_Name", "dest_file", "dest_model", " dest_names", "dest_none", "destRName", "destPnames", "destFilenamed", "Dest_path", " destination_resource", "destJname", "destRname", "destFresource", "target_type", "destRpath", " destination_name", "destFilelabel", "dest_definition", "source_names", "destJnames", " dest_path", "destFpath", "target_name", "dest_label", "Dest_name", "destFname", "source_Name", "dest_info", "destapptype", "destappmodel", "destFilefile", " dest_type", " dest_none", "destJName", "dest_type", "dest_Name", "destffile", " destinationFname", "target_model", "destfnamed"], "source_file": [" source_files", "source_File", "src_files", "src_name", "source_line", "source__base", "source_base", "source_files", "sourceffile", " source_cache", "source__name", "source__file", "source_class", "source__class", " source_url", "sourcefFile", "ource_file", "source_stream", " source_base", "src_stream", "ource_line", "sourcefname", " source_File", "ource_files", "source_url", "ource_name", " source_class", "src_file", "sourcefurl", "source_cache"], "destination_file": ["destination2file", "destation_file", "destination_function", "destination_name", "destention_name", "destination_files", "destation_name", "destination_path", "destinate_page", "destention4file", "destinate_base", "destation_function", "destention4name", "destination_page", "destination2name", "destention_source", "destinate_files", "destation_folder", "destention_file", "destention_path", "destinationablebase", "destination_folder", "destination2source", "destention4path", "destination4name", "destination_source", "destation_files", "destination4file", "destinate_file", "destinationablefile", "destinationablepage", "destination4source", "destention4source", "destinationablefiles", "destination_base", "destination4path", "destination2path"], "source": ["local", "remote", "result", "copy", "cache", "uri", "output", "client", "current", "inner", "load", "config", "ite", "view", "master", "slave", "via", "ources", "input", "ource", "src", "image", "single", "SOURCE", "resources", "get", "Source", "service", "object", "resource", "proxy", "from", "open", "storage", "dest", "core", "class", "name", "search", "spec", "server", "secure", "index", "connection", "scope", "stream", "ize", "reference", "file", "slice", "site", "reader", "unit", "diff", "parent", "start", "target"], "destination": ["Destribution", "coordination", "descension", "descinator", "destinated", "validinated", "destension", "foreigninator", "descination", "constinator", "testribution", "Destension", "constribution", "constining", "validinator", " destining", "Destinated", "coordinator", "testinated", "coordension", "dependination", "identina", "identribution", "Destina", "destinate", "validinate", "foreignination", "foreigninate", "variinated", "foreigninated", "destina", "targetination", "testinator", "coordinated", " destina", " destinator", "testination", " destinated", "Destining", "Destination", "targetinator", "dependinator", "constination", "destining", "destinator", "dependinated", "identinated", "variinator", " destribution", "identination", "targetinate", "destribution", "validination", "Destinator", "variinate", "variination", "dependinate", "descinated", "targetinated"], "buffer": ["sequence", "text", "cache", "memory", "buff", "buf", "timeout", "input", "uffer", "padding", "image", "writer", "binary", "limit", "window", "pool", "transfer", "Buffer", "header", "channel", "queue", "batch", "block", "iter", "temp", "reader", "flush", "bin"], "bytes_read": ["Bytes_Read", "Bytes_read", "bytesUnread", "bytesUnRead", "Bytes_set", "bytesUnset", "bytesUnfound", "bytes_set", "bytes_Read", "Bytes_found", "bytes_found"], "in": ["p", "as", "rec", "re", "current", "inn", "out", "token", "path", "session", "inner", "f", "s", "input", "l", "serv", "image", "line", "val", "read", "IN", "data", "get", "ini", "con", "resource", "or", "n", "a", "url", "log", "din", "b", "is", "fe", "nin", "min", "container", "ins", "h", "connection", "lock", "stream", "In", "inc", "again", "file", "temp", "request", "r", "ssl", "login", "id", "reader", "bin", "doc"], "response": ["text", "sequence", "message", "result", "su", "re", "output", "uri", "json", "dict", "question", "reset", "update", "status", "model", "view", "success", "offer", "image", "line", "application", "resp", "data", "example", "object", "location", "resource", "description", "next", "reason", "server", "Response", "res", "body", "api", "onse", "string", "header", "respond", "true", "respons", "received", "value", "version", "answer", "request", "r", "feed", "error", "report", "reply"], "parentdir": ["parentDir", "parentfile", "Parentdirectory", " parentDir", "rootdirectory", "rootfile", " parentlib", " parentfile", "partfile", "homediff", "Parentdict", " parentdict", "parentsDir", "parentdict", "parentdirectory", "homefile", "rootlib", " parentdiff", " parentdirectory", "hostdirectory", "hostdir", "parentsdir", "partlib", "parentsfile", "parentdiff", "homedir", "parentlib", "parentsdiff", "homeDir", "partdirectory", "hostdict", "Parentdir", "rootdir", "partdir"]}}
{"id1": "3801655", "id2": "13333160", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"helper": ["workmer", "harper", "heller", "Helper", "helppherd", "harpherd", "Heler", "helHelper", "workp", "heler", "helmer", "helpper", "shmer", "scheHelper", "workper", "help", "schepherd", "Helmer", "scheper", "helpler", "shp", "harler", "worker", "shper", "scheler", "helpHelper", "helpherd", "Help", "sher", "harHelper"], "dataset": ["metasset", "datastets", "datraset", " Dataset", "datasert", "datasheet", "datacet", "datacheet", "metaset", " DatASet", "DatASeter", "datAsets", "datassheet", "metassET", "datassets", "datasset", " DatASheet", " Datasets", "datasET", "DatASets", "datasets", "datrasets", "Dataseter", "datapsET", "datAset", " DatASET", "datacET", "datAsET", "DatASET", "dataseter", "datrasET", "datAsheet", "datASheet", "DatASet", "DatasET", "datastet", "datastET", "datapset", "datassert", "Dataset", " Datasheet", "datASeter", "metassert", "datassET", "datasteter", "metasert", "Datasets", "datASets", "datapsheet", "metasET", "metasheet", "datapsert", "metassheet", "datASet", "datASET", " DatasET", "datraseter", "datacert", " DatASets"], "zip": ["p", "source", "flat", "copy", "se", "out", "parse", "git", "z", "py", "bag", "f", "system", "archive", "gz", "java", "data", "folder", "service", "binary", "pdf", "ip", "io", "directory", "window", "code", "split", "sl", "secure", "lock", "handler", "wrap", "plugin", "tar", "file", "loop", "bug", "ssl", "pack", "dir", "pipe", "sea", "zone", "slice", "xml", "pkg", "jar", "Zip"], "entries": ["contents", "intlements", "entrees", " entlines", " entlements", "entryries", "contry", "inflements", "infities", "entlections", "deents", "entsrees", "ENTrants", "ntrys", "entrylements", "iterents", "ENTlections", "entsrants", "infrants", "itry", "entents", "contries", "itrys", "entities", "inflections", "entrys", "deries", "entslections", "entrants", "infrees", "itries", "itents", "inflines", "entryents", "entsries", "iterries", "contrys", "ENTrees", "intlines", "iterlements", " entities", "ENTries", "ntents", "ntry", "intries", "ntries", "entlements", "entlines", "infries", "intities", "delements"], "performance": ["work", " output", "util", "units", "union", "its", " writers", "slave", "rank", " units", " Unit", "runner", "it", "exec", "book", "ui", " u", "each", " unit", " Units", "stats", " ratio", "ul", " group", " split", "Unit", "U", " suite", "unit", " result"], "index": ["x", "position", "depth", "length", "path", "head", "page", "level", "i", "pos", "count", "limit", "name", "num", "Index", "number", "write", "iter", "value", "key", "id", "unit", "type", "offset", "order"], "entry": ["style", "result", "uri", "se", "parse", "ry", "cell", "inner", "Entry", "info", "archive", "e", "ie", "nt", "input", "cel", "or", "install", "data", "record", "in", "service", "folder", "export", "si", "pe", "it", "server", "add", "lc", "obj", "post", "child", "connection", "stream", "element", "write", "office", "file", "route", "row", "r", "key", "feed", "her", "part", "section", "xml", "pattern"], "temp": ["p", "local", "flat", "copy", "cache", "output", "table", "out", "path", "session", "clean", "empty", "emp", "config", "f", "tc", "store", "archive", "w", "porary", "txt", "input", "single", "cel", "data", "folder", "tem", "binary", "Temp", "stable", "storage", "dest", "directory", "valid", "original", "io", "tmp", "base", "fake", " temporary", "thread", "lock", "wrap", "full", "test", "iter", "office", "file", "part", "partial", "template", "layout", "pipe", "ctx", "parent", "context", "http"], "writer": ["wer", "sw", "writers", "output", "out", "wire", "inner", "author", "written", "w", "driver", "ler", "writing", "per", "war", "manager", "or", "riter", "loader", "builder", "ws", "Writer", "io", "editor", "log", "outer", "server", "player", "wr", "worker", "holder", "rw", "handler", "stream", "layer", "write", "wrapper", "element", "iter", "file", "r", "er", "wave", "key", "feed", "engine"], "reader": ["reading", "ry", "inner", "f", "ter", "rr", "rar", "ler", "per", "i", "input", "driver", "upper", "or", "loader", "oder", "ner", "builder", "io", "editor", "rer", "server", "worker", "handler", "stream", "wrapper", "write", "element", "Reader", "iter", "file", "ser", "er", "r", "feed", "iterator", "ri", "http"], "buffer": ["sequence", "source", "message", "position", "result", "table", "length", "memory", "buff", "buf", "bytes", "seed", "input", "uffer", "data", "resource", "binary", "limit", "document", "character", "device", "initial", "null", "server", "capacity", "transfer", "address", "Buffer", "header", "channel", "size", "queue", "layer", "write", "batch", "reference", "iter", "row", "wave", "feed", "slice", "flush", "offset"], "read": ["work", "text", "ride", "x", "seek", "create", "copy", "current", "se", "Read", "reading", "parse", "length", "check", "sync", "available", "load", "download", "config", "use", "view", "pass", "READ", "input", "send", "skip", "max", "count", "k", "sleep", "default", "process", "build", "data", "ind", "readable", "close", "open", "ad", "play", "old", "find", "print", "g", "connect", "next", "add", "allow", "report", "book", "exec", "reads", "child", "eval", "size", "write", "raw", "iter", "wait", "save", "feed", "id", "end", "type", "get", "start", "select", "fill", "run"], "outfile": ["outf", " outstream", "outstream", "outFile", "Outfile", "outline", "Outf", "againline", "Outdir", " outf", " outline", "inline", "outdata", "Outstream", " outfilename", "logdata", "instream", "inf", " outFile", "outdir", "logfilename", "againfile", "Outline", "outfilename", "logFile", "inFile", "indata", "logfile", "infile", " outdata", "againstream", "againdir", "indir", "infilename"], "line": ["text", "column", "lf", "style", "look", "Line", "lines", "str", "sync", "parse", "cell", "frame", "page", "pass", "link", "word", "l", "cle", "item", "inline", "val", "data", "object", "strip", "comment", "ip", "on", "url", "job", "log", "name", "band", "code", "sel", "split", "letter", "side", "string", "header", "LINE", "el", "lin", "range", "filter", "block", "ine", "file", "row", "end", "le", "type", "section", "error", "status"], "parser": ["p", "lp", "arser", "parse", "system", "cher", "driver", "processor", "per", "ler", "manager", "data", "loader", "oder", "Parser", "umper", "builder", "class", "server", "params", "angler", "pool", "book", "function", "string", "worker", "par", "handler", "plugin", "wrapper", "plan", "test", "r", "er", "type", "xml", "pattern"], "list": ["p", "lp", "match", "right", "group", "result", "LIST", "set", "table", "out", "lists", "all", "info", "l", "val", "get", "data", "map", "left", "other", "and", "base", "array", "pool", "li", "best", "chain", "plan", "filter", "test", "collection", "parent", "part", "r", "er", "join", "type", "v", "member", "listed", "can"], "rule": ["match", "group", "rules", "style", "table", "str", "parse", "dict", "field", "model", "event", "per", "ule", "tree", "val", "Rule", "item", "data", "service", "record", "class", "base", "pe", "rl", "function", "li", "header", "layer", "lr", "range", "ul", "plugin", "ee", "row", "r", "er", "rate", "ri", "rol"], "measure": ["feasure", "measuring", "speasure", "speasuring", "Measure", "measured", "measures", "feasuring", "speasures", "Measuring", "feasures", "feasured", "speasured", "Measured", "Measures"]}}
{"id1": "9449064", "id2": "17193692", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 0, "substitutes": {"readExp": ["writeexp", "loadEx", "loadExpl", " readExpl", "writeExt", "readEXP", "ReadExp", "readEx", "ReadEXP", " readEx", "readExt", "readExpl", "Readexp", "loadEXP", "loadExp", "writeEx", "ReadExpl", " readexp", "readexp", "loadexp", " readEXP", "writeExpl", " readExt", "loadExt"], "writeExp": ["writeexp", "WriteExp", "WriteCom", " writeExpl", " writeEx", "writingCom", "writeExt", "writeCom", "readEx", " writeexp", "WriteEx", "readExt", "writingexp", "WriteExpl", "readExpl", "writeEx", "readexp", "writeExpl", "writingEx", " writeCom", "Writeexp", "writingExp", " writeExt", "WriteExt"], "expFile": ["expSourceFile", "ExpString", "xpDir", " experimentFile", "EXPString", "xpString", "expLine", "expString", "xpFiles", "expressLine", "EXPPlace", " experimentLine", "ExpFile", "ExpLine", "EXPSourceFile", "expressDir", " experimentPlace", "expfile", "expFiles", "ExpSourceFile", "expPlace", "xpFile", "expressFile", "xpPlace", "ExpDir", "EXPFile", " expLine", "EXPLine", "expDir", "Expfile", " expFiles", "expressfile", "EXPDir", "expressSourceFile", "expressPlace", "EXPfile", " experimentFiles", "xpfile", "ExpPlace", " expPlace", " expSourceFile", " expDir", "xpLine"], "exp": ["p", "x", "form", "app", "str", " expansion", "push", "feat", "f", "expl", " exam", "model", "pl", "plus", " experiment", "Exp", "i", "dj", "expr", "iz", "project", "inst", "serv", "nz", "example", "act", "asm", "host", "xp", "inf", "lc", " expand", "ext", "EXP", "obj", "spec", "fe", "sc", "zip", "rep", "query", "ef", "express", "imp", "div", "scope", "ng", "jp", "pr", "acc", "test", "vec", " expanded", "prov"], "fi": ["ani", "lli", "fp", "cf", "py", "ni", "fb", "ii", "info", "Fi", "i", "ci", "yi", "abi", "ini", "wi", "afi", "fy", "bi", "flo", "si", "sci", "fe", "pi", "li", "ifi", "isi", "ji", "ifa", "fa", "ffe", "qi", "fc", "eni", "FI", "xi", "sf", "osi", "zi"], "oi": ["ahi", "shi", "oxy", "ani", "odi", "ogi", "lli", "asi", "obb", "ni", "omi", "ai", "eu", "avi", "ii", "ori", "i", "ci", "abi", "ini", "cci", "oa", "io", "bi", "flo", "si", "obi", "ui", "ki", "ji", "li", "isi", "oni", "uci", "di", "oid", "qi", "agi", "edi", "oci", "eni", "eye", "ilo", "osi", "ti", "ski", "ois", "ofi"], "jf": ["ujf", "jjcf", "appcf", "jfe", "Jf", "djfm", " jp", " jfp", "pf", "xfp", " jfr", "jjfx", "ztf", "djf", "Jb", "jpf", "Jfe", "ffs", "jarfr", " jfe", "jfx", "xtf", "pb", "ff", "JF", "jjfm", "appf", "jtf", "Jcf", " jtf", "jarf", "ujfs", "jb", "pfr", " jb", "jF", "xcf", "jjf", " jcf", "fe", " je", " jfm", "jcf", "jarp", "je", "zfp", "jpfx", "djfx", " jfx", " jfs", "zcf", "zf", "jp", "djcf", "uje", "jarb", "ffp", "jfp", "appfx", "pp", "ujfp", "jfs", "Jfx", "jfm", "jpcf", " jF", "jpb", "appfe", "xf", "jfr", "jpF"], "sp": ["p", "tp", "app", "sw", "sb", "ps", "fp", "so", "se", "mp", "cf", "ss", "str", "py", "s", "page", "pl", "wp", "serv", "inst", "bp", "amp", "service", "vp", "ep", "gp", "sup", "si", "sm", "spec", "sci", "SP", "sc", "fe", "sl", "esp", "ch", "Sp", "sk", "scope", "imp", "cp", "jp", "pr", "sh", "ap", "html", "space", "bsp", "spe", "pp", "op", "sf", "sv", "ctx", "js", "osp"], "e": ["x", "ent", "se", "event", "w", "ie", "exc", "et", "ep", "ce", "ec", "pe", "ext", "fe", "ef", "ee", "el", "ae", "en", "es", "ev", "t", "ctx", "v", "events", "ception", "Event"], "fo": ["vo", "tto", "wo", "ho", "so", "ato", "yo", " lo", "py", "ooo", "lo", "f", "info", "bo", "po", "ko", "ph", "obo", "la", "FO", "io", "foo", "flo", "os", "obj", "ico", "fe", "zo", "fa", "olo", "mo", "oooo", "co", "ao", "osa", "o", "jo"], "oo": ["goo", "wo", "so", "ooo", "lo", "aco", "bo", "po", "ko", "va", "oda", "oh", "oe", "argo", "obo", "OO", "FO", "la", "io", "foo", "flo", "oa", "bean", "os", "ou", "ollo", "ico", "oto", "cro", "loo", "oid", "oos", "olo", "mo", "obe", "qa", "elo", "oooo", "ox", "ao", "ilo", "osa", "que", "o", "co"], "ex": ["x", " exc", "su", "re", "Ex", "se", "ax", "expl", "lex", "com", "event", "ix", " Ex", "js", "exc", "Exc", "tx", "six", "ic", "con", "aux", "act", "class", "null", "ext", "obj", "res", "nex", "EX", "exit", "cl", "fail", "pex", "used", "ass", "rex", "def", "es", "err", "ignore", "ct", "sex", "Exception", "tex", "inc", "error", "ception", "except"]}}
{"id1": "14773782", "id2": "13333160", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPEGWasters", " testJPEGratter", " testJPEGWast", " testJPPGrast", " testJPPGrasters", " testJPEGraster", " testJPEGRatter", " testJPPGratter", " testJPPGRast", " testJPEGWaster", " testJPEGRasters", " testJPPGraster", " testJPPGRatter", " testJPEGRotaster", " testJPEGRotast", " testJPEGRotatter", " testJPEGWatter", " testJPEGrasters", " testJPEGRast", " testJPPGRaster", " testJPPGRasters", " testJPEGRotasters", " testJPEGrast"], "IOException": ["OSception", " IOception", "IOception", "IPError", "IPException", "OSError", "IOError", " IOError", "OSException", "IPception"], "start": ["pre", "source", "init", "style", "Start", "set", "length", "first", "load", "shift", "starting", "date", "info", "f", "use", "pos", "data", "left", "in", "from", "started", "speed", "base", "stage", "min", "time", "delay", "size", "scale", "sum", "ish", "step", "art", "end", "id", "diff", "get", "offset", "order"], "i": ["p", "x", "uni", "inner", "c", "ni", "f", "ai", "info", "ii", "gi", "ix", "e", "ie", "l", "I", "image", "ci", "yi", "abi", "m", "ini", "multi", "ip", "iu", "io", "bi", "si", "u", "b", "ui", "pi", "oi", "li", "index", "j", "hi", "mi", "di", "qi", "eni", "xi", "fi", "key", "slice", "id", "zi", "v", "ri", "ti", "phi"], "url": ["ls", "source", "org", "ref", "filename", "uri", "path", "album", "Url", "download", "f", "config", "fb", "page", "l", "src", "image", "data", "web", "in", "location", "resource", "hub", "img", "www", "base", "name", "URL", "sl", "address", "string", "connection", "channel", "ur", "file", "route", "href", "feed", "id", "http"], "istream": ["istep", "isream", "instead", "irstore", "irstound", "iststream", "ISTep", "isep", "istREAM", "istagram", "isead", "istsstream", "ISTstream", "istound", "istsore", "isteream", "ISTream", "stagram", "isterib", "irstream", "istsound", "stead", "ishound", "ISTrib", "istsrib", "instream", "instep", "ishREAM", "istestream", "ishore", "stream", "istsep", "istsream", "istead", "istsREAM", "ishream", "step", "istrib", "isteep", "istore", "instagram", "isagram", "irstREAM"], "dec": ["rec", "ode", "out", "Dec", "c", " decode", "s", "draw", " Dec", "deg", "dig", "de", " DEC", "func", "data", "des", "oder", "da", "decl", "director", "ec", "img", "valid", "next", "der", "sec", "code", "neg", "exp", "div", "fr", "enc", "DEC", "desc", "ra", "vec", "r", "dir", "rev", "inc", "doc", "cam", "dc"], "raster": [" roder", "hatter", "Rap", "Raster", "roder", " rap", "rap", "eratter", "eroder", "Ratter", "arascal", "rascal", "rasters", "araster", "arasters", "haster", "hasters", "erasters", "Roder", "ratter", " rasters", " ratter", " rascal", "aroder", "eraster", "Rascal", "Rasters", "hap"], "width": ["flow", "x", "p", "dim", "work", "wn", "style", "shape", "Width", "widget", "length", "z", "frame", "f", "wd", "page", "w", "area", "image", "west", "lon", "left", "duration", "age", "img", "n", "gender", "wa", "window", "fw", "min", "h", "size", "ize", "scale", "write", "en", "full", "weight", "wm", "value", "density", "wb", "layout", "d"], "height": ["th", "work", "x", "dim", "crop", "shape", "depth", "length", "inches", "pad", "head", "w", "max", "angle", "han", "k", "padding", "build", "img", "window", "v", "deep", "rh", "h", "dy", "size", "thin", "hd", "stroke", "y", "density", "ady", "right", "d", "rows", "Height", "volume"], "stop": ["Stop", "cut", "shape", "summary", "output", "set", "check", "page", "hop", "trip", "keep", "rest", "skip", "drop", "sleep", "pop", "comment", "zero", "speed", "limit", "clip", "b", "change", "number", "address", "delay", "exit", "block", "wait", "sort", "pause", "save", "step", "snap", "sign", "remove", "spot", "end", "roll", "fill", "hide", "ops"]}}
{"id1": "9796161", "id2": "6008635", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"getMD5": ["getmd4", "getmd512", "getmdHash", "getHTML5", "getMD4", " getMDHash", "getHTML512", "getSHAHash", "getSHA4", "getSHA512", " getSHA4", "getHTMLHash", " getSHAHash", " getSHA5", "getMDHash", "getmd5", "getMD512", "getHTML4", " getMD512", " getSHA512", "getSHA5", " getMD4"], "s": ["p", "ls", "source", "tests", "parts", " fails", "cs", "sb", "ps", "ts", "ss", "str", "lines", "sync", "ends", "styles", "c", "ips", "f", "its", "als", "sym", "bytes", "e", "i", "input", "l", "services", "ds", "data", "in", "strings", "rs", "ws", "self", "n", "g", "a", "si", "ses", "ms", "b", "os", "is", "ates", "bs", "string", "scripts", "gs", "ings", " ads", "sets", "ns", "ows", "es", "abs", "ssl", "comments", "S", "v", "js"], "m": ["p", "me", "mand", "hm", "mut", "md", "im", "mm", "c", "f", "mr", "e", "i", "M", "dm", "l", "manager", "fm", "nm", "module", "mac", "em", "v", "rm", "sm", "ms", "vm", "um", "man", "gm", "tm", "h", "om", "machine", "mi", "bm", "arm", "cm", "am", "wm", "mc", "t", "mu", "ym", "pm", "d"]}}
{"id1": "7118860", "id2": "19667000", "code1": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"getEncoding": ["getEnryption", "getEndryption", " getencoded", "getEncryption", " getEncryption", "getEncoded", "getencoder", "getEnoder", "getencoded", " getEncoder", "getEndoded", "getEndoding", " getencoder", " getencryption", " getEncoded", "getEncoder", "getencryption", "getencoding", "getEnoding", "getEnoded", "getEndoder", " getencoding"], "reader": ["source", "right", "result", "buffer", "copy", "client", "reading", "parse", "ry", "inner", "load", "info", "rr", "seed", "driver", "per", "i", "rar", "input", "ler", "ri", "pointer", "read", "data", "writer", "oder", "loader", "in", "resource", "builder", "ner", "director", "io", "editor", "url", "rer", "server", "container", "worker", "handler", "stream", "parser", "Reader", "iter", "file", "row", "r", "er", "feed", "parent", "error", "library", "context"], "encoding": ["enode", "enhoding", "Encging", "installcel", "extoding", "enhode", "incoding", "execoded", "Encoding", "engoded", "encoded", "exploding", "enryption", "encode", "encryption", "Encasing", "enging", "incode", "encetting", "expletting", "enhryption", "encoder", "Encoded", "extging", "Encryption", "engryption", "execoding", "installasing", "enccel", " encryption", "engoder", "enhoded", "enoded", "incryption", "extoded", " encetting", " enccel", "installoding", "enoding", "execoder", " encosing", "enosing", "explcel", "enoder", "explasing", "incoder", "engosing", "enhoder", "extoder", "encging", "execode", " encoder", " encasing", "installetting", "engasing", "encosing", "engoding", " encoded", "enasing", "Encoder", "encasing"], "connection": ["method", "relation", "position", "uri", "client", "connected", "session", "c", "config", "system", "Connection", "link", "conn", "application", "condition", "writer", "con", "service", "resource", "open", "communication", "io", "directory", "connect", "document", "url", "character", "database", "server", "function", "body", "index", "container", "channel", "handler", "wrapper", "creator", "response", "section", "context", "http"], "header": ["message", "column", "group", "buffer", "table", "json", "Header", "dict", "first", "head", "page", "event", "title", "data", "writer", "map", "record", "heading", "metadata", "document", "url", "server", "host", "body", "index", "container", "dr", "h", "channel", "handler", "layer", "filter", "file", "headers", "row", "key", "response", "er", "section", "content"], "entry": ["match", "ent", "result", "str", "se", "parse", "translation", "cell", "ry", "field", "inner", "Entry", "info", "page", "e", "ie", "owner", "enter", "or", "data", "record", "expected", "next", "array", "pe", "add", "it", "ge", "entity", "letter", "term", "index", "string", "exp", "element", "auto", "inc", "value", "file", "row", "key", "feed", "her", "member", "section", "error", "application"], "item": ["text", "source", "app", "uri", "str", "bar", "instance", "info", "hop", "word", "area", "image", "val", "atom", "data", "anything", "or", "object", "other", "ip", "url", "base", "name", "character", "it", "server", "article", "sel", "letter", "Item", "container", "li", "string", "om", "element", "layer", "coll", "value", "file", "attribute", "key", "r", "id", "items", "ct", "type", "unit", "section", "member", "content"], "line": ["text", "source", "message", "column", "lf", "style", "look", "Line", "lines", "str", "sync", "parse", "cell", "lo", "load", "frame", "point", "page", "pass", "link", "word", "l", "single", "inline", "or", "data", "object", "strip", "comment", "ip", "shell", "url", "character", "name", "base", "no", "pe", "lc", "log", "ge", "code", "sl", "letter", "string", "rule", "LINE", "el", "lin", "write", "cl", "layer", "block", "value", "file", "part", "row", "key", "non", "end", "le", "user", "unit", "section", "id", "content"]}}
{"id1": "88047", "id2": "812803", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "6009527", "id2": "647224", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadInstment", "doFinishloadAttments", "doFinishloadAttachachment", "doFinishLoadAttachachment", "doFinishLoadAttachments", "doFinishLoadInstortion", "doFinishLoadAssortion", "doFinishLoadAssachment", "doFinishLoadAssments", "doFinishLoadInstachment", "doFinishloadAttachment", "doFinishLoadAttments", "doFinishLoadInstments", "doFinishloadAttortion", "doFinishloadAttachments", "doFinishLoadAttachortion", "doFinishloadAttment", "doFinishLoadAssment", "doFinishloadAttachortion", "doFinishLoadAttortion", "doFinishLoadAttment"], "attachmentId": ["attachmentInfo", "attplementationID", "attimagePath", "attlementID", "ttociationId", "attociationID", "AttachmentId", "attachmentid", "adociationId", "attentionId", "ttachmentid", "ttociationid", "attociationid", "attimageInfo", "AttachmentID", "Attachmentid", "attlementType", "adociationID", "attociationPath", "attentionid", "adociationPath", "attentionID", "attlementid", "ttachmentId", "attplementationId", "ttociationID", "attimageID", "attachmentID", "ttachmentID", "attlementId", "attachmentPath", "attachmentType", "attociationId", "adachmentId", "attentionPath", "adachmentInfo", "attimageId", "attplementationid", "adachmentID", "AttachmentType", "attentionType", "attociationInfo", "adociationInfo", "attentionInfo", "adachmentPath"], "attachment": ["attachachment", "attachention", " adaptention", "appention", " adaptociation", "adached", "assached", "instruction", "assment", "adachment", " attociation", "instment", "attociation", "appruction", " adaptment", "attruction", "appment", "assachment", " attment", "assention", " attention", "attached", "association", "attment", "attention", "attachruction", "instention", "attachached", "appachment", "instachment", " adaptachment", "adention", "adment"], "attachmentUri": ["attmentIri", "attachmentIris", "attachmentEti", "attachedAri", "attachmentSuuri", "attachmentAuri", "attmentUris", "attachedUuri", "attmentIuri", "attachedUti", "attachedURI", "attachedAti", "attmentUURI", "attachedARI", "attmentUuri", "attachmentERI", "attachedUri", "attachmentUURI", "attachmentARI", "attachmentSuri", "attachmentSuRI", "attachedAuri", "attachmentIri", "attachmentIuri", "attachmentUris", "attmentIris", "attmentIURI", "attachmentEri", "attachmentEuri", "attachmentCuuri", "attachmentUuri", "attachmentSuti", "attachmentAri", "attachmentURI", "attachmentSuris", "attachmentCuri", "attachmentSuURI", "attachmentIURI", "attachmentUti", "attmentUri", "attachmentCuris", "attachmentCuURI", "attachmentAti"], "contentUri": ["contentCri", "contentUdi", "contentIRI", "contentIri", " contentSuRI", "resourceUi", "contentIris", "contentURri", "resourceURI", "contentUsri", " contentUdi", "contentFileris", "contentUsRI", "resourceUri", " contentURI", "contentIuri", "contentCdi", "contentCRI", "contentCi", "contentSudi", "resourceIuri", "contentUi", "resourceIris", " contentSuri", "resourceUris", "contentFileri", " contentUris", "contentURI", " contentSuris", "contentSuris", "contentUris", "resourceUuri", "contentURris", "contentCris", "contentFileRI", "contentURuri", "contentSuRI", "contentFileuri", "resourceIRI", "contentURi", "contentUsdi", "resourceIi", "contentSuri", "contentCuri", "contentIi", "contentUsuri", "resourceIri", "contentUuri", "contentUsris", " contentSudi"], "file": ["work", "source", "local", "create", "filename", "buffer", "copy", "File", "fp", "output", "uri", "cache", "path", "load", "f", "this", "model", "use", "view", "via", "input", "to", "socket", "image", "line", "single", "data", "folder", "resource", "object", "able", "binary", "ger", "up", "io", "FILE", "url", "base", "name", "log", "b", "pe", "picture", "book", "files", "zip", "entity", "child", "letter", "upload", "connection", "stream", "handler", "auto", "le", "unit", "reader", "get", "content"], "in": ["source", "as", "init", "copy", "inn", "gin", "sync", "pin", "inner", "c", "ac", "f", "s", "this", "e", "i", "input", "socket", "conn", "image", "or", "IN", "data", "m", "ini", "win", "con", "binary", "io", "up", "bin", "a", "url", "din", "b", "nin", "ins", "connection", "In", "again", "pull", "r", "err", "login", "cli", "o", "id", "reader", "inc"], "out": ["source", "init", "copy", "cache", "output", "client", "sync", "net", "inner", "s", "this", "page", "view", "ex", "one", "i", "to", "socket", "conn", "OUT", "line", "image", "by", "data", "writer", "IN", "resource", "on", "up", "io", "bin", "base", "log", "b", "null", "outer", "ext", "exec", "nin", "connection", "lock", "Out", "In", "outs", "again", "err", "cli", "o", "inc"], "intent": ["text", "contact", "ent", "init", "ani", "concept", " Intent", "language", "effect", "feature", "feat", "android", "activity", "this", "event", "ents", "inst", "vent", "animate", "agent", "Activity", "object", "context", "anim", "act", "action", "document", "ink", "it", "intention", "entity", "term", "activation", "category", "activate", "enc", "element", "spirit", "acc", "eng", "advert", "impact", "anc", "request", "response", "entry", "ctx", "ant", "xml", "focus", "content"]}}
{"id1": "5683576", "id2": "755203", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"shorten": ["offen", "Shortend", " Shortener", " Shortening", "shortend", "offening", "shortening", "offend", "Shorten", "offener", " Shortend", "shortener", " Shorten", "Shortener", "Shortening"], "url": ["account", "ls", "source", "text", "method", "secret", "str", "json", "path", "username", "Url", "language", "config", "info", "page", "l", "data", "service", "resource", "email", "location", "www", "base", "name", "server", "host", "URL", "address", "api", "sl", "term", "string", " webpage", "version", "file", "request", "route", "key", "login", "id", " resource", "http"], "qparams": ["quparams", "reqoptions", "Qapi", "Qdetails", "qtypes", " qannels", "qParameters", " qParameters", "reqParameters", "Qplugins", " qtags", "qmac", "Qnames", "qplugins", "sqams", "quproperties", "qunames", "quapi", " qvals", "qtproperties", " qchanges", " qresults", " qproperties", "questapi", " qtypes", "qapi", "reqparams", "kresults", " qapi", "Qtags", " qquery", "Qproperties", "Qparams", "qdetails", "kams", " qams", "questparams", " qnames", "questproperties", "reqtags", "qresults", "qoptions", "Qtypes", "reqproperties", "questannels", "qtags", "qtquery", "qams", "qvals", "qtParameters", "Qvals", "questplugins", "reqmac", " qdetails", " qmac", "kchanges", "qutags", "sqmac", "sqresults", "qproperties", "qnames", "qannels", "questdetails", "qchanges", "qquery", "kparams", " qplugins", "reqquery", "sqtags", "sqparams", "sqoptions", "qutypes", "sqchanges", "questvals", " qoptions", "quannels", "qtparams"], "params": ["p", "lp", "secret", "rules", "ps", "json", "mm", "license", "py", "instance", "config", "s", "param", "phrase", "per", "i", "options", "services", "afi", "ras", "base", "qs", "apter", "server", "password", "pi", "api", "ams", "details", " parameters", "radius", "Parameters", "settings", "plugins", "properties", "pro", "ssl", "ctx", "cmp", "posts", "http"], "httpclient": ["httpconn", " httpconn", "httpconnection", " httppublic", "webClient", "webconn", "webcli", "webconnection", " httpcli", "webclient", "httpClient", "htmlconnection", "webpublic", "htmlclient", "httppublic", "webapi", "htmlcli", "phpclient", "phpClient", "phpapi", " httpconnection", "phppublic", "httpcli", "htmlconn", " httpClient", " httpapi", "httpapi"], "uri": ["uni", "client", "path", " ur", "gi", "environment", "i", " URI", "service", "resource", "proxy", "location", "directory", "document", "base", "database", "u", "server", "URL", "ui", "pi", "api", "address", "iri", "connection", "direction", "mi", "ur", "qi", "plugin", "range", "universal", "request", "route", "ilo", "href", "URI", "cli", "doi", "adi", "ri", "http"], "httpget": ["httpstart", "urlstart", "htmllike", " httpfind", " httplike", " httpGet", "ttpget", "httpquery", "htmlfind", "ttpsend", "harGet", "httpfind", "urlget", "httget", "httpshow", "httpGet", "httpsend", "httGet", "httpsshow", "ttpshow", "htmlget", "htmlGet", " httpsend", "httpssend", "ttpGet", " httpquery", "httpsget", "harfind", "harget", "urlquery", "harlike", " httpshow", "httstart", "httquery", "httplike", "httpsGet", " httpstart", "urlGet"], "response": ["message", "relation", "result", "output", "json", "generation", "successful", "environment", "page", "resp", "data", "service", "object", "resource", "reply", "document", "next", "server", "Response", "api", "body", "onse", "connection", "respond", "full", "received", "value", "collection", "request", "feed", "entry", "status", "application"], "entity": ["p", "ent", "message", "result", "output", "json", "translation", "info", "company", "model", "event", "page", "person", "environment", "component", "e", "po", "image", "issue", "data", "iso", "object", "resource", "email", "metadata", "node", "document", "error", "em", "server", "article", "obj", "api", "body", "connection", "element", "el", "coll", "eni", "value", "file", "collection", "ilo", "get", "xml", "Entity", "content"], "instream": [" invideo", "outstream", "outstruct", " infile", "inputstream", "instruct", " instring", "Instream", "Instring", "instring", " instruct", "invideo", "innstring", "inputfile", "innstream", " inStream", "inputStream", "innfile", "outfile", "infile", "outStream", "Invideo", "inputstruct", "Infile", "inStream", "innvideo"], "f": ["p", "F", "fp", "json", "fx", "cf", "c", "fb", "info", "w", "e", "i", "d", "l", "m", "fm", "aff", "framework", "fing", "bf", "inf", "fd", "fac", "fs", "fe", "api", "j", "h", "fr", "tf", "rf", "full", "fc", "df", "t", "feed", "sf", "v", "fab"], "jp": ["p", "lp", "ijk", "jing", "tp", "pai", "fp", "json", "mp", "git", "py", "jl", "np", "bj", "java", "txt", "dj", "pb", "ppo", "qt", "data", "bp", "fm", "prot", "vp", "bot", "pa", "gp", "jj", "kj", "ja", "dt", "obj", "zip", "api", "ji", "j", "jc", "je", "jen", "cp", "aja", "hp", "orb", "JP", "rup", "appy", "pp", "adj", "uj", "keeper", "pkg", "js", "jo", "jar"], "responseObj": [" responseObject", " responseExt", "respondObj", "ResponseObj", "respObject", "responseOb", "responseObject", "respondInfo", "ResponseObject", "serverobj", "Responseobj", " responseInfo", "respondObject", "respObj", " responseOb", "respondExt", "respExt", "serverObj", "responseExt", "serverObject", "responseobj", "respInfo", "responseInfo", "ResponseOb", " responseobj", "serverOb"], "token": ["p", "cookie", "init", "json", "current", "cho", "session", "generation", "field", "KEN", "language", "date", "info", "event", "wt", "seed", "note", "po", "tree", "notice", "complete", "atom", "qt", "or", "data", "aa", "writer", "in", "object", "format", "bot", "open", "operator", "Token", "valid", "next", "document", "character", "name", "action", "random", "oken", "api", "variable", "string", "fn", "tag", "header", "channel", "rule", "prefix", "option", "element", "parser", "ok", "iter", "tick", "key", "sign", "template", "after", "type", "start", "node", "pattern", "active"], "fieldname": [" fieldvalue", "columname", "fieldnan", "handname", "ieldName", "managervalue", "ieldvalue", "groupname", "Fieldnan", " fieldn", "handName", "Fieldname", "fieldame", "fieldvalue", "managerName", "groupvalue", "fieldn", "handame", "ieldalias", "columnnan", " fieldName", "columnname", "fieldName", " fieldalias", "ieldname", "groupName", "groupalias", "fieldalias", "FieldName", "Fieldame", "columnName", "managern", "handnan", "managername", "groupn"]}}
{"id1": "13981689", "id2": "14194234", "code1": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"md5Hash": ["md4Hash", "md5String", "md512hash", "md6Hash", "md5Sum", " MD6Sum", "md512String", "md6String", " MD5Sum", " MD6String", " MD6hash", " MD5hash", "md512Hash", "md512Sum", "md6Sum", " MD5String", "md4Sum", " MD6Hash", "md4String", " MD5Hash", "md4hash", "md6hash", "md5hash"], "src": ["text", "source", "ptr", "Bytes", "sb", "buster", "uri", "str", "length", "SB", "Url", "Str", "s", "info", "buf", " source", "bytes", "input", "inst", "SOURCE", "data", "RC", "Source", "img", "dest", "sup", "tmp", "inf", "b", "obj", "URL", "sc", "msg", "sl", "SourceFile", "rc", "rb", "string", "gb", "RGB", "ruby", "file", "lib", "ssl", "href"], "md": ["mand", "ss", "mm", "mp", "mod", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "mb", "material", "ind", "m", "ad", "metadata", "mad", "mac", "editor", "rm", "ms", "vd", "kg", "code", "pd", "gd", " MD", "od", "di", "dd", "mo", "hd", "cd", "km", "MD", "mc", "ma", "rod", "mag", "pm", "db", "d", "bd"]}}
{"id1": "6190356", "id2": "1097147", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForNewMD3", " hashPasswordForOldMC3", " hashPasswordForNewM3", " hashPasswordForOldM5", " hashPasswordForNewMD4", " hashPasswordForOldmd5", " hashPasswordForOldM4", " hashPasswordForOldMC5", " hashPasswordForOldMC4", " hashPasswordForNewM512", " hashPasswordForOldmd512", " hashPasswordForOldmd3", " hashPasswordForOldM3", " hashPasswordForOldMC512", " hashPasswordForOldmd4", " hashPasswordForOldMD4", " hashPasswordForNewM5", " hashPasswordForNewMD5", " hashPasswordForNewMD512", " hashPasswordForOldMD512", " hashPasswordForOldMD3", " hashPasswordForNewM4", " hashPasswordForOldM512"], "password": ["p", "text", "secret", " passwords", "message", "account", "result", "buffer", "words", "token", "path", "username", "pad", "hash", "wd", "seed", "pass", "phrase", "word", "input", "pattern", "padding", "data", "auth", "PASS", "name", "array", "sword", "code", "address", "wallet", "string", "crypt", "encrypted", "Password", "value", "key", " Password", "content"], "md": ["mand", "hm", "mm", "mp", "clean", "mod", "amd", "f", "Cmd", "wd", "dig", "cmd", "dm", "mb", "meta", "ind", "m", "nm", "pg", "metadata", "mac", "grad", "rm", "vm", "vd", "um", "pd", "gd", " MD", "managed", "od", "di", "dd", "mo", "mt", "hd", "cd", "am", "km", "MD", "mc", "df", "ma", "mag", "pm", "d", "rpm", "bd", "dc"], "messageDigest": ["MessageModester", "messagedigester", "MessageDigse", " messageModEST", "messageDEST", "messageModester", "messageAddests", "messageModests", "messagedigEST", " messageDigEST", "messagedigest", "MessageModEST", "MessageDigester", "messageDigEST", "MessageAddester", "messageDester", "messageAddester", "messageDigests", " messageDigester", "MessageModse", "messagedigse", "messageDigester", "messageAddest", "messageModEST", "messageModest", "messageDest", "messagedigests", " messageModests", " messageDigests", "MessageAddest", "messageDigse", " messageModest", "messageAddse", "MessageDigest", "messageModse", "messageDse", "messageAddEST", "MessageAddEST", " messageModester", "MessageDigEST", "MessageModest", "MessageAddse"], "hexString": ["hexArray", " hexstring", "crossstring", "sumStr", " hexSection", "hexBuffer", " hexService", "transformString", "stringString", "crossFunction", " hexBuffer", "stringSection", "tempFunction", "tempFile", "tempStr", "hashSection", "hexstring", "tempString", "sumString", "sumstring", "transformArray", "hashService", "tempstring", "hexFile", "sumFile", "octArray", "hexService", "stringService", "octStr", "hexSection", "octString", "octBuffer", " hexStr", "stringArray", "transformStr", "transformBuffer", " hexFile", "crossString", " hexFunction", "hexStr", "crossStr", "hashString", " hexArray", "hexFunction", "hashArray"], "i": ["p", "x", "uri", "length", "c", "f", "ai", "s", "ii", "info", "ix", "e", "d", "l", "I", "k", "ci", "m", "multi", "n", "ip", "io", "a", "si", "bi", "u", "b", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "di", "qi", "xi", "fi", "r", "t", "slice", "o", "id", "v", "ri", "ti", "phi"], "hex": ["text", "form", "nexus", "cookie", "char", "result", "cache", "str", "json", "length", "path", "hello", "shift", "buff", "hash", "hack", "ex", "pattern", "none", "default", "data", "format", "binary", "transform", "ip", " Hex", "zero", "pixel", "bit", "character", "null", "host", "letter", "oct", "h", "string", "exp", "he", "alpha", "digit", "comp", "full", "batch", "orig", "serial", "lit", "pex", "rex", "raw", "temp", "utf", "pack", "sex", "rh", "cmp", "http"]}}
{"id1": "10385815", "id2": "6457199", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": ["create", "cmp", "sync", "paste", "Transfer", "update", "download", "Cop", "send", "move", "process", "open", "clone", "change", "transfer", "exec", "split", "zip", "upload", "Copy", "write", " Copy", "replace", "put", "file", "get", "delete"], "fileFrom": ["mailIn", "FileSource", " fileIn", "fileStart", "FileIn", "FileFrom", "fileAs", " fileStart", "mailAs", "ioFrom", " fileSource", "FileTo", "ioStart", "mailTo", "FileStart", "mailFrom", "ioTo", " fileAs", "fileSource", "fileIn", "ioSource", "FileAs"], "fileTo": ["fpFrom", " fileFile", "FileFrom", " fileTarget", "fpTo", "resourceFile", "fileFile", "fileTO", "FileTarget", "FileTo", " fileTO", "fileto", "Fileto", "FileFile", "FileTO", "fpto", " fileto", "fpTO", "fileTarget", "resourceTarget", "resourceTo", "resourceFrom"], "inputStream": ["InputFile", "InputChannel", " inputstream", "inputContext", "InputSync", "outputSteam", "inputFile", "InputContext", "outputContext", "Inputstream", "inputstream", "InputStream", " inputFile", "InputSteam", " inputSteam", "outputSync", "outputstream", "inputSteam", "outputFile", " inputContext", "inputSync", " inputSync"], "outputStream": ["OutputStream", "outputPath", "OutputStreamer", "writeStream", "OutputSteam", "writeSocket", "writeSteam", "outputStreamer", "referenceChannel", "inputChan", "inputSocket", " outputSteam", "OutputChan", "fourStreamer", "fourStream", "referenceStream", "inputPath", "OutputPath", " outputChan", " outputStreamer", "referenceSteam", "inputSteam", "fourSteam", "writeChannel", "OutputChannel", "fourChannel", "referenceSocket", "outputChan", "outputSocket", "outputSteam", " outputPath"], "inputChannel": ["outputClient", "audioCam", "butChannel", "parentPassword", "InputChannel", "inputContext", "InputContext", "inputChan", "outputContext", " inputSocket", " inputCam", "inputPassword", "inputCam", " inputPassword", "butCommand", "inputSocket", "parentChannel", " inputChan", "InputSocket", "audioChannel", "audioClient", "audioStream", "butContext", "InputStream", "inputCommand", "outputCam", "inputClient", "outputPassword", "outputCommand", "butChan", " inputClient", "InputChan", "parentChan", "outputChan", " inputContext", "outputSocket", "parentStream", " inputCommand"], "outputChannel": ["Outputchannel", "OutputStream", "inputQueue", "inputContext", "OutputContext", "inputChan", "outputContext", "outputchannel", "outContext", "outputQueue", "OutputChan", "OutputQueue", " outputQueue", " outputChan", " outputchannel", " outputContext", "outChannel", "OutputChannel", "outChan", "outputChan", "outStream", "inputchannel"]}}
{"id1": "335223", "id2": "8320469", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "11153282", "id2": "8062076", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": ["containsUrl", "exitsURL", "exiesURI", "containsURL", "containsURI", "exainsURL", "existsUrl", "exiesurl", "exitsurl", "exainsurl", "exainsURI", "contistsURL", "exitsURI", "containsurl", "contistsUrl", "exitsUrl", "contistsURI", "exiesURL", "exiesUrl", "existsurl", "existsURI", "exainsUrl", "contistsurl"], "urlStr": ["httpSTR", "URLString", "uriStr", "httpString", "httpStr", "uriString", "urlSt", "uriSTR", " urlSt", "URLSt", " urlSTR", "URLStr", "urlUrl", "resourceString", "resourceUrl", " urlString", "URLUrl", "urlString", " urlUrl", "resourceSt", "uriSt", "httpSt", "urlSTR", "resourceStr"], "url": ["ls", "client", "Url", "c", "f", "bb", "config", "e", "l", "conn", "loc", "blog", "web", "resource", "proxy", "aur", "open", "www", "base", "log", "bel", "b", "lc", "server", "host", "URL", "fl", "sl", "api", "secure", "connection", "ur", "ul", "ll", "el", "fc", "file", "ssl", "http"], "con": ["x", "ln", "xc", "client", "cf", "ctrl", "cover", "c", "ocon", "ver", "Connection", " conn", "ca", "conn", "Conn", "close", "web", "open", "ec", "on", "connect", "bc", "pc", "ann", "conv", "bon", "gen", "exec", "ran", "fl", "Con", "conf", "can", "rc", "connection", "cc", "fa", "plain", "cons", "cm", "run", "fc", "en", "un", "cn", "syn", "CON", "ct", "common", "co", "bn", "http"], "responseCode": ["respCode", "statusCode", "resourcecode", " responsecode", "responsecode", "Responsecode", "ResponseCount", "ResponseStatus", "respType", "respStatus", "responseType", "ResponseCode", "responseCount", "respCount", "statusType", "statusCount", "resourceCode", "responseStatus", " responseType", "resourceType", "ResponseType", "statusStatus"]}}
{"id1": "16804988", "id2": "8266672", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "label": 0, "substitutes": {"init": ["create", " initialization", "parse", "load", "update", "config", "info", "construct", "show", "image", "build", " initialized", "close", "format", "Initialized", "initial", "it", "setup", "Init", " startup", "activate", "ize", "layout", "launch", "start", " Init", "draw"], "filename": ["fp", "uri", "length", "path", "username", "license", "kl", "ppa", "download", "config", "f", "title", "il", "phrase", "txt", "fil", "word", "l", "loc", "loader", "folder", "location", "metadata", "binary", "which", "journal", "dll", "directory", "n", "online", "database", "name", "kn", "fd", "params", "files", "password", "SourceFile", "upload", "string", "fn", "ename", "size", "prefix", "Filename", "fax", "file", "utf", "nil", "ssl", "doi", "sf", "jpg", "content"], "dim": ["p", "iframe", "span", "shape", "marg", "im", "py", "mod", "wid", " reim", "config", "info", "param", "lim", "dm", "imm", "project", "image", "dimension", "val", "m", "fm", "format", "img", "multi", "g", "si", "grad", "num", "width", "spec", "ext", "du", "fac", "ims", " Dim", "min", "dat", "dem", "dr", "gm", "index", "dist", "div", "size", "mi", "di", "thin", "cm", "scale", "grid", "dom", "wm", "Dim", "part", "sam", "fi", "slice", "diff", "d"], "w": ["p", "x", "sw", "z", "c", "f", "s", "wd", "wt", "e", "i", "l", "max", "k", "hw", "m", "q", "win", "W", "n", "a", "wa", "u", "b", "width", "fw", "wh", "rw", "height", "en", "weight", "y", "r", "t", "ow", "o", "v", "d", "ew"], "h": ["p", "x", "th", "ht", "hm", "bh", "z", "c", "f", "s", "e", "ah", "l", "k", "oh", "hs", "kh", "ph", "q", "gh", "n", "b", "u", "hr", "rh", "j", "ih", "uh", "height", "sh", "hd", "en", "ha", "y", "t", "H", "o", "v", "d"], "in": ["source", "as", "fp", "inn", "out", "gin", "cf", "pin", "ac", "f", "ax", "fb", "i", "input", "l", "src", "socket", "conn", "serv", "read", "IN", "data", "ini", "win", "resource", "io", "n", "din", "b", "fac", "is", "fe", "nin", "min", "ins", "connection", "amin", "stream", "cl", "el", "In", "impl", "inc", "fc", "again", "file", "kin", "lib", "r", "err", "login", "cgi", "id", "reader", "ssl", "bin"], "ff": ["lf", "fp", "uf", "fx", "cf", "f", "bb", "fb", "buff", "buf", "ulp", "back", "iff", "aff", "af", "bf", "eff", "fd", "fe", "fl", "xff", "ouf", "ef", "FF", "ffe", "fff", "fc", "fed", "file", "df", "pp", "feed", "sf", "ctx", "cb", "cmp", "library"], "url": ["ls", "source", "uri", "fp", "path", "Url", "download", "f", "fb", "e", "l", "src", "image", "web", "resource", "open", "www", "io", "base", "b", "server", "URL", "fl", "zip", "sl", "string", "connection", "fr", "stream", "ll", "file", "ssl", "feed", "sf", "ob", "http"]}}
{"id1": "18370075", "id2": "4716110", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"createPasswordDigest": ["createPassworddigenge", "createPasswordSignester", "createpassworddigenge", "createPasswordSignifier", "createpasswordDigest", "createPassworddigester", "createPassworddigifier", "createpassworddigester", "createPasswordSignest", "createPasswordDigester", "createPasswordModenge", "createPassworddigest", "createPasswordDigenge", "createpasswordDigifier", "createpassworddigest", "createpasswordDigenge", "createPasswordModifier", "createPasswordDigifier", "createPasswordSignenge", "createpassworddigifier", "createPasswordModester", "createPasswordModest", "createpasswordDigester"], "password": ["p", "account", "secret", "text", "message", "source", "filename", "words", "token", "path", "username", "config", "pad", "hash", "wd", "seed", "pass", "phrase", "command", "word", "padding", "data", "auth", "email", "PASS", "database", "name", "sword", "security", "address", "wallet", "Pass", "string", "crypt", "Password", "key", "login", "user", "pattern"], "salt": ["psecret", "sass", "sessecret", "sesALT", " ssecret", "sesalt", "pass", "pALT", "palt", "Sass", "ssALT", "ssass", "SALT", "Salt", "sssecret", "sALT", " sass", " sALT", "sesass", "ssecret", "Ssecret", "ssalt"], "md": ["me", "mand", "message", "mm", "clean", "mod", "amd", "cmd", "dm", "po", "mb", "meta", "ind", "ph", "m", "nm", "ad", "metadata", "mad", "mac", "bf", "ms", "kg", "code", "nd", "zip", "pd", "sha", "gd", " MD", "od", "di", "dd", "ld", "mo", "mn", "mt", "cd", "MD", "mc", "ma", "mag", "pm", "d", "bd", "mail"], "digest": ["generests", "decress", "Digester", "dester", "DigEST", "digress", "hashest", "signcode", "digEST", "dEST", "decests", "digested", " digests", "decest", "hashested", "generester", "dested", "hashester", "dest", "signested", "generest", " digEST", "digests", "signester", "generress", "Digest", " digcode", "decester", " digested", "Digested", "digester", " digress", "hashcode", "digcode", " digester", "signest"]}}
{"id1": "14877116", "id2": "12172485", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"cpFile": [" copyFile", "cpfile", " cpfile", "CopyFile", " cpFiles", " cpCode", " copyCode", "Copyfile", "CopyFiles", " copyfile", "cpCode", "cpFiles", "CopyCode", " copyFiles"], "source": ["remote", "current", "se", "client", "token", "table", "path", "config", "this", "use", "view", "seed", "archive", "component", "ources", "ource", "image", "SOURCE", "project", "Source", "service", "object", "from", "resource", "ce", "Target", "force", "self", "dest", "directory", "document", "url", "base", "name", "subject", "database", "null", "server", "host", "zip", "secure", "grade", "scene", "string", "connection", "scope", "channel", "stream", "element", "reference", "iter", "file", "route", "slice", "template", "site", "unit", "type", "parent", "start", "node", "context"], "target": ["top", "remote", "result", "copy", "tor", "table", "current", "port", "token", "client", "path", "sync", "output", "download", "config", "alias", "home", "archive", "component", "master", "tail", "nt", "root", "owner", "to", "arget", "project", "ource", "global", "service", "object", "Target", "resource", "other", "format", "transform", "force", "self", "dest", "proxy", "director", "next", "url", "base", "name", "database", "folder", "null", "it", "server", "host", "connection", "external", "origin", "range", "reference", "iter", "file", "route", "template", "site", "boot", "type", "parent", "content"], "replace": ["match", "reset", "copy", "re", "sync", "cover", "flash", "update", "store", "use", "place", "compatible", "root", "move", "complete", "inline", "follow", "other", "force", "placed", "rm", "share", "allow", "change", "add", "multiple", "array", "split", "append", "fill", "align", "repeat", "repl", "write", "only", "range", "insert", "include", "route", "protect", "remove", "stall", "apply", "same", "delete", "hide", "rel", "reply"], "bufferSize": ["byteLen", "serverLen", " bufferCount", "bytesize", "flushSize", "buffersize", " buffersize", "queueSize", "serversize", "byteSize", "flushsize", "queuesize", "serverSize", " bufferLen", "flushLen", "queueLen", "bufferCount", "bufferLen", " bufferSIZE", "flushSIZE", "bufferSIZE", "serverSIZE", "queueCount", "byteCount"], "src": ["result", "sb", "copy", "rec", "sync", "flash", "gz", "archive", "ources", "input", "ource", "socket", "inst", "loc", "RC", "req", "Source", "sys", "in", "resource", "proxy", "sr", "dest", "reflect", "url", "tmp", "bc", "proc", "server", "obj", "sel", "sc", "zip", "sl", "secure", "sub", "rc", "rb", "cur", "fn", "gb", "stream", "sh", "sq", "ruby", "rt", "ssl", "ser", "ctx", "start", "cb"], "tarn": ["taur", " treen", "taron", "yarn", "ttarp", "ttaro", "tron", "wtern", "Treen", "ttarm", "taran", "treen", "trn", "ttern", " taron", "ttrn", "wtaran", "ntaron", "etann", " tern", "yaran", "thern", "ttann", "ntann", "ttarn", "wtarn", " tarm", "Tann", " tron", "Tarm", "tann", "tharn", "yern", "ttaron", "Trn", "tern", "taro", "Taran", " taro", "wtarm", " tarp", "ttron", "ntarp", "yarm", "ttaur", "ntarn", "tharo", " taur", "Tron", "etarn", "Tarn", "tarm", " trn", "etaran", " taran", "etreen", "tarp", " tann", "thaur"], "tardir": ["tarddir", "tardedpath", "tartdir", "tartart", "tarpirt", "tartirs", "tartire", "tartirt", "tardsar", "tarir", "tarart", "Tartir", "tardire", "tildart", "sardar", "sardirt", "tardsire", "sardsar", "Tartart", "tartar", "tardiri", "Tartiri", "tardirs", "tarpar", "tildir", "tarpire", "tartpath", "tardsdir", "Tartdir", "tardsir", "tardeddir", "tartiri", "tariri", "Tardirs", "sardire", "Tardiri", "tarar", "sardsire", "tildiri", "Tartpath", "Tardir", "Tarddir", "tardsirs", "sardsir", "tartir", "Tardpath", "Tartar", "sardsirt", "tardedir", "tardedirs", "Tardart", "tardart", "Tartirs", "Tardar", "sardir", "tardirt", "tarpir", "tildar", "tardar", "tardpath", "tardspath", "tardsirt"], "n": ["p", "x", "ln", "z", "c", "ni", "nt", "i", "e", "l", "k", "conn", "norm", "N", "nor", "none", "m", "nl", "in", "ne", "g", "nn", "u", "num", "nb", "number", "na", "nu", "j", "min", "nc", "fn", "pn", "mn", "rn", "ng", "nw", "coll", "en", "un", "sn", "ns", "cn", "dn", "o", "v", "d", " i"], "tar": ["buffer", "shape", "copy", "cloud", "large", "ray", "flash", "csv", "cat", "tc", "archive", "gz", "rar", "trans", "war", "ca", "skip", "tan", "box", "sr", "dest", "ar", "tmp", "cos", "tif", "transfer", "cr", "zip", "cro", "Tar", "tg", "dr", "par", "shr", "tf", "di", "safe", "sum", "sh", "test", "ra", "tr", "file", "temp", "pack", "sv", "raf", "jar", "car"], "bytes": ["frames", "ls", "nets", "bles", "eps", "Bytes", "ps", "words", "lines", "out", "bits", "keys", "seconds", "vals", "les", "resources", "ones", "data", "ipes", "vs", "bps", "cells", "io", "values", "pieces", "b", "os", "objects", "files", "bs", "reads", "steps", "pages", "outs", "runs", "es", "tes", "items", "classes", "boot", "blocks", "rows", "ops"], "readn": ["runns", "findne", "findN", "findn", "Readn", "writelen", "ReadN", "writen", " readl", "readN", "writene", "passns", "readno", " readlen", "Readl", "writeno", "runl", "readns", "writeN", " readN", "runlen", "runn", "runN", "readne", "Readlen", "passN", "readl", "passn", "passno", " readne", "findlen", "writens", "runno", "readlen"]}}
{"id1": "22057083", "id2": "20855053", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "label": 0, "substitutes": {"Connect": [" Close", "Open", "Client", "connected", "Close", "Config", " Connection", "Construct", "New", "Connection", "Create", "Dial", "Conn", "Run", "Build", "Sync", "Load", "Setup", "connect", "Fail", "Socket", "Init", "Process", "Connector", "Remote", "Subscribe", "Login", "Host"], "client": ["local", "call", "util", "remote", "cloud", "cache", "ace", "Client", "port", "session", "cell", "clean", "c", "config", "per", "command", "console", "socket", "conn", "friend", "manager", "project", "ci", "get", "default", "con", "close", "service", "resource", "proxy", "ce", "open", "force", "core", "connect", "pc", "name", "server", "host", "code", "pool", "secure", "api", "child", "connection", "cc", "channel", "cp", "handler", "cl", "plugin", "cm", "grid", "cod", "cn", "lib", "request", "cli", "ssl", "end", "user", "parent", "co", "http"], "reply": ["message", "call", "ret", "result", "buffer", "sync", "continue", "ping", "info", "status", "state", "link", "ply", "send", " replies", "read", "resp", "bot", "comment", "next", "related", "reason", "code", "post", "query", "address", "rc", "connection", "respond", "dy", "echo", "prefix", "repl", "Reply", "replace", "answer", "request", "part", "err", "response", "error", " response"]}}
{"id1": "11840277", "id2": "1156851", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"clearTables": ["createStaches", "clearTableows", "clearTows", "cacheTableables", "clearTaces", "createTaches", "clearTemations", "clearBaches", "clearBations", "cacheTableings", "clearTations", "clearContows", "clearTableations", "cacheTableations", "clearTemings", "clearStaces", "createStaces", "clearStows", "clearTableings", "clearTemables", "createTables", "cacheTables", "clearStaches", "createTows", "clearTaches", "clearContaces", "cacheTations", "createStables", "cacheTableows", "clearTemows", "cacheTows", "clearBings", "clearContaches", "createStows", "cacheTings", "clearBables", "clearTableables", "clearTings", "clearBows", "clearBaces", "clearContables", "clearStables", "createTaces"], "conn": ["p", "org", "cmp", "cache", "client", "oss", "cf", "path", "session", "cb", "c", "ac", "cat", "ai", "bb", "config", "wd", "Connection", "state", "nt", "ca", "Conn", "ci", "loc", "con", "close", "pg", "open", "act", "pub", "n", "sth", "connect", "error", "ann", "log", "ou", "lc", "col", "server", "exec", "obj", "conf", "ch", "jc", "rc", "connection", "h", "nc", "cc", "cond", "cp", "lock", "di", "enc", "coll", "cm", "mt", "Connect", "oci", "sql", "cn", "ns", "mc", "ssl", "dn", "ob", "ct", "ctx", "db", "co", "dc"], "stmt": ["ssmn", "Sttx", " stma", " stlt", "Stnt", "ldmt", "estmm", " stql", "putm", "ldmn", "Stwt", "ctql", "stwd", "STmd", "Stmt", "Stm", " stmi", "putmm", "stwt", "playtx", "actmi", "Stml", " stmc", "sswt", "istgr", " stml", "STMT", "istMT", "emt", "ftlt", "putap", " stmd", "ldma", "STgr", "est", "putmn", "putml", "stmm", "Stap", "putmt", "STmt", "stprint", "actmt", "Sttor", "playmt", "Stct", "STmn", "stsprint", "strmt", "stm", "STprint", "ctr", "strml", "Stmn", "ftmn", " stbm", "stma", "stct", "istmt", "STst", "stMT", " stmn", "Stlt", "stsst", " str", "putlt", "stgr", "Stmd", "str", "ctmd", "Stmm", "tmt", "stml", "ssbm", "Stmi", "dm", "stbm", "stap", "stmd", "ldager", "estwt", "stsmt", "actnt", "stswd", "ctgr", " stager", " stm", "stmi", "putbm", "dr", "stlt", " stap", "stmn", "Stgr", "ctm", "StMT", "eprint", "putMT", "STlt", "ftbm", "putma", "strMT", "tct", "stager", "stst", "tnt", "putager", "estm", "estmt", "istmn", "STwd", "dmt", "ctmt", "stql", " stct", " stgr", "putwt", "actmn", "puttor", " stwt", "sttx", "playwt", "playtor", "ssmt", "tm", " stnt", "Stmc", "STmc", "ftmt", "sttor", "stnt", "dql", "stmc", "ewd", "puttx", "STbm", "strlt"]}}
{"id1": "11556231", "id2": "23510383", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 0, "substitutes": {"ByURL": ["ByUrl", "CreateURI", "bySSL", "byURI", "CreateURL", "byURL", "createUrl", "ByURI", "createSSL", "CreateSSL", "createURI", "createURL", "byUrl", "BySSL", "CreateUrl"], "urlstr": ["httpSTR", "Urlname", "Urlstr", "URLname", "URLstr", "urlname", "UrlSTR", " urlname", "Urlstring", "httpStr", "URLstring", "httpstr", "urlStr", "httpstring", "URLStr", " urlSTR", " urlstring", "urlstring", "UrlStr", "urlSTR", "URLSTR"], "uri": ["text", "filename", "absolute", "path", "username", "Url", "domain", "i", " URI", "manager", "image", "resource", "location", "description", "io", "directory", "database", "base", "server", "host", "URL", "ui", "query", "address", "pi", "iri", "string", "direction", "prefix", "qi", "attribute", "collection", "file", "route", "href", "URI", "id", "type", "ri", "http"], "url": ["client", "path", "session", "Url", "download", "f", "system", "page", "link", "l", "conn", "image", "loc", "loader", "web", "service", "resource", "location", "proxy", "base", "server", "host", "URL", "sl", "address", "li", "string", "channel", "stream", "file", "ssl", "feed", "id", "user", "http"], "connection": ["relation", "client", "connected", "c", "system", "Connection", "i", "control", "l", "socket", "conn", "or", "application", "writer", "con", "resource", "open", "director", "io", "directory", "connect", "database", "server", "URL", "body", "channel", "stream", "handler", "collection", "response", "context", "http"], "in": ["as", "init", "inn", "out", "client", "inner", "c", "ac", "f", "s", "i", "input", "socket", "conn", "or", "IN", "writer", "ini", "con", "bin", "a", "and", "connect", "ins", "stream", "lin", "In", "kin", "r", "login", "inc", "cms"], "reader": ["buffer", "result", "out", "reading", "client", "inner", "ler", "i", "input", "conn", "or", "read", "writer", "loader", "ini", "resource", "io", "server", "rc", "channel", "stream", "handler", "ais", "wrapper", "parser", "Reader", "iter", "row", "r", "er", "entry"], "is": ["mis", "as", "ris", "im", "IS", "out", "isa", "was", "ai", "s", "info", "iss", "i", "Is", "serv", "conn", "src", "ci", "or", "iso", "lis", "rs", "sr", "io", "si", "os", "ui", "fs", "isl", "isi", "sp", "iri", "ins", "rss", "ais", "ios", "iris", "err", "nis", "bis", "has", "ri", "cms"], "document": ["message", "result", "output", "config", "root", "ocument", " documents", "writer", "m", "object", "resource", "node", "class", "database", "graph", "docs", "Document", "Documents", "element", "collection", "response", " documentation", "parent", "xml", "doc", "content", "application"], "source": ["text", "language", "instance", "info", "content", "driver", "input", "src", "SOURCE", "Source", "service", "object", "resource", "class", "container", "string", "stream", "element", "parser", "file", "unit", "parent", "node", "context"], "name": ["text", "filename", "property", "instance", "NAME", "info", "domain", "root", "word", "Name", "names", "definition", "object", "format", "resource", "location", "comment", "description", "base", "string", "tag", "prefix", "element", "value", "file", "attribute", "named", "key", "URI", "id", "type", "parent", "node"], "namespaceURI": ["namesheetURI", "namesistenceFINE", "Namespacesuri", "perspacedGI", "NamespacesMI", "NamespacesURI", "NamespaceURI", "nameservingURI", "namesistenceURI", "namesheetGI", "namespaceduri", "namespacedURI", "namesferenceURI", "namespacedNS", "namespaceNS", "namespacesFINE", "namesistenceuri", "namesferenceFINE", "namespacedGI", "Namespaceuri", "perspaceduri", "namesferenceuri", "namespaceGI", "namespacesuri", "perspaceGI", "perspaceURI", "namespacesMI", "NamespacesFINE", "NamespaceMI", "namespaceFINE", "nameservingNS", "namespacesURI", "namespaceMI", "perspacedURI", "namespaceuri", "nameservinguri", "namesferenceMI", "NamespaceNS", "namesheeturi", "perspaceuri", "namesistenceMI", "NamespaceFINE"], "qualifiedName": ["qualPath", " qualifiedname", "localType", "fixedname", "qualifiedType", " qualifiedURI", "localPath", "simplename", "qualURI", " qualifiedType", "qualName", "simplePath", "fixedName", " qualifiedPath", "fixedPath", "localname", "qualifiedPath", "qualifiedURI", "fixedType", "qualname", "simpleURI", "simpleName", "qualifiedname"], "data": ["text", "message", "buffer", "property", "media", "str", "output", "script", "DATA", "language", "config", "NAME", "info", "model", "input", "default", "definition", "object", "resource", "context", "format", "node", "ata", "description", "class", "base", "number", "child", "body", "string", "stream", "element", "def", "value", "template", "id", "comments", "type", "parent", "xml", "doc", "content"], "tagName": [" tagClass", "TagClass", "localClass", "Tagname", "TagName", "tagClass", "localname"], "target": ["method", "uid", "property", "prop", "path", "instance", "info", "NAME", "head", "component", "domain", "root", "object", "Target", "location", "resource", "format", "next", "class", "base", "host", "label", "address", "href", "template", "parent", "node"], "elementId": ["elementid", " elementID", "objectTag", "elementID", "nodeId", "objectId", " elementid", "objectid", " elementTag", "nodeID", "elementTag", "nodeTag", "objectID", "nodeid"], "tagname": ["className", "classname", "TagNAME", "tagNAME", " tagNAME", "classNAME", "Tagname", "TagName"], "localName": [" localname", "clientName", " localNAME", "localname", "clientNAME", "clientname", "qualifiedname", "qualifiedNAME", "localNAME"]}}
{"id1": "11716816", "id2": "397240", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"updateFile": ["updateFolder", "importFolder", "upBody", "copyBody", "upFile", "importDirectory", "copyDirectory", "importBody", "upFolder", "updateBody", "updateDirectory", "importFile", "copyFile", "copyFolder", "upDirectory"], "file": ["source", "local", "filename", "File", "fp", "cache", "current", "path", "load", "f", "info", "this", "model", "e", "input", "l", "socket", "image", "single", "line", "data", "object", "resource", "FILE", "up", "io", "class", "url", "base", "name", "log", "b", "pe", "files", "zip", "connection", "lock", "future", "queue", "handler", "full", "parent", "part", "dir", "type", "get", "db", "content", "http"], "IOException": ["TimeoutProblem", "TimeoutException", "DownloadException", "Downloadception", "IOception", " IOception", " IOProblem", "DownloadProblem", "Timeoutception", "IOProblem"], "destFile": ["sourceDir", " destFull", "destfile", "srcFile", " destPath", "origfile", " destinationFull", "flatDir", " destTable", " destDir", "destDir", "srcPath", "destroyFile", "DestDir", "destTable", "destroyfile", "DestFiles", "destPath", "DestFull", "flatfile", "destFull", " destFiles", "flatFile", "origDir", "origTable", " destinationFile", "DestFolder", "srcFiles", " destFolder", "origFile", "sourceFiles", "destroyDir", "sourceFolder", " destfile", "destroyTable", "flatFiles", "DestFile", "srcFolder", " destinationFiles", " destinationDir", "DestPath", "sourceFile", "destFiles", "destFolder", "Destfile"], "in": ["p", "work", "source", "as", "init", "re", "inn", "gin", "client", "sync", "cf", "pin", "inner", "ac", "c", "f", "ax", "s", "this", "with", "pass", "i", "input", "l", "socket", "inside", "image", "conn", "IN", "con", "win", "ini", "on", "io", "up", "bin", "a", "isin", "b", "nin", "min", "ins", "connection", "lock", "cin", "cl", "el", "In", "inc", "again", "pull", "r", "err", "login", "id", "reader", "din"], "out": ["call", "cookie", "of", "output", "sync", "client", "net", "c", "at", "point", "this", "extra", "w", "timeout", "ex", "pass", "i", "to", "socket", "OUT", "conn", "writer", "resource", "up", "io", "n", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "password", "nin", "connection", "exp", "channel", "option", "Out", "In", "outs", "inc", "again", "off", "lib", "err", "login", "o", "user", "bin", "outside", "co", "no"]}}
{"id1": "18202328", "id2": "8788371", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"register": ["create", "app", "init", "check", "load", "update", " regenerate", "config", "reg", "master", "Register", "auth", "play", " Register", "connect", "setup", "password", "activate", "chain", " reg", "save", "login", "bind", " unlock", "user", "start", "Login", " registration"], "session": ["python", "message", "group", "cookie", "remote", "position", "sb", "video", "cache", "facebook", "client", "sync", "port", "browser", "script", "ession", "config", "gui", "state", "view", "slave", "driver", "master", "use", "person", "input", "event", "socket", "manager", "conn", "image", "global", "service", "resource", "proxy", "play", "ess", "shell", "sa", "connect", "window", "database", "caster", "device", "security", "server", "host", "thread", "password", "child", "h", "connection", "machine", "channel", "lock", " Session", "section", "version", "mc", "request", "parent", "temp", "ssl", "room", "login", "site", "game", "Session", "user"], "username": ["account", "text", "source", "secret", "message", "uid", "filename", "property", "uri", "token", "steam", "monitor", "length", "path", "phone", "hello", "ame", "NAME", "title", "ername", "seed", "phrase", "driver", "person", "word", "mother", "nick", "Name", "localhost", "duration", "auth", "email", "voice", "url", "character", "name", "subject", "database", "sword", "host", "amer", "password", "address", "verb", "term", " nickname", " password", "string", "crypt", "prefix", "profile", "Password", "users", "attribute", "login", "minecraft", "user", "mobile"], "verificationKey": ["significationSecret", "vermentKEY", "verifykey", "validificationkey", "verifySecret", "vermentKey", "verifyingPoint", "vermentSecret", "verifyingSecret", "validificationPoint", "signationKEY", "significationKey", "verifyingKEY", "significationKEY", "signationkey", "verifyKey", "verationKey", "verificationKEY", "verifyPoint", "verificationPoint", "verifyingkey", "verifyingKey", "validifyingkey", "verationkey", "verationKEY", "verificationkey", "validifyingPoint", "validificationSecret", "verificationSecret", "validifyingSecret", "significationkey", "verationPoint", "vermentkey", "verationSecret", "validificationKey", "validifyingKey", "signationSecret", "signationKey"], "salt": ["sodium", " sodium", "seALT", " sort", "sealt", "seSalt", "setsALT", "setsodium", "Shash", "suffSalt", "SALT", "setsalt", "setsort", "Salt", "shash", "sALT", "sort", "sSalt", "suffalt", "suffhash", " sALT", "sehash", "suffALT", "SSalt"], "hash": ["text", "secret", "match", "message", "result", "buffer", "hed", "cache", "output", "square", "ash", "memory", "input", "build", "kh", "total", "auth", "mac", "url", "name", "array", "log", "Hash", "host", "pool", "password", "number", "query", "sha", "hex", "address", "string", "h", "header", "crypt", "sum", "html", "version", "key", "her", "user"], "digest": ["Digit", "bigest", "Digester", "defest", "Digests", "bigester", "biggest", "DigEST", "defester", "bigested", "digEST", "logest", "digested", " digests", "logester", "logger", "hedested", "defEST", "Digger", "logit", "digger", "signested", " digger", "signEST", "diggest", " digit", " digEST", "digests", "hedester", "hedest", " dige", "dige", "Digest", "hedEST", "digit", " diggest", "defe", "Diggest", " digested", "Digested", "Dige", "signests", "digester", " digester", "signest"], "nameChars": ["nameChararts", "nameCheases", " nameCharacters", "nameChats", " nameChases", "namechases", "nameGrarts", "nameCharARS", "nameGrARS", "nameGrars", "nameChARS", "nameCharacters", "namecharts", " nameChararts", " nameCharARS", "nameGracters", " nameChARS", "nameChacters", "nameChases", " nameChats", " nameCharars", "nameCharts", "nameChears", "namechars", "namechacters", "nameCharars", "nameCheARS", " nameChacters", "namechats", "nameCheats", " nameCharts", "namechARS"], "nameChar": [" nameText", "resourceChar", " NameCh", "nameDir", "NameCharacter", "resourcechar", " NameText", "nameCharacter", "nameText", "NameCh", "nameCh", "idCharacter", "resourceCharacter", "addressCh", "nameCtrl", " nameCharacter", "NameChar", "idText", "namechar", "addressCtrl", " nameCh", "idCh", " nameDir", "addressCharacter", "NameDir", "resourceDir", "idChar", " NameChar", " nameCtrl", "addressChar", " namechar", "Namechar", "NameCtrl", " NameCharacter"], "p": ["lp", "pre", "ps", "fp", "client", " P", "br", "py", "f", "point", "s", "np", "at", "e", "per", "i", "po", "l", "m", "q", "cop", "pa", "n", "g", "a", "up", "pc", "u", "pe", "b", "api", "j", "sp", "h", "cp", "jp", "ap", "part", "r", "pp", "er", "t", "o", "op", "v", "d", "P", "pair"], "player": ["match", "video", "position", " Player", "media", "steam", "client", "played", "ace", "script", "person", "slave", "driver", "ler", "per", "e", "l", "Player", "players", "manager", "league", "owner", "playing", "data", "m", "board", "play", "n", "g", "class", "name", "caster", "party", "pe", "server", "pool", "master", "live", "team", "worker", "connection", "machine", "layer", "leader", "winner", "aster", "parent", "pm", "part", "pro", "er", "conference", "controller", "gamer", "user", "game", "member", "can"], "c": ["cs", "cache", "cf", "ac", "config", "f", "tc", "l", "ca", "k", "ci", "m", "con", "ce", "ec", "n", "arc", "bc", "pc", "lc", "C", "cr", "sc", "conf", "rc", "cc", "h", "nc", "cp", "chain", "enc", "cl", "cm", "fc", "cu", "mc", "r", "t", "ct", "o", "ctx", "v", "cb", "d", "abc", "dc"]}}
{"id1": "1156851", "id2": "3756429", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"runWeb": ["runweb", "processWs", "runWs", "runningSite", " runWs", "runningWs", "runningWeb", " runweb", "runningweb", "processSite", "processWeb", "processweb", "runSite", " runSite"], "beginURL": [" beginUrl", "untilurl", "useUR", "beginurl", "startURL", "untilURL", "startUrl", " beginSSL", "useUrl", "startELF", "BeginSSL", "useURI", "endUrl", "untilURI", " beginELF", "beginUR", "startSSL", "BeginELF", "endurl", "BeginURL", "BeginUR", "BeginUrl", "beginURI", "BeginURI", "endUR", "useURL", "endURI", "beginUrl", "endURL", "untilUrl", "beginSSL", "Beginurl", "beginELF"], "contextRoot": ["conceptRoot", "resourcePath", " contextRO", " contextHome", "contextPath", "serviceRO", "conceptBase", "eventRoot", " contextroot", "ContextBase", "ContextPath", "Contextroot", "serviceGround", "ContextRoot", "eventroot", "serviceRoot", "conceptHome", "contextroot", "contextRO", "conceptroot", " contextGround", "ContextGround", "serviceroot", "resourceroot", "resourceRoot", "ContextHome", " contextBase", "contextHome", "contextGround", "contextBase", "ContextRO", " contextPath"], "pageURI": [" pageUR", "siteURL", "PageURI", "PageUR", " pageURL", "pageID", "pageURL", "siteUR", "endUR", "pageUR", " pageuri", "siteURI", "endURI", "PageURL", "endURL", "PageID", " pageID", "enduri", "siteID", "Pageuri", "pageuri"], "vtURLs": ["vtUrli", "vtURS", "vtUrlobs", "VTURls", "vtURLobs", "rtURLS", "VTURLs", "htURls", "VTURi", "htURLParts", "vtGETS", "vtIPS", "vtUrlS", "vtStreams", "vtUrllines", "vtURlines", "vtURLi", "rtURs", "vtURs", "vtURLls", "vtUrls", "vtUrlParts", "vtDownloadS", "vtIPes", "vtUrlls", "vtURls", "vturlls", "tvURLs", "vtURobs", "vtStreamParts", "vtGETs", "rtURLls", "VTURLlines", "vtDownloads", "rtURS", "tvURLes", "vturls", "vtRLes", "tvDownloadS", "vtURLes", "VTURLls", "htURobs", "vtRLs", "vtURParts", "vtURi", "htURs", "vtDownloades", "htURLobs", "htURLls", "vtURLS", "VTURlines", "tvURLS", "htURParts", "vtURLlines", "vtRLS", "vturllines", "vtStreamls", "vturli", "tvDownloades", "vtGETls", "vtURLParts", "rtURLs", "VTURLi", "VTURs", "vtStreamobs", "vtIPs", "tvDownloads", "rtURls", "htURLs"], "vtRobots": ["htRobots", "vtBots", "vtLogs", "vtRobs", "vtPlrots", "vtrobots", "VTRobOTS", "vtrobops", "VTGrougs", "vtBOTS", "htrobots", "vtBs", "VTProops", "vtRobrots", "vtRobops", "VTGroibraries", "vtPlugs", "vtPlibraries", "vtBlots", "vtBlops", "VTRobrots", "VTRobugs", "VTRobs", "vtPlots", "vtRobugs", "vtBops", "htRobOTS", "vtProOTS", "vtBlot", "VTRobibraries", "VTRobops", "htRobot", "vtLogOTS", "vtBlOTS", "VTProOTS", "vtLogops", "VTGrorots", "VTProots", "vtLogots", "vtrobOTS", "VTPros", "vtPros", "htRobops", "vtLegrots", "vtRobibraries", "vtGrorots", "vtBot", "vtLegugs", "vtrobot", "vtGrougs", "VTGroots", "VTRobots", "vtGroibraries", "htrobot", "vtProots", "vtLegots", "vtRobot", "htrobOTS", "vtGroots", "vtProops", "vtLegibraries", "vtRobOTS", "htrobops"], "indexer": ["indexers", " indexReader", " indexe", "Indexer", "indexe", "finder", "IndexER", " indexeer", "Indexeer", "finde", "fixed", " indexers", "indexed", "fixer", "indexReader", " indexER", "indexER", "checkER", "findReader", "checker", "indexeer", "Indexers", " indexed", "checkeer", "checkers", "fixReader", "finded", "fixe"], "indexDoc": ["indexDom", "documentdoc", "IndexDom", "documentPage", "indexdoc", "officePage", "officeDom", "IndexPage", "officedoc", "documentDoc", "IndexDoc", "Indexdoc", "officeDoc", "documentDom", "indexPage"], "sxURL": ["sxiDOM", "sxaUR", "SxURL", "dsxTL", "sxxDB", "dsxurl", "sxDB", "sxeUrl", "pxUrl", "dsxeurl", " sxDB", "sxcUR", "pxURI", "sxaurl", " sexUR", "sxiSSL", "sxcurl", "sexURL", " sxurl", "sxSSL", "sxbUrl", "swwURL", "sXUR", "snexTL", "dsxeUR", "sxLink", "lXSSL", "snexURL", "sxaURL", " sexUrl", "sxbUR", "lxUR", " sxURI", "sfxURL", "sxcURL", "dsxUR", "sfxSSL", "dsxeURL", "sxiUR", "sXDOM", "sexDOM", "sexSSL", "sxxUR", "sXURL", "SxUR", "sxeURL", "sexUrl", "sxeUR", " sXURL", "sxTL", "sXUrl", "pxcURI", "sxxurl", " sxUrl", "swwUrl", "sexurl", "dsxeTL", "sxtUR", "sxcLink", " sxcUrl", "sxaTL", "swwLink", " sxLink", "sxELF", "lxURL", "sfxURI", "sxtURL", "sXELF", "lXDOM", "sxUR", "lXURL", "sXSSL", "snexUR", "sXDB", "lxDOM", "sxtDB", "pxURL", "sxiURL", "lxSSL", " sexURL", " sxUR", "snexurl", "sfxUrl", "sfxUR", "sxtURI", " sexurl", "sxtUrl", " sXDB", "sxxUrl", " sxcUR", "sxturl", "SxELF", "lXUR", "SexELF", "sxcURI", " sxcurl", "dsxURL", "pxcURL", "sxcSSL", "SexURL", "sexELF", "sxeurl", "SexUrl", "sxDOM", "sxcUrl", " sxcSSL", "sxUrl", "sxeTL", " sXUR", " sxcURI", "sxbURL", "sxURI", "SexUR", "sxburl", "SxUrl", "sxurl", "sxeSSL", " sxSSL", "sexUR", "sxcELF", "pxcUrl", "sxxURI", "sxxURL", "swwUR", " sxcURL", "sXurl", " sXurl"], "sxRobotURL": ["sxRoboyPath", "sxRobogurl", "sxRobotTL", "sxRubotURL", "sxLooburl", "sxRobOTTL", "sxRobogURL", "sxRooyURL", "sxRoboyUrl", "sxRobogSSL", "sxRobortTL", "sxRoboURL", "sxLootSSL", "sxRobobCL", "sxRobootURL", "sxLooturl", "sxRobOTURI", "sxRoboburl", "sxRoboUrl", "sxRobotURI", "sxRobOTPath", "sxRobobURL", "sxRobotPath", "sxRubotPath", "sxLootTL", "sxRobotationURI", "sxRobOTCL", "sxLootURL", "sxRobobTL", "sxRoboyUR", "sxRobotUrl", "sxRobotSSL", "sxRootURL", "sxRoboyURL", "sxRobotCL", "sxRobOTURL", "sxRooyUR", "sxRubotUrl", "sxRobobSSL", "sxRobortURL", "sxRobobURI", "sxRoboUR", "sxRootUR", "sxRobOTUrl", "sxRobotUR", "sxRoboturl", "sxRuboURL", "sxLoobURL", "sxRobootTL", "sxLoobTL", "sxLoobSSL", "sxRuboUR", "sxRuboUrl", "sxRobotationURL", "sxRoboPath", "sxRobotationCL", "sxRobobUR", "sxRootTL", "sxRobogTL", "sxRobooturl", "sxRobortUR", "sxRuboPath", "sxRobOTUR", "sxRobootSSL", "sxRubotUR", "sxRooyTL", "sxRoboyTL", "sxRobotationUR"], "pd": [" cp", "lp", "ht", "p", "PD", "md", "ppa", "py", "CB", "bb", "wp", " md", " dd", " DD", "pb", "ds", "Parser", " db", "pg", "dl", "bf", " cd", "pc", " td", "vd", "pi", "gd", "APD", " pp", " PD", "dd", "cpp", "hd", "cd", "parser", " pm", "xd", "pp", "BT", "PF", "PB", " df", "pm", " sd", "d", " dc", " pdf", "td", "bd"], "cb": ["cv", "sb", "cf", "c", "CB", "obb", "bb", "fb", "buff", "cmd", " CB", " dd", "pb", "ca", "ff", "func", "bp", "kb", " db", "bf", " cd", "callback", "bc", "b", "BBC", " bc", "fd", " rc", "rb", "db", "gb", "fn", "eb", "cp", "handler", "cpp", "cm", "fc", "cd", "cod", "Callback", "ob", "ctx", "cmp", "bd", "dc"], "bIndexPage": ["bSearchpage", "bindexTable", "bbSearchPage", " bSearchpage", "bIndexFile", "bindexPage", " bindexpage", " bQueryLine", " bindexLine", "bbIndexpage", " bindexPages", "bLinkPage", " bIndexPages", " bQueryTable", "bbSearchpage", "bLinkFile", "bSearchLine", "bQueryFile", "bQueryLine", "bQueryTable", "nbLinkFile", "nbIndexpage", "bindexpage", "bLinkLine", " bQueryPage", " bIndexFile", "bShortpage", " bIndexTable", "bindexLine", "bShortLine", "bQueryPage", "nbIndexPage", "nbLinkpage", "bShortPage", " bIndexpage", "nbIndexLine", "bbIndexLine", "bSearchPage", "bindexPages", " bindexPage", "bSearchPages", "bSearchTable", "bIndexTable", " bQueryFile", "bIndexPages", "bLinkpage", " bIndexLine", "bIndexpage", "bindexFile", "nbLinkLine", "bLinkPages", "bIndexLine", " bSearchPages", "bbIndexPage", "nbIndexFile", "nbLinkPage", "bSearchFile", " bSearchPage", "bbSearchLine"], "urlConn": ["httpconn", "URLConnect", "serverCon", "urlCo", "UrlConf", "httpConnection", "fileConn", "urlBuff", "fileconn", " urlBuff", "httpConnect", "URLConn", "httpCon", "URLConnection", " urlConnection", "UrlConfig", "urlCon", "urlconn", " urlCon", " urlConnect", "URLConf", "fileConnection", "UrlBuff", "urlConfig", " urlCo", "fileConnect", "URLCo", "httpCo", "httpConn", "urlConnect", "URLconn", "URLConfig", " urlConfig", "URLBuff", " urlConf", "UrlConn", "serverConnect", "serverConn", "urlConf", "urlConnection", "serverConnection"], "modDate": ["MODTime", "ModTime", "ModDay", " modDat", "MODDay", "modDay", "MODDat", "modTime", "ModDate", " modTime", "ModDat", "modDat", " modDay", "MODDate"], "bfReader": ["bdWriter", "bfFile", "bbWriter", "bfRead", "btRead", "bbBuffer", "btWriter", "bdreader", "bfBuffer", "btreader", "BFWriter", "bbRead", "bdBuffer", "BFRead", "BFFile", "bbreader", "bfreader", "btReader", "bdReader", "bfWriter", "BFReader", "btFile", "bbReader", "btBuffer", "bbFile"]}}
{"id1": "8665649", "id2": "8490297", "code1": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"_getImage": ["_readimage", "_downloadImage", "_downloadImages", "_downloadThumbnail", "_getimage", "_readImage", "_parseThumbnail", "_parseImages", "_parseImage", "_readImages", "_getThumbnail", "_downloadimage", "_readThumbnail", "_getImages", "_parseimage"], "urlStr": ["imageSt", "urlText", "imageString", " urlText", "imagestr", "strStr", "urlstr", "urlSt", "imageStr", " urlSt", " urlSTR", "strString", "fileSTR", " urlString", "fileSt", " urlstr", "fileString", "urlString", "imageText", "fileStr", "imageSTR", "strstr", "urlSTR", "strText"], "url": ["ls", "org", "uri", "str", "client", "browser", "path", "Url", "c", "f", "config", "bb", "page", "l", "image", "build", "blog", "loader", "loc", "web", "object", "resource", "www", "job", "log", "b", "lc", "server", "host", "URL", "rl", "fl", "sl", "ch", "connection", "channel", "ll", "impl", "ssl", "r", "feed", "user", "http"], "conn": ["ls", "out", "sync", "client", "c", "Connection", "cmd", "nt", "socket", "Conn", "ci", "con", "close", "ad", "open", "act", "n", "connect", "pc", "conv", "exec", "conf", "ch", "api", "cur", "connection", "h", "nc", "cp", "enc", "impl", "cn", "rt", "cli", "err", "ssl", "ct", "ctx", "cb", "co", "http"], "in": ["source", "as", "init", "rec", "gin", "inn", "out", "token", "pin", "inner", "c", "ac", "f", "ax", "s", "gz", "ex", "i", "input", "socket", "image", "inas", "IN", "data", "m", "con", "ini", "win", "n", "isin", "bin", "din", "pc", "b", "null", "fd", "is", "nin", "min", "ins", "connection", "cin", "stream", "In", "again", "rin", "kin", "r", "err", "login", "ssl", "id", "reader", "inc"]}}
{"id1": "23296117", "id2": "16969205", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractLibrarylib", "extractedNativeLibrary", "extractLibraryLibrary", "extractednativelib", "extractnativeLib", "extractednativeLib", "extractnativeLibrary", "extractNativeLibrary", "extractedNativelib", "extractRemoteLib", "extractLibraryLib", "extractnativelib", "extractednativeLibrary", "extractNativelib", "extractRemotelib", "extractRemoteLibrary", "extractedNativeLib"], "sysName": ["SysDir", "systemPath", "SysPath", "sysDir", " sysPath", " sysFull", "libname", "ysname", "systemname", "ysName", " sysDir", " sysname", "systemFull", "systemName", "sysPath", "libTitle", "libName", "systemDir", "sysname", "sysFull", "sysTitle", " sysTitle", "Sysname", "SysFull", "SysName", "ysPath", "systemTitle", "libPath"], "name": ["source", "filename", "cache", "username", "NAME", "system", "title", "root", "word", "Name", "default", "loader", "data", "nm", "resource", "nice", "n", "base", "label", "number", "na", "string", "connection", "size", "prefix", "plugin", "nam", "named", "file", "part", "key", "id", "type", "no"], "load": ["call", "create", "init", "loading", "copy", "cache", "set", "sync", "parse", "push", "loaded", "check", "download", "leaf", "use", "hack", "link", "l", "dump", "skip", "read", "loader", "close", "open", "comment", "force", "Load", "play", "progress", " reload", "callback", "add", "null", "zip", "oad", "rc", "require", "lock", "cl", "loads", "write", "fail", "test", "wait", "save", "include", "pull", "cli", "pack", "remove", "ck", "launch", "get", "start", "delete", "LOAD"], "warning": ["message", "loading", "misc", "fp", " warn", "generation", "leaf", "breaking", "success", "watch", " warnings", "war", "notice", "loader", "web", "resource", "comment", "weak", "ws", "WARN", "Warning", "wa", "ww", "aw", "initial", "random", "fw", "blocking", "lang", "warn", "external", "alert", "only", "auto", "acl", "WARNING", "wild", "error", "ew"], "fullname": ["flatpath", "fullbase", "Fullpath", "realNAME", "fullnumber", "fullkey", "fulkey", " fullName", "realnamed", "fullyname", "fullykey", " fullbase", "fullybase", " fullnode", "flatname", "fulbase", "fullpath", "Fullname", " fullpath", "fulpath", " fullnamed", "fullypath", "fulname", " fullnumber", "fullName", "fulName", "fullynumber", "Fullnamed", "Fullnumber", "fullyName", "FullNAME", "flatnamed", " fullNAME", "Fullnode", "fullNAME", "flatName", "fulnode", "realpath", " fullkey", "fullnode", "realname", "fullnamed", "realName", "FullName"], "path": ["work", "text", "method", "ref", "filename", "cache", "uri", "str", "Path", "config", "link", "PATH", "ath", "pointer", "root", "image", "loader", "data", "object", "resource", "location", "base", "log", "code", "api", "string", "enc", "full", "filter", "file", "part", "route", "key", "id", "type", "parent", "pattern", "context"], "url": ["source", "org", "uri", "Url", "download", "f", "config", "bb", "il", "link", "l", "src", "serv", "image", "loc", "loader", "blog", "service", "resource", "location", "www", "base", "log", "bel", "server", "URL", "rl", "fl", "sl", "api", "address", "connection", "string", "channel", "fr", "ur", "coll", "lr", "ll", "impl", "file", "lib", "ssl", "ob", "http"], "conn": ["org", "init", "fp", "client", "sync", "net", "session", "c", "config", "reg", "Connection", "nt", "l", "serv", "Conn", "socket", "loc", "resp", "con", "open", "act", "n", "io", "connect", "log", "ann", "conv", "conf", "ch", "api", "rc", "connection", "nc", "channel", "lock", "cp", "enc", "coll", "cn", "rt", "ssl", "err", "cli", "ob", "ct", "dn", "ctx", "cb", "cmp", "http"], "in": ["pre", "source", "init", "cache", "inn", "gin", "client", "sync", "pin", "inner", "ac", "c", "f", "config", "s", "this", "i", "ie", "input", "src", "socket", "image", "inside", "serv", "IN", "data", "ini", "con", "win", "resource", "on", "n", "up", "bin", "a", "b", "exec", "nin", "child", "min", "index", "ins", "connection", "lock", "cin", "lin", "In", "inc", "again", "like", "file", "kin", "request", "pull", "part", "r", "err", "login", "ssl", "id", "reader", "din", "ic"], "targetFile": ["sourceDir", "resourceLine", "argetClass", "argetFolder", " targetFolder", "targetfile", "TargetStream", "sourceLine", "hostStream", "sourceDirectory", "argetFiles", " targetfile", "resourceFile", "TargetClass", "argetfile", "targetClass", "hostfile", "targetDirectory", "targetLine", "targetDir", "TargetFiles", "targetFiles", " targetDirectory", "resourceDirectory", " targetStream", "sourcePath", "TargetFile", " targetClass", "TargetDir", "targetFolder", "sourcefile", "resourcefile", "hostFile", "sourceFiles", "targetPath", "sourceFolder", "Targetfile", "resourceDir", "argetPath", " targetDir", "hostDir", "argetFile", "TargetDirectory", "targetStream", " targetLine", "sourceFile", "TargetPath", " targetFiles", " targetPath"], "out": ["source", "doc", "group", "call", "init", "app", "result", "cache", "output", "token", "client", "sync", "net", "inner", "at", "buf", "page", "w", "ex", "cmd", "one", "socket", "OUT", "line", "image", "default", "writer", "resource", "comment", "on", "io", "up", "n", "log", "null", "outer", "ext", "server", "obj", "exec", "post", "connection", "exp", "lock", "prefix", "plain", "option", "Out", "sum", "inc", "again", "block", "off", "file", "temp", "part", "err", "key", "login", "o", "user", "parent", "bin", "error", "target", "co"], "targetLastModified": ["targetLastSemified", "targetFirstModocked", "targetLastModIFIED", "targetLastPeded", "targetLastMODIFIED", "targetFirstMODocked", "targetFirstMODified", "targetFirstMinamed", "targetLastMinIFIED", "targetLastMinified", "targetFirstMined", "targetLastMinamed", "targetLastMODamed", "targetLastMified", "targetLastPedamed", "targetLastMocked", "targetFirstMODification", "targetFirstMinified", "targetFirstModamed", "targetLastPedified", "targetLastModamed", "targetLastModocked", "targetLastModed", "targetLastMODed", "targetLastSemification", "targetLastPedIFIED", "targetFirstModification", "targetLastModification", "targetFirstMODed", "targetLastSemocked", "targetLastSemed", "targetLastMed", "targetLastMification", "targetLastMined", "targetFirstModified", "targetLastMODification", "targetFirstModed", "targetFirstModIFIED", "targetLastMODocked", "targetLastMODified", "targetFirstMinIFIED"], "sourceLastModified": ["sourceLastImated", "sourceLastModed", "sourceFirstMODated", "sourceLastmodified", "sourceLastImified", "sourceFirstMODIFIED", "sourceFirstModified", "sourceLastImification", "sourceLastmoded", "sourceLastModated", "sourceLastMinIFIED", "sourceLastModIFIED", "sourceLastMification", "sourceFirstMODified", "sourceFirstMODed", "sourceLastMified", "sourceLastImed", "sourceLastMODification", "sourceFirstModification", "sourceLastModification", "sourceLastMated", "sourceLastMinified", "sourceFirstModIFIED", "sourceLastmodIFIED", "sourceFirstModated", "sourceLastMODified", "sourceLastMODated", "sourceLastMODed", "sourceLastMODIFIED", "sourceFirstModed", "sourceLastMed", "sourceFirstMODification", "sourceLastMined"], "len": ["lf", "ln", "str", "length", "net", "z", "f", "nt", "lim", "ler", "l", "pos", "count", "line", "val", "lon", "data", "n", "limit", "num", "lc", "fin", "fl", "sl", "min", "li", "body", "size", "cl", "el", "lin", "en", "Len", "iter", "part", "err", "end", "id", "le", "bin", "no"]}}
{"id1": "14053882", "id2": "8917658", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static void copyAll(URL url, Writer out) {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new BufferedInputStream(url.openStream()));\n            copyAll(in, out);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            close(in);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["enccode", " encryptcode", "decrypt", " encryptrypt", "decryption", " enipher", " encryptryption", "deccode", "decipher", "encipher", " enrypt", " enryption", "encryption", " encode", " encryptipher"], "plaintext": ["plainsource", " plaincontent", "encryptedstruct", "givenfont", " plainText", "protectedText", "plainstring", "batsource", "plainfont", "givenstring", "encryptedtext", " plainstring", "plainstruct", "batfont", "protectedstruct", "givensource", " plainfont", "protectedtext", "plaincontent", "plainText", " plainsource", "battext", "batstring", "encryptedText", "protectedcontent", "giventext", " plainstruct", "encryptedcontent"], "md": ["mand", "hm", "alg", "mm", "mp", "mod", "amd", "Cmd", "wd", "dig", "cmd", "dm", "po", "mb", "meta", "material", "mg", "data", "m", "ph", "da", "pg", "mage", "metadata", "ad", "mad", "mac", "nm", "sm", "ms", "code", "kg", "pd", "sha", "dr", " MD", "od", "dd", "cm", "mo", "mt", "hd", "cd", "am", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "cb", "d", "bd", "dc"], "raw": ["text", "buffer", "json", "dec", "clean", "empty", "load", "instance", "rew", " RAW", "buf", "unsigned", "input", "image", "shared", "Raw", "data", "unknown", "auth", "binary", "original", "array", "null", "initial", "sha", "hex", "ack", "rc", "string", "stream", "enc", "wrapper", "full", "block", "serial", "pure", "row", "wave", "pack", "response", "feed", "partial", "RAW"], "hash": ["secret", "message", "buffer", "cache", "ashes", "length", "ash", "image", "kh", "data", "auth", "mac", "url", "base", "log", "array", "Hash", "password", "sha", "hex", "index", "h", "header", "sum", "sh", "block", "ha", "html", "version", "key", "response", "href", "her", "id", "rh"]}}
{"id1": "7981642", "id2": "9479502", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"update": ["text", "edit", "create", "init", "copy", "set", "push", "check", "config", "send", "build", "updated", "data", "auth", "Update", "up", "and", "url", "u", "add", "change", "setup", "exec", "password", "post", "address", "append", "h", "UPDATE", "write", "sum", "replace", "put", "save", "insert", "register", "key", "sign", "login", "end", "apply", "user", "delete"], "mail": ["text", "contact", "source", "message", "group", "local", "who", "md", "uri", "phone", "username", "hello", "date", "alt", "company", "model", "front", "view", "gal", "m", "dial", "folder", "proxy", "old", "ip", "Mail", "url", "name", "server", "host", "ge", "label", "password", "msg", "zip", "address", "string", "lock", "ul", "Email", "fax", "html", "mails", "office", "file", "value", "login", "dir", "gmail", "id", "user", "xml"], "email": ["text", "message", "md", "uri", "phone", "username", "hello", "eu", "home", "info", "alt", "wd", "model", "archive", "note", "nick", "enter", "line", "cdn", "xml", "addr", "folder", "old", "ip", "n", "description", "online", "Mail", "url", "class", "name", "log", "server", "host", "password", "zip", "address", "li", "inet", "element", "el", "Email", "fax", "en", "office", "cn", "mails", "file", "dn", "login", "dir", "gmail", "id", "ail"], "pwd": [" pwa", "pws", "Ppassword", "cpws", "hwd", "ppass", " pWD", "cpwt", "pppassword", "ppwh", "hpass", "Ppass", "ppassword", "PWD", "pppass", "pwa", "hWD", " pws", "ppwd", "Pwt", " pwh", "hwa", " ppassword", "Pwh", "pwt", " pwt", "Pws", "cpWD", "pwh", "cpwd", "Pwa", "Pwd", "pWD", " ppass"], "firstname": ["caseName", "firstkey", "firstnames", "newname", "lastemail", "lastkey", "firstName", "hostName", "casepass", "lastpass", "lastnames", " firstName", "newnames", "hostkey", " firstkey", "firstuser", " firstemail", " firstpass", "firstemail", " firstuser", "hostname", "hostemail", "newuser", "firstpass", "lastuser", "caseemail", "casename", "lastName", " firstnames"], "lastname": ["firstkey", "firstn", "firstnames", " lastkey", " lastn", "lastday", "secondName", " lastName", "lastkey", "firstName", "secondkey", " lastnames", "lastaddress", "lastnames", "secondaddress", "secondname", " lastaddress", "firstday", "fullName", "fullname", "fullnames", "fullday", "firstaddress", "lastn", " lastday", "fulln", "lastName"], "connection": ["relation", "management", "client", "cf", "connected", "session", "c", "config", " Connection", "system", "this", "Connection", "ca", "conn", "Conn", "manager", "condition", "m", "con", "object", "communication", "directory", "connect", "document", "bc", "database", "b", "lc", "graph", "server", "pool", "sc", "function", "index", "cc", "h", "nc", "di", "handler", "creator", "response", "ion", "db", "context", "application"], "attrs": ["attr", "attks", "attars", "Attras", "attRS", "addRS", "attps", "matps", "atacts", "Attars", " attr", "attras", "addks", "addras", " attributes", "Attr", "atks", "addr", "Attributes", "matars", " attRs", "atRS", "matrs", " attps", "attacts", "addRs", "Attrs", "attributes", "Attps", "AttRs", "attRs", "atars", "atras", "Attacts", " attars", " attacts", "atps", "addars", "matributes", "atributes", "addributes", "atr", " attks", "addps", "atrs", " attRS", "addrs"], "sha": ["shi", "md", "mm", "alias", "va", "ca", "asha", "meta", "ema", "da", "pg", "ami", "mac", "ua", "pa", "sa", "ga", "wa", "base", "si", "sm", "a", "SHA", "lambda", "password", " SHA", "pi", "na", "h", "sche", "eta", "alpha", "sh", "sum", "acl", "ha", "HA", "ma", "ya", "ka", "la", "hi", "volume"], "digest": [" diged", "modEST", "Digester", "Digests", "mdested", "tagester", "DigEST", "digEST", "Digcode", "digested", " digests", "tagcode", "mdester", "diged", "mdgest", "moded", "modests", "diggest", "digests", " digEST", "tagest", " digcode", "Digest", "modest", " diggest", " digested", "Diggest", "Digested", "mdest", "digester", "digcode", " digester", "Diged", "tagested"], "hash": ["secret", "match", "message", "bh", "hed", "json", "cover", "ash", "ag", "dig", "image", "build", "kh", "auth", "mac", "url", "base", "array", "Hash", "code", "password", "hex", "body", "h", "enc", "sum", "sh", "raw", "block", "ha", "html", "value", "version", "key", "her", "user", "rh", "bin"], "ctx": ["cv", " cs", "cs", "xc", "client", "cf", "ctrl", "c", "config", "tc", " conn", "ca", "conn", "hw", "Context", "tx", "ci", "loc", "cci", "cas", "bc", "pc", " cx", "conv", "lc", " c", "fw", "cr", "sc", " rc", "rc", "cc", "cp", "cl", "jp", "qa", "cm", "sq", "cca", "cu", "cn", "vc", "anc", "mc", "ct", "pkg", "ck", "cb", "cmp", " context", "context"], "newName": [" newEmail", " newname", "Newname", "NewEmail", "newEmail", "oldname", "oldEmail", " newAddress", "NewAddress", "NewName", "oldAddress", "newname", "newAddress"], "oldName": ["oldname", "OldHome", "OldPath", " oldAddress", "origPath", "newEmail", "OldAddress", "oldAddress", " oldname", " oldHome", "OldName", "oldEmail", "Oldname", "origName", " oldPath", "newAddress", "origname", "origEmail", "newHome", " oldEmail", "oldPath", "oldHome", "OldEmail"]}}
{"id1": "18217985", "id2": "20735941", "code1": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"fromHtml": ["fromHText", "fromBushttp", " fromChText", "fromShhtml", " fromHUrl", "fromPhttp", "fromChText", "fromHttpText", "fromBushtml", " fromChUrl", "fromShUrl", "fromChhtml", " fromChhtml", " fromPhHTML", "fromHttp", "fromHttptml", " fromPhttp", " fromHText", "fromBushHTML", " fromHml", "fromHttpUrl", "fromHhtml", "fromPhml", "fromChUrl", "fromHttpHTML", "fromChtml", "fromHttpml", " fromHhtml", "fromHml", " fromHHTML", " fromPhml", "fromHttpttp", "fromHHTML", "fromHttphtml", "fromPhHTML", " fromChtml", " fromPhtml", "fromHUrl", "fromPhtml", "fromBushml", "fromShtml", " fromHttp", "fromShText"], "url": ["text", "source", "org", "ref", "remote", "uri", "str", "client", "browser", "path", "Url", "download", "config", "f", "page", "domain", "il", "link", "input", "l", "image", "or", "loc", "loader", "blog", "web", "service", "object", "location", "builder", "resource", "open", "email", "www", "base", "name", "server", "host", "article", "URL", "obj", "address", "ch", "sl", "api", "connection", "string", "ur", "lr", "html", "file", "cli", "r", "ssl", "response", "id", "xml", "http"], "defaultEncoding": ["currentEnoding", " defaultEncasing", "defaultencode", "currentEnoded", "defaultChoding", " defaultencoding", "currentEncoding", "defaultCoder", "defaultencasing", " defaultCasing", "defaultEnode", "defaultCoded", "defaultEngoding", "defaultEngoder", " defaultCoding", "defaultEncoder", "defaultEnoding", "defaultChasing", "defaultEnasing", "currentEncoded", " defaultencoder", "defaultEngasing", " defaultCoded", " defaultencoded", " defaultencasing", "defaultEncode", "currentEncasing", "defaultencoder", " defaultCoder", "defaultencoded", "defaultEnoded", " defaultEncoder", "defaultencoding", "defaultCoding", "defaultChoded", "defaultEncasing", "currentEnode", "defaultChode", "currentEnasing", "defaultCasing", " defaultEncoded", "defaultEngoded", "defaultEncoded", "defaultEnoder", "currentEncode"], "overrideEncoding": ["overwriteEncoding", "overrideEnoding", "overrideencoder", "overrideEncoder", "overrideCoding", "overwriteEnoded", "overrideEnasing", "overrideCoded", "overwriteEnoding", "overrideEncoded", "overrideEncasing", "overrideCoder", "overwriteEnasing", "overrideencasing", "overwriteEncoder", "overwriteEncoded", "overwriteEncasing", "overrideencoding", "overrideEnoder", "overwriteEnoder", "overrideEnoded", "overrideCasing", "overrideencoded"], "conn": ["out", "client", "sync", "session", "cb", "c", "config", "f", "dc", "reg", "Connection", "cmd", "nt", "l", "serv", "Conn", "socket", "loc", "con", "close", "open", "ad", "act", "n", "connect", "ann", "conv", "server", "exec", "conf", "ch", "api", "connection", "nc", "cp", "enc", "coll", "sql", "cn", "err", "ssl", "cli", "dn", "ct", "ctx", "db", "co", "http"], "contentType": ["enctype", "resourceName", "contentClass", "ContentLine", " contentFormat", "documentName", "ContentClass", "contentPath", "ContentUnit", "codeFile", "filetype", "languageStyle", " contentText", "inputPath", "wordtype", "inputUnit", " contentUnit", "documentType", "ontentPath", "inputType", "documentInfo", "ContentFile", "encLength", "contentFile", "codeType", "fileType", "contentToken", "contentText", "wordType", "languagetype", " contentLength", "ontentClass", "inputLine", "codetype", "inputtype", "contentName", "ContentLength", "ContentType", "ContentPath", "languageInfo", " contentName", "wordName", "codeInfo", "languageType", " contenttype", "codeStyle", " contentToken", "ontentType", "contentStyle", "fileFile", "ContentText", "contentLength", "ontentName", " contentStyle", " contentClass", " contentLine", "workType", "Contenttype", "contenttype", "resourceLength", "workToken", "codeName", "ContentName", " contentFile", "contentInfo", "filePath", "ContentInfo", "resourceInfo", "contentFormat", "ontentLength", "resourceUnit", "contentLine", "resourcetype", " contentPath", "workLength", "worktype", "documentText", "ontentFormat", "encToken", "encType", "resourceType", "codeUnit", "ContentFormat", " contentInfo", "contentUnit"], "encoding": ["enhoding", "equoding", "enhode", "engoded", "Encoding", "execoded", "encoded", " encapping", "enaching", "encode", "encryption", "encasing", "Encasing", "collasing", "casing", "equapping", "enhryption", "encoder", "ecasing", "enhasing", "Encoded", "colloded", "Encryption", "Encode", "coding", "execoding", " encryption", "engoder", "engapping", "coder", "enoded", "caching", "colloding", "enoding", "execoder", "execasing", " encosing", "encaching", "enosing", "ecoding", "Encaching", "enoder", " encode", "engosing", "ecoded", "colloder", "equosing", "equoded", " encoder", "encosing", " encasing", "engasing", "engoding", "enasing", "Encoder", "encapping", "ecoder", "equoder", "coded"], "i": ["p", "x", "init", "uri", "c", "ni", "f", "ai", "gi", "ii", "ori", "ix", "info", "ei", "e", "ie", "l", "I", "area", "ci", "yi", "abi", "ini", "multi", "ip", "io", "bi", "iu", "si", "u", "lc", "is", "ui", "pi", "api", "ji", "li", "j", "h", "oi", "hi", "mi", "di", "qi", "eni", "xi", "fi", "cli", "t", "mu", "slice", "o", "id", "zi", "adi", "v", "ri", "ti", "phi"], "s": ["p", "ls", "source", "as", "su", "ps", "sb", "ts", "ss", "str", "sync", "session", "c", "f", "sym", "e", "sg", "l", "ds", "m", "service", "strings", "ws", "n", "g", "a", "si", "ses", "u", "os", "b", "fs", "sl", "string", "h", "ins", "enc", "details", "gs", "en", "settings", "ns", "abs", "es", "r", "ssl", "t", "o", "sv", "site", "S", "v", "js", "d"], "expected": [" e", "nexpected", "style", "pecting", " Expect", "current", "reported", "wrong", "actual", "pect", "info", "event", "pected", "e", "ie", "needed", "ed", "default", "updated", "required", "example", "found", "allowed", "format", "email", "yet", "latest", "supported", "force", " ie", " received", "next", " unexpected", "fake", " accepted", "opened", "host", " expecting", "seen", "specified", " expects", "now", "ception", "pretty", "handled", "element", "encrypted", " expect", "received", "provided", "failed", "illegal", " event", " expectation", "response", "entry", "acceptable", "forced", "type", " email", "error", "target"], "index": ["x", "match", "edit", "column", "position", "shape", "current", "output", "length", "update", "point", "date", "info", "all", "page", "ix", "level", "input", "pos", "none", "ind", "loc", "condition", "ini", "object", "open", "where", "find", "connect", "num", "search", "array", "Index", "width", "number", "address", "list", "size", "prefix", "alpha", "option", "element", "sort", "weight", "value", "version", "pull", "key", "slice", "end", "id", "unit", "type", "diff", "inc", "offset", "active"], "msg": ["text", "og", "message", "sim", "Message", "ug", "str", "info", "reg", "title", "rr", "ag", "mr", "cmd", "sg", "agg", "fg", "format", "mess", "g", "log", "name", "ms", "reason", "Msg", "gen", "printf", "mid", "gm", "lang", "dr", "details", "mt", "gs", "mit", "desc", "MS", "ma", "err", "comm", " message", "error", "doc"], "in": ["p", "as", "buffer", "rx", "gin", "inn", "out", "inner", "c", "ax", "input", "inas", "xml", "read", "IN", "data", "ini", "win", "con", "io", "din", "b", "dr", "ins", "connection", "fr", "stream", "In", "impl", "inc", "rin", "r", "err", "login", "id", "reader", "bin", "tin"]}}
{"id1": "18011804", "id2": "1986417", "code1": "    public FileChooserTestFrame() throws HeadlessException, MalformedURLException {\n        super();\n        addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent aEvent) {\n                System.exit(0);\n            }\n        });\n        Dimension dim = getToolkit().getScreenSize();\n        Rectangle abounds = getBounds();\n        setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2);\n        setVisible(true);\n        URL url = new URL(\"ftp://cendantstp/\");\n        char[] password = \"spnr\".toCharArray();\n        PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password);\n        FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication);\n        JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView);\n        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\n        fileChooser.setMultiSelectionEnabled(true);\n        File[] selectedFiles = null;\n        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {\n            selectedFiles = fileChooser.getSelectedFiles();\n            for (int i = 0; i < selectedFiles.length; i++) {\n                if (selectedFiles[i] instanceof FTPFileFile) {\n                    FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i];\n                    logger.fine(ftpFile.getName());\n                    logger.fine(ftpFile.getPath());\n                } else {\n                    logger.fine(selectedFiles[i].toString());\n                    logger.fine(selectedFiles[i].getAbsolutePath());\n                }\n            }\n        }\n        remoteFileSystemView.disconnect();\n        try {\n            if (null != selectedFiles) {\n                FTPClient ftpClient = new FTPClient();\n                InetAddress inetAddress = InetAddress.getByName(url.getHost());\n                ftpClient.connect(inetAddress);\n                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {\n                    throw new FTPBrowseException(ftpClient.getReplyString());\n                }\n                if (null != passwordAuthentication) {\n                    ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString());\n                }\n                for (int i = 0; i < selectedFiles.length; i++) {\n                    FTPFileFile file = (FTPFileFile) selectedFiles[i];\n                    logger.fine(file.getPath());\n                    FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\"));\n                    logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos));\n                    fos.close();\n                }\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(0);\n    }\n", "code2": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"HeadlessException": ["Headfulception", "headlessException", "HeadLessException", "HeadingException", "headfulception", "Headingception", "Headlessception", "HeadfulException", "HeadLessception", "headlessception", "headfulException"], "MalformedURLException": ["MalformedURLEncException", "MalformedURLArceptions", "MalformedURLExrupt", "MalformedURLExpception", "MalformedURLArception", "MalformedURLAxException", "MalformedURLExceptions", "MalformedURLArrupt", "MalformedURLExprupt", "MalformedURLErceptions", "MalformedURLAxceptions", "MalformedURLExException", "MalformedURLErception", "MalformedURLEncception", "MalformedURLEncceptions", "MalformedURLAxrupt", "MalformedURLExpException", "MalformedURLErException", "MalformedURLExpceptions", "MalformedURLErrupt", "MalformedURLArException", "MalformedURLAxception", "MalformedURLEncrupt"], "aEvent": [" keyboardEvent", " keyboardName", " keyboardAdapter", " oAdapter", " oEvent", " aAdapter", " keyboardFilter", " videoEvent", " aName", " aFilter", " oFilter", " videoAdapter", " videoName", " videoFilter", " oName"], "dim": [" pixels", "uv", "shape", " imm", "marg", "im", " disp", "large", "mm", "medium", "py", "lat", "lim", "dm", "imm", "ds", "project", "dimension", "loc", "img", "multi", " cm", "width", "du", "vm", "dt", "rect", "center", "ims", "dat", "dem", "dr", "tm", "gb", "div", "size", " img", "di", "bm", "detail", "cm", "height", "scale", "grid", "coord", "dom", "Dim", "sam", "db", "d", "cam", "dc"], "abounds": ["bbox", "acound", "bbbox", " abound", "Abands", "abound", "abounding", "bounding", "Abounding", "Aborders", " abounding", "bbounding", "borders", "obbox", "Abound", "bbound", "acands", "bound", "obounding", "obounds", " aborders", "Abounds", "bbounds", "abbox", "aborders", "abands", "bounds", "acounding", " abands", "obound", "acounds"], "url": ["text", "source", "ref", "gl", "buffer", "uri", "str", "browser", "client", "path", "username", "Url", "download", "f", "config", "https", "page", "input", "l", "image", "loc", "data", "loader", "web", "service", "location", "email", "resource", "www", "base", "name", "server", "host", "URL", "fl", "address", "sl", "string", "connection", "channel", "ssl", "href", "feed", "id", "user", "http"], "password": ["account", "text", "secret", " passwords", "words", "token", "path", "username", "language", "alias", "wd", "pass", "phrase", "command", "word", "padding", "data", "resource", "email", "auth", "sudo", "description", "name", "sword", "security", "address", "wallet", "connection", "channel", "size", "prefix", "Password", "attribute", "ssl", "login", "key", "user", "pattern"], "passwordAuthentication": ["passwordAfficating", "passwordCommunicator", " passwordAuthenticating", " passwordAuthenticator", "passwordAuthicating", "PasswordAuthentection", "passwordAfficator", "passwordAuthentection", "PasswordAuthication", "passwordAffection", "passwordCommunicating", "PasswordAuthenticating", "PasswordAuthentication", " passwordCommunication", "passwordAuthication", "passwordAuthenticator", "PasswordAuthection", "PasswordAuthicator", "passwordAuthicator", "PasswordAuthicating", "passwordAuthenticating", " passwordAuthentection", "passwordCommunection", " passwordCommunicating", "PasswordAuthenticator", " passwordCommunicator", "passwordAuthection", " passwordCommunection", "passwordAffication", "passwordCommunication"], "remoteFileSystemView": ["remoteFileystemView", "remoteFileystemManager", "remotefileystemview", "remoteFileSystemVIEW", "remoteFileystemVIEW", "remoteFileNameView", "remoteFilesystemVIEW", "remoteFilesystemview", "remoteFileSystemManager", "remoteFilesSystemClient", "remotefileSystemClient", "remoteFilessystemview", "remoteFileNameview", "remoteFileServerClient", "remotefileSystemManager", "remotefileystemVIEW", "remotefileServerClient", "remotefileSystemVIEW", "remoteFilesSystemView", "remoteFileServerManager", "remotefileServerManager", "remotefileystemView", "remoteFileystemview", "remotefileSystemview", "remoteFileServerView", "remoteFilesSystemview", "remotefileSystemView", "remoteFileystemClient", "remoteFileSystemClient", "remotefileServerView", "remoteFilesystemClient", "remoteFilesystemManager", "remoteFilessystemView", "remoteFileNameVIEW", "remoteFilessystemClient", "remotefileystemManager", "remoteFileNameManager", "remoteFilesystemView", "remoteFileSystemview"], "fileChooser": ["resourceChose", "fileChoker", "fileChoosen", "fileSeoser", "FileCloser", "fileCloser", "fileChoiser", " fileClressor", "fileVooker", "fileDeclosen", "resourceChoker", "fileChoosing", "fileVoose", " fileChoose", "FileCloker", "resourceChooser", "fileClosing", "fileComposes", "FileChoose", "fileJoose", "FileClose", "fileClosen", "fileCompressor", "fileCliser", " fileCloser", "fileChooses", " fileClose", "fileSeose", " fileCloses", "fileChiser", "resourceChoose", "fileSeoker", "FileChooker", "fileVoosen", "FileClosing", "FileClosen", "fileChose", "fileChoressor", "fileCloker", "fileCloses", "fileJooser", "fileChoser", "resourceCliser", "fileDecloser", "fileChoose", "fileVoosing", "FileChoosen", "fileVooser", "resourceChoser", "resourceCloser", "resourceChosen", "fileDecliser", "resourceClose", "resourceChooker", "fileChosen", " fileChoressor", "FileChoosing", "FileChooser", "fileClose", "resourceChoiser", "fileClressor", "fileCompose", "resourceChoosen", "fileComposer", "fileChooker", "fileJoressor", "fileDeclose", "fileSeosen", "resourceClosen", " fileChooses", "fileJooses"], "selectedFiles": ["lectedfiles", "matchedfiles", " selectedBooks", "selectedResources", "selectionImages", "selectedThings", "lectedTags", "matchedBooks", " selectedImages", "lectedApplications", "lectedContents", "selectionFiles", "selectedBlocks", "selectionLS", " selectedResources", "lectedLS", "matchedThings", " selectedQuestions", "registeredFiles", "selectionTags", " selectedLS", "selectedApplications", "lectedOps", "registeredImages", " selectedContents", "currentfiles", "registeredfiles", "registeredBlocks", "testedFiles", "currentFile", "selectedOps", "currentFiles", " selectedOps", "lectedQuestions", "publishedFile", "selectedImages", "matchedQuestions", "publishedfiles", " selectedThings", "selectionThings", "testedApplications", "selectedQuestions", "testedOps", "selectionfiles", " selectedFile", "lectedFile", "selectedTags", "selectedContents", " selectedfiles", "publishedContents", " selectedBlocks", " selectedApplications", "currentResources", "selectedLS", "lectedImages", "lectedBlocks", "selectedFile", " selectedTags", "publishedFiles", "selectedfiles", "lectedBooks", "matchedFiles", "lectedFiles", "selectedBooks", "publishedResources"], "i": ["p", "x", "uri", "inner", "c", "ni", "ai", "f", "info", "ii", "gi", "ix", "e", "d", "ie", "l", "I", "k", "count", "ci", "vi", "data", "m", "ini", "in", "multi", "ip", "n", "bi", "iu", "io", "si", "g", "u", "b", "it", "iv", "ui", "pi", "oi", "index", "li", "j", "h", "hi", "di", "qi", "y", "xi", "part", "fi", "key", "r", "slice", "id", "o", "diff", "type", "v", "start", "ri", "ti"], "ftpFile": ["ftapFiles", "ptpFiles", " ftapFile", "ftpeMessage", "fttpImage", "ftapfile", "ftPFile", "nttpChat", " ftpfile", "ftPPart", "ftpeFile", "ftapFolder", "ftapFile", "ftfFiles", "ntpImage", "ftfMessage", "ptpeFile", "ntpChat", "ftffile", "ftPMessage", "nttpImage", "fttpFiles", "ftiImage", "ftiFiles", "ptpeMessage", "ftpeFiles", "ftiChat", "ntpFiles", "ptpeFiles", " ftpFiles", "ftiFile", "ftcFile", " ftapfile", "ntpFile", "fttpChat", "nttpFiles", "ftfImage", "ftpFolder", "ftpImage", "ftfFile", "ftfChat", "ftpePart", "ftfFolder", "ftpfile", "ftfPart", "ftpMessage", "ftcFiles", "nttpFile", "ftPFiles", "ftpPart", "ftcFolder", " ftapFolder", " ftapFiles", " ftpFolder", "fttpFile", "ptpMessage", "ftpFiles", "ptpFile", "ptpePart", "ftcfile", "ftpChat", "ptpPart"], "ftpClient": ["ftpHost", "ftsclient", "ftapiCan", "ctcpCan", "ftpcCan", "ftpclient", "ftapiView", "ftpCan", "ftcpServer", "ctcpClient", " ftpclient", "ctpCan", "ftpServer", " ftpView", "ftpcHost", "ctpServer", "ftpiclient", "ctpHost", " ftsClient", "fttServer", " ftsCan", " ftsclient", "ftapiclient", " ftsView", "ftcpClient", "ftpView", "ctcpServer", "ctcpHost", "fttCan", "ftcpHost", "ftapiClient", "ftsView", "ftpcClient", "fttClient", "ftsClient", " ftpCan", "fttHost", "ftcpCan", "ftsCan", "ctpClient", "ftpiView", "ftpiClient", "ftpcServer", "ftpiCan"], "inetAddress": ["remoteZone", "networkAddress", "etAddress", "remotePort", "socketPort", "etZone", "etPort", "inetSocket", "socketAddress", "etHost", "remoteSocket", "targetHost", "targetLocation", "etSocket", "networkPort", "networkLocation", "targetAddress", "networkHost", "etLocation", "inetLocation", "remoteAddress", "targetPort", "inetZone", "socketZone", "inetPort", "inetHost", "socketSocket"]}}
{"id1": "5744493", "id2": "15580610", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": ["newFileCopy", " dofileWrite", "newFilecopy", "newFileWrite", " dofileCopy", " doFoldercopy", " doBlockCopy", " dofilecopy", " doFileCopy", "newBlockcopy", " doFileWrite", "newBlockWrite", " doBlockWrite", " doBlockcopy", " doFilecopy", " doFileProxy", "newBlockProxy", " doFolderCopy", " doFolderWrite", "newFileProxy", " doBlockProxy", " doFolderProxy", " dofileProxy", "newBlockCopy"], "in": ["source", "buffer", "inn", "pin", "inner", "c", "config", "ex", "i", "input", "image", "IN", "data", "m", "win", "isin", "bin", "url", "base", "name", "b", "query", "min", "index", "ins", "lock", "lin", "In", "again", "file", "part", "err", "login", "id", "reader", "diff", "inc"], "out": ["dot", "pre", "source", "buffer", "copy", "cache", "output", "point", "page", "ex", "socket", "OUT", "conn", "image", "default", "writer", "resource", "io", "base", "name", "b", "ext", "server", "exec", "string", "external", "connection", "plain", "prefix", "Out", "write", "outs", "again", "off", "file", "temp", "part", "o", "user", "v", "target"], "inChannel": ["outSocket", "Inchannel", "outchannel", "inClient", "inChan", "InChan", " inchannel", "inputChannel", "inputChan", "binSocket", "INChannel", "INChan", "INStream", "inputSocket", "binChannel", "INSocket", "InStream", "outClient", " inChan", " inClient", "InChannel", "inchannel", "inputStream", " inStream", " inSocket", "INClient", "outChan", "outStream", "binChan", "InSocket", "INchannel", "inStream", "inSocket", "binStream"], "outChannel": ["outSocket", "outchannel", "againSocket", "OutChan", "inChan", "intchannel", "OutContainer", "intChan", "againChan", " outStream", "outBuffer", "outContainer", " outButton", "inButton", "outButton", " outChan", " outchannel", "inContainer", "againChannel", "inchannel", "inBuffer", "OutBuffer", " outContainer", "OutStream", "outChan", " outSocket", "outStream", "againStream", "intButton", "intChannel", "OutChannel", " outBuffer", "inStream", "inSocket"], "maxCount": [" maxLength", " maxSize", "axCount", "maxSum", "axLength", "blockCount", "Maxcount", " maxcount", "blockSize", "axcount", "MaxSize", "MaxSum", "blockcount", " maxSum", "MaxLength", "axSize", "MaxCount", "maxSize", "blockSum", "maxcount", "maxLength"], "size": ["p", "seek", "position", "shape", "mode", "length", "available", "fee", "empty", "shift", "SIZE", "len", "bytes", "send", "max", "count", "loc", "data", "Size", "n", "speed", "limit", "name", "small", "width", "sized", "capacity", "transfer", "address", "min", "time", "ize", "range", "sum", "scale", "en", "cap", "end", "unit", "type", "flush", "start", "offset", "volume"], "pos": ["p", "ref", "position", "pt", "port", "length", "push", " position", "point", "slot", "len", "pass", "i", "pointer", "Pos", "po", "count", "val", "loc", "data", "open", "pose", "limit", "no", "base", "os", "cos", "spec", "obj", "address", "min", "index", "neg", "POS", "block", "iter", "pid", "off", "part", "slice", "id", "unit", "diff", "o", "start", "offset", "rel"]}}
{"id1": "8801436", "id2": "7296597", "code1": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copy": [" cp", "source", "create", "sync", "paste", "load", "download", "cat", "update", "cross", "archive", "link", "Cop", "move", "image", "process", "open", "cop", " copying", "clone", "rm", "clip", "share", "change", "ge", "transfer", " transfer", "zip", "split", "upload", "Copy", "cp", "attach", "opy", "ize", "write", " Copy", "save", "ignore", "type", "delete"], "from_file": ["from67auto", " from_connection", "fromingclass", "to_files", "from_parent", "fromfsingle", " from_folder", "from2file", " from_directory", "from_cache", "from_class", " from_function", "source_parent", "to_File", "fromffiles", "from2File", " from_money", "from_function", "from_directory", " from_files", "fromingmoney", "to_user", "from_files", "fromffolder", "from67file", "from_folder", "from_single", "from_money", " from_single", "from_user", "source_file", "from2source", " from_auto", "from_auto", " from_File", "from67directory", "fromffile", "from67files", "from_connection", "source_cache", "fromingfile", "from_File", "to_source", "from2files", "from_source", " from_class"], "to_file": ["to_files", "to_letter", "from_model", "toPfiles", "to_string", "to_global", "to_get", "to_name", "To_resource", "To_directory", " to_path", "to_resource", "to_path", " to_string", "to_model", "totheglobal", " to_get", "toPname", "to_folder", "tothefile", "to_image", "from_name", " to_source", "from_filename", "toPfile", " to_resource", "from_files", "To_mail", "from_folder", "tothefolder", "to_filename", " to_directory", " to_global", "to_directory", "to_mail", " to_folder", "from_image", "to_source", " to_letter", "To_file", "tothesource"], "parent": ["source", "remote", "cache", "current", "session", "ca", "loc", "location", "ip", "directory", "url", "name", "search", "null", "pool", "rule", "div", "size", "pid", "key", "any", "type", "section", "uri", "client", "ppa", "home", "root", "po", "tree", "data", "pa", "term", "api", "layer", "parser", "test", "Parent", "anc", "partial", "id", "unit", "path", "point", "folder", "resource", "and", "container", "par", "pr", "inc", "content", "p", "pt", "port", "ac", "memory", "page", "pointer", "manager", "parents", "old", "it", "host", "function", "child", "address", "connection", "patch", "handler", "file", "part", "fat"], "dir": ["group", "cache", "out", "dict", "dec", "path", "Dir", " directory", "mod", "f", "config", "home", "ver", "wd", "per", "root", "po", "tree", "keep", "manager", "or", "build", "loc", "data", "folder", "object", "director", "ir", "directory", "base", "name", "url", "nav", "fd", "die", "container", "dr", "cur", "div", "dev", "di", "coll", "block", "iter", "def", "file", "part", "entry", "dis", "pkg", "id", "user", "db", "d", "doc", "rel", "dc"], "from": ["source", "form", "normal", "who", "so", "se", "out", "parse", "client", "path", "clean", "empty", "with", "this", "component", "link", "e", "one", "per", "vol", "po", "conn", "or", "get", "by", "data", "left", "con", "in", "ce", "self", "on", "io", "up", "flo", "find", "url", "base", "name", "bean", "low", "add", "pe", "code", "cr", "hand", "query", "address", "ch", "api", "without", "connection", "From", "stream", "range", "auto", "un", "file", "part", "o", "start", "can", "http"], "to": ["source", "tto", "top", "cache", "token", "TO", "out", "so", "output", "sync", "thro", "session", "tool", "ver", "with", "store", "page", "not", "via", "this", "per", "one", "po", "socket", "too", "about", "or", "by", "on", "io", "be", "flo", "url", "name", "b", "server", "until", "pi", "api", "see", "will", "connection", "two", "size", "To", "auto", "tom", "office", "value", "file", "temp", "made", "t", "key", "op", "o", "fat", "type", "db", "target", "co", "http"], "buffer": ["message", "position", "shape", "result", "length", "available", "memory", "buff", "buf", "page", "texture", "seed", "uffer", "border", "padding", "default", "read", "data", "duration", "total", "resource", "binary", "comment", "document", "character", "base", "device", "null", "server", "capacity", "pool", "transfer", "number", "address", "Buffer", "variable", "header", "channel", "queue", "layer", "batch", "reference", "iter", "block", "value", "row", "slice", "reader", "flush", "offset"], "bytes_read": ["es_used", "bytes_load", "bytes0write", "bytes0pass", " bytes_pass", "bytes_write", " bytes_received", "bytes___found", "bytes___read", " bytes_write", "bytes_pass", "keys___read", "bytes0read", "bytes_used", "keys_written", "bytes0received", "keys_found", "keys___found", "bytes_allow", "es_read", "bytes___written", "es_allow", "bytes_received", "bytes_written", "keys___written", "bytes_found", "keys_read", "es_load"]}}
{"id1": "4618237", "id2": "11341711", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFilesAsFile", "writeFileAsChannel", "writeFilesToFile", "writeFileAndFiles", "writeFile2File", "writeFileAsFiles", "writeFile2Stream", "writeFile2Files", "writeFileAsFile", "writeFilesToStream", "writeFileToStream", "writeFile2Channel", "writeFilesToChannel", "writeFileToChannel", "writeFileAndChannel", "writeFilesAsFiles", "writeFileAsStream", "writeFilesAsStream", "writeFileAndStream", "writeFileToFiles", "writeFileAndFile", "writeFilesToFiles", "writeFilesAsChannel"], "fin": ["fine", "init", "ris", "ln", "inn", "fp", "pin", "f", "ori", "conn", "ini", "fm", "fen", "Fin", "arin", "inf", "din", "pins", "fd", "inv", "fn", "fr", "fa", "thin", "rf", "lin", "FIN", "en", "rt", "file", "nir", "rin", "kin", "fi", "include", "fat", "raf"], "fout": ["fOut", "Foff", "rfin", "rfint", "bout", "rfOut", "Fout", "bOut", " fOut", "boff", "Fint", "Fin", "bin", " foff", " fint", "foff", "rfout", "FOut", "fint"], "append": ["text", "adjust", "app", "flat", "pend", "opp", "push", "want", "leaf", "pad", "update", "spread", "send", "padding", "open", "ended", "vert", "except", "add", "null", "ext", "password", "printf", "string", "future", "enc", "only", "batch", "fail", "atten", "save", "protect", "pack", "remove", "end", "apply", "flush", "ending", "optional"], "inChannel": ["innerConnection", "Inchannel", "outchannel", "outQueue", "innerChan", "inChan", "loginStream", "InChan", " inchannel", "loginChannel", "inputChannel", "inputChan", "INChannel", "loginchannel", " inQueue", "INChan", "innStream", "INStream", "inputConnection", "inQueue", "innerchannel", "inConnection", "InChannel", "innchannel", "innerStream", "INConnection", "inchannel", "innerChannel", "inputStream", " inStream", "innChannel", "outChan", "outStream", "INchannel", "INQueue", "inStream", "InStream"], "outChannel": ["outSocket", "OutContext", "outchannel", "OutChan", "inChan", "iochannel", "outputchannel", "ioChan", "outContext", "Outchannel", "externalchannel", "externalChannel", " outChan", " outchannel", "ioChannel", "inContext", "externalChan", "inchannel", "OutStream", "ioStream", "outputChannel", "externalSocket", "outChan", " outContext", "outStream", "outputChan", "OutChannel", "outputSocket", "inStream", "inSocket"]}}
{"id1": "17296916", "id2": "4417943", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"logging": ["Logging", "blogger", " logting", " loging", "blogging", "logting", "Logting", "logger", "blogting", "loging", "Loging", "Logger", "bloging", " logger"], "wrap": ["p", "work", "message", "create", "init", "util", "sw", "cache", "widget", "parse", "cover", "wire", "flash", "bag", "frame", "f", "rap", " Wrap", "use", "w", "wp", "word", "war", "image", "or", "build", "process", "default", "wra", "web", "box", "we", "format", "ad", "transform", "ws", "force", "self", "binary", "wa", "b", " wrapped", "api", "h", "now", "div", "lock", "handler", "stream", "wrapper", "nw", "wb", "ow", "pipe", "get", "handle", "run"], "buffer": ["source", "message", "ref", "bridge", "result", "copy", "cache", "table", "uf", "bar", "flash", "cover", "frame", "bb", "fb", "buff", "buf", "view", "pb", "manager", "uffer", "image", "loader", "writer", "board", "builder", "binary", "comment", "print", "shell", "document", "url", "bc", "log", "base", "b", "null", "server", "player", "transfer", " buf", "msg", "nb", "code", "Buffer", "header", "bm", "queue", "layer", "wrapper", "batch", " receive", "iter", "reference", "pause", "BU", "surface", "response", "feed", " buffers", "ob", "reader", "template", "bin", "cb", "report", "reply"], "encoding": ["unicoder", "enode", "unicoding", "ecryption", "Encoding", "encoded", "encode", "encryption", "Encet", "decoded", "decryption", "encoder", "cet", "Encoded", "Encryption", "coding", "decode", "coder", "packoded", "enoded", "packoder", "enoding", "ecoding", "enoder", "packet", "encet", "ecoded", "decoder", "decoding", "unicode", "Encoder", "ecoder", "unicoded", "packoding", "coded"], "getEncoding": ["getCoder", "getEncoded", " getEnoded", " getEnoder", " getEnoding", "getencoder", "getEnoder", "getencoded", " getEncoder", " getEnocol", "getEnasing", "getCasing", "getEncocol", "getEncasing", "getEnocol", " getEncoded", "getEncoder", "getencoding", " getEncasing", " getEnasing", "getCoded", "getEnoding", "getCocol", "getEnoded", " getEncocol", "getencocol", "getencasing", "getCoding"], "headers": ["frames", "relations", "workers", "types", "parts", "writers", "lines", "ppers", "str", "dict", "bits", "keys", "s", "head", "ers", "ters", "groups", "options", "heads", "vals", "padding", "caps", "names", "strings", "rs", "ints", "values", "objects", "params", "host", "files", "features", "body", "header", "h", "links", "blocks", "details", "wrapper", "ings", "settings", "plugins", "properties", "breaks", "ports", "fields", "ids", "content", "http"], "is": ["tis", "mis", "as", "ris", "was", "IS", "out", "oss", "us", "isa", "so", "ists", "s", "its", "ori", "sis", "bas", "are", "iss", "i", "Is", "or", "iso", "in", "lis", "ws", "io", "\u00eds", "ses", "ms", "os", "ui", "fs", "bs", "isl", "api", "isi", "isol", "ins", "las", "ais", "ios", "aos", "abs", "es", "iris", "obs", "nis", "bis", "has", "js", "cms", "ops", "ois", "http"], "bos": ["org", "uds", "tis", "mis", "bh", "so", "bits", "bones", "opus", "home", "oes", "bas", "mos", "bo", "oops", "ubis", "ko", "bott", "abi", "obo", "mobi", "bot", "ws", "shadow", "bi", "ros", "flo", "bin", "bc", "ses", "pins", "oks", "os", "los", "obi", "cos", "zos", "fs", "bots", "bs", "zo", "fits", "ubs", "obos", "las", "oos", "ios", "aos", "base", "outs", "lins", "osa", "obs", "ob", "osi", "bis", "beans", "cms", "oses", "ois", "bes", "ops"], "e": ["p", "x", "me", "re", "se", "c", "f", "ite", "ale", "ie", "i", "de", "one", "d", "l", "exc", "ise", "oe", "E", "ce", "ze", "ec", "ke", "be", "a", "pe", "fe", "je", "ee", "ae", "ev", "err", "er", "o", "type", "esi", "error", "ception", "ea"]}}
{"id1": "14303294", "id2": "6159896", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getServerAddress", "getSessionHash", "getserverSHA", "getserverSalt", " getServerSHA", "getSecureAddress", "getSecureSHA", " getSecureSalt", "getserverAddress", "getSessionAddress", "getSecureHash", " getServerSalt", "getSessionSalt", "getserverHash", "getServerSalt", "getServerSHA", " getServerAddress", " getSecureAddress", "getSecureSalt", " getSecureHash", " getSecureSHA", "getSessionSHA"], "passwordHash": ["passwordCode", "privatehash", "privateHash", "passwordPassword", " PasswordCode", "PasswordPass", " passwordSalt", " passwordCode", "passwordhash", " PasswordPass", "passwordSalt", "PasswordHash", " PasswordHash", " passwordPassword", " passwordPass", "PasswordPassword", "Passwordhash", " passwordhash", "passwordPass", "PasswordCode", "privateSalt", "privatePassword"], "PasswordSalt": [" PasswordSecret", "passwordPassword", "Password256", "PASSSalt", "PASS256", " PasswordPassword", " Password256", " passwordSalt", " passwordSecret", "PASSHash", "passwordSalt", "PasswordHash", " PasswordHash", "passwordSecret", " passwordPassword", "PASSPassword", "PasswordPassword", "PasswordSecret", "password256"], "hash": ["work", "message", "result", "buffer", "copy", "cache", "check", "ash", "update", "dig", "image", "build", "kh", "data", "auth", "mac", "url", "base", "log", "array", "search", "Hash", "change", "pool", "password", "number", "code", "sha", "hex", "address", "h", "string", "size", "crypt", "sum", "sh", "block", "html", "ha", "value", "row", "key", "response", "her", "user", "error", "content"], "digest": ["Digusher", "Digester", " digall", " digher", "mdested", "hashener", "hashest", "integested", " digusher", "digusher", "digested", "mdester", "Digener", "Diger", " digener", "generester", "Digger", "signger", "hashester", "integest", "digger", " digger", "generest", "diger", "generested", "signester", " diger", "Digest", "generall", "integall", "integester", "signher", "signer", " digested", "Digested", "mdest", "digener", "digester", "hasher", " digester", "signest", "digher", "digall", "mdusher", "Digher"]}}
{"id1": "14191679", "id2": "20924119", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnodeReturn", "EncodReturns", "EncodReturn", "EncodData", "EncodeReturns", "EnccodeData", "EnodeResult", "EnodeReturns", "EnodedResult", "EncodResult", "EnodedReturns", "EnodedReturn", "EnodeData", "EnccodeResult", "EnccodeReturn", "EnccodeReturns", "EnodedData", "EncodeResult", "EncodeData"], "IOException": ["DownloadException", "DownloadError", " IOception", "Downloadception", "IOception", "IPError", "IPException", "IOError", " IOError", "IPception"], "c": ["p", "gc", "cs", "xc", "cache", "uc", "client", "cf", "ac", "f", "e", "l", "ci", "m", "ce", "ec", "n", "pc", "conv", "lc", "proc", "C", "u", "cr", "b", "sc", "ch", "cur", "cc", "nc", "cp", "chain", "enc", "cpp", "fc", "cd", "cu", "y", "mc", "t", "r", "ct", "d", "cmp", "dc"], "tmpf": ["tempcf", " tmpfs", "poraryf", "zipf", "zipfs", "tmpfd", "tempfs", "empfs", "tempF", " tmpF", "vmf", "tmpfs", " tmpcf", " tmpfen", "vmF", "empf", "tmpF", "tempfen", "porarycf", "vmcf", "zipF", "poraryfen", "vmfs", "poraryF", "tempfd", "empF", "tmpcf", "tempf", "tmpfen", "zipfd", "empfd"], "cw": ["Cw", " cwa", "cws", "cwd", "rcwe", "cwb", "pW", "rcwd", " csw", "pw", "Cws", "ffw", " cW", "fws", "csw", "cwa", "fwa", "pwa", "psw", "lcw", "fw", "cW", "lcwe", "rcw", " cwd", "lcwd", " cwb", "lcwb", " cwe", "cfw", " cws", "Csw", "Cfw", "Cwa", "cwe", "rcwb", "CW", " cfw"], "encdata": [" encData", "envdata", "extData", "installData", "envdat", "installdat", "secData", "encdatabase", "envreader", "extdat", "secdata", "extdata", "envkeys", "extdatabase", "encData", "Encdata", "enccache", " encdatabase", " encdat", "incdata", "incroot", "EncData", " encreader", "encreader", "envData", "encdat", "installdatabase", "Enckeys", "enckeys", "Encdat", "inccache", "installdata", "secdat", " encroot", " enccache", "seckeys", "encroot", "increader", "envroot", "envcache"], "pigdata": ["pagresults", "pippcache", "pigscache", "pigrdata", "pocresource", "pagdata", "pocData", "picresource", "PigData", "PigsData", "Pigsla", "Pigresults", "pigrData", "pichdata", "Pigresource", "Pigsdat", "pocdata", "PibData", "Pigscache", "pigresults", "picdat", "pippdata", "Pigdata", "pichcache", "pagData", "pigdat", "pigresource", "pigData", "Pigdat", "picData", "pigrresults", "pichData", "pigsla", "Pibresource", "pigcache", "pigsdat", "pocdat", "pigsdata", "pippData", "Pigla", "Pibdata", "pigsData", "pichla", "pibdat", "pigrdat", "pigsresults", "pibdata", "pigla", "pibresource", "pippla", "Pigsdata", "pibData", "pagdat", "Pigsresults", "Pibdat", "picdata", "Pigcache"], "pigroute": ["pibrouter", "apibrouter", "pirmroute", "miarote", "pigrationoute", "pibrote", "pigrationouter", "apigrouter", "pigrationange", "pipeloute", "piarune", "apibroute", "fibrote", "fibrange", "migroute", "pibrroute", "pirmouter", "pigerote", "figrroute", "pigrouter", "pigerune", "piarouting", "migrote", "figrote", "pipelote", "pipelouting", "pigeroute", "pibrange", "pigrroute", "pirmouting", "pirmoute", "pigrote", "apibrouting", "migrouting", "figrange", "pigerouting", "miaroute", "pigrange", "apibrroute", "apigroute", "pigrune", "pipelange", "pibroute", "migrune", "piaroute", "miarouting", "figroute", "miarune", "pigrationouting", "pipelune", "pibrouting", "pigrationote", "piarote", "pigrationroute", "pipelroute", "apigrroute", "pigrouting", "apigrouting", "fibrroute", "fibroute"], "fos": ["refos", "foes", "Fo", "Foes", " fops", "to", "pos", " fOS", "Fos", " foes", "pOS", "fo", "poes", "toc", " fo", "toes", "refOS", "Foc", "refoes", "tos", "pops", "fOS", "fops", "refops"], "foc": ["infocol", "Focol", "infoc", " focol", "infic", " fac", "infac", "Fec", "fac", "Fac", "Foc", "fec", "focol", " fec", "infec", "Fic"], "fis": ["infi", "Fi", "cig", "infic", "fics", "Fis", "infis", "Fics", "Fig", " fi", "cis", "fi", "Fic", " fig", "cic", "fig", " fics", "cics", "infics"], "fic": ["rfics", "Fisc", "cfoc", "infoc", "Fico", " fico", " fisc", "rfoc", "poc", "cfic", "infic", " fac", "fico", "cfics", "fics", "pis", "Fis", "cfico", "rfic", "pic", "Fics", "cfis", "fac", "Fac", "pac", "Foc", "fisc", "Fic", "rfis", "infisc", " fics", "infics"]}}
{"id1": "11962480", "id2": "1357662", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"read": ["create", "init", "copy", "Read", "parse", "check", "load", "download", "store", "construct", "build", "process", "readable", "resource", "open", "transform", "find", "print", "add", "split", "write", "replace", "register", "get", "start", "report"], "skeletonFilename": ["SkelDownload", " skelfilename", " skeletonfilename", "sletonDownload", "skeletonSourceFile", "sleeSourceFile", " skelFile", " skelFilename", " skeletonFile", "sleefilename", "skeletonFile", "sletonfilename", "SkeletonFilename", "sletonFile", "Skeletonfilename", "skelFilename", "sleeFile", "SkeletonDownload", "skelSourceFile", "skelDownload", "Skelfilename", "SkeletonSourceFile", "skelfilename", "SkelFile", " skelSourceFile", "sleeFilename", "SkelFilename", "skeletonfilename", " skeletonSourceFile", "SkeletonFile", "southeastFile", "southeastSourceFile", "southeastDownload", "sletonFilename", "SkelSourceFile", "skeletonDownload", "sletonSourceFile", "skelFile", "southeastFilename"], "loader": ["source", "init", "buffer", "loading", "cache", "Loader", "path", "loaded", "load", "config", "system", "CL", "driver", "l", "loc", "in", "resource", "builder", "class", "base", "log", "name", "b", "lc", "null", "server", "rl", "lang", "lock", "handler", "cl", "layer", "impl", "parser", "file", "r", "er", "err", "http"], "url": ["source", "buffer", "uri", "browser", "client", "path", "Url", "load", "f", "page", "i", "l", "image", "cdn", "loc", "data", "service", "object", "resource", "location", "base", "name", "bel", "b", "server", "host", "URL", "rl", "sl", "api", "address", "string", "connection", "ur", "coll", "file", "lib", "r", "ssl", "feed", "user", "rel", "http"], "line": ["text", "source", "lf", "style", "result", "Line", "L", "lines", "str", "sync", "parse", "se", "cell", "lo", "page", "link", "i", "word", "l", "item", "inline", "data", "definition", "nl", "strip", "comment", "base", "name", "log", "job", "pe", "lc", "no", "code", "number", "split", "sl", "letter", "body", "string", "header", "LINE", "cl", "lin", "write", "file", "part", "row", "key", "entry", "liner", "unit", "le", "user", "content"], "section": ["text", "source", "style", "position", "sector", "output", "se", "length", "script", "union", "config", "page", "ler", "area", "draft", "data", "writer", "ner", "service", " intersection", "format", "location", "builder", "definition", "sect", "journal", "storage", "editor", "description", "division", "job", "sections", "sec", "array", "search", "lc", "character", "server", "null", "article", "function", "sub", "letter", "chapter", "zip", "body", "string", "connection", "patch", "rule", "region", "handler", "layer", "element", "option", "parser", "block", "file", "version", "row", "key", "feed", "entry", "join", "layout", "contract", "parent", "Section", "content"], "reader": ["rx", "buffer", "reading", "inner", "f", "rr", "rar", "ler", "i", "per", "input", "driver", "bird", "writer", "ner", "oder", "resource", "builder", "io", "editor", "rer", "worker", "handler", "stream", "layer", "parser", "Reader", "iter", "file", "row", "r", "er", "feed", "ri"]}}
{"id1": "3266833", "id2": "20073619", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 0, "substitutes": {"is": ["mis", "as", "init", "ris", "im", "IS", "was", "isa", "us", "info", "its", "isu", "iss", "i", "Is", "image", "or", "iso", "ib", "in", "lis", "close", "ir", "ws", "ip", "os", "iv", "isc", "fits", "bs", "ins", "ais", "ios", "es", "abs", "iris", "id", "bis", "get", "has", "cms"], "name": ["source", "filename", "large", "path", "ame", "memory", "alias", "NAME", "this", "title", "domain", "pass", "one", "word", "Name", "image", "default", "data", "names", "module", "nice", "format", "description", "n", "directory", "url", "base", "database", "search", "null", "label", "code", "address", "term", "min", "string", "connection", "size", "prefix", "office", "named", "file", "value", "space", "part", "version", "key", "id", "type", "parent", "vision", "no"], "contentType": ["ContentName", "mediaType", " contenttype", "outputPath", "documentInfo", "contentInfo", "ContentInfo", "messageType", "contentPath", "sourcetype", " contentInfo", "outputTypes", " contentPoint", "messageName", "sourceInfo", "messageInfo", "sourceType", "documentPoint", "mediaTypes", "mediaPath", "outputName", "messagetype", "contentName", "contentPoint", "ContentType", "Contenttype", "ContentPath", "outputType", "contenttype", "mediaName", "ContentTypes", "sourcePoint", " contentName", "documentType", "contentTypes", "documenttype"], "index": ["x", "position", "shape", "expression", "depth", "length", "update", "page", "timeout", "level", "i", "pointer", "input", "image", "none", "default", "data", "in", "open", "fix", "multi", "axis", "width", "search", "Index", "number", "address", "body", "append", "string", "list", "size", "alpha", "prefix", "height", "write", "weight", "value", "include", "pull", "key", "slice", "id", "end", "type", "inc", "error", "offset", "content"], "extension": ["configension", "extensions", "extance", "variension", "variuration", "exturation", "variance", "Extance", "configensions", "configuration", "configance", "Exturation", "Extension", "Extensions", "variensions"], "isImage": ["ISVideo", "IsFile", "isVideo", "asimage", "isImages", " isimage", "isMedia", "areMedia", "IsVideo", "isaImage", "isInstance", "asFile", "areInstance", "isFile", "ISImage", "areImages", "IsPicture", "ISFile", "isaMedia", "isimage", " isPicture", " isVideo", " isMedia", "areimage", "isaFile", "asInstance", "asImage", "areImage", "isaImages", "areFile", " isInstance", "isPicture", "ISPicture", " isFile", " isImages", "IsImage"], "isAux": ["isWalux", "isAslux", "isArrayUX", "isWaUX", " isArrayxt", "isAsx", "isAsUX", " isHaux", "asAsExcept", "isAlux", "isAAxt", "isAru", " isAx", " isAUX", "isAnux", "isAnlux", "isAsux", "isAAru", "isAxt", "isAex", "isAcUX", "isUUX", "isAsex", "isWax", "isAcxt", "isArrayux", "isArrayru", " isArrayru", "isAUX", "isOAExcept", " isArrayux", " isHalux", " isAxt", " isHax", "isAcru", "isOAux", "isHalux", "asAsUX", "isAAux", "asAsex", "isAAUX", " isArrayUX", "isOAUX", " isHaUX", "isAsExcept", "isWaux", "isHaux", "asAslux", "isUExcept", "asAExcept", " isAlux", "isAExcept", "isAnex", "isUlux", "isOAlux", "isUex", "asAex", "asAsux", "isHaUX", " isAru", "isAnUX", "isHax", "asAux", "asAlux", "isUux", "isArrayxt", "isAx", "isAcux", "asAUX"], "out": ["work", "source", "result", "buffer", "copy", "cache", "output", "table", "client", "sync", "inner", "at", "this", "page", "extra", "ex", "word", "input", "socket", "OUT", "image", "conn", "project", "data", "in", "object", "up", "io", "next", "a", "base", "array", "null", "outer", "ext", "exec", "post", "pool", "obj", "exp", "size", "over", "plain", "prefix", "Out", "auto", "outs", "again", "off", "file", "temp", "version", "part", "parent", "o", "user", " in", "error"], "bufferedImage": ["bufferingImage", "buffledimage", "BufferedImage", "buffendedimage", "BufferingImage", "buffledImage", "bufferingimage", "buffendedImage", "bufferedimage", "Bufferingimage", "Bufferedimage"], "inputStream": ["InputBuffer", "outputstream", "inputSteam", "outputStream", "InputStream", "Inputstream", "InputSteam", " inputstream", " inputBuffer", " inputSteam", "outputSteam", "inputstream", "outputBuffer", "inputBuffer"]}}
{"id1": "3558512", "id2": "12172485", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"serialize": ["serialization", "finalized", " serialization", "finalify", "Serialization", "serialify", "serialze", "normalze", " serializable", "erialze", "Serializable", "Serialize", " serialze", "normalized", "normalify", "Serialized", "erialization", "serializable", "serialized", "Serialify", "erializable", "finalze", "normalize", "finalize", "Serialze", "erialize"], "out": ["source", "png", "filename", "buffer", "copy", "cache", "output", "client", "archive", "page", "w", "ex", "i", "dump", "OUT", "image", "conn", "data", "writer", "loader", "io", "up", "a", "name", "server", "gen", "obj", "pool", "exec", "string", "Out", "raw", "outs", "file", "temp", "err", "o", "parent", "bin", "report", "content"], "parser": ["p", "lp", "arser", "as", "copy", "cache", "ss", "parse", "instance", "system", "seed", "master", "rar", "per", "processor", "txt", "manager", "loader", "writer", "Parser", "builder", "tt", "up", "class", "base", "pe", "server", "upload", "worker", "cp", "handler", "plugin", "wrapper", "php", "test", "file", "er", "pp", "reader", "pkg", "parent", "xml", "pillar"], "on_disk": ["onnetdrive", "onJdemand", "onJdisk", "on_storage", "onbookdisk", "off_drive", "onjdisk", "on_lock", "on_demand", "onJdrive", "onbootstorage", "onbootdrive", "onbookdrive", "on_space", "off_space", "onbootlock", "onjdrive", "onnetdisk", "on_file", "onnetfile", "on_drive", "off_delete", "onJlock", "onnetspace", "off_disk", "onjspace", "off_storage", "off_file", "off_lock", "onjfile", "onbootdisk", "onnetdemand", "onbookdelete", "on_delete", "off_demand"], "in": ["source", "as", "copy", "inn", "pin", "inner", "c", "ac", "f", "ax", "info", "pass", "i", "input", "socket", "conn", "inas", "IN", "data", "ini", "win", "con", "din", "min", "ins", "connection", "thin", "stream", "lin", "In", "inc", "again", "rin", "file", "kin", "r", "login", "o", "reader", "bin"]}}
{"id1": "12039034", "id2": "17207832", "code1": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"importRoles": ["importRoleRole", "ImportGroots", "importGroots", "ImportGrorts", "importGroles", "importroorts", "ImportRorts", "ImportGrRole", "importRoots", "importrooots", "ImportRRole", "importRorts", "importroRole", "ImportRoots", "importRoleoots", "importGrorts", "ImportRoles", "importGrRole", "importRRole", "ImportGroles", "importRoleoles", "importrooles", "importRoleorts"], "urlString": [" urlStream", "URLString", "fileImport", "urlStream", "urlImport", "URLstring", "fileFile", "serviceStream", "servicestring", "urlStr", "resourceString", " urlstring", "serviceString", "resourcestring", "URLImport", " urlImport", "fileString", "urlstring", "urlFile", "resourceStream", "serviceStr", " urlFile", "URLFile", "filestring", " urlStr", "resourceStr"], "results": ["relations", "tests", "rules", "result", "lines", "Results", "groups", "shows", "services", "vals", "resources", "data", "names", "errors", "authors", "values", "RESULTS", "roots", "objects", "params", "members", "reads", "res", "features", "reports", "list", "models", "times", "details", "vers", "ings", "runs", "helps", "users", "ils", "es", "grades", "properties", "changes", "tops", "items", "rows"], "url": ["ls", "source", "buffer", "uri", "str", "browser", "client", "path", "Url", "f", "this", "ball", "page", "e", "i", "l", "socket", "loader", "service", "resource", "hub", "open", "io", "base", "log", "b", "server", "URL", "rl", "sl", "api", "string", "connection", "ur", "stream", "ll", "file", "r", "ssl", "feed", "reader", "http"], "in": ["source", "init", "buffer", "rec", "inn", "gin", "out", "inner", "f", "s", "e", "i", "input", "l", "socket", "read", "IN", "by", "ini", "io", "n", "isin", "din", "b", "server", "ins", "h", "stream", "lin", "In", "inc", "again", "file", "r", "ssl", "login", "id", "reader", "bin", "doc"], "buff": ["flow", "text", "app", "ab", "buffer", "sb", "uf", "br", "bag", "obb", "load", "f", "bb", "info", "buf", "fb", "lab", "back", "front", "txt", "agg", "pb", "ff", "mb", "ph", "box", "ib", "prof", "comment", "bf", "callback", "base", "b", "null", "fw", "bound", "nb", "nd", "bg", "append", "Buffer", "rb", "eb", "gb", "uff", "cp", "bm", "cpp", "raw", "orig", "off", "utf", "bug", "wb", "feed", "pp", "ob", "fam", "Buff", "tab", "ctx", "bin", "cb", "raf"], "line": ["text", "message", "column", "lf", "look", "buffer", "Line", "lines", "str", "out", "parse", "cell", "f", "model", "page", "link", "e", "word", "l", "item", "inline", "data", "nl", "object", "email", "comment", "ne", "base", "log", "job", "lc", "server", "code", "ge", "string", "header", "rule", "profile", "LINE", "el", "lin", "range", "cl", "block", "value", "file", "part", "row", "key", "response", "entry", "end", "le", "unit", "status", "no"], "name": ["attr", " support", "span", "role", " account", " type", "known", "path", " connection", " file", "alias", "NAME", " lookup", " player", "word", "Name", " entity", "data", "names", " path", "object", "resource", "n", " info", " object", "base", " address", " description", "job", "ann", "number", " nickname", "connection", " one", "profile", "cn", "file", "part", "key", "member", "id", "type", "user", "zone", "node", " number", "no"]}}
{"id1": "14688886", "id2": "17286898", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"populateResources": ["popractResource", "compureResources", "popureRelations", "compulateResources", "poputeRelations", "populateRelations", "poputeResources", "popureFiles", "popureResources", "poputeResource", "popureResource", "compureRelations", "popractFiles", "compulateRelations", "compureFiles", "compulateFiles", "popractResources", "poputeFiles", "compureResource", "compulateResource", "populateFiles", "populateResource", "popractRelations"], "templates": ["templateplates", "tempps", "temps", "filpl", "templateples", "Template", "tompl", "tomplate", "Temeters", "tomplates", "tometers", "Templates", "tempplates", " temens", "templateps", "temeters", "Templ", "typs", "stemps", "temppl", "templ", "Temens", "stemplates", "stempl", "Temures", "temens", "typl", "prometers", "temures", "tempplate", "promplate", "templatepl", " temures", "filures", "filplates", "stemples", "promplates", "filens", "Temples", "prompl", "Temps", "typlates", "template", "temples", " templ", "typlate"], "url": ["source", "filename", "buffer", "uri", " URL", "path", "Url", "download", "f", "config", "page", "pl", "il", "link", "e", "l", "image", "data", "service", "object", "resource", "email", "location", "base", "name", "job", "server", "host", "URL", "fl", "sl", "address", "string", "connection", "channel", "el", "html", "file", "route", "r", "template", "ssl", "entry", "feed", "ob", "href", "xml", "pattern", "http"], "fileName": ["filenameLength", " filePath", "FileInfo", "folderPath", "resourceName", "filePart", " fileSync", " fileType", "FileDir", "FILELocation", "sourcename", "folderPart", "modelLocation", "FILEname", "fileString", " fileLength", "stringName", "modelname", "fileDir", "FILESystem", "fileLocation", "stringDirectory", "fileType", "stringType", "fname", "resourcename", "objectTime", "sourceLength", "resourcePart", "FileDirectory", "Filename", "fileFull", "FileFull", "foldername", " fileLocation", "objectname", "resourcePath", "filenameType", "sourceString", "FileString", "fKey", " filePart", "objectSync", " filename", "sourceInfo", "FILESync", "sourceName", "FileName", "modelName", "FILEName", "FileType", "FILETime", "filenameFull", "fileSync", " fileTime", " fileDir", "fileDirectory", " fileSystem", "filename", "fName", "filePath", "filenamename", "fileTime", "fileKey", " fileDirectory", "fileInfo", " fileFull", " fileKey", "fileLength", "folderName", "filenameString", " fileInfo", "modelSystem", "filenameName", "fileSystem", "objectName", "FileKey", "fDir", " fileString"], "templateResource": ["eventresource", " templateRole", "xmlFile", "xmlResource", "privateresource", "plateContent", "translationResource", "privateResource", "tempFile", "eventResource", "templateRing", "translationContent", "layoutContainer", "templateReader", "xmlType", "privateUrl", "privateReader", "eventReader", "templateFile", "tempResource", " templateType", "xmlRole", "translationRing", "copyReader", " templateFile", "templateContainer", "plateResource", "templateRole", "templateUrl", "copyResource", "tempType", "layoutResource", "copyUrl", "layoutRing", "templateContent", "templateType", "eventUrl", "layoutContent", "copyresource", "templateresource", "plateRing", "tempRole", "translationContainer", "plateContainer"], "is": ["as", "ris", "app", "uri", "isa", "IS", "out", "im", "was", "s", "its", "ori", "iss", "Is", "irc", "serv", "src", "iso", "in", "ib", "lis", "ir", "ip", "io", "ar", "os", "it", "isc", "isl", "isi", "api", "rss", "ais", "ios", "abs", "iris", "r", "nis", "bis", "has", "ri", "cms"], "strBuff": ["StrTab", "brBuff", "strbuff", "rbuff", "brGrab", "arrTab", " strTab", "StrPref", "strGrab", " strFlow", " strPref", "stringBuffer", "brBuffer", "rBuff", "arrBuff", "strFlow", "stringGrab", "rBuffer", "strBuffer", "StrBuff", "StrBuffer", " strBuffer", " strText", "brFlow", "arrPref", "stringBuff", "stringFlow", "rText", "Strbuff", "StrText", " strGrab", "strPref", "arrBuffer", "strText", " strbuff", "strTab"], "br": ["text", "result", "bro", "arr", "browser", "bar", "cb", "buf", "ori", "mr", "BR", "bl", "data", "Br", "sr", "io", "bc", "ber", "b", "hr", "cr", "nr", "res", "gr", "sp", "rb", "brush", "dr", "div", "fr", "yr", "stream", " reader", "ctr", "Reader", "tr", "r", "er", "err", "reader", "orb"], "str": ["p", "text", "kr", "strike", "char", "style", "arr", "st", "Str", "f", "line", "STR", "stri", "or", "data", "star", "sr", "name", "sec", "lc", "spec", "hr", "cr", "sc", "wr", "sl", "oct", "sp", "dr", "cur", "string", "div", "fr", "enc", "coll", "pr", "cl", "iter", "tr", "r", "er", "t", "err", "key", "type"], "images": ["frames", "holes", "videos", "types", "people", "png", "tests", "bands", "apps", "media", "words", "ups", "agents", "photos", "styles", "inches", "ips", "sites", "assets", "versions", "groups", "shows", "services", "icons", "image", "dates", "resources", "games", "rooms", "ages", "opens", "flows", "letters", "pieces", "objects", "boxes", "thumbnails", "picture", "files", "ims", "Images", "features", "ins", "models", "tags", "pages", "views", "xs", "scripts", "quarters", "gif", "plugins", "users", "gallery", "lights", "classes", "ions", "events", "stars", "jobs"], "i": ["x", "ai", "config", "s", "I", "image", "ci", "chi", "ip", "u", "add", "li", "y", "key", "slice", "d", "ti", "http", "uri", "info", "this", "ini", "multi", "iu", "bi", "io", "n", "lc", "pi", "j", "eni", "_", "cli", "mu", "id", "diff", "hi", "ii", "e", "ind", "format", "si", "b", "ji", "mi", "di", "qi", "gu", "html", "xi", "phi", "p", "uni", "app", "ij", "z", "Url", "ni", "f", "gi", "ie", "yi", "in", "it", "ui", "index", "fi", "v", "xml"], "img": ["p", "png", "ani", "app", "iframe", "arr", "im", "cb", "f", "config", "info", "fb", "ie", "input", "src", "bl", "image", "inst", "ff", "aut", "norm", "data", "m", "map", "aff", "tmp", "small", "hr", "ext", "tif", "fw", "bg", "ch", "sl", "li", "gd", "exp", "imp", "ng", "gif", "file", "gallery", "lib", "icon", "jpg", "v", "fig", "att", "abc"], "imgProperty": ["imgImage", "bgPro", "bgProp", "cacheImage", "bgImage", "cacheProperty", "imgProp", " imgImage", " imgProp", "cacheProp", "imgPro", "cachePro", "bgProperty", " imgPro"]}}
{"id1": "12349563", "id2": "5399593", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" fileexes", " fileexists", " resourceExits", " resourceexists", " resourceexits", " resourceExes", " resourceexistence", " resourceCompists", " resourceAbsistence", " fileExits", " resourceCompistence", " resourceAbses", " resourceAbsists", " fileExes", " resourceCompes", " fileexits", " fileExistence", " fileExists", " resourceexes", " resourceAbsits", " resourceExistence", " fileexistence", " resourceCompits"], "location": ["source", "local", "message", "filename", "position", "shape", "remote", "uri", "Location", "length", "path", "language", "point", "home", "info", "pointer", "area", "image", "localhost", "loc", "data", "folder", "object", "resource", "LOC", "directory", "description", "base", "name", "server", "host", "operation", "address", "connection", "string", "region", "layer", "provided", "reference", "file", "collection", "route", "href", "response", "layout", "type", "node", "target", "content"], "url": ["source", "uri", "path", "Url", "c", "f", "config", "page", "i", "l", "image", "build", "loc", "blog", "web", "resource", "open", "www", "io", "base", "b", "server", "host", "URL", "obj", "fl", "sl", "api", "address", "zip", "string", "connection", "ll", "impl", "file", "lib", "r", "ssl", "user", "http"], "cxn": ["crexg", "cexne", "Cxne", "cxxn", "cuxp", "Cxns", " cxp", "crexcon", " crexp", "cuxne", "cxxne", "crexp", "cdscon", "cuxns", "cexcon", " crexn", "cxg", "Cxp", "cxp", "cxcon", "cxns", "Cuxns", " crexg", "cdsp", "cdsn", "cxxp", "cxxns", "cuxn", "cexn", "cexp", " crexcon", "cexg", "cexns", "Cuxne", " cxcon", " cxg", "cxne", "Cuxn", "cdsg", "crexn", "Cxn", "Cuxp"], "is": ["x", "as", "ris", "app", "init", "internet", "uri", "IS", "out", "im", "us", "was", "isa", "oss", "ai", "info", "s", "its", "ori", "ens", "iss", "i", "Is", "src", "or", "iso", "web", "in", "close", "lis", "does", "ir", "ip", "ar", "next", "ms", "os", "cos", "it", "isc", "fs", "ui", "isl", "bs", "api", "isi", "stream", "ais", "ios", "es", "abs", "iris", "nis", "ob", "id", "bis", "get", "has", "js", "cms", "ois", "http"], "byteBuffer": ["bitBuff", "ByteArray", "ByteBuff", " byteBB", "byteBB", "bitBuffer", "ByteLength", " byteArray", "ByteBuffer", "byteArray", "bitLength", "ByteBB", "byteBuff", "byteLength", " byteBuff", " byteLength", "bitBB", "bitArray"]}}
{"id1": "18114701", "id2": "9267602", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"resolveEntity": ["resolvingEnt", "resolvedentity", "reolvedEntity", "resolvedEnt", "resolveEnt", "resolvingentity", "reserveentity", "resolvingEntity", "reolvedentity", "reserveEnt", "reolveentity", "reserveEntity", "reolvedEnt", "resolveentity", "resolvedEntity", "reolveEntity", "reolveEnt"], "publicId": ["ublicID", "externalMid", "publicUrl", " publicKey", "projectKey", "ublicId", "systemMid", "externalID", "systemID", "publicMid", "openID", "productionUrl", " publicData", "systemKey", "publicData", "productionid", "systemData", "openid", "productionId", "publicEntity", " publicID", "projectData", " publicUrl", "publicKey", "productionID", "openId", "systemEntity", "ublicMid", "externalId", "publicid", "externalEntity", "publicID", "projectId", "projectID", "openUrl", " publicid", "ublicEntity"], "systemId": ["systemPath", " systemPath", "serverUrl", "serverId", "systemID", " systemID", " systemName", "SystemID", "SystemName", "systemName", " systemUrl", "SystemUrl", "SystemId", "serverName", " systemid", "systemid", "ystemID", "serverid", "Systemid", "ystemId", "ystemPath", "systemUrl", "SystemPath", "ystemid"], "resolved": ["presolving", "Resolution", "presjected", " resolving", "revolved", " resolution", "reolved", "resolve", "revolving", "presolver", "reolving", "resolver", "resolving", "revolution", "reolve", "Resolved", "revolve", "presolution", "revolver", "presolve", " resjected", "Resolve", "resolution", "presolved", " resolver", "rejected", "reolution", "resjected", "Resolver", " resolve", "reolver"], "iSource": ["ISource", "piFactory", "diSourceFile", "diPoint", "iFactory", "iuClient", " iPoint", "iClient", "iuSource", "iUrl", "apiSource", "iuStream", "piSession", "iSourceFile", "uiSOURCE", "iuSOURCE", "uriSession", "piUrl", "uiSource", "piSourceFile", "uriSourceFile", "diSource", "diStream", "IClient", "uriStream", "apiFactory", "apiStream", "iSOURCE", "uiStream", " iUrl", "uriSource", " iFactory", "piPoint", "IStream", " iSession", "ISOURCE", "uiClient", "apiUrl", "piSource", " iSourceFile", "piStream", "iSession", "iPoint"], "url": ["source", "org", "uri", "browser", "client", "path", "Url", "f", "config", "page", "l", "image", "data", "web", "resource", "location", "www", "b", "server", "URL", "rl", "fl", "sl", "address", "api", "secure", "string", "connection", "channel", "fr", "stream", "file", "ssl", "feed", "id", "user", "jar", "rel", "http"], "iStream": ["iiSource", "iFrame", "uPath", "iPath", "iStreamer", "iiSteam", "uSteam", "lStream", "lFrame", "lSource", "uriStreamer", "uStream", "uriStream", "iiStreamer", "uFrame", "uriSource", "uSource", "uStreamer", "uriSteam", "iiFrame", "iiPath", "lPath", "iiStream", "iSteam"]}}
{"id1": "14168494", "id2": "812803", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyClass", "copyfile", "copyFiles", "copyClass", "transferfile", "transferFile", "transferClass", " copiedClass", " copiedFiles", " copiedfile", " copyfile", " copiedFile", " copyFiles"], "dest": ["source", "output", "out", "st", "path", " destination", "this", " Dest", "txt", "loc", "data", "resource", "done", "later", "sup", "class", "tmp", "name", "null", "obj", "transfer", "destroy", "dist", "target", "comb", "true", "orig", "desc", "file", "temp", "wb", "Dest", "dir", "d"], "src": ["source", "filename", "sb", "copy", "sync", "st", "download", "config", "s", "master", "ds", "inst", "sin", "loc", "storage", "img", "sup", "rob", "tmp", "url", "sel", "sit", "sub", "sc", "sl", "split", "dist", "rc", "rb", "upload", "gb", "stream", "sq", "file", "Dest", "ssl", "slice", "bin", "cb", "target"], "srcChannel": ["destConnection", "srcSection", "destchannel", "rcButton", "rcChan", " srcSection", "rcchannel", "destChannel", "distStream", "inputChannel", "srcButton", "distChan", "sourceChan", "srcchannel", " srcChan", "inputConnection", "srcCh", "rcStream", "distChannel", "srcConnection", " srcchannel", "sourceChannel", " srcConnection", " srcCh", "rcConnection", " srcStream", "inputSection", "srcChan", "rcSection", "sourceButton", "sourcechannel", " srcButton", "rcChannel", "distCh", "srcStream", "destChan", "rcCh", "inputchannel"], "dstChannel": ["dstVideo", "DstVideo", " drdContext", "dstChan", " dstStream", " dstsStream", " dstContext", " dstConnection", "dstsStream", " dstchannel", "dDestStream", "dstsChannel", "dsrcChannel", " dstChan", "dstConnection", "dstschannel", "dDestchannel", "ddestVideo", "dstContext", " drdChannel", "DstChannel", " dstsChannel", "drcchannel", " drdchannel", "drcChan", "drcVideo", "ddestchannel", "ddestStream", "dDestConnection", "dstStream", " dstschannel", "drcContext", "dsrcchannel", "ddestConnection", "DdestChannel", "dDestChannel", "Ddestchannel", "ddestContext", "DdestVideo", "Dstchannel", "dstchannel", "dstsConnection", " dstsConnection", "drdContext", "drdChannel", "ddestChan", "drdChan", " drdChan", "ddestChannel", "drdchannel", "dsrcVideo", "drcChannel"]}}
{"id1": "8932510", "id2": "23666867", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["sendPOST", "DoPost", "sendGet", " doPOST", " doGet", "doGet", "DoPOST", " doPut", "sendPut", "DoGet", "doPOST", "doPut", "DoPut", "sendPost"], "request": ["message", "remote", "buffer", "current", "session", "instance", "config", "head", "event", "have", "project", "image", "url", "post", "queue", "stream", "type", "http", "application", "form", "result", "uri", "client", "hello", "info", "this", "model", "view", "command", "req", "data", "writer", "object", "QUEST", "self", "allow", "save", "remove", "rate", "user", "parent", "method", "call", "path", "input", "condition", "resource", "next", "document", "subject", "requ", "attribute", "reader", "get", "Request", "create", "question", "re", "port", "frame", "enter", "complete", "q", "server", "query", "child", "connection", "list", "rf", "join", "right", "xml", "report", "context"], "response": ["message", "result", "re", "output", "json", "client", "view", " Response", "image", "xml", "resp", "writer", "data", "service", "object", "resource", "reply", "description", "next", "document", "server", "Response", "host", "res", "onse", "connection", "respond", "stream", "respons", "site", "error", "report", "status", "application"], "is": ["p", "mis", "as", "ris", "ist", "uri", "IS", "isa", "out", "was", "us", "isp", "ai", "info", "ori", "sis", "are", "iss", "i", "ie", "Is", "ci", "iso", "web", "in", "ib", "lis", "ini", "ir", "alis", "vs", "ip", "isin", "url", "si", "it", "isc", "ui", "isl", "address", "api", "isi", "iri", "pi", "bs", "rss", "ais", "ios", "eni", "iris", "nis", "bis", "ri", "ois", "http"], "page": ["p", "account", "message", "result", "cache", "so", "phone", "browser", "path", "flash", "session", "cover", "f", "view", "wp", "pl", "per", "root", "button", "po", "ko", "area", "image", "line", "blog", "menu", "web", "photo", "pg", "object", "record", "node", "www", "ip", "next", "url", "pe", "change", "article", "server", "pool", "code", "child", "Page", "sp", "list", "channel", "pages", "order", "handler", "filter", "html", "office", "bad", "pm", "sea", "pp", "site", "end", "plane", "parent", "user", "error", "can", "wiki"], "os": ["p", "ls", "OS", "ps", "ot", "so", "oss", "bos", "po", "socket", "pos", "object", "oa", "io", "ros", "ms", "oo", "obj", "oto", "oid", "mo", "ios", "op", "o", " bos", "ops"], "rootUrl": ["remoteurl", "randomurl", "rootPage", " rootURL", "weburl", "randomPage", "rootURL", " rooturl", "webPage", "randomUrl", " rootPage", "rooturl", "remotePage", "webURL", "remoteURL", "remoteUrl", "randomURL"], "isMultipart": ["isMultumpArt", "isMultitepart", "isMultiippoint", "isMultipparts", "isMultisepart", "isMultippoint", "isMultiiseArt", "isMultumparts", "isMultumppart", "isMultipppart", "isMultiseArt", "isMultiipArt", "isMultypArt", "isMultumpart", "isMultippart", "isMultiiseart", "isMultiteart", "isMultiipparts", "isMultiisepart", "isMultiparts", "isMultiipart", "isMultiiparts", "isMultipoint", "isMultypart", "isMultiipppart", "isMultisearts", "isMultiipoint", "isMultipArt", "isMultiippart", "isMultiteoint", "isMultiseart", "isMultiisearts", "isMultyppart", "isMultyparts", "isMultitearts"], "rd": ["ren", "ird", "rx", "rid", "pt", "hh", "wid", "lt", "rr", "RD", "dig", "dj", "ds", "func", "ind", "loc", "aa", "rs", "ru", "director", "rob", "fd", "cr", "rl", "wr", "pd", "fl", "rolog", "rss", "dr", "rb", "respond", "fr", "ld", "rw", "dd", "od", "rn", "rf", "cd", "ra", "rt", "std", "dh", "xd", "rg", "rh", "db", "dra", "td", "bd"], "upload": [" uploading", "form", "create", "util", "pload", "out", " submission", "instance", "Upload", "f", "load", "archive", "driver", "command", "input", "control", "project", "image", "or", "install", "folder", "object", "up", "io", "sup", "url", " instance", " uploaded", " Upload", "server", "transfer", "post", "zip", "container", "uploads", "dd", "stream", "parser", " archive", "file", "pkg", "user", "audio", "http"], "webUrl": ["rootPage", "wwwURL", "webUr", " webUr", "wwwUrl", "WebUrl", "rootURL", "WebUr", "rootPath", " webLine", " webPath", " webURL", "webPath", "WebLine", "rootUr", "webPage", "wwwUr", " webPage", "WebPath", "webURL", "webLine", "WebURL", "WebPage", "wwwLine"], "iter": ["inse", "itter", "init", "set", "apper", "inner", " iterator", "ver", "info", "ite", "its", "ter", "cher", "feed", "keep", "enter", "gener", "or", "loc", "ner", "walker", "in", "liter", "ir", "Iterator", "collect", "iv", "it", "izer", "outer", "Iter", "exec", "ator", "li", "list", "vis", "iner", "former", "over", "coll", "inc", "eni", "file", "ser", "er", "ignore", "err", "end", "reader", "inter", "keeper", "iterator", "oper", "slice", "order", "http"], "item": ["p", "source", "app", "result", "rec", " Item", "bar", "inner", "instance", "update", "custom", "info", "this", "extra", "hop", "link", "e", "input", "area", "image", "or", "atom", "data", "m", "get", "in", "object", "other", "record", "q", "ip", "up", "g", "ar", "it", "entity", "zip", "stat", "api", "Item", "li", "queue", "element", "layer", "coll", "plugin", "el", "value", "file", "temp", "part", "row", "r", "er", "feed", "entry", "items", "unit", "end", "user", "site", "op", "xml", "order"], "name": ["x", "call", "path", "field", "inner", "ame", "ni", "f", "NAME", "info", "not", "e", "one", "i", "word", "Name", "none", "data", "m", "nm", "in", "names", "old", "on", "n", "col", "label", "term", "na", "child", "time", "string", "connection", "size", "prefix", "layer", "am", "block", "nam", "orig", "named", "part", "key", "non", "id", "end", "type", "parent", "member", "common", "no"], "baos": ["BAo", "nais", "Baios", "abao", "BAOS", "baOs", "caos", "BAios", "cao", "cais", "BAis", "Bao", "paOs", "pao", "saOS", " baios", "BAoes", " baoes", "abaOS", "BaOs", " bao", "baOS", "saos", "Baos", "caOS", "paoes", "sais", " baOS", "bais", "naos", "baios", "abaios", "naOs", "caOs", "abaos", "nao", " bais", "Bais", "pais", "bao", "BAos", "paos", "sao", "baoes"], "wpIs": ["wpAs", "wpOs", "fwI", "cpis", "ipIS", "phpIns", "fwIs", "fwIS", "wpis", "WPIS", "wordpressis", "wpI", "wxIns", "fwAs", "wordpressAs", "ipAs", "cpIs", "WPI", "fpis", "WPIs", "WPAs", "phpIs", "wxIS", "xpIs", "wxis", "xpOs", "fpOs", "cpIns", "fpIs", "WPis", "phpIS", "cpIS", "wordpressIs", "phpis", "ipIs", "wpIns", "xpAs", "WPOs", "wxIs", "gpOs", "WPIns", "xpis", "gpIns", "wpIS", "wordpressOs", "fpIns", "gpis", "gpIs", "ipI"], "u": ["p", "uni", "uv", "uid", "una", "util", "su", "fu", "uri", "us", "Url", "c", "f", "s", "i", "input", "l", "web", "tu", "ru", "iu", "url", "ou", "b", "ui", "api", "nu", "bu", "uci", "ur", "ul", "lu", "Lu", "cu", "file", "hu", "mu", "U", "uu", "o"]}}
{"id1": "11475527", "id2": "9267602", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"addDataFromURL": ["addTextfromUrl", "addTextFromUrl", "addDataForurl", "addTextfromFile", "addDatafromFile", "addDatafromurl", "addDataFromurl", "addDatafromUrl", "addDatafromURL", "addDataFromUrl", "addTextfromurl", "addDataWithFile", "addDataForFile", "addDataWithURL", "addDataForURL", "addDataWithUrl", "addTextFromURL", "addTextFromurl", "addTextFromFile", "addDataForUrl", "addDataFromFile", "addTextfromURL", "addDataWithurl"], "theurl": ["theUrl", "thereuri", " thelog", "mypublic", "pythonurl", "testlog", "theURL", "testurl", "testUrl", "youUrl", "thelog", "youurl", " theuri", " theUrl", "myurl", "myURL", " theURL", "testURL", "theuri", "myUrl", " thepublic", " Theurl", "thepublic", " Thepublic", "pythonuri", "thereURL", "youlog", "youURL", " TheURL", " TheUrl", "thereurl", "pythonURL"], "line": ["text", "source", "style", "char", "buffer", "Line", "lines", "str", "out", "sync", "cell", "f", "len", "model", "pass", "link", "i", "l", "nl", "object", "comment", "url", "base", "name", "log", "character", "pe", "code", "number", "letter", "li", "string", "connection", "LINE", "el", "lin", "write", "cl", "ine", "block", "file", "part", "row", "key", "feed", "entry", "id", "le", "reader", "unit", "no"], "in": ["source", "init", "inn", "out", "client", "pin", "inner", "image", "s", "info", "pass", "i", "input", "l", "socket", "conn", "serv", "inside", "or", "read", "IN", "m", "ini", "record", "win", "io", "isin", "bin", "a", "url", "arin", "b", "it", "is", "fin", "nin", "ins", "fa", "cin", "stream", "lin", "In", "inc", "again", "rin", "file", "r", "err", "login", "oin", "reader", "din"], "data": ["source", "result", "buffer", "output", "lines", "out", "DATA", "inner", "f", "info", "this", "plus", "i", "one", "input", "l", "conn", "default", "writer", "da", "open", "ata", "up", "next", "url", "body", "dat", "connection", "di", "stream", "handler", "iter", "like", "file", "r", "er", "entry", "o", "reader", "end", "start", "d", "la"], "e": ["me", "ade", "se", "ace", "f", "eu", "event", "ale", "ue", "ie", "one", "de", "exc", "ele", "oe", "et", "or", "E", "ise", "ce", "ze", "ep", "ec", "ne", "ke", "be", "edge", "pe", "ge", "fe", "je", "ef", "element", "ee", "ae", "en", "eme", "es", "ev", "err", "er", "ede", "o", "error", "ception", "ea"]}}
{"id1": "1188100", "id2": "5989666", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"test": ["tests", "method", "call", "create", "out", "testing", "check", "Test", "show", " evaluate", "build", "example", "print", "execute", " example", "server", " testing", " Test", "run", "write", "fail", "debug", "start", "error", "report"], "s": ["p", "ls", "source", "as", "cs", "sb", "ps", "ts", "ss", "lines", "out", "sync", "us", "session", "f", "its", "state", "less", "w", "sym", "e", "i", "services", "l", "ds", "ans", "in", "service", "rs", "ws", "storage", "opens", "n", "g", "ks", "si", "ses", "ms", "os", "b", "server", "is", "fs", "bs", "stats", "south", "sl", "states", "h", "stream", "gs", "settings", "outs", "sets", "ns", "ils", "abs", "es", "ssl", "o", "sv", "S", "bis", "js", "d", "ops"], "input": ["flow", "source", "buffer", "copy", "output", "out", "reading", "instance", "w", "Input", "driver", "i", "image", "read", "data", "in", "storage", "io", "up", "a", "null", "rss", "stream", "qa", "raw", "php", "temp", "request", "r", "response", "ssl", "feed", "o", "reader", "xml", "audio"], "writer": ["work", "source", "buffer", "writers", "output", "str", "out", "written", "w", "ler", "per", "writing", "word", "pointer", "riter", "data", "walker", "builder", "storage", "Writer", "io", "editor", "wa", "null", "outer", "book", "writ", "wr", "letter", "string", "worker", "rw", "WR", "layer", "write", "raw", "wan", "wrapper", "office", "temp", "wb", "r", "er", "key", "o", "reader", "keeper", "xml"]}}
{"id1": "9996334", "id2": "8320469", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"generateToken": ["generationToken", "generATETokens", "generationSecret", "generATEKey", "generatedSecret", "generATESecret", "generationTokens", " GenerateTokens", "generateSecret", "generateTokens", "generatedToken", " GenerATETokens", "generATEToken", " GenerATESecret", " GenerateKey", " GenerateSecret", "generatedTokens", " GenerATEToken", " GenerateToken", "generationKey", "generateKey", " GenerATEKey", "generatedKey"], "code": ["text", "source", "message", "buffer", "ode", "token", "str", "output", "cache", "script", "c", "config", "info", "hash", "state", "input", "data", "mac", "next", "name", "password", "address", "hex", "Code", "body", "string", "header", "tag", "prefix", "codes", "cod", "value", "key", "id", "content", "coded"], "md": ["mand", "mm", "mp", "mod", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "po", "ds", "mb", "meta", "ind", "mg", "m", "metadata", "ad", "mac", "editor", "grad", "rm", "sm", "ms", "kg", "pd", "sha", "gd", " MD", "od", "dd", "mo", "cm", "mt", "hd", "cd", "MD", "mc", "ma", "df", "mu", "mag", "pm", "d", "bd"], "bytes": ["parts", "bles", "Bytes", "units", "words", "output", "lines", "bits", "ips", "s", "buf", "seconds", "groups", "les", "data", "strings", "binary", "bps", "vs", "values", "pieces", "b", "objects", "files", "zip", "bs", "address", "body", "string", "codes", "outs", "es", "tes", "classes", "boot", "blocks", "bin"]}}
{"id1": "13414771", "id2": "5723876", "code1": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"encriptPassword": [" desryptpassword", " enjectSecret", " encriptSecret", " encriptPass", " encriptpassword", " descriptPassword", " desryptSecret", " desjectPass", " descodepassword", " descriptSecret", " descodePassword", " desjectPassword", " desryptPass", " descriptpassword", " descodePass", " enjectPassword", " descriptPass", " desryptPassword", " desjectSecret", " enjectpassword", " descodeSecret", " desjectpassword", " enjectPass"], "passwd": ["assw", " passw", " passpassword", "failwt", "asswd", "Passpassword", "passwt", "failwd", "Passw", "asspassword", "password", "passw", " password", "Passwd", "passpassword", "assword", "Password", "failpassword", "failword", " passwt", "Passwt"], "md": ["mand", "hm", "mm", "mp", "mod", "amd", "wd", "dig", "cmd", "dm", "mb", "mg", "m", "nm", "metadata", "ad", "mad", "mac", "rm", "ms", "sm", "vd", "kg", "nd", "pd", "sha", "gd", " MD", "gb", "od", "di", "dd", "ld", "mo", "bm", "mt", "hd", "cd", "MD", "mc", "ma", "mag", "pm", "d", "bd"], "hash": ["message", "hed", "copy", "square", "check", "ash", "f", "dig", "image", "oh", "count", "build", "kh", "object", "auth", "mac", "shadow", "print", "log", "num", "array", "Hash", "password", "number", "sha", "hex", "body", "index", "h", "string", "sh", "sum", "html", "value", "version", "key", "her", "user", "rh", "node"]}}
{"id1": "255765", "id2": "16079868", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"f": ["p", "x", "form", "lf", "F", "flat", "filename", "ref", "of", "fp", "fun", "fx", "cf", "path", "c", "s", "this", "w", "e", "l", "ff", "m", "fm", "folder", "fen", "bf", "self", "io", "g", "n", "a", "fo", "inf", "name", "b", "fd", "fs", "fe", "function", "j", "h", "fn", "fr", "fa", "tf", "rf", "fc", "file", "df", "t", "feed", "r", "sf", "fi", "fold", "v", "d"], "in": ["source", "init", "gin", "session", "config", "w", "image", "con", "isin", "ins", "In", "d", "rec", "inn", "token", "pin", "with", "or", "IN", "data", "ini", "win", "n", "g", "up", "nin", "thin", "lin", "t", "diff", "bin", "str", "input", "socket", "serv", "a", "b", "gen", "is", "login", "reader", "get", "inc", "din", "p", "inner", "c", "ac", "pass", "ex", "l", "m", "it", "vin", "exec", "fe", "min", "connection", "fa", "lock", "cin", "again", "rin", "part", "r", "err", "ssl", "v", "ic"], "cbuf": ["cfuc", "rbbuf", "bcul", "bbuf", "bbuff", "ebuff", "fbuf", "rbux", "fbbuf", "bburs", "bbull", "rbuff", "cbutf", "bcur", "cbault", "rbul", "bcux", "buff", "buf", "dbuc", "rbuc", "fbuc", "cbuc", "dbuff", "zbuu", "cbux", "zbuf", "bcuff", "rbault", "rbutf", "cbuff", "ebuf", "bcuf", "CBuc", "bcull", "bux", "bault", "CBuf", "fbuff", "bcurs", "CBul", "ebuu", "cfuf", "dbur", "zbuff", "cfuff", "dbuf", "cbur", "rbull", "cfbuf", "cbull", "cbul", "CBuff", "rbuu", "rbuf", "rburs", "cburs", "cbuu", "ebutf", "cfur", "bcuc", "zbutf", "cbbuf", "bcault"], "read": ["work", "text", "x", "buffer", "Read", "parse", "want", "config", "w", "k", "cel", "val", "build", "close", "name", "log", "add", "pe", "report", "reads", "ack", "size", "stream", "repeat", "write", "ak", "ok", "iter", "un", "y", "key", "feed", "type", "start", "error", "d", "run", "last", "sync", "check", "load", "use", "view", "level", "ed", "count", "data", "play", "io", "g", "allow", "rc", "raw", "used", "ing", "insert", "id", "select", "know", "call", " reading", "reading", "update", "lex", "READ", "input", "send", "skip", "socket", "sleep", "ind", "readable", "print", "valid", "bit", " write", "each", "ize", "only", "en", "orig", "wait", " READ", "loop", "put", "reader", "bind", "get", "inc", "fill", " Read", "ride", "seek", "create", "re", "se", "length", "pass", "q", "record", "open", "old", "find", "connect", "ink", "num", "it", "change", "child", "hex", "oct", "index", "full", "r", "er", "end", "draw"], "totRead": ["totoRead", "totReading", "tobyLoad", " totLink", "notLoad", "totiBuild", "octotoReading", "tazonLoad", "TotWrite", "totSearch", " totalBuild", "TotaWrite", "totalBuild", "ntotWrite", "intotRead", "nottRead", "intottLoad", "tottSearch", "totaReading", "totiLink", "TottLoad", "totalAccept", "totaRead", "tobyUse", "tottFind", "totoLength", " totalWrite", "nottWrite", "dottLoad", "tottClose", "TotaLoad", "towWrite", "tetRead", "dotLoad", "tottedFollow", "totoConnect", "tottReader", "TottReader", "towReading", "tntWrite", "TottSearch", "dottReading", "totoUse", "intottBuild", "totingGet", "tottUse", "totaLink", "ntotRead", "totClose", "totGet", "tottBuild", "octotRead", "totoFind", "tottAccept", "dotReader", "TottFollow", "totalRead", "TotConnect", "towRead", "totAccept", "totoLoad", "towLoad", "totaBuild", "dottReader", "totoReading", "dotUse", "octotLength", "nottLoad", "tochLoad", "ntottLoad", "tottConnect", "TotSearch", "tatReader", "totingWrite", "TottRead", "tottLoad", "dottWrite", "totUse", "TotLoad", "dottUse", "TotFollow", "ntottReader", " totalLink", "totingSearch", "tottDraw", "totLoad", "totReader", " totalRead", "toyWrite", "tetWrite", "dottRead", "totLink", "tottGet", "toyDraw", "tntRead", "ntottRead", "intotLoad", "tottWrite", "totiRead", "TotaRead", "tochWrite", "TotDraw", "TotGet", "totaWrite", "tochRead", "intotBuild", "toyLoad", "tottedRead", "tochReader", "totingRead", "notWrite", "notAccept", "tollWrite", "ntottWrite", "TotaDraw", "tntReader", "tottRead", "TottConnect", "totoWrite", "ntotReader", "intottClose", "TottWrite", "tcotBuild", " totBuild", "tatRead", "tobyRead", "TottGet", "tcotLoad", "TotReader", " totWrite", "octotReading", "tollRead", "totalLink", "tollLoad", "totBuild", "ntotLoad", "tntLoad", "totingConnect", "tobyFind", "tcotClose", "tazonBuild", "tottLength", "nottAccept", "tollReading", "tottedWrite", "notRead", "dotReading", "tottFollow", "totalLoad", "tatLoad", "totingFollow", "tazonClose", "towLength", "TotReading", "totaLoad", "tottReading", "totDraw", "dotWrite", "totoSearch", "totLength", "totWrite", "octotoWrite", "totConnect", "tottedGet", "tatWrite", "dotRead", "octotWrite", "tetReading", "intottRead", "dottFind", "dotFind", "intotClose", "totaDraw", "totalWrite", "octotoLength", "TottReading", "totFind", "totaReader", "tetLoad", "toyRead", "tcotRead", "tazonRead", "TotRead", "totFollow", "totiWrite", "octotoRead", "towAccept"], "out": ["p", "x", "init", "output", "client", "sync", "net", "c", "ac", "s", "w", "plus", "ex", "l", "socket", "conn", "OUT", "writer", "n", "g", "io", "a", "up", "b", "outer", "ext", "exec", "obj", "conf", "h", "fn", "exp", "connection", "Out", "In", "outs", "inc", "again", "off", "file", "parent", "part", "t", "err", "r", "o", "v", "bin", "d"], "i": ["x", "source", "init", "buffer", "current", "ai", "I", "k", "ci", "abi", "chi", "ip", "name", "u", "li", "y", "key", "slice", "start", "d", "ti", "uri", "info", "ei", "one", "data", "ini", "multi", "iu", "bi", "io", "g", "pi", "api", "j", "eni", "id", "hi", "me", "ii", "e", "input", "ind", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "zi", "ri", "my", "phi", "p", "length", "z", "c", "ni", "gi", "ix", "ori", "ie", "l", "yi", "m", "q", "it", "ui", "ik", "oi", "index", "fi", "r", "v", "ic"]}}
{"id1": "7122523", "id2": "14038176", "code1": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"execute": ["method", "message", "call", "create", "result", "forward", "invoke", "instance", "info", "this", "send", "func", "default", "process", "data", "transform", "action", "next", "exec", "transfer", "report", "post", "submit", "route", "apply", "start", "handle", "run"], "mapping": ["Mapped", "rmappings", "mmailing", "mmapping", " mappings", "mappings", "patching", "rmapper", "papping", "pailing", "Mapping", " mailing", "mmatching", "Mapper", " mapper", " matching", "mmording", "Mappings", "mapped", " mording", "rmapped", "mapper", "rmapping", " mapped", "matching", "mailing", "pording", "mording"], "form": ["flow", "app", "FORM", "path", "forms", "session", "field", "Form", "config", "model", "page", "view", "command", "control", "input", "object", "format", "builder", "transform", " forms", "post", "query", "upload", "former", "submit", "route", "template", "entry"], "request": ["method", "message", "create", "result", "current", "client", "path", "session", "instance", "frame", "model", "event", "view", "use", "state", "input", "enter", "image", "req", "web", "q", "object", "resource", "QUEST", "ware", "subject", "server", "query", "queue", "handler", "submit", "parent", "route", "user", "type", "xml", "Request", "report", "context", "application"], "response": ["message", "result", "output", "client", "session", "status", "model", "http", "view", "page", " Response", " responses", "manager", "application", "resp", "req", "data", "object", "resource", "server", "Response", "res", "results", "error", "report", "reply"], "delegate": ["DElegate", "deider", "DEleg", " deplementation", "relegates", "Deleg", "declegates", "Delegate", "DElegates", "rolelic", " deleg", "Deplementation", "declegate", "Delic", " delegates", "Deploy", "Deider", " deider", "Delegates", "rolelegates", "reploy", "deplementation", "roleplementation", "relegate", "decider", "delegates", "DEploy", "releg", " delic", "deploy", "deleg", "rolelegate", "decleg", "delic"], "errors": ["relations", "rules", " Errors", "effects", "ays", "management", "eps", "orders", "ations", "instance", "s", "all", "e", " responses", "issues", "les", "rors", "data", "rs", "ages", "values", "ros", "error", "array", "null", "objects", "params", " messages", "members", "reports", "rss", "asts", "links", "ins", " problems", "details", "ae", "settings", "parser", "runs", "failed", "uments", "plugins", "es", "ceptions", " exceptions", "err", "results", "items", "maps", "comments", "blocks", "events", "xml", "rows", "ops"], "ayudaPantalla": ["ayudaPantala", "ayudaPandilla", "ayudaPantella", "ayudaPandala", "ayudaPentella", "ayudaParaala", "ayudaPatantilla", "ayudaParala", "ayudaTantilla", "ayudaTentella", "ayudaPandalla", "ayudaParaalla", "ayudaPantsala", "ayudaPantilla", "ayudaTentalla", "ayudaPantsla", "ayudaPantsilla", "ayudaParailla", "ayudaPentilla", "ayudaPantsella", "ayudaPentala", "ayudaPatarailla", "ayudaPatantala", "ayudaPantsalla", "ayudaPantla", "ayudaPatantla", "ayudaTantala", "ayudaPandla", "ayudaTantella", "ayudaPentalla", "ayudaPataraala", "ayudaPataraalla", "ayudaPatantalla", "ayudaPatarala", "ayudaTantalla", "ayudaPandella", "ayudaTentala", "ayudaTentilla"], "traAyudaPantalla": ["traAyudaPlantalla", "traAyudaPantingalla", "traAyudaPlantingella", "traAyudaPartalla", "traAyudaPlantella", "traAyudaPlantilla", "traAyudaPantingala", "traAyudaParaalla", "traAyudaPentella", "traAyudaParaala", "traAyudaPandella", "traAyudaVantlla", "traAyudaPartlla", "traAyudaPartaya", "traAyudaParalla", "traAyudaPantingilla", "traAyudaPentilla", "traAyudaVandalla", "traAyudaPantaya", "traAyudaPandaya", "traAyudaParaaya", "traAyudaVantalla", "traAyudaPlantala", "traAyudaPentalla", "traAyudaPandala", "traAyudaPlantingalla", "traAyudaPandalla", "traAyudaPantilla", "traAyudaVantaya", "traAyudaVandala", "traAyudaPantella", "traAyudaVantala", "traAyudaPlantingilla", "traAyudaPlantingala", "traAyudaPantlla", "traAyudaPandlla", "traAyudaPantala", "traAyudaPentala", "traAyudaPantingella", "traAyudaVandlla", "traAyudaVandaya", "traAyudaPartala", "traAyudaPandilla"], "urlSonido": ["UrlSenido", "urlSONida", "urlTonigma", " urlTonado", "urlSonri", "urlSonado", "urlTonid", " urlTonini", "urlSenido", "UrlSenini", "uriSonid", "urlTonini", "urlBonido", "urlSONido", "uriSonini", "urlsonigma", "urlSonidi", "urlsonigo", "UrlSonuli", "UrlSonido", " urlTonido", "urlsonri", "UrlSonigo", " urlTonigo", "urlTonido", "urlSenini", "uriSONid", "urlMonido", "UrlSonidi", "urlSenri", "urlSONidi", "UrlBonuli", "UrlBonidi", "uriSONido", "urlBonuli", "UrlBonida", "UrlSonri", " urlSonado", "urlSonid", "uriSONigma", "UrlSonida", "urlBonida", "urlSonuli", "urlTonigo", "urlSONuli", "urlSonigma", "urlMonuli", "UrlSenigo", " urlSonigo", "urlTonado", "urlSonida", "urlTonri", "uriSONini", "urlsonini", "urlSONini", "urlSenigo", "UrlBonido", "urlBonini", "urlsonid", "urlMonida", "urlBonigo", "urlSonigo", "urlSONigma", "urlBonidi", "urlsonido", "urlBonado", "UrlSonini", "uriSonigma", "uriSonido", " urlSonini", "urlSONid", "urlMonidi", "UrlSenri", "urlSonini", "urlsonado"], "url": ["ls", "source", "gl", "uri", "json", "client", "str", "path", "Url", "download", "f", "config", "system", "page", "control", "l", "image", "web", "service", "resource", "location", "www", "base", "log", "b", "server", "URL", "fl", "sl", "string", "connection", "ll", "full", "impl", "ssl", "user", "http"], "urlConnection": ["URLFactory", "webClient", " urlconnection", "URLClient", "urlConnector", "UrlConnect", "httpConnection", "httpFactory", "UrlConnection", "urlInfo", "UrlConnector", "eventConnection", "webFactory", "UrlInfo", "webconnection", "URLConn", "URLConnection", "urlConn", "httpClient", "userConnection", "webConnection", "webConn", "userconnection", "userInfo", "eventConnector", "Urlconnection", "httpConn", "urlConnect", "urlFactory", "eventConnect", "webConnect", "urlconnection", "eventconnection", "webConnector", " urlInfo", "urlClient"], "tipoMime": ["tipoPike", "tipoDemIME", "tipoCext", "tiposTike", "tiposMike", "tiposTIME", "tipoKnime", "tiposTime", " tipoSmime", "tipoPIME", "tipoTize", "tiposTorph", "tipoTIME", "tiposMize", " tiposMile", "tipoText", " tiposTpe", " tiposMpe", "tiposManche", "tipoTorph", "tipoNile", "tiposMime", " tipoMIME", " tiposTIME", " tipoSmpe", "tipoDemime", "tipoDemize", "tipoPime", "tipoTime", " tiposTile", "tipoMale", "tiposMorph", "tipoManche", " tipoTIME", " tipoMetime", "tipoNext", "tipoImize", " tiposTime", "tiposMext", "tipoMike", "tipoCIME", "tiposTile", "tipoTile", " tipoMile", "tipoMile", " tipoTime", "tipoKnIME", "tiposMIME", " tiposMime", "tipoCorph", "tipoMorph", " tiposMIME", " tipoSmIME", "tipoTale", "tipoNIME", "tipoKnanche", "tipoImime", "tipoImale", " tipoMetpe", "tipoMext", "tiposText", "tipoNime", "tipoCime", "tipoImIME", "tipoDemale", " tipoMpe", "tipoTike", "tipoMIME", " tipoTpe", "tiposTanche", "tipoCile", " tipoSmile", "tiposTize", "tipoKnike", "tiposMale", "tipoPanche", "tiposMile", " tipoMetile", " tipoMetIME", "tipoTanche", "tipoMize", " tipoTile", "tiposTale"], "audioOptions": ["audioVideo", "archiveOptions", " audioStream", " audioStyle", "oggContents", " audioSettings", "soundOptions", "audioRules", "audiooptions", " audioGames", "musicSettings", "soundoptions", " audioColor", " audioRules", "archiveColor", "AudioStyle", "AudioOptions", "audioStream", "mediaStyle", "AudioGames", "videooptions", "soundSettings", " audioParts", "musicOptions", "videoStream", "mediaOptions", "audioStyle", "oggOption", "oggRules", "videoParts", "oggOptions", "audioOption", " audiooptions", "mediaVideo", "audioContents", "mediaGames", "videoGames", "AudioColor", "audioColor", "archiveStyle", "mediaSettings", "soundContents", "videoSettings", " audioContents", "audioParts", "archiveStream", "mediaParts", "audioSettings", "videoOptions", "musicStream", "soundRules", "AudioSettings", "videoVideo", "audioGames", "soundOption", "AudioStream", " audioVideo", " audioOption", "musicParts"]}}
{"id1": "21438069", "id2": "732800", "code1": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"createNewProjectDeploymentConfig": ["createNewProjectDeploymentsConfig", "createNewProjectDeployizationInfo", "createNewProjectDeploymentsConfiguration", "createNewProjectDeployerConfig", "createNewProjectDeploymentInfo", "createNewProjectDeploymentFile", "createNewProjectDeployizationConfiguration", "createNewProjectDeploymentsInfo", "createNewProjectDeployizationConfig", "createNewProjectDeployerConfiguration", "createNewProjectDeployizationFile", "createNewProjectDeployerFile", "createNewProjectDeployerInfo", "createNewProjectDeploymentConfiguration", "createNewProjectDeploymentsFile"], "projectID": ["documentId", "contractType", "appID", "packageIDs", "configIP", "contractID", "subjectId", "appId", "packageType", "documentIL", " projectIL", "projectIDs", " projectid", "databaseId", " projectType", " projectIDs", "databaseIDs", "subjectid", "appid", "projectIL", "contractid", "appIL", "packageID", " projectIP", "documentID", "configid", "configId", " projectId", "packageid", "projectIP", "projectId", "databaseid", "projectType", "subjectID", "projectid", "packageId", "documentid", "subjectIP", "databaseID", "configID"], "name": ["create", "filename", "path", "username", "session", "ame", "alias", "with", "NAME", "model", "title", "pass", "word", "Name", "image", "none", "an", "data", "names", "menu", "definition", "release", "nice", "on", "n", "job", "database", "label", "mini", "ui", "address", "na", "time", "string", "ename", "size", "prefix", "profile", "plugin", "block", "creation", "named", "value", "version", "part", "custom", "id", "common", "parent", "type", "vision", "no"], "description": ["text", "secret", "message", "filename", "position", "video", "summary", "expression", "uri", "username", "language", "escription", "NAME", "model", "title", "environment", "image", "design", "des", "definition", "duration", "release", "resource", "location", "comment", "document", "display", "reason", "label", "password", "operation", "address", " descriptions", "string", "direction", "category", "esc", "details", "desc", "value", "version", "unit", "type", "section", "vision", "Description"], "config": ["text", " exc", "result", "cache", "output", "uc", "client", "out", "cf", "Config", "dict", "Configuration", "c", "instance", "cat", "cb", "gui", "driver", "cmd", "cfg", "conn", "ca", "project", "data", " lib", "service", "bc", "log", "sec", "lc", "proc", "ext", " cache", "cont", "spec", "cos", "obj", "conf", "exec", "ch", "rc", "struct", "acc", "settings", "def", "lib", "json", "ct", "ctx", "current", "section", "db"], "connection": ["message", "relation", "cache", "client", "connected", "session", "c", "ion", " Connection", "Connection", "state", "use", "driver", "manager", "conn", "socket", "image", "loc", "condition", "con", "resource", "communication", "directory", "connect", "document", "si", "database", "bc", "log", "error", "graph", "server", "pool", "password", "function", "index", "container", "machine", "channel", "lock", "cond", "sql", "collection", "version", "ongo", "volume", "response", "unit", "ctx", "engine", "section", "db", "network", "context", "application"], "statement": ["ment", "sequence", "relation", "result", "summary", "expression", "ss", "str", "se", "parse", "git", "Statement", "session", "table", "instance", "state", "use", "Connection", "link", "driver", "command", "i", "note", "pass", "serv", "conn", "ri", "condition", "writer", "comment", "storage", "connect", "document", "si", "database", "execute", "server", "function", "stat", "li", "string", "usage", "di", "mt", "sql", "parser", "collection", "response", "unit", "commit", "Session", "section", "db", "report", "status"], "resultSet": [" resultRow", "responseList", "responseSc", "ResultSource", "resultsGen", " resultList", "responseSet", "pageSource", "rowSet", "pageSet", "resultGen", "resultSc", "ResultLine", "ResultGen", "ResultSet", "responseSource", "resultList", " resultSc", "resultRow", "resultSource", "ResultS", "resultsList", "ResultRow", "responseS", "resultsSource", "ResultList", "pageRow", "rowLine", " resultSource", "ResultSc", "resultsSet", "rowSource", "resultLine", " resultGen", " resultS", "resultS", " resultLine"], "query": ["work", "message", "call", "create", "style", "result", "select", "question", "expression", "table", "str", "out", "uri", "parse", "json", "script", "update", "timeout", "command", "i", "root", "send", "qq", "condition", "m", "q", "in", "module", "resource", "where", "comment", "database", "search", "code", "password", "function", "scope", "string", "rule", "lock", "scan", "sql", "qu", "sq", "filter", "request", "key", "id", "join", "type", "error", "Query", "report", "go"], "msg": ["text", "og", "message", "char", "Message", "gor", "md", "ug", "str", "tool", "title", "rr", "ag", "mr", "cmd", "e", "sg", "phrase", "agg", "rag", "cfg", "var", "exc", "fg", "mg", "loc", "req", "m", "fm", "map", "nm", "format", "bf", "mor", "g", "log", "reason", "Msg", "ext", "gen", "ge", "bg", "gm", "gr", "dr", "tag", "mn", "mt", "gs", "html", "desc", "cap", "essage", "err", "ma", "op", "id", "pkg", "comm", " message", "type", "error", "doc", "status"]}}
{"id1": "6159896", "id2": "4531653", "code1": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "code2": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"md5": [" md4", "MD4", "MD5", "MD7", "sha7", " md7", "sha2", "md4", "md2", "sha4", " md2", "md7", "sha5", "MD2"], "str": ["text", "source", "char", "buffer", "result", "style", "arr", "st", "br", "Str", "f", "s", "this", "bytes", "txt", "e", "input", "STR", "stri", "data", "m", "in", "strings", "star", "self", "url", "name", "hr", "spec", "code", "obj", "msg", "sp", "dr", "string", "exp", "fr", "tr", "r", "doc"], "md": ["mand", "hm", "mm", "mp", "git", "amd", "Cmd", "f", "wd", "cmd", "dm", "de", "cfg", "mb", "mg", "m", "nm", "amp", "mac", "bf", "rm", "sm", "vm", "vd", "pd", "sha", "gm", "gd", " MD", "gb", "ld", "di", "dd", "bm", "cm", "hd", "cd", "mem", "MD", "dh", "mc", "df", "pkg", "mag", "pm", "db", "d", "rpm", "bd", "mail"], "b": ["p", "ab", "buffer", "br", "cb", "c", "f", "bb", "fb", "s", "buff", "buf", "bytes", "reb", "ba", "e", "pb", "l", "bl", "mb", "B", "ib", "binary", "lb", "bf", "g", "a", "base", "bt", "u", "nb", "bs", "body", "rb", "gb", "abb", "emb", "wb", "ob", "bis", "db", "d", "bd"], "sb": ["ls", "lp", "bh", "buffer", "ss", "xb", "SB", "obb", "bb", "fb", "s", "buf", "bj", "lab", "ub", "sg", "pb", "src", "mb", "B", "bp", "ib", "kb", "zb", "bps", "lb", "bf", "sa", "si", "bc", "tmp", "bt", "usb", "nb", "sc", "bs", "sl", "bg", "sp", "rb", "db", "gb", "sk", "BB", "lr", "orb", "acc", "cca", "sq", "bsp", "wb", "sf", "ob", "sv", "cb", "abb", "bd"], "i": ["p", "x", "uri", "z", "c", "f", "ai", "s", "ii", "gi", "ix", "e", "vi", "ie", "l", "I", "k", "ci", "val", "abi", "ini", "in", "multi", "ip", "n", "bi", "g", "a", "si", "io", "u", "it", "ui", "pi", "oi", "li", "index", "j", "h", "di", "qi", "y", "xi", "fi", "t", "key", "o", "id", "ri", "ti", "phi"], "v": ["p", "x", "cv", "uv", "cover", "nv", "c", "f", "ver", "ve", "vt", "s", "vg", "e", "vi", "vol", "l", "va", "k", "ov", "val", "m", "q", "vp", "tv", "vs", "n", "g", "av", "u", "vd", "conv", "iv", "j", "h", "qv", "V", "value", "vc", "lv", "ev", "t", "r", "vv", " vi", "o", "sv", "d"], "cc": ["cv", "cmp", "cs", "uc", "cf", "c", "tc", "ca", "cel", "ci", "cci", "ce", "ec", "sup", "bc", "lc", " c", "C", "CC", "code", "sc", "ch", "rc", "esc", "ucc", "enc", "cl", "coll", " ecc", "cca", "acc", "fc", "cu", "lv", "vc", "cn", "ct", "ck", "inc", "cb", "co", " CC", "dc"], "returnString": ["ReturnString", "returnstring", "resultStr", "resultArray", " returnstring", " returnLine", "resultstring", "resultString", "returnLine", " returnArray", " returnStr", "ReturnStr", "ReturnLine", "returnArray", "Returnstring", "resultLine", "ReturnArray", "returnStr"]}}
{"id1": "23008590", "id2": "5299276", "code1": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"run": ["work", "init", "output", "load", "update", " deploy", "info", "java", "running", "Run", "build", "process", "install", "up", "execute", "server", "exec", "report", " Run", "submit", "Main", "test", "login", "apply", "launch", "start"], "url": ["source", "uri", "str", "browser", "path", "Url", "download", "f", "update", "config", "page", "il", "i", "l", "image", "blog", "loader", "loc", "web", "service", "resource", "location", "proxy", "hub", "www", "base", "name", "bel", "server", "article", "host", "URL", "sl", "address", "api", "string", "ur", "lr", "file", "r", "feed", "ssl", "keeper", "id", "http"], "is": ["ls", "as", "ris", "app", "uri", "IS", "out", "was", "browser", "ai", "s", "info", "its", "il", "iss", "i", "ie", "Is", "src", "image", "or", "ini", "in", "lis", "ir", "ip", "io", "ar", "os", "iv", "it", "ui", "fs", "address", "api", "isi", "stream", "ais", "ios", "iter", "es", "r", "err", "id", "bis", "iterator", "has", "ri", "http"], "writer": ["work", "wer", "source", "writers", "out", "widget", "wire", "written", "page", "w", "driver", "ler", "writing", "word", "war", "riter", "data", "ner", "walker", "in", "builder", "director", "journal", "ws", "Writer", "editor", "null", "server", "player", "writ", "wr", "letter", "zip", "string", "worker", "handler", "layer", "ee", "write", "winner", "parser", "creator", "maker", "file", "temp", "r", "er", "key", "feed", "parent"], "buffer": ["vector", "sequence", "source", "char", "position", "result", "cache", "length", "memory", "buff", "buf", "page", "seed", "bytes", "phrase", "uffer", "padding", "border", "read", "data", "resource", "binary", "base", "character", "b", "player", "transfer", "counter", "address", "Buffer", "string", "stack", "queue", "layer", "batch", "block", "iter", "row", "wave", "feed", "slice", "bin"], "reader": ["source", "rx", "reading", "f", "rr", "rar", "ler", "e", "i", "input", "per", "bird", "read", "loader", "ner", "in", "oder", "ir", "io", "editor", "rer", "dr", "worker", "stream", "handler", "parser", "Reader", "iter", "row", "r", "er", "ser", "iterator", "ri"], "n": ["p", "x", "out", "z", "c", "f", "s", "not", "len", "nt", "i", "e", "l", "pos", "k", "count", "N", "nor", "m", "ner", "nl", "ne", "nn", "b", "num", "u", "nb", "number", "nin", "na", "j", "h", "nc", "ng", "en", "sn", "ns", "y", "r", "t", "dn", "o", "nr", "d", "no"], "updatePage": ["updatedLine", " updateFile", "downloadUrl", "UpdateUrl", "downloadPage", " updateLine", "updateUrl", "workLine", "updatedUrl", "downloadpage", " updateSite", "currentSite", "updateServer", "updatedFile", "UpdateFile", "currentpage", "currentLine", "currentPage", "currentServer", "Updatepage", "updatedpage", " updateUrl", "currentUrl", "updateFile", " updateVersion", "updatedServer", "updateLine", "updateSite", "updatedVersion", "workSite", "UpdateVersion", "updatedPage", "workPage", " updatepage", " updateServer", "updateVersion", "downloadLine", "updatepage", "downloadVersion", "UpdatePage"], "pos1": ["position1", "positionOne", "posOne", "position2", "Pos1", "pos0", "Pos4", "POS0", "POSOne", "position4", "POS3", " posOne", "position0", "Pos3", "Pos2", "position3", " pos0", "POS1"], "pos2": ["index5", "position1", "posSecond", "position2", "po22", "po5", "POS4", "index22", "POS22", "POS5", "POS2", "index3", "index2", "pos22", "indexSecond", " posSecond", "po4", "index1", "position3", "po2", "positionSecond", "index4", "pos5"], "pos3": ["position1", " pos03", "position2", "Pos1", "position03", "pose43", "Pos43", "pose3", "Pos03", "pose2", "Pos3", "position43", "Pos2", "position3", "pos43", "pose1", "pos03"], "pos4": ["posfour", "position2", "po1", " posfour", "pose04", "pofour", "index7", " pos7", " pos04", "position4", "index3", "po04", "index2", "posefour", "po4", "pos7", "pos04", "pose4", "position3", "pose1", "position7", "index4"], "currentVersion": ["updatePackage", "CurrentRelease", "CurrentPackage", "currentRelease", "CurrentUrl", "initialVersion", "reportedName", " currentRelease", " currentName", "reportedVersion", "CurrentName", "currentVer", "CurrentVersion", " currentPage", "currentPatch", " currentUrl", "currentPage", "reportedPatch", "CurrentVer", " currentPatch", "initialVer", "currentUrl", "CurrentPage", "initialPackage", " currentPackage", "reportedUrl", "CurrentPatch", "currentPackage", "updateVersion", "initialPage", "currentName", "updateVer", "updateRelease"], "downloadURL": [" downloadUrl", "updateURL", "downloadUrl", "installLocation", "downloadLocation", " downloadLocation", "updateLocation", "updateUrl", "installURL", "installUrl"]}}
{"id1": "5760649", "id2": "530882", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"createFile": ["createContent", "saveFolder", "saveResource", "saveContent", " createContent", "CreateFile", "CreateContent", "createFolder", " createFolder", "createResource", "saveFile", " createResource", "CreateResource", "CreateFolder"], "src": ["source", "sb", "fp", "uri", "path", "username", "load", "s", "buf", "txt", "input", "resources", "loc", "data", "Source", "resource", "img", "dest", "rob", "url", "name", "proc", "obj", "files", "sel", "sit", "sl", "sc", "secure", "SourceFile", "rc", "rss", "string", "fn", "rb", "upload", "gb", "stream", "ruby", "file", "r", "ssl", "slice", "href", "cb", "content"], "filename": ["source", "uri", "fp", "output", "length", "path", "username", "feat", "ame", "f", "s", "title", "txt", "fil", "l", "loader", "location", "metadata", "resource", "which", "dll", "directory", "FILE", "url", "name", "ames", "files", "rl", "SourceFile", "string", "fn", "ename", "prefix", "Filename", "acl", "file", "utf", "route", "nil", "wb", "sf"], "fis": ["fbs", "Fiss", "fiss", "cfIS", "cfris", "FIS", " fiss", "sfis", "Fbs", "sfos", "fris", "Fos", "Fis", " fais", "Fais", "fais", "cfis", "Fris", "cfbs", "fIS", "sfris", " fIS", "cfais", "sfiss", " fbs", "cfos", " fris"], "fos": ["affis", "affios", "Fas", "bos", "sfios", "foras", "sfis", "affbos", "affos", "Fbos", "sfos", "FOS", " fops", "sfops", " fOS", "bbos", "Fos", "fbos", "bios", "Fis", "Fops", "fas", "fios", " fas", "foris", "Fios", "fOS", "bis", "fops", " fios", "foros", "forOS"]}}
{"id1": "3266833", "id2": "17161805", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"is": ["mis", "as", "init", "ris", "im", "IS", "was", "isa", "us", "info", "its", "isu", "iss", "i", "Is", "image", "or", "iso", "ib", "in", "lis", "close", "ir", "ws", "ip", "os", "iv", "isc", "fits", "bs", "ins", "ais", "ios", "es", "abs", "iris", "id", "bis", "get", "has", "cms"], "name": ["source", "filename", "large", "path", "ame", "memory", "alias", "NAME", "this", "title", "domain", "pass", "one", "word", "Name", "image", "default", "data", "names", "module", "nice", "format", "description", "n", "directory", "url", "base", "database", "search", "null", "label", "code", "address", "term", "min", "string", "connection", "size", "prefix", "office", "named", "file", "value", "space", "part", "version", "key", "id", "type", "parent", "vision", "no"], "contentType": ["ContentName", "mediaType", " contenttype", "outputPath", "documentInfo", "contentInfo", "ContentInfo", "messageType", "contentPath", "sourcetype", " contentInfo", "outputTypes", " contentPoint", "messageName", "sourceInfo", "messageInfo", "sourceType", "documentPoint", "mediaTypes", "mediaPath", "outputName", "messagetype", "contentName", "contentPoint", "ContentType", "Contenttype", "ContentPath", "outputType", "contenttype", "mediaName", "ContentTypes", "sourcePoint", " contentName", "documentType", "contentTypes", "documenttype"], "index": ["x", "position", "shape", "expression", "depth", "length", "update", "page", "timeout", "level", "i", "pointer", "input", "image", "none", "default", "data", "in", "open", "fix", "multi", "axis", "width", "search", "Index", "number", "address", "body", "append", "string", "list", "size", "alpha", "prefix", "height", "write", "weight", "value", "include", "pull", "key", "slice", "id", "end", "type", "inc", "error", "offset", "content"], "extension": ["configension", "extensions", "extance", "variension", "variuration", "exturation", "variance", "Extance", "configensions", "configuration", "configance", "Exturation", "Extension", "Extensions", "variensions"], "isImage": ["ISVideo", "IsFile", "isVideo", "asimage", "isImages", " isimage", "isMedia", "areMedia", "IsVideo", "isaImage", "isInstance", "asFile", "areInstance", "isFile", "ISImage", "areImages", "IsPicture", "ISFile", "isaMedia", "isimage", " isPicture", " isVideo", " isMedia", "areimage", "isaFile", "asInstance", "asImage", "areImage", "isaImages", "areFile", " isInstance", "isPicture", "ISPicture", " isFile", " isImages", "IsImage"], "isAux": ["isWalux", "isAslux", "isArrayUX", "isWaUX", " isArrayxt", "isAsx", "isAsUX", " isHaux", "asAsExcept", "isAlux", "isAAxt", "isAru", " isAx", " isAUX", "isAnux", "isAnlux", "isAsux", "isAAru", "isAxt", "isAex", "isAcUX", "isUUX", "isAsex", "isWax", "isAcxt", "isArrayux", "isArrayru", " isArrayru", "isAUX", "isOAExcept", " isArrayux", " isHalux", " isAxt", " isHax", "isAcru", "isOAux", "isHalux", "asAsUX", "isAAux", "asAsex", "isAAUX", " isArrayUX", "isOAUX", " isHaUX", "isAsExcept", "isWaux", "isHaux", "asAslux", "isUExcept", "asAExcept", " isAlux", "isAExcept", "isAnex", "isUlux", "isOAlux", "isUex", "asAex", "asAsux", "isHaUX", " isAru", "isAnUX", "isHax", "asAux", "asAlux", "isUux", "isArrayxt", "isAx", "isAcux", "asAUX"], "out": ["work", "source", "result", "buffer", "copy", "cache", "output", "table", "client", "sync", "inner", "at", "this", "page", "extra", "ex", "word", "input", "socket", "OUT", "image", "conn", "project", "data", "in", "object", "up", "io", "next", "a", "base", "array", "null", "outer", "ext", "exec", "post", "pool", "obj", "exp", "size", "over", "plain", "prefix", "Out", "auto", "outs", "again", "off", "file", "temp", "version", "part", "parent", "o", "user", " in", "error"], "bufferedImage": ["bufferingImage", "buffledimage", "BufferedImage", "buffendedimage", "BufferingImage", "buffledImage", "bufferingimage", "buffendedImage", "bufferedimage", "Bufferingimage", "Bufferedimage"], "inputStream": ["InputBuffer", "outputstream", "inputSteam", "outputStream", "InputStream", "Inputstream", "InputSteam", " inputstream", " inputBuffer", " inputSteam", "outputSteam", "inputstream", "outputBuffer", "inputBuffer"]}}
{"id1": "16760971", "id2": "5441579", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"generateHash": ["generatesHash", " GeneratedKey", "generoseMac", " GenerateSalt", " GeneratedMac", "generoseSalt", "generatedHash", "generatesMac", "generoseHash", " GeneratedSalt", "generateSalt", " GeneratedHash", "generoseKey", " GenerateHash", " GenerateKey", "generatedSalt", "generatesKey", " GenerateMac", "generateKey", "generatesSalt", "generateMac", "generatedMac", "generatedKey"], "key": ["work", "text", "secret", "message", "char", "cy", "token", "str", "ace", "fee", "path", "keys", "point", "date", "hash", "seed", "word", "k", "data", "cert", "ce", "mac", "self", "url", "base", "name", "pe", "code", "password", "msg", "address", "hex", "proof", "body", "string", "rule", "connection", "crypt", "prefix", "full", "block", "trust", "file", "sign", "KEY", "id", "type", "user", "Key", "pair"], "md": ["me", "mand", "message", "hm", "mm", "mp", "clean", "mod", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", "po", "ds", "mb", "mg", "m", "nm", "mage", "metadata", "mad", "ad", "mac", "editor", "bm", "rm", "sm", "ms", "mail", "nd", "pd", "dr", " MD", "ld", "di", "dd", "od", "cm", "mo", "mt", " Md", "hd", "mem", "am", "cd", "MD", "dh", "mc", "ma", "df", "mag", "pm", "d", "rpm", "bd", "dc"], "bytes": ["ls", "parts", "bles", "Bytes", "words", "lines", "bits", "ips", "keys", "fb", "s", "seconds", " bits", "vals", "les", "ones", "data", "errors", "strings", "bps", "binary", "vs", "cells", "values", "pieces", "letters", "pins", "b", "objects", "os", "files", "zip", "bs", "gb", "pages", "codes", "outs", "es", "items", "boot", "bis", "blocks", "rows", "ops"], "buff": ["app", "flat", "buffer", "sb", "uf", "fx", "py", "bag", "obb", "f", "bb", "fb", "buf", "hack", "bo", "txt", "agg", "pb", "ff", "mb", "cast", "ph", "amp", "kb", "bf", "tt", "tmp", "b", "fw", "nb", "Buffer", "append", "eb", "gb", "uff", "bm", "cp", "tf", "cpp", "batch", "html", "bug", "pp", "ob", "diff", "Buff", "ctx", "bis", "cb", "abb", "bd"], "l": ["p", "x", "ls", "lp", "ln", "L", "al", "length", "z", "kl", "c", "jl", "f", "pl", "il", "e", "i", "bl", "nl", "ell", "ol", "dl", "lb", "n", "u", "b", "lc", "col", "ly", "rl", "fl", "sl", "li", "j", "h", " L", "cl", "el", "ll", "ul", "lu", "lv", "t", "o", "le", "v", "d", "la"], "hx": ["dhx", " hxc", "hrx", "hxa", "hsrx", "Hxc", "hc", "Hrx", " hrx", "Hex", " hwx", "hsx", " hxa", "Hx", "hswx", "hwx", "dhc", " hc", " hex", "dhex", "Hc", "hex", "hsxc", "hxs", " hxs", "hmxs", "hxc", " hy", "hmy", "Hxa", "Hy", "hmx", "dhxc", "hmxa", "hy", "Hxs", "Hwx"]}}
{"id1": "19584877", "id2": "6988216", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToFiles", "encodeStringToFile", "encodeFileFromString", "encodeFileToStream", "encodeFileToString", "encodeFileFromStream", "encodeString2String", "encodeFile2File", "encodeFile2String", "encodeFiletoFiles", "encodeStringToStream", "encodeFileToFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeString2Stream", "encodeFile2Stream", "encodeFile2Files", "encodeFiletoFile", "encodeStringToString", "encodeFiletoString", "encodeString2File", "encodeFileFromFiles", "encodeString2Files"], "infile": ["infp", "outFile", "inputFile", "infiles", "InFile", "outfiles", "outfilename", "inputfile", " infilename", "inputfilename", "inFile", "inputfiles", "Infilename", "outfp", "inputfp", "Infiles", "Infile", "infilename", " infiles", " infp"], "outfile": ["infp", "outFile", "newname", "Outfile", " outfp", "outname", "newfile", " outfilename", " outfolder", "outputfp", "Outfolder", " outFile", "Outname", "infolder", "outputfolder", "outfolder", "outfilename", "outputfile", " outname", "outputfilename", "OutFile", "newFile", "newfolder", "outfp", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "image", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "base", "b", "vin", "is", "nin", "min", "ins", "cin", "thin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "source", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "on", "io", "up", "job", "base", "name", "ou", "outer", "exec", "post", "obj", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "fb", "buf", "len", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "input", "count", "sleep", "ind", "close", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", "modified", " succ", "true", "rolling", "respons", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "4531653", "id2": "7166270", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 0, "substitutes": {"md5": ["mp5", "mp512", "mp7", " md6", "MD5", " md7", "md512", "MD6", "MD512", " md512", "md7", "md6", "MD7", "mp6"], "data": ["text", "source", "message", "method", "buffer", "media", "cache", "output", "str", "script", "DATA", "pad", "this", "bytes", "input", "image", "in", "format", "ata", "a", "name", "base", "database", "code", "sha", "hex", "dat", "body", "address", "api", "string", "alpha", "key", "template", "content"], "md": ["mand", "mm", "mp", "mod", "amd", "wd", "dig", "cmd", "dm", "ds", "mb", "meta", "material", "mg", "m", "nm", "metadata", "ad", "mac", "editor", "docker", "grad", "sm", "code", "pd", "gd", " MD", "od", "di", "dd", "mo", "mt", "hd", "cd", "MD", "mc", "ma", "rod", "mag", "pm", "db", "d", "bd"]}}
{"id1": "19912848", "id2": "6558022", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "8490710", "id2": "14231545", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 0, "substitutes": {"actualizar": ["actualizerada", " actualizear", "actualizerado", " actualizada", " actualizas", "actualizeada", "actualizeras", "actualizas", "actualizado", " actualizado", " actualizeada", "actualisiar", "actualisias", "actualizada", "actualizeado", "actualizear", "actualizeas", "actualizerar", " actualizeado", "actualisiada", "actualisiado", " actualizeas"], "ClassNotFoundException": ["ClassNotPresentES", "ClassNotFoundError", "ClassNotSupportedException", "ClassNotPresentError", "ClassNotSupportedError", "ClassNotFoundES", "ClassNameFoundError", "ClassNameFoundES", "ClassNotSupportedES", "ClassNameFoundException", "ClassNotFindError", "ClassNameSupportedES", "ClassNotPresentException", "ClassNotFindException", "ClassNameSupportedException", "ClassNameSupportedError", "ClassNotFindES"], "Exception": ["F", "Element", "Ex", "Information", "Error", "Engine", "Connection", "Exp", "Adapter", "Exc", "Context", "E", "Interface", "W", "Failure", "IO", "Transaction", "X", "Throw", "Warning", "Except", "Problem", "Fail", "Un", "Null", "Document", "ERROR", "Unknown", "Class", "T", "Event", "Application", "EX", "Abstract", "ceptions", " exception", "Default", "ception", "Request", "Entity", "except"], "conn": ["p", "cs", "util", "client", "oss", "mm", "session", "cb", "c", "cat", "config", "reg", "Connection", "state", "ens", "nt", "ca", "Conn", "ci", "loc", "con", "pg", "pub", "n", "connect", "ann", "col", "ou", "cr", "conf", "ch", "jc", "rc", "connection", "nc", "h", "cc", "cp", "enc", "cm", "coll", "Connect", "oci", "sql", "en", "ok", "sn", "cn", "dh", "mc", "cli", "ob", "ct", "comm", "ctx", "db", "dc"], "ms": ["me", "ls", "ums", "hm", "mis", "cs", "ps", "md", "ts", "mm", "mp", "ml", "mod", "ys", "keys", "s", "DS", "mos", "ens", "pse", "mb", "ds", "ans", "sem", "m", "mes", "rs", "vs", "ws", "mx", "oms", "ks", "em", "mas", "os", "qs", "is", "fs", "ims", "bs", "Ms", "gm", "res", "cus", "tm", "ins", "models", "ems", "mi", "bm", "mn", "details", "mo", "mt", "gs", "sql", "ns", "mc", "MS", "es", "ma", "pm", "js", "cms", "ops"], "fechaSystem": ["fechlaSTEM", "febaService", "fechasSys", "fechtaSystem", "fekasSystem", "fechasService", "fichlaSys", "febaSystem", "febasService", "fichlaSystem", "fichaSystem", "fetchaSTEM", "febaSys", "fechasSystem", "fechmaSys", "fechaSys", "fechlaSys", "fekaSystem", "fechmaSystem", "fechasSTEM", "fechasServer", "fechosystem", "fekaSTEM", "fetchasystem", "fechtasystem", "fekasSTEM", "fechtaSys", "fechmaSTEM", "fechaSTEM", "fetchmaSTEM", "fichasystem", "fekaSys", "fechoSTEM", "fechaServer", "fechaService", "febasSys", "fechetaService", "fechlasystem", "fechmaService", "fechasystem", "febasServer", "fichaSys", "febasSystem", "fechoSystem", "fechetaSys", "febaServer", "fichlasystem", "fetchaSystem", "fechetaServer", "fechmaServer", "fechetaSystem", "fechassystem", "fechmasystem", "fetchmaSystem", "fekasSys", "fetchmasystem", "fechlaSystem"], "aaaammdd": ["aaaasmds", "aaaasmd", "aaaamd", "aaaamtz", "aaaymmd", "aaaaammd", "aaaamdd", "aaaammds", "aaaammtz", "aaammsd", "aaaaamtz", "aaammdd", "aaaymmsd", "aaaasmdd", "aaaaammds", "aaaaamd", "aaaaammsd", "aaaamsd", "aaammtz", "aaaymmds", "aaaaammdd", "aaaymmdd", "aaaaamsd", "aaammds", "aaaaammtz", "aaaamds", "aaaammsd", "aaaasmtz", "aaaaamdd", "aaaammd", "aaammd", "aaaaamds"], "fzafsis": ["fzafsi", "fzahs", "fzafs", "fzahsi", "fzAFs", "fzhafs", "fzaphsi", "fzhafsi", "fzhahsi", "fzaphsis", "fzaftics", "fzAFsis", "fzaphs", "fzaphtics", "fzhafsis", "fzhahs", "fzhahsis", "fzAFsi", "fzhahtics", "fzhaftics", "fzAFtics", "fzahtics"], "hhmmss": ["hhMMds", "hhmds", "hhMMms", "HHmms", "hhhmms", "HHMMs", "hhhmmms", "hhmdess", "hhmss", "hhhmmmess", "hhmmmds", "HHmmds", "HHMMds", "hhmmmess", "hhmms", "hhms", "hhmmds", "hhmdss", "HHMMss", "hhhmmess", "hhmdds", "hhhmmds", "hhhmmmss", "hhmmess", "HHMMms", "hhmmmss", "hhMMss", "hhMMs", "hhmls", "hhmmms", "HHmmss", "hhMMess", "hhhmmss", "HHmmms", "hhmlms", "hhmlds", "hhmlss", "hhhmmmds"], "sss": ["rsss", "\u00dfss", "ssls", "ssp", "ssns", "rssp", "\u00dfls", "usss", " ssp", " ssss", " ssses", "ussss", "ussp", "rssls", "ssses", "ussses", "hessss", "rssns", "hessns", "hessls", "ssss", "rssss", "\u00dfs", "\u00dfns", "hesss", "rssses"], "ss": ["account", "ls", "eps", "cs", "su", "hess", "ps", "ts", "str", "hh", "oss", "st", "styles", "s", "less", "tz", "pass", "iss", "\u00df", "ds", "pps", "pg", "rs", "vs", "ws", "ess", "nn", "si", "ses", "fs", "bs", "sl", "ross", "rss", "string", "struct", "ng", "sq", "settings", "ns", "css", "WS", "xx", "ssl", "SS", "ssh", "sf", "sv", "js", "uss", "ass"], "fzahsis": ["fzeajsis", "fzajses", "fzafsi", "fzeafses", "fzahsi", "fzavses", "fzahses", "fzavtics", "fzaftics", "fzeafsis", "fzajtics", "fzajsis", "fzafses", "fzajsi", "fzeajses", "fzavsi", "fzeafsi", "fzeaftics", "fzeajtics", "fzavsis", "fzeajsi", "fzahtics"], "afectados": ["rafctado", "afecanos", "afectionadas", "afectionados", "afemptadas", "afectadas", "afctados", "AFecados", "afescantes", "afemptados", "afectionado", "afescados", "AFecantes", "afecados", "afectionantes", "AFecanos", "afecadas", "AFectantes", "afecantes", "rafctadas", "rafectado", "rafectatos", "afectado", "afctatos", "AFectadas", "afescadas", "AFecadas", "AFectanos", "AFectados", "afctadas", "rafectados", "afectionanos", "afemptado", "rafectadas", "afctado", "afectantes", "afectanos", "rafctados", "afectatos", "afectionatos", "rafctatos", "afescanos", "afemptatos"]}}
{"id1": "2324868", "id2": "14617444", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"actionPerformed": ["actionOccuted", "actionCalled", "actionExecuted", "actionPeralled", "actionExecalled", " actionPeruted", " actionExecuted", "actionExecressed", " actionExecformed", " actionExecressed", "actionCuted", "actionPerressed", " actionExecalled", " actionPeralled", "actionExecformed", "actionOccalled", "actionOccressed", "actionPeruted", " actionPerressed", "actionCformed", "actionOccformed", "actionCressed"], "e": ["x", "me", "se", "c", "f", "event", "de", "exc", "et", "an", "E", "q", "ec", "self", "g", "a", "name", "te", "ee", "ae", "es", "ev", "t", "ctx", "v", "events", "type", "ception"], "delim": ["selam", "delcm", " delimmer", " delcm", "elim", "delam", "selim", "Delem", "selm", " delam", "selem", "flimmer", "delimmer", "Delcm", "flim", "delem", "Delam", "flcm", "flam", "Delimmer", "elem", "Delm", "elam", "Delim", "delm", "elm"], "r": ["p", "kr", "rx", "re", "br", "c", "f", "rr", "w", "rar", "i", "l", "writer", "rs", "ir", "ws", "sr", "ru", "n", "ar", "hr", "adr", "R", "cr", "rl", "res", "rss", "rb", "dr", "rc", "fr", "rw", "pr", "lr", "iter", "rt", "tr", "err", "er", "reader", "rh", "nr"], "line": ["text", "source", "lf", "look", "style", "Line", "re", "lines", "str", "cell", "page", "pass", "link", "one", "word", "l", "inline", "val", "data", "nl", "comment", "job", "name", "log", "col", "pe", "lc", "code", "sel", "rl", "number", "split", "sl", "time", "string", "rule", "header", "LINE", "el", "lin", "cl", "block", "value", "file", "row", "response", "key", "entry", "id", "reader", "end", "le", "feed", "fin", "no"], "url": ["ls", "org", "uri", "client", "path", "Url", "f", "link", "l", "loc", "blog", "web", "nl", "resource", "sr", "www", "base", "log", "server", "host", "URL", "rl", "fl", "sl", "connection", "string", "fr", "ur", "lr", "file", "pull", "ssl", "err", "ob", "jar", "http"], "conn": ["p", "fp", "out", "sync", "cf", "ctrl", "client", "cb", "c", "f", "dc", "Connection", "w", "nt", "l", "socket", "Conn", "loc", "con", "open", "pub", "n", "io", "connect", "ann", "conv", "cr", "ch", "gr", "api", "rc", "cur", "connection", "nc", "lock", "cp", "rn", "enc", "coll", "pr", "cl", "cm", "sql", "cn", "rt", "ssl", "err", "ct", "ctx", "db", "co", "http"], "wr": ["wer", "wy", "kr", "Wr", "rx", "out", "wk", "wd", "rr", "w", "wt", "mr", "vr", "rar", "war", "riter", "writer", "rs", "sr", "Writer", "wa", "wx", "hr", "fw", "cr", "res", "gr", "rss", "dr", "rb", "wh", "fr", "rw", "shr", "wrap", "WR", "pr", "write", "nw", "wm", "rt", "err", "wb", "wave", "wl", "RW", "rh", "nr", "wal", "ew"], "tokens": ["pargen", "Tokoks", "tokenens", "takos", "targens", "Taken", "itokenets", "token", "targelines", "tokenets", "Tokens", "pargens", "takets", "takelines", "tkicks", "takens", "takoks", "targen", "toyen", "tokos", "tokoks", "tokets", "Takicks", "Takens", "torkicks", "Tokicks", "pargets", "itokenos", "toyets", "tokenos", "tokicks", "Token", "tkens", "pokets", "torken", "targets", "toyens", "itokens", "tkoks", "torkens", "tken", "itoken", "takicks", "tOKelines", "tokelines", "tOKen", "tokenen", "poken", "tOKens", "torkoks", "pargelines", "itokenens", "toyos", "itokenen", "taken", "pokelines", "itokets", "Takoks", "itokos", "tOKets", "pokens"], "in": ["init", "ln", "inn", "str", "out", "gin", "pin", "inner", "ina", "i", "input", "inas", "sin", "IN", "data", "ini", "win", "con", "n", "isin", "bin", "arin", "io", "vin", "it", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "kin", "pull", "err", "oin", "reader", "zin", "din", "tin", "ic"]}}
{"id1": "15737836", "id2": "17337238", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["del", "create", "sync", "update", "de", "drop", "process", "close", "release", "where", " update", "Delete", "connect", "execute", "exec", "destroy", " destroy", " Delete", "write", "sql", "replace", "save", " create", "remove", "id", "get", "select", "clear"], "site": ["source", "course", "remote", "result", "cache", "set", "sync", "se", "license", "session", "sites", "config", "environment", "ite", "model", "page", "domain", "isite", "note", "conn", "project", "line", "image", "item", " Site", "blog", "data", "install", "module", "object", "location", "node", "class", "si", "base", "name", "database", "edge", "null", "server", "sit", "theme", "db", "target", "profile", "plugin", "sql", "sample", "space", "Site", "unit", "type", "zone", "section", "xml", "network", "status"], "dbo": ["rdBo", " dBo", "rdbc", "drbc", "Dbo", "jBO", "dBO", "pba", "dBo", "pBo", "rdbo", "idebo", " dbi", "pbo", "idebl", "gBO", "pBO", "idbo", " dbos", "Dho", "fBo", "jba", "fbo", "ideho", " dBO", "idho", "gBo", "gbo", "gbos", "jbo", "ideBo", "rdbi", "drbo", " dbc", "DBO", "dbl", "Dba", "drBo", "dbos", "idBo", "jBo", "idbl", "fBO", " dba", "Dbl", "dba", "Dbos", "dho", "drbi", "fba", "dbi", "DBo", "dbc"], "connection": ["relation", "management", "result", "position", "cache", "table", "client", "connected", "session", "translation", "c", "union", "config", "instance", "environment", "Connection", "use", "component", "driver", "manager", "conn", "image", "ci", "condition", "loc", "con", "resource", "builder", "node", "communication", "statement", "directory", "io", "connect", "document", "database", "bc", "subject", "character", "graph", "log", "server", "pool", "function", "query", "index", "container", "machine", "channel", "lock", "handler", "engine", "sql", "reference", "creator", "collection", "ongo", "response", "unit", "ctx", "ion", "section", "db", "library", "context", "application"], "preparedStatement": ["prehedStatement", "prepperDocument", "PreparedParent", "prearedDatabase", "preparableStatement", "PrearedStatement", "prearedHeader", "prearedStat", "eculatedStatement", "psefixedStatement", "preciseStatement", "preppedStatement", "eparedTransaction", "caparedStatement", "preculatedTransaction", "preamedStatement", "previousConnection", "preutedQuery", "previousTransaction", "preachedStatement", "preciseParent", "PrearedStat", "psefixedComment", "previousComment", "proparableStatement", "proparableStat", "calyingStatement", "preplacedStat", "preparedInstance", "PrearedString", "prearedScope", "PreparedTransaction", "PreparedComment", "eparedstatement", "prepperTransaction", "eculatedstatement", "preparedScope", "pseparedComment", "prequalifiedStatement", "partvisedStatement", "prequalifiedStat", "preutedOperation", "preachedString", "proparedStatement", "preformedTransaction", "preachedDatabase", "prefixedStatement", "preferredQuery", "partvisedComment", "preparedDatabase", "preamedParent", "preplacedComment", "preparedService", "preparedConnection", "preppedQuery", "preutedStatement", "previsedStatement", "prehedComment", "preamedString", "preferredStatement", "preciseString", "partparedStatement", "prelyingStatement", "calyingTransaction", "preparedParent", "PrearedComment", "PreppedStatement", "eparedStatement", "previousDocument", "PrearedService", "preculatedStatement", "PreparedService", "calyingComment", "preformedService", "PreppedConnection", "PreppedTransaction", "preparedStat", "prehedScope", "PreppedDocument", "PreparedConnection", "PreparedHeader", "caparedTransaction", "preformedString", "prehedQuery", "prefixedOperation", "prearedComment", "PreparedOperation", "preamedStat", "PreparedString", "prequalifiedInstance", "calyingstatement", "prearedQuery", "proparableInstance", "proparablestatement", "eparedConfiguration", "psefixedQuery", "pseparedStatement", "preparedComment", "preformedConfiguration", "preparedstatement", "PreparedStatement", "preparedHeader", "preparedOperation", "partvisedQuery", "preculatedConfiguration", "prepperConnection", "preutedHeader", "preciseStat", "preformedstatement", "PreparedStat", "preplacedStatement", "caparedstatement", "PrearedParent", "proparedStat", "preformedDatabase", "preparedQuery", "preculatedstatement", "previsedComment", "prearedInstance", "preppedString", "partparedQuery", "eculatedConfiguration", "preppedConnection", "proparedstatement", "preparableStat", "preppedTransaction", "preplacedQuery", "preppedComment", "PreparedQuery", "PrearedDatabase", "previousstatement", "PrearedHeader", "PrearedOperation", "prearedService", "prefixedHeader", "pseparedQuery", "pseparedScope", "prepperStatement", "prearedTransaction", "prearedstatement", "prearedString", "caparedComment", "preppedDocument", "partparedComment", "prequalifiedstatement", "eculatedTransaction", "proparedInstance", "preferredComment", "PrearedQuery", "prefixedComment", "partparedStat", "PreparedDocument", "prelyingComment", "prefixedQuery", "PreparedDatabase", "prearedOperation", "preformedStatement", "prearedConfiguration", "psefixedScope", "previsedQuery", "preachedService", "prelyingTransaction", "preparedTransaction", "prearedParent", "preparableInstance", "previsedStat", "preparedString", "preparedConfiguration", "previousStatement", "prelyingstatement", "prearedStatement", "partvisedStat", "preparedDocument", "preferredString", "prefixedScope", "preparablestatement"], "resultSet": ["responseList", "responseLine", "resultsLine", " resultSize", "ResultSize", "ResultSource", "responseSet", " resultList", "resultGet", "rowSet", "resultSize", "ResultLine", "ResultGet", "ResultSet", "responseSource", " resultGet", "resultList", "rowSize", "resultSource", "resultsList", "resultsSource", "ResultList", " resultSource", "resultsSet", "rowSource", "resultLine", "rowGet", " resultLine"], "chkSql": ["chksSql", "chkRsq", "chkSQL", "chkSsql", "chkPresq", "chkOssl", "chkPssl", "chKSq", "chkPssql", "chkPresQL", "chkOsq", "chksAsql", "chksAssql", "chksSq", "chKRssl", "chkAssql", "chkPresql", "chksAsq", "chkPsql", "chkOsQL", "chKSsl", "chKRsql", "chkOsql", "chksAsQL", "chksSsql", "chkPressql", "chKRsq", "chkRsql", "chksSQL", "chKSsql", "chkRssql", "chkSsl", "chkRssl", "chkSq", "chKRssql", "chkAsq", "chkAsQL", "chkOssql", "chkAsql", "chkPsq", "chKSql"], "selfDefinePath": ["selfDefinedKey", "selfDefinepath", "selfDefiningpath", "selfDefinedPath", "selfDefenPath", "selfDefineName", "selfDeclineKey", "selfDefiningPath", "selfDefineKey", "selfDefineUrl", "selfDefinesUrl", "selfDeclinedPath", "selfDefenLocation", "selfDefiningKey", "selfDefinesLocation", "selfDeclinedpath", "selfDefinedUrl", "selfDefineLocation", "selfDeclinepath", "selfDefenName", "selfDefinedLocation", "selfDefiningUrl", "selfDefinesKey", "selfDeclinedKey", "selfDefinespath", "selfDeclineUrl", "selfDeclinedUrl", "selfDefinedpath", "selfDefinesPath", "selfDefinedName", "selfDeclinePath", "selfDefinesName", "selfDefenpath"], "sqlStr": ["sqlBr", "querystr", "sqlText", "queryDec", "sqlWr", "SQLString", "SQLStr", " sqlDec", "queryStr", " sqlString", "qlString", "SQLWr", "SQLDec", "sqlDec", "SQLBr", "sqlstr", " sqlstr", " sqlWr", "SQLText", "sqlString", "queryText", "qlStr", "qlWr", " sqlText", "SQLstr", "qlBr", " sqlBr"]}}
{"id1": "1180878", "id2": "12172485", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchJSONData", "frieveURLData", "fetchUrldata", "frieveURLDATA", "frieveURLdata", "fetchUrlData", "fetchJSONdata", "fetchHTTPData", "fetchURLDATA", "frieveUrlDATA", "fetchHTTPdata", "fetchHTTPDATA", "fetchUrlDATA", "fetchURLdata", "fetchJSONDATA", "frieveUrldata", "frieveUrlData"], "url": ["ls", "source", "text", "filename", "gl", "uri", "path", "username", "Url", "download", "f", "page", "view", "l", "src", "image", "loc", "data", "resource", "location", "www", "base", "name", "server", "host", "URL", "fl", "address", "sl", "api", "string", "connection", "ur", "el", "html", "file", "ssl", "href", "feed", "user", "xml", "http"], "proxyHost": ["ProxyHost", "remoteHead", "proxyHead", "ProxyPath", "serverHost", "remoteHost", "serverServer", "proxyPath", "serverAddress", "remoteDomain", "baseHead", "ProxyHead", "proxyServer", "Proxyhost", "proxyDomain", "cacheAddress", "baseHost", " proxyAddress", " proxyPath", "proxyhost", "remoteAddress", "serverPath", "proxyAddress", "baseDomain", "cacheHost", "ProxyPort", "cachePort", "baseAddress", " proxyServer", " proxyhost", "ProxyServer", "cachehost", "ProxyDomain", "ProxyAddress"], "proxyPort": ["ProxyHost", " proxyport", "httpHost", "cacheport", "httpAddress", "Proxyport", "proxyServer", "cacheAddress", "httpServer", " proxyAddress", "proxyAddress", "cacheHost", "ProxyPort", "cachePort", "httpPort", " proxyServer", "ProxyServer", "proxyport", "ProxyAddress"], "con": ["x", "remote", "cache", "uc", "out", "ai", "ca", "ci", "close", "act", "Con", "conf", "cur", "cc", "cp", "fc", "un", "run", "can", "go", "http", "pre", "rec", "sync", "ctrl", "pin", "ocon", "ver", "com", "cone", "conn", "win", "pub", "n", "don", "rc", "mc", "cons", "ls", "pen", "fun", "cf", "socket", "cas", "bc", "pc", "gen", "cr", "sub", "fl", "cm", "en", "syn", "login", "inc", "fan", "xc", "re", "ac", "c", "f", "per", "func", "an", "open", "ec", "on", "connect", "conv", "change", "fac", "exec", "ran", "ch", "min", "canon", "connection", "fa", "cl", "cn", "part", "CON", "common", "co"], "is": ["p", "mis", "as", "ris", "cs", "ps", "im", "IS", "out", "oss", "us", "isa", "was", "ai", "info", "s", "its", "state", "ori", "il", "isu", "iss", "are", "i", "ie", "Is", "ri", "conn", "serv", "ci", "or", "iso", "in", "ib", "lis", "does", "vs", "ws", "ir", "act", "isin", "ar", "si", "os", "cos", "it", "isc", "fs", "bs", "isl", "api", "isi", "sp", "ais", "ios", "ics", "es", "abs", "iris", "id", "bis", "get", "has", "js", "cms", "can", "ops"], "u": ["p", "uv", "su", "fu", "uri", "uc", "client", "us", "c", "f", "i", "l", "conn", "m", "q", "tu", "ru", "ut", "yu", "iu", "io", "up", "ou", "os", "b", "ui", "api", "nu", "h", "uci", "ur", "ul", "lu", "un", "cu", "file", "hu", "U", "o", "user", "v", "ue", "http"], "proxy": ["p", "x", "create", "remote", "copy", "cache", "uri", "phone", "port", "client", "pin", "c", "config", "f", "plus", "timeout", "l", "socket", "pse", "web", "prot", " Proxy", "resource", "cop", "force", "ip", "pa", "shadow", "bean", "clone", "pc", "pe", "server", "host", "pool", "zip", "fe", "address", "api", "xy", "connection", "XY", "wrapper", "lib", "roxy", "ssl", "Proxy", "type", " proxies", "http"], "baos": ["aOS", "BAo", "abros", "BAOS", "baOs", "boas", "abos", "caos", "BAis", "boOS", "pao", "alos", "BAOs", "baas", "calos", "haos", "BaOs", "baOS", "Baros", "balos", "paOS", "bolos", "Baos", "haOS", "caOS", "BAros", "caas", "baros", "bais", "hao", "abOs", "hais", "aos", "boos", "Bais", "pais", "abis", "bao", "BAos", "paos", "aas"]}}
{"id1": "13852596", "id2": "5543349", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "label": 0, "substitutes": {"execute": ["call", "create", "copy", "parse", "ute", "invoke", "load", "all", "process", "install", "evaluate", "server", "code", "exec", "transfer", "report", " invoke", " perform", "Exec", "submit", "test", "register", "apply", "start", "handle", "run"], "resources": ["relations", "workers", "types", "rules", "chains", "apps", "locks", "writers", "groups", "issues", "services", "projects", "strings", "resource", "cells", "flows", "archives", "works", "rings", "objects", "series", "thumbnails", "params", "files", "stores", "reports", "features", "models", "pages", "scripts", "plugins", "users", "rates", "results", "Resources", "items", "maps", "classes", "ions", "events", "ids", "stars", "images", "roots"], "i": ["p", "ani", "uri", "ai", "f", "gi", "ii", "info", "ori", "s", "e", "vi", "ie", "l", "I", "k", "wei", "ci", "abi", "ini", "we", "ami", "ir", "multi", "ip", "iu", "bi", "io", "si", "ti", "u", "is", "ui", "pi", "oi", "isi", "j", "li", "iri", "h", "hi", "di", "qi", "eni", "xi", "cli", "mu", "o", "id", "v", "esi", "ri", "ic", "phi"], "classFile": ["classFILE", "ruleLine", "staticfile", "classEntry", "CLASSFile", "connectionFile", "sessionFILE", "ClassGlobal", "customEntry", "sessionFile", "classClass", "Classfile", "filefile", "lassFiles", " classFILE", " classPage", "baseFile", "lassClass", "lassGlobal", "fileFiles", "finalFILE", "serviceLine", "CLASSEntry", "classGlobal", "staticFILE", "packEntry", "fileLoader", "CLASSFILE", "connectionfile", "ClassFactory", "ClassPage", "ClassImage", "sessionfile", " classEntry", "finalfile", "CLASSLoader", " classLoader", "ClassFiles", "baseUrl", "classLoader", "ClassClass", "customFILE", "classfile", "ClassFilename", "servicefile", "staticLine", "classesPath", "objectFiles", "ClassEntry", "objectfile", " classFiles", "classFactory", " classLine", "finalUrl", "ClassDir", " classGlobal", "classImage", "fileImage", "packFile", "classFiles", "ruleFile", "classPage", "classUrl", "ClassStream", "classesFile", "packFILE", "fileFile", " classFactory", " classStream", "classesFiles", "finalFile", "classStream", "CLASSLine", "classesfile", "classDirectory", "classPath", "classDir", " classFilename", "sessionEntry", " classClass", "CLASSDirectory", "connectionFiles", "baseFILE", "ruleFiles", "customFiles", " classDir", "ruleFilename", "CLASSfile", "ClassFile", "packfile", "serviceFile", "customFile", "classFilename", "CLASSImage", "ClassPath", "ClassLine", "fileDirectory", "basefile", "ClassDirectory", "fileLine", "staticFile", "sessionFactory", "CLASSUrl", "CLASSPage", "CLASSFiles", "objectDir", "classLine", "lassFile", "connectionStream", "objectFile", "sessionFiles", " classPath", " classfile", "serviceFILE", "ClassFILE"], "inputStream": ["InputFile", "initSteam", "InputStreamer", "uploadstream", "binaryFile", "importSteam", "inputContext", "outputStreamer", " inputstream", "rawFile", "inputFile", "importStream", "childstream", "inputSw", "childContext", "activeSteam", "outputContext", "binaryStream", "activeStream", "outputReader", "childStream", "uploadStream", "Inputstream", "rawStream", "activeStreamer", "rawSteam", "initStreamer", "inputReader", "inputstream", "InputStream", "outputSw", "InputSw", "importStreamer", "uploadSw", " inputFile", "InputSteam", "binaryStreamer", "inputStreamer", " inputStreamer", " inputSteam", "outputstream", "inputSteam", "rawStreamer", "childReader", "outputFile", "uploadFile", "importstream", "activestream", " inputContext", "initStream", "outputSteam", "initstream", " inputReader", "binarySteam"], "reader": ["source", "arser", "rx", "buffer", "copy", "writers", "re", "client", "reading", "sync", "inner", "author", "system", "rr", "seed", "driver", "ler", "per", "rar", "input", "owner", "manager", "war", "draft", "shared", "or", "read", "riter", "loader", "ner", "oder", "resource", "builder", "director", "ger", "Writer", "io", "editor", "reflect", "rer", "server", "book", "dr", "rc", "worker", "handler", "stream", "ee", "layer", "wrapper", "parser", "Reader", "iter", "request", "row", "key", "er", "entry", "keeper", "right", "ri", "report", "context", "http"], "oldSize": ["OldName", "oldName", "OldSc", " oldSc", "oldLength", "prevSize", "prevLength", "prevSc", " oldName", "prevName", "OldSize", " oldLength", "OldLength", "oldSc"], "writer": ["wer", "buffer", "writers", "token", "widget", "wire", "inner", "author", "written", "w", "driver", "ler", "writing", "word", "e", "war", "manager", "draft", "read", "riter", "data", "ner", "loader", "service", "resource", "builder", "format", "director", "object", "Writer", "oder", "walker", "editor", "io", "document", "player", "writ", "wr", "child", "index", "worker", "string", "rw", "handler", "element", "ee", "write", "wrapper", "winner", "parser", "iter", "creator", "Reader", "maker", "row", "r", "er", "her", "engine", "report", "dc"], "b": ["p", "ab", "buffer", "bar", "br", "abc", "c", "f", "bb", "fb", "ba", "w", "e", "pb", "l", "k", "B", "m", "object", "binary", "lb", "be", "g", "a", "base", "u", "null", "rb", "db", "h", "eb", "emb", "r", "ob", "boot", "bin", "orb", "d", "bd"], "outputStream": [" outputView", "OutputStream", "outstream", "protectedSteam", "OutputStreamer", "OutputSteam", "Outputstream", "OutputView", "outputStreamer", " outputSteam", "inputstream", "protectedStream", "protectedStreamer", "protectedstream", "dataStream", "dataStreamer", "outputContainer", " outputStreamer", "outStreamer", "inputStreamer", "inputView", "outputstream", "outSteam", "inputSteam", " outputContainer", "dataSteam", "outStream", " outputstream", "outputView", "inputContainer", "outputSteam", "dataContainer"], "injectedClasses": ["injectedWrites", "injectedClassies", "injectionClasses", "injectedClassites", "injectedclassies", "injectionclassites", "injectedWrits", "injectionClassies", "injectedProjectes", "injectionclasss", "injectedclassites", "injectedclasses", "injectionclassies", "injectedWritites", "injectionClassites", "injectedProjectites", "injectionclasses", "injectedProjecties", "injectedWrities", "injectedProjects", "injectionClasss", "injectedclasss", "injectedClasss"], "newSize": ["NewStorage", "finalSize", "NewSize", " newLength", "newStorage", "newFontSize", "finalStorage", " newFontSize", "finalFontSize", "finalLength", " newStorage", "newLength", "NewFontSize", "NewLength"]}}
{"id1": "442381", "id2": "7945594", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": [" doVersioncheck", "doReleaseWork", "doReleasecheck", "doVersionTest", " doReleaseTest", "doReleaseCheck", " doReleaseCheck", "doversionTest", "doVERSIONTest", " doBuildcheck", "doReleaseTest", "doVersioncheck", " doBuildTest", " doVersionWork", "doversioncheck", "doVERSIONCheck", "doBuildWork", " doReleasecheck", "doBuildCheck", "doVersionWork", "doVERSIONcheck", "doBuildTest", " doBuildWork", "doversionCheck", " doVersionTest", " doBuildCheck", "doVERSIONWork", "doBuildcheck"], "view": ["form", "edit", "style", "app", "buffer", "cache", "widget", "port", "out", "client", "session", "cell", "update", "config", "this", "model", "View", "page", "event", "show", "e", "use", "gui", "input", "l", "image", "screen", "box", "q", "VIEW", "object", "comment", "self", "accept", "window", "display", "server", "change", "sel", "ui", "body", "see", "vis", "div", "lock", "views", "gu", "el", "full", "block", "html", "request", "row", "layout", "reader", "v", "can", "http"], "url": ["source", "buffer", "uri", "browser", "client", "path", "Url", "f", "bb", "input", "l", "socket", "image", "build", "blog", "loader", "web", "service", "resource", "open", "hub", "base", "log", "bel", "server", "host", "URL", "zip", "sl", "address", "string", "connection", "channel", "stream", "ll", "file", "lib", "ssl", "ob", "user", "http"], "in": ["source", "as", "init", "buffer", "gin", "inn", "out", "inner", "ac", "s", "i", "input", "socket", "sin", "IN", "data", "ini", "win", "con", "resource", "binary", "n", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "rin", "file", "login", "reader", "bis", "din"], "bin": ["init", "ln", "buffer", "inn", "gin", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "inline", "IN", "abi", "data", "loader", "win", "record", "con", "binary", "bot", "bi", "log", "b", "bn", "fin", "nb", "body", "lock", "cin", "lin", "spin", "ruby", "file", "kin", "lib", "part", "oin", "reader", "din", "run"], "line": ["text", "source", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "cell", "day", "load", "lo", "home", "model", "page", "pass", "link", "e", "i", "word", "l", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "valid", "base", "name", "log", "b", "lc", "job", "pe", "band", "code", "ge", "split", "letter", "string", "rule", "LINE", "el", "lin", "cl", "layer", "ine", "block", "file", "part", "row", "key", "non", "entry", "end", "le", "unit", "site", "id", "no"], "develBuild": ["deployBuild", "develBuilder", "dewardbuild", "deployBuilt", "DEvelbuild", "dewardBuilder", "desvenRun", "DEvelBuilt", "desvenBuilder", "deviousBuild", "desvelbuild", "desvelBuilder", "deVELRun", "desvelRun", "deVELBuilder", "devenBuild", "develbuild", "desvelBuild", "deVELbuild", "develRun", "desvenRelease", "DEvelBuild", "deployBuilder", "devenBuilder", "develRelease", "desvelBuilt", "deelRelease", "DEVELBuilt", "deployRun", "dellBuild", "dewardBuild", "dewardBuilt", "devenbuild", "DEVELBuilder", "desvenbuild", "dellRun", "DEVELBuild", "DEvelBuilder", "deelBuilder", "dellBuilder", "desvenBuild", "DEVELbuild", "develBuilt", "desvenBuilt", "deviousbuild", "devenBuilt", "deelBuild", "deVELBuild", "devenRun", "deelRun", "dellRelease", "deviousBuilt", "deVELBuilt", "desvelRelease", "devenRelease", "deploybuild"], "stableBuild": ["basebuild", "latestBuilder", "stablebuild", "compatibleBuild", "latestbuild", "prettyBuilder", "stableVersion", "validBuilder", "securebuild", "prettybuild", "latestBuild", "compatibleBuilder", "baseBuild", "secureBuild", "compatiblebuild", "secureBuilder", "stableBuilder", "validBuild", " stablebuild", " stableVersion", "staticbuild", "validbuild", " stableBuilder", "baseVersion", "prettyVersion", "prettyBuild", "staticBuild", "baseBuilder", "staticBuilder"]}}
{"id1": "4056444", "id2": "720361", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"hashPassword": ["updateSecret", "updateWord", " hashpassword", "hashWord", "printPassword", " hashWord", "updatepassword", "hashSecret", "hashpassword", " hashSecret", "printWord", "updatePassword", "printpassword", "printSecret"], "password": ["p", "text", "secret", " passwords", "message", "account", "create", "words", "cache", "token", "out", "path", "username", "wd", "param", "pass", "phrase", "word", "input", "padding", "data", "auth", "PASS", "email", "database", "name", "sword", "null", "SHA", "security", "code", "pool", "random", "address", "sha", "string", "crypt", "prefix", "confirmed", "Password", "attribute", "login", "user", " Password"], "md": ["mand", "hm", "mm", "mp", "mod", "amd", "f", "wd", "dig", "cmd", "dm", "mb", "mg", "m", "metadata", "mad", "ad", "mac", "bf", "grad", "rm", "sm", "nd", "sha", "pd", " MD", "od", "di", "dd", "mo", "mt", "hd", "sum", "am", "MD", "dh", "mc", "ma", "rod", "mag", "pm", "d", "bd"], "hash": ["dot", "match", "secret", "style", "hed", "ho", "cache", "length", "check", "username", "ash", "dig", "pass", "dump", "image", "build", "kh", "data", "format", "mac", "shadow", "url", "log", "array", "search", "Hash", "SHA", "code", "number", "sha", "hex", "address", "body", "h", "header", "string", "sum", "sh", "full", "block", "ha", "html", "value", "version", "file", "key", " hashing", "her", "id", "user", "rh", "db"]}}
{"id1": "841724", "id2": "4750967", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "7087108", "id2": "13783549", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["didGET", "doDownload", "didPut", "didGet", "processGet", " doPut", "processDownload", "processGET", "doPut", "doGET", "processPut", "didDownload", " doDownload", " doGET"], "request": ["message", "method", "create", "result", "buffer", "forward", "uri", "json", "client", "current", "instance", "config", "info", "this", "model", "event", "view", "http", "use", "input", "project", "complete", "condition", "req", "data", "web", "object", "resource", "builder", "QUEST", "self", "error", "url", "subject", "name", "server", "host", "query", "child", "connection", "external", "string", "version", "parent", "route", "reader", "user", "type", "xml", "target", "Request", "report", "context", "application"], "response": ["message", "method", "remote", "result", "cache", "output", "json", "out", "client", "model", "http", "view", "page", "image", "application", "resp", "writer", "example", "service", "object", "resource", "document", "server", "Response", "body", "connection", "respond", "reference", "version", "collection", "wave", "results", "site", "report", "status", "content", "reply"], "path": ["p", "text", "message", "method", "filename", "cache", "uri", "output", "out", "Path", "config", "point", "info", "PATH", "ath", "image", "data", "folder", "object", "location", "format", "resource", "directory", "url", "base", "name", "index", "string", "filter", "value", "route", "key", "dir", "id", "pattern", "content", "http"], "file": ["work", "source", "local", "filename", "File", "fp", "uri", "out", "f", "info", "use", "l", "to", "socket", "image", "data", "object", "resource", "folder", "FILE", "directory", "up", "class", "url", "base", "name", "log", "b", "pe", "it", "files", "fe", "function", "child", "zip", "h", "connection", "rule", "lock", "handler", "full", "lib", "part", "route", "feed", "dir", "le", "http"], "in": ["source", "as", "init", "copy", "gin", "inn", "out", "pin", "inner", "c", "ac", "f", "ax", "s", "i", "input", "serv", "socket", "IN", "data", "ini", "con", "resource", "win", "binary", "isin", "bin", "din", "b", "it", "is", "nin", "ins", "cin", "thin", "stream", "lin", "In", "rin", "kin", "r", "login", "id", "reader", "inc"]}}
{"id1": "20623709", "id2": "804637", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"split": ["match", "cmp", "init", "copy", "set", "sync", "parse", "update", "archive", "build", "process", "format", "open", "share", "add", "execute", "exec", "transfer", "append", "sort", "part", "diff", "join", "start", "delete", "run", "Split"], "targetDirectory": ["destDirectory", "currentDir", "basePath", " targetFolder", "currentDirectory", "outputDir", "currentPath", "currentRoot", "baseDatabase", " targetRoot", "TargetFolder", "destDir", "targetRoot", "targetDatabase", "outputDirectory", "TargetRoot", "baseDir", "targetDir", "destFile", "masterDatabase", "masterPath", "outputFolder", "targetFile", "TargetFile", "TargetDir", "masterDir", "targetFolder", "baseFile", "baseDirectory", "masterDirectory", "targetPath", "outputFile", " targetDir", "TargetDirectory", " targetFile", "baseFolder", "TargetPath", "currentFolder", "TargetDatabase", "destFolder", " targetPath"], "prefix": ["pre", "sequence", "filename", "cache", "uri", "fp", "path", "username", "first", "FIX", "Pref", "config", "ix", "domain", "timeout", "txt", "root", "padding", "fixed", "folder", "prot", "format", "resource", "fix", "directory", "base", "name", "number", "append", "index", "string", "patch", " suffix", "queue", "resolution", "temp", "template", "unit", "type", "pattern", "offset"], "maxUnitBases": ["maxUnitPlails", "maxUnitBues", "maxUnitAliaches", "maxUnitQueues", "maxunitAliases", "maxunitBues", "maxunitAliase", "maxunitBaches", "maxUnitAliues", "maxunitBails", "maxUnitAliails", "maxUnitChasing", "maxUnitChues", "maxunitAliails", "maxUnitBails", "maxUnitPlases", "maxUnitEaches", "maxUnitChases", "maxunitBases", "maxUnitPlase", "maxUnitBasing", "maxunitBase", "maxUnitBase", "maxUnitPlaches", "maxUnitQueases", "maxUnitEails", "maxunitAliasing", "maxUnitAliases", "maxUnitEase", "maxUnitAliasing", "maxunitAliues", "maxUnitAliase", "maxUnitChase", "maxUnitQueasing", "maxUnitEases", "maxUnitQuease", "maxUnitBaches", "maxunitAliaches", "maxunitBasing"], "maxUnitEntries": ["maxUnitAddresses", "maxUnitOrdrations", "maxUnitEntry", "maxUnitOrdines", "maxUnitIntrys", "maxLineEntry", "maxLineOrdines", "maxUnitOrdies", "maxUnitOrdresses", "maxUnitCountrations", "maxUnitEntryures", "maxUnitEntryry", "maxLineOrdries", "maxunitEntrys", "maxunitEntryrys", "maxUnitErries", "maxUnitEntrys", "maxUnitAddry", "maxUnitAddures", "maxUnitEntryrys", "maxunitEntresses", "maxUnitIntresses", "maxUnitEntines", "maxUnitCountry", "maxUnitAddries", "maxUnitIntries", "maxunitEnties", "maxUnitEntresses", "maxUnitEnties", "maxUnitOrdries", "maxunitEntryies", "maxLineOrdry", "maxUnitErry", "maxUnitOrdry", "maxLineOrdrations", "maxLineEntrations", "maxUnitEntryries", "maxUnitErines", "maxLineEntries", "maxunitEntryries", "maxUnitErrations", "maxUnitEntryresses", "maxunitEntries", "maxUnitEntryies", "maxunitEntryresses", "maxUnitOrdrys", "maxLineEntines", "maxUnitCountines", "maxUnitEntures", "maxUnitInties", "maxUnitEntrations", "maxUnitCountries"], "fis": ["fai", "Fisc", "Fiss", "fiss", "forIs", " fisc", "forisa", " fiss", "foriss", "fris", "Fis", "visa", " fIs", "forris", "fisa", "Fris", "vis", "vai", "forisc", " fai", "foris", " fisa", "fisc", "vIs", "fIs", "forai", " fris"], "fci": ["dco", "fai", "bco", "Fai", "fii", "efcos", "vci", "hci", "bci", " fii", "Fis", "fcos", "Fco", "efai", "efci", "vco", "vai", "doci", " fai", "dii", " foci", "vcos", "hai", "Fci", "bai", "Fii", "Foci", "hco", "hcos", "bis", "efco", "dci", "foci"], "fos": ["infos", "foss", "tis", "fso", " fcos", "ifcos", "foes", "Foss", "infoes", "Foes", "ifios", "Fos", "infoss", "Fis", "infis", "fsos", "fo", "fcos", "ifos", " fo", "toes", "fios", "ifo", "tos", "toss", "fsios", "fscos", " fios"], "fco": ["dco", "fro", " fcos", "filebo", "Fico", "fileico", " fico", "hci", "lro", "lco", "lgo", "fgo", "fbo", "fico", "fileco", " fbo", "fileci", "lcos", "fcos", "Fco", "Fbo", "hgo", " fro", "dcos", "Fci", "lci", "hco", "dro", "hcos", " fgo", "dci"], "buffer": ["source", "message", "result", "copy", "cache", "expression", "position", "bar", "length", "translation", "memory", "pad", "buff", "info", "buf", "texture", "timeout", "view", "input", "uffer", "border", "image", "read", "data", "writer", "loader", "resource", "binary", "comment", "zero", "document", "window", "base", "callback", "bc", "device", "null", "server", "capacity", "transfer", "counter", "Buffer", "header", "channel", "size", "queue", "layer", "scale", "batch", "block", "reference", "iter", "pause", "request", "response", "feed", "entry", "reader", "rate", "flush", "bin", "offset", "context"], "currentBasesCount": ["currentBasingNum", "currentChasecount", "currentChasescount", "currentBasingCounter", "currentBatchesCount", "currentBatchesCounter", "currentBasingCount", "currentChaseCount", "currentBaseNum", "currentChaseNum", "currentBatchesNum", "currentChasesCount", "currentBaseCount", "currentBatchescount", "currentBaseCounter", "currentBasescount", "currentChasesNum", "currentBasecount", "currentBasingcount", "currentChasesCounter", "currentChaseCounter", "currentBasesNum", "currentBasesCounter"], "currentEntriesCount": ["currentAdduresOffset", "currentAddriesLimit", "currentEntursLimit", "currentEntursSize", "currentAdduresSize", "currentAddriesSize", "currentEntriesLimit", "currentAddriesCount", "currentEntriesSize", "currentEntursOffset", "currentEnturesCount", "currentAddriesOffset", "currentEntriesOffset", "currentEntrasSize", "currentEntrasLimit", "currentEntursCount", "currentEnturesSize", "currentEntrasCount", "currentAdduresLimit", "currentEnturesLimit", "currentEntrasOffset", "currentEnturesOffset", "currentAdduresCount"], "targetCount": ["targetSum", "patternCount", "TargetSize", "argetcount", "patternSum", "argetSize", "targetSize", "TargetCount", "argetSum", "patterncount", "TargetSum", "patternSize", "targetcount", "argetCount", "Targetcount"], "fastaChannel": [" fastAChannel", " fastAColumn", "fastAContainer", "fastAConnection", " fastAContainer", "fastaqChannel", "fastasContainer", "fastasContext", "fastaContext", "fastAColumn", "fastasChannel", " fastaConnection", "fastanContext", " fastaContainer", "fastaqConnection", "fastaqBuffer", " fastaContext", " fastAContext", "fastaConnection", "fastAContext", "fastABuffer", "fastasConnection", "fastanContainer", "fastaColumn", "fastanChannel", " fastABuffer", "fastanBuffer", " fastaColumn", "fastAChannel", " fastAConnection", "fastasBuffer", "fastasColumn", "fastaContainer", "fastaqColumn"], "totalSeqCount": ["totalSeQcount", "totalQueqCounter", "totalSeqNum", "totalSeQNum", "totalSeqsCounter", "totalSeqscount", "totalQueqNum", "totalSeuxCounter", "totalSeuxCount", "totalSeqcount", "totalQueQCount", "totalSeQCounter", "totalQueQNum", "totalSeqsCount", "totalSeQCount", "totalSeqsNum", "totalQueqCount", "totalSeuxNum", "totalQueQCounter", "totalQueqcount", "totalQueQcount", "totalSeuxcount", "totalSeqCounter"], "totalResiduesCount": ["totalResidurescount", "totalResiduesSize", "totalResiduingSize", "totalResiduesNum", "totalResqueurescount", "totalResiduingcount", "totalResiduescount", "totalResiduingNum", "totalResqueuresCount", "totalResqueuresSize", "totalResqueuesNum", "totalResiduationCount", "totalResqueuescount", "totalResiduresSize", "totalResqueuesCount", "totalResiduingCount", "totalResiduresCount", "totalResiduationNum", "totalResqueuresNum", "totalResiduationSize", "totalResiduresNum", "totalResqueuesSize", "totalResiduationcount"], "prevTime": ["PrevValue", " prevValue", "prevSize", "prevFile", "commitValue", "commitFile", "PrevTime", "PrevFile", " prevSize", "commitSize", "commitTime", "PrevSize", " prevFile", "prevValue"], "fastaFileSize": ["fastaBufferLength", "fastasHeaderAddress", "fastasFileAddress", "fastaLineSize", "fastaBlockLength", "fastaFilesName", "fastasHeaderName", "fastaFileName", "fastaLineAddress", "fastaHeaderAddress", "fastaFilesLength", "fastaBlockCount", "fastasFileLength", "fastasFileName", "fastaFilesAddress", "fastAFileLength", "fastABufferCount", "fastasHeaderSize", "fastABufferAddress", "fastaPageSize", "fastAFileAddress", "fastaBlockSize", "fastABufferSize", "fastAFileCount", "fastaHeaderName", "fastaFilesSize", "fastaFileLength", "fastaBufferCount", "fastaHeaderLength", "fastABufferLength", "fastaFileAddress", "fastasHeaderLength", "fastaLineCount", "fastaFileCount", "fastaBufferSize", "fastaBufferAddress", "fastAFileSize", "fastaBlockAddress", "fastaPageLength", "fastaPageAddress", "fastaLineLength", "fastaPageName", "fastaHeaderSize", "fastasFileSize"], "fastaFileReadOffset": ["fastaFileWriteLength", "fastaBufferWriteLength", "fastaFileRunoffset", "fastaFileStartoffset", "fastaFilereadOff", "fastaBufferReadAmount", "fastaFileWriteoffset", "fastaFileStartOffset", "fastaBufferReadOffset", "fastaFilereadOffset", "fastaFileRunEntry", "fastaFilesWriteOff", "fastaFileLoadOffset", "fastaFileLoadoffset", "fastaFileWriteOffset", "fastaFileRunOff", "fastaDirectoryWriteOffset", "fastaDirectoryReadEntry", "fastaDirectoryReadoffset", "fastaDirectoryWriteEntry", "fastaFileStartOff", "fastaFilereadoffset", "fastaFileReadOff", "fastaFilesWriteOffset", "fastaFilesReadOff", "fastaFileRunOffset", "fastaFilesReadOffset", "fastaFilesWriteoffset", "fastaFilereadLength", "fastaFileWriteOff", "fastaFileLoadLength", "fastaDirectoryReadOffset", "fastaBufferWriteAmount", "fastaFileLoadAmount", "fastaFilesReadoffset", "fastaBufferWriteoffset", "fastaFileWriteAmount", "fastaDirectoryReadOff", "fastaFileLengthOffset", "fastaFilesWriteLength", "fastaFileLengthOff", "fastaFileLengthoffset", "fastaFileWriteEntry", "fastaDirectoryWriteoffset", "fastaBufferReadLength", "fastaFileLengthAmount", "fastaFileReadEntry", "fastaFileReadAmount", "fastaDirectoryWriteOff", "fastaFileLengthLength", "fastaFileStartEntry", "fastaBufferReadoffset", "fastaFilesReadLength", "fastaFileReadoffset", "fastaFileReadLength", "fastaBufferWriteOffset"], "partitionStartOffset": ["partitionStartOrder", "partitionBufferOffset", "partitionsStartOffset", "partitionBufferRange", "partitionsEndOrder", "partitionStartRange", "partitionsEndOff", "partitionsStartOff", "partitionsEndRange", "partitionEndOrder", "partitionStopOffset", "partitionStopRange", "partitionBufferOrder", "partitionStopOff", "partitionStopOrder", "partitionEndRange", "partitionsStartOrder", "partitionEndOff", "partitionsEndOffset", "partitionStartOff", "partitionsStartRange", "partitionBufferOff"], "bufferSize": ["processType", "BufferC", " bufferCount", "BufferSize", "BufferSIZE", "processC", "bufferType", " bufferC", "processSIZE", "queueSize", "processSize", "bufferC", "bufferCount", "BufferCount", "BufferType", " bufferSIZE", "bufferSIZE", " bufferType", "queueCount"], "fastaBuffer": ["FastasStream", "fastacePtr", " fastAChannel", "fastasPtr", " fastasBuffer", "fastAContainer", "FastaBuffer", " fastasContainer", "FastasBuff", "FastasPtr", "fastaaBuff", "fastasContainer", "fastAPtr", "fastaStream", "fastasQueue", "fastaPtr", "fastaBuff", "fastanFile", "fastanStream", "FastasBuffer", "fastaaBuffer", "fastanBuff", "fastasChannel", "fastaaStream", "fastABuff", " fastABuff", "FastasChannel", "fastanQueue", "fastaQueue", " fastaContainer", "FastaChannel", " fastaBuff", " fastAFile", "fastaceChannel", "fastAQueue", " fastaQueue", "fastaaPtr", "fastasBuff", " fastAQueue", "fastABuffer", "FastaPtr", "fastasStream", "fastAFile", "fastanContainer", "fastaceBuff", "fastanChannel", " fastaFile", "FastaBuff", "FastaStream", " fastABuffer", "fastanBuffer", "fastAChannel", "fastasBuffer", "fastaFile", "fastanPtr", " fastasFile", " fastasChannel", "fastaceBuffer", "fastaContainer", "fastasFile"], "fastaReadState": ["fastaFilestate", "fastaFileMode", "fastaReaderType", "fastaReaderState", "fastasReaderType", "fastaReaderstate", "fastaReadingType", "fastasReadMode", "fastasReaderMode", "fastaFileState", "fastaReadingState", "fastasReadstate", "fastaReadType", "fastasReadType", "fastaReadingstate", "fastasReadState", "fastasReaderState", "fastaReaderMode", "fastaReadingMode", "fastasReaderstate", "fastaReadMode", "fastaFileType", "fastaReadstate"], "nBytes": ["nFiles", "obytes", "lenBytes", "pBytes", "oBytes", "oParts", " nParts", "NByte", "NParts", "Nbytes", "lenbytes", "numBytes", "nbytes", "lenFiles", "lenFrames", "NBytes", "numFrames", "numbytes", "pParts", " nFrames", "oFiles", " nbytes", "pbytes", "numFiles", "nFrames", " nFiles", "pByte", "nByte", "nParts", " nByte", "NFiles"]}}
{"id1": "9261777", "id2": "14590676", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"source": ["text", "style", "flat", "result", "copy", "uri", "token", "se", "parse", "path", "session", "empty", "inner", "config", "info", "use", "view", "seed", "options", "input", "ource", "src", "image", "SOURCE", "single", "project", "shared", "sin", "data", "Source", "in", "service", "resource", "proxy", "missing", "strip", "comment", "force", "dest", "original", "url", "base", "name", "null", "spec", "zip", "query", "address", "secure", "sl", "index", "string", "rule", "scope", "size", "prefix", "element", "sample", "sort", "file", "request", "slice", "template", "id", "unit", "site", "parent", "start", "target"], "destination": [" destension", "coordination", "homeination", "homeinated", "destinating", "destinated", "destension", "coordinate", " destinating", "distension", "distinated", "Destinated", "destignment", "coordinator", "dependination", "Desturation", "databaseuration", "destipping", "Destinations", "destinate", "databaseinated", " destinate", " destipping", "dominated", " destinator", "Destinate", " destinated", "homeignment", "desturation", "Destination", "dominations", "distination", "distipping", "destinator", "Destinating", "dependinated", "dependension", "domination", "Destinator", "homeinator", "Destignment", " destignment", "databaseinations", "destinations", "coordinating", "dependipping", "databaseination", "domuration"], "is": ["mis", "as", "init", "ris", "was", "IS", "out", "se", "us", "isa", "oss", "ai", "info", "s", "ii", "ori", "sis", "ens", "are", "iss", "i", "ie", "Is", "serv", "src", "ci", "sin", "or", "iso", "in", "ib", "lis", "close", "ir", "act", "ip", "io", "ar", "cos", "isc", "ui", "zip", "fs", "bs", "api", "isl", "isi", "ins", "ais", "ios", "ics", "eni", "abs", "es", "iris", "obs", "nis", "ob", "id", "osi", "bis", "get", "esi", "ri", "ic", "ois", "ops"], "os": ["ls", "OS", "as", "dos", "ends", "ot", "so", "ss", "out", "oss", "us", "bos", "oise", "oes", "s", "ori", "ens", "mos", "i", "socket", "ds", "pos", "acs", "or", "ose", "sys", "ol", "vs", "oa", "nos", "io", "ros", "ks", "oS", "cos", "los", "ou", "ies", "fs", "bs", "ais", "ios", "aos", "es", "obs", "op", "Os", "o", "ow", "ob", "osi", "boot", "js", "oses", "ops"], "buffer": ["sequence", "position", "result", "copy", "pad", "buff", "bb", "buf", "page", "seed", "bytes", "uffer", "image", "border", "padding", "read", "data", "writer", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "number", "address", "Buffer", "string", "header", "channel", "size", "queue", "layer", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "flush"], "length": ["sequence", "match", "last", "style", "position", "of", "lower", "depth", "shape", "Length", "ring", "load", "point", "len", "level", "l", "count", "line", "data", "left", "duration", "object", "strip", "age", "total", "division", "limit", "url", "character", "width", "code", "power", "number", "split", "address", "key", "index", "string", "quote", "size", "lock", "section", "range", "full", "block", "distance", "weight", "value", "part", "partial", "row", "feed", "slice", "ob", "end", "id", "reader", "type", "get", "start", "offset", "volume"]}}
{"id1": "947406", "id2": "6403868", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "p", "sync", "csv", "paste", "download", "cat", "Cop", "dump", "cop", "clone", "log", "clip", "it", "transfer", " transfer", "zip", "split", "Copy", "cp", "write", " Copy", "replace", "put", "file", "get", "cmp"], "src": ["source", "filename", "bh", "sb", "uri", "config", "s", "use", "txt", "input", "ource", "inst", "sin", "loc", "data", "resource", "rs", "img", "url", "rob", "name", "files", "sel", "sub", "sit", "sl", "sc", "dist", "rc", "rb", "ins", "string", "fn", "cur", "gb", "stream", "sq", "href", "id", "js", "stab"], "dest": ["source", "flat", "result", "prop", "output", "st", "home", "wd", " Dest", "txt", "de", "rest", "des", "const", "folder", "done", "later", "img", "sup", "class", "tmp", "name", "die", "obj", "destroy", "dat", "dist", "target", "comb", "thin", "orig", "test", "desc", "replace", "temp", "wb", "Dest", "dir", "bin", "opt", "d", "delete"], "in": ["work", "source", "as", "init", "inn", "gin", "cf", "pin", "inner", "download", "s", "info", "this", "pass", "i", "input", "trans", "socket", "conn", "IN", "data", "m", "con", "win", "ini", "issue", "isin", "bin", "a", "url", "base", "up", "b", "vin", "it", "is", "nin", "ins", "lock", "cin", "thin", "lin", "In", "inc", "again", "rin", "kin", "lib", "pull", "r", "err", "login", "id", "reader", "diff", "din"], "out": ["x", "source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "at", "our", "this", "timeout", "w", "ex", "one", "socket", "OUT", "conn", "image", "or", "data", "writer", "img", "io", "up", "vert", "bin", "log", "os", "ou", "outer", "ext", "exec", "obj", "pool", "nin", "index", "exp", "plain", "exit", "Out", "write", "aos", "outs", "again", "off", "file", "lib", "part", "err", "o", "id", "user", "inc", "no"], "buf": ["p", "cv", "ref", "ab", "buffer", "bh", "result", "uf", "seq", "uc", "br", "bag", "c", "feat", "f", "pad", "buff", "fb", "len", "bytes", "pos", "count", "ff", "loc", "data", "bp", "box", "bf", "bc", "b", "num", "fd", "nb", "fl", "rc", "rb", "cur", "queue", "raw", "batch", "orig", "block", "off", "cap", "ctx", "v", "bin", "cb", "fab", "bn", "bd"], "n": ["p", "x", "length", "z", "c", "f", "len", "w", "nt", "i", "max", "l", "k", "count", "N", "ind", "m", "ne", "nn", "num", "b", "u", "nb", "nd", "number", "nin", "na", "index", "j", "nc", "size", "rn", "ng", "write", "en", "un", "sn", "ns", "t", "dn", "o", "v", "nr", "d", "no"]}}
{"id1": "19738435", "id2": "13666876", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"parse": ["match", "source", "create", " parser", "set", "se", "arse", "load", "instance", "link", "read", "process", "Parser", "resource", "open", "format", "from", "find", "add", "parser", "replace", "request", "pack", "apply", "get", "start", "run"], "url": ["text", "source", "buffer", "uri", "str", "absolute", " URL", "path", "client", "Url", "config", "page", "link", "e", "input", "l", "src", "conn", "image", "loader", "object", "resource", "location", "proxy", "io", "document", "base", "server", "host", "URL", "address", "api", "string", "channel", "ur", "stream", "element", "file", "request", "ssl", "feed", "r", "entry", "error", "http"], "target": ["source", "result", "output", "current", "path", "config", " Target", "this", "component", "event", "timeout", "root", "pointer", "to", "arget", "project", "resources", "data", "object", "Target", "resource", "context", "format", "document", "class", "host", "address", "container", "reference", "collection", "t", "response", "ctx", "parent", "node", "content"], "parseURL": ["parseResource", "parseType", "parserUrl", "parserType", "readUrl", " parseType", "parserURL", "readType", "readResource", " parseResource", "readURL", "parserResource", "parseUrl", " parseUrl"], "connection": ["text", "source", "relation", "normal", "uri", "client", "out", "connected", "c", "config", "Connection", "timeout", "conn", "or", "writer", "con", "service", "resource", "open", "director", "which", "io", "directory", "connect", "bc", "character", "database", "pool", "function", "body", "container", "channel", "handler", "creator", "response", "ctx", "ion", "section", "db", "context", "application"], "charset": ["charsET", "ChARSect", "choarsET", "chasec", "CharsET", "chipseting", "ChARSET", "Chasetter", "Charset", "charseting", "charsect", "chapterset", "chARSetter", "choarsets", "chipset", "charsets", "choarseting", "choarset", "chansec", "chasetter", "chasET", "chARSect", "Charsect", "chaseting", "chaptersetter", "Chaset", "chARSet", "choipsets", "ChARSet", "chanset", "chipsET", "chaptersET", "Charsec", "chasets", "Chasec", "Charsetter", "chARSec", "choipseting", "chansET", "ChasET", "chansect", "chipsec", "chaset", "chipsets", "charsec", "choipsET", "ChARSec", "choipset", "chARSET", "charsetter", "chipsect", "chaptersec"], "reader": ["x", "source", "reading", "rr", "driver", "per", "i", "ler", "input", "rar", "pointer", "or", "read", "data", "writer", "loader", "in", "object", "resource", "oder", "director", "io", "server", "container", "worker", "channel", "stream", "handler", "parser", "Reader", "iter", "row", "r", "er", "feed", "entry", "keeper", "context"]}}
{"id1": "23273706", "id2": "8216539", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectTreeInfo", "getprojecttreeInfo", "getProjecttreeDATA", "getProjectDocumentData", "getProjectPageDATA", "getprojectTreeData", "getProjectDocumentMeta", "getProjecttreeInfo", "getProjectPageData", "getprojecttreeDATA", "getProjectPageMeta", "getprojecttreeMeta", "getProjectDocumentInfo", "getprojectTreeMeta", "getProjectTreeMeta", "getProjectTreeDATA", "getProjecttreeData", "getProjectPageInfo", "getProjectDocumentDATA", "getProjecttreeMeta", "getprojectTreeInfo", "getprojecttreeData", "getprojectTreeDATA"], "treeData": ["TreeList", "contentInfo", "TreeArray", "TreeData", "treeArray", "monkeyData", "monkeyDec", "reeText", "treeDec", "contentText", " treeInfo", "treeText", "bodyDat", "storyDat", "reeDat", "reeInfo", "treeDat", "monkeyArray", "reeList", " treeDat", "storyData", " treeDec", "storyDec", "storyArray", "contentData", "contentDat", "reeArray", "bodyList", "bodyData", "reeString", " treeArray", "reeData", " treeText", "treeList", " treeString", " treeList", "bodyString", "TreeString", "treeString", "TreeInfo", "monkeyDat", "treeInfo"], "filename": ["figure", "whatever", "uri", "fp", "ppa", "path", "username", "kl", "wav", "title", "ername", "fil", "txt", "sheet", "data", "folder", "location", "metadata", "dll", "journal", "framework", "directory", "FILE", "url", "database", "name", "tmp", "kn", "kj", "fd", "files", "password", "dylib", "SourceFile", "upload", "string", "fn", "prefix", "Filename", "file", "nil", "jpg", "xml"], "urlString": [" urlURL", "URLString", "addressStr", "URLURL", "URLstring", "urlStr", "addressString", "URLStr", "addressURL", "urlUrl", "locationUrl", " urlstring", "urlURL", "locationString", "URLUrl", "urlstring", " urlUrl", "addressstring", "locationStr", "locationstring", " urlStr"], "urldata": ["urlledATA", "URldat", "urlledata", "urlledta", "urlfat", " urLDdata", " urLDta", "urldat", "urLDat", "urleddata", "urledATA", "urllata", "urledta", " urldATA", "urledata", "urLDta", " urLDATA", "URlddata", "urLData", "urldATA", "URlfata", "URlfat", " urldta", " urLData", "urlldata", "urlfATA", "urlfata", "urlfdata", "urllat", "urldta", "URlfATA", "URldata", "urLDATA", "urllATA", "URldATA", "urlleddata", " urlddata", "urlddata", "urLDdata", "URlfdata"], "factory": ["cFactory", " fault", "confFactory", " fFactory", "conflier", "confiller", "liller", "cflier", "fuild", "ciller", "lactory", "fFactory", "ufactory", "luild", "cault", "cfFactory", "pFactory", "ufuild", "cfiller", "flier", " flier", "lictionary", " fictionary", "pault", "ufictionary", "fault", "pactory", "filler", "confactory", " fuild", "ufiller", "piller", "cfactory", "cactory", "fictionary", " filler"], "parser": ["p", "lp", "arser", "util", "uri", "se", "json", "parse", "instance", "s", "driver", "root", "l", "manager", "loader", "writer", "ph", "Parser", "builder", "pdf", "ger", "up", "b", "utils", "monkey", "fruit", "api", "string", "jack", "handler", "plugin", "auto", "t", "er", "r", "reader", "parent", "xml", "raf", "library", "http"], "u": ["p", "uni", "uv", "util", "su", "uri", "uf", "us", "c", "plug", " ur", "eu", "s", "l", "tu", "ru", "yu", "io", "iu", "url", "ou", "b", "ui", "nu", "ur", "ul", "lu", "universal", "cu", "hu", "uu", "U", "o", "d", "http"], "is": ["p", "mis", "as", "ris", "init", "uri", "IS", "isa", "us", "ai", "info", "s", "its", "ori", "isu", "iss", "are", "ie", "Is", "serv", "or", "iso", "gets", "in", "ib", "lis", "ir", "ip", "io", "ar", "it", "fs", "ui", "isl", "pi", "api", "ais", "ios", "es", "abs", "iris", "obs", "ob", "bis", "has", "ri", "ops", "http"], "os": ["OS", "ops", "as", "dos", "ps", "so", "oss", "us", "bos", "s", "oes", "ens", "pos", "or", "iso", "ose", "gets", "sys", "ol", "oa", "opens", "io", "ros", "ms", "cos", "los", "fs", "bs", "fits", "oos", "ios", "aos", "ils", "es", "obs", "Os", "o", "ob", "osi", "bis", "oses", "http"], "iBufSize": ["iBufsize", "iBbufsize", "iBlfLength", "iBbufSize", "iByteufLength", "iBytebufSize", "iLlfLength", "iBytebufLength", "iByteufsize", "iLlfSt", "iBbufLength", "iByteufSize", "iBufLength", "iLufSt", "iLlfSize", "iBuffLen", "iLufSize", "iBbufLen", "iBlfsize", "iBufferSt", "iBufferSize", "iBuffLength", "iLlfsize", "iBlfLen", "iBuffersize", "iBytebufLen", "iBuffSt", "iLufLength", "iBytebufsize", "iBuffsize", "iBufSt", "iBuffSize", "iByteufLen", "iBufLen", "iBlfSt", "iLufsize", "iBufferLength", "iBlfSize"], "inBuf": ["inBluf", " inFbuf", "inbuf", " inFaf", "inDuff", "inBunk", "inFuf", "inFuff", "inDbuf", "outBuffub", "outBuffump", "inBump", "outBump", "inCbuf", "inCunk", " inBuff", "inBlunk", " inBaf", "inCuf", " inBump", "inPluf", "outBuf", "outBuffbuf", "inBuffuf", "inPlump", "inDuf", "inBub", "inDaf", " inBunk", " inCunk", " inCuf", "outBbuf", "inbub", "inBuffump", " inCbuf", "inCuff", " inCump", "inPlunk", "inFaf", "inBbuf", "inbump", "inFbuf", "outBuffuf", "inBuff", "inBuffbuf", "inBlbuf", " inFuff", "inbbuf", "inBlub", "inBuffub", "inBaf", "inCaf", "inBlump", "outBub", "inPlbuf", "inCump", " inFuf", " inBbuf"], "iNumRead": ["pNumberRead", "inumWritten", "qiNumREAD", "iChanBuild", "qiNumread", "pNumberWritten", "iValREAD", "iNumread", "inumread", "iLenRead", "iNumREAD", "iNumberBuild", "pNumberread", "pNumWritten", "iLenWritten", "iFatWritten", "inumWrite", " iFatWritten", "iChanREAD", "qiValread", " iFatRead", "pNumRead", "iNumWritten", "iNumberWrite", "iValRead", "iFatRead", " iNumWrite", "inumRead", "iValBuild", "iNumberread", "qiValREAD", "qiValBuild", " iFatWrite", "pNumread", "iNumberREAD", "iValread", "iNumberWritten", "qiNumBuild", "iChanRead", "qiNumRead", "iFatWrite", "iNumberRead", "iChanread", "pNumWrite", "iNumWrite", "qiValRead", "iLenWrite", " iNumWritten", "pNumberWrite", "iNumBuild"], "f": ["p", "F", "fp", "uf", "c", "s", "e", "l", "ff", "m", "n", "g", "io", "b", "fd", "fs", "fe", "j", "h", "fn", "fr", "fa", "handler", "rf", "full", "fc", "file", "df", "t", "r", "fi", "sf", "o", "feed", "v", "d"], "inputstream": ["Inputsw", " inputsw", "Inputchannel", " inputchannel", "outputchannel", "Inputstream", "contentStream", "InputStream", " inputStream", "inputsystem", "contentsw", "contentstream", "outputStream", "Inputsystem", "inputsw", "outputstream", "inputStream", "contentsystem", " inputsystem", "inputchannel"], "document": ["p", "source", "DOM", "media", "output", "language", "info", "page", "e", "l", "tree", "project", "ocument", "xml", "data", " documents", "m", "record", "object", "context", "director", "n", "directory", "window", "null", "docs", "Document", "Documents", "container", "list", "html", "dom", "office", "file", "collection", "t", "response", " documentation", "parent", "node", "d", "doc", "content"], "nodelist": ["nodedestyle", "nodemark", "nodestate", "nodata", "anodedeme", " nodesels", "nondestate", "nodedestate", "nodedeme", "snodseline", "NODelist", "nonedelist", "nozette", " nodesename", "Nodelist", "nozelist", "nODesh", "nodeeme", "snodselist", "nozename", "nodels", "snodsette", "nODelist", "nodette", "Nodestyle", "nodeestate", "nODeline", "nodedemark", "nodesename", "nODestyle", "anodedata", "anodestate", "snodslist", "nodedelist", "nondeme", " nodename", "nodeme", "snodlist", "nodesh", "nodestyle", "Nodemark", "anodelist", "snodelist", "Nodesh", "nonedette", "nodlist", "nodeline", "NODesh", "nodesels", "nozemark", "NODemark", "nondelist", "nondata", "nodedette", "snodette", "nozels", "nodeelist", " nodeselist", "nODette", "anodeme", "nodseline", "nodedlist", "nodsette", " nodette", " nodels", "nodedeline", "anodedestate", "nozestyle", " nodesette", "nodslist", "nodename", "nodeata", "nodedesh", "anodata", "nodeselist", "nODlist", "nodselist", "nozesh", "nonedels", "nonedename", "NODestyle", "nODemark", "nodedata", "anodedelist", "nodesette", "snodeline"], "num": ["Num", "dim", "uni", "init", "span", "uri", "net", "np", "len", "nom", "lim", "max", "pos", "count", "norm", "loc", "m", "NUM", "con", "total", "multi", "n", "zero", "col", "um", "nb", "nr", "number", "nu", "index", "om", "mon", "div", "comb", "ul", "tri", "sum", "en", "nam", "dom", "umi", "temp", "part", "mu", "unit", "inc", "node", "mult"], "i": ["p", "x", "uri", "c", "ai", "info", "ii", "gi", "ori", "ix", "ie", "d", "l", "I", "ci", "yi", "m", "chi", "in", "ini", "multi", "ip", "iu", "g", "io", "bi", "si", "a", "b", "col", "it", "iv", "ui", "ik", "pi", "oi", "ji", "j", "li", "index", "isi", "hi", "mi", "di", "qi", "eni", "y", "xi", "part", "fi", "cli", "mu", "slice", "id", "o", "v", "start", "ri", "ti", "phi"]}}
{"id1": "804637", "id2": "22536033", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "23246123", "id2": "421042", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createControlarea", " createButtonGroup", "createEditorGroup", " createButtonArea", "createButtonArea", " createDialogPanel", "createMessageArea", " createHelpPanel", "createDialogarea", "createHelpGroup", "createButtonGroup", "createDialogPanel", "createButtonarea", "createHelpArea", " createDialogarea", "createHelparea", "createEditorArea", "createMessagePanel", "createControlArea", " createDialogGroup", "createHelpPanel", " createHelparea", "createDialogGroup", " createButtonarea", "createMessagearea", " createHelpArea", "createEditorarea", "createControlPanel"], "parent": ["p", "message", "current", "port", "client", "c", "instance", "this", "component", "page", "root", " child", "image", "panel", "menu", "parents", "object", "resource", "builder", " sup", "self", "g", "sup", "document", "class", "clip", "null", "host", "child", "container", "connection", "section", "cl", "comp", "wrapper", "parser", "Parent", " scene", "ctx", "context"], "composite": ["compositionited", "comppositive", "compposites", "complexite", "complexites", "compositionite", "compposited", "comppositionitor", "comPOSite", "complexitable", "comppositable", "comppositionited", "comvalitor", "comPOSitable", "comppositor", "Complexite", "composites", "compositionitive", "compositive", "comppositionitable", "compositioniting", "complexitor", "comppositionites", "complexiting", "comvalite", "comosited", "comositable", "compositable", "Complexiting", "comosite", "comosites", "composited", "complexitive", "comvalites", "Complexitable", "Composite", "comppositionitive", "Composites", "compposite", "compositionites", "compositing", "Compositable", "comvalitive", "Complexites", "comPOSited", "compositionitor", "comppositionite", "Compositing", "comPOSiting", "comPOSites", "compositor", "compositionitable"], "content": ["source", "message", "create", "app", "media", "copy", "output", "json", "client", "cell", "load", "config", "activity", "model", "component", "page", "title", "ez", "control", "scroll", "conn", "image", "complete", "loader", "folder", "object", "format", "resource", "comment", "document", "cont", "server", "host", "code", "exec", "child", "address", "container", "header", "connection", "cm", "plugin", "layer", "html", "Content", "version", "file", "feed", "section", "xml", "cms", "report", "context", "application"], "ncol": ["numcolumn", " nrow", "nbcolumn", "pblock", "ncolumn", "pCol", "nblock", "Ncol", " ncolumn", "nCol", "pcolumn", "nrow", "Nblock", " nblock", "nbCol", "numcol", " nCol", "Ncolumn", "NCol", "numCol", "numrow", "nbcol", "pcol", "nbrow"], "layout": ["flow", "group", "edit", "closure", "figure", "flat", "position", "shape", "widget", "translation", "config", "draw", "font", "model", "view", "control", "l", "scroll", "image", "xml", "inline", "build", "design", "data", "follow", "padding", "nl", "board", "location", "Layout", "where", "shadow", "base", "nav", "lc", " layouts", "ui", "zip", "split", "address", "container", " Layout", "list", "alpha", "holder", "lock", "layer", "scale", "lay", "block", "grid", "mount", "feed", "entry", "join", "section", "offset"], "numColumns": ["nbcolumnes", "numCols", "numColumnn", "numColows", "numColn", "numControls", "numcolumnows", "numcolumnn", "nbcolumnows", "numColes", "numControln", "nbcolumnn", "nbColumnes", "nbColumns", "nbcolumns", "numControlows", "nbColumnn", "numControles", "nbColumnows", "numcolumns", "numColumnes", "numcolumnes", "numColumnows"], "browser": ["sim", "cookie", "iframe", "facebook", "remote", "uri", "client", "bar", "session", "flash", "feature", "br", "config", "finder", "ver", "river", "front", "page", "driver", "root", "manager", "image", "Browser", "design", "loader", "agent", "web", "box", "bot", "proxy", "binary", "open", "comment", "ger", "img", "shadow", "editor", "vert", "platform", "roller", "fire", "cart", "window", "io", "graph", "runner", "server", "host", "nav", "book", "theme", "report", "chrome", "webkit", "coll", "plugin", "fox", "test", "html", "lib", "css", "ssl", "feed", "google", "js", "mobile", "jar", "http"], "text": ["source", "message", "form", "output", " Text", "str", "client", "port", "path", "inner", "config", "info", "font", "title", "driver", "txt", "input", "image", "data", "TEXT", "writer", "service", "object", "format", "context", "binary", "comment", "pdf", "ut", "editor", "vert", "name", "it", "ext", "Text", "label", "letter", "term", "string", "connection", "struct", "element", "plugin", "test", "desc", "off", "abs", "feed", "atter", "entry", "unit", "user", "select", "report"], "url": ["source", "ref", "gl", "re", "uri", "path", "Url", "download", "f", "config", "page", "l", "image", "web", "service", "resource", "open", "www", "io", "base", "bel", "server", "host", "URL", "zip", "address", "sl", "api", "string", "connection", "ur", "lr", "file", "pull", "ssl", "feed", "id", "user", "rel", "http"], "in": ["p", "x", "init", "rec", "re", "inn", "gin", "out", "str", "br", "pin", "inner", "c", "f", "s", "w", "pass", "i", "input", "l", "serv", "conn", "image", "xml", "or", "IN", "data", "ic", "ini", "resource", "on", "ar", "arin", "a", "din", "b", "it", "is", "nin", "min", "dr", "rc", "ins", "rb", "fr", "stream", "el", "lin", "In", "inc", "again", "rin", "er", "err", "login", "o", "reader", "bin", "ri", "d"], "r": ["p", "right", "kr", "rx", "ro", "re", "out", "br", "c", "f", "rr", "mr", "rar", "i", "vr", "l", "or", "ner", "m", "rs", "ir", "ru", "sr", "ar", "rob", "b", "hr", "R", "nr", "rl", "cr", "res", "gr", "rss", "rb", "dr", "rc", "h", "fr", "ur", "rw", "pr", "lr", "rf", "rt", "er", "err", "o", "reader", "rh", "ri", "d", "rg", "rel"], "sb": ["lp", "ls", "bh", "buffer", "ab", "xb", "SB", "obb", "bb", "fb", "s", "buf", "bj", "lab", "sg", "pb", "src", "mb", " SB", "bp", "kb", "ib", "nl", "erb", "binary", "bf", "lb", "sr", "storage", "sth", "sa", "si", "bc", "rob", "sm", "b", "usb", "bs", "sp", "rb", "db", "gb", "eb", "bm", "lr", "ruby", "sn", "abs", "bsp", "wb", "ssl", "sf", "ob", "sv", "cb", "abb", "library"], "line": ["source", "message", "lf", "char", "Line", "lines", "str", "se", "cell", "f", "page", "pass", "i", "l", "cle", "inline", "data", "record", "object", "nl", "comment", "ne", "n", "character", "name", "base", "b", "col", "pe", "lc", "code", "ge", "obj", "split", "sl", "letter", "li", "string", "header", "LINE", "el", "lin", "cl", "stroke", "block", "part", "row", "key", "entry", "end", "le", "id"], "e": ["p", "me", "se", "f", "ve", "ite", "ale", "ue", "one", "ie", "de", "d", "i", "exc", "oe", "or", "ele", "E", "ise", "ze", "ce", "ec", "ne", "ke", "be", "pe", "te", "ge", "fe", "ime", "je", "ef", "ee", "ae", "en", "es", "ev", "err", "er", "o", "le", "esi", "error", "ception", "ea"]}}
{"id1": "16621503", "id2": "6682825", "code1": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"loadURLToStrings": ["loadURLToStringings", "loadURL2STRString", "loadURL2Strings", "loadURLAsStrings", "loadURLToSTRINGS", "loadURLTostrINGS", "loadURLToStrINGS", "loadURL2STRINGS", "loadURLAsStringING", "loadURLToSTRings", "loadURLToStrING", "loadURLToStringINGS", "loadURL2STRings", "loadURLAsStrINGS", "loadURL2StrString", "loadURLAsStrING", "loadURLToStringING", "loadURLToStrString", "loadURL2StrINGS", "loadURLTostrString", "loadURLTostrings", "loadURLToStringString", "loadURLTostrING", "loadURLAsStrString", "loadURL2STRING", "loadURLAsStringings", "loadURLAsStringString", "loadURL2StrING", "loadURLToSTRING", "loadURLAsStringINGS", "loadURLToSTRString"], "url": ["ls", "source", "text", "org", "buffer", "position", "uri", "browser", "client", "path", "Url", "config", "page", "link", "l", "conn", "image", "loc", "web", "service", "location", "resource", "io", "base", "server", "URL", "address", "sl", "string", "channel", "lr", "file", "bug", "ssl", "user", "http"], "maxLines": ["maxLined", "maxFline", " maxBlined", "maxCLines", "minLine", "maxCLine", "maxFlizes", "maxSlizes", "minFlizes", "maxline", "maxFlues", "maxSlined", " maxBlanes", "maxlines", "maxLanes", "maxlues", " maxBlines", "maxBline", "minLizes", "maxCLined", "maxSlines", " maxBline", "maxLues", "maxFlines", "maxlizes", "maxBlines", " maxLanes", "maxBlined", "minLues", "maxSline", "maxSlues", "minLines", "minFlues", "maxCLanes", "minFlines", " maxLine", " maxLined", "maxLine", "minFline", "maxSlanes", "maxLizes", "maxBlanes"], "userAgent": ["usersData", "customId", "contentInfo", " useragent", " userId", " userData", "useragent", "customInfo", "contentCh", "customAgent", "useagent", "usersagent", "customagent", "userCh", "UserType", "userId", "contentAgent", "userType", "useType", "UserInfo", "userInfo", "UserCh", "usersAgent", "usersId", "Useragent", "UserAgent", "userData", "useInfo", "UserId", "contentType", "UserData", " userCh", " userType", " userInfo", "useAgent"], "timeout": ["buffer", "token", "period", "out", "sync", "length", "port", "fee", "timer", "frequency", "slot", "socket", "sleep", "duration", "service", "interrupted", "resource", "Timeout", "limit", "server", "capacity", "pool", "password", "until", "query", "number", "delay", "time", "index", "beta", "size", "resolution", "wait", "trial", "ssl", "unit", "rate", "type", "network", "offset"], "connection": ["text", "relation", "position", "current", "uri", "client", "connected", "cf", "session", "inner", "c", "config", "Connection", "component", "use", "driver", "l", "to", "conn", "image", "socket", "or", "application", "loc", "condition", "con", "service", "object", "proxy", "resource", "builder", "which", "communication", "io", "directory", "connect", "document", "database", "character", "bc", "b", "server", "password", "function", "index", "channel", "handler", "version", "collection", "part", "key", "response", "entry", "ion", "section", "db", "context", "http"]}}
{"id1": "12349563", "id2": "19652200", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "label": 0, "substitutes": {"resourceExists": [" fileexes", " fileexists", " resourceExits", " resourceexists", " resourceexits", " resourceExes", " resourceexistence", " resourceCompists", " resourceAbsistence", " fileExits", " resourceCompistence", " resourceAbses", " resourceAbsists", " fileExes", " resourceCompes", " fileexits", " fileExistence", " fileExists", " resourceexes", " resourceAbsits", " resourceExistence", " fileexistence", " resourceCompits"], "location": ["source", "local", "message", "filename", "position", "shape", "remote", "uri", "Location", "length", "path", "language", "point", "home", "info", "pointer", "area", "image", "localhost", "loc", "data", "folder", "object", "resource", "LOC", "directory", "description", "base", "name", "server", "host", "operation", "address", "connection", "string", "region", "layer", "provided", "reference", "file", "collection", "route", "href", "response", "layout", "type", "node", "target", "content"], "url": ["source", "uri", "path", "Url", "c", "f", "config", "page", "i", "l", "image", "build", "loc", "blog", "web", "resource", "open", "www", "io", "base", "b", "server", "host", "URL", "obj", "fl", "sl", "api", "address", "zip", "string", "connection", "ll", "impl", "file", "lib", "r", "ssl", "user", "http"], "cxn": ["crexg", "cexne", "Cxne", "cxxn", "cuxp", "Cxns", " cxp", "crexcon", " crexp", "cuxne", "cxxne", "crexp", "cdscon", "cuxns", "cexcon", " crexn", "cxg", "Cxp", "cxp", "cxcon", "cxns", "Cuxns", " crexg", "cdsp", "cdsn", "cxxp", "cxxns", "cuxn", "cexn", "cexp", " crexcon", "cexg", "cexns", "Cuxne", " cxcon", " cxg", "cxne", "Cuxn", "cdsg", "crexn", "Cxn", "Cuxp"], "is": ["x", "as", "ris", "app", "init", "internet", "uri", "IS", "out", "im", "us", "was", "isa", "oss", "ai", "info", "s", "its", "ori", "ens", "iss", "i", "Is", "src", "or", "iso", "web", "in", "close", "lis", "does", "ir", "ip", "ar", "next", "ms", "os", "cos", "it", "isc", "fs", "ui", "isl", "bs", "api", "isi", "stream", "ais", "ios", "es", "abs", "iris", "nis", "ob", "id", "bis", "get", "has", "js", "cms", "ois", "http"], "byteBuffer": ["bitBuff", "ByteArray", "ByteBuff", " byteBB", "byteBB", "bitBuffer", "ByteLength", " byteArray", "ByteBuffer", "byteArray", "bitLength", "ByteBB", "byteBuff", "byteLength", " byteBuff", " byteLength", "bitBB", "bitArray"]}}
{"id1": "18504192", "id2": "20190303", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "in": ["buffer", "copy", "inn", "inner", "c", "ac", "at", "info", "i", "input", "src", "image", "or", "IN", "data", "m", "ini", "old", "io", "url", "base", "name", "b", "min", "index", "ins", "In", "inc", "again", "file", "parent", "part", "login", "id", "reader", "diff", "bin", "d"], "out": ["p", "call", "copy", "cache", "output", "client", "c", "point", "w", "ex", "OUT", "conn", "line", "data", "writer", "object", "dest", "io", "n", "base", "name", "b", "obj", "password", "exec", "string", "connection", "external", "prefix", "Out", "outs", "again", "file", "temp", "part", "err", "o", "inc", "target"], "source": ["copy", "se", "client", "sync", "use", "component", "view", "slave", "ie", "i", "input", "ources", "ource", "src", "project", "sin", "SOURCE", "get", "writer", "Source", "service", "proxy", "from", "storage", "self", "dest", "core", "clone", "null", "server", "sl", "secure", "connection", "scope", "origin", "size", "channel", "stream", "settings", "iter", "ssl", "slice", "reader", "unit", "parent", "start", "target"], "destination": ["declification", "destinated", "destification", "testinations", " destining", "Destinated", "testinated", "dependination", "continated", "Destinations", "declinator", "continator", "contination", " destinations", "declinated", "testinator", " destinator", "testination", " destinated", "Destining", "Destination", "dependinator", "declination", "destinator", "contining", "dependinated", "Destinator", "destinations", "Destification", "destining", "dependification"]}}
{"id1": "19849797", "id2": "4716110", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "clonefile", " copySource", "copyfile", "copyFiles", "cloneSource", "transferfile", "transferFile", "cloneFiles", "cloneFile", "transferSource", " copyfile", "copySource", " copyFiles"], "sourceFile": ["destDirectory", "sourceDir", "ourceDirectory", "srcFile", "srcfile", "destfile", " sourcefile", " sourceFolder", "sourceDirectory", "ourceFile", "destUrl", "SourceUrl", "ourcefile", "SourceFolder", "SourceDir", "SourceFile", "sourcefile", "sourceFolder", "sourceUrl", "ourceUrl", "srcFolder", "SourceDirectory", "srcDir", " sourceDir", "Sourcefile"], "destFile": ["destDirectory", "sourceDir", "destfile", "srcfile", "srcFile", "DestPoint", "targetfile", " destDir", "destDir", "DestDirectory", " destPoint", "DestDir", "DestFiles", "foreignPath", "destPath", "targetLine", "foreignFiles", "resultfile", "resultDir", "targetDir", "targetFiles", " destFiles", " destDirectory", "targetFile", "destPoint", "resultFile", "srcFiles", "sourceFiles", "srcDirectory", "targetPath", "srcLine", " destfile", "DestFile", "foreignfile", "foreignFile", "sourcePoint", "resultLine", "srcDir", "DestPath", "destFiles", "Destfile", "destLine"], "source": ["remote", "result", "cache", "uri", "current", "client", "table", "output", "session", "inner", "config", "this", "use", "component", "seed", "slave", "view", "root", "ie", "input", "ource", "src", "image", "SOURCE", "manager", "sin", "get", "Source", "service", "object", "resource", "proxy", "ce", "from", "storage", "dest", "core", "si", "url", "null", "server", "secure", "api", "scene", "index", "connection", "scope", "channel", "size", "stream", "wrapper", "reference", "iter", "file", "route", "slice", "id", "unit", "reader", "site", "parent", "start", "target", "status", "context"], "destination": ["identinator", "Destion", "Destribution", "destinated", "domation", "constinator", " destation", "distion", "constribution", "distinated", " destion", "Destinated", "destation", "dominator", "generinator", "generination", " destruction", "Destruction", "destinate", "Destation", "dominated", "distruction", "generinated", " destinator", "Destinate", "participinator", "participinate", " destinated", "Destination", "constination", "destruction", "distination", "destinator", "identinated", "distinator", "participinated", "construction", " destribution", "identination", "generruction", "destion", "destribution", "participination", "Destinator", "domination", "identinate"]}}
{"id1": "6625074", "id2": "20365090", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "label": 0, "substitutes": {"SHA1": ["HA384", "SHAOne", " SHAOne", "sha256", "shaOne", "SHA256", "sha384", "HA256", "SHA384", "HA1", "HAOne", " SHA256", " SHA384", "sha1"], "text": ["source", "message", "buffer", "output", "str", " Text", "out", "token", "path", "translation", "config", "font", "bytes", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "format", "context", "editor", "class", "name", "ext", "Text", "code", "obj", "password", "transfer", "letter", "hex", "string", "struct", "test", "value", "template", "contract", "plain", "pattern", "content"], "sha1hash": ["sha256password", "shaOnehash", "SHA1cap", "SHA1text", "sha6Hash", "sha6hash", "sha_Hash", "ha2hash", "sha1hex", "sha2cap", "sha81Hash", "shaOnepassword", "ha1hash", "sha256text", "sha6log", "ha1hex", "sha_sum", "ha2hex", "SHA2cap", "sha6cap", "sha1cap", "ha2Hash", "ha1Hash", "sha1text", "sha2Hash", "sha81log", "sha1Hash", "sha2hash", "shaOnetext", "sha81cap", "sha256Hash", "ha2sum", "SHA2hash", "SHA1Hash", "sha2hex", "sha2sum", "SHA1hash", "sha_hex", "sha81hash", "sha2log", "sha1sum", "SHA2log", "ha1sum", "sha1password", "sha256hash", "shaOneHash", "sha_hash", "sha1log", "SHA1password", "SHA2Hash", "SHA1log"], "md": ["hm", "mm", "mp", "cf", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "de", "mb", "meta", "m", "nm", "metadata", "ad", "mac", "editor", "rm", "ms", "sm", "vd", "um", "nd", "pd", "sha", " MD", "gb", "od", "ld", "dd", "mo", "mt", "hd", "cd", "MD", "mc", "ma", "df", "pkg", "mag", "pm", "d", "rpm", "bd"]}}
{"id1": "17522011", "id2": "17207832", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"read": ["work", "create", "Read", "reading", "parse", "check", "invoke", "load", "use", "READ", "input", "send", "default", "process", "build", "resources", "readable", "data", "resource", "open", "play", "find", "print", "connect", "class", "add", "exec", "report", "reads", "eval", "write", "include", "feed", "reader", "type", "get", "start", "select", "run"], "classLoader": ["ClassPath", "resourceloader", "fileLoader", "fileDir", "filePath", "ClassLoad", "Classloader", "classLoad", " classloader", " classReader", " classLoad", "resourceReader", " classLoading", "classLoading", "fileloader", "ClassLoader", "classPath", "classloader", "classDir", "resourceLoader", " classDir", " classPath", "classReader", "fileLoad", "ClassDir", "ClassReader", "resourceLoading", "ClassLoading"], "name": ["x", "filename", "large", "str", "path", "ame", "alias", "NAME", "home", "pass", "root", "word", "Name", "image", "none", "default", "data", "names", "resource", "comment", "old", "n", "class", "base", "search", "null", "code", "child", "address", "time", "string", "connection", "size", "prefix", "named", "file", "value", "part", "key", "id", "type", "parent", "no", "active"], "all": ["local", "call", "app", "al", "sync", "at", "f", "this", "not", "with", "pass", "one", "l", "none", "global", "process", "left", "total", "and", "ann", "array", "allow", "All", "each", "ALL", "list", "alpha", "full", "batch", "only", "auto", "both", "sort", "am", "attribute", "named", "part", "partial", "any", "apply", "alls", "active"], "sm": ["source", "hm", "sim", "smith", "sy", "su", "sb", "sw", "so", "im", "ss", "mm", "Sm", "sym", "imm", "ama", "serv", "m", "fm", "nm", "service", "sr", "asm", "sa", "si", "rm", "em", "ms", "vm", "zip", "sl", "api", "gm", "sp", "sk", "tm", "om", "bm", "cm", "mo", "sh", "sum", "sn", "SM", "km", "wm", "sam", "spe", "sf", "sv", "ym"], "enu": ["munun", "ENc", "enus", " enus", "ennu", "Enu", "ENu", "EnU", "enun", "Encu", "anus", " ennu", "anU", "ENus", "Enus", "venus", "Enc", "enou", "anun", "munU", "munus", "Enun", "munu", "ENou", "venou", "Enou", " encu", "encu", "Ennu", "ennnu", "ennus", "anu", "enc", "enncu", "enU", "venc", "venu"], "url": ["ls", "source", "uri", "str", "browser", "path", "Url", "plug", "f", "download", "page", "i", "l", "image", "loc", "loader", "web", "in", "resource", "base", "job", "server", "URL", "zip", "sl", "address", "li", "string", "connection", "ur", "layer", "ll", "impl", "file", "pull", "ssl", "r", "key", "id", "rel", "http"], "is": ["p", "ls", "mis", "as", "ris", "app", "init", "uri", "IS", "isa", "was", "im", "us", "inner", "info", "ii", "ori", "its", "il", "are", "iss", "i", "js", "Is", "ie", "serv", "image", "or", "iso", "ic", "web", "in", "lis", "close", "ir", "vs", "act", "ip", "io", "ar", "si", "os", "it", "esi", "isc", "isl", "api", "isi", "ins", "ais", "ios", "es", "abs", "iris", "ignore", "id", "bis", "has", "ri", "cms", "ops", "ois", "http"], "s": ["p", "ls", "cs", "su", "sb", "ps", "ts", "ss", "se", "lines", "session", "c", "ips", "f", "its", "als", "w", "e", "sg", "i", "l", "services", "ds", "ans", "les", "m", "strings", "rs", "ws", "storage", "n", "g", "ks", "si", "ses", "ms", "os", "u", "spec", "ies", "ments", "sc", "sl", "string", "ins", "h", "ches", "details", "gs", "ings", "outs", "sets", "ns", "ows", "es", "abs", "ssl", "r", "results", "sf", "o", "sv", "comments", "S", "ions", "js", "d", "rows"]}}
{"id1": "6742637", "id2": "88047", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findextensions", "findDistension", "getextends", "findextends", "getExtensions", "getExtends", "findExtension", "getExtension", "findDistends", "getextension", "findDistensions", "findAppends", "findAppension", "findextension", "getextensions", "findExtends", "findAppensions"], "url": ["ls", "source", "org", "remote", "result", "buffer", "re", "uri", "gl", "path", "Url", "load", "config", "f", "ver", "bb", "page", "il", "link", "l", "src", "image", "loc", "data", "web", "service", "resource", "location", "io", "base", "name", "bel", "log", "server", "URL", "rl", "zip", "address", "api", "ch", "sl", "rc", "connection", "fr", "ur", "cl", "lr", "ul", "element", "impl", "coll", "html", "file", "bug", "pull", "err", "r", "ssl", "feed", "id", "entry", "rel", "http"], "extensions": ["intps", "fensions", "exensions", "Extension", "fends", "intension", "appensions", "fps", "Extencies", "intends", "xtension", "xtends", "extension", "appencies", "exras", "extras", "appras", "fension", "extps", "extencies", "exension", "xtps", "exencies", "exends", "Extras", "intensions", "exps", "xtensions", "Extensions", "appension"], "res": ["rem", "ris", "ret", "result", "ps", "re", "out", "ver", "rr", "mr", "ex", "rest", "RE", "vals", "resp", "req", "resource", "RS", "rs", "ras", "ros", "RES", "os", "ries", "hr", "is", "gr", "ch", "rc", "Rs", "rss", "rus", "fr", "pres", "details", "vers", "raw", "rez", "resolution", "rex", "ress", "Res", "es", "request", "r", "results", "response", "err", "rev", "rh", "js", "rows", "http"], "prop": ["p", "attr", "ref", "app", "style", "result", "property", "ps", "fp", "mp", "feature", "feat", "f", "config", "info", "fb", "point", "Prop", "pb", "project", "pos", "val", "data", "resource", "class", "base", "tmp", "b", "proc", "ext", "obj", "pac", "priv", "api", "term", "j", "exp", "cp", "option", "comp", "pr", "lit", "def", "properties", "pro", "key", "part", "op", "opt"], "msg": ["text", "me", "og", "message", "eg", "ug", "str", "s", "info", "title", "cmd", "sg", "agg", "rag", "cfg", "ko", "mb", "mg", "loc", "req", "m", "format", "bf", "g", "log", "ms", "reason", "Msg", "ext", "kg", "printf", "mid", "bg", "gr", "gm", "db", "string", "tag", "mn", "mt", "gs", "urg", "err", "comm", "mag", "error", "status"]}}
{"id1": "16048516", "id2": "16621503", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"load": ["create", "init", "set", "parse", "loaded", "check", "download", "update", "content", "show", "dump", "read", "install", "loader", "build", "process", "open", "transform", "Load", "add", "oad", "upload", "loads", "save", "get", "start", "LOAD"], "urlConfiguracion": ["urlconfiguraton", "urlConfigURation", "urlConfigutacion", "urlconfigauraton", "urlConfurator", "urlConfigURator", "urlConfigureation", "urlconfiguraci", "urlConfureacion", "urlConfigurator", "urlConfigurateation", "urlConfureator", "urlConfuration", "urlconfigauracion", "urlConfigaurator", "urlconfigauraci", "urlConfureation", "urlConfuracion", "urlConfigureracion", "urlConfigauraton", "urlconfigurator", "urlConfigurabet", "urlConfigureacion", "urlConfuraci", "urlConfigutabet", "urlConfigutado", "urlConfiguration", "urlConfiguraton", "urlConfigurerator", "urlConfigurado", "urlConfigureabet", "urlConfigureator", "urlConfigURaton", "urlConfigauracion", "urlConfigurateaci", "urlConfigureaton", "urlConfureaci", "urlConfigauraci", "urlConfiguraci", "urlConfigURaci", "urlConfigureaci", "urlConfigutator", "urlConfigURacion", "urlConfigurateator", "urlConfigurerado", "urlconfiguracion", "urlConfigureado", "urlConfigurateacion", "urlConfigurerabet", "urlconfigaurator"], "configuracion": ["Configuraci", "configuraton", "Configureant", "configutaton", "configuralacion", "configureaci", "configoration", "Configuration", "configuraateur", "configuralation", "configutant", "configoracion", "Configureab", "calureaci", "configurator", "caluration", "configureacion", "configureation", "Configuraton", "Configuracion", "Configureation", "Configureaton", "configurab", "configuration", "configureator", "Configurateur", "configuraacion", "configureaton", "Configureacion", "configureab", "configureateur", "configuraab", "configuralaton", "calureacion", "configureant", "caluraton", "configuralant", "calureation", "configaurator", "configuralator", "configauraton", "configutaci", "Configureaci", "configutacion", "configuralaci", "configuraci", "Configurab", "Configureator", "configurateur", "configoraci", "configurant", "caluracion", "Configureateur", "Configurant", "Configurator", "configauraci", "configaurab", "configaurateur", "configauracion", "configuraator", "configauration", "configoraton", "caluraci", "calureaton"], "xenc": ["Xenv", "xenv", "xmlenc", "fxens", " xEnc", "ixstream", "Xenc", "xec", " xec", "exsen", "xmlEnc", "xstream", "exenc", "Xenz", "ixec", "xEnc", "ixenc", "xmlenv", "fxenz", "fxEnc", "Xens", " xstream", "xens", "fxenc", "exec", " xens", "xsen", " xsen", "xenz", "XEnc", "exstream", " xenz", "xmlens", " xenv", "ixsen"]}}
{"id1": "884867", "id2": "20619879", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"zipname": ["filename", "lockname", "ziproot", "zipno", "zipfile", "clipName", "projectname", "lockno", "gzsize", "clipcache", "zname", "clipno", "projectName", "zipsize", "zName", "zsize", "filefile", "gzfile", "lockcache", "zipcache", "projectno", " zipsize", "zroot", "fileName", " ziproot", "gzname", "lockName", " zipfile", "zfile", "gzName", " zipName", "fileroot", "clipname", "projectcache", "zipName"], "zipout": [" zipserver", "clipout", "zipcontainer", "copname", "zipfile", "zserver", "zipserver", "zipin", "clipcache", " zipin", "zname", "copfile", "copin", "zengen", "zoutput", " zipcache", " zipgen", "folderout", " zipcontainer", "zipoutput", "zout", "zcontainer", "zipcache", "folderin", "zgen", " zipoutput", "zipgen", "zenin", " zipfile", "zcache", "zenout", "zfile", "clipoutput", "zenserver", "zin", "copout", "foldername", "clipin", "foldercontainer"], "out": ["p", "pre", "dot", "doc", "group", "copy", "cache", "output", "client", "flush", "point", "f", "page", "w", "plus", "ex", "word", "dump", "OUT", "conn", "line", "image", "project", "writer", "print", "io", "n", "bin", "up", "base", "log", "name", "b", "window", "url", "outer", "code", "gen", "post", "msg", "query", "term", "exec", "pool", "obj", "list", "exp", "lock", "prefix", "Out", "write", "raw", "outs", "again", "file", "parent", "lib", "err", "key", "diff", "o", "user", "inc", "error", "co"], "buffer": ["sequence", "source", "shape", "position", "cache", "result", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "image", "border", "padding", "read", "data", "resource", "binary", "comment", "limit", "url", "base", "b", "array", "null", "transfer", "number", "Buffer", "header", "channel", "size", "stack", "queue", "layer", "batch", "block", "iter", "reference", "file", "row", "wave", "feed", "slice", "reader", "offset"], "in": ["as", "init", "rec", "re", "gin", "inn", "pin", "inner", "c", "f", "pass", "ex", "i", "input", "l", "serv", "conn", "image", "IN", "ini", "win", "con", "up", "a", "url", "din", "b", "is", "nin", "ins", "fr", "lin", "In", "inc", "again", "rin", "r", "err", "login", "diff", "reader", "id", "bin", "ic"], "length": ["sequence", "last", "style", "position", "shape", "Length", "load", "point", "f", "len", "component", "view", "tail", "level", "feed", "l", "angle", "count", "present", "ength", "line", "build", "loc", "ph", "left", "duration", "total", "old", "force", "core", "class", "limit", "url", "character", "width", "pe", "code", "number", "body", "append", "index", "string", "size", "lock", "range", "full", "ok", "part", "partial", "key", "pull", "slice", "ob", "end", "join", "id", "type", "section", "row", "offset"]}}
{"id1": "4593012", "id2": "21930714", "code1": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testSpeedyShareUpload() throws Exception {\n        request.setUrl(\"http://www.speedyshare.com/upload.php\");\n        request.setFile(\"fileup0\", file);\n        HttpResponse response = httpClient.execute(request);\n        assertTrue(response.is2xxSuccess());\n        assertTrue(response.getResponseHeaders().size() > 0);\n        String body = IOUtils.toString(response.getResponseBody());\n        assertTrue(body.contains(\"Download link\"));\n        assertTrue(body.contains(\"Delete password\"));\n        response.close();\n    }\n", "label": 0, "substitutes": {"upgradeSchema": ["upgradeSchement", "upgradeCatalogment", "upgradeCatalogMeta", "upgradingschement", "upgradingschemas", "upgradeDatabaseMeta", "upgradeschement", "upgradingSchema", "upgradeCatalogmas", "upgradeSchemas", "upgradingSchemas", "upgradeScheMeta", "upgradeschemas", "upgradescheMeta", "upgradeDatabasema", "upgradeDatabasemas", "upgradeCatalogma", "upgradeschema", "upgradingSchement", "upgradingschema", "upgradingscheMeta", "upgradeDatabasement", "upgradingScheMeta"], "stmt": ["strmr", "stvt", "estmp", "estm", "pmt", "estmt", "strnt", "STvt", "estmsg", "hnt", "sttm", "stql", " stmp", " stmsg", "Stnt", "rql", "ftmp", "STmt", "STtm", " stql", "Stdb", "stmr", "rmt", "pvt", "hmit", " stmit", "ftmit", "rmr", "hmp", " sttm", "stdb", "Stmt", "rmp", "frm", "stmsg", "frmsg", " stm", "Stmr", "ftnt", "strmt", "hmt", "frmp", "stm", " stnt", " stmr", "STm", "ptm", "ftmt", "stmp", " stvt", "stnt", "frmt", "stmit", "strql", "strmp", "pm", " stdb", "strdb"], "i": ["p", "x", "hei", "uri", "c", "ni", "ai", "f", "gi", "ii", "info", "ix", "isu", "e", "ie", "vi", "I", "k", "count", "ci", "yi", "abi", "ini", "in", "ami", "multi", "ip", "iu", "bi", "n", "si", "name", "u", "b", "it", "ui", "pi", "oi", "isi", "li", "index", "j", "api", "ki", "mi", "di", "qi", "eni", "xi", "start", "fi", "cli", "t", "slice", "r", "id", "o", "zi", "adi", "v", "esi", "ri", "ti", "hi", "phi"], "qry": ["qrc", " qcr", "quri", "qrys", "qri", "qurc", " qRY", " qrc", "querRY", "Qry", "QRY", "qucr", "qries", "qurys", "Qri", " qries", "querrc", "qury", "querry", "Qrys", "quries", " qrys", "quRY", "qcr", "Qries", "qRY", "Qcr", " qri", "querri"]}}
{"id1": "6304373", "id2": "16820041", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrtemFiles"], "action": ["flow", "method", "ACTION", "call", "style", "flash", "effect", "activity", "environment", "actions", "event", "state", "ction", "view", "item", "module", "service", "format", "resource", "act", "next", "url", "name", "change", "function", "operation", "Action", "api", "activation", "now", "lock", "element", "plugin", "test", "version", "parent", "part", "step", "controller", "what", "site", "type", "commit", "section", "error", "status", "active"], "object": ["edit", "group", "mode", "current", "instance", "environment", "system", "not", "event", "model", "project", "image", "none", "resource", "email", "module", "service", "self", "directory", "class", "url", "subject", "document", "objects", "thread", "article", "host", "obj", "function", "number", "address", "letter", "string", "now", "lock", "oid", "ject", "element", "full", "auto", "office", "version", "request", "part", "o", "zone", "parent", "node", "target"], "numElements": ["numGelem", "numeodes", " numElem", "numEllem", "numEllement", "numelem", "numelements", "numEodes", "numElem", "numGeodes", " numelem", " numelement", " numEodes", "numelement", "numGelements", "numGelement", " numelements", "numElodes", "numEllements", " numeodes"], "req": ["util", "ro", "load", "update", "use", "mr", "resp", "module", "builder", "g", "next", "base", "log", "params", "obj", "msg", "conf", "verb", "res", "gr", "usr", "html", "err", "r", "ctx", "parent", "xml", "report"], "session": ["local", "result", "cache", "token", "client", "browser", "flash", "instance", "ession", "system", "state", "event", "person", "use", "ESSION", "manager", "image", "global", "shared", "service", "resource", "sa", "document", "subject", "security", "thread", "sp", "container", "connection", "h", "scope", "lock", "test", "temp", "request", "response", "site", "Session", "ctx", "context", "http"], "ftp": ["FTP", "ttP", " ftc", "ttcp", " ftcp", "FTp", "ttp", "ftcp", "ftP", "ttc", "FTcp", "ftc", " ftP", "FTc"], "user": ["account", "match", "group", "facebook", "result", "current", "browser", "client", "path", "username", "author", "config", "ver", "info", "hash", "this", "use", "page", "pass", "person", "home", "e", "per", "view", "state", "usa", "project", "image", "shared", "USER", "by", "data", "module", "auth", "other", "record", "comment", "self", "class", "url", "base", "name", "log", "error", "mail", "post", "admin", "string", "rule", "connection", "lock", "profile", "ee", "full", "usr", "used", "html", "creator", "users", "system", "parent", "bug", "er", "custom", "type", "member", "db", "User"], "links": ["Links", "lines", "flash", "styles", "actions", "link", "groups", "tree", "image", "menu", "linked", "email", "url", "base", "log", "members", "Link", "pages", "details", "html", "mails", "headers", "results", "items", "ids", "images", "posts", "mail"], "folders": ["handers", "handors", "anchages", "handries", "foldages", "filers", "anchries", "anchers", "foldors", "handages", "anchors", "foldries", "filages", "filries", "filors"], "folder": ["source", "filename", "flat", "Folder", "uri", "path", "license", "home", "archive", "level", "command", "area", "enter", "project", "menu", "location", "email", "resource", "directory", "editor", "division", "document", "url", "database", "device", "picture", "theme", "zip", "address", "letter", "append", "upload", "scope", "connection", "two", "region", "future", "element", "layer", "plugin", "sample", "dir", "slice", "id", "layout", "fold", "zone", "ignore", "network", "volume"], "server": ["erver", "account", "source", "filename", "remote", "uri", "token", "client", "port", "username", "inner", "system", "page", "master", "slave", "seed", "socket", "manager", "localhost", "enter", "service", "resource", "email", "location", "directory", "url", "database", "device", "outer", "Server", "host", "peer", "address", "string", "connection", "scale", "value", "version", "ser", "ssl", "site", "reader", "engine", "network", "node", "type", "status"], "login": ["account", "secret", "access", "group", "cookie", "filename", "bridge", "path", "username", "pin", "basic", "config", "info", "skin", "pass", "socket", "blog", "service", "auth", "email", "resource", "journal", "consumer", "sudo", "shell", "url", "database", "name", "log", "mail", "picture", "label", "string", "connection", "machine", "lock", "profile", "plugin", "users", "ssl", "layout", "site", "network", "Login", "blank", "status"], "password": ["account", "secret", " passwords", "access", "column", "mask", "cookie", "filename", "token", "username", "language", "basic", "alias", "pass", "timeout", "phrase", "slave", "word", "manager", "padding", "photo", "auth", "email", "strip", "PASS", "sudo", "directory", "division", "database", "name", "device", "security", "sword", "picture", "string", "worker", "connection", "profile", "plugin", "Password", "ass", "pattern", "volume"], "fileTransferFolder": ["fileImportDirectory", "fileUploadServer", "fileImportFolder", "FileUploadTheme", "fileTransferTheme", "FileUploadPath", "fileTransferServer", "mediaUploadfolder", "fileAccessTheme", "fileTransformTheme", "fileUploadfolder", "mediaUploadServer", "fileUploadTheme", "fileImportfolder", "mediaUploadDirectory", "fileUploadPath", "FileUploadfolder", "FileTransferFolder", "fileTransformfolder", "mediaTransferFolder", "mediaTransferfolder", "fileAccessPath", "fileTransformPath", "fileImportServer", "fileUploadFolder", "fileTransformFolder", "fileUploadDirectory", "fileTransferDirectory", "FileTransferTheme", "fileAccessfolder", "FileTransferfolder", "FileTransferPath", "mediaTransferServer", "fileTransferfolder", "fileAccessFolder", "mediaTransferDirectory", "mediaUploadFolder", "FileUploadFolder", "fileTransferPath"], "liveFolder": ["LiveDirectory", "PreviewFolder", "Previewfolder", "livefolder", " livefolder", " liveLocation", "liveLocation", "LiveLocation", "Livefolder", "PreviewDirectory", "liveDirectory", "LiveFolder", " liveDirectory", "PreviewLocation"], "servers": ["SerServer", "serls", " serations", "servations", "serServer", "servServer", "serations", "servls", "Serls", "servvers", "Serations", "Servers", " serServer", " serls"], "message": ["Message", "buffer", "summary", "path", "flash", "update", "page", "manager", "image", "menu", "module", "resource", "email", "mess", "description", "document", "url", "log", "array", "mail", " messages", "msg", "address", "body", "header", "string", "details", "element", "request", "response", "member", "error", "status", "content", "application"]}}
{"id1": "15810440", "id2": "10547671", "code1": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"addRecipe": ["saveApplication", "setRecipe", "AddCourse", "addCourse", "setCourse", "addApplication", "AddRecipe", "setApplication", "addFood", "AddApplication", "saveCourse", "setFood", "AddFood", "saveFood", "saveRecipe"], "name": ["source", "create", "style", "filename", "table", "large", "path", "username", "ame", "config", "alias", "NAME", "home", "company", "title", "model", "plus", "family", "one", "word", "Name", "image", "none", "data", "names", "module", "comment", "old", "n", "description", "action", "class", "url", "base", "database", "search", "label", "mini", "admin", "time", "string", "connection", "size", "prefix", "full", "named", "file", "collection", "parent", "part", "version", "key", "template", "type", "common"], "instructions": ["inscription", "incriptions", "insemptories", "instruction", "instructations", "incriptures", "inscriptures", "incorrections", "insemption", "insstruction", " inscriptions", "incription", "insemptions", "inemptions", "inemptories", "injectutions", "injections", "injectures", "inemptutions", "insstructions", "instructs", "INSTRUCTion", "insstructes", "incorrectures", "INstruction", "inemptations", "inemptes", " instructures", " inscriptutions", "injection", "INSTRUCTions", "inscriptions", "inSTRUCTures", "incorrectories", "INstructions", "injects", "instructes", "inempts", "INSTRUCTures", "incorrection", " instructations", "inscriptories", " inscriptations", " instructutions", "incriptes", "insstructories", "INSTRUCTs", "inscriptutions", "instructories", "injectations", "insstructures", "injectes", "inemptures", "insemptures", "INstructs", "inSTRUCTs", "inSTRUCTion", "inemption", "instructutions", " inscriptures", "insemptes", "INstructures", "instructures", "inscriptations", "inSTRUCTions"], "categoryId": ["ategorySize", "channelSize", "CategoryId", "packageInfo", "categoryid", "channelid", "categoryCode", "channelId", "categoryType", " categoryID", "ategoryid", "CategoryInfo", "ategoryType", "currencyCode", " categoryInfo", " categoryCode", " categoryInt", "CategoryID", "categoryID", "currencyid", "categorySize", "channelType", "sectionID", "packageID", "currencyID", " categoryid", " categoryType", "categoryInt", "CategoryInt", "currencyId", "sectionid", "sectionId", "packageId", "ategoryId", "sectionCode", "packageInt", " categorySize", "categoryInfo"], "ainekset": ["aineeksette", "ainseksET", "raineeksset", "raineksets", "aineksheet", "aineksette", "aineksET", "ainscesset", "raineeksette", "aineeeksET", "ainesat", "raineeksets", "ainesset", "aineticsset", "ainesette", "aineksets", "aineeeksset", "ainsekset", "ainscesET", "aincesET", "ainnersset", "aincesset", "rainekset", "aineekset", "aineset", "ainesET", "ainewsset", "ainscesheet", "aineeksets", "ainesets", "ainseksset", "ainseksheet", "aineticsheet", "aineticsET", "ainesheet", "aineksset", "aineeksat", "ainewsET", "ainceset", "raineekset", "raineksette", "aineeksET", "aineksat", "ainewsat", "aincesheet", "raineksset", "aineeksset", "ainnerset", "aineeekset", "ainnersette", "aineeeksat", "ainsceset", "ainewset", "aineticset", "ainnersets"], "pst1": ["ppt1", "psth2", " pest0", "ppst1", "ppste0", "ppst3", "presteOne", " pstOne", "pcr2", "PstOne", "pest100", "pstr2", "Pct0", "psts0", "presteone", "pst55", " pst100", "psteone", "pste3", "pstone", "psp100", "pcr0", "pct1", "pstr0", " pcr0", "pstr1", "pmt55", " pcr2", "Pst55", "prestone", "preste2", "pcr1", "pctOne", "pct01", "ppst0", "PctOne", "pmt0", "Pst1", "Pct2", "pft2", "pct2", " pcr01", "pSTone", "preste1", "pst3", "pstsOne", "psp1", "pstr55", "pst01", "pste1", "pctone", "pmt2", "pST2", "Pst0", "prest2", "pST1", "pptOne", "pest1", "ppste1", "pspOne", "pst100", "pct55", "pmt1", "pft1", "pst0", "psth1", "pste0", " pcr1", "pftOne", "pest0", "Pct1", "Pst2", "psts100", "pestOne", "psp0", "pste2", "pptone", "prestOne", " pst0", "pcr01", "psth01", "pct0", "Pstone", "Pctone", " pest1", "pct3", "psth0", " pest100", "pSTOne", "ppste2", "ppt2", "pftone", "psteOne", "prest1", "psts1", "Pct55", " pst01", " pestOne", "ppst2", "ppste3", "pstOne"], "pst2": ["pct6", "qst2", "pv2", "psth2", "qest25", "post5", "ppr2", "pst10", "qst02", "Pct10", "ppr1", " pmt1", "pst6", "pv1", "pct5", "qst25", "pmtSecond", "pct1", "pctSecond", "pct2012", "pct02", "pct4", "psth6", " post5", "pstSecond", "psth4", "qst1", "pkt2", " psth0", "pSTTwo", "qest1", "pct10", "pkt2012", "pxt1", "pv6", "pctTwo", "Pst1", "post2", "Pct2", "pct2", "pct25", "post1", " post2", "pest02", "pstd1", "pstd4", "pst5", "Pct6", "pkttwo", "pstTwo", "pxt2", "pste1", " psth2", " psth4", "pmt2", "pST2", "pest2", "pst25", "pxttwo", "psth10", "pST1", "pcttwo", " pstTwo", " pstSecond", " psth1", "pest1", " pmt2", "pstdSecond", "pest25", "pmt1", "pst0", " postTwo", "psth1", "qest2", "pste0", "ppr02", "postTwo", "qest02", "Pct1", "Pst2", "pkt1", " pmt4", "pst4", "Pcttwo", "Pst2012", "pmt4", " post1", "Pct2012", "pste2", "pxt2012", " pst0", "pste4", "pv10", "pct0", "psttwo", "pst2012", "pST5", "pstd2", "psth0", "Psttwo", "Pst6", "pst02", " pmtSecond", "Pst10", "ppr25", " pst5", " pst4"], "rs": ["ls", "as", "ris", "cs", "rx", "ps", "s", "ars", "rr", "mr", "ers", "ds", "hs", "RC", "errors", "RS", "ws", "sr", "ras", "ros", "ks", "ms", "qs", "hr", "rd", "cr", "rl", "bs", "sl", "res", "rss", "rc", "Rs", "ins", "acks", "yr", "rys", "xs", "details", "pr", "vers", "gs", "repl", "runs", "rt", "ows", "row", "r", "results", "rh", "js", "rows", "rg"], "retVal": [" retRet", "authVal", "RetVal", "authValue", "RETTx", "RetValue", "retRet", " retValue", "returnValue", "returnRes", "retValue", "altValue", "RETVal", "retVAL", "RETRet", "returnVal", "altRes", "altRet", "Retval", " retRes", "authVAL", "retTx", "altTx", "altVal", " retval", " retVAL", "retval", "retRes", "altval", " retTx", "returnval", "RetVAL"], "id": ["p", "kid", "uid", "ref", "result", "Id", "rid", "str", "path", "cat", "f", "alias", "info", "root", "ident", "max", "count", "in", "bid", "vid", "ip", "ide", "error", "url", "num", "it", "code", "gen", "number", "index", "string", "ID", "sid", "lit", "def", "pid", "value", "version", "row", "key", "aid", "end", "type", "start", "ids", "d"], "aines": ["ginse", "ansES", "AINse", "anses", "raine", "ansences", "rainences", "ainences", "aine", "AINe", "ainsse", "raines", "ainsetics", "gines", "ainetics", "ainss", "versens", "dons", "done", "rainetics", "ainsens", "rouetics", "verses", "dones", "ainens", "ainsES", "ainse", "rainES", "versse", "AINes", "ainES", "roue", "ainsess", "rainens", "donse", "ginES", "ains", "AINess", "rains", "gine", "rainess", "verse", "ainses", "roues", "rainse", "rouse", "anse", "ainess", "ainsences"], "i": ["p", "x", "uri", "z", "c", "ni", "ai", "gi", "ii", "info", "ori", "e", "ie", "one", "l", "I", "ci", "uli", "yi", "ini", "in", "multi", "ip", "n", "bi", "iu", "io", "si", "u", "b", "it", "ti", "is", "ui", "pi", "oi", "li", "index", "j", "hi", "mi", "di", "qi", "y", "xi", "part", "fi", "t", "o", "v", "d", "phi"]}}
{"id1": "3806532", "id2": "10540676", "code1": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"createNew": ["writeNew", "createnew", "writeFile", "createRemote", "writeRemote", "requestFile", "requestNew", "writenew", "requestnew", " createRemote", "createFile", " createFile", "requestRemote", " createnew"], "name": ["x", "source", "filename", "uri", "path", "username", "ame", "alias", "NAME", "this", "domain", "e", "word", "Name", "none", "default", "data", "names", "resource", "old", "self", "n", "action", "url", "base", "null", "server", "ext", "host", "code", "address", "child", "time", "string", "connection", "size", "prefix", "named", "file", "space", "request", "part", "value", "key", "id", "type", "parent", "common", "content"], "in": ["work", "source", "path", "pin", "inner", "f", "config", "info", "len", "plus", "pass", "i", "input", "conn", "image", "inside", "read", "IN", "data", "con", "record", "resource", "win", "ini", "isin", "url", " IN", "exec", "min", "index", "ins", "connection", "size", "cin", "thin", "In", "inc", "pull", "part", "r", "login", "id", "reader", "diff", "type", "bin"], "length": ["sequence", "filename", "buffer", "Length", "path", "load", "info", "len", "timeout", "level", "count", "ength", "padding", "duration", "limit", "width", "capacity", "number", "address", "body", "time", "string", "lock", "size", "id", "type", "offset", "content"], "contentType": ["acceptType", "Contenttype", "contentToken", " contenttype", "contenttype", "acceptLength", "accepttype", "contentLength", "ContentToken", " contentToken", " contentLength", "ContentLength", "ContentType", "acceptToken"], "dest": ["source", "flat", "output", "uc", "path", " destination", "config", "home", "through", "store", "this", "trip", "txt", " Dest", "d", "de", "src", "project", "rest", "func", "cdn", "default", "down", "loc", "data", "folder", "resource", "done", "later", "img", "up", "sup", "tmp", "cont", "proc", "null", "asc", "gen", "obj", "destroy", "dist", "fn", "comb", "cl", "desc", "coord", "file", "temp", "route", "wb", "Dest", "dir", "ctx", "parent", "opt", "target", "dc"], "out": ["x", "init", "cache", "gin", "session", "extra", "image", "url", "base", "log", "null", "ext", "pool", "channel", "qa", "off", "temp", "key", "copy", "client", "sync", "home", "all", "view", "plus", "one", "conn", "OUT", "data", "writer", "up", "io", "n", "job", "obj", "password", "raw", "outs", "lib", "diff", "parent", "bin", "call", "output", "point", "socket", "line", "bit", "array", "b", "exp", "Out", "version", "loop", "o", "inc", "flow", "f", "page", "pass", "ex", "cmd", "window", "exec", "child", "connection", "again", "file", "part", "err", "v"]}}
{"id1": "12066447", "id2": "539195", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"truncate": ["trrenate", "trunational", "trrenator", "truncator", "trunator", "autuncator", "truncation", "autuncational", "autatenation", "autuncation", "trrenation", "truncational", "autatenational", "autuncate", "tratenate", "trrenational", "tratenational", "tratenator", "autatenator", "trunate", "tratenation", "trunation", "autatenate"], "file": ["source", "local", "filename", "File", "fp", "cache", "out", "uri", "current", "path", "f", "info", "this", "model", "page", "ile", "plus", "archive", "e", "one", "per", "l", "image", "single", "line", "or", "get", "data", "folder", "object", "resource", "format", "binary", "FILE", "directory", "io", "class", "url", "base", "log", "name", "document", "it", "files", "function", "zip", "address", "body", "time", "string", "connection", "future", "handler", "stream", "queue", "full", "type", "parent", " File", "db", "http"], "backupRoot": ["BackupPath", "backupsDirectory", "backbaseRoot", "backbackDirectory", "backupDir", "backbasePath", "frontupDir", "backupHome", "frontdownroot", "backbackRoot", "backflowDir", "backdownDirectory", "backdownFolder", "backupDirectory", "backureHome", "BackbackFile", "backUpDir", "frontdownDir", "backUpFolder", "backdownHome", "backupsroot", "BackureDirectory", "backupPath", "BackdownRoot", "backupFile", "backUproot", "BackdownDirectory", "backbackDir", "backdownRoot", "backUpRoot", "frontupFolder", "BackupDirectory", "backureDirectory", "backbackHome", "backdownroot", "backbaseroot", "backupsPath", "BackbackDir", "BackdownPath", "backbackFile", "backflowFile", "backflowRoot", "frontdownRoot", "backflowroot", "BackupHome", "BackupDir", "backupFolder", "frontupRoot", "backdownFile", "backureDir", "Backuproot", "backupsFolder", "backupsDir", "frontdownFolder", "backbaseDirectory", "BackureDir", "BackbackRoot", "backuproot", "BackupFile", "backupsRoot", "backdownDir", "backdownPath", "Backbackroot", "backureRoot", "frontuproot", "Backdownroot", "BackureHome", "BackureRoot", "backbackroot", "BackupRoot"], "df": ["flow", "DF", "md", "fp", "dict", "cf", "f", "fb", "CF", "dm", "de", "ds", "func", "data", "da", " def", "format", "dl", "bf", "pdf", "af", "io", "deb", "fd", "dt", "fs", "fe", "pd", "fn", "fr", "di", "dd", "tf", "dp", "fc", "def", "dn", "sf", "xf", "dq", "db", "d", "raf", "dc"], "date": ["work", "x", "pre", "created", "form", "message", "create", "style", "ate", "days", "re", "output", "str", "out", "fee", "sync", "day", "update", "back", "use", "ale", "input", "dates", "complete", "atom", "data", "m", "updated", "year", "module", "format", "open", "age", "valid", "url", "name", "log", "stage", "pe", "modified", "dt", "code", "ge", "dat", "time", "min", "j", "string", "tag", "dose", "rule", "Date", "D", "value", " Date", "version", "bug", "custom", "diff", "type", "db", "d"], "zipFile": ["sqlModel", "ZipFile", "zipfile", "ressFile", "Zipfile", "ressfile", "zipFiles", "zipSection", "zFiles", "ressModel", " zipFiles", "zipModel", " zipfile", "zFile", "ZipFiles", "zfile", "zModel", "zSection", "ZipEntry", "ressSection", "zipEntry", "sqlFile", "sqlfile", "sqlSection", " zipEntry", "zEntry"], "zos": ["ls", "closure", "dos", "hess", "bos", "z", "chini", "obb", "iffs", "zer", "zl", "gz", "zik", "tz", "robe", "han", "zona", "nz", "cash", "zy", "zb", "proxy", "zzy", "bitcoin", "eros", "ros", "zero", "ses", " sands", "os", "cos", "los", "ZA", "inos", "dylib", "zip", "fits", "zo", "address", "webkit", "uz", "zag", "budget", "zes", "zh", "zn", "exit", "las", "liquid", "rez", "outs", "settings", "zen", "kos", "lins", "ils", "css", "ozo", "zan", "ssl", "asio", "her", "osi", "zi", "zx", "jas", "nox", "js", "forge", "zon", "zar", "bes", "ops"], "fis": ["lids", "rafris", "fliss", "infias", "flids", "fiz", "infiss", "Fiss", "fiss", "lias", "rafis", "rafias", "flias", "flis", " fits", "flris", "vils", "bos", " fiss", "rafiss", " fiz", " fos", "biss", "bisl", "fris", "fisl", "fias", "infits", "Fos", "Fias", "lis", "liss", "Fis", "infis", " fils", "vits", "Fris", "fits", "fils", "vis", "Fisl", "Fisp", " fias", " fisp", "fisp", "infiz", "infils", "fos", " fisl", "flisp", "fids", "bis", "infids", " fris", "viz"], "entry": [" Entry", "style", "the", "uri", "se", "ace", "so", "z", "ry", "cell", "ion", "Entry", "info", "archive", "event", "extra", "e", "ie", "per", "de", "card", "image", "cel", "or", "data", "record", "array", "comment", "and", "next", "si", "ries", "lc", "add", "it", "server", "obj", "ui", "zip", "ge", "address", "term", "letter", "index", "zo", "exp", "element", "auto", "row", "r", "feed", "key", "her", "reader", "offset"], "buffer": ["vector", "sequence", "position", "shape", "cache", "result", "length", "available", "memory", "pad", "buff", "bb", "buf", "page", "seed", "bytes", "uffer", "padding", "border", "FFER", "data", "writer", "binary", "comment", "b", "device", "null", "server", "transfer", "number", "address", "Buffer", "beta", "header", "channel", "queue", "layer", "batch", "reference", "iter", "row", "wave", "feed", "slice", "reader", "flush"], "readed": ["inputED", " ReadED", "inputled", "inted", "intED", "textized", "readled", "textED", "readended", " readable", "readned", " Readed", " Readered", "readable", "bootered", "inputned", " readered", " readED", "bootable", "textended", "inputed", " readended", "texted", " Readned", " Readable", "intended", " readized", "readED", " Readled", " readled", "readered", "readized", "bootED", " readned", "booted", "intized"]}}
{"id1": "11968328", "id2": "17158020", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA32", "getMD32", " getCD5", "getSHA512", " getMD53", " getSHA5", " getCD32", " getMD32", " getSHA53", " getMC32", " getMC512", " getMC53", " getCD53", "getMD512", "getSHA53", " getCD512", " getMD512", " getSHA32", " getSHA512", "getSHA5", " getMC5", "getMD53"], "_pwd": ["_npass", "_sword", "_nwn", "_nWD", "_swd", "_dpass", "_sWD", "_Pword", "_pwn", "_dwd", "_Ppass", "_pWD", "_Pwn", "_nwd", "_spass", "_dword", "_dWD", "_pword", "_ppass", "_PWD", "_Pwd"], "md": ["mand", "mm", "mp", "amd", "wd", "dig", "cmd", "dm", "po", "mb", "meta", "mg", "ind", "m", "nm", "pg", "metadata", "mad", "ad", "mac", "bf", "editor", "rm", "sm", "vd", "um", "kg", "pd", "sha", " MD", "gb", "od", "dd", "mo", "mt", "hd", "cd", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "db", "d", "bd"]}}
{"id1": "7757297", "id2": "7981642", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["form", "init", " submission", "update", "download", "success", "input", "send", "complete", "process", "close", "open", "accept", "execute", "report", "post", "sub", "write", "save", "request", "register", "login", "apply", "type", "start", "run", "Submit"], "uri": ["text", "source", "message", "filename", "absolute", "path", "username", "Url", " ur", "i", " URI", "xml", "data", "duration", "location", "resource", "format", "description", "directory", "io", "database", "base", "server", "URL", "ui", "address", "api", "iri", " Uri", "string", "plugin", "file", "route", "cli", "href", "response", "URI", "id", "ri", "report", "http"], "Exception": ["Ex", "Exit", "Error", "Connection", "Adapter", "Exc", "Description", "Interface", "Timeout", "Transaction", "Record", "Except", "Problem", "End", "Response", "Null", "A", "Document", "Event", "Application", "ceptions", " exception", "ception", "Request", "except"], "encodedrdf": ["encodedudrf", "encodedwdF", "encodingrdf", "encodedrrf", "encodedrre", "encodingrdbf", "encodedrdbf", "encodedrdrf", "encodedvrf", "encodedwde", "encoderdef", "encodeudrf", "encoderdrf", "encodedrrrf", "encodingrdrf", "encoderdf", "encodedvrrf", "encodedudef", "encodedwdef", "encodingwdbf", "encodingrdF", "encodingwdrf", "encodedrdef", "encodeudf", "encodedrde", "encodedrdF", "encodedudf", "encodedwdrf", "encodingwdF", "encodedrtf", "encodedrtF", "encodedvrF", "encoderde", "encodedude", "encodedwdbf", "encodingwdf", "encodedrtrf", "encodeude", "encodedwdf", "encodedrtbf", "encodeudef", "encodedrref", "encodedvrbf"], "url": ["text", "source", "contact", "relation", "position", "client", "path", "session", "Url", "config", "Connection", "use", "page", "link", "control", "l", "socket", "conn", "image", "loc", "service", "proxy", "open", "location", "resource", "connect", "base", "name", "job", "database", "server", "URL", "address", "string", "channel", "file", "ssl", "user", "http"], "connection": ["text", "source", "contact", "org", "relation", "position", "client", "connected", "session", "c", "config", " Connection", "Connection", "http", "use", "link", "driver", "l", "socket", "conn", "or", "loc", "condition", "writer", "con", "in", "service", "proxy", "open", "communication", "n", "directory", "connect", "document", "database", "character", "io", "b", "server", "URL", "password", "function", "number", "string", "channel", "handler", "version", "response", "section", "context", "application"], "lastUser": ["lastWord", "latestWord", "latestRow", " lastCategory", "LastCategory", "latestCategory", "LastUser", "lastRow", " lastRow", "LastWord", "latestUser", "LastRow", "lastCategory", " lastWord"], "out": ["init", "cache", "at", "extra", "w", "image", "global", "down", "builder", "comment", "name", "log", "pool", "write", "wrapper", "off", "temp", "key", "flush", "error", "result", "copy", "sync", "client", "check", "view", "word", "dump", "OUT", "conn", "data", "writer", "req", "io", "up", "obj", "password", "outs", "cli", "user", "plain", "bin", "call", "output", "socket", "line", "editor", "outer", "exp", "external", "prefix", "Out", "office", "login", "o", "doc", "no", "inner", "page", "cmd", "in", "window", "server", "exec", "list", "lock", "full", "again", "file", "part", "err", "commit"]}}
{"id1": "15799935", "id2": "536614", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAttachmentPart", "saveAttPartbody", "saveAttachedBody", "saveAppachmentBody", "saveAppensionPart", "saveAppachmentFile", "saveAttensionbody", "saveAttachmentFile", "saveAttPartPart", "saveAttachedbody", "saveAttensionPart", "saveAppachmentPart", "saveAppensionBody", "saveAttachedPart", "saveAppensionbody", "saveAppensionFile", "saveAttPartFile", "saveAttPartBody", "saveAttachmentbody", "saveAppachmentbody", "saveAttensionBody", "saveAttensionFile"], "context": ["text", "contact", "message", "concept", "media", "cache", "current", "client", "cf", "translation", "c", "config", "front", "system", "environment", "kernel", "state", "component", "event", "view", "driver", "processor", "content", "input", "ca", "manager", "project", "Context", "present", "definition", "service", "resource", "ce", "document", "subject", "host", "center", "container", "connection", "channel", "queue", "coll", "cca", "collection", "mc", "request", "version", "template", "community", "support", "reader", "ctx", "parent", "network", "cms"], "part": ["p", "pre", "source", "message", "parts", " Part", "app", "position", "media", "pod", "translation", "point", "component", "place", "state", "event", "per", " parts", "po", "area", "to", "image", "or", "PART", "object", "from", "service", "comment", "base", "name", "phase", "chapter", "body", "upload", "connection", "patch", "channel", "section", "mission", "plan", "block", "html", "Part", "file", "Parts", "partial", "art", "type", "parent", "start"], "localAttachment": [" localAttachachment", "LocalAttention", " localAttment", "localAddachment", "localExtacher", "localAttachacement", " localAttacement", " localExtacement", " localExtacher", " localAttrollment", "localAssachment", "localInstension", "localAttension", " localPartention", " localAttension", "LocalAttachment", "localAssail", "LocalAttail", "LocalAssachment", "localattment", "localattention", "localAvachment", "localArtail", "localAddail", "localPartachment", " localPartension", " localAttribution", "localAvention", "localAddention", "localAvacher", "localattrollment", "localArtment", "localAttment", "localAttachachment", "localInstachment", "localAttacher", " localExtachment", "localAttachension", "localAddment", " localPartachment", "localAttachribution", " localAttachrollment", "LocalAssment", "localPartention", "localAssment", "localInstention", "localPartension", " localAttacher", " localPartribution", "localAttribution", "localAttacement", "localArtention", "localAvacement", "localInstribution", "localAttention", "localAttachention", "LocalAssail", "localAddrollment", "LocalAssention", "localattachment", "localAttachrollment", "localAssention", "localAttachacher", "localAttrollment", " localExtention", "localExtention", "localPartribution", " localAttention", "localAttail", "LocalAttment", "localExtachment", " localAttachention", "localArtachment", "localExtacement"], "accountId": ["jobid", "AccountID", " accountName", "appID", " accountid", "accId", "appId", "jobId", " accountInfo", "accInfo", "contactid", "accountInfo", " accountID", "accid", "AccountId", "feedid", "contractName", "Accountid", "accID", "appid", "appInfo", "AccountName", "contractid", "contactName", "feedID", "accountName", "accountID", "contractId", "feedName", "feedId", "jobID", "jobName", "contactId", "accountid"], "attachmentId": ["attociationReference", "atociationID", "extachmentID", "adentionID", "attentionSource", "attachmentReference", "attachedId", "attmentReference", "addentionID", "addentionUrl", "attachmentIndex", "attociationId", "atachmentReference", "adachmentID", "attachmentName", "extensionSource", "atachmentId", "attmentID", "attentionIndex", "attensionSource", "attachedUrl", "extensionid", "attociationID", "attentionUrl", "attentionId", "adachmentIndex", "attptionIndex", "attentionid", "addachmentId", "atachmentID", "attlementId", "attlementReference", "attmissionId", "atociationId", "attmissionID", "extachmentSource", "addachmentType", "attentionInfo", "addentionId", "attptionInfo", "attociationUrl", "attlementID", "attmissionSource", "attptionId", "addentionType", "attlementName", "attociationType", "attachmentUrl", "extensionId", "attensionID", "attptionID", "attentionID", "attmentId", "attensionid", "attmentName", "adachmentId", "adentionIndex", "attentionType", "adentionId", "attachmentInfo", "attagramIndex", "addachmentID", "extensionID", "attachmentSource", "attachmentid", "extachmentId", "extachmentid", "attensionId", "attagramInfo", "adentionInfo", "atachmentName", "attmissionid", "atociationReference", "attachmentID", "atociationName", "attagramId", "attachmentType", "adachmentInfo", "attachedType", "attociationName", "addachmentUrl", "attachedID", "attagramID"], "in": ["p", "source", "as", "init", "copy", "gin", "inn", "pin", "inner", "ac", "load", "f", "info", "plus", "pass", "i", "input", "socket", "inside", "image", "conn", "or", "IN", "data", "ini", "con", "up", "a", "url", "din", "it", "is", "nin", "ins", "cin", "In", "inc", "again", "file", "pull", "err", "login", "slice", "id", "reader", "bin"], "saveIn": ["SaveAs", "savOut", "writeOut", " saveOut", "aveAs", "stageIns", "saveIN", "aveOut", "stageOut", "SaveIns", "savein", "SaveOut", "savIn", "writeIn", " saveIN", "saveOut", "savin", "avein", "stageIn", "saveIns", "aveIn", "writein", " saveIns", " savein", "stageAs", "savAs", "writeIN", "aveIN", "SaveIn"], "saveAs": ["SaveAs", "openAS", "saveAS", "writeOut", " saveOut", "copyas", "copyAS", "saveFile", "writeAs", "writeAS", "createFile", "SaveAS", "saveas", " saveAS", "SaveOut", "copyIn", "writeIn", "openAt", "openFile", "createAs", "saveOut", "saveAt", " saveFile", "createAt", "openAs", " saveas", " saveAt", "Saveas", "createAS", "copyAs", "SaveIn"], "out": ["flow", "source", "as", "init", "copy", "cache", "output", "client", "sync", "path", "inner", "c", "at", "s", "this", "page", "plus", "ex", "to", "OUT", "conn", "line", "image", "default", "data", "writer", "other", "up", "io", "a", "name", "null", "outer", "ext", "exec", "string", "Out", "outs", "inc", "again", "off", "file", "temp", "err", "o", "v", "bin"], "copySize": ["copyAddress", "lesize", "copyTime", "CopyTime", "openSize", "leLength", "bytesize", "saveSize", "opensize", "byteTime", "leSize", " copyLength", "openSIZE", " copyAddress", "leSIZE", "byteSize", "saveAddress", "copysize", "copySIZE", "Copysize", "saveLength", "byteLength", "byteAddress", " copysize", "openLength", " copyTime", "savesize", "copyLength", "CopyLength", " copySIZE", "CopySize"], "contentUriString": ["contentIrisStr", "contentUiniByte", "contentUrisStr", "contentUrisstring", "contentIriByte", "contentUriByte", "contentUpiInt", "contentUiNumber", "contentIrisstring", "contentUuriString", "contentUristring", "contentUrisString", "contentUioStr", "contentUrisInt", "contentUioString", "contentIriString", "contentUridStr", "contentUioInt", "contentIrisInt", "contentIriNumber", "contentIrisUnit", "contentIiByte", "contentIristring", "contentUridString", "contentUriNumber", "contentUriStr", "contentUpiStr", "contentIriInt", "contentUuriByte", "contentUuriNumber", "contentIiString", "contentUrisUnit", "contentUriUnit", "contentIrisString", "contentUuriStr", "contentIriUnit", "contentUriInt", "contentUiniString", "contentIiNumber", "contentIriStr", "contentIiStr", "contentUiStr", "contentUiByte", "contentUpiString", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUiostring", "contentUiUnit", "contentUpistring", "contentUiString"], "mSize": ["cCount", "cName", "pCount", "iLength", "iName", "iSize", "pSize", "mCount", "mLength", "mName", "pLength", "cLength", "iCount", "cSize", "pName"], "mContentUri": ["mContentUric", "mContentOUri", "mContentIric", "mResourceUri", "mResourceUris", "mContentUrric", "mContentIci", "mResourceIris", "mContentUrris", "mContentUris", "mContentOUci", "mResourceIci", "mContentIri", "mContentIris", "mResourceIric", "mResourceIri", "mContentUrri", "mContentUci", "mResourceUci", "mContentOUris", "mContentOUric", "mContentUrci", "mResourceUric"], "cv": ["uv", "cs", "xc", "fp", "uc", "cf", "ctrl", "nv", "cover", "csv", "c", "buf", "CV", "ov", "vr", "pb", "ca", "keep", "loc", "vp", "iq", "vs", "GV", "core", "bc", "av", "conv", "lc", "vm", "iv", "um", "cr", "sc", "rc", "cc", "nc", "VC", "cp", "enc", "cm", "coll", "auc", "fc", "cd", "cu", "lv", "vc", "mc", "cap", "que", "vv", "sv", "ctx", "v", "cb", "co", "content"], "uri": ["uni", "uid", "path", "username", "point", " ur", "environment", "i", " URI", "ci", "data", "resource", "proxy", "format", "location", "metadata", "storage", "url", "base", " url", "iv", "ui", "query", "address", "api", "pi", "iri", " Uri", " scheme", "string", "gb", "mi", "prefix", "oid", "qi", "range", "universal", "attribute", "route", "cli", "href", "URI", "id", "ri", "http"]}}
{"id1": "3745402", "id2": "17083703", "code1": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createCipher": [" createScrypt", "createcSecret", " createCSecret", "createScrypt", "createIntegursor", "createcursor", "createScSecret", "createCSecret", "createIntegipher", " createCursor", "createScursor", "createIntegSecret", " createScursor", "createScipher", "createcrypt", "createCursor", " createCrypt", "createIntegrypt", " createScipher", "createcipher", " createScSecret", "createCrypt"], "passwd": ["Passphrase", "passwordphrase", " passpassword", "passphrase", " passphrase", "Passpassword", "passwordpassword", "PassWD", "passwordword", "failwd", "password", " password", " passWD", "Passwd", "passpassword", "Password", "passWD", "passwordwd", "failpassword", "failword", "failWD"], "mode": ["source", "message", "method", "mask", "role", "depth", "mm", "path", "language", "mod", "domain", "seed", "slave", "MODE", "phrase", "level", "cmd", "driver", "command", "manager", "module", "mac", "core", "phase", "name", "server", "code", "password", "address", "delay", "time", "Mode", "direction", "prefix", "range", "version", "slice", "dir", "type"], "keySpec": ["signspec", "keyCS", " keyCS", "secretCS", "KeySpec", "secretFactory", "keySet", "Keyspec", "keyConfig", "KeyFactory", "secretSet", "signSpec", "keyspec", "signConfig", " keyspec", "secretSpec", "KeyConfig", "KeySet", " keyConfig", "KeyCS", " keySet"], "keyFactory": ["KeySpec", "kService", "secretFactory", "keyFamily", "kSpec", "keyService", "KeyFactory", "KeyFamily", "secretService", " keyService", "kFamily", " keyFamily", "secretSpec", "kFactory", "KeyService"], "key": ["p", "text", "secret", "source", "message", "cache", "c", "keys", "config", " secret", "hash", "state", "seed", "pass", "phrase", "k", "data", "cert", "ce", "mac", "pub", "ke", "core", "base", "name", "pe", "code", "password", "ki", "sk", "enc", "sum", "file", "temp", "sign", "ssl", "KEY", "id", "type", "user", "Key", "pair"], "md": ["mand", "message", "mm", "mp", "amd", "f", "dig", "cmd", "dm", "mb", "meta", "material", "m", "ad", "metadata", "mac", "sm", "vd", "msg", "sha", "dr", " MD", "dd", "cm", "mt", "hd", "cd", "MD", "dh", "mc", "ma", "df", "mag", "pm", "db", "d", "bd", "dc"], "digest": ["digeter", "signeter", "Digester", "mdested", "DigEST", "demester", " digeter", "digEST", "digested", " digend", "mdester", "mdend", "digend", "signested", "demested", " digEST", "signester", "mdEST", "Digest", " digested", "Digested", "mdest", "digester", "Digend", " digester", "signest", "demest", "demeter"], "salt": ["sodium", "psort", "sipher", " sodium", "isALT", "sesALT", " sort", "secretipher", "sesalt", "sesodium", "secretalt", "dsALT", "psodium", "secretsecret", "ssALT", "secretALT", "Sodium", "ssipher", "dsort", "isSalt", "dsodium", "SALT", "isodium", "Salt", "dsalt", "sssecret", "sALT", "sort", "sSalt", "psALT", "Sipher", " sALT", "SSalt", "ssecret", "psalt", "Ssecret", "ssalt", "isalt", "sesSalt"], "i": ["p", "x", "init", "uri", "z", "c", "f", "at", "s", "ii", "info", "ai", "gi", "ix", "e", "l", "I", "k", "ci", "uli", "ind", "m", "in", "ip", "n", "bi", "si", "u", "b", "ti", "it", "ui", "pi", "oi", "index", "j", "li", "hi", "di", "qi", "y", "xi", "t", "mu", "id", "o", "v", "ri", "d"], "paramSpec": ["ParamConfig", "paramCS", "paramsSpec", "paramConfig", "parspec", "Paramspec", "paramspec", "parConfig", "aramConfig", "paramSel", "paramsspec", "aramSpe", " paramConfig", " parameterSpe", "paramsCS", " paramSel", "paramSpe", " parameterSel", "parSpec", "ParamSpec", "parCS", "paramsConfig", "aramSpec", " paramSpe", " parameterConfig", "ParamCS", "aramSel", " parameterSpec"], "cipher": ["Cistor", "coursor", " coder", "Crypt", "encipher", "couster", " cursor", "encistor", "coipher", "cairo", "encairo", "corypt", "Cipher", "pistor", "encoder", "prypt", " cairo", "conrypt", "cistor", "pipher", "coder", "encursor", "conuster", "Cairo", "Coder", "encrypt", "crypt", "encuster", "cursor", "conursor", "conipher", "pairo", "custer", "Cursor"]}}
{"id1": "17161805", "id2": "21016435", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "label": 0, "substitutes": {"encode": ["enode", "enscode", "encod", "ensoder", "ensode", "enccode", "enccod", "encoder", "Enoder", "Encode", "reode", "reoding", "recode", "Encod", "enoding", "enoder", "recod", "enscod", "encoding", "Enode", "Enoding"], "plaintext": ["longform", "bodytext", " plaincontent", " plainText", "plainstring", "plainform", "plainTEXT", "foretext", "foreTEXT", " plainstring", "longcontent", "foreText", "bodyform", "bodyText", "forestring", "plaincontent", "plainText", "batText", "battext", "batstring", "longText", "batTEXT", " plainform", "longtext", " plainTEXT", "bodycontent"], "md": ["me", "mand", "mm", "mp", "mod", "amd", "f", "wd", "cmd", "dm", "po", "mb", "meta", "ind", "m", "metadata", "ad", "mad", "mac", "grad", "rm", "sm", "ms", "um", "code", "pd", "sha", "gd", " MD", "od", "di", "dd", "hd", "cd", "MD", "dh", "mc", "ma", "df", "mag", "pm", "d", "rpm", "bd"], "raw": ["local", "remote", "buffer", "ode", "out", "dec", "clean", "load", "instance", "rew", "all", "unsigned", "ghost", "input", "shared", "Raw", "unknown", "binary", "missing", "internal", "original", "array", "initial", " hex", "hex", "ack", "alpha", "enc", "stream", " Raw", "micro", "block", "serial", "orig", "pure", "row", "custom", "pack", "feed", "blocks", "RAW"]}}
{"id1": "6871529", "id2": "12106167", "code1": "    private boolean readUrlFile(String fullUrl, PrintWriter out) {\n        try {\n            URL url = new URL(fullUrl);\n            String encoding = \"gbk\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding));\n            return fileEditor.pushStream(out, in, fullUrl, false);\n        } catch (Exception e) {\n        }\n        return false;\n    }\n", "code2": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "label": 0, "substitutes": {"readUrlFile": ["readFileFiles", "openUrlStream", "openUrlFile", "readURLFiles", "readURLFile", "readFilefile", "readurlFiles", "openURLfile", "openUrlFiles", "readURLStream", "readFileFile", "openURLFiles", "openURLFile", "openUrlfile", "readURLfile", "readUrlStream", "readurlStream", "readurlFile", "openURLStream", "readUrlfile", "readUrlFiles", "readFileStream", "readurlfile"], "fullUrl": ["completeUr", " fullUr", "completeURL", "rawURL", " fullPath", "shorturl", "FullPath", " fullurl", "FullUrl", "rawurl", "FullUr", "shortUrl", "rawUrl", "rawPage", "fullURL", "completePage", "Fullurl", "fullurl", "fullPath", "fullPage", "shortURL", "completeUrl", "shortPath", "fullUr", "FullURL", "completeurl", " fullURL", "FullPage", " fullPage"], "out": ["source", "filename", "buffer", "result", "cache", "output", "client", "inner", "w", "i", "OUT", "image", "line", "IN", "data", "writer", "resource", "io", "log", "name", "server", "obj", "string", "connection", "Out", "write", "raw", "outs", "inc", "again", "file", "temp", "parent", "err", "login", "o", "reader", "user", "flush", "bin", "report", "content"], "url": ["ls", "source", "buffer", "uri", "browser", "Url", "f", "bb", "ball", "page", "l", "image", "blog", "web", "service", "resource", "open", "www", "up", "io", "base", "log", "bel", "b", "server", "URL", "rl", "zip", "sl", "string", "connection", "stream", "ll", "file", "ssl", "feed", "user", "xml", "http"], "encoding": ["Encoding", "encoded", "enaching", "encode", "Encasing", "casing", "encoder", "Encoded", "Encode", "coding", "coder", "enoded", "caching", "code", "enoding", "encaching", " encode", "Encaching", " encoder", " encasing", "enasing", "Encoder", "encasing", "coded"], "in": ["source", "rec", "inn", "str", "client", "inner", "c", "f", "s", "i", "input", "serv", "IN", "data", "con", "ini", "win", "resource", "n", "io", "bin", "a", "b", "nin", "body", "ins", "connection", "stream", "In", "inc", "rin", "file", "part", "r", "err", "login", "reader", "din", "xml", "doc"]}}
{"id1": "10451698", "id2": "20310134", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "create", "remote", "sync", "py", "paste", "load", "update", "download", "cat", "archive", "dump", "move", "drop", "process", "cop", "clone", "rm", "clip", "share", "change", "transfer", "split", "zip", "Copy", "list", "lock", "cp", "write", "replace", "file", "parent", "part", "ignore", "ssh", "type", "get", "delete", "run"], "source": ["filename", "result", "flat", "cache", "current", "client", "remote", "path", "config", "info", "model", "view", "seed", "slave", "use", "plus", "root", "ie", "ource", "src", "project", "SOURCE", "image", "data", "Source", "service", "object", "from", "resource", "ce", "proxy", "folder", "storage", "directory", "class", "document", "url", "name", "null", "server", "secure", "string", "scope", "connection", "section", "stream", "iter", "file", "slice", "sf", "reader", "site", "unit", "parent", "start", "archive", "target"], "destinationDirectory": ["destificationDir", "destributionPath", "destributionHome", "destinationFile", "DestributionDirectory", "DestributionDir", "DestinationPoint", "DestinationDirectory", "destarationDirectory", "destructionDir", " destinationsFolder", "DestinationPath", "destinationPath", "DestinationHome", "DestinationFolder", "destinationsFile", "destinationsDirectory", "destificationHome", "DestributionPath", "destippingHome", "destructionFile", "destributionDir", "destinatorPath", "destinationDir", "destinatorPoint", "destributionFile", "destarationPoint", "DestributionHome", " destinationsDirectory", "destippingFolder", "destificationFolder", " destinationFolder", " destinationsFile", "destarationPath", "DestinationDir", "destributionDirectory", "destinationFolder", " destinationFile", "destructionFolder", "destinationsFolder", "destippingDirectory", "destructionDirectory", "destinatorDirectory", "DestributionPoint", "destinationsDir", "destributionFolder", "DestributionFolder", " destinationDir", "destificationDirectory", " destinationsDir", "destippingDir", "destributionPoint", "destinationPoint", "destinationHome"], "newDir": ["newFolder", " newdir", "NewFolder", " newFolder", "nextDirectory", "nextDir", "nextFolder", "nextdir", "NewDirectory", " newDirectory", "nextFile", "NewFile", "newDirectory", "newdir", "Newdir", "NewDir"], "children": ["ren", "tests", "ums", "rules", "filename", " Children", "words", "uc", "current", "father", "kids", "iblings", "scenes", "Children", "ools", "balls", "projects", "loc", "data", "names", "web", "parents", "other", "which", "opens", "values", "url", "roots", "iv", "files", "sub", "members", "child", "each", "ins", "list", "pages", "blocks", "begin", "ul", "sort", "collection", "mount", "when", "items", "pes", "parent", "events", "packages", "rows", "content"], "i": ["p", "x", "uri", "inner", "ai", "f", "gi", "ii", "info", "ori", "ix", "e", "ie", "I", "k", "ci", "m", "ini", "in", "q", "multi", "ip", "iu", "n", "io", "si", "u", "b", "ti", "it", "iv", "lc", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "mi", "di", "qi", "y", "xi", "part", "fi", "key", "slice", "mu", "o", "id", "end", "type", "v", "start", "ri", "d"], "newFile": ["newSource", " newSourceFile", "oldFile", "Newfile", "createFile", "nextfile", "oldDirectory", "newfile", "nextSourceFile", "createfile", "nextSource", " newFiles", "newFiles", "oldDir", "nextDir", "NewFiles", " newfile", "NewDirectory", " newDirectory", "NewSource", "createDir", "nextFile", "createSource", "newSourceFile", "NewSourceFile", "NewFile", "newDirectory", "nextFiles", "oldFiles", "NewDir"], "output": ["flow", "result", "current", "out", "generated", "generation", "update", "config", "kernel", "page", "four", "console", "control", "socket", "image", "complete", "writer", "web", "service", "object", "resource", "other", "binary", "core", "display", "ou", "outer", "change", "operation", "address", "connection", "external", "option", "write", "again", "Output", "put", "file", "temp", "ilo", "response", "o", "unit", "after", "parent", "oper", "error", "target", "application"], "input": ["flow", "work", "text", "form", "buffer", "current", "out", "client", "inner", "instance", "config", "before", "this", "plus", "Input", "socket", "keep", "image", "data", "in", "resource", "storage", "self", "operator", "print", "ink", "inf", "exec", "child", "index", "ack", "connection", "stream", "raw", "temp", "request", "pull", "feed", "reader", "parent", "inc", "error", "audio", "context", "http"], "buff": ["text", "char", "buffer", "shape", "uf", "length", "cf", "hello", "load", "f", "bb", "pad", "fb", "gz", "buf", "info", "back", "cmd", "txt", "count", "ff", "cast", "data", "ph", "comment", "b", "bound", "fe", "oct", "rb", "cur", "gb", "comb", "uff", "cp", "batch", "cod", "bug", "feed", "slice", "pack", "ob", "boot", "Buff", "bind", "flush", "bin", "cb"], "read": ["text", "x", "seek", "buffer", "se", "Read", "sync", "length", "reading", "check", "parse", "load", "ask", "f", "config", "lex", "len", "use", "pass", "READ", "send", "skip", "k", "count", "ind", "readable", "get", "close", "open", "play", "find", "io", "ip", "n", "and", "ink", "next", " load", "b", " write", "add", "allow", "transfer", "exec", "reads", "index", "size", "write", "en", "iter", "wait", "ok", "loop", "feed", "slice", " count", "end", "id", "type", "reader", "start", "rate", "select", "fill", "run"]}}
{"id1": "11032546", "id2": "20924119", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": ["testcopyUnknownsize", "testCopyunknownsize", "testCopyunknownSize", "testcopyUnknownSize", "testCopyUnknownsize", "testcopyunknownSize", "testCopyKnownsize", "testcopyunknownsize", "testCopyKnownSize"], "in": ["source", "as", "inn", "inner", "c", "at", "info", "this", "i", "input", "src", "inside", "image", "conn", "IN", "data", "m", "up", "n", "io", "a", "url", "din", "b", "is", "exec", "nin", "min", "ins", "connection", "In", "inc", "r", "err", "id", "reader", "bin"], "out": ["work", "buffer", "copy", "cache", "output", "sync", "client", "path", "at", "with", "extra", "plus", "ex", "one", "input", "to", "OUT", "conn", "image", "data", "io", "up", "bin", "next", "base", "name", "array", "ext", "exec", "pool", "post", "obj", "append", "size", "prefix", "Out", "auto", "outs", "again", "off", "file", "temp", "o", "user", "parent", "inc", "error", "target"], "cpySize": ["CpyLength", " cpeSize", "CpeCount", "cpeLength", "czipArray", "cpiMode", "CpySize", "cpeMode", "czipMode", "cpyLength", "cpyArray", "cpeSize", " cpyLength", " cpeLength", "cciLength", "cPyCount", " cpeMode", "cpiSize", "cpeCount", "CpeSize", "cpyMode", " cpeArray", "cpyCount", "cPySize", "CpeLength", "CpyCount", "cpiArray", "czipLength", "cciCount", " cpyMode", " cpyArray", "cpeArray", "cpiLength", "cPyLength", "czipSize", "cciSize"], "outArray": ["outList", "inSize", "viewAmount", " outSize", " outList", "targetBuffer", "outputArray", "outBuffer", "outMemory", "targetMemory", " outMemory", "outputBuffer", "viewSize", "viewBuffer", "outputList", "targetArray", "outAmount", "inBuffer", "viewArray", " outAmount", "inAmount", "inArray", "outputMemory", " outBuffer", "targetList", "outSize"]}}
{"id1": "23532405", "id2": "16719805", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"persist": ["Persister", "Persistence", "persister", "plist", "plister", "persistence", " Persists", " Persistence", "Persist", "plists", " Persist", "persists", " Persister", "plistence", "Persists"], "ffConfigurable": ["effConfural", "uffLogurable", "ffconfigurred", "effConfigurable", "ffConfiguring", "ffPlur", "ffConfured", "ffConfurred", "ffPlurable", "ffFure", "effConfigural", "ffSegural", "ffGurable", "ffLoguring", "ffConfigure", "ffLogural", "ffSegurer", "ffConfur", "uffConfiguring", "ffConfigurer", "FFConfigurer", "uffLogure", "ffFured", "ffLogurer", "FFConfurred", "ffconfigurable", "effConfigured", "uffLogured", "ffGuring", "ffFuring", "ffConfigured", "ffPluring", "FFConfurer", "ffConfigur", "FFConfigurable", "ffPlurer", "uffConfigure", "ffLogurable", "FFConfigural", "ffConfurable", "ffconfigurer", "ffConfigural", "effConfurer", "ffSegured", "uffConfigurable", "uffConfigured", "FFConfur", "ffSegurable", "effConfigurer", "FFConfurable", "FFConfigur", "ffLogure", "FFConfural", "ffGurer", "effConfured", "ffConfure", "ffConfurer", "ffLogured", "ffSegurred", "FFConfuring", "FFConfigurred", "ffConfigurred", "ffGur", "uffLoguring", "ffconfigural", "ffConfuring", "ffConfural", "ffFurable", "FFConfiguring", "effConfurable"], "relativePath": ["relativeName", "protectedFile", " relativePoint", "absolutePath", " relativeName", "relativeLocation", "absoluteName", " relativeFile", "protectedPath", "ativePath", "ativeName", "ativeLocation", "relativeFile", "absoluteUrl", " relativepath", " relativeLocation", "protectedPoint", "ativeUrl", "absoluteLocation", "relativeUrl", " relativeUrl", "absolutePoint", "absolutepath", "absoluteFile", "relativePoint", "protectedpath", "relativepath"], "file": ["work", "source", "local", "form", "filename", "File", "fp", "cache", "out", "cf", "path", "config", "f", "store", "model", "use", "place", "ile", "il", "show", "e", "l", "image", "single", "data", "in", "folder", "object", "location", "module", "self", "io", "FILE", "directory", "class", "url", "base", "name", "log", "b", "pe", "it", "files", "fe", "zip", "stream", "handler", "el", "full", "php", "temp", "parent", "part", "dir", "sf", "unit", "le", "type", "get", " File", "db", "http"], "is": ["mis", "as", "ris", "ps", "was", "IS", "isa", "out", "us", "oss", "ai", "info", "ii", "iss", "i", "Is", "iso", "gets", "in", "does", "ir", "ws", "ip", "io", "si", "ms", "fs", "ui", "api", "isi", "ais", "ios", "ics", "es", "iris", "nis", "bis"], "os": ["OS", "as", "oss", "us", "bos", "ips", "uns", "oes", "s", "ori", "ens", "iso", "ol", "rs", "oa", "io", "ms", "oS", "cos", "los", "ou", "ies", "fs", "oid", "oos", "ais", "ios", "aos", "outs", "ils", "ows", "obs", "Os", "o", "osi", " bos", "oses", "ops"]}}
{"id1": "4852691", "id2": "19608872", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 0, "substitutes": {"hash": ["text", "copy", "str", "check", "update", "component", "dig", "dump", "build", "read", "print", " fingerprint", "log", "add", "SHA", "Hash", "code", "password", " Hash", "h", "string", "sum", "pack", " hashes", " hashing", "get"], "data": ["p", "text", "source", "message", "result", "buffer", "video", "media", "output", "json", "str", "length", "DATA", "memory", "info", "s", "bytes", "input", "dump", "image", "padding", "format", "binary", "storage", "a", "base", "database", "address", "hex", "dat", "body", "string", "connection", "key", "response", "reader", "audio", "content"], "digest": ["loger", "bigest", "Digit", "Digester", "Digests", "bigester", "DigEST", "digEST", "logest", " digests", "Digener", "bigger", "Diger", "bigEST", " digse", " digener", "logester", "Digger", "signger", "digger", " digger", "signEST", " digit", "logener", "digests", " digEST", "diger", "biger", "Digse", "signester", " diger", "Digest", "digit", "signests", "signer", "signse", "digener", "signit", "digester", "signest", " digester", "digse"]}}
{"id1": "2221297", "id2": "11952735", "code1": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"getURLContent": ["parseurlContents", "geturlBody", "geturlContent", "getPagecontent", "parseURLContent", "parseURLBody", "getURLContents", "getPageContent", "parseurlContent", "getStringcontent", "getURLcontent", "parseURLContents", "parseurlcontent", "getStringContent", "getURLBody", "geturlContents", "getPageBody", "getPageContents", "parseurlBody", "getStringContents", "getStringBody", "parseURLcontent", "geturlcontent"], "urlToSearchString": ["urltosearchSection", "urlTOFindSection", "urlToFindArray", "urlToFindSection", "urltosearchArray", "urlTosearchString", "urltoSearchSection", "urltoSearchStr", "urlTOSearchString", "urlToSearchStr", "urlTosearchStr", "urlTOSearchArray", "urlToSearchArray", "urlTOSearchSection", "urlToCreateString", "urlTOFindString", "urlTOFindStr", "urlToSearchSection", "urlTosearchArray", "urlToFindStr", "urlToCreateStr", "urltoSearchArray", "urlToCreateSection", "urlTOSearchStr", "urlTosearchSection", "urltosearchStr", "urlTOFindArray", "urltoSearchString", "urlToCreateArray", "urltosearchString", "urlToFindString"], "url": ["ls", "org", "uri", "str", "client", "Url", "cb", "c", "download", "f", "bb", "page", "l", "blog", "web", "resource", "open", "www", "base", "job", "log", "b", "lc", "server", "host", "URL", "rl", "zip", "sl", "ch", "cur", "connection", "ur", "ll", "file", "ssl", "db", "jar", "http"], "conn": ["client", "sync", "connected", "Config", "cb", "c", "config", "dc", "Connection", "nt", "socket", "Conn", "loc", "con", "auth", "open", "act", "n", "g", "connect", "io", "conv", "host", "exec", "conf", "ch", "api", "cur", "rc", "connection", "nc", "cp", "enc", "cn", "rt", "ssl", "err", "cli", "ct", "ctx", "db", "http"], "encoding": ["Encatin", " encoring", " encatin", "engoded", "Encoding", "noded", "encoded", "engcode", "acatin", "acoder", "encode", "locoding", "decoded", "enccode", "acoding", "encatin", "encoder", "enale", "Encoded", "decoring", "noder", "engoder", "enoded", "enoding", "noding", "loccode", "enoder", "locoded", "nale", "Encale", "encoring", "decoder", "engoring", " encoder", "decoding", " encoded", "engoding", "acoded", "Encoder", "locoder", "encale"], "br": ["ref", "bh", "ab", "result", "bridge", "arr", "bro", "str", "browser", "bar", "bb", "fb", "buf", "mr", "grab", "BR", "bl", "src", "Br", "sr", "img", "bc", "ber", "b", "hr", "cr", "ch", "cro", "sp", "rb", "db", "dr", "fr", "stream", "lr", "orb", "tr", "r", "err", "ob", "reader", "cb", "jar", "http"], "sb": ["ls", "lp", "bh", "ab", "xb", "SB", "cb", "obb", "bb", "fb", "buff", "lab", "bj", "sg", "pb", "src", "mb", " SB", "bp", "kb", "ib", "bot", "builder", "binary", "erb", "bf", "lb", "bps", "sa", "si", "bc", "bt", "b", "nb", "bs", "rb", "eb", "gb", "bm", "BB", "amb", "ruby", "sn", "bsp", "wb", "ssl", "sf", "ob", "db", "abb", "bd"], "line": ["text", "source", "lf", "char", "buffer", "Line", "lines", "str", "out", "cell", "c", "f", "len", "page", "link", "e", "i", "word", "l", "pos", "inline", "data", "comment", "n", "next", "base", "name", "character", "b", "lc", "code", "number", "sl", "letter", "body", "string", "cl", "LINE", "lin", "part", "row", "r", "response", "key", "err", "end", "reader", "feed", "content"]}}
{"id1": "3756429", "id2": "18164929", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"scramble": ["scroubler", " screambler", " screamble", " screambling", " screambles", "screamble", "screambling", " scrambling", "scambles", "screambles", "scrambling", "scrouble", "scrambles", "scroubles", "scrambler", "scamble", "screambler", " scrambler", "scambling", "scambler", "scroubling", " scrambles"], "text": ["source", "secret", "message", "buffer", "output", "str", "out", "token", "path", "username", "config", "texture", "bytes", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "binary", "editor", "class", "name", "ext", "Text", "code", "obj", "password", "letter", "body", "string", "struct", "test", "pattern", "content"], "md": ["mand", "hm", "mm", "mp", "mod", "amd", "f", "bb", "wd", "cmd", "dm", "mb", "ind", "m", "metadata", "mad", "ad", "mac", "grad", "rm", "sm", "vd", "ms", "um", "pd", "gd", " MD", "od", "di", "dd", "mn", "cm", "bm", "mt", "hd", " Md", "cd", "am", "MD", "dh", "mc", "df", "ma", "mag", "pm", "db", "d", "rpm", "bd"], "sb": ["ls", "bh", "su", "buffer", "ab", "sync", "xb", "SB", "cb", "obb", "bb", "fb", "s", "buf", "sg", "pb", "src", "mb", " SB", "bp", "kb", "ib", "erb", "binary", "bf", "lb", "sr", "sa", "bc", "bt", "usb", "nb", "bs", "rb", "eb", "gb", "bm", "BB", "bsp", "wb", "ssl", "sf", "ob", " eb", "db", "bd"], "b": ["p", "ab", "buffer", "br", "cb", "c", "f", "bb", "fb", "bytes", "i", "pb", "l", "mb", "B", "object", "bot", "binary", "bf", "be", "a", "base", "nb", "obj", "bs", "body", "eb", "rb", "beta", "machine", "orb", "block", "ob", "boot", "bis", "bin", "db", "d", "bd"]}}
{"id1": "8430178", "id2": "7545002", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFiles", "copyfile", "CopyFile", "copyFiles", "transferfile", "CopyPath", "transferFile", " copyPath", "copyPath", "transferPath", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "source_name": [" source_path", "sourceCalias", "Source_file", " source_names", "sourceNname", " source_key", "source_path", "src_name", " source_Name", "Source_data", "source_type", "sourceCname", "source_key", "Source_name", "src_size", "source_uri", "sourceNalias", "src_type", "src_uri", "source_alias", "sourceNfile", "source_size", "source_data", "sourceCtype", "sourceNtype", "source_names", "sourceCfile", "source_Name", "src_file", "src_alias"], "dest_name": [" dest_word", "dest_path", " destination_info", "dest_named", "Dest_id", "destFilename", " dest_file", "destRdefinition", " dest_named", " destination_path", "Dest_Name", " destinationFresource", " dest_label", "destappnames", "destPmodel", "source_path", "dest_word", "destflabel", "destJword", "destPname", " dest_definition", "destappname", "dest_names", "dest_resource", "destfname", " destinationFinfo", "destPpath", "target_names", "destFinfo", " destinationFpath", "destPtype", "dest_id", "destPName", "destPword", " dest_Name", "dest_file", "dest_model", " dest_names", "dest_none", "destRName", "destPnames", "destFilenamed", "Dest_path", " destination_resource", "destJname", "destRname", "destFresource", "target_type", "destRpath", " destination_name", "destFilelabel", "dest_definition", "source_names", "destJnames", " dest_path", "destFpath", "target_name", "dest_label", "Dest_name", "destFname", "source_Name", "dest_info", "destapptype", "destappmodel", "destFilefile", " dest_type", " dest_none", "destJName", "dest_type", "dest_Name", "destffile", " destinationFname", "target_model", "destfnamed"], "source_file": [" source_files", "source_File", "src_files", "src_name", "source_line", "source__base", "source_base", "source_files", "sourceffile", " source_cache", "source__name", "source__file", "source_class", "source__class", " source_url", "sourcefFile", "ource_file", "source_stream", " source_base", "src_stream", "ource_line", "sourcefname", " source_File", "ource_files", "source_url", "ource_name", " source_class", "src_file", "sourcefurl", "source_cache"], "destination_file": ["destination2file", "destation_file", "destination_function", "destination_name", "destention_name", "destination_files", "destation_name", "destination_path", "destinate_page", "destention4file", "destinate_base", "destation_function", "destention4name", "destination_page", "destination2name", "destention_source", "destinate_files", "destation_folder", "destention_file", "destention_path", "destinationablebase", "destination_folder", "destination2source", "destention4path", "destination4name", "destination_source", "destation_files", "destination4file", "destinate_file", "destinationablefile", "destinationablepage", "destination4source", "destention4source", "destinationablefiles", "destination_base", "destination4path", "destination2path"], "source": ["local", "remote", "result", "copy", "cache", "uri", "output", "client", "current", "inner", "load", "config", "ite", "view", "master", "slave", "via", "ources", "input", "ource", "src", "image", "single", "SOURCE", "resources", "get", "Source", "service", "object", "resource", "proxy", "from", "open", "storage", "dest", "core", "class", "name", "search", "spec", "server", "secure", "index", "connection", "scope", "stream", "ize", "reference", "file", "slice", "site", "reader", "unit", "diff", "parent", "start", "target"], "destination": ["Destribution", "coordination", "descension", "descinator", "destinated", "validinated", "destension", "foreigninator", "descination", "constinator", "testribution", "Destension", "constribution", "constining", "validinator", " destining", "Destinated", "coordinator", "testinated", "coordension", "dependination", "identina", "identribution", "Destina", "destinate", "validinate", "foreignination", "foreigninate", "variinated", "foreigninated", "destina", "targetination", "testinator", "coordinated", " destina", " destinator", "testination", " destinated", "Destining", "Destination", "targetinator", "dependinator", "constination", "destining", "destinator", "dependinated", "identinated", "variinator", " destribution", "identination", "targetinate", "destribution", "validination", "Destinator", "variinate", "variination", "dependinate", "descinated", "targetinated"], "buffer": ["sequence", "text", "cache", "memory", "buff", "buf", "timeout", "input", "uffer", "padding", "image", "writer", "binary", "limit", "window", "pool", "transfer", "Buffer", "header", "channel", "queue", "batch", "block", "iter", "temp", "reader", "flush", "bin"], "bytes_read": ["Bytes_Read", "Bytes_read", "bytesUnread", "bytesUnRead", "Bytes_set", "bytesUnset", "bytesUnfound", "bytes_set", "bytes_Read", "Bytes_found", "bytes_found"], "in": ["p", "as", "rec", "re", "current", "inn", "out", "token", "path", "session", "inner", "f", "s", "input", "l", "serv", "image", "line", "val", "read", "IN", "data", "get", "ini", "con", "resource", "or", "n", "a", "url", "log", "din", "b", "is", "fe", "nin", "min", "container", "ins", "h", "connection", "lock", "stream", "In", "inc", "again", "file", "temp", "request", "r", "ssl", "login", "id", "reader", "bin", "doc"], "response": ["text", "sequence", "message", "result", "su", "re", "output", "uri", "json", "dict", "question", "reset", "update", "status", "model", "view", "success", "offer", "image", "line", "application", "resp", "data", "example", "object", "location", "resource", "description", "next", "reason", "server", "Response", "res", "body", "api", "onse", "string", "header", "respond", "true", "respons", "received", "value", "version", "answer", "request", "r", "feed", "error", "report", "reply"], "parentdir": ["parentDir", "parentfile", "Parentdirectory", " parentDir", "rootdirectory", "rootfile", " parentlib", " parentfile", "partfile", "homediff", "Parentdict", " parentdict", "parentsDir", "parentdict", "parentdirectory", "homefile", "rootlib", " parentdiff", " parentdirectory", "hostdirectory", "hostdir", "parentsdir", "partlib", "parentsfile", "parentdiff", "homedir", "parentlib", "parentsdiff", "homeDir", "partdirectory", "hostdict", "Parentdir", "rootdir", "partdir"]}}
{"id1": "18433984", "id2": "3184073", "code1": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"doUpload": ["Doupload", "doupload", "doDownload", "DoDownload", " doupload", "DoUpload", "runupload", "runUpload", " doSave", "runSave", "DoSave", " doDownload", "doSave", "runDownload"], "request": ["message", "buffer", "current", "json", " Request", "session", "instance", "config", "head", "event", "param", "image", "url", "operation", "upload", "header", "require", "queue", "stream", "temp", "type", "http", "application", "result", "client", "hello", "info", "model", "use", "view", "command", "req", "data", "object", "QUEST", "quest", "worker", "raw", "art", "user", "parent", "match", "method", "path", "state", "input", "condition", "resource", "ware", "accept", "document", "subject", "requ", "string", "version", "get", "Request", "content", "create", "re", "frame", "page", "complete", "q", "initial", "server", "transfer", "query", "child", "connection", "submit", "file", "r", "er", "join", "xml", "report", "context"], "response": ["message", "result", "re", "output", "json", "client", "model", "page", "view", " Response", "image", "resp", "resource", "reply", "Resp", "document", "server", "Response", "onse", "connection", "stream", "xml", "report", "status", "content", "application"], "reqSession": ["requSession", "requConn", "rbSecret", " reqsession", "tempSocket", "reqSecret", "clientsession", "clientSocket", "rbession", "refLog", "rbsession", "reqLog", "qsession", "rbLog", "requsession", "reqession", "reqCh", "qConn", "tempsession", "reqConn", "qClient", "refession", " reqSocket", "refSecret", " reqSecret", "qSession", "clientCh", "rbSession", " reqLog", "rbConn", "rbClient", " reqCh", "reqsession", "requClient", "reqClient", "tempSession", " reqession", "clientSession", "tempCh", "refSession", "reqSocket"], "uploadFiles": ["transferFiles", " uploadResources", "transferfiles", "Uploadfiles", "uploadFile", "uploadfiles", "UploadFile", "UploadFiles", "uploadResources", "UploadResources", "transferResources", "transferFile", " uploadFile", " uploadfiles"], "tempDirName": ["tempAreaname", " tempDirInfo", "tempVername", "tempAreaSize", "tempFolderName", "tempFolderPath", "cacheDIRname", "tempFileInfo", "TempDirectoryPath", " tempFileName", "tempFileSize", "tempDirInfo", "tempDirHome", "tempDIRname", "tempDirKey", "TempDirKey", "tempDirname", "cacheDirname", "tempDirSize", "tempVerName", "tempFoldername", "tempDirectoryHome", "TempDirectoryKey", "tempDirPath", "tempDirectorySize", "tempVerDesc", "tempDirCode", "tempFileCode", " tempFileSize", "tempAreaName", "tempDirectoryInfo", "cacheDirName", " tempFileInfo", "TempDirName", "tempFilePath", "cacheDIRName", " tempDirname", "cacheDirPart", "tempFolderCode", "TempDirectoryName", "tempDIRName", "cacheDirHome", "tempFolderPart", "tempDirectoryPath", "tempFileName", "tempDirectoryname", "TempDirCode", "tempFolderKey", "tempDirPart", "tempFolderHome", "tempDIRHome", " tempFilename", "TempDirectoryCode", " tempDirDesc", " tempFoldername", "tempFileKey", " tempDirSize", "tempDirDesc", " tempFolderDesc", " tempFolderCode", " tempDirCode", "cacheDIRHome", "tempVerCode", "tempAreaInfo", "tempDirectoryDesc", "tempDirectoryPart", "tempDIRPart", "tempDirectoryName", "TempDirPath", "tempDirectoryKey", "tempDirectoryCode", "tempFolderDesc", "cacheDIRPart", "tempFilename", " tempFolderName"], "tempUploadDir": ["TempUploadDirectory", "tempUploadD", "tempTempDir", "TempDownloadDir", "tempUploadDb", "tempInputDir", "tempBuildD", " tempStreamJar", " tempDownloadFolder", "tempDownloadManager", " tempDownloadArea", " tempDownloadManager", "tempRootFolder", "tempImagedir", "testAttachFolder", "tempDownloaddir", "tempCaptureD", "tempWorkDir", " tempUploadFolder", "testUploadUrl", "tempDownloadJar", "tempDownloadPath", "temUploadInfo", "tempStreamArea", "TempUploadDir", " tempUploadJar", "tempDownloadDir", "testBuildDir", "tempDownFolder", "tempAttachFolder", "tempRootDb", "TempDownloadFolder", "testAttachUrl", "tempStreamDb", "testAttachDir", "tempDownloadUrl", "tempAttachUrl", "tempDownloadDirectory", "tempDownloadFolder", "tempDownJar", "tempImageArea", "tempuploadDir", "tempUploadPath", " tempUploaddir", "tempBuildJar", "tempCaptureJar", "tempUploadArea", "tempDownloadDb", "temUploadPath", "tempDownDirectory", "tempUploadDirectory", " tempStreamFolder", "temUploadFolder", "temuploadFolder", " tempDownloadDb", " tempUploadFile", "tempWorkDirectory", "TempDownloadDb", "tempAttachDir", "tempuploadFolder", "tempFileFolder", "tempInputFolder", "tempRootDir", "tempDownloadArea", " tempUploadDb", "tempBuilddir", "tempBuildDir", " tempStreamDirectory", "tempStreamJar", "tempUploadUrl", " tempStreamDir", "tempFileDir", "tempUploadInfo", "testUploadDir", "testBuilddir", "tempDownloadInfo", "tempCapturedir", "tempuploadPath", "tempCaptureDir", "testUploadD", "testUploadJar", "temuploadDir", "tempUploadJar", "tempDownloadD", "tempStreamDir", "tempInputPath", "testBuildJar", "tempUploadManager", "tempFileDirectory", "testAttachdir", "temuploadPath", "tempWorkFolder", "tempuploadInfo", " tempDownloadDir", "TempUploadFolder", "temUploadDir", "tempStreamFolder", "tempTempdir", " tempDownloadFile", "tempTempFolder", "tempImageDir", "TempDownloadDirectory", "tempAttachdir", "temuploadInfo", "tempUploaddir", " tempDownloadDirectory", " tempDownloaddir", "testUploadFolder", " tempUploadArea", "tempDownloadFile", "tempImageDirectory", "tempStreamDirectory", "TempUploadDb", "tempImageManager", "tempWorkFile", "tempFileFile", "tempUploadFile", "tempTempDirectory", "tempTempDb", " tempUploadDirectory", "testUploaddir", "tempTempManager", "tempUploadFolder", "tempInputInfo", "testBuildD", "tempDownDir", "tempRootDirectory", "tempImageFolder", " tempUploadManager"], "attachmentDir": ["attmentFolder", "attentionDb", "attachmentMin", "attributionFile", "attentionFile", "AttmentDirectory", "AttachedFile", "attachmentDb", "AttmentFolder", "attachedObj", "attachmentDet", "attributionDir", "attachmentFolder", "attachedFile", "attributionDb", "AttachedDirectory", "attporaryDet", "attachDirectory", "assachmentDet", "attmentDirectory", "attributionDet", "attmentDir", "attachedDir", "assachmentFile", "attmentMin", "attporaryDir", "attachDb", "assachedFile", "attentionMin", "AttachedObj", "assachedDir", "attachFile", "attentionDir", "attachmentObj", "attmentObj", "assachedDb", "attporaryFile", "attachDir", "AttachmentDirectory", "assachedDet", "AttmentDir", "attachedDet", "attentionObj", "AttachmentObj", "AttachedDir", "assachmentDb", "AttachmentMin", "attporaryDb", "attachmentFile", "attachmentDirectory", "attachedDb", "attachedDirectory", "assachmentDirectory", "assachedDirectory", "AttachmentDir", "attentionDirectory", "AttachmentFolder", "AttmentMin", "attmentFile", "AttachmentFile", "attentionFolder", "assachmentDir"], "paramMap": ["argMap", "ParamList", "mediamap", " paramClear", "Parammap", "ParameterCache", "argArray", "ParamClear", " paramList", "argList", "argClear", " paramCache", "ParamBlock", " parameterZone", "ParameterMap", "mediaMap", "paramArray", "paramList", " parameterMap", "ParameterList", " paramZone", " parammap", "paramBlock", " parameterList", "mediaArray", " parameterCache", "argBlock", "paramZone", "parammap", "paramCache", "mediaList", " paramBlock", "paramClear", "ParamArray", "ParamMap", "ParameterZone", " paramArray"]}}
{"id1": "6403868", "id2": "4599372", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractUpinstallSources", "extractUppackfiles", "extractUnInstallFile", "extractUnInstallfiles", "extractUpinstallFiles", "extractUnpackFile", "extractUnpackSources", "extractUninstallfiles", "extractUninstallFile", "extractUnpackfiles", "extractUnpackFiles", "extractUnzipFiles", "extractUnInstallSources", "extractUppackSources", "extractUpinstallfiles", "extractUppackFile", "extractUnInstallFiles", "extractUnzipFile", "extractUnzipSources", "extractUpinstallFile", "extractUnzipfiles", "extractUppackFiles", "extractUninstallSources"], "_destPath": ["_destDir", "_DestDirectory", "_destpath", "_DestFile", "_Destpath", "_downloadFile", " _sourceFile", "_DestPath", " _sourceHome", "_downloadDirectory", "_sourceFile", "_tmppath", "_sourceDirectory", " _destFile", "_sourceHome", " _destHome", "_distFile", "_DestDir", "_sourcepath", "_DestHome", "_srcDirectory", "_sourceDir", "_downloadHome", "_srcPath", "_tmpPath", "_destHome", "_destFile", "_sourcePath", "_destDirectory", " _sourcePath", "_distDirectory", "_tmpDirectory", "_srcFile", "_distPath", " _sourceDirectory", "_tmpDir", "_srcDir", "_distDir", " _destDirectory", "_downloadPath"], "upgrade": [" upGrade", "UpGrade", "upgrading", "ipgrade", "upGrade", "upge", "dugrading", "ipinstall", "upgrades", " upinstall", "offgrading", "ipgrades", "duGrade", "upinstall", "ipgrading", "Upge", "offinstall", " upgrades", "offgrades", "dugrade", "Upgrading", "Upgrade", "duge", " upgrading", " upge", "offgrade"], "lastVer": ["prevVers", " lastver", "firstVER", "lastVersion", "LastVer", "prevVer", "LastVersion", "nextver", "firstVersion", " lastVers", " lastVersion", " lastVER", "lastVER", "Lastver", "prevver", "lastver", "LastVER", "lastVers", "firstver", "nextVersion", "firstVer", "nextVers", "prevVersion", "nextVer"], "oldlog": ["newpath", "olderlog", " oldLOG", "OLDlog", "newLOG", "oldertext", "Oldpath", " oldtext", "oldpath", " oldpath", "OLDbug", "OldLog", "OldLOG", "olderLog", "newLog", "oldbug", " oldbug", "olderLOG", "oldLOG", "oldtext", "newtext", "oldLog", "newlog", " oldLog", "newbug", "Oldlog", "OLDLog"], "destPath": ["secureLog", "donepath", " destHome", "constpath", "homepath", "destpath", "flatDir", "descPath", "sourceDirectory", "destName", "descCh", "contpath", "sourcePath", "DestRoot", "targetFile", "doneDir", "DestPATH", " destFolder", "destKit", "DestFile", "exportPath", "exportpath", " destWin", " destName", "usrFile", "usrPath", "Destpath", "srcpath", "destCh", " destpath", "targetRoot", "DestDirectory", "exportPATH", "contDir", "DestHome", " destDirectory", "exportDirectory", "flatFolder", "DestFolder", "srcPATH", "srcDirectory", "destath", "destLog", "DestPath", "contath", "postPATH", "secureWin", "destDirectory", "sourceDir", "descName", "postRoot", "constPath", "descKit", "destDir", "flatPath", "homePath", "homeLog", "srcPath", " destRoot", "targetDir", "doneWin", "usrpath", " destCh", "constFile", "securePath", " destath", " destFile", "targetPath", "postPath", "sourcepath", "homeDir", "DestCh", "homeKit", "flatpath", "postpath", "descFile", " destDir", " destKit", "secureDir", "DestDir", "descpath", "destHome", "destRoot", "Destath", "donePath", "destFile", "targetpath", "descDir", "doneLog", "destWin", "targetPATH", "contPath", " destPATH", "constHome", "homeName", " destLog", "destFolder", "destPATH"], "lastVerPath": ["lastVERDir", "lastverDir", "lastVersionpath", "lastVerspath", "lastverName", "prevVerpath", "prevVerPath", "nextverFile", "prevVerName", "lastModDir", "prevverPath", " lastVersionEx", "prevVerFile", "lastVERPath", "lastModFile", " lastVerEx", "lastVersionCh", "prevverFile", "lastVersionName", " lastModpath", "lastVERpath", "lastVerpath", "nextverCh", "nextverPath", " lastVerpath", " lastVersionFile", "lastModpath", "lastverpath", " lastVerDir", "lastVersFile", "lastVerCh", " lastModDir", "lastModName", "nextVerFile", "lastVersPath", " lastVerFile", "nextVerpath", "lastModCh", "nextverpath", "lastVersionFile", "lastverFile", "lastTestFile", "lastTestPath", "lastverPath", "lastVerFile", "nextVerPath", " lastVersionpath", "lastVersCh", "nextVerCh", "lastVersionId", "lastVEREx", "lastModPath", " lastVersionPath", "prevverpath", "lastVerDir", "lastVersionPath", "lastVerId", "lastverId", "lastTestId", "lastVersionEx", "lastVERCh", "lastTestpath", "prevverName", " lastVerCh", " lastVersionId", "lastVerName", " lastVersionCh", "lastverEx", " lastModPath", "lastVerEx", " lastVerId", "lastverCh", " lastModCh"], "bkdir": ["bKDir", "bktdir", " bakir", "bkDir", "bkgDir", " bakdir", "bvdir", " bktdir", "bakpath", "bvloc", "bkkloc", "bktloc", " bkir", "bkbdesc", "bakDir", " bktfile", " bakpath", "bkfile", "bktdesc", " bkfile", "bkloc", " bakDir", "bKpath", "BckDir", "bakir", "bkkfile", "bkbloc", "bKdirectory", " bktloc", " bkdesc", "bkdirectory", "bkkDir", "bkkdesc", "Bckdir", "bakdir", "Bckpath", " bkDir", "bkir", "Bkpath", "bktfile", "bkgir", "bkdesc", "bckDir", "bKdir", "Bckdirectory", "bkpath", " bkloc", "bkbfile", "bvDir", "bckdir", "bckpath", " bkpath", " bktdesc", "bkkdir", "bakdirectory", "bkkir", "BkDir", " bakloc", "bakloc", "bkkpath", "Bkdirectory", "bkgdir", "bckdirectory", "bkbdir", "Bkdir", "bvpath"], "oldClassCopied": ["oldClassCopie", "oldClasscopored", "oldClassCopored", "oldClasscopies", "oldFileCopies", "oldFileCopyying", "oldclassCopie", "oldClassSkies", "oldClassCopyified", "oldFileCopied", "oldClassCopyiated", "oldClassCopyying", "oldClassCopies", "oldClassCopyies", "oldClasscopying", "oldFileCopiated", "oldClassSkie", "oldFileCopying", "oldClassCrossiated", "oldclassCopies", "oldClassCopified", "oldFilecopying", "oldclassCopored", "oldClassSkored", "oldFileCopified", "oldFilecopie", "oldFilecopies", "oldclassCopied", "oldClassCopyied", "oldFilecopied", "oldClassCopyie", "oldClasscopie", "oldFileCopyified", "oldClassSkied", "oldFileCopyied", "oldFileCopyiated", "oldClassCopiated", "oldClassCrossying", "oldFileCopie", "oldClassCrossified", "oldClassCopying", "oldClasscopied", "oldClassCrossied"], "ls": ["lp", "sels", "lf", "tl", "ln", "cs", "fts", "locks", "lines", "ols", "lists", "iffs", "lt", "irs", "LS", "less", "als", "igs", "l", "les", "lis", "bps", "dl", "vs", "lb", "lbs", "lc", "los", "qs", "files", "ails", "fs", "rl", "fl", "bs", "list", "ches", "lr", "ll", "acl", "mails", "ns", "ils", "lv", "wl", "la"], "i": ["p", "x", "uri", "ij", "z", "inner", "c", "ai", "f", "s", "ii", "gi", "info", "ix", "e", "d", "l", "I", "ci", "uli", "ind", "yi", "abi", "m", "ini", "q", "multi", "ip", "iu", "io", "si", "u", "b", "it", "lc", "ui", "pi", "oi", "min", "li", "index", "j", "ji", "hi", "mi", "di", "qi", "eni", "y", "xi", "part", "fi", "t", "mu", "slice", "o", "id", "end", "type", "v", "start", "ri", "ti", "phi"]}}
{"id1": "9727056", "id2": "8754809", "code1": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"loadModel": ["initModule", "getObject", "LoadFull", "createObject", "loadObject", "createFile", " loadFull", "getmodel", "loadFull", "getModel", "LoadModule", "LoadContent", "Loadmodel", "initFull", "initModel", "getFile", "loadmodel", "loadContent", "loadModule", " loadContent", "createModel", "loadFile", "createmodel", " loadModule", "LoadObject", "LoadModel", "LoadFile", "initContent"], "url": ["source", "buffer", "uri", "browser", "path", "Url", "f", "config", "page", "link", "l", "image", "blog", "object", "location", "email", "resource", "io", "base", "log", "job", "bel", "name", "server", "URL", "address", "sl", "db", "string", "ur", "layer", "lr", "ll", "el", "html", "file", "bug", "feed", "id", "user", "xml", "http"], "skin": ["source", "secret", "style", "span", "mode", "fun", "token", "uri", "color", "feature", "pin", "seed", " Skin", "kit", "root", "socket", "year", "fit", "Skin", "shell", "si", "name", "spec", "theme", "sel", "features", "sk", "origin", "layer", "plugin", "spin", "sid", "settings", "kin", "dir", "spot", "site", "id", "bin", "species"], "ParsingErrorException": ["ParsingStateEnd", "ParsingInputException", "ParsingingError", "ParsingingException", "ParsingErrorEnd", "ParsingErrorError", "ParserErrorception", "ParserErrorError", "ParseringException", "ParserErrorException", "ParsingStateception", "ParsingStateException", "ParseringEnd", "ParsingInputEnd", "Parseringception", "ParsingErrorception", "ParsingStateError", "ParserErrorEnd", "ParsingingEnd", "ParseringError", "ParsingInputception", "Parsingingception", "ParsingInputError"], "baseURLWasNull": ["baseURLwasEmpty", "baseUrlwasEmpty", "baseURLWasZero", "baseUrlWasZero", "baseUrlWasFound", "baseURLIsEmpty", "baseURLIsNull", "baseURLIsFound", "baseURLWasFound", "baseUrlwasNone", "baseUrlWasNone", "baseURLPreviouslyFound", "baseURLISNULL", "baseURLIsZero", "baseURLwasZero", "baseURLISFound", "baseURLWasNULL", "baseURLISEmpty", "baseURLISNull", "baseURLPreviouslyZero", "baseURLWasNone", "baseUrlWasEmpty", "baseURLwasNULL", "baseURLIsNULL", "baseURLPreviouslyNone", "baseUrlWasNULL", "baseURLIsNone", "baseUrlwasFound", "baseURLwasNull", "baseURLwasNone", "baseURLPreviouslyNull", "baseURLWasEmpty", "baseUrlwasNULL", "baseURLwasFound", "baseUrlwasNull", "baseUrlwasZero", "baseUrlWasNull"], "model": ["lp", "form", "app", "copy", "output", "json", "ml", "instance", "f", "info", "ii", "config", "view", "link", "l", "image", "Model", "data", "m", "module", "object", "service", "proxy", "ga", "base", "document", "bel", "null", "server", "zip", "sl", "api", "models", "channel", "el", "file", "parent", "response", "v", "xml", "jo"]}}
{"id1": "4938100", "id2": "6501291", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"sha1": [" SHA64", "SHA1", " SHAOne", "SHAOne", "hash1", "sha256", "shaOne", "hash256", "SHA256", "sha64", "hash64", "hashOne", " SHA1", " SHA256", "SHA64"], "text": [" TEXT", "source", "message", "secret", "output", "str", " Text", "token", "path", "translation", "config", "this", "font", "bytes", "txt", "word", "input", "image", "data", "TEXT", "object", "format", "editor", "class", "url", "name", "ext", "Text", "code", "password", "number", "letter", "hex", "string", "connection", "struct", "test", "value", "version", "key", "EXT", "template", "contract", "pattern", "content"], "UnsupportedEncodingException": ["UnsupportedEncodedEx", "UnsupportedEncodedception", "UnsupportedEncoderException", "UnsupportedEncodingEx", "UnsupportedEncasingception", "UnsupportedEncoderception", "UnsupportedEncodingception", "UnsupportedEncasingException", "UnsupportedEncodedException", "UnsupportedEncasingEx", "UnsupportedEncoderEx"], "md": ["me", "message", "mand", "mode", "mm", "mp", "mod", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", "mb", "meta", "mg", "ind", "data", "m", "map", "nm", "metadata", "ad", "mad", "mac", "bf", "editor", "valid", "rm", "ms", "sm", "vd", "code", "pd", "sha", "body", "gd", " MD", "ld", "mn", "dd", "di", "mo", "od", "mt", "hd", "cd", "am", "MD", "mc", "ma", "df", "mag", "pm", "d", "bd"], "sha1hash": ["sha41address", "SHA2check", "sha1address", "sha001sum", "sha256Hash", "SHA1sum", "sha4sum", "wa1sum", "sha1check", "sha2address", "wa3hash", "SHA1address", "sha1hex", "sha001hash", "SHA1check", "sha2sha", "sha1sha", "wa1dash", "sha5sha", "wa3sum", "sha5Hash", "SHA2sha", "sha3hash", "SHA1sha", "sha4dash", "sha41sum", "sha2Hash", "sha91hash", "sha1Hash", "sha256sum", "sha2hash", "sha256sha", "sha5sum", "sha5hash", "sha91sum", "sha4hex", "sha4hash", "sha3sum", "sha41hash", "sha91check", "SHA2hash", "wa1hex", "SHA1Hash", "sha2sum", "sha2check", "SHA1hash", "sha41check", "sha91address", "wa3hex", "sha1sum", "SHA2address", "sha1dash", "wa1hash", "SHA2sum", "sha001dash", "sha001hex", "sha3dash", "sha256hash", "SHA2Hash", "wa3dash", "sha3hex"]}}
{"id1": "22536033", "id2": "15645004", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"setPayload": ["setWorkload", "parsePayloads", "setPayloads", " setPayloads", "setWorkContent", "setPayContent", "setMessageLoad", "parsePayContent", "setPayLoad", "setShiploads", "setShipContent", "setRawContent", "setWorkloads", "setMessageloads", "parseShipLoad", "parseShipload", "setRawloads", "setWorkLoad", "setMessageContent", " setPayLoad", "setShipload", "parseShiploads", "parsePayLoad", "setMessageload", " setPayContent", "parseShipContent", "setShipLoad", "setRawLoad", "parsePayload", "setRawload"], "fos": ["cfoc", "bos", "cfics", "Fos", "fics", "Fis", "bics", "Fics", "cfis", "Foc", "boc", "cfos", "bis", " fics"], "fis": [" fib", "forics", "fib", "FIS", "eis", "eoc", "fics", "Fis", "Fics", "eIS", "forib", "fIS", "Foc", "Fib", " fIS", "foris", "Fic", "foric", " fics", "eic"], "fic": ["elfics", "firc", "elfik", "cfoc", "cfac", " firc", "cfic", "elfic", "infic", "Fik", " fac", "cfics", "Fos", "fics", " fik", "ufos", "elfci", "Fics", "fac", "Fac", "cfirc", "fci", "infci", "Foc", "ufik", "Firc", "ufic", "ufoc", "Fci", "fik", "Fic", "infik", " fics", "infics"], "foc": ["infos", "infocol", "Focol", "Fisc", "infocon", "infoc", " fisc", " foca", "troc", " focol", "infic", " fac", "infac", "Fos", "toca", "Froc", " focon", "infisc", "focon", "toc", "fac", " froc", "Fac", "tic", "Focon", "Foc", "froc", "focol", "foca", "fisc", "Fic", "Foca"], "Index": ["x", "Number", "Num", "Mass", "Pull", "Element", "Start", "Address", "Offset", "Width", "Found", "Location", "Header", "Path", "Value", "Length", "Weight", "Url", "Level", "Depth", "Client", "Entry", "Insert", "Counter", "Body", "Connection", "Input", "Exp", "Order", "Pos", "I", "Loop", "Loc", "Row", "X", "First", "Size", "Instance", " index", "Label", "Page", "Code", "index", "Link", "Version", "Count", "Flag", "Inf", "ID", "Position", "Rank", "Len", "Content", "Array", "Dim", "Stage", "Interest", "Section", "Key"]}}
{"id1": "5760649", "id2": "335223", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"createFile": ["createContent", "saveFolder", "saveResource", "saveContent", " createContent", "CreateFile", "CreateContent", "createFolder", " createFolder", "createResource", "saveFile", " createResource", "CreateResource", "CreateFolder"], "src": ["source", "sb", "fp", "uri", "path", "username", "load", "s", "buf", "txt", "input", "resources", "loc", "data", "Source", "resource", "img", "dest", "rob", "url", "name", "proc", "obj", "files", "sel", "sit", "sl", "sc", "secure", "SourceFile", "rc", "rss", "string", "fn", "rb", "upload", "gb", "stream", "ruby", "file", "r", "ssl", "slice", "href", "cb", "content"], "filename": ["source", "uri", "fp", "output", "length", "path", "username", "feat", "ame", "f", "s", "title", "txt", "fil", "l", "loader", "location", "metadata", "resource", "which", "dll", "directory", "FILE", "url", "name", "ames", "files", "rl", "SourceFile", "string", "fn", "ename", "prefix", "Filename", "acl", "file", "utf", "route", "nil", "wb", "sf"], "fis": ["fbs", "Fiss", "fiss", "cfIS", "cfris", "FIS", " fiss", "sfis", "Fbs", "sfos", "fris", "Fos", "Fis", " fais", "Fais", "fais", "cfis", "Fris", "cfbs", "fIS", "sfris", " fIS", "cfais", "sfiss", " fbs", "cfos", " fris"], "fos": ["affis", "affios", "Fas", "bos", "sfios", "foras", "sfis", "affbos", "affos", "Fbos", "sfos", "FOS", " fops", "sfops", " fOS", "bbos", "Fos", "fbos", "bios", "Fis", "Fops", "fas", "fios", " fas", "foris", "Fios", "fOS", "bis", "fops", " fios", "foros", "forOS"]}}
{"id1": "4895903", "id2": "23531898", "code1": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["create", "init", "loading", "parse", "check", "loaded", "construct", "view", "link", "dump", "read", "build", "loader", "process", "transform", "Load", "find", "add", "list", "loads", "loop", "include", "get", "LOAD"], "sourceType": ["typeType", " sourceStyle", " sourceCase", "resourceName", "srcUnit", "srcType", "secureType", "resourceTypes", "ourceInfo", "sourcePath", "srcCase", "sessionStyle", "secureStyle", "Sourcetype", "ourcetype", "parentPath", "sizeParam", "viewtype", "sourceTyp", "typeTyp", "parseType", "ourceName", "sourceTypes", "sourcetype", "ourceParam", " sourceTyp", "ourceUnit", "sourceCode", "securetype", " sourceTYPE", "SourceType", "srcName", "typePath", "secureTyp", "sourceUnit", "optionTYPE", "sessionType", "proxyType", "secureName", "sourceParam", "sourceTYPE", "ourcePath", "cacheName", "sizetype", "ourceTyp", "sessionTYPE", "resourcePath", " sourceTypes", "sizeType", "proxyPath", "parsetype", "parentType", " sourceParam", " sourceName", "SourceName", "parseName", " sourceTime", "cacheTyp", "sourceInfo", "ourceCode", "sourceCase", "sourceName", " sourceUnit", "cacheType", "SourceTypes", "ourceType", "sourceTime", "parenttype", "cacheTime", "sizeName", "ourceStyle", "sourceStyle", " sourcePath", "viewPath", "proxyStyle", "resourceInfo", "ourceTime", "optionInfo", "parseTyp", "optionStyle", "resourceUnit", "resourcetype", "typeStyle", " sourceInfo", "optionType", "resourceCase", " sourceCode", " sourcetype", "resourceCode", "sessionInfo", "proxyTyp", "resourceType", "viewType"], "source": ["text", "remote", "current", "parse", "session", "config", "project", "proxy", "comment", "dest", "core", "name", "spec", "see", "size", "stream", "iter", "slice", "target", "form", "position", "result", "uri", "client", "info", "component", "model", "view", "use", "ources", "SOURCE", "item", "Source", "object", "term", "dist", "site", "unit", "id", "parent", "style", "path", "language", "link", "driver", "e", "input", "ource", "single", "resource", "ce", "document", "grade", "string", "option", "element", "reference", "get", "status", "create", "inner", "src", "service", "missing", "class", "server", "function", "address", "secure", "scope", "connection", "handler", "file", "request", "route", "context"], "param": ["p", "ram", "python", "message", "ref", "meter", "property", "mode", "media", "large", "im", "client", "path", "language", "problem", "Param", "config", "model", "page", "view", "keep", "project", "pos", "default", "item", "required", "amp", "m", "con", "const", "resource", "comment", "asm", "rm", "name", "num", "reason", "vm", "params", "Parameter", "address", "lang", "see", "channel", "par", "cp", "option", "cm", "am", "include", "template", "unit", "aram", "pm", "member", "prom"], "location": ["local", "message", "filename", "position", "property", "expression", "uri", "remote", "Location", "mode", "length", "path", "language", "session", "containing", "instance", "point", "command", "root", "owner", "area", "image", "localhost", "loc", "condition", "loader", "definition", "folder", "resource", "where", "which", "format", "comment", "storage", "directory", "description", "platform", "error", "name", "lc", "selection", "function", "operation", "address", "shape", "region", "connection", "direction", "usage", "layer", "collection", "route", "slice", "entry", "site", "ocation", "layout", "response", "section", "node", "target"], "type": ["p", "types", "form", "method", "style", "position", "role", "media", "port", "length", "path", "language", "field", "info", "with", "page", "link", "to", "single", "none", "by", "ty", "format", "resource", "where", "comment", "valid", "class", "no", "name", "col", "pe", "null", "search", "params", "Type", "function", "address", "time", "index", "lang", "tag", "pretty", "option", "full", "block", "TYPE", "weight", "like", "attribute", "part", "ype", "t", "key", "id", "unit", "site", "parent", "user", "error", "target", "rel"], "inputsource": ["outputource", "imagesource", " Inputsite", "outputsite", "selectresource", " inputscope", " Inputsource", "sessionresource", " Inputresource", "inputscope", "inputresource", "Inputscope", " inputservice", "selectsource", "sessionource", "imagescope", "Inputconfig", "requestsite", "selectource", "Inputservice", " Inputservice", " inputource", " inputresource", "imageresource", "outputresource", "requestsource", "sessionsource", "Inputsource", "requestconfig", "imageource", "Inputource", "Inputresource", "requestresource", "requestservice", " inputconfig", "outputscope", "inputsite", "sessionsite", "requestource", "selectsite", "inputconfig", "inputource", "Inputsite", "outputsource", "inputservice", " inputsite"], "url": ["remote", "uri", "browser", "Url", "page", "link", "l", "image", "loc", "blog", "web", "object", "resource", "email", "www", "shell", "base", "bel", "server", "host", "URL", "rl", "sl", "address", "connection", "string", "fr", "ur", "stream", "layer", "coll", "ll", "file", "route", "pull", "ssl", "feed", "r", "ob", "err", "id", "user", "rel", "http"], "ds": ["ls", "uds", " cs", "cs", "ps", "ts", "ss", "ides", "iffs", "ys", "ists", "s", "DS", "dm", " dd", "ands", "ipes", "da", "des", " db", "rs", "dl", " docs", "ks", "os", "qs", "dt", "cks", "fs", "ails", "bs", "pd", "ants", "gd", "dds", "nas", "Ds", "di", "dd", "xs", " DS", "ains", "gs", "ads", "ns", "ils", "df", "db", "d", "dc"], "mbeans": ["mbs", " mobs", "modelbeans", "modelbs", "mnotations", "bmbean", "gmones", "mbean", "gmbeans", "modelnotations", "gmbs", " mones", "lbs", "bmones", "gmobs", "lnotations", "mobs", "gmnotations", "lbean", "bmbeans", " mbean", "modelbean", "bmobs", "mones", "gmbean", "lbeans"]}}
{"id1": "11716816", "id2": "189963", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"updateFile": ["updateFolder", "importFolder", "upBody", "copyBody", "upFile", "importDirectory", "copyDirectory", "importBody", "upFolder", "updateBody", "updateDirectory", "importFile", "copyFile", "copyFolder", "upDirectory"], "file": ["source", "local", "filename", "File", "fp", "cache", "current", "path", "load", "f", "info", "this", "model", "e", "input", "l", "socket", "image", "single", "line", "data", "object", "resource", "FILE", "up", "io", "class", "url", "base", "name", "log", "b", "pe", "files", "zip", "connection", "lock", "future", "queue", "handler", "full", "parent", "part", "dir", "type", "get", "db", "content", "http"], "IOException": ["TimeoutProblem", "TimeoutException", "DownloadException", "Downloadception", "IOception", " IOception", " IOProblem", "DownloadProblem", "Timeoutception", "IOProblem"], "destFile": ["sourceDir", " destFull", "destfile", "srcFile", " destPath", "origfile", " destinationFull", "flatDir", " destTable", " destDir", "destDir", "srcPath", "destroyFile", "DestDir", "destTable", "destroyfile", "DestFiles", "destPath", "DestFull", "flatfile", "destFull", " destFiles", "flatFile", "origDir", "origTable", " destinationFile", "DestFolder", "srcFiles", " destFolder", "origFile", "sourceFiles", "destroyDir", "sourceFolder", " destfile", "destroyTable", "flatFiles", "DestFile", "srcFolder", " destinationFiles", " destinationDir", "DestPath", "sourceFile", "destFiles", "destFolder", "Destfile"], "in": ["p", "work", "source", "as", "init", "re", "inn", "gin", "client", "sync", "cf", "pin", "inner", "ac", "c", "f", "ax", "s", "this", "with", "pass", "i", "input", "l", "socket", "inside", "image", "conn", "IN", "con", "win", "ini", "on", "io", "up", "bin", "a", "isin", "b", "nin", "min", "ins", "connection", "lock", "cin", "cl", "el", "In", "inc", "again", "pull", "r", "err", "login", "id", "reader", "din"], "out": ["call", "cookie", "of", "output", "sync", "client", "net", "c", "at", "point", "this", "extra", "w", "timeout", "ex", "pass", "i", "to", "socket", "OUT", "conn", "writer", "resource", "up", "io", "n", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "password", "nin", "connection", "exp", "channel", "option", "Out", "In", "outs", "inc", "again", "off", "lib", "err", "login", "o", "user", "bin", "outside", "co", "no"]}}
{"id1": "10690321", "id2": "1966310", "code1": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "code2": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "label": 0, "substitutes": {"readData": ["processData", "readdata", "parseDATA", "processdata", "parseData", "initDATA", "processDATA", "readText", "initdata", "initText", "readDATA", "parseText", "initData", "parsedata", "processText"], "sTok": ["sisTu", "yourChat", "fsDec", "sslTu", "tIter", "seTok", "sSel", "servicesTu", "opensPop", "sEh", "dLoc", "nIter", "sOk", "sMsg", "dsTu", "sUt", "awsRec", "servicesIter", "sBuild", "lsBuild", "fsSk", "hsVo", " sPos", "sLoc", "servicesKo", "suVo", "nLoc", "sChat", "sslIter", "siteLoc", "siteTag", "siteTok", "suSk", "synTok", "sisChan", "sesAk", "sisTok", "sportsPop", " sChat", "yourMsg", "servicesLex", " sIter", "suTok", "opensEh", "sDec", "nLex", "sisVal", "dToken", "lsKe", "tDoc", "nChat", "submitTok", "dsVal", "singleSk", "sKo", "fsTok", "newTok", "newUt", " sEnc", " sKo", " sDoc", " sLoc", "yourTok", "opensPos", " sPop", "sportsBuild", "sslVo", "sDoc", "synIter", "dTok", "hsTok", " sLex", "sLex", "tTok", "sportsEh", "newBot", " sOrg", "obsKe", " sBuff", "submitBu", "dsIter", "synVal", "testsKo", " sSk", "pTok", "sisIter", " sToken", "tLoc", "awsTok", "sportsPos", "synOtt", "testsTu", " sCorp", "sIv", "sAk", " sOk", "pLoc", "servicesIv", "seToken", "submitMsg", "sChan", "sesIter", " sIv", "awsDoc", "nTok", "dsUk", "awsEnc", "sKe", "sOrg", "SToken", "hsIter", " sVo", "sEnc", " sDec", "dIter", "awsIter", "obsBuild", "syncTok", "dsOtt", "sUk", "STok", " sBot", "sTu", "gsLex", "singleCorp", "siteIter", "dsTok", "SOk", " sOp", " sVal", "dsVo", "pToken", "suIter", "sesTok", "sSk", "testsIter", " sEh", "lsTok", "sPos", "sisOtt", "fsLex", " sTu", " sMsg", " sKe", "sVo", "nMsg", "SSel", "sTag", "sBot", "sportsTok", "sisBuff", " sChan", " sTag", "SOrg", "gsSk", "SBuff", " sBu", "gsDec", "siteOtt", "nUt", "servicesTok", " sRec", "sRec", " sAk", "seSel", "sIter", "nOp", "sToken", "sOtt", " sOtt", " sSel", "dsAk", "sVal", "nBu", "gsTok", "singleMsg", "awsLoc", "syncIter", "submitLex", "seBuff", "hsSk", "opensTok", "sBu", "newKe", " sUt", "syncVo", "testsTok", "obsTok", "sBuff", "sOp", "yourLoc", "syncTu", "dsLoc", " sUk", "sCorp", "SIter", "sportsKe", "pIter", "sslTok", "sPop", "singleTok", "sesUk"], "topSet": ["TopMap", " topMap", "topChan", "topAdd", "topMap", "pperHat", " topUnit", "pperChan", "pperSet", "TopSet", "pperMap", "TopUnit", "TOPChan", "TopHat", "TOPUnit", "TopAdd", "topHat", " topChan", "TOPSet", "TopChan", "topUnit", " topAdd", "TOPAdd", " topHat"], "leftSet": ["smallSet", "leftBlock", " leftUnit", "smallKit", "controlBlock", "smallUnit", "rightKit", "controlCollect", "leftHat", " leftKit", "lawBlock", "leftCollect", "lawHat", " leftHat", "leftKit", "lawCollect", " leftBlock", "rightUnit", " leftCollect", "leftUnit", "controlSet", "controlHat", "lawSet"], "rightSet": ["rightSource", "RightList", "rightMap", "rightsMap", " rightUnit", "rightsUnit", " rightChain", "rightsList", "RightMap", "rightChain", "rightGet", " rightList", "RightSet", " rightGet", "RightChain", " rightSource", "rightUnit", "RightSource", "rightsSource", "rightsChain", "RightGet", "rightsGet", "rightsSet", "rightList", " rightMap", "RightUnit"], "farRightSet": ["farRightUnit", "farLeftset", "farLeftSet", " farLeftSet", "farLeftUnit", "farCorrectChan", "farrightSet", "farLeftChan", "farRightset", "farRightList", "farrightUnit", " farRightUnit", "farCorrectset", "farrightList", "farCorrectSet", " farLeftUnit", "farRightChan", " farRightChan", " farLeftList", "farLeftList", " farRightList", " farRightset", "farCorrectList"], "vowelSet": ["voulSet", "vowlSize", "voxelList", "vowelsList", "vowelsMap", "voulSize", "vouelSet", "vouelSize", "voxelMap", "voweleMap", "voulList", "voxelSet", "vowlList", "vowellSize", "vowellSet", "vowellMap", "vowellList", "voweleSet", "vowelList", "vowelsSize", "voxelsSet", "voxelsMap", "voweleList", "vowelMap", "vowelSize", "voxelsList", "vowelsSet", "vowlSet", "vouelList"], "ntk": ["NTch", "ontr", "rtk", "ntkg", "antr", "ontp", "untk", "NTek", "ntak", "ontg", "ntok", "rtK", "netc", "settke", "ntke", "ptik", "ntks", "antK", "otku", "LTuk", "ptk", "netok", "antkg", "ontak", "ptr", "octk", "ctK", "rtok", "settsk", "ctk", "settk", "netK", "ctke", "ntg", "ontc", "gtk", "ntK", "octke", "ntik", "settg", "antik", "LTok", "ptp", "ntuk", "etwork", "gtc", "ntku", "ontke", "antp", "etok", "notsk", "ptK", "netk", "gtK", "NTak", "antok", "ontch", "ntc", "ntsk", "montk", "ontik", "untch", "ntp", "ottk", "ontsk", "notk", "ontk", "antwork", "ontK", "ontks", "ottok", "antku", "NTuk", "otk", "etk", "ottwork", "untok", "ontkg", "montK", "ctsk", "ottak", "ontku", "NTK", "NTc", "otp", "ntch", "ptsk", "gtke", "gtsk", "notK", "montke", "montsk", "NTwork", "etK", "ptks", "otkg", "octsk", "ntwork", "notks", "untwork", "ontwork", "NTk", "LTek", "gtok", "antc", "LTk", "antk", "rtwork", "ontok", "octg", "ntr", "NTok", "ntek"], "maxEwtsVowelLength": ["maxEwtsVowelsType", "maxEwtsVoyellLength", "maxEwtsVowelType", "maxEwtsVowellLen", "maxEwtsVowelsLength", "maxEwtsVowelText", "maxEwtsVowelingText", "maxEwtsVowellText", "maxEwtsVoyellId", "maxEwtsVowilLen", "maxEwtsVoyelType", "maxEwtsVowellType", "maxEwtsVowselNumber", "maxEwtsVowelingLength", "maxEwtsVowilId", "maxEwtsVowsetLength", "maxEwtsVowetLength", "maxEwtsVowelingNumber", "maxEwtsVowelLen", "maxEwtsVowetText", "maxEwtsVowsetText", "maxEwtsVoyellLen", "maxEwtsVowselLength", "maxEwtsVowelsLen", "maxEwtsVowelsId", "maxEwtsVowselText", "maxEwtsVowilType", "maxEwtsVowelingLen", "maxEwtsVoyellType", "maxEwtsVoyelLength", "maxEwtsVowelNumber", "maxEwtsVowsetNumber", "maxEwtsVowsetLen", "maxEwtsVowelId", "maxEwtsVowetNumber", "maxEwtsVowellId", "maxEwtsVowilLength", "maxEwtsVowellNumber", "maxEwtsVoyelId", "maxEwtsVowetLen", "maxEwtsVowellLength", "maxEwtsVoyelLen", "maxEwtsVowselLen"], "puncSet": ["PuncList", "puncset", "PucNum", "pucSet", " puccSet", "pummSet", "pummset", "pucGet", "PucSet", " puncGet", " puncset", "pascalSet", "puncList", "pascalList", "pocSet", "puccset", "PucList", "puccGet", "puncNum", "pascalNum", "pummGet", "pucNum", "PuncNum", "pucset", "PuncSet", "puccSet", " puccGet", "pucList", "puncGet", " puccset", "pocNum", "pocList"], "charSet": ["CharSet", " charMap", "charMap", "CharList", "charBlock", "characterBlock", "characterLet", "characterSet", "charList", "inchSet", "inchMap", "characterMap", "characterList", " charBlock", "inchLet", " charLet", "charLet", "CharBlock", " charList"], "tibSet": ["tbiet", "tikSet", "tibset", "tbiset", "TibiSet", "tobet", "tivet", "tibArray", "tikset", "tibiset", "TibEn", "Tibset", "tbiArray", "TobEn", "tivSet", "Tibiet", "TibSet", "Tibet", "tikArray", "tiket", "tibiArray", "TibiArray", "Tibiset", "tivEn", "TobSet", "tibEn", "tobSet", "tbiSet", "tibet", "tibiSet", "tilibet", "tilibSet", "tobEn", "tibiet", "tilibEn", "TibArray", "Tobet"], "sanskritStackSet": ["sanskritHashset", "sanskriticalStackset", "sanskritHashMap", "sanskritStackMap", "sanskritContextset", "sanskritStackset", "sanskritRootMap", "sanskriticalStackMap", "sanskriticalStackSet", "sanskriticalRootMap", "sanskritContextSet", "sanskriticalRootset", "sanskritRootset", "sanskritRootSet", "sanskritContextMap", "sanskriticalRootSet", "sanskritHashSet"]}}
{"id1": "2668634", "id2": "13783549", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"inputName": ["InputFile", "outputPath", "imageName", "Inputname", "inputname", "imageFile", "InputPath", " inputUrl", "inputFile", "InputName", "outputUrl", "InputAddress", "InputUrl", "inputPath", "imagename", " inputFile", " inputPath", "imageAddress", "inputUrl", "inputAddress", "outputFile", " inputAddress", " inputname"], "outputName": ["outputPath", "outputDir", "inputFile", " outputFile", " outputname", "inputDir", "OutputName", "applicationName", "applicationPath", "Outputname", "inputPath", "applicationFile", "OutputPath", "OutputDir", "outputname", " outputDir", "applicationDir", "OutputFile", "outputFile", "applicationname"], "stripLoggers": ["stripColger", " stripLogger", "striploggers", "stripColgers", "stripLogters", "striplogters", "stripDebugging", "stripColging", " striplogters", "stripLogging", "stripDebuggers", "striplogging", " striploggers", " stripLogters", " stripLogging", " striplogging", "stripLogger", " striplogger", "stripDebugger", "stripDebugters", "stripColters", "striplogger"], "tempFile": ["Tempfile", " tempFiles", " tempMessage", "TempDir", " temporaryStream", "poraryfile", "TempStream", "tmpPage", " tempDir", " temporaryFiles", "inputFile", "tempFiles", "tempStream", "TempFiles", "poraryFile", "inputDir", "tmpFiles", "tmpDir", " tempfile", "poraryMessage", "tempMessage", " temporaryFile", "tempPage", "tmpFile", "poraryFiles", " tempStream", "tempDir", "inputfile", " temporaryfile", "tempfile", "tmpfile", "TempFile", "inputPage", " tempPage", "TempMessage"], "jin": ["jing", "util", "ln", "su", " Jin", "rio", "gin", "unin", "jan", "pin", "ni", "jl", "skin", "zik", "fil", "sin", "ini", "Js", "in", "fen", "jack", "Skin", "NJ", "jun", "arin", "din", "ja", "cos", "vin", "sit", "zip", "nin", "Mu", "nu", "jen", "hin", "Ru", "NI", "cin", "thin", "jp", "lin", "plugin", "lu", "john", "zn", "spin", "inx", "Intern", "lib", "kin", "rin", "hn", "nir", "cli", "Mos", "zon", "irin", "icer", "zin", "bin", "tin", "raf", "pillar", "Kit"], "jout": ["nOut", "jetOut", "jetOUT", " jOUT", "jOut", "jetarray", "narray", "jouter", "ujout", " jouter", " jOut", "jOUT", "ujouter", "JOut", "nOUT", "Jouter", "ujOut", "Jout", "jarray", "jetout", "nout", " jarray"], "srcChannel": [" srcchannel", "sourceChannel", "sourceCh", "sourceChan", "srcchannel", " srcCh", "rcChannel", "sourcechannel", "rcChan", " srcChan", "rcchannel", "srcCh", "rcCh", "srcChan"], "dstChannel": [" ddestchannel", "dndChannel", "dndChan", "dstChan", "dstCh", " dstchannel", " ddestCh", " dstChan", "ddestCh", " ddestChan", "dspCh", " ddestChannel", " dstCh", "ddestchannel", "dspChan", "dspChannel", "dndCh", "dstchannel", "dspchannel", "ddestChan", "ddestChannel", "dndchannel"], "portletApplicationName": ["portletapplicationName", "portletApplicationsPath", "portletAppInfo", "portletAppType", "portletsAppCode", "portletApplicationCode", "portletApplicationsInfo", "portalPlatformUrl", "portletApplicationPath", "portalApplicationType", "portletApplicationsName", "portletsApplicationPath", "portalPlatformName", "portalApplicationName", "portalApplicationUrl", "portletPlatformType", "portletPlatformPath", "portletPlatformName", "portalApplicationPath", "portletAppPath", "portalPlatformPath", "portletPlatformUrl", "portletapplicationPath", "portletApplicationUrl", "portletAppCode", "portletPlatformInfo", "portletapplicationType", "portletsApplicationCode", "portletsAppInfo", "portletPlatformCode", "portletApplicationType", "portletAppUrl", "portletApplicationsCode", "portletsAppPath", "portletapplicationUrl", "portletApplicationInfo", "portletsApplicationInfo", "portletAppName", "portletsApplicationName", "portletsAppName", "portalPlatformType"], "webXml": ["WebXMML", "WebXml", "webCrossml", "webxaml", "webClass", "webHiel", " webXxml", " webXMxml", "webXul", "webxML", "webEcpl", "webEcML", "webCrossul", "webHML", "contextXli", "WebXiel", "WebXMpl", "contextCML", "contextClass", "webEciel", "contextXML", "webWorkaml", "webXaml", "contextCrossML", "WebXpl", "webXMpl", "contextXxml", "webXlass", " webXML", "webCxml", " webXMml", "contextCml", "webxml", "webxxml", " webXaml", "WebXMml", "webWorkul", " webXMML", "contextXul", "webHml", "webXMiel", "contextCrossml", "contextCxml", "contextCrossli", "webXpl", "webXli", "webXMaml", " webXMaml", "webXxml", "WebXML", "webCml", "webWorkml", "webHpl", "webEcml", "webxlass", "webXMxml", "webXMML", "webXMml", "webWorkML", "contextXlass", "WebXMiel", "contextCrossul", "webCrossML", "webCrossli", "webWorkli", "webXML", "webXiel", "webCML", "webWorkxml"], "portletXml": ["portletSytml", "portletXxml", "portleXml", "portletYML", "portletsXml", "portfileHml", "portleXxml", "portletSyxml", "portletHml", "portletSyml", "portletCML", "portfileHmos", "portletHxml", "portletSyaml", "portfileXml", "portletYml", "portleXaml", "portletXMaml", "portletXMml", "portletXtml", "portfileHML", "portletsYng", "portletHML", "portletsYml", "portletxxml", "portletHmos", "portletXMML", "portletXMmal", "portfileXxml", "portleSytml", "portletEml", "portletXMng", "portletXMxml", "portletSyncaml", "portletXMtml", "portfileXmos", "portfileXML", "portletXmal", "portletCmos", "portletEML", "portfileHxml", "portletSyncml", "portletYmal", "portletXML", "portletEmal", "portletXng", "portletCml", "portletXaml", "portleXtml", "portletsYML", "portletXmos", "portletxml", "portleSyml", "portletEng", "portletSyncxml", "portleSyxml", "portletxmos", "portletsXmal", "portletsXng", "portletSynctml", "portletYng", "portletCxml", "portletsXML", "portletxML", "portletsYmal", "portleSyaml"], "contextXml": ["contextExml", " contextAxla", "contextHaml", " contextAxML", "contextExML", "contextAxML", "contextUl", "contextxwl", "contextUML", "contextXML", "conceptHxml", "contextXla", "conceptXaml", "conceptHaml", " contextXla", "contextxaml", "contextxml", "conceptHml", "contextAxla", "contextXaml", " contextXl", "conceptXxml", "contextExl", "conceptHwl", " contextAxl", "contextXxml", " contextAxml", "contextXMxml", "contextHxml", "contextXMaml", "contextXMml", " contextXML", "contextExla", "contextHwl", "contextAxml", "conceptXml", "contextXwl", "contextUla", "contextXMwl", "contextAxl", "contextUml", "conceptXwl", "contextxxml", "contextHml", "contextXl"], "src": ["bh", "result", "sb", "rec", "lower", "uri", "uc", "sync", "st", "username", "config", "s", "gz", "ie", "i", "ource", "socket", "inst", "SOURCE", "sin", "rest", "loc", "req", "Source", "in", "prot", "resource", "rs", "img", "dest", "sr", "sup", "url", "ses", "cont", "spec", "host", "sit", "obj", "zip", "sub", "sl", "sel", "rl", "dist", "rc", "rb", "gb", "sc", "secure", "cur", "rss", "ur", "comp", "sq", "ruby", "lit", "sn", "rin", "r", "ssl", "ser", "entry", "slice", "href", "ctx", "ri", "jar", "rel", "http"], "source": ["text", "form", "result", "fp", "uri", "out", "client", "token", "session", "inner", "this", "use", "component", "view", "driver", "e", "i", "ie", "input", "ources", "ource", "sin", "SOURCE", "resources", "loader", "Source", "in", "service", "resource", "from", "proxy", "ce", "sr", "storage", "core", "url", "null", "spec", "reason", "gen", "sit", "zip", "function", "sl", "secure", "sp", "rc", "string", "connection", "scope", "stack", "size", "channel", "thin", "stream", "handler", "comp", "wrapper", "iter", "kin", "parent", "file", "slice", "reader", "unit", "get", "start", "xml", "status", "context"], "zipEntries": ["zipEntlements", "ZipEntions", "zipElines", "zipEnlines", "sliceEresses", "sliceEntresses", " zipEntrys", "zipentlements", "sliceEry", "zipCurrys", " zipEntrations", "zipIntegrations", "zipEntlines", "sliceElines", "zipEnries", "zipEntresses", "zipEresses", "sliceEntry", "zipIntegries", "zipCurries", "zipEndlines", "sliceEries", "zipEnry", "zipEnresses", "zipEndry", "sliceEntries", "zipentries", "zipCurlements", "zipEndresses", "zipentions", "zipentrys", "zipEry", "zipEntions", "zipEndries", "zipEries", "ZipEntries", "sliceEntlines", "zipEntrys", "ZipEntrys", "zipIntegrys", "zipCurions", "zipEnrations", "zipEntry", "zipEnrys", "zipEntrations", " zipEntry", "ZipEntlements", "zipIntegry"], "target": ["match", "method", "top", "style", "filename", "bh", "remote", "flat", "output", "current", "goal", "path", "wrong", "feat", "config", "component", "compatible", "hop", "tail", "nt", "arget", "project", "loc", "data", "object", "Target", "location", "format", "resource", "context", "dest", "platform", "class", "next", "name", "it", "host", "theme", "address", "tag", "string", "external", "scope", "prefix", "value", "file", "route", "template", "href", "rel", "site", "unit", "type", "content"], "webRewriter": ["app", "webResorter", "webRepriter", "Entry", "this", "New", "s", " webrewitcher", "webReworter", "application", " webReworter", "webResrite", "webResitcher", " webrewrite", " webrewriter", " webreworter", "webreworter", "webrewriter", "_", "webRepitcher", " webRewitcher", "webrewrite", " webRewrite", "webrewitcher", "webRewitcher", "webReporter", "webResriter", "webReprite", "webRewrite", "http"]}}
{"id1": "14617444", "id2": "13152325", "code1": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"readUNI": ["readUNDI", " readUnI", "readUTDI", "readULI", "readULDI", "readUND", "readULi", "readUTI", " readUNDI", "readULD", "readUni", " readUni", "readUnD", "readUnDI", " readUNi", "readUTD", "readUNi", "readUTi", " readUnD", " readUND", "readUnI", " readUnDI"], "descriptions": ["desriptors", "descractes", "descractations", "describedor", "descriptations", "describedions", "descractors", "desccriptions", "escriptors", "descractions", "describations", "describes", "describeations", "describeors", "describeions", "desccriptations", "escriptions", "describions", "describedors", "describeor", "escriptations", "escribes", "desriptations", "describors", "escribations", "escribions", "desccriptors", "desccriptor", "describedations", "descriptes", "descriptor", "desccriptes", "descriptors", "escriptes", "desriptions", "escribors", "desriptor"], "source": ["text", "filename", "result", "uri", "output", "table", "path", "info", "e", "i", "input", "ource", "src", "SOURCE", "data", "Source", "service", "resource", "format", "proxy", "description", "base", "name", "server", "code", "address", "grade", "string", "size", "stream", "iter", "file", "type", "start", "target", "content"], "is": ["as", "ris", "init", "internet", "uri", "isa", "IS", "out", "oss", "us", "im", "was", "inner", "isp", "ai", "info", "s", "its", "state", "il", "iss", "i", "ie", "Is", "src", "serv", "or", "iso", "in", "lis", "ir", "ip", "isin", "ar", "os", "cos", "it", "isc", "fs", "zip", "isl", "isol", "api", "isi", "ais", "iter", "abs", "es", "start", "iris", "err", "bis", "has", "ri", "can", "http"], "url": ["ls", "uri", "path", "Url", "f", "page", "l", "ource", "src", "image", "blog", "web", "resource", "open", "sr", "base", "bel", "server", "host", "URL", "fl", "sl", "string", "channel", "fr", "stream", "ul", "ll", "iter", "file", "ssl", "feed", "ob", "user", "rel", "http"], "scanner": ["scanker", "canler", "wininner", "caniter", " scaniter", "verinner", "Scanner", " scaninner", " scanne", "scanzer", "scaninner", " scanzer", "winker", "canzer", "verzer", "cankin", "scaner", "scankin", "scaniter", "canne", "caner", "Scanler", " scanler", " scanker", " scaner", "verner", "scanler", "canner", "Scaninner", "scanne", "Scanne", "caninner", "verer", "Scaner", "canker", "Scaniter", "winner", " scankin", "winkin"], "line": ["text", "message", "lf", "style", "Line", "lines", "se", "parse", "cell", "frame", "f", "info", "title", "page", "link", "l", "inline", "data", "in", "strip", "comment", "ip", "shell", "base", "name", "log", "pe", "code", "sel", "gen", "sl", "letter", "body", "li", "string", "header", "LINE", "el", "lin", "cl", "block", "file", "part", "row", "key", "feed", "entry", "le", "unit", "type", "end", "section", "content"], "id": ["kid", "uid", "Id", "rid", "uri", "str", "path", "info", "i", "ident", "data", "q", "in", "object", "bid", "ad", "vid", "ip", "ide", "error", "base", "name", "du", "code", "mid", "index", "string", "tag", "ID", "sid", "en", "iter", "pid", "key", "iden", "end", "aid", "type", "start", "ids"], "desc": ["text", "secret", "fun", "str", "Desc", "dec", "path", "c", "info", "alt", "de", "default", "loc", "data", "des", "dep", "comment", "dest", "description", "name", "der", "sec", "lc", "asc", "ext", "code", "sub", "priv", "sc", "dist", "neg", "esc", "div", "dev", "def", "dir", "end", "rev", "type", "error", "doc", "hide", "dc"], "linescanner": [" linesanener", "linescaninner", " linescanker", "linescanter", "linesscanler", " linesscanning", " linescaniner", " linescaner", " linesanker", "linescoreinner", "linesanller", "linespanning", "linespanner", " linesanner", " linescaninner", "linesconner", "linesscanker", " linesscaner", "linescaniner", "linesconinner", "lineshaninner", "linespaner", "linscanner", "linesscanning", "lineshanning", "linesanner", "linespanener", "linescoreller", " linescanler", "lineschaner", "linesscanner", " linesscanter", "lineschanner", "linescanener", "lineschaniner", " linesaner", " linesscaninner", "linesigner", "linsaninner", "linscanler", "linespanler", "lineschanter", " linescanter", "linesanker", "linesaniner", "lineshanler", "linscaner", "linescanker", " linesscanler", "linescorener", " linescanller", "linesscaniner", " linesscanner", "linescanller", "linescanning", " linesaninner", "linesscaner", "linesscaninner", "linesigninner", "linesaninner", "linesignner", "linesignker", "linsanler", "linsaner", " linesscaniner", "linescanler", "linesannter", "linesscanller", "linesconler", "linesanninner", "lineshanner", "linscaninner", " linesanter", "linesanter", "linesannner", "linesscanter", " linescanning", "linesscanener", "linesaner", " linesscanller", "linespaninner", "linesanler", "linsanner", "linesanener", " linescanener", "linescoreer", "linesconer", "linescaner"]}}
{"id1": "8000624", "id2": "23273706", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " copyFile", "CopyFile", "copyTo", "copyto", " transferTo", "copyFrom", " copyTo", "Copyto", " transferFrom", " transferFile", " copyto", " transferto", "CopyFrom", "copyFile"], "dest": ["source", "them", "filename", "flat", "output", "table", "path", " destination", "w", " Dest", "txt", "src", "rest", "data", "folder", "object", "done", "transform", "later", "img", "sup", "class", "tmp", "name", "cont", "die", "obj", "destroy", "dist", "comb", "exit", "write", "orig", "test", "desc", "file", "temp", "wb", "Dest", "bin", "opt", "target", "delete", "content"], "in": ["x", "source", "as", "init", "ln", "re", "inn", "gin", "pin", "inner", "ac", "f", "ax", "s", "pass", "plus", "i", "input", "l", "inside", "image", "sin", "conn", "IN", "issue", "m", "con", "win", "ini", "n", "isin", "bin", "up", "din", "b", "vin", "nin", "ins", "h", "connection", "fa", "cin", "thin", "lin", "In", "again", "rin", "kin", "lib", "pull", "r", "wave", "login", "id", "reader", "inc"], "out": ["x", "call", "app", "copy", "cache", "output", "sync", "client", "net", "pin", "inner", "our", "this", "not", "w", "timeout", "ex", "plus", "i", "one", "socket", "OUT", "conn", "image", "or", "data", "writer", "object", "other", "n", "io", "up", "vert", "url", "name", "b", "ou", "outer", "ext", "exec", "nin", "external", "Out", "outs", "inc", "again", "off", "file", "temp", "lib", "part", "err", "o", "user", "bin", "outside", "target", "no"], "c": ["p", "x", "cy", "oc", "buffer", "char", "xc", "uc", "cf", "abc", "ac", "f", "config", "e", "i", "pointer", "l", "ca", "exc", "ci", "ic", "m", "ce", "comment", "ec", "n", "arc", "bc", "pc", "u", "col", "lc", "C", "code", "cr", "sc", "ch", "rc", "cc", "esc", "enc", "cl", "cm", "fc", "cu", "t", "r", "o", "ct", "v", "cb", "d", "content", "dc"]}}
{"id1": "13563706", "id2": "18211588", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "didGET", "handleget", "didPut", "didGet", "handleGET", "handlePut", " doPut", "doPut", "didget", " doget", "doGET", "doget", " doGET"], "request": ["p", "method", "message", "create", "remote", "result", "buffer", "current", "client", "instance", "frame", "config", "info", "model", "view", "event", "input", "image", "complete", "req", "data", "object", "resource", "QUEST", "document", "url", "server", "Response", "query", "connection", "string", "queue", "attribute", "user", "type", "xml", "Request", "report", "application"], "response": ["message", "result", "re", "output", "json", "client", "model", "view", " Response", "image", "application", "resp", "writer", "service", "object", "resource", "reply", "location", "description", "document", "wa", "subject", "reason", "server", "Response", "pool", "query", "res", "body", "index", "api", "onse", "connection", "header", "respond", "collection", "results", "feed", "site", "error", "report", "status", "http"], "selectedPage": ["selectedSite", "lectedLine", "lectedButton", "lectedpage", "lectedSite", "lectedAction", "electedpage", "selectedHour", "selectionHour", " selectedAction", "selectionpage", " selectedItem", "selectionLine", "selectedAction", "namedPage", "selectedpage", "selectionFile", "electedPage", "electedButton", "namedLine", "selectionAction", "electedLine", "selectionPage", " selectedSite", " selectedButton", " selectedLine", "selectedLine", "namedFile", "selectedFile", "selectedItem", "namedpage", "lectedHour", "lectedPage", " selectedHour", "namedSite", " selectedFile", " selectedpage", "lectedFile", "selectionButton", "lectedItem", "selectedButton", "selectionItem"], "page": ["message", "cache", "instance", "project", "image", "location", "proxy", "ip", "url", "display", "article", "pool", "sp", "je", "rule", "channel", "profile", "queue", "pp", "type", "section", "result", "position", "client", "model", "view", "po", " Page", "item", "module", "age", "ice", "peer", "Page", "plugin", "site", "unit", "user", "parent", "account", "me", "language", "point", "pl", "pg", "resource", "document", "number", "block", "html", "office", "node", "p", "phone", "port", "f", "per", "menu", "photo", "record", "change", "server", "ge", "fe", "address", "child", "connection", "handler", "route", "row", "layout"], "portalRequest": [" portialRequest", "portugalOrder", "portialPage", "portialResponse", "portugalRequest", "portpalPage", "portortalRequest", "portbalQuery", "portugalResponse", "portalOrder", "portALEvent", "portelRequest", "PortortalEvent", " portialQuery", "portALUser", "portortalServer", "portortalPage", " portialResponse", "PortalServer", " portalQuery", "portallingAccess", "PortalOrder", "portugalServer", "portpalRequest", "PortalRequest", "portalServer", "portallRequest", "portelQuery", "portailResponse", "portallServer", "PortortalRequest", "portALResponse", "portalAccess", "PortortalPage", "PortortalAccess", "portugalUser", " portalResponse", "portalEvent", "portallResponse", "PortalUser", "portalUser", "PortortalOrder", "portallingRequest", "portpalResponse", "portelPage", "portbalResponse", "portpalAccess", "portelResponse", "portALRequest", "portallingResponse", "PortalCommand", "portortalResponse", "portalResponse", "portortalOrder", "portelCommand", " portalPage", "PortalAccess", "portallUser", "portialRequest", "PortortalUser", "portalQuery", "PortalEvent", "portortalEvent", "PortortalCommand", "PortalPage", "portbalRequest", " portialPage", "PortortalServer", "portalCommand", "portortalUser", "portortalAccess", "portugalEvent", "portallingPage", "portailUser", "portortalCommand", "PortortalResponse", "portbalPage", "portialQuery", "portailOrder", "PortalResponse", "portallingCommand", "portailRequest", "portalPage"], "pageProp": ["pagePro", " pagePro", "agePro", "projectProperty", "pluginProperty", "pluginPro", "parentObj", "PagePro", "resourceProp", "pageProperty", "ageprop", "resourcePro", "pageObj", "Pageprop", "PageProperty", "parentPro", " pageStr", "parentProperty", "projectPro", "PageObj", "resourceProperty", "ageProp", "peerPro", "peerStr", "PageStr", "parentProp", " pageProperty", " pageObj", "pluginProp", "projectprop", "resourceprop", "peerProperty", "pageStr", "PageProp", "peerProp", "ageProperty", "projectProp", "pluginprop", "pageprop"], "possiblePage": ["PossiblePages", "pablePages", "puredItem", "Possibilitypage", "possiblyItem", "PossibilityPages", "possiblyPage", "patchingItem", "patchingpage", "PossibleOrder", "PossibleItem", "possiblepage", "PossiblePage", "pablePage", "PossiblyOrder", "patchedLine", "puredPage", "patchedPage", "PossibilityPage", "patchingGroup", "patchedOrder", "PossiblyLine", "possiblePages", "possibilityLine", "possiblyLine", "permanentLine", "possiblyOrder", "permanentOrder", "pablepage", "possibleItem", "PossiblyPage", "patchedpage", "possibleOrder", "PossibleLine", "possiblyPages", "PossibleGroup", "possiblypage", "puredGroup", "permanentPage", "pableLine", "patchingPage", "possibilityPage", "permanentpage", "PossibilityLine", "PossiblyItem", "possibleLine", "possibleGroup", "PossiblyGroup", "puredpage", "Possiblypage", "possibilitypage", "Possiblepage", "possiblyGroup", "possibilityPages"], "property": ["p", "binding", "result", "expression", "prop", "perties", "set", "table", "feature", "language", " Property", "f", "config", "project", "uration", "data", "duration", "object", "resource", "binary", "operator", "integer", "Property", "class", "character", "name", "label", "entity", "function", "number", "address", "notation", "term", "variable", "header", "string", "prefix", "section", "profile", "future", "layer", "attribute", "value", "properties", "key", "t", "type", "maximum"], "referer": ["Refender", "referers", "refiner", "Referers", " refere", " referen", "deferer", "ferer", "defrer", "Refre", " refre", "afferer", "refeline", "defere", "refender", "diffiner", "Refiner", "diffender", "Refrer", "fere", "Refber", "affere", "reiner", "Referen", "diffrer", "refre", "rere", "refber", "refrer", "ferers", "redber", "rederer", " refrer", "refere", "defender", "referen", "Referer", " refber", "differer", "redeline", "reere", "Refere", "affrer", "reerer", "defber", " refiner", "rerer", " refender", " refeline", "Refeline", "redrer", "afferen", " referers", "frer"], "e": ["p", "me", "message", "se", "f", "this", "event", "i", "ie", "d", "one", "de", "ed", "exc", "ele", "or", "E", "a", "null", "fe", "see", "element", "ee", "ae", "eme", "es", "err", "er", "o", "type", "esi", "error", "ception", "ea"]}}
{"id1": "6171406", "id2": "8079516", "code1": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"createTar": ["makeHar", "createJar", " createJar", "makeJar", "buildTar", "makeTar", "buildHar", " createHar", "createHar", "buildJar"], "directoryToPack": ["directorytopack", "directoryOfSave", "Directorytopack", "directorytoPush", "directorytoUse", " directorytoPack", "databaseToPack", "directoryToSave", "directoryFromPush", "directoryFromPack", "categoryToPack", "directoryWillSave", "directoryOfPack", "directorytoHack", "directory2Save", "directory2pack", "databaseTopack", "databaseToSave", "dirToPack", "directoryFrompack", "DirectorytoZip", "directoryTopack", "dirtoPack", "directoryPopack", " directoryToUse", "directoryTOSave", "directoryTOPack", "directorySyncPush", "directionToPush", "DirectoryToSave", "DirectoryToPack", "directoryOfUse", "directoryWillZip", "directoryToUse", "directorySyncSave", " directorytoUse", "directionTOPack", " directorytoPush", "directoryPoPack", "directoryToPush", "directoryWillPush", "directoryTOpack", " directoryToPush", "directoryPoPush", "directorySyncPack", "filenameToSave", "filenametoPush", "directoryTOHack", "dirtoSave", "databaseTOpack", "directoryWillHack", "directoryToZip", "directoryFromSave", "directionToSave", "directionTOPush", "directorytoSave", "dirTopack", "DirectorytoPack", " directorytoHack", " directorytopack", "directorytoZip", "dirtoPush", "categoryToPush", "directoryToHack", "directionTopack", "directionTOpack", " directorytoSave", "directoryTOPush", "directorytoPack", "DirectoryTopack", "directionTOSave", "filenametoPack", "DirectorytoSave", "categoryPopack", "databaseTOPack", "DirectoryToZip", "directory2Push", "filenametoSave", "directoryTOUse", "directoryWillpack", " directoryTopack", "filenameTopack", "categoryTopack", "directory2Pack", " directoryToHack", "filenameToPack", "dirtopack", "categoryPoPack", "filenametopack", "directoryWillPack", "categoryPoPush", "directionToPack", "directoryOfpack", "dirToPush", "filenameToPush", "dirToSave", " directoryToSave", "directorySyncpack", "databaseTOSave"], "targetTarFile": [" targetTarMessage", "targetScarfile", "targetHarMessage", "targetTarEntry", "targetScarU", "targetRaMessage", "targetJarFile", " targetTarPath", "targetJarfile", " targetHarFiles", " targetScarFile", " targetTarFiles", "targetWarPlace", "targetScarPath", "argetTarFile", "targetTarFiles", "targetTransferString", "targetRaPath", "targetHarEntry", " targetHarfile", "targetWarFiles", " targetScarFiles", "targetScarFiles", " targetHarEntry", "targetTarPath", "argetTarFiles", "targetWarFile", "argetScarU", "argetTarString", "argetTarFunction", "targetTargetFile", "targetHarfile", "targetWarPath", "targetFilefile", "argetScarPath", "targetJarString", "targetTarFunction", "targetFilePath", " targetTarfile", "argetTarU", "targetTarPlace", "targetWarfile", "targetHarPath", "argetScarFiles", "targetTarU", "targetHarU", "targetTarMessage", "targetHarPlace", "targetRafile", " targetTarEntry", "targetScarPlace", "targetTargetPlace", "targetWarFunction", "argetTarPath", "targetHarFile", " targetHarMessage", " targetTarPlace", "targetJarPath", "targetWarU", " targetHarPath", "targetTarfile", " targetHarFile", "targetScarFile", "targetJarEntry", "targetTargetPath", " targetScarfile", "argetTransferFunction", "argetTransferFile", "targetTransferFiles", "argetTransferFiles", "targetHarFiles", "targetTarString", "targetWarString", " targetScarPath", "targetTransferFile", "argetTransferString", "argetScarFile", "targetTransferFunction", "targetFileFile", "targetRaFile", "targetJarFunction", " targetHarPlace", "targetFileEntry", "targetTargetfile", "targetJarFiles"], "buffer": ["source", "position", "copy", "cache", "length", "memory", "info", "buff", "buf", "input", "image", "data", "writer", "map", "object", "resource", "array", "address", "Buffer", "header", "channel", "queue", "block", "reference", "key", "type", "offset"], "targetOutput": ["sourceoutput", "sourceTar", "externaloutput", "sourceInput", " targetTar", "TargetInput", "targetInput", "TargetFile", "targetFile", "externalFile", " targetoutput", "targetoutput", "TargetOutput", "externalInput", "tarInput", "Targetoutput", " targetFile", " targetInput", "tarOutput", "targetTar", "taroutput", "sourceOutput", "externalOutput", "tarTar"], "targetOutputTar": ["targetConnectionFile", "targetoutputHar", "targetOutputDirectory", " targetInputStream", "targetConnectionHar", " targetOutputStream", "TargetoutputFile", "targetInputFile", "targetOutputStream", " targetOutputFile", "TargetOutputT", "TargetOutputDirectory", "targetOutputHar", "targetOutputFile", "targetInputStream", "targetoutputFile", "targetoutputStream", "targetInputT", "targetConnectionTar", "targetOutputT", "targetConnectionStream", "TargetoutputTar", "targetInputTar", "TargetOutputFile", "TargetoutputT", " targetInputHar", "targetoutputT", "targetoutputDirectory", "targetoutputTar", "TargetoutputDirectory", "targetInputDirectory", "TargetOutputTar", " targetOutputHar", " targetInputFile", " targetInputTar", "targetInputHar"], "fileList": [" filelist", "fileSet", "fileChain", "FileList", " fileChain", "queuelist", "FileChain", " fileSt", "FileSt", "Filelist", "dirSt", "FileQueue", "dirStream", "fileSt", "fileStream", "dirList", "fileQueue", " fileStream", "queueChain", "dirSet", "FileStream", " fileSet", "queueList", "FileSet", "queueQueue", "filelist", " fileQueue"], "iter": ["itter", "init", "set", "inner", "finder", "ver", "info", "ite", "ter", "cher", "ler", "e", "i", "keep", "enter", "skip", "ele", "upper", "gener", "loc", "loader", "walker", "ner", "other", "ider", "ir", "ip", "outer", "izer", "it", "Iter", "oper", "ator", "li", "list", "former", "over", "chain", "coll", "loop", "err", "er", "dir", "r", "her", "reader", "inter", "ser", "iterator", "inc", "order", "ipper"], "file": ["source", "message", "remote", "File", "cache", "current", "session", "py", "ball", "ile", "il", "project", "image", "comment", "directory", "core", "url", "base", "log", "name", "pe", "zip", "profile", "stream", "queue", "let", "un", "key", "template", "dir", "entry", "type", "same", "http", "application", "uri", "check", "info", "model", "use", "show", "fil", "root", "item", "data", "module", "object", "binary", "play", "force", "self", "phase", "files", "entity", "live", "future", "layer", "plugin", "_", "pull", "parent", "plain", "db", "style", "flat", "path", "back", "place", "link", "e", "single", "line", "folder", "resource", "format", "FILE", "document", "b", "string", "element", "only", "get", "flow", "local", "filename", "fp", "f", "archive", "page", "l", "complete", "service", "where", "class", "it", "change", "function", "fe", "letter", "child", "index", "connection", "handler", "full", "part", "route", "er"], "filePathInTar": ["filepathIntar", "filePathOutsideEar", "filepathInTar", "filepathedInHar", "filePathINTar", "filePathINJar", "filePathedIntar", "filePathOutsideJar", "filePathIntar", "filePathForJar", "fileNameInJar", "filePathinTar", "fileNameedInEar", "filePathinJar", "filePathedInHar", "filePathInsideTr", "filePathInsideTar", "filePathINtar", "filePathOutsideTar", "filePathedInTar", "filePathInHar", "filePathinTr", "filepathinTar", "filePathForTar", "filePathedInPrivate", "fileNameInPrivate", "filepathedIntar", "filepathedInTar", "fileNameedInJar", "filePathedInEar", "filepathinJar", "fileNameInEar", "filepathedInJar", "fileNameInTar", "filePathForPrivate", "filePathedInJar", "filePathintar", "filepathInJar", "filepathInHar", "filePathInsideJar", "filePathedInTr", "filePathForEar", "filePathInEar", "fileNameedInPrivate", "filePathOutsidePrivate", "fileNameedInTar", "filePathInJar", "filepathinTr", "filePathinHar", "filePathINHar", "filePathInTr", "filepathInTr", "filePathInPrivate"], "tarAdd": ["TarAdd", "drAdd", "rarCreate", "parseAdd", "drEntry", "arAdded", "drAdded", "rarEntry", "rarAdd", "tarCopy", " tarCreate", " tarEntry", "parseAdded", "catadd", "catCopy", "parseCreate", "arCopy", " tarAdded", "catAdd", "carAdded", "TarCopy", "rarAdded", "TarAdded", "tarEntry", "tarAdded", "carCreate", "aradd", "Taradd", "arAdd", "taradd", "drCreate", "parseEntry", "catAdded", "carEntry", "tarCreate", "carAdd"], "in": ["the", "of", "inn", "gin", "out", "inner", "at", "yn", "s", "this", "per", "inside", "sin", "ans", "inline", "an", "IN", "by", "from", "internal", "on", "n", "and", "bin", "it", "gen", "is", "sub", "nin", "index", "inv", "ins", "thin", "In", "under", "en", "id", "inc", "outside", "d", "ass"]}}
{"id1": "5951610", "id2": "2525897", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testNETHTML", " testInternetHTTP", "testnetworkHTTP", "testNetworkHttp", "testnetworkSSL", "testInternetHTML", "testNETHTTP", "testNetworkSSL", " testInternetHttp", "testInternetSSL", "testNETSSL", "testInternetHTTP", "testnetworkHTML", " testNetworkHTML", " testNetworkHttp", "testInternetHttp", "testNetworkHTML", " testInternetHTML", " testInternetSSL", "testNETHttp", " testNetworkSSL", "testnetworkHttp"], "url": ["text", "gl", "buffer", "ml", "config", "hl", "event", "il", "bl", "image", "build", "loc", "left", "location", "ol", "base", "log", "rl", "channel", "key", "feed", "entry", "http", "group", "util", "uri", "tool", "load", "use", "view", "control", "loader", "email", "job", "lc", "coll", "layer", "impl", "lib", "pull", "user", "ls", "org", "call", "cloud", "output", "path", "update", "pl", "nl", "resource", "shell", "URL", "fl", "sl", "ul", "ll", "rel", "mail", "large", "Url", "page", "l", "blog", "github", "web", "service", "dl", "bf", "www", "server", "host", "connection", "ur", "cl", "lr", "el", "file", "ssl", "r", "ob"], "urlConnection": ["emailconnection", "flConstruction", "lengthConnection", "termConn", "UrlConnect", "ulUnit", "urlConstruction", "urlFunction", "urlConn", "blogConnect", "implReference", "UrlContainer", "webConnection", " urlConnect", "numberconnection", "termComputer", "serviceConnect", "resourceGate", "httpConn", "emailConnect", "httpComputer", "urlFactory", " urlConnector", " urlPool", "emailClient", "urFunction", "lconnection", " urlEnvironment", "viewConnect", "httpFactory", "httpConnection", "uriComputer", "urlPool", "urlUnit", "ulConn", "uriFunction", " urlClient", "htmlconnection", "urFactory", "flConnect", "webPool", " urlComputer", " urlReference", "emailConstruction", "serviceConn", "implEnvironment", "urlConnect", "UrlEnvironment", "uriUnit", "UrlConn", " urlConn", "serviceConnection", "numberConnector", "sslConnection", "urlComputer", "ulConnection", "resourceconnection", "urlConnector", "UrlConnection", "sslConn", "implConnection", "UrlComputer", "urConn", "htmlConnection", "URLConn", "lConnect", "emailConnection", "urlEnvironment", "lConnection", "urlReference", "URLConnection", "sslUnit", "viewConnection", "urlGate", "blogconnection", "glFunction", "numberConnection", " urlGate", "viewConstruction", "blogConnector", "ulConnector", "glConn", "urlClient", "serviceconnection", "glConnection", "URLConnect", "flconnection", "UrlReference", " urlconnection", "glConnect", "numberConnect", "sslConnector", "lengthconnection", "lConn", "urlContainer", "termContainer", "httpFunction", "urConnection", "emailGate", "resourceClient", "webconnection", "viewconnection", "lengthConstruction", " urlFactory", "termConnection", "flConnector", "htmlConstruction", "UrlFunction", "URLPool", "flConnection", " urlFunction", "uriConnection", "blogConnection", "URLconnection", "urlconnection", " urlContainer", "resourceConnection", " urlUnit", "lengthConnect", "httpUnit"], "rd": ["ird", "lf", "rx", "own", "rid", "arr", "lt", "wd", "rr", "RD", "dig", "rowd", "d", "dj", "bl", "ds", "RR", "nor", "addr", "nl", "rs", "ru", "director", "rown", "sr", "bf", "sth", "rob", "vd", "adr", "DR", "fd", "hr", "rl", "R", "nd", "RF", "wr", "pd", "gd", "rb", "dr", "rss", "respond", "fr", "ld", "rw", "dd", "rn", "ng", " reader", "lr", "usr", "rf", "Reader", "rt", "RL", "std", "xd", "td", "rod", "r", "dh", "tr", "reader", "RW", "rg", "rh", "db", "erd", "dra", "red", "bd", "rand"], "line": ["source", "lf", "Line", "lines", "cell", "lo", "frame", "day", "len", "page", "pass", "link", "word", "l", "skip", "val", "inline", "loc", "data", "nl", "comment", "ne", "limit", "log", "name", "lc", "col", "code", "ge", "rl", "sel", "number", "sl", "letter", "msg", "li", "string", "ld", "cl", "LINE", "lin", "el", "write", "block", "file", "part", "row", "key", "response", "login", "entry", "end", "le", "unit", "id", "user", "error", "d", "la", "status"]}}
{"id1": "8266672", "id2": "15202804", "code1": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"updatePicInfo": ["saveImageinfo", "updatepicInfo", "updatepicInf", "updatePicInf", "updateImageInfo", "updatePictureInfo", "savePicInfo", "updatePicinfo", "updatePictureInf", "saveImageInf", "savePicInf", "updateImageInf", "savePicinfo", "saveImageInfo", "updatepicinfo", "updateImageinfo", "updatePictureinfo"], "conn": ["gn", "cmp", "util", "sync", "client", "oss", "cf", "session", "cb", "c", "cat", "config", "reg", "cmd", "nt", "vol", "ca", "Conn", "ci", "serv", "manager", "loc", "con", "sys", "pg", "act", "pub", "connect", "core", "pc", "ann", "conv", "col", "server", "exec", "pool", "orp", "stat", "conf", "ch", "cr", "jc", "rc", "connection", "nc", "cc", "cp", "mn", "enc", "coll", "en", "cn", "rt", "mc", "cli", "dn", "ct", "ctx", "db", "cms", "co", "dc"], "nr": ["nar", "rx", "orr", "arr", "ni", "major", "our", "np", "nie", "rr", "mr", "rar", "vr", "nick", "nor", "ner", "nl", "ru", "sr", "n", "nn", "num", "adr", "random", "counter", "rl", "number", "wr", "nb", "gr", "dr", "inv", "rb", "nc", "fr", "mn", "rn", "yr", "rw", "lr", "radius", "range", "rf", "usr", "nw", "ctr", "sn", "eni", "rin", "lvl", "nir", "chain", "nil", "r", "err", "dir", "nis", "NR"], "lock": ["locks", "arr", "sync", "LOCK", "length", "ml", "pin", "len", "pl", "sol", "max", "bl", "l", "locked", "loc", "limit", "ock", "lc", "zip", "number", "sl", "live", "delay", "lang", "rc", "list", "gr", "min", "Lock", "cl", "lr", "lin", "ll", "block", "ok", "sn", "lvl", "pull", "row", "ssl", "dir", "locking", "rel"], "picInfo": ["pictureStyle", "picInf", "moduleINFO", "iconInf", "iconSync", "picLi", "pixelInf", "pictObj", "styleInf", "PicConf", "pictureInf", "picObj", "pinInf", "niceConf", "collInfo", "moduleInfo", "picUpdate", "moduleInf", "pictType", "pinObj", "pictInfo", "pinInfo", "PicSetup", "syncInfo", "picSync", "kinInfo", "studyInf", "picConf", "collInf", "PicInf", "pictureINFO", "pixelInfo", "syncLi", "picArea", "pictId", "PicINFO", "picId", "niceInfo", "pictureObj", "pictureUpdate", "kinStyle", "pinId", "PicType", "pixelArea", " picInit", "kinSync", " picINFO", "studyObj", "moduleLi", "pinArea", "picEx", "picSetup", " picArea", "studyInfo", "pictureInit", "styleInfo", "PicObj", "PicEx", "pixelINFO", "pinInit", " picEx", "styleConf", "collEx", "styleSetup", "studyUpdate", "iconInfo", "PicInfo", "syncInf", "niceSetup", "pinUpdate", " picInf", "pictInf", "pictureInfo", " picObj", "kinInf", "picInit", "pictureLi", "syncINFO", "collINFO", "pictureId", "niceInf", "picType", "picINFO", "iconStyle", "picStyle", "pictureSync", " picType", "pictureArea"], "sql": ["su", "summary", "json", "generic", "csv", "session", "sal", "s", "il", "sg", "loc", "auth", "comment", "url", "log", "SQL", "reason", "params", "printf", "rl", "msg", "zip", "pool", "lang", "sk", "fn", "tf", "general", "serial", "lv", "http", "util", "result", "ln", "uri", "sync", "kl", "tool", "seed", "email", "job", "lc", "utils", "lambda", "sq", "cli", "sf", "pkg", "db", "select", "ls", "str", "ql", "serv", "socket", "install", "sys", "nl", "shell", "limit", "sl", "string", "details", "ll", "html", "sn", "rup", "sv", "status", "eps", "filename", " SQL", "sol", "dl", "function", "QL", "err", "ssl", "xml", "cmp"], "pstmt": ["Pstmb", "pfatt", "pconstmb", "prsthpm", "prestmb", "postcl", "pprmb", "pstddr", "prstql", "Pstmon", "pstatmc", "ppstmd", "prsthql", "pstdrel", "ppstmt", "pestatt", "ppsthtool", "prstbh", "pfrm", "pconstpm", "psthmc", "prestcl", "pdmn", " postmt", "hstmt", "perstmt", "ipstpm", "pestmb", "pestbh", "pstrnl", " pftmt", "Postmt", "psthcl", "postmb", "pctdr", "pstbh", "ppbh", "perstmc", "ipstrnl", "psctr", "pstrmt", "prpmb", "pdm", "ipstmt", "ppsthdr", "psthrt", "pctpm", "pstert", "pstdmn", "pscbh", "ppstgr", "pstrm", "ipstrtr", "pestdr", "preostau", " pstert", "lpstmt", " postrel", "ppsthmb", "lpstrtr", " psttp", "pstmon", "pprmn", "psctor", "ppsthgr", "perstrm", "putmd", "preostcl", " pftmm", "ppstdr", "pstsrm", "prpbh", "pstrmm", "prsthmb", "pstmm", "pstrmon", "prpmt", "pftmt", "preostmt", "ppestql", " pfm", "hstbh", "pflrel", "psttool", "pstdert", "pctql", "pflmt", "pscmt", "preostmn", "ipstrpm", "pstql", " postert", "pfmn", "ppsthmt", "pstdm", "prestrel", "pstpt", "pclbh", "pscpm", "psttp", "pclmn", "prstatt", "pflm", "pstdmd", "pctrm", "pctpt", "ppatt", " pstrm", "pctmb", "pstdmt", "lpstm", "pustmt", "pstdtp", "pfret", "pconstcl", "prestau", "pstsmc", "pfpt", " pfmt", "presttr", "pstsgr", "ipstrmt", " pstrel", "pestmn", "pesttool", " pstcl", "lpstrmt", "lpsttr", " pfrel", "psthtool", "pftrt", "pdpl", "lpstrm", "pstdtool", "ppmn", "pftemb", "perstsgr", "pstrpl", " pstm", " pstmm", "psthmn", "lpstgr", "perstsmc", "pfrel", "Postret", "pstmb", "pstcl", "pptp", "prestql", "pconstpt", "pestcl", "postm", "Pstpt", "pflert", "ppsttool", "ppestmt", "pstsmt", "ppstql", " postm", "pscnl", "putdr", " pfcl", "pstdr", "postret", "ppsthmd", "psthmt", "prestsp", "pestmt", "putmt", "prestmt", "pprmt", "postau", "pstpl", "postert", "ppesttool", "psttr", "pstrel", "psthdr", "pstmd", "ppemb", "pcltor", "psthql", "pconstau", "prestmn", "Pstmn", "pstrgr", "postmd", "psthgr", "prpatt", "prestnl", "Pctmb", "pstrtr", "lpstrgr", "pctmn", "pestgr", "presttool", " pfttp", "pfm", "Pctm", "ppestsp", "ipstnl", "pstdemb", "ppmb", "Pstret", " pstmd", " pftmn", "pstatrm", "pstrrt", "perstsmt", "pctcl", " pfrm", "pconstmn", "pprrm", "Postmn", " pstemb", "ppmt", "pscmn", "Pctpt", "pstrpm", "psthmb", "Pstpl", " pfmb", "postmon", "pctpl", "pstsp", "pconstmt", "pestql", "pfttp", "psthpm", "pclmt", "pstatgr", " pfmn", "pstau", "hsttor", "pstrt", " pstmn", "pftmm", "pstret", "pstrmn", "psthmd", "Pstm", "Pctmn", "pstatmt", "prsthmt", "ppstsp", "pfbh", "Postmon", "ipsttr", "pctmd", "pstmn", "pstrret", "pdmt", "psthrel", "prstmb", "pcttr", "pconstql", "prstpm", "psthm", "pstpm", "perstgr", "psthrm", "psthtr", "pusttool", "Pstmt", "pctrel", "psthmm", "pctm", "pustql", " pstrt", "pfmt", " postmb", "Pctmt", "pconstm", "perstsrm", "pstnl", " pstmb", "pustsp", " pftrt", "puttool", "pfmon", "ppstmb", "prestmd", "postrel", "prstmt", "pctgr", "pctmt", "psttor", "pstm", "postmn", " postmd", "prestpm", "pstmc", "pstatt", "pfmb", "pstemb", "postmt", "pstgr", " pftemb", "pfcl", "pestsp", "hstmn", "pestau", "Pctpl", "pftmn"]}}
{"id1": "17999474", "id2": "14502142", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getTempAsFile", "getZipasDir", "getZipAtFile", "getZipasFile", "getTempAsDir", "getZipasPlace", "getTempAsPlace", "getZipAsDir", "getZipAsPlace", "getZipAtPlace", "getZipasfile", "getZipAtfile", "getZipAtDir", "getTempAsfile", "getZipAsfile"], "digOb": ["ditob", "DigOb", "signob", " digOB", "digOl", "DigObject", "signOb", "signOB", " digob", "ditOb", " digObject", "signObj", "signObject", "dimObj", "digObject", "dimObject", "digObj", "ditOB", "dimOb", "Digob", "DigObj", "ditObject", "digOB", " digOl", " digObj", "dimOl", "digob", "DigOl"], "folderName": ["packagePath", "filename", "folderPath", "foldName", " folderDir", "FolderDir", "filePath", "packageDir", " folderPath", "fileInfo", "foldInfo", "folderInfo", "foldname", "FolderName", "fileName", " foldername", "folderDir", "Foldername", "foldPath", "packagename", "packageName", "FolderPath", "foldername", "FolderInfo"], "tmpFolder": [" tmpManager", "tempFolder", " temporaryfolder", "mpfolder", " temporaryFolder", "tmpDirectory", "mpFolder", " tmpfolder", "tempfolder", "tmpDir", "mpDirectory", " temporaryManager", "tempDir", " tmpDir", " temporaryDirectory", "tempManager", " tmpDirectory", "tmpfolder", "mpDir", "tmpManager", "tempDirectory"], "zip": ["flow", "p", "source", "flat", "copy", "fp", "json", "cf", "z", "py", "bag", "download", "f", "lex", "gz", "archive", "ulp", "seed", "ie", " ZIP", "install", "folder", "proxy", " zipper", "ce", "ze", "cop", "ip", "io", "job", "clip", "url", "tmp", "sl", "upload", "lock", "wrap", "ipped", "ress", "file", "temp", "lib", "pack", "ignore", "feed", "pkg", "pipe", "zone", "slice", "xml", "jar", "Zip"], "out": ["flow", "source", "result", "copy", "cache", "output", "sync", "client", "path", "z", "flush", "download", "f", "info", "this", "gz", "page", "ex", "socket", "OUT", "conn", "line", "loader", "writer", "box", "in", "object", "io", "a", "url", "base", "log", "os", "null", "gen", "obj", "is", "child", "upload", "connection", "plain", "Out", "write", "outs", "again", "file", "temp", "parent", "cli", "err", "o", "user"]}}
{"id1": "8119563", "id2": "20851065", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"checkLink": ["checklink", "CheckConnect", "loadlink", "CheckLine", "checkLine", " checkConnect", "CheckLink", " checklink", "loadLine", "loadConnect", "loadLink", "Checklink", "checkConnect", " checkLine"], "url": ["source", "uri", "str", "client", " URL", "Url", "instance", "config", "page", "link", "l", "socket", "conn", "image", "or", "loc", "service", "object", "location", "proxy", "resource", "open", "class", "base", "name", "null", "server", "host", "URL", "address", "sl", "string", "element", "file", "route", "ssl", "entry", "http"], "connection": ["relation", "position", "uri", "client", "connected", "c", "config", " Connection", "Connection", "timeout", "link", "i", "l", "socket", "conn", "image", "application", "loc", "data", "writer", "object", "resource", "open", "builder", "communication", "io", "connect", "character", "database", "b", "server", "function", "channel", "handler", "response", "unit", "network", "ion", "http"]}}
{"id1": "10385815", "id2": "11673907", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["create", "cmp", "sync", "paste", "Transfer", "update", "download", "Cop", "send", "move", "process", "open", "clone", "change", "transfer", "exec", "split", "zip", "upload", "Copy", "write", " Copy", "replace", "put", "file", "get", "delete"], "fileFrom": ["mailIn", "FileSource", " fileIn", "fileStart", "FileIn", "FileFrom", "fileAs", " fileStart", "mailAs", "ioFrom", " fileSource", "FileTo", "ioStart", "mailTo", "FileStart", "mailFrom", "ioTo", " fileAs", "fileSource", "fileIn", "ioSource", "FileAs"], "fileTo": ["fpFrom", " fileFile", "FileFrom", " fileTarget", "fpTo", "resourceFile", "fileFile", "fileTO", "FileTarget", "FileTo", " fileTO", "fileto", "Fileto", "FileFile", "FileTO", "fpto", " fileto", "fpTO", "fileTarget", "resourceTarget", "resourceTo", "resourceFrom"], "inputStream": ["InputFile", "InputChannel", " inputstream", "inputContext", "InputSync", "outputSteam", "inputFile", "InputContext", "outputContext", "Inputstream", "inputstream", "InputStream", " inputFile", "InputSteam", " inputSteam", "outputSync", "outputstream", "inputSteam", "outputFile", " inputContext", "inputSync", " inputSync"], "outputStream": ["OutputStream", "outputPath", "OutputStreamer", "writeStream", "OutputSteam", "writeSocket", "writeSteam", "outputStreamer", "referenceChannel", "inputChan", "inputSocket", " outputSteam", "OutputChan", "fourStreamer", "fourStream", "referenceStream", "inputPath", "OutputPath", " outputChan", " outputStreamer", "referenceSteam", "inputSteam", "fourSteam", "writeChannel", "OutputChannel", "fourChannel", "referenceSocket", "outputChan", "outputSocket", "outputSteam", " outputPath"], "inputChannel": ["outputClient", "audioCam", "butChannel", "parentPassword", "InputChannel", "inputContext", "InputContext", "inputChan", "outputContext", " inputSocket", " inputCam", "inputPassword", "inputCam", " inputPassword", "butCommand", "inputSocket", "parentChannel", " inputChan", "InputSocket", "audioChannel", "audioClient", "audioStream", "butContext", "InputStream", "inputCommand", "outputCam", "inputClient", "outputPassword", "outputCommand", "butChan", " inputClient", "InputChan", "parentChan", "outputChan", " inputContext", "outputSocket", "parentStream", " inputCommand"], "outputChannel": ["Outputchannel", "OutputStream", "inputQueue", "inputContext", "OutputContext", "inputChan", "outputContext", "outputchannel", "outContext", "outputQueue", "OutputChan", "OutputQueue", " outputQueue", " outputChan", " outputchannel", " outputContext", "outChannel", "OutputChannel", "outChan", "outputChan", "outStream", "inputchannel"]}}
{"id1": "6371580", "id2": "17116123", "code1": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"insertDomain": [" insertHost", "updateHost", "insertdomain", "updateDomain", " insertdomain", "insertDom", "addDom", " insertDom", "updatedomain", "adddomain", "addDomain", "updateDom", "addHost", "insertHost"], "domains": ["demains", "messances", "Domands", "domands", "demances", "Domages", "commances", "domales", "dimains", "domages", "demain", "messands", "dimages", "dimands", "dimales", "commands", "domances", "demales", "commains", "demands", "commain", "Domales", "messain", "demages", "messains", "Domains"], "psImpl": ["ipsManager", "osFactory", "paramsInterface", "PSOrg", "paramsManager", "upsUl", "psEl", "qsImpl", "osImpl", "osEl", "upsimpl", " psOrg", "psManager", "qsimpl", "osimpl", "upsImpl", "ipsEl", " psManager", " psInterface", "PSImpl", "qsUl", " psInstance", "ipsInstance", "PSFactory", "PSimpl", " psFactory", "ipsInterface", "psimpl", "ipsImpl", "PSUl", " psimpl", "ipsOrg", "psInterface", "psFactory", "paramsImpl", " psEl", "paramsInstance", "psInstance", "psUl", "ipsimpl", "psOrg", "PSEl"], "iter": ["inse", "itter", "set", "parse", "apper", "inner", "finder", "ite", "ter", "page", "cher", "e", "i", "enter", "upper", "gener", "ner", "walker", "in", "ir", "ider", "ip", "next", "Iterator", "it", "izer", "Iter", "is", "ator", "index", "former", "over", "chain", "coll", "el", "cer", "inc", "sort", "loop", "err", "er", "feed", "entry", "end", "reader", "inter", "iterator", "oper", "order"], "domain": ["message", "remote", "result", "role", "country", "str", "brand", "feature", "company", "model", "page", "command", "root", "Domain", "data", "agent", "example", "module", "folder", "format", "description", "division", "url", "base", "name", "host", "query", "address", "index", "string", "rule", "region", "origin", "prefix", "range", "dom", "value", "version", "file", "route", "key", "id", "site", "unit", "type", "zone", "node", "pattern", "product"]}}
{"id1": "647224", "id2": "3053403", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "label": 1, "substitutes": {"uploadFile": ["UploadDir", "processFiles", "processFile", " uploadDir", "UploadFile", "UploadFiles", "processfile", "Uploadfile", "uploadfile", "uploadFiles", "uploadDir", "processDir", " uploadfile", " uploadFiles"], "inputFile": ["InputFile", " inputfile", "inputType", "sourceLog", "targetLog", "sourcePage", "initialStream", "initialFile", "targetfile", " inputFolder", " inputDir", "InputFolder", "targetFilename", "inputFolder", "inputDir", "initialFolder", " inputType", "Inputfile", "InputStream", " inputStream", "targetFiles", "InputType", "targetDir", " inputPage", "inputPage", "targetFolder", " inputFiles", "inputfile", "initialFilename", "sourcefile", "InputFiles", "inputFilename", "sourceFolder", "inputStream", "sourceStream", " inputLog", "InputDir", "targetStream", "sourceFile", " inputFilename", "inputFiles", "targetPage", "sourceType", "inputLog"], "targetFile": ["sourceDir", "outputLine", "outputPath", "TargetLine", "outputDir", "targetfile", "targetName", " targetPath", "inputDir", " targetfile", "sourcePlace", "targetLine", "outputFiles", "targetDir", "TargetFiles", "targetFiles", "externalPath", "externalName", "sourcePath", "inputPath", "targetPlace", "TargetFile", "externalfile", "externalFile", "TargetDir", "outputName", "TargetName", "targetPath", "Targetfile", " targetDir", " targetLine", "sourceFile", "TargetPath", " targetFiles", "inputPlace", " targetName", " targetPlace"], "outputFile": ["outPath", "writeFile", "outputPath", "writeUrl", "targetQueue", "currentFile", "writeStream", "inputQueue", "outFile", " outputfile", "outputDir", "targetfile", " outputUrl", "inputFiles", "currentPlace", " outputPlace", "inputFolder", " targetFiles", "inputDir", "outputUrl", "outFolder", "outputDirectory", " outputStream", "currentfile", "outputQueue", "inputDirectory", "targetDirectory", " outputFiles", "targetFiles", " targetDirectory", "outDirectory", "outputPage", "inputPath", "outputFolder", "inputPage", "outputPlace", "Outputfile", "outputStream", "OutputDir", "outPlace", "inputfile", "outputfile", " outputDirectory", "inputUrl", " outputDir", "targetPath", "OutputFile", " targetQueue", "inputStream", " outputPage", "outfile", "writePage", "OutputFolder", "outputFiles", "currentFolder", " outputFolder", " outputPath"], "in": ["source", "init", "rec", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "serv", "inside", "read", "IN", "data", "issue", "ini", "win", "con", "io", "up", "isin", "url", "din", "is", "sub", "nin", "ins", "cin", "stream", "lin", "In", "inc", "again", "rin", "kin", "pull", "r", "err", "login", "id", "reader", "diff", "bin"], "out": ["source", "copy", "cache", "output", "table", "sync", "client", "net", "inner", "point", "s", "this", "page", "state", "println", "cmd", "one", "ex", "console", "to", "dump", "OUT", "conn", "image", "by", "data", "writer", "sys", "ger", "io", "print", "up", "n", "base", "log", "outer", "ext", "exec", "lock", "Out", "write", "outs", "inc", "again", "off", "file", "err", "r", "o", "inter", "user", "plain", "bin", "error", "co", "report"], "line": ["lf", "char", "buffer", "Line", "lines", "sync", "cell", "frame", "page", "pass", "link", "e", "word", "inline", "data", "comment", "limit", "url", "base", "name", "log", "job", "pe", "lc", "code", "split", "string", "rule", "header", "lock", "LINE", "lin", "write", "range", "ine", "block", "file", "part", "row", "entry", "le", "unit", "type", "error"], "bytes": ["ls", "eps", "Bytes", " cycles", "units", "words", "lines", "length", "bits", "ips", "s", "ines", "len", "seconds", "i", "groups", "pos", "count", "les", "ones", "bps", "binary", "odes", "values", "os", "code", "files", "zip", "number", "reads", "steps", "bs", "size", "pages", "codes", "outs", " lines", "es", "cycles", "tes", "items", "classes", "comments", "blocks", "rows"]}}
{"id1": "21224967", "id2": "12869602", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"crear": [" crea", " Creas", "generar", " Crear", "genera", "Creare", "Creas", "Crear", " creare", " Crea", " creas", " Creare", "generare", "Crea", "generas"], "result": ["match", "message", "ret", "out", "length", "feature", "mark", "ver", "date", "status", "event", "page", "success", "count", "cash", "default", "found", "record", "comment", "force", "up", "valid", "limit", "currency", "die", "counter", "number", "function", "grade", "res", "db", "Result", "score", "ure", "value", "df", "err", "response", "results", "sign", "diff", "entry", "rate", "type", "user", "error", "order"], "sql": ["fp", "sync", "session", "script", " SQL", "update", "ql", "seed", "cmd", "serv", "conn", "install", "q", "pg", "where", "dl", "comment", "statement", "up", "action", "job", "url", "base", "SQL", "log", "database", "params", "setup", "exec", "printf", "zip", "query", "sl", "string", "fn", "repl", "sq", "plan", "ssl", "join", "db", "select"], "connection": ["p", "relation", "position", "cache", "table", "client", "connected", "session", "c", "union", "config", "environment", "system", "tc", "Connection", "event", "driver", "socket", "conn", "manager", "condition", "loc", "writer", "con", "pg", "proxy", "which", "communication", "statement", "connect", "document", "error", "database", "log", "bc", "graph", "server", "function", "query", "index", "container", "cond", "lock", "engine", "BC", "collection", "Exception", "ctx", "ion", "section", "db", "context", "application"], "ps": ["p", "pre", "eps", "cs", "pt", "ss", "ups", "ppa", "ips", "po", "pse", "ds", "pos", "hs", "conn", "pps", "pg", "proxy", "PS", "vs", "gres", "cop", "pa", "ks", "pc", "os", "pe", "qs", "proc", "params", "Ps", "query", "bs", "pd", "sp", "ins", "cp", "pr", "jp", "gs", "settings", "ns", "pers", "properties", "changes", "pp", "ports", "posts", "ops"]}}
{"id1": "2518655", "id2": "18693224", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fpIn", "lsOUT", "FNOutput", "fnEx", "fnOUT", "fpOut", " fnIn", "fpEx", " fnEx", "lsFile", "fpOutput", "FNEx", " fnOUT", "fnOutput", "fpFile", " fnFile", "fnIn", "FNIn", "fnFile", "FNOut", " fnOutput", "lsOut", "lsOutput", "fpOUT"], "writer": ["work", "buffer", "writers", "output", "out", "widget", "wire", "inner", "w", "driver", "per", "writing", "ler", "word", "socket", "war", "riter", "loader", "walker", "usher", "builder", "director", "ws", "Writer", "editor", "a", "wa", "outer", "server", "fd", "writ", "wr", "worker", "handler", "layer", "nw", "write", "winner", "parser", "file", "temp", "r", "er", "key", "entry", "reader"], "i": ["p", "x", "uri", "z", "c", "f", "ai", "s", "ii", "gi", "ori", "ix", "e", "ie", "I", "k", "ci", "abi", "m", "chi", "ini", "multi", "ip", "n", "iu", "bi", "io", "si", "u", "b", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "mi", "di", "qi", "eni", "strength", "xi", "part", "fi", "key", "id", "o", "type", "v", "ri", "ti", "phi"], "fInput": ["sfOutput", " fSource", "sfFormat", "fileFormat", "fFormat", "fSource", "fileOutput", " fFormat", " fOutput", "sfinput", "sfInput", "fileSource", "sfSource", "finput", "fileinput", "fileInput", "fOutput", " finput"], "in": ["init", "ln", "inn", "gin", "out", "reading", "pin", "inner", "c", "f", "s", "input", "socket", "inside", "conn", "line", "sin", "inas", "IN", "data", "ner", "ini", "win", "n", "isin", "bin", "b", "vin", "nin", "min", "ins", "connection", "cin", "scan", "lin", "In", "inc", "again", "rin", "kin", "version", "login", "id", "reader", "din"]}}
{"id1": "13439950", "id2": "22479286", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["loadremoteFile", "loadRemoteResponse", "readStaticFiles", "loadRemoteFiles", "loadRemoteFile", "readremotefile", "readRemoteFiles", "readLocalResponse", "loadremoteFiles", "readRemotefile", "readStaticfile", "readStaticFile", "readLocalFile", "readremoteFile", "readremoteResponse", "readStaticResponse", "loadremoteResponse", "loadremotefile", "readLocalfile", "readremoteFiles", "loadRemotefile", "readRemoteResponse", "readLocalFiles"], "response": ["message", "result", "output", "json", "ss", "out", "uri", "http", "e", "i", "offer", "line", "application", "resp", "data", "example", "service", "object", "resource", "description", "next", "array", "server", "Response", "res", "body", "api", "onse", "string", "respond", "ception", "respons", "value", "answer", "request", "results", "feed", "site", "error", "status", "content", "reply"], "url": ["ls", "org", "ref", "remote", "uri", "str", "browser", "Url", "plug", "f", "i", "l", "web", "resource", "open", "io", "base", "bel", "b", "server", "host", "URL", "rl", "zip", "sl", "fr", "ur", "stream", "impl", "file", "r", "ssl", "ob", "jar", "http"], "is": ["as", "ris", "uri", "IS", "out", "str", "was", "info", "its", "are", "iss", "i", "Is", "src", "or", "iso", "in", "ib", "close", "ir", "sr", "ip", "io", "ar", "os", "b", "it", "fs", "bs", "res", "api", "sp", "fr", "ais", "ios", "es", "r", "id", "bis", "has", "ri", "http"], "br": ["ab", "result", "bro", "bridge", "arr", "bed", "str", "browser", "bh", "bar", "bb", "fb", "buf", "mr", "i", "BR", "bl", "serv", "ib", "sr", "img", "io", "be", "ber", "b", "os", "hr", "obj", "cr", "res", "body", "sp", "rb", "dr", "ch", "gr", "fr", "stream", "orb", "iter", "rt", "tr", "r", "er", "err", "ob", "reader", "cb", "rel", "http"], "s": ["p", "ls", "source", "message", "result", "su", "sb", "ps", "lines", "str", "ss", "session", "c", "f", "sym", "bytes", "e", "i", "input", "l", "services", "single", "data", "m", "strings", "resource", "rs", "ws", "sr", "n", "shell", "g", "si", "ses", "v", "u", "b", "os", "null", "sl", "res", "string", "details", "raw", "sample", "ns", "es", "r", "t", "results", "o", "sv", "site", "S", "ssl", "sf", "js", "d", "status", "content"], "eof": ["eol", "oeoh", "geore", "eeol", "Eof", "eeoh", "yeof", "eif", "EOF", "Eef", "eoh", "oeol", "geif", "yeOF", "Eoh", "ueOF", "eeaf", "Eok", "oeof", " eOF", "Eif", "ueof", "ueaf", "Eaf", "Eol", " eef", " eom", "oeok", "Eore", " eol", "ueom", " eaf", "eOF", "eaf", "yeore", "yeif", "geof", "geOF", "eom", "eeof", "Eom", "eok", "eeok", "eore", "eeef", "eef"]}}
{"id1": "9954926", "id2": "8815137", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 1, "substitutes": {"simulate": ["imulator", "Simulate", "animure", "simulator", "simulation", "imulate", "animulate", "Simulator", "animulation", "animulator", "Simure", "imure", "imulation", "Simulation", "simure"], "out": ["buffer", "cache", "session", "w", "down", "con", "comment", "base", "log", "name", "null", "pool", "post", "write", "temp", "key", "flush", "error", "pre", "group", "result", "copy", "client", "info", "view", "word", "dump", "OUT", "conn", "data", "writer", "object", "io", "up", "tmp", "obj", "now", "raw", "outs", "lib", "cli", "user", "plain", "parent", "db", "bin", "output", "table", "point", "state", "line", "sys", "resource", "outer", "gen", "string", "external", "exp", "prefix", "exit", "Out", "o", "flow", "net", "store", "page", "ex", "in", "window", "server", "list", "lock", "full", "again", "part", "err", "co", "report"], "file": ["source", "message", "filename", "buffer", "File", "fp", "output", "cache", "port", "path", "f", "page", "ile", "l", "socket", "line", "data", "loader", "in", "resource", "FILE", "url", "base", "name", "log", "b", "pe", "book", "files", "fe", "address", "connection", "rule", "handler", "stream", "queue", "full", "collection", "feed", "le", "unit", "report"], "obtainUserReputationRequest": ["obtainUserRelentionResponse", "obtainUserReputationInfo", "obtainUserReputedResponse", "obtainUserRelutationGrant", "obtainUserRepositoryrequest", "obtainUserReputedrequest", "obtainUserRepigrationGrant", "obtainUserReputableRequest", "obtainUserReputationrequest", "obtainUserReputationQuery", "obtainUserAnnigrationResponse", "obtainUserComputeRequest", "obtainUserRelutationRequest", "obtainUserComputationInfo", "obtainUserRepentionrequest", "obtainUserRepurityResponse", "obtainUserComputationEntry", "obtainUserReputionResponse", "obtainUserRepurationResponse", "obtainUserAnnigrationQuery", "obtainUserRelentionGrant", "obtainUserRepositoryRequest", "obtainUserRepentionResponse", "obtainUserComputeResponse", "obtainUserReputeResponse", "obtainUserAnnigrationRequest", "obtainUserComputeInfo", "obtainUserRepentionRequest", "obtainUserReputeGrant", "obtainUserAnnutationRequest", "obtainUserRepurationGrant", "obtainUserReputedGrant", "obtainUserComputeEntry", "obtainUserRepulationEntry", "obtainUserComputationrequest", "obtainUserRepulationInput", "obtainUserRelutationrequest", "obtainUserRelentionrequest", "obtainUserRepurationRequest", "obtainUserReputeEntry", "obtainUserComputationRequest", "obtainUserAnnigrationGrant", "obtainUserReputeInput", "obtainUserRepulationResponse", "obtainUserReputeQuery", "obtainUserRepigrationQuery", "obtainUserRepulationRequest", "obtainUserRepigrationInfo", "obtainUserRepurityEntry", "obtainUserRepurityRequest", "obtainUserRepositoryResponse", "obtainUserReputedRequest", "obtainUserReputionGrant", "obtainUserReputionRequest", "obtainUserComputerequest", "obtainUserAnnutationResponse", "obtainUserComputeInput", "obtainUserRepositoryInfo", "obtainUserRepurationQuery", "obtainUserReputationInput", "obtainUserRepigrationRequest", "obtainUserAnnutationQuery", "obtainUserReputationGrant", "obtainUserReputablerequest", "obtainUserComputationResponse", "obtainUserReputeInfo", "obtainUserReputableResponse", "obtainUserReputationEntry", "obtainUserRelentionRequest", "obtainUserRelutationResponse", "obtainUserReputeRequest", "obtainUserRepurityInput", "obtainUserRepentionGrant", "obtainUserAnnutationGrant", "obtainUserRepigrationrequest", "obtainUserComputationInput", "obtainUserRepigrationResponse", "obtainUserReputionrequest", "obtainUserReputerequest"], "obtainUserReputationResponse": ["obtainUserReputeResp", "obtainUserExpositoryResponse", "obtainUserRepurationRequest", "obtainUserRepositoryResp", "obtainUserRepurationResponse", "obtainUserRepositoryRequest", "obtainUserExpositoryResp", "obtainUserExputationResp", "obtainUserReputeResponse", "obtainUserRepurationResp", "obtainUserRepositoryResponse", "obtainUserReputeRequest", "obtainUserExputationResponse", "obtainUserReputationResp", "obtainUserExpositoryRequest", "obtainUserExputationRequest"], "rateUserRequest": ["ratePostrequest", " rateUserrequest", "gradeLineCustomer", "rateServiceCommand", "gradeLinerequest", "rateHumanrequest", "ratedUserFunction", "RateUserRequest", "gradeUserCustomer", "rateLineCustomer", "rateHumanVersion", " rateApplicationRequest", "rateUsageQuery", "rateCustomerReturn", "rateApplicationQuery", " rateClientRequest", "RateFilerequest", "rateLineResponse", "rateUserReturn", "rateuserrequest", "rateUFunction", "rateCustomerQUEST", "rateUsagerequest", "rateUsForce", "featureMachineRequest", "rateApplicationResponse", "rateUsageReturn", "rateUsageResponse", "issueCustomerQUEST", "rateFileResult", "ratedFileFunction", " rateuserQUEST", "rateUForce", "rateLineError", "rateUSERRequest", "rateUserVersion", "rateWordRequest", "rateServiceFunction", "rateUsageForce", "ratedFileRequest", "rateUSERForce", " rateApplicationResponse", "featureUserResult", "rateUserCommand", " rateuserrequest", "rateFileQUEST", " rateUserUser", "rateMachineRequest", "rateFileCommand", "rateFileFunction", "rateLineQuery", "rateUsRequest", "rateUserResult", "issueUserReturn", "rateApplicationRequest", "rateWordQuery", "rateUserQUEST", "ratePostResponse", "rateUserCustomer", "rateLineRequest", "RateFileQUEST", "issueUserForce", "featureMachinerequest", "rateUError", "rateMachineResult", "rateWordCustomer", "ratedFileQuery", "ratedUsageRequest", "rateuserQUEST", " rateClientGrant", "rateHumanResult", "rateLineQUEST", "ratedUsageQuery", "issueCustomerForce", "featureUserrequest", "rateApplicationUser", "ratedUsagerequest", "rateUsageUser", "rateFilerequest", "rateUserGrant", "rateUserFunction", "rateUResponse", "rateClientrequest", "rateUCustomer", "rateMachineVersion", "ratedUsageForce", "rateUsQUEST", "RateFileRequest", "gradeUserRequest", "gradeUserError", "gradeLineRequest", "rateFileQuery", "rateUsageQUEST", "rateLinerequest", "rateUserrequest", "rateClientGrant", " rateuserResponse", "rateServiceRequest", " rateUserGrant", "issueCustomerRequest", "rateMachinerequest", "rateUSERQUEST", "issueUserRequest", "rateWordError", "rateWordrequest", "rateUsReturn", "featureMachineVersion", "rateFileRequest", "rateHumanRequest", "RateUserQUEST", "rateUserQuery", "issueCustomerReturn", "rateFileVersion", "featureMachineResult", "ratePostRequest", "rateUrequest", "rateUserForce", "gradeUserrequest", "rateURequest", "rateLineGrant", "featureUserRequest", " rateUserQuery", "rateCustomerForce", "ratedUserCommand", "ratedUserRequest", " rateClientrequest", "ratePostQUEST", "rateFileUser", "rateUsageRequest", "ratedUserForce", "rateCustomerRequest", "RateFileResponse", "RateUserrequest", "gradeLineError", "ratedUserQuery", "rateClientRequest", " rateApplicationUser", "rateUQUEST", "rateUsageGrant", "ratedUserrequest", " rateApplicationQuery", "featureUserVersion", "rateuserRequest", "rateUCommand", "rateUserError", "ratedUserQUEST", "rateUSERrequest", "ratedFileCommand", "rateUserUser", "RateUserResponse", "rateServiceQuery", "issueUserQUEST", " rateuserRequest", "rateFileResponse", "ratedUsageQUEST", " rateUserQUEST", "rateuserResponse", "rateUQuery"], "rateUserResponse": [" rateFileResponse", "RateUserRequest", " rateUresponse", " rateApplicationData", "rateUserReply", " rateUReply", " rateFileStatus", "rateTimeCustomer", "rateFileResp", "rateCustomCustomer", " rateUserReference", " rateUserResult", "rateCustomerResponse", "rateClientStatus", " rateUResponse", "rateuserStatus", "rateApplicationResponse", "rateTimeResponse", "rateApplicationReference", "rateFileResult", "rateCustomerResp", "RateUserCustomer", "RateUserStatus", "RateUserResource", "rateTimeStatus", "rateCustomerData", "RateTimeCustomer", " rateApplicationResponse", "rateApplicationResp", "rateUsersResource", " rateUResp", "rateUsersResponse", "rateUserResult", " rateFileResp", "rateuserData", "RateTimeStatus", "RateUserResp", " rateApplicationResp", "rateuserResult", "rateUserCustomer", "rateUsersResult", " rateApplicationReference", "rateUsersRequest", "rateTimeResp", "rateFileStatus", "rateUReply", "RateTimeResponse", " rateUserReply", "rateUResponse", "rateClientResp", "rateCustomResponse", "rateUresponse", "rateFileReply", "rateCustomStatus", "rateCustomerResource", "rateClientResponse", " rateUserData", "rateUsersStatus", "rateUserResource", "rateuserReference", "rateUserData", "rateUserReference", "RateTimeResp", " rateUserresponse", "rateFileresponse", "rateCustomerRequest", " rateFileResult", "rateuserresponse", "rateUserResp", "rateuserReply", "rateApplicationData", " rateUserResp", " rateUserStatus", "rateUserresponse", "rateCustomerReference", "rateuserResp", "rateUResp", "rateCustomResp", "rateClientCustomer", "RateUserResponse", "rateUsersResp", "rateFileResponse", "rateuserResponse", "rateUserStatus"], "fis": ["bIs", "Fiss", "fiss", " fiss", "bris", "sfis", "biss", "fris", "sfIs", "Fis", " fIs", "Fris", "sfris", "fIs", "sfiss", "FIs", "bis", " fris"], "br": ["ref", "bridge", "buffer", "result", " tr", "arr", " bio", "sw", "str", "bro", "browser", "bed", "buf", "ler", "BR", "bl", "bp", "Br", "io", "bc", "ber", "b", "hr", "cr", "bs", "wr", "res", "ch", "sp", "rb", "brush", "body", "dr", "gr", "fr", "pr", "lr", "Reader", "tr", " fr", "r", "err", "ob", "reader", "fin"], "call": ["flow", "text", "contact", "doc", "message", "called", "work", "create", "buffer", "Line", "result", "output", "str", "phone", "push", "check", "cell", "claim", "c", "load", "cat", "f", "invoke", "info", "charge", "use", "e", "input", "line", "loc", "data", "throw", "ell", "comment", "play", "voice", "callback", "url", "name", "code", "msg", "query", "sc", "address", "body", "ack", "Call", "string", "calling", "cl", "fax", "cod", "cu", "request", "response", "roll", "ck", "type", "user", "xml", "co"]}}
{"id1": "11477906", "id2": "19739421", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationConfiguration", "getDefaultParameters", "loadApplicationSettings", "getDefaultConfiguration", "getdefaultParameters", "loadGlobalSettings", "loaddefaultsettings", "loadGlobalParameters", "loadDefaultConfiguration", "getDefaultsettings", "loadApplicationParameters", "loadGlobalsettings", "getDefaultSettings", "loadApplicationsettings", "loadGlobalConfiguration", "loadDefaultParameters", "loadDefaultsettings", "getdefaultConfiguration", "loaddefaultConfiguration", "getdefaultSettings", "loaddefaultParameters", "getdefaultsettings", "loaddefaultSettings"], "configFileName": ["configModuleLocation", "configPlaceUrl", "configFullUrl", "configPlaceString", "configFilesType", "configFilesLocation", "configFileUrl", "configFullLocation", "fileFILETime", "configFILEName", "configFILETime", "fileFILEType", "configFilesTime", "fileFileType", "ConfigFileLocation", "configFileString", "configFullName", "configFilenameName", "configFileLocation", "configModuleString", "ConfigFileString", "configPlaceName", "configFilenameType", "fileFILEName", "configModuleUrl", "ConfigModuleLocation", "configPlaceLocation", "configFileType", "ConfigFileName", "configModuleName", "fileFileTime", "configFILELocation", "configFILEType", "configFilesName", "fileFILELocation", "ConfigModuleName", "configFilenameLocation", "ConfigFileUrl", "fileFileLocation", "configFullString", "configFilenameTime", "ConfigModuleString", "configFileTime", "fileFileName", "ConfigModuleUrl"], "in": ["work", "source", "as", "init", "inn", "pin", "inner", "f", "config", "this", "plus", "pass", "i", "input", "socket", "conn", "inside", "read", "IN", "data", "m", "con", "ini", "resource", "n", "up", "a", "url", "base", "din", "pc", "log", "it", "is", "nin", "ins", "cin", "stream", "In", "inc", "again", "pull", "err", "r", "login", "ssl", "id", "reader", "diff", "bin"], "out": [" output", "copy", "output", "set", "sync", "client", " back", "net", "c", "instance", " file", "point", "config", "all", "back", "f", "view", "timeout", "s", "ex", "one", "this", "to", "socket", "OUT", "conn", "image", "default", "data", "writer", "object", "able", "up", "io", "and", "log", "name", "null", "ou", "ext", "server", "it", "exec", "obj", "password", "string", "connection", "exp", "prefix", "Out", "write", "outs", "inc", "again", "off", "file", "lib", "version", "err", "t", "o", "user", "parent", "bin", "error", "d"]}}
{"id1": "5707205", "id2": "14038176", "code1": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"run": ["work", "create", "app", "client", "check", "load", "update", "show", "running", "Run", "build", "process", "find", "url", "search", "runner", "server", "exec", "query", "worker", "submit", "test", "loop", "request", "launch", "start"], "dbHelper": ["DbHelper", "dbFactory", "dbSupport", "DBManager", " dbSupport", " dbServer", " dbFactory", "DbSupport", "DBSupport", "dbManager", "DbServer", "DBServer", "DbFactory", "DBHelper", "DbManager", "DBFactory", " dbManager", "dbServer"], "notifyId": [" notifyCount", "noteifyId", "notiqId", "notificationID", "notificationCount", "noteifyUrl", "notounceCount", "notiqID", "noteifierID", "notifierId", "notifierID", "noteifierId", "notificationUrl", "noteifierUrl", "notifyID", "notounceID", "notifyUrl", "noteifyID", "notounceId", "notificationId", "notifierUrl", " notifyID", "notiqUrl", "notifyCount"], "host": ["work", "source", "message", "port", "path", "username", "home", "domain", "root", "project", "localhost", "loc", "addr", "service", "object", "location", "auth", "hub", "proxy", "mac", "format", "ip", "valid", "url", "database", "name", "null", "server", "address", "h", "string", "connection", "prefix", "part", "key", "feed", "id", "bind", "user", "node", "target", "pattern", "Host", "http"], "sp": ["lp", "pre", "tp", "sb", "sw", "fp", "se", "mp", "py", "isp", "asp", "np", "per", "manager", "serv", "bp", "service", "sr", "pa", "gp", "sup", "si", "sm", "SP", "sc", "esp", "sl", "Sp", "sk", "scope", "profile", "hp", "ap", "sh", "jp", "policy", "html", " SP", "space", "bsp", "spe", "pp", "op", "sf", "db", "jar", "osp"], "userAgent": [" useragent", " userData", " userAg", "useragent", "useData", "sourceAgent", "useagent", " userText", "useAg", "sourceText", "sourceAg", "useText", "userText", "UserInfo", "userInfo", "userAg", "Useragent", "UserAgent", "userData", "useInfo", "sourceData", "sourceagent", " userInfo", "useAgent"], "ahc": ["ihc", "ehl", "ehc", "ohp", "chec", "ehb", "chef", "ihci", "ohf", "chepc", "ihf", "ahci", "ihpc", "ohc", "checi", "ahl", "ohb", "ohpc", "ahpc", "yahl", "yahp", "ohci", "ahp", "ahb", "ahf", "ehp", "yahb", "ohl", "yahc"], "uri": ["source", "message", "uni", "remote", "filename", "absolute", "browser", "license", "username", "system", "environment", "gi", "domain", "component", "archive", "ori", " URI", "image", "or", "uno", "iso", "object", "resource", "location", "done", "consumer", "storage", "directory", "document", "url", "database", "base", "server", "ui", "query", "address", "pi", "api", "term", "iri", "verb", "connection", "direction", "string", "future", "prefix", "di", "range", "general", "universal", "route", "cli", "ilo", "URI", "site", "doi", "controller", "unit", "ri", "http"], "norm": ["uni", "normal", "flat", "orr", "known", "sync", "generic", "orient", "union", "front", "info", "system", "NOR", "domain", "bas", "ord", "our", "ori", "real", "line", "cdn", "nor", "global", "process", "or", "resource", "transform", "orm", "core", "url", "base", "cos", "chrom", "gen", "center", "Normal", "function", "term", "dist", "neg", "orbit", "rom", "origin", "Norm", "coll", "radius", "raw", "range", "orig", "coord", "desc", "route", "custom", "unit", "common", "parent", "cb", "handle"], "get": ["message", "method", "call", "create", "set", "client", "check", "invoke", "update", "gi", "view", "show", "send", "read", "req", "service", "object", "resource", "open", "find", "url", "search", "gen", "post", "query", "getting", "api", "body", "GET", "Get", "like", "request", " Get", "r", "pull", "start", "handle"], "response": ["message", "method", "relation", "result", "output", "json", "client", "translation", "successful", "status", "page", "success", "application", "resp", "service", "object", "resource", "reply", "next", "document", "server", "Response", "api", "body", "connection", "onse", "respond", "ception", "handler", "respons", "full", "received", "collection", "version", "request", "wave", "feed", "error", "report", "http"], "entity": ["ent", "message", "result", "cache", "json", "output", "instance", "info", "status", "environment", "event", "component", "person", "e", "image", "service", "object", "resource", "metadata", "node", "action", "error", "document", "security", "server", "article", "query", "api", "body", "string", "connection", "element", "el", "file", "entry", "type", "xml", "Entity", "content", "application"], "baos": ["daas", "BAo", "daos", "nais", "waOS", "laom", "BAios", "BAis", "waas", "laOS", "pao", "baas", "dao", " baios", " baom", "laos", "naios", "daOS", " bao", "baOS", "paOS", "taOS", " baOS", "naos", "bais", "baios", "waos", "paom", "taas", "nao", "taos", "wao", " bais", "tao", "lao", "bao", "BAos", "paos", "baom"], "data": ["text", "message", "parts", "style", "result", "buffer", "media", "output", "json", "DATA", "memory", "info", "bytes", "input", "image", "complete", "record", "object", "resource", "done", "format", "ata", "description", "action", "url", "database", "array", "dat", "body", "string", "batch", "html", "value", "space", "part", "partial", "key", "results", "layout", "reader", "bin", "pattern", "content"], "i": ["x", "uni", "field", "c", "ni", "f", "ai", "info", "ii", "gi", "e", "l", "I", "ci", "ind", "yi", "abi", "ini", "chi", "multi", "ip", "n", "bi", "io", "si", "u", "b", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "mi", "di", "eni", "y", "xi", "part", "fi", "mu", "slice", "id", "o", "end", "v", "start", "ri", "ti", "phi"], "p": ["lp", "pre", "ps", "parse", "py", "c", "f", "np", "point", "per", "po", "l", "m", "pa", "ip", "n", "g", "pc", "u", "pe", "proc", "api", "j", "string", "patch", "cp", "pr", "ap", "parser", "part", "pat", "t", "pp", "op", "r", "o", "v", "d", "pattern", "P"], "sysMillis": ["sysMinis", " systemmillis", " systemmilles", "sysMins", " systemmills", "sysmillis", "sysmilles", "sysmilli", " systemmilli", "sysmills", "sysMills", "sysMili", " systemMilli", "sysMiles", "sysMilli", "sysMini", "sysMils", " systemMillis", " systemMilles", "sysMilis", "sysMines", " systemMills", "sysMilles"], "errorOccurred": ["erroroccurrence", "erroroccur", "errorOccurrence", "errorIssurrence", "errorOccur", " errorOccurrence", "errorIssurred", " errorOccured", "errorAccured", "errorAccur", "errorAccurred", "erroroccurred", " errorOccur", "erroroccured", "errorIssur", "errorIssured", "errorOccured", "errorAccurrence"]}}
{"id1": "20247400", "id2": "9846843", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"in": ["p", "source", "gin", "inn", "token", "client", "inner", "c", "f", "config", "s", "this", "pass", "i", "input", "l", "socket", "image", "IN", "data", "con", "win", "n", "isin", "a", "din", "b", "nin", "ins", "h", "connection", "stream", "In", "inc", "again", "parent", "part", "r", "login", "diff", "reader", "bin"], "out": ["flow", "source", "group", "call", "style", "cache", "output", "str", "client", "inner", "page", "w", "ex", "i", "word", "console", "dump", "OUT", "image", "line", "socket", "conn", "writer", "sys", "comment", "print", "io", "up", "window", "log", "name", "outer", "server", "ext", "obj", "exec", "msg", "pool", "list", "connection", "exp", "channel", "lock", "prefix", "Out", "write", "again", "off", "file", "temp", "err", "r", "o", "debug", "user", "v", "inc", "error"], "buffer": ["flow", "source", "result", "cache", "output", "length", "bar", "f", "config", "buff", "pad", "buf", "fb", "slave", "input", "uffer", "count", "border", "read", "data", "writer", "loader", "abi", "binary", "limit", "document", "base", "window", "b", "null", "server", "transfer", "Buffer", "header", "channel", "size", "queue", "layer", "batch", "reference", "iter", "pause", "wave", "feed", "slice", "reader", "flush", "bin", "offset", "context"]}}
{"id1": "14191679", "id2": "2199604", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnodeReturn", "EncodReturns", "EncodReturn", "EncodData", "EncodeReturns", "EnccodeData", "EnodeResult", "EnodeReturns", "EnodedResult", "EncodResult", "EnodedReturns", "EnodedReturn", "EnodeData", "EnccodeResult", "EnccodeReturn", "EnccodeReturns", "EnodedData", "EncodeResult", "EncodeData"], "IOException": ["DownloadException", "DownloadError", " IOception", "Downloadception", "IOception", "IPError", "IPException", "IOError", " IOError", "IPception"], "c": ["p", "gc", "cs", "xc", "cache", "uc", "client", "cf", "ac", "f", "e", "l", "ci", "m", "ce", "ec", "n", "pc", "conv", "lc", "proc", "C", "u", "cr", "b", "sc", "ch", "cur", "cc", "nc", "cp", "chain", "enc", "cpp", "fc", "cd", "cu", "y", "mc", "t", "r", "ct", "d", "cmp", "dc"], "tmpf": ["tempcf", " tmpfs", "poraryf", "zipf", "zipfs", "tmpfd", "tempfs", "empfs", "tempF", " tmpF", "vmf", "tmpfs", " tmpcf", " tmpfen", "vmF", "empf", "tmpF", "tempfen", "porarycf", "vmcf", "zipF", "poraryfen", "vmfs", "poraryF", "tempfd", "empF", "tmpcf", "tempf", "tmpfen", "zipfd", "empfd"], "cw": ["Cw", " cwa", "cws", "cwd", "rcwe", "cwb", "pW", "rcwd", " csw", "pw", "Cws", "ffw", " cW", "fws", "csw", "cwa", "fwa", "pwa", "psw", "lcw", "fw", "cW", "lcwe", "rcw", " cwd", "lcwd", " cwb", "lcwb", " cwe", "cfw", " cws", "Csw", "Cfw", "Cwa", "cwe", "rcwb", "CW", " cfw"], "encdata": [" encData", "envdata", "extData", "installData", "envdat", "installdat", "secData", "encdatabase", "envreader", "extdat", "secdata", "extdata", "envkeys", "extdatabase", "encData", "Encdata", "enccache", " encdatabase", " encdat", "incdata", "incroot", "EncData", " encreader", "encreader", "envData", "encdat", "installdatabase", "Enckeys", "enckeys", "Encdat", "inccache", "installdata", "secdat", " encroot", " enccache", "seckeys", "encroot", "increader", "envroot", "envcache"], "pigdata": ["pagresults", "pippcache", "pigscache", "pigrdata", "pocresource", "pagdata", "pocData", "picresource", "PigData", "PigsData", "Pigsla", "Pigresults", "pigrData", "pichdata", "Pigresource", "Pigsdat", "pocdata", "PibData", "Pigscache", "pigresults", "picdat", "pippdata", "Pigdata", "pichcache", "pagData", "pigdat", "pigresource", "pigData", "Pigdat", "picData", "pigrresults", "pichData", "pigsla", "Pibresource", "pigcache", "pigsdat", "pocdat", "pigsdata", "pippData", "Pigla", "Pibdata", "pigsData", "pichla", "pibdat", "pigrdat", "pigsresults", "pibdata", "pigla", "pibresource", "pippla", "Pigsdata", "pibData", "pagdat", "Pigsresults", "Pibdat", "picdata", "Pigcache"], "pigroute": ["pibrouter", "apibrouter", "pirmroute", "miarote", "pigrationoute", "pibrote", "pigrationouter", "apigrouter", "pigrationange", "pipeloute", "piarune", "apibroute", "fibrote", "fibrange", "migroute", "pibrroute", "pirmouter", "pigerote", "figrroute", "pigrouter", "pigerune", "piarouting", "migrote", "figrote", "pipelote", "pipelouting", "pigeroute", "pibrange", "pigrroute", "pirmouting", "pirmoute", "pigrote", "apibrouting", "migrouting", "figrange", "pigerouting", "miaroute", "pigrange", "apibrroute", "apigroute", "pigrune", "pipelange", "pibroute", "migrune", "piaroute", "miarouting", "figroute", "miarune", "pigrationouting", "pipelune", "pibrouting", "pigrationote", "piarote", "pigrationroute", "pipelroute", "apigrroute", "pigrouting", "apigrouting", "fibrroute", "fibroute"], "fos": ["refos", "foes", "Fo", "Foes", " fops", "to", "pos", " fOS", "Fos", " foes", "pOS", "fo", "poes", "toc", " fo", "toes", "refOS", "Foc", "refoes", "tos", "pops", "fOS", "fops", "refops"], "foc": ["infocol", "Focol", "infoc", " focol", "infic", " fac", "infac", "Fec", "fac", "Fac", "Foc", "fec", "focol", " fec", "infec", "Fic"], "fis": ["infi", "Fi", "cig", "infic", "fics", "Fis", "infis", "Fics", "Fig", " fi", "cis", "fi", "Fic", " fig", "cic", "fig", " fics", "cics", "infics"], "fic": ["rfics", "Fisc", "cfoc", "infoc", "Fico", " fico", " fisc", "rfoc", "poc", "cfic", "infic", " fac", "fico", "cfics", "fics", "pis", "Fis", "cfico", "rfic", "pic", "Fics", "cfis", "fac", "Fac", "pac", "Foc", "fisc", "Fic", "rfis", "infisc", " fics", "infics"]}}
{"id1": "1133123", "id2": "11154758", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openConnection": ["createChannel", "closeConn", "openConnector", "OpenConnect", "closeConnect", "createConnector", "OpenConnector", "OpenConn", "closeConnector", "openChannel", "openConnect", "OpenChannel", "closeChannel", "createConnect", "createConn", "OpenConnection", "createConnection", "openConn", "closeConnection"], "url": ["source", "buffer", "uri", "str", "path", "Url", "config", "f", "this", "link", "options", "l", "image", "loc", "data", "service", "object", "location", "resource", "proxy", "limit", "base", "name", "log", "bel", "null", "server", "host", "URL", "address", "sl", "connection", "channel", "el", "ll", "iter", "file", "ssl", "id", "http"]}}
{"id1": "20310134", "id2": "7908169", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyChannel", "copyfile", "CopyChannel", "copyFiles", "CopyFile", "copyChannel", "transferfile", "transferFile", "transferChannel", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "in": ["work", "source", "as", "buffer", "inn", "inner", "c", "config", "ex", "i", "input", "l", "image", "IN", "data", "m", "io", "url", "base", "name", "query", "min", "index", "ins", "lock", "lin", "In", "inc", "again", "file", "login", "id", "reader", "diff", "bin", "ic"], "out": ["p", "x", "dot", "call", "cache", "output", "c", "point", "page", "w", "ex", "OUT", "conn", "image", "default", "writer", "resource", "img", "io", "n", "base", "name", "b", "ext", "server", "exec", "string", "external", "connection", "plain", "prefix", "Out", "write", "outs", "again", "off", "file", "o", "user", "v"], "inChannel": ["outQueue", "Inchannel", "binGate", "outchannel", "insChannel", "iniChan", "inChan", "insConnection", "loginStream", "InChan", " inchannel", "loginChannel", "inputChan", "inputChannel", "INChannel", " inQueue", "loginchannel", "INChan", "INStream", "InQueue", "inputConnection", "binChannel", "InStream", "inQueue", "binchannel", "iniChannel", "inConnection", "InGate", " inChan", "iniStream", "InChannel", "INConnection", "inGate", "iniGate", "inchannel", "insChan", "inputStream", "insStream", "loginChan", "outChan", "outStream", "binChan", "INchannel", "inStream", "binStream"], "outChannel": [" outGate", "outchannel", "netGate", "OutChan", "inChan", "ouGate", "netChan", " outStream", "ouChan", "outputchannel", "ouChannel", "Outchannel", "outGate", "inConnection", "outConnection", "netStream", "outChar", " outChan", " outchannel", "outputStream", "outputGate", "inGate", "inchannel", "netChannel", "inChar", "outputChannel", "OutConnection", "outputChar", "outChan", "outStream", " outConnection", "outputChan", "ouchannel", "OutChannel", " outChar", "inStream"]}}
{"id1": "20247400", "id2": "12766377", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "label": 0, "substitutes": {"in": ["p", "source", "gin", "inn", "token", "client", "inner", "c", "f", "config", "s", "this", "pass", "i", "input", "l", "socket", "image", "IN", "data", "con", "win", "n", "isin", "a", "din", "b", "nin", "ins", "h", "connection", "stream", "In", "inc", "again", "parent", "part", "r", "login", "diff", "reader", "bin"], "out": ["flow", "source", "group", "call", "style", "cache", "output", "str", "client", "inner", "page", "w", "ex", "i", "word", "console", "dump", "OUT", "image", "line", "socket", "conn", "writer", "sys", "comment", "print", "io", "up", "window", "log", "name", "outer", "server", "ext", "obj", "exec", "msg", "pool", "list", "connection", "exp", "channel", "lock", "prefix", "Out", "write", "again", "off", "file", "temp", "err", "r", "o", "debug", "user", "v", "inc", "error"], "buffer": ["flow", "source", "result", "cache", "output", "length", "bar", "f", "config", "buff", "pad", "buf", "fb", "slave", "input", "uffer", "count", "border", "read", "data", "writer", "loader", "abi", "binary", "limit", "document", "base", "window", "b", "null", "server", "transfer", "Buffer", "header", "channel", "size", "queue", "layer", "batch", "reference", "iter", "pause", "wave", "feed", "slice", "reader", "flush", "bin", "offset", "context"]}}
{"id1": "22441244", "id2": "16378239", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 1, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "15797402", "id2": "10391753", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"parse": [" parser", "se", "set", "arse", "cover", "processing", "load", "view", "read", "process", "service", "Parser", "transform", "fork", "print", "pc", " transform", "handle", "split", "worker", "patch", " convert", "scan", "wrap", " dispatch", "raw", "parser", " analyse", "replace", "php", " process", "save", "request", " serve", "pack", " split", "rate", "apply", "xml", " parsing", "report", " rewrite", "http"], "stream": ["source", "message", "form", "remote", "video", "client", "inner", "load", "download", "through", "view", "content", "input", "src", "image", "down", "read", "loader", "data", "writer", "in", "resource", "document", "url", "server", "upload", "Stream", "channel", "stack", "raw", "sample", "file", "temp", "feed", "response", "reader", "iterator", "handle", "draw", "http"], "handler": ["monitor", "client", "info", "event", "driver", "processor", "pointer", "manager", "default", "data", "writer", "loader", "service", "format", "base", "phase", "server", "host", "hand", "function", "connection", "h", "channel", "di", "handled", "layer", "wrapper", "parser", "Handler", "collection", "response", "controller", "reader", "ctx", "parent", "handle", "application"], "metadata": ["source", "adata", "message", "management", "property", "md", "uri", "monitor", "json", "config", "met", "info", "state", "component", "content", "processor", "manager", "meta", "material", "metry", "data", "m", "map", "module", "resource", "storage", "mx", "directory", "document", "database", "subject", "params", "header", "connection", "mon", "managed", "mi", "di", "plugin", "mt", "parser", "attribute", "collection", "properties", "template", "runtime", "ctx", "xml"], "context": ["text", "message", "method", "concept", "translation", "instance", "config", "system", "environment", "kernel", "event", "component", "processor", "command", "txt", "manager", "Context", "tx", "data", "object", "resource", "proxy", "document", "subject", " Context", "scope", "connection", "element", " contexts", "collection", "mc", "request", "entry", "reader", "ctx", "parent", "xml", "cmp", "content"], "name": ["work", "source", "message", "call", "filename", "large", "sync", "path", "ame", "alias", "NAME", "model", "word", "Name", "image", "none", "default", "data", "names", "m", "in", "object", "resource", "missing", "comment", "old", "on", "n", "action", "class", "url", "base", "job", "search", "null", "label", "code", "address", "api", "child", "time", "string", "connection", "size", "prefix", "full", "named", "file", "version", "part", "route", "key", "id", "type", "common", "no", "active"], "out": ["source", "result", "copy", "output", "client", "sync", "path", "ray", "instance", "page", "extra", "ex", "socket", "OUT", "conn", "line", "manager", "image", "data", "writer", "in", "object", "resource", "builder", "io", "window", "url", "cos", "null", "server", "ext", "obj", "pool", "child", "connection", "exp", "channel", "plain", "Out", "outs", "again", "file", "lib", "temp", "err", "o", "user", "flush", "bin"]}}
{"id1": "20073619", "id2": "11562165", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"getPagina": ["getPaguina", "getPaminate", "getChangine", "getPanginate", "getChagira", "getChaginate", "getPaginate", "getChagina", "getPangira", "getChagine", "getChangina", "getChangira", "getPamira", "getChanginate", "getPangine", "getPagine", "getPamina", "getPaguira", "getPamine", "getPagira", "getPangina", "getPaguine", "getPaguinate"], "strurl": ["strUrl", "StrUrl", "strURL", "wrstr", "wrstring", "ststr", "Strurl", "STRstring", "stristring", "wrURL", "arrhttp", "arrstr", "strhttp", "striURL", "stUrl", "sturl", "arrurl", "striurl", "Strstr", "arrUrl", "strstring", "wrurl", "STRstr", "sthttp", "STRURL", "Strhttp", "strstr", "STRurl", "stristr"], "resp": ["p", "lp", "ref", "ret", "result", "remote", "rec", "news", "json", "bb", "model", "page", "wp", "success", "serv", "conn", "rest", "default", "req", "www", "dest", "Resp", "reason", "Response", "host", "obj", "fe", "rep", "esp", "res", "api", "sp", "zip", "rss", "msg", "exp", "respond", "fr", "pretty", "coll", "comp", "respons", "html", "part", "err", "response", "pp", "rel", "rev", "rh", "esi", "cmp", "report", "content", "reply"], "url": ["ls", "source", "org", "gl", "buffer", "uri", "path", "Url", "f", "ball", "page", "e", "i", "l", "socket", "image", "web", "service", "resource", "open", "io", "base", "log", "inf", "b", "bel", "server", "job", "URL", "rl", "sl", "connection", "ur", "stream", "ll", "file", "ssl", "r", "entry", "user", "http"], "in": ["source", "as", "init", "into", "rec", "inn", "out", "gin", "cf", "inner", "c", "ac", "f", "s", "e", "i", "input", "l", "inside", "image", "IN", "ini", "con", "ar", "din", "b", "it", "is", "nin", "ins", "fr", "stream", "el", "lin", "In", "impl", "inc", "again", "file", "r", "err", "login", "id", "reader", "bin", "d", "doc"], "str": ["p", "text", "char", "rec", "arr", "st", "br", "c", "Str", "f", "s", "rr", "e", "i", "l", "line", "STR", "stri", "read", "data", "rs", "sr", "lc", "code", "obj", "cr", "wr", "sl", "sp", "dr", "cur", "string", "div", "fr", "enc", "cl", "pr", "coll", "raw", "iter", "tr", "err", "r", "reader", "doc"]}}
{"id1": "8087001", "id2": "3745402", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generateStackHeaderKey", "generateStackHeaderkey", "generatestackhashkey", "generatestackhashString", "generatestackHashString", "generateStackHashkey", "generateStackhashkey", "generateStackHashKeys", "generateStackHeaderKeys", "generateStackHashString", "generateStackhashKey", "generatestackhashKey", "generateStackHeaderString", "generatestackHashkey", "generateStackhashKeys", "generatestackHashKey", "generatestackhashKeys", "generateStackhashString", "generatestackHashKeys"], "e": ["p", "x", "est", "me", "se", "ace", "c", "f", "this", "event", "ex", "ie", "enter", "exc", "ele", "et", "oe", "ed", "E", "m", "ze", "ec", "n", "a", "b", "pe", "esi", "exec", "fe", "body", "ef", "h", "he", "ception", "element", "ee", "el", "ae", "en", "es", "ev", "t", "r", "err", "er", "o", "Exception", "error", "d", "ea"], "digest": [" digator", " digenge", "decature", "mdate", "Digusher", "Signate", "Digester", "mder", "mdested", " digher", "Signature", "Signester", "Signest", "logest", "Digenge", " Digator", " digusher", "digested", "digusher", "digge", "mdester", "digenge", "digate", "Diger", " Digest", "logher", "decest", "logester", " Digested", " Digester", "digature", "Digator", " digge", "diger", "mdenge", " diger", "Digge", "Digest", "decester", "mdature", "digator", " digested", "Digested", "decate", "mdest", "logge", "digester", " digester", "digher", "mdusher", "Digher"], "hash": ["dot", "text", "message", "history", "bh", "hed", "result", "ashes", "ash", "f", "dig", "image", "build", "kh", "data", "ph", "total", "mac", "base", "v", "array", "b", "Hash", "code", "sha", "hex", "body", "h", "string", "header", "sum", "sh", "ha", "value", "key", "her", "rh"], "rtn": ["RTnin", "RTb", "vrns", "ntc", "ortne", "txc", "ntn", "rtne", "txn", "retns", "RTns", "ntnin", "latne", "RTpn", "RTn", "retn", "rdn", "gtN", "rdns", "rtN", "rtnn", "rdN", "retN", "ntpn", "RTN", "gtn", "txN", "txnin", "rtb", "ntN", "latn", "ortN", "rdb", "RTne", "ntb", "latN", "gtpn", "RTc", "rtc", "gtb", "rtpn", "vrne", "ortnn", "vrnn", "retb", "RTnn", "ortn", "vrN", "rtns", "rtnin", "latns", "vrn"]}}
{"id1": "10451698", "id2": "16590954", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "create", "remote", "sync", "py", "paste", "load", "update", "download", "cat", "archive", "dump", "move", "drop", "process", "cop", "clone", "rm", "clip", "share", "change", "transfer", "split", "zip", "Copy", "list", "lock", "cp", "write", "replace", "file", "parent", "part", "ignore", "ssh", "type", "get", "delete", "run"], "source": ["filename", "result", "flat", "cache", "current", "client", "remote", "path", "config", "info", "model", "view", "seed", "slave", "use", "plus", "root", "ie", "ource", "src", "project", "SOURCE", "image", "data", "Source", "service", "object", "from", "resource", "ce", "proxy", "folder", "storage", "directory", "class", "document", "url", "name", "null", "server", "secure", "string", "scope", "connection", "section", "stream", "iter", "file", "slice", "sf", "reader", "site", "unit", "parent", "start", "archive", "target"], "destinationDirectory": ["destificationDir", "destributionPath", "destributionHome", "destinationFile", "DestributionDirectory", "DestributionDir", "DestinationPoint", "DestinationDirectory", "destarationDirectory", "destructionDir", " destinationsFolder", "DestinationPath", "destinationPath", "DestinationHome", "DestinationFolder", "destinationsFile", "destinationsDirectory", "destificationHome", "DestributionPath", "destippingHome", "destructionFile", "destributionDir", "destinatorPath", "destinationDir", "destinatorPoint", "destributionFile", "destarationPoint", "DestributionHome", " destinationsDirectory", "destippingFolder", "destificationFolder", " destinationFolder", " destinationsFile", "destarationPath", "DestinationDir", "destributionDirectory", "destinationFolder", " destinationFile", "destructionFolder", "destinationsFolder", "destippingDirectory", "destructionDirectory", "destinatorDirectory", "DestributionPoint", "destinationsDir", "destributionFolder", "DestributionFolder", " destinationDir", "destificationDirectory", " destinationsDir", "destippingDir", "destributionPoint", "destinationPoint", "destinationHome"], "newDir": ["newFolder", " newdir", "NewFolder", " newFolder", "nextDirectory", "nextDir", "nextFolder", "nextdir", "NewDirectory", " newDirectory", "nextFile", "NewFile", "newDirectory", "newdir", "Newdir", "NewDir"], "children": ["ren", "tests", "ums", "rules", "filename", " Children", "words", "uc", "current", "father", "kids", "iblings", "scenes", "Children", "ools", "balls", "projects", "loc", "data", "names", "web", "parents", "other", "which", "opens", "values", "url", "roots", "iv", "files", "sub", "members", "child", "each", "ins", "list", "pages", "blocks", "begin", "ul", "sort", "collection", "mount", "when", "items", "pes", "parent", "events", "packages", "rows", "content"], "i": ["p", "x", "uri", "inner", "ai", "f", "gi", "ii", "info", "ori", "ix", "e", "ie", "I", "k", "ci", "m", "ini", "in", "q", "multi", "ip", "iu", "n", "io", "si", "u", "b", "ti", "it", "iv", "lc", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "mi", "di", "qi", "y", "xi", "part", "fi", "key", "slice", "mu", "o", "id", "end", "type", "v", "start", "ri", "d"], "newFile": ["newSource", " newSourceFile", "oldFile", "Newfile", "createFile", "nextfile", "oldDirectory", "newfile", "nextSourceFile", "createfile", "nextSource", " newFiles", "newFiles", "oldDir", "nextDir", "NewFiles", " newfile", "NewDirectory", " newDirectory", "NewSource", "createDir", "nextFile", "createSource", "newSourceFile", "NewSourceFile", "NewFile", "newDirectory", "nextFiles", "oldFiles", "NewDir"], "output": ["flow", "result", "current", "out", "generated", "generation", "update", "config", "kernel", "page", "four", "console", "control", "socket", "image", "complete", "writer", "web", "service", "object", "resource", "other", "binary", "core", "display", "ou", "outer", "change", "operation", "address", "connection", "external", "option", "write", "again", "Output", "put", "file", "temp", "ilo", "response", "o", "unit", "after", "parent", "oper", "error", "target", "application"], "input": ["flow", "work", "text", "form", "buffer", "current", "out", "client", "inner", "instance", "config", "before", "this", "plus", "Input", "socket", "keep", "image", "data", "in", "resource", "storage", "self", "operator", "print", "ink", "inf", "exec", "child", "index", "ack", "connection", "stream", "raw", "temp", "request", "pull", "feed", "reader", "parent", "inc", "error", "audio", "context", "http"], "buff": ["text", "char", "buffer", "shape", "uf", "length", "cf", "hello", "load", "f", "bb", "pad", "fb", "gz", "buf", "info", "back", "cmd", "txt", "count", "ff", "cast", "data", "ph", "comment", "b", "bound", "fe", "oct", "rb", "cur", "gb", "comb", "uff", "cp", "batch", "cod", "bug", "feed", "slice", "pack", "ob", "boot", "Buff", "bind", "flush", "bin", "cb"], "read": ["text", "x", "seek", "buffer", "se", "Read", "sync", "length", "reading", "check", "parse", "load", "ask", "f", "config", "lex", "len", "use", "pass", "READ", "send", "skip", "k", "count", "ind", "readable", "get", "close", "open", "play", "find", "io", "ip", "n", "and", "ink", "next", " load", "b", " write", "add", "allow", "transfer", "exec", "reads", "index", "size", "write", "en", "iter", "wait", "ok", "loop", "feed", "slice", " count", "end", "id", "type", "reader", "start", "rate", "select", "fill", "run"]}}
{"id1": "11616716", "id2": "15166511", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultAsSteam", "getCMSResultWithReader", "getCMSResultAsReader", "getCMSResultasSteam", "getCMSResponseAsFile", "getCMSResultasFile", "getCMSResultWithFile", "getCMSResultInReader", "getCMSResultasReader", "getCMSResultWithSteam", "getCMSResultAsFile", "getCMSResultasStream", "getCMSResponseasFile", "getCMSResponseasReader", "getCMSResultInStream", "getCMSResultWithStream", "getCMSResponseAsStream", "getCMSResultInSteam", "getCMSResponseasSteam", "getCMSResponseAsSteam", "getCMSResultInFile", "getCMSResponseasStream", "getCMSResponseAsReader"], "rqlQuery": ["rsqlquery", "rSQLQuery", "rQLMethod", " rqlquery", " rsqlquery", "rsqlQu", "rSQLQu", "rQLQ", "srQLquery", "rQLQu", "srQLQuery", "riliQuery", "rqlQ", " rsqlMethod", "rQLquery", "riliQu", "rqlQu", " rsqlQu", "rsqlQ", "srqlQuery", "srqlQu", "rQLQuery", "srqlquery", "rSQLMethod", "rqlMethod", "riliQ", " rqlMethod", " rqlQu", " rsqlQuery", "srQLQ", "srqlQ", "rqlquery", "srQLQu", "rSQLquery", "riliquery", "rsqlQuery", "rsqlMethod"], "osr": ["OSerr", "osrw", "iosr", " ospr", "usrs", " osrm", "osrt", "opsR", "oswer", "osssr", "cosfr", "ossrm", "yscr", "obsR", "obswer", "bosr", "oscr", "iosrs", "userr", "cosr", "ysrar", "otsrm", "OSrr", "osspr", "ospr", "losrr", "ossr", "osrs", "uspr", " oscr", "usrr", "ossrr", "osscr", "ysrt", "osserr", "cosrt", " osrr", "opsrar", "opswer", "osfr", "OSr", " osrar", "ossrt", " osfr", "bosrar", "opsr", "otssr", "losr", "bosR", "iosrw", "cosrr", "OSrt", "osrar", "obsrar", "otspr", "oserr", "ysr", "boswer", "usr", "usrw", "ossrs", "osrr", "losfr", "losrt", "usrt", "ossrw", "osrm", "obsr", " ossr", "iospr", "osR", "otsr", " osrt", "ossrar"], "url": ["ls", "source", "org", "uri", "client", "path", "Url", "f", "config", "fb", "page", "l", "socket", "blog", "web", "nl", "resource", "open", "www", "base", "b", "lc", "server", "host", "URL", "rl", "fl", "sl", "connection", "string", "channel", "ll", "file", "ssl", "r", "ob", "http"], "conn": ["p", "attr", "org", "client", "sync", "oss", "net", "cb", "c", "f", "dc", "reg", "Connection", "nt", "l", "ca", "Conn", "ci", "loc", "con", "open", "act", "ec", "n", "connect", "ann", "pc", "conv", "lc", "col", "server", "exec", "cr", "ch", "rc", "cur", "connection", "nc", "h", "fn", "cp", "rn", "enc", "coll", "pr", "wrapper", "en", "cn", "rt", "ssl", "err", "ct", "ctx", "db", "http"]}}
{"id1": "5543349", "id2": "1141361", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadMFileViaWeb": ["loadMFilesviaWeb", "loadMFileviaWeb", "loadMFileviaweb", "loadMFilesviaweb", "loadMFileViaweb", "loadMFilesViaWeb", "loadMFileUsingweb", "loadMFileUsingWeb", "loadMFilesViaweb"], "codeBase": ["CodeLocation", "CodeBase", "knowledgeFile", "knowledgeUrl", "CodeFile", " codeFile", " codebase", "Codebase", "CodeUrl", "codeFile", "addressbase", "knowledgeBase", "knowledgeLocation", "knowledgeName", "codeUrl", "addressUrl", "addressName", "knowledgebase", "CodeName", "codeLocation", "addressBase", " codeLocation", "codebase", "codeName"], "directoryAndFile": ["filenameAndFiles", "DirectoryAndFile", "directoryOrFilename", "directoryFromFile", "directoryandSourceFile", "filenameandFilename", "DirectoryOrFilename", "directoryWithFile", "directoryFromfile", "directoryandfile", "directoryAndSourceFile", "directoryAndfile", "DirectoryOrSourceFile", "filenameAndFilename", "directoryandFilename", "filenameAndFile", "DirectoryOrFile", "directoryOrFile", "filenameandFile", "directoryWithfile", "directoryAndFilename", "DirectoryAndFilename", "filenameandfile", "directoryWithFilename", "directoryandFile", "filenameAndfile", "directoryOrFiles", "DirectoryAndfile", "directoryFromSourceFile", "DirectoryAndSourceFile", "filenameandFiles", "directoryOrfile", "directoryFromFilename", "directoryOrSourceFile", "directoryWithFiles", "directoryandFiles", "directoryAndFiles", "DirectoryOrfile"], "mFileName": ["MSourceFileYear", "mFileData", "mClassFile", "mBaseData", "MSourceFileHandle", "mFileYear", "mFilePath", "mBasePath", "mLibraryHandle", "mFilenameHandle", "mFilesPath", "pFilePath", "MClassFile", "mFilenameFile", "pFunctionType", "pFunctionInfo", "mFilesInfo", "cmFilePath", "mFilesKey", "mFileHandle", "mFunctionType", "cmFilesname", "mFileType", "mStringKey", "MClassPath", "MSourceFilePath", "cmFileKey", "mLibraryPath", "mFilenameData", "mFilenameYear", "MFileFile", "MFilePath", "mClassname", "mFunctionName", "pFunctionName", "mStringName", "mFilename", "cmFilename", "mFilenamePath", "pFileType", "mSourceFilePath", "mFilesname", "MFileHandle", "mClassData", "cmFilesKey", "MClassName", "mClassInfo", "mBaseFile", "MFileYear", "cmFilesPath", "mFunctionInfo", "MSourceFileName", "mFilesType", "mFileKey", "pFunctionPath", "mBaseName", "mFilenameName", "pFileName", "pFileInfo", "MClassData", "mClassName", "mFunctionPath", "mSourceFileHandle", "mClassKey", "mSourceFileName", "mLibraryName", "cmFilesName", "mFileFile", "mLibraryYear", "mSourceFileYear", "mStringPath", "mFilesName", "mClassType", "MFileData", "MFileName", "cmFileName", "mFileInfo", "mStringname", "mClassPath"], "code": ["text", "x", "message", "buffer", "comment", " Code", "name", "zip", "fore", "Code", "header", "escape", "key", "type", "error", "go", "closure", "result", "check", "info", "use", "java", "count", "data", "module", "age", "n", "now", "codes", "cause", "test", "id", "method", "call", "expression", "done", "ce", "number", "string", "loop", "status", "content", "coded", "create", "length", "script", "c", "frame", "f", "page", "func", "callback", "class", "exec", "address", "body", "cod", "file", "xxx", "co"], "function": ["python", "form", "call", "result", "role", "expression", "fun", "output", "fp", "feature", "instance", "f", "event", "component", "word", "functional", "func", "module", "object", "service", "action", " functionality", " object", "document", "job", "class", "array", "callback", "lambda", " library", " module", "Function", "operation", "number", "variable", "string", "fn", "connection", "rule", "handler", "element", "value", "file", "lib", "ctor", "unit", "section", "error", "library"], "url": ["source", "uri", "browser", "path", "Url", "plug", "f", "update", "download", "ball", "page", "i", "l", "socket", "image", "blog", "loader", "data", "web", "resource", "base", "log", "bel", "b", "server", "URL", "sl", "address", "string", "connection", "channel", "ur", "stream", "file", "r", "ssl", "er", "feed", "key", "reader", "user", "jar", "http"], "in": ["as", "buffer", "gin", "inn", "out", "client", "inner", "c", "ac", "f", "i", "input", "socket", "serv", "image", "read", "IN", "loader", "data", "ini", "af", "io", "ar", "arin", "a", "din", "b", "is", "ins", "fr", "stream", "In", "inc", "Reader", "file", "r", "err", "er", "ssl", "login", "reader", "bin"], "inReader": [" inParser", "outParser", "InReader", "InWriter", "inRead", "outWriter", " inRead", "InRead", " inWriter", "incRead", "INReader", "InFile", "inWriter", "inParser", "incWriter", " inFile", "INFile", "inFile", "incReader", "InParser", " inStream", "incParser", "outReader", "outStream", "INRead", "inStream", "INWriter", "InStream"], "line": ["text", "source", "message", "column", "lf", "char", "Line", "re", "lines", "str", "lined", "cell", "c", "frame", "model", "page", "pass", "link", "e", "i", "word", "l", "inline", "data", "record", "comment", "character", "name", "pe", "col", "lc", "cr", "number", "letter", "sl", "string", "connection", "LINE", "cl", "lin", "write", "file", "include", "part", "row", "key", "r", "entry", "id", "liner", "type", "error", "content"], "end": ["init", "create", "set", "load", "all", "info", "e", "pos", "complete", "open", "ended", "name", "End", "END", "add", "append", "stop", "begin", "en", "block", "id", "start", "ending"]}}
{"id1": "3558512", "id2": "18164929", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"serialize": ["serialization", "finalized", " serialization", "finalify", "Serialization", "serialify", "serialze", "normalze", " serializable", "erialze", "Serializable", "Serialize", " serialze", "normalized", "normalify", "Serialized", "erialization", "serializable", "serialized", "Serialify", "erializable", "finalze", "normalize", "finalize", "Serialze", "erialize"], "out": ["source", "png", "filename", "buffer", "copy", "cache", "output", "client", "archive", "page", "w", "ex", "i", "dump", "OUT", "image", "conn", "data", "writer", "loader", "io", "up", "a", "name", "server", "gen", "obj", "pool", "exec", "string", "Out", "raw", "outs", "file", "temp", "err", "o", "parent", "bin", "report", "content"], "parser": ["p", "lp", "arser", "as", "copy", "cache", "ss", "parse", "instance", "system", "seed", "master", "rar", "per", "processor", "txt", "manager", "loader", "writer", "Parser", "builder", "tt", "up", "class", "base", "pe", "server", "upload", "worker", "cp", "handler", "plugin", "wrapper", "php", "test", "file", "er", "pp", "reader", "pkg", "parent", "xml", "pillar"], "on_disk": ["onnetdrive", "onJdemand", "onJdisk", "on_storage", "onbookdisk", "off_drive", "onjdisk", "on_lock", "on_demand", "onJdrive", "onbootstorage", "onbootdrive", "onbookdrive", "on_space", "off_space", "onbootlock", "onjdrive", "onnetdisk", "on_file", "onnetfile", "on_drive", "off_delete", "onJlock", "onnetspace", "off_disk", "onjspace", "off_storage", "off_file", "off_lock", "onjfile", "onbootdisk", "onnetdemand", "onbookdelete", "on_delete", "off_demand"], "in": ["source", "as", "copy", "inn", "pin", "inner", "c", "ac", "f", "ax", "info", "pass", "i", "input", "socket", "conn", "inas", "IN", "data", "ini", "win", "con", "din", "min", "ins", "connection", "thin", "stream", "lin", "In", "inc", "again", "rin", "file", "kin", "r", "login", "o", "reader", "bin"]}}
{"id1": "19747399", "id2": "9647576", "code1": "    @Before\n    public void setUp() throws Exception {\n        connectionDigestHandler = new ConnectionDigestHandlerDefaultImpl();\n        URL url = null;\n        try {\n            url = new URL(\"http://dev2dev.bea.com.cn/bbs/servlet/D2DServlet/download/64104-35000-204984-2890/webwork2guide.pdf\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        try {\n            uc = url.openConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"setUp": [" setDown", "startUp", "setups", "Setups", " setup", "SetUp", "setup", "startups", "setDown", " setups", "startDown", "startup", "SetDown", "Setup"], "connectionDigestHandler": ["connectionDigessPath", "connectionDesterManager", "connectionDigestBase", "connectionDesterBase", "connectionDigistHandler", "connectionDigesterManager", "connectionDigessManager", "connectionDigessBase", "connectionDestPath", "connectionDigesterPath", "connectionDigestManager", "connectionDigesterHandler", "connectionDesterHandler", "connectionDesterPath", "connectionDigistPath", "connectionDestManager", "connectionDigessHandler", "connectionDigistManager", "connectionDestBase", "connectionDigesterBase", "connectionDigestPath", "connectionDigistBase", "connectionDestHandler"], "url": ["ls", "source", "result", "cache", "uri", "client", "path", "Url", "tool", "config", "f", "page", "use", "link", "e", "l", "conn", "image", "loc", "blog", "web", "service", "object", "resource", "location", "open", "www", "base", "log", "bel", "b", "server", "host", "URL", "sl", "address", "secure", "connection", "string", "channel", "ll", "impl", "bug", "ssl", "feed", "ob", "user", "db", "jar", "http"], "uc": ["org", "oc", "result", "username", "Url", "instance", "config", "bb", "tc", "https", "loc", "hub", "bc", "log", "aw", "name", "ou", "fd", "cr", "ch", "rc", "cc", "auc", "acc", "mc", "feed", "uu"]}}
{"id1": "15362793", "id2": "4716110", "code1": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"ReadURL": ["ReadHTTP", " ReadHTTP", "GetURL", " ReadString", "GetString", "GetUrl", "GetHTTP", "ReadString", " ReadUrl", "ReadUrl", "readUrl", "readURL", "readString", "readHTTP"], "url": ["source", "uri", "str", "path", "Url", "config", "this", "page", "link", "l", "conn", "image", "or", "loc", "web", "service", "resource", "io", "base", "server", "host", "URL", "sl", "address", "api", "secure", "connection", "string", "fr", "ur", "ll", "impl", "file", "bug", "err", "ssl", "twitter", "user", "jar", "http"], "textonly": [" textOnly", "textempty", "textOnly", "extOnly", "extempty", "Textempty", "TextOnly", "Textonly", " textempty", "extonly"], "uconn": ["uConn", "Uopen", "uconnect", "Ucon", "cuconnection", "UConn", "luconnect", "luconn", "Uconn", "luconnection", "luopen", "cuconn", "cuopen", "Uconnection", "ouconn", "ouConn", "cuconnect", "ucon", "uopen", "uconnection", " ucon", " uconnection", "ouconnection", "oucon", "Uconnect", " uConn"], "ucont": ["cuont", "ucouch", "uuCont", "uccouch", "uclet", "uccet", "ucent", "ucotton", "bcnt", "aucont", "acont", "ucCont", "bcront", "cuent", "cunt", "ucet", "uclouch", "unicontent", "acotton", "unicant", "uccant", "ucond", "ucontent", "uscont", "aucent", "uuont", "ucant", "unicnt", "unicouch", "uccont", "uccnt", "uscond", "ucront", "unicet", "uuotton", "aucCont", "acent", "uccront", "aucotton", "uclont", "cuotton", "ucnt", "uccontent", "aucnt", "acnt", "bcant", "uscCont", "uscotton", "unicront", "uuond", "aucond", "uclontent", "unicont", "bcont"]}}
{"id1": "2022160", "id2": "13886238", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"write": ["flow", "call", "create", "copy", "output", "set", "sync", "out", "update", "written", "lex", "store", "w", "writing", "send", "dump", "read", "process", "data", "writer", "service", "close", "kill", "open", "play", "cycle", "export", "connect", "next", "wrote", "add", "code", "exec", "writ", "append", "size", "put", "feed", "end", "pipe", "flush", "Write", "run"], "byteBuffers": [" byteCompares", " byteBuffeners", "bytesBuffapers", "byteDefers", " byteCompERS", "ByteOrdresses", "bytebuffERS", "bytesBuffelines", "ByteBuffERS", "byteIntegelines", "bytesCornests", "bytePackapers", " byteOrders", "wordBuffatters", "byteCornatters", "byteOrders", " byteOrdinals", "byteWritizers", "byteOrdresses", "bytesDefelines", "doubleBuffers", "byteOffors", "doubleBuffERS", " byteBuffares", "doubleHeadERS", "bytesBuffors", "byteBuffereners", "ByteBuffers", " byteOrderers", "byteHeadings", "byteBuffinals", "bytesAkizers", "byteAkizers", "byteIntegers", "byteInferers", "connectionbuffers", "bytesDefERS", "byteBuffizers", " byteBuffors", "byteBuilders", " byteOffers", "byteHeaders", " byteOrdlers", "byteBufferers", "byteBuffERS", "connectionBufferers", "bytebufflers", "doubleHeadings", " byteOrdiners", "bytesAkers", "wordBuffERS", "ByteBuffresses", "bytesBuffERS", "bytesDefatters", "bytesCornered", "byteBuildERS", "connectionbufferers", "byteHeadERS", "bytesPackerers", "connectionBuffeners", "byteOrdinals", "bytesAkelines", "byteChered", "bytePackERS", "byteBuffors", "byteOffERS", "byteCompers", "byteInfers", "byteWritelines", "bytebuffizers", "bytesBuffests", "bytesBuffatters", "bytebuffings", " byteOrdeners", "byteBuffiners", "doubleBuffings", " byteBuffERS", "bytebuffered", "ByteOrdERS", "bytesCorners", "byteInteginals", "byteOrderers", "byteBuffapers", "byteWriterers", "bytebuffers", "byteCornests", "byteOffers", "byteBuildatters", "byteAkors", "byteBuffresses", " byteOffters", "bytebufferers", "ByteBufflers", "byteBuilderers", "byteIntegatters", "bytePackers", " byteComplers", "byteBuffests", "byteAkelines", "bytesPackERS", " byteOffors", "bytebuffeners", "byteBuffered", "doubleHeaders", "connectionbuffeners", "byteWriters", "byteOffters", "byteBufflers", "connectionBuffERS", "byteBuffatters", "byteChings", "wordBufferers", "byteCompares", "bytesAkors", "bytesBuffers", "bytebuffters", " byteOrdERS", "doubleHeadered", "byteCornered", "byteBuffters", "doubleBuffered", "ByteOrders", "byteBuffares", "byteBufferapers", "bytesBuffizers", "bytesBuffered", " byteBuffinals", "bytebuffresses", "bytesCornatters", "byteOrdeners", "byteIntegeners", "connectionBuffers", "bytePackerers", "byteOrdERS", "byteWritors", "bytebuffors", "byteCornERS", " byteBufferers", "byteOrdapers", "byteBuffings", "byteChERS", "connectionbuffERS", "wordBuffers", "byteDefelines", "bytesPackapers", "bytebuffests", "byteCompERS", "byteComplers", " byteBufflers", "byteCornlers", "bytesBufferers", "byteBufferelines", "byteBuffererers", "byteInfERS", " byteBuffters", "byteIntegERS", " byteBuffiners", "ByteBufferers", "bytebuffinals", "byteDefatters", "byteBuffeners", "byteHeadered", "byteCornares", "bytesDefers", " byteOffERS", "bytebuffatters", "byteBufferatters", "bytebuffiners", "ByteOrderers", "byteInfatters", "byteOrdiners", "byteDefERS", "byteBufferERS", "byteWritlers", "byteBufferlers", "byteOrdlers", "byteAkers", "byteWritiners", "bytebuffelines", "byteCorners", " byteCompers", "bytesPackers", "byteBuffelines", "byteChers"], "m_initialOutBuffer": ["m_finalOutBuffer", "m_initialSocketFile", "m_finalOutBuff", "m_initialOutputFile", "m_initialSocketBuffer", "m_initialOutAddress", "m_originalOutBuffer", "m_initialOutCache", "m_initialOutputHeader", "m_finalInLine", "m_initialInCache", "m_InitialOutputLayer", "m_initialInHeader", "m_finalInMessage", "m_finalOutChannel", "m_initialOutBuff", "m_initialNewBuffer", "m_initialOutHeader", "m_initialSocketLayer", "m_initialInBuffer", "m_initialoutLine", "m_initialShortBuffer", "m_initialoutCache", "m_finalOutLine", "m_finaloutBuff", "m_initialClientLine", "m_initialOutLayer", "m_initialAuthAddress", "m_finalOutCache", "m_initialOutputMessage", "m_finalInChannel", "m_InitialOutputBuffer", "m_InitialOutBuffer", "m_finaloutFile", "m_initialInFile", "m_initialOutMessage", "m_initialClientBuffer", "m_originalOutFile", "m_finaloutChannel", "m_initialInAddress", "m_InitialOutFile", "m_finaloutBuffer", "m_InitialOutHeader", "m_initialInLine", "m_InitialOutLayer", "m_initialAuthLine", "m_initialNewFile", "m_initialClientFile", "m_initialoutBuffer", "m_initialInMessage", "m_originaloutLine", "m_initialOutLine", "m_initialAuthFile", "m_initialOutFile", "m_finalInBuff", "m_finalInFile", "m_finalOutFile", "m_initialOutputBuffer", "m_InitialOutputFile", "m_initialOutChannel", "m_finalOutMessage", "m_initialoutBuff", "m_finalInCache", "m_initialoutChannel", "m_initialNewBuff", "m_initialoutAddress", "m_initialOutputChannel", "m_initialShortCache", "m_initialClientBuff", "m_initialAuthBuffer", "m_initialOutputLayer", "m_initialSocketHeader", "m_initialInChannel", "m_initialoutFile", "m_finalInBuffer", "m_initialNewMessage", "m_originalOutAddress", "m_initialInBuff", "m_originaloutBuffer", "m_initialShortFile", "m_initialInLayer", "m_originaloutFile", "m_initialOutputBuff", "m_InitialOutputHeader", "m_originaloutAddress", "m_originalOutLine", "m_initialShortChannel"], "buffer": ["source", "message", "cache", "config", "buff", "event", "uffer", "builder", "comment", "url", "base", "null", "pool", "cur", "header", "stack", "holder", "channel", "queue", "iter", "temp", "template", "feed", "slice", "flush", "bridge", "copy", "client", "view", "phrase", "FFER", "data", "writer", "loader", "object", "binary", "worker", "layer", "batch", "table", "output", "back", "timeout", "input", "ker", "resource", "shell", "document", "limit", "bc", "array", "string", "block", "response", "reader", "engine", "re", "port", "cell", "f", "fb", "buf", "page", "console", "read", "callback", "window", "server", "transfer", "address", "Buffer", "file", "row", "wave", "er"], "buffers": ["phers", "affaches", "Buffers", "Bufferers", "ufaches", "affers", "ufers", "bufars", "Buffars", "buffors", "bufering", " bufferers", "bufferers", " buffERS", "bufors", "bufages", "bufaches", "buffering", "bufERS", "phators", "buffaches", "transformers", "affors", "transformler", "buffars", "phresses", "Buffered", "buferers", "transformERS", "bufers", " buffars", "phages", "buffresses", "bufered", "buffages", "ufering", " buffered", "bufler", "buffered", "affering", "ufors", "bufators", " buffages", "transformering", " buffresses", "bufresses", " buffler", "buffler", "buffERS", " buffering", "buffators", " buffators"], "result": ["match", "message", "ret", "re", "cache", "json", "out", "output", "session", "flash", "inner", "successful", "f", "ver", "info", "status", "date", "event", "view", "use", "success", "driver", "card", "manager", "complete", "val", "default", "or", "data", "resource", "consumer", "comment", "sr", "up", "valid", "url", "search", "runner", "function", "grade", "res", "rc", "Result", "cup", "future", "true", "acc", "winner", "test", "request", "row", "r", "results", "response", "err", "er", "rate", "user", "diff", "error", "report"], "encrypted": ["text", "secret", "source", "cache", "flash", "available", "inner", "config", "pad", "extra", "image", "padding", "loader", "interrupted", "binary", "internal", " data", "transfer", "body", "channel", "stream", "layer", "temp", "entry", "reader", "packed", "flush", "selected"]}}
{"id1": "22868825", "id2": "4458076", "code1": "    String sendRequest(String[] getVars, String[] postVars, Object[] fileVars, boolean getSessionKey) throws IOException {\n        String uri = wikiBaseURI;\n        if (getVars != null) for (int i = 0; i + 1 < getVars.length; i += 2) uri += (i == 0 ? '?' : '&') + urlEncode(getVars[i]) + '=' + urlEncode(getVars[i + 1]);\n        URL url = new URL(uri);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        if (!getSessionKey) {\n            String cookie = \"\";\n            for (String key : cookies.keySet()) cookie += (cookie.length() == 0 ? \"\" : \"; \") + key + \"=\" + cookies.get(key);\n            conn.setRequestProperty(\"Cookie\", cookie);\n        }\n        if (fileVars != null) {\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; fileVars != null && i + 2 < fileVars.length; i += 3) {\n                ps.print(\"--\" + boundary + \"\\r\\n\");\n                postFile(ps, conn, (String) fileVars[i], (String) fileVars[i + 1], (byte[]) fileVars[i + 2]);\n            }\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print(\"--\" + boundary + \"\\r\\n\" + \"Content-Disposition: \" + \"form-data; name=\\\"\" + postVars[i] + \"\\\"\\r\\n\\r\\n\" + postVars[i + 1] + \"\\r\\n\");\n            ps.println(\"--\" + boundary + \"--\");\n            ps.close();\n        } else if (postVars != null) {\n            conn.setDoOutput(true);\n            conn.setRequestMethod(\"POST\");\n            conn.connect();\n            PrintStream ps = new PrintStream(conn.getOutputStream());\n            for (int i = 0; postVars != null && i + 1 < postVars.length; i += 2) ps.print((i == 0 ? \"\" : \"&\") + urlEncode(postVars[i]) + \"=\" + urlEncode(postVars[i + 1]));\n            ps.close();\n        }\n        int httpCode = conn.getResponseCode();\n        if (httpCode != 200) throw new IOException(\"HTTP code: \" + httpCode);\n        if (getSessionKey) getCookies(conn.getHeaderFields().get(\"Set-Cookie\"));\n        InputStream in = conn.getInputStream();\n        response = \"\";\n        byte[] buffer = new byte[1 << 16];\n        for (; ; ) {\n            int len = in.read(buffer);\n            if (len < 0) break;\n            response += new String(buffer, 0, len);\n        }\n        in.close();\n        return response;\n    }\n", "code2": "    public InputStream getInputStream() throws TGBrowserException {\n        try {\n            if (!this.isFolder()) {\n                URL url = new URL(this.url);\n                InputStream stream = url.openStream();\n                return stream;\n            }\n        } catch (Throwable throwable) {\n            throw new TGBrowserException(throwable);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"sendRequest": ["createRequest", "doRequest", " sendrequest", "createCall", "sendrequest", "sendCall", "dorequest", " sendCall", "createResponse", " sendResponse", "sendResponse", "doCall", "createrequest", "doResponse"], "getVars": ["getJars", "postVariars", "postVards", "getVAR", " getVores", " getParms", "getWar", "getNars", "getJrs", "getMrs", "postVarms", "getVariARS", "getParms", "getJores", " getNars", "getPar", "getCar", "getVrs", "getVariars", "getMAR", "getNAR", "getVariards", " getVARS", " getNores", "getvARS", "getWARS", " getVrs", "postVariar", "queryVar", "queryCArgs", "getWarms", "postVarn", "getCArgs", "getVariar", "getVarn", "getJAR", "getNrs", "getvarms", "getCARS", "postVariARS", " getPars", " getVarms", "queryCars", "getVARS", "getVArgs", "getVariArgs", "queryVArgs", "getPars", " getNrs", "getVarms", "postVariarms", "getPARS", "getVar", "getvards", "getMores", "postVariarn", " getPARS", " getNAR", "getVariarn", "getMars", "postVar", "getCarms", "getvars", "queryVARS", "getvarn", "getCards", "postVARS", "getVariarms", "postVariards", "getWars", "getvar", "getCars", " getVar", " getVAR", "queryCar", " getPar", "getVores", "getNores", "getVards", "queryCARS", "queryVars"], "postVars": ["postNar", "postVariars", "postCars", "postVards", "postCards", "postWARS", "POSTCars", "postVARS", "postNars", "PostMams", "postvats", "PostMar", "postMams", "postWars", "POSTVats", "postLats", "postVams", "postVariar", "PostVar", "PostVars", "postMarms", "postWar", "postLars", "postLards", " postVARS", "postVats", "POSTCar", "postNARS", "postNats", "postVariams", "POSTVar", "postWams", " postVariARS", "postCats", "PostVams", "PostMARS", "postVariarms", " postVar", " postVats", "POSTCats", "postLar", "postVarms", "postWards", " postVariars", "postvarms", "PostVARS", "postMars", "postvar", " postVarms", "PostMars", "POSTVards", " postVariats", " postVariarms", "postvars", "POSTCards", "postWats", "postvARS", "postVariARS", "postMARS", "postCar", "postVariats", "postVar", " postVariar", "POSTVars", "postMar"], "fileVars": ["postVariars", "fileQuals", "filevARS", "fileVariarms", "fileNARS", "fileVals", "fileVarms", "formQuars", "postVels", "fileVard", "fileFels", "filevars", "postVarients", "fileQuars", " fileKar", "fileDars", "fileCents", "postNar", "fileVares", "fileQuARS", "postVariar", "fileVariars", "fileKys", "postVarials", "fileHard", "postVals", "filevels", "filevar", "postVares", "postVariARS", "postVariarts", "formVarms", "fileVels", "filePar", "fileHARS", "fileNard", "fileDar", "formVARS", "fileQuarms", "postNars", "fileKars", "fileNar", "fileFars", "fileFARS", " fileKys", "fileKarms", "fileNares", "formQuarms", "filePys", "fileKar", "fileVARS", "fileVys", "postVard", "fileHar", "postVariares", "fileQuents", " fileVar", "fileDARS", "filePars", "fileNarts", "fileCals", " fileKars", "postVar", "postVents", "fileQuarts", "formQuarts", "formVarts", "formQuARS", "formVars", "fileVar", "postVARS", "fileCars", " fileVarms", "fileVariarts", "fileCARS", "fileNars", "fileVariARS", "filevarms", "fileVents", "postNARS", " fileVys", "fileDarts", "fileVarials", "fileVariys", "fileVariares", " fileKarms", "postNard", "fileVarts", "fileParms", "filevarts", "fileVariar", "postVariels", "fileVariard", "fileVarients", "postVarts", "fileHars", "fileFar", "fileVariels"], "getSessionKey": ["getessionKey", "gotSessionKey", "gotSessionkey", " getsessionName", "getessionkey", "getSecretkey", "getSessionName", "getsessionName", "gotsessionkey", " getSessionkey", "getsessionKey", " getsessionKey", "getessionName", "gotSessionName", "getESSIONkey", "getsessionkey", "getESSIONName", "gotsessionName", "getSecretName", " getsessionkey", " getSessionName", "getSessionkey", "getESSIONKey", "gotsessionKey", "getSecretKey"], "uri": ["text", "uni", "remote", "absolute", "path", "username", "gi", "archive", " URI", "ci", "data", "location", "resource", "afi", "storage", "multi", "ip", "directory", "base", "database", "iv", "server", "URL", "ui", "post", "query", "pi", "api", "address", "term", "iri", "connection", "string", "direction", "origin", "mi", "ur", "future", "qi", "route", "cli", "href", "URI", "id", "ri", "http"], "i": ["x", "source", "init", "ai", "I", "ci", "ami", "ip", "base", "u", "li", "sp", "y", "slice", "type", "start", "ti", "d", "info", "ei", "count", "ini", "multi", "io", "iu", "bi", "g", "pi", "api", "j", "eni", "t", "cli", "mu", "id", "diff", "hi", "me", "ii", "e", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "ri", "my", "phi", "p", "uni", "z", "inner", "c", "ni", "f", "gi", "ix", "page", "ie", "l", "yi", "m", "num", "it", "ui", "oi", "index", "fi", "err", "end", "v"], "url": ["ls", "org", "cache", "client", "browser", "path", "session", "Url", "f", "bb", "page", "l", "web", "con", "object", "www", "io", "base", "log", "lc", "server", "host", "URL", "obj", "fl", "sl", "li", "connection", "channel", "fr", "ur", "ll", "file", "pull", "ssl", "user", "rel", "http"], "conn": ["p", "org", "init", "fp", "client", "out", "oss", "ctrl", "session", "sync", "net", "c", "cat", "config", "dc", "reg", "Connection", "nt", "l", "ca", "Conn", "ci", "socket", "or", "loc", "con", "close", "pg", "open", "act", "pub", "ec", "oa", "io", "n", "connect", "g", "ann", "conv", "col", "exec", "obj", "conf", "ch", "rc", "db", "connection", "h", "nc", "cur", "cp", "enc", "cl", "cm", "pr", "coll", "impl", "en", "jp", "cn", "rt", "cli", "ssl", "adj", "ct", "ctx", "cb", "co", "http"], "cookie": ["text", "secret", "char", "copy", "cache", "token", "json", "pod", "cf", "session", "clean", "cell", "c", "inner", "cat", "config", "cb", "gi", "timeout", "txt", "card", "data", "nice", "ce", "ookie", "comment", "binary", "cook", "character", "code", "label", "password", "zip", "query", "child", "string", "header", "rule", "channel", " cookies", "chain", "enc", "value", "temp", "css", "entry", "id", "type", "xml", "co", "jar", "content"], "key": ["text", "x", "secret", "kid", "char", "cy", "cache", "str", "ace", "fee", "json", "path", "cell", "field", "ry", "ask", "keys", "point", "page", "seed", "hop", "phrase", "link", "ie", "k", "item", "data", "box", "ce", "ice", "mac", "pe", "col", "code", "zip", "query", "child", "string", "rule", "exp", "prefix", "ee", "value", "part", "sign", "any", "id", "entry", "KEY", "type", "co", "Key", "pair"], "ps": ["ons", "ends", "ts", "ups", "py", "pos", "pe", "fs", "sp", "ins", "jp", "css", "properties", "pp", "pes", "http", "this", "HTTP", "po", "pse", "pps", "rs", "pa", "hes", "os", "Ps", "_", "posts", "ls", "cs", "ss", "lines", "mp", "ips", "pl", "pg", "ras", "ks", "pc", "qs", "bs", "details", "pr", "gs", "rows", "p", "aps", "tests", "eps", "pt", "Url", "pass", "per", "ds", "gets", "PS", "ws", "ms", "pas", "pers", "ports", "ops"], "name": ["access", "form", " header", "path", "title", "Name", "default", "data", " body", "resource", "comment", " filename", "description", "action", " extension", " data", "header", "size", "prefix", "block", " prefix", "value", "file", "part", "entry", "id", " compression", " Name"]}}
{"id1": "3330944", "id2": "17729554", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"extractImage": ["compractImage", "extractText", "extvertImage", "compressFile", "extractLayer", "extrateFile", "compractFile", "extractFile", "extrateImage", "extressFile", "compractText", "extrateText", "extvertText", "extvertLayer", "extvertFile", "extressImage", "extressText", "compressText", "extrateLayer", "compressLayer", "compressImage", "compractLayer", "extressLayer"], "input": ["work", "text", "source", "form", "init", "media", "current", "out", "path", "DATA", "inner", "empty", "PUT", "config", "view", "Input", "command", "i", "src", "OUT", "image", "sin", "SOURCE", "inside", "IN", "data", "amp", "ini", "img", "url", "base", "inf", "tmp", "null", "ink", "standard", "picture", "address", "rc", "string", "prefix", "qa", "API", "raw", "In", "inc", "RAW", "file", "temp", "include", "request", "pull", "id", "reader", "type", "parent", "bin", "xml", "audio", "dc"], "output": ["source", "secret", "message", "text", "filename", "result", "current", "out", "generated", "path", "config", "page", "image", "format", "resource", "document", "name", "password", "address", "string", "external", "prefix", "exit", "write", "Output", "file", "version", "temp", "response", "dir", "unit", "parent", "target", "STDOUT"], "params": ["p", "attr", "lp", "rules", "parts", "ps", "words", "json", "mm", "photos", "py", "Param", "styles", "config", "s", "Par", "param", "mos", "phrase", "processor", "options", "i", "fps", "services", "manager", "resources", "data", "names", "lis", "afi", "vs", "ras", "pixel", "si", "base", "pins", "lc", "proc", "spec", "server", "obj", "theme", "conf", "pi", "ams", "features", "api", "models", "par", "las", "details", "Parameters", "settings", "batch", "plugins", "properties", "pro", "phys", "results", "dis", "reader", "ctx", "bis", "xml", "http"], "w": ["work", "p", "sw", "widget", "out", "world", "f", "wd", "wt", "wp", "wic", "war", "hw", "writer", "m", "wi", "web", "W", "we", "kw", "ws", "wa", "wx", "aw", "fw", "wh", "worker", "rw", "nw", "write", "wm", "temp", "wb", "wave", "ow", "wl", "reader", "pipe", "xml", "wal", "wcs"], "in": ["p", "source", "init", "ani", "gin", "inn", "out", "pin", "ac", "f", "config", "ai", "ex", "i", "socket", "conn", "image", "inside", "src", "inas", "IN", "data", "m", "ini", "win", "con", "binary", "img", "n", "bin", "mc", "arin", "isin", "din", "b", "null", "vin", "nin", "min", "index", "ins", "connection", "fa", "cin", "thin", "qa", "lin", "In", "again", "rin", "file", "kin", "include", "temp", "part", "r", "cgi", "login", "ssl", "id", "cli", "err", "inc"], "dest": ["source", "doc", "style", "flat", "remote", "prop", "st", "path", "config", "home", "wd", "gui", "txt", " Dest", "de", "src", "project", "rest", "default", "loc", "folder", "resource", "done", "decl", "dep", "img", "sup", "tmp", "name", "cont", "null", "die", "destroy", "dat", "dist", "beta", "target", "comb", "di", "exit", "test", "nam", "desc", "coord", "dom", "temp", "route", "wb", "Dest", "dis", "dir", "id", "parent", "din", "d", "delete", "dc"], "bi": ["bh", "sb", " bio", "pin", "ni", "ai", "ba", "gi", "ii", "info", "bas", "ori", "vi", "i", "wei", "ci", "abi", "ini", "wi", "chi", "bid", "ib", "ga", "si", "bc", "obi", "b", "Bi", "mini", "nb", "BI", "bs", "pi", "ji", "ki", "li", "isi", "oi", "dat", "gb", "bank", "fa", "bm", "di", "agi", "qi", "oci", "eni", "umi", "cu", "xi", "fi", "cli", "mu", "zi", "bis", "bin", "ti", "phi"], "os": ["ors", "OS", "as", "cs", "dos", "ot", "so", "out", "oss", "us", "bos", "oes", "s", "i", "ds", "pos", "des", "vs", "ws", "oa", "nos", "io", "ks", "oS", "los", "ou", "cos", "is", "fs", "bs", "fits", "oos", "xs", "ios", "aos", "outs", "co", "ns", "es", "obs", "Os", "o", "osi", "ob", " bos", "oses", "ops"]}}
{"id1": "8690362", "id2": "22411381", "code1": "    public static void fileUpload() throws IOException {\n        HttpClient httpclient = new DefaultHttpClient();\n        httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);\n        HttpPost httppost = new HttpPost(postURL);\n        File file = new File(\"d:/hai.html\");\n        System.out.println(ukeycookie);\n        httppost.setHeader(\"Cookie\", ukeycookie + \";\" + skeycookie + \";\" + usercookie);\n        MultipartEntity mpEntity = new MultipartEntity();\n        ContentBody cbFile = new FileBody(file);\n        mpEntity.addPart(\"\", cbFile);\n        httppost.setEntity(mpEntity);\n        System.out.println(\"Now uploading your file into mediafire...........................\");\n        HttpResponse response = httpclient.execute(httppost);\n        HttpEntity resEntity = response.getEntity();\n        System.out.println(response.getStatusLine());\n        if (resEntity != null) {\n            System.out.println(\"Getting upload response key value..........\");\n            uploadresponsekey = EntityUtils.toString(resEntity);\n            getUploadResponseKey();\n            System.out.println(\"upload resoponse key \" + uploadresponsekey);\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"fileUpload": ["FileDownload", "urlDownload", " filePost", "FileUpload", "filePost", " fileupload", "FilePost", "fileDownload", "fileupload", "urlUpload", "Fileupload", "urlPost", " fileDownload", "urlupload"], "httpclient": ["HttpClient", "httpserver", " httpcon", "httpsClient", "httpconnection", "php24", "webClient", "httpsserver", "webconnection", "webclient", "httpClient", "Httpclient", "phpcon", "httpsclient", "Httpcon", "Http24", " httpserver", "webserver", "phpclient", "httpcon", "phpClient", "http24", "httpsconnection", " httpconnection", " httpClient", " http24"], "httppost": [" httplrest", "httphost", "httplrest", "motpppost", "httpppast", "httpposter", "httphoint", " httphort", " httpppost", " httphost", "httpspost", "httpprest", " httploint", "httppppost", "httmposter", "motpspost", "httmport", " httplost", " httppod", "httppposter", "htteppost", "htteposter", " httplod", "httmprest", "httppoint", "httpsort", "httppod", "httprest", "httippoint", "httphpost", "httplost", "httport", "httipprest", "httepost", "httippod", "httmpost", "motpsrest", "httmpod", "motppost", "httppast", "httepast", "httpport", "motpport", "httmpast", "httpsrest", "httmpoint", "httpast", "httippost", "httmppost", "httplpost", " httphpost", "httposter", "httpppost", "httphort", "motpsort", " httpport", "httploint", "httpost", " httpprest", " httppoint", " httphoint", "httplod", "httplort", "httpsost", "motpprest", "motpsost"], "file": ["p", "source", "message", "form", "filename", "buffer", "video", "media", "File", "fp", "cache", "path", "f", "model", "page", "e", "l", "image", "data", "folder", "object", "resource", "story", "FILE", "document", "url", "base", "log", "name", "b", "picture", "files", "zip", "body", "upload", "connection", "handler", "stream", "queue", "php", "part", "movie", "feed", "xml", "audio", "content", "http"], "mpEntity": ["phpEntity", "phpUrl", "upOrg", "ppEntity", " mpUrl", "upEntity", "mmContent", "phpBody", "mpContent", "MPEntity", "cpOrg", "upContent", "mmEnt", " mpOrg", "cpEntity", "MPBody", "ppContent", " mpEngine", "phpEngine", "cpContent", "mpOrg", "MPEngine", "cpentity", " mpentity", "MPEnt", "MPContent", "mmEntity", "MPUrl", "mpUrl", "ppEnt", "mpentity", "mpEngine", "upentity", " mpBody", "mpEnt", "mpBody", " mpContent"], "cbFile": ["bbEntity", "fbEntity", "CBFile", "fbFiles", "cbBody", "cbFiles", "cbfile", "bbBody", "fbFile", "bbfile", "cbEntity", "bbPart", "bbFiles", "CBFiles", "fbPart", "CBBody", "CBEntity", "fbfile", "fbBody", "cbPart", "CBfile", "CBPart", "bbFile"], "response": ["sequence", "message", "relation", "result", "output", "json", "client", "flash", "successful", "model", "page", "http", "success", "de", "tree", "image", "line", "default", "resp", "data", "service", "object", "resource", "reply", "description", "document", "server", "Response", "res", "body", "onse", "connection", "respond", "ception", "stream", "respons", "full", "received", "collection", "request", "answer", "feed", "site", "v", "error", "status", "application"], "resEntity": [" resInstance", "respEntity", "resInstance", " resEntry", "resentity", "respEntry", "resEntry", "ResEntry", "ResEnt", " resEnt", "respUnit", "resEnt", "ResInstance", "ResUnit", "Resentity", " resUnit", " resentity", "ResEntity", "respInstance", "resUnit", "respentity", "respEnt"], "uploadresponsekey": ["uploadrespvalue", " uploadrespvalue", "uploadresppart", "UploadresponseKey", "uploadresponsepart", "uploadrequestKey", "uploadrequestkey", " uploadrespkey", "uploadrespkey", "uploadrequestvalue", "uploadResponsevalue", "Uploadresponsevalue", " uploadresponsepart", "uploadrequestpart", "UploadResponsevalue", " uploadresponseKey", "UploadResponseKey", "uploadresponseKey", "uploadResponseKey", "Uploadresponsekey", "uploadResponsepart", "UploadResponsekey", " uploadresponsevalue", "uploadresponsevalue", " uploadresppart", "uploadResponsekey", "uploadrespKey", " uploadrespKey"]}}
{"id1": "21232043", "id2": "4056444", "code1": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "code2": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "label": 0, "substitutes": {"call": ["work", "copy", "output", "download", "Upload", " method", "send", " request", "process", "close", "open", " upload", "connect", "next", "url", "execute", "exec", "transfer", " invoke", " flush", "upload", "Call", " complete", "write", "request", "start", "run", " end"], "conn": ["p", "ls", "init", "fp", "uc", "client", "sync", "cf", "net", "cb", "c", "config", "ai", "f", "dc", "reg", "Connection", "nt", "po", "ca", "Conn", "ci", "socket", "loc", "loader", "con", "pg", "open", "act", "n", "connect", "url", "log", "ann", "conv", "col", "server", "exec", "conf", "ch", "api", "rc", "connection", "nc", "cc", "channel", "lock", "cp", "enc", "cm", "coll", "co", "cn", "rt", "cli", "ssl", "dn", "ct", "ctx", "db", "cmp", "http"], "fileDownloading": ["fileUploadING", "filedownloadging", "fileDownloadding", "fileUploadcing", " fileProcessting", "FileUploadING", "fileUploading", "fileSpawnancing", "fileUploadding", " fileDownloads", " fileProcessancing", "fileDownloadting", "fileSpawnging", " fileDownloadding", " fileDownloadING", "fileUploadbing", "resourceDownloadging", " fileDownloadting", "filedownloadding", " fileDownloadging", "filedownloadancing", "fileDownloadcing", " fileProcessing", "resourceDownloading", "fileMonitorcing", "fileFunder", " fileDownloadancing", "fileDownloader", "fileDownloaduing", "resourceDownloadancing", "fileDownloadING", "filePullancing", "fileReviewbing", "fileFundancing", "filedownloadting", "fileFielding", "fileReviewING", "filePullging", "fileFundting", "filedownloading", "fileUploads", "FileDownloadING", "FileUploading", "FileUploaduing", "fileReviewing", "fileFieldING", "FileUploadbing", "fileMonitors", " fileProcesser", "fileFunding", "FileDownloaduing", "filedownloadING", "fileReviewuing", "fileMonitording", "fileDownloads", "fileSpawning", "fileProcesser", "fileDownloadging", "fileDownloadbing", "fileProcessting", "FileDownloadbing", "filePulling", "fileUploaduing", "fileDownloadancing", "fileFieldding", "fileProcessancing", "FileDownloading", " fileDownloader", "filePuller", "fileMonitoring", " fileDownloadcing", "resourceDownloader", "filedownloader", "fileFieldging", "fileSpawner", "fileProcessing"], "fileWriting": ["FileSetting", "Filewriting", "filewriting", "urlLoading", "fileLoading", "resourceWrit", "ioWriting", "FileCreating", "fileWritten", "FileWriting", "mailWriter", "fileSetting", "fileWriter", " fileWriter", " fileLoading", "fwriting", "ioReading", "ioWorking", " fileReading", "fileReading", " fileWorking", "placeWriter", " fileWrit", "iowriting", "urlWriter", "placeWriting", "resourceWriter", "FileWorking", "resourceWriting", " filewriting", "fileCreating", " fileWritten", "mailwriting", "fCreating", "placeSetting", " fileSetting", "urlWriting", "mailWriting", "fileWrit", "placeWritten", "fWriting", "fWriter", "FileLoading", "mailWrit", " fileCreating", "FileWriter", "FileReading", "resourcewriting", "fileWorking", "FileWritten"], "size": ["cache", "uri", "large", "sync", "fee", "length", "clean", "empty", "SIZE", "page", "timeout", "level", "max", "count", "six", "loc", "data", "close", "storage", "Size", "speed", "limit", "si", "zero", "name", "small", "width", "low", "sized", "capacity", "code", "mini", "password", "address", "body", "time", "string", "ize", "scale", "sum", "file", "unit", "offset", "content"], "left": ["limited", "last", "own", "position", "loading", "lower", "L", "Left", "length", "available", "loaded", "led", "lo", "empty", "leave", "inner", "shift", "spread", "less", "pl", "lost", "lim", "needed", "l", "loc", "loader", "found", "ell", "missing", "limit", "next", "small", "low", "sized", "label", "fl", "child", "little", "held", "two", "coll", "second", "cl", "scale", "auto", "fail", "used", "failed", "partial", "diff", "le", "right", "la", "offset"], "chunkSize": ["chobNum", "changeLength", "chgroupize", "ChunkLength", " chacketNum", " chacketsize", "copunkSize", "coprawSize", " chunksize", "coprawsize", "chunksSize", "copunksize", "chrawsize", "chunksLen", "crgroupLength", "chunkNum", "crunkSize", "chunkssize", "changeSize", "coprawBreak", "chumpsize", "chicaLen", "crgroupSize", "crunkLength", "chicasize", "chrawSize", "crunksize", "chgroupSize", " chacketSize", "changesize", "crunkize", "Chunksize", "copunkLength", "chobSize", "chicaSize", "chobsize", "chacketNum", "chumpLength", " chunkNum", "chgroupsize", "chgroupLength", "chunksBreak", "chacketSize", "chunksize", "chicaLength", "chunkize", "chunkBreak", "chunksLength", " chunkLength", "chobLength", "copunkBreak", " chacketLength", "changeBreak", "chumpize", "chrawLength", "coprawLength", "chunkLen", "crgroupsize", "chunkLength", "crgroupize", "chunksNum", "chumpSize", "chacketLength", "chrawBreak", "chacketsize", "ChunkLen", "ChunkSize"], "downloaded": [" download", "downwritten", "uploaded", "download", "Downled", "downsloader", "uploading", "weightled", "uploader", "downsled", "weightloaded", "downsloading", "ownloaded", "downled", "ownled", " downloader", "downloader", "downsloaded", "ownloader", "weightwritten", "ownloading", "defloader", "weightload", "Download", "Downloading", "upload", "downswritten", "defloading", "defloaded", "downsload", "defload", "upled", "downloading", " downloading", "Downloader", " downwritten", "Downloaded", "ownload", " downled"]}}
{"id1": "5760649", "id2": "18097962", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"createFile": ["createContent", "saveFolder", "saveResource", "saveContent", " createContent", "CreateFile", "CreateContent", "createFolder", " createFolder", "createResource", "saveFile", " createResource", "CreateResource", "CreateFolder"], "src": ["source", "sb", "fp", "uri", "path", "username", "load", "s", "buf", "txt", "input", "resources", "loc", "data", "Source", "resource", "img", "dest", "rob", "url", "name", "proc", "obj", "files", "sel", "sit", "sl", "sc", "secure", "SourceFile", "rc", "rss", "string", "fn", "rb", "upload", "gb", "stream", "ruby", "file", "r", "ssl", "slice", "href", "cb", "content"], "filename": ["source", "uri", "fp", "output", "length", "path", "username", "feat", "ame", "f", "s", "title", "txt", "fil", "l", "loader", "location", "metadata", "resource", "which", "dll", "directory", "FILE", "url", "name", "ames", "files", "rl", "SourceFile", "string", "fn", "ename", "prefix", "Filename", "acl", "file", "utf", "route", "nil", "wb", "sf"], "fis": ["fbs", "Fiss", "fiss", "cfIS", "cfris", "FIS", " fiss", "sfis", "Fbs", "sfos", "fris", "Fos", "Fis", " fais", "Fais", "fais", "cfis", "Fris", "cfbs", "fIS", "sfris", " fIS", "cfais", "sfiss", " fbs", "cfos", " fris"], "fos": ["affis", "affios", "Fas", "bos", "sfios", "foras", "sfis", "affbos", "affos", "Fbos", "sfos", "FOS", " fops", "sfops", " fOS", "bbos", "Fos", "fbos", "bios", "Fis", "Fops", "fas", "fios", " fas", "foris", "Fios", "fOS", "bis", "fops", " fios", "foros", "forOS"]}}
{"id1": "6906419", "id2": "13152325", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["enccryptPassword", "encryptpassword", "decipherpassword", "encipherpassword", "decryptpassword", "encipherPassword", "encratePassword", "encratepassword", "decipherPassword", "decryptHash", "decryptString", "enccryptString", "decipherHash", "enccryptHash", "encryptHash", "decipherString", "encrateHash", "encipherHash", "encrateString", "decryptPassword", "enccryptpassword", "encryptString", "encipherString"], "password": ["p", "text", "secret", " passwords", "message", "buffer", "words", "token", "path", "username", "wd", "pass", "seed", "phrase", "word", "input", "project", "padding", "data", "auth", "PASS", "database", "name", "array", "sword", "address", "string", "crypt", "prefix", "confirmed", "Password", "key", "user", "pattern", "content"], "digest": ["diffester", "digeter", "Digeter", "Digester", "Digests", "DigEST", "hasheter", " digeter", "diffest", "DigText", "hashest", "digEST", "diffested", "digested", "initest", " digests", "Diger", "initText", "hashester", "diffEST", "signEST", "digText", " digEST", "digests", "diger", "initests", "signester", " diger", "Digest", "signer", " digested", "Digested", "digester", "hasher", "initEST", " digester", "signest", " digText"], "hash": ["secret", "match", "message", "mask", "history", "char", "bh", "buffer", "hed", "ashes", "cache", "cover", "check", "ash", "memory", "f", "image", "count", "build", "kh", "map", "auth", "url", "log", "array", "search", "Hash", "code", "number", "query", "sha", "hex", "address", "index", "body", "h", "header", "sum", "batch", "sh", "filter", "ha", "html", "block", "value", "version", "bug", "key", "wave", "diff", "id", "bin", "error", "handle"], "buf": ["cv", "uv", "cmp", "bh", "buffer", "sb", "ab", "fp", "uf", "out", "uc", "port", "cb", "bag", "f", "bb", "fb", "buff", "pad", "ba", "home", "config", "uber", "vr", "pb", "va", "src", "func", "data", "box", "aux", "builder", "af", "bf", "cas", "img", "url", "bc", "tmp", "b", "conv", "runner", "fw", "nb", "Buffer", "append", "rb", "cur", "bu", "queue", "coll", "vec", "cap", "wb", "ob", "pkg", "Buff", "ctx", "v", "bin", "db", "abb", "la", "abc"], "i": ["p", "x", "uni", "init", "uri", "length", "c", "f", "ai", "gi", "ii", "info", "ix", "e", "d", "ie", "l", "I", "count", "ci", "abi", "ini", "multi", "ip", "n", "iu", "io", "a", "si", "u", "b", "it", "mini", "ui", "pi", "oi", "ji", "li", "index", "j", "h", "hi", "di", "qi", "xi", "fi", "key", "mu", "slice", "o", "id", "type", "v", "ri", "ti", "phi"], "halfbyte": ["postabyte", " halfurl", "halfByte", "littlebit", "sideByte", "Halfchar", " halfchar", "quarterbytes", "halfnumber", "thirdbyte", "wardurl", "halfreference", "superchar", "quarterabyte", " halfabyte", "quarterurl", "sidereference", "littleByte", "sidebit", "thirdsecond", "postbyte", "quarterbyte", "littlebyte", " halfsecond", " halfbit", "halfsecond", "quarterByte", "halfchar", "wardbyte", "postbit", "halfbytes", "halfbit", "superbit", "thirdnumber", "sidebyte", "quarternumber", "halfabyte", "Halfbyte", "superbyte", "halfurl", "quarterbit", "wardbytes", " halfnumber", "HalfByte", " halfByte", "quartersecond", "Halfbit", " halfreference", "littlereference", " halfbytes"], "two_halfs": ["two_commonows", "two_commonrows", "two_commonions", "two_halfrows", "two_thirdrows", "two_thirdis", "two_halfis", "two_commons", "two_quarterows", "two_Halfis", "two_hatrows", "two_quarterions", "two_partis", "two_Halfrows", "two_halfbytes", "two_halfows", "two_hatows", "two_thirdbytes", "two_thirds", "two_hats", "two_hations", "two_quarters", "two_Halfbytes", "two_Halfs", "two_parts", "two_partrows", "two_quarterrows", "two_halfions", "two_partbytes"]}}
{"id1": "5977352", "id2": "9347451", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyDir", "copyfile", " copyDir", "CopyFile", "copyFiles", " copyFiles", "transferfile", "transferFile", "transferDir", "Copyfile", "CopyFiles", " copyfile", "CopyDir"], "src": ["source", "filename", "sb", "uri", "fp", "path", "config", "s", "this", "buf", "view", "input", "ource", "conn", "inst", "loc", "data", "loader", "resource", "proxy", "img", "url", "tmp", "b", "proc", "obj", "files", "sel", "sc", "sl", "dist", "rc", "rb", "ins", "gb", "stream", "file", "slice"], "dest": ["source", "cache", "output", "table", "st", "path", " destination", "config", "home", "store", "this", "master", " Dest", "txt", "d", "de", "trans", "project", "rest", "cdn", "folder", "done", "dep", "later", "img", "class", "url", "tmp", "name", "cont", "null", "die", "obj", "destroy", "zip", "dist", "cp", "thin", "orig", "desc", "file", "temp", "route", "wb", "Dest", "part", "dir", "parent", "opt", "target", "delete", "dc"], "bufSize": ["buf2", "ufSize", "bufferSize", "buffersize", " bufsize", "bufLen", "uf2", "queueSize", "ufLen", " buf2", " bufLen", "queuesize", "queueLen", "buffer2", "ufsize", "bufsize", "bufferLen"], "force": ["ride", "p", "source", "Force", "remote", "ist", "sync", "push", "dirty", "load", "forces", "front", "f", "store", "use", "place", "hard", "urse", "count", "base", "deep", "rc", "require", "write", "only", "auto", "replace", "like", "file", "parent", "forcing", "pull", "route", "id", "forced", "apply", "flush", "delete", "no"], "buffer": ["source", "result", "cache", "length", "memory", "load", "buff", "fb", "buf", "seed", "bytes", "uffer", "border", "padding", "data", "binary", "zero", "limit", "url", "base", "b", "null", "transfer", "split", "address", "append", "Buffer", "queue", "write", "raw", "batch", "reference", "iter", "value", "request", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "text", "ride", "seek", "create", "select", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "lex", "len", "use", "view", "pass", "show", "level", "READ", "i", "input", "send", "skip", "ed", "count", "k", "sleep", "ind", "data", "build", "close", "ad", "open", "play", "find", "ip", "io", "n", "connect", "next", "b", "add", " write", "allow", "exec", "reads", "index", "size", "write", "raw", "block", "iter", "wait", "feed", "id", "reader", "end", "get", "start", "d", "fill", "run"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "c", "ac", "f", "pass", "ex", "i", "input", "socket", "conn", "image", "sin", "inside", "serv", "IN", "m", "con", "win", "ini", "up", "n", "isin", "a", "url", "base", "din", "b", "nin", "min", "ins", "connection", "cin", "thin", "In", "inc", "again", "rin", "kin", "lib", "part", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "ac", "at", "home", "this", "with", "w", "ex", "i", "one", "max", "socket", "conn", "OUT", "line", "image", "by", "writer", "n", "io", "up", "bin", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "nin", "connection", "exp", "plain", "Out", "write", "outs", "again", "off", "lib", "part", "err", "key", "o", "id", "user", "inc", "co", "can", "no"]}}
{"id1": "8216539", "id2": "1357662", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentasStr", "getFileContentAsStr", "getFileContentasStream", "getFileContentInStream", "getFileContentFromString", "getFilecontentInStream", "getFileContentInText", "getFilecontentInText", "getFileContentAsStream", "getFilecontentAsText", "getFileContentAsText", "getFileContentFromStream", "getFileContentInString", "getFilecontentInStr", "getFilecontentAsString", "getFilecontentInString", "getFileContentInStr", "getFileContentFromText", "getFileContentFromStr", "getFileContentasString", "getFilecontentAsStream", "getFilecontentAsStr", "getFileContentasText"], "filePath": ["resourcePath", "basePath", "FileLocation", "fileLocation", "resourceName", "baseLocation", "FileStr", "resourceLocation", " fileStr", "FilePath", "singleLocation", "fileUrl", "Filepath", "baseUrl", "FileName", "baseStr", "fileName", "FileUrl", " filepath", "filepath", "baseName", "basepath", "fileStr", "singleUrl", "resourcepath", "singlepath", "singlePath", " fileUrl"], "encoding": ["Encging", "languageoding", "equlocking", "equoding", "decasing", "Encoding", "encoded", "encryption", "Encasing", "decoded", "enclocking", "languagelocking", "casing", "decryption", "languageging", "Encoded", "Encryption", "coding", "encpling", "languagepling", "cryption", "equging", "Enclocking", "equpling", "encging", "decoding", "Encpling", "encasing", "coded"], "testURL": ["TestURL", "testingURL", " testTL", "testRL", "testUR", " testURI", "fileURL", "shorturl", "fileURI", " testRL", "TestUR", "testurl", "testUrl", "shortUrl", "appURL", "appUrl", "Testurl", "fileUrl", "appUR", " testUrl", "testingUR", " testurl", "testTL", "shortURL", "TestUrl", "testingUrl", "testURI", "shortTL", "testingTL", "testingurl", "testingRL", "appurl", "fileRL", "testingURI"], "input": ["flow", "text", "source", "form", "init", "result", "output", "current", "out", "client", "path", "inner", "ac", "instance", "config", "dc", "through", "this", "Input", "i", "socket", "conn", "image", "inside", "data", "in", "resource", "binary", "act", "img", "bin", "error", "ink", "url", "inf", "null", "ou", "active", "exec", "api", "ack", "rc", "upload", "connection", "enc", "stream", "qa", "wrapper", "raw", "but", "acl", "element", "file", "temp", "parent", "pull", "ssl", "feed", "op", "entry", "reader", "type", "get", "inc", "xml", "audio", "http"], "sw": ["work", " SW", "rx", "sb", "fp", "rew", "wt", "w", "wp", "hw", "writer", "web", "ib", "we", "SW", "ws", "io", "sa", "ww", "wx", "sm", "aw", "tw", "cr", "sc", "wr", "sl", "rc", "sk", "now", "rw", "stream", "wrap", "nw", "wrapper", "sh", "Sw", "en", "sn", "WS", "wb", "sf", "iw", "ow", "sv", "ew"]}}
{"id1": "12097948", "id2": "19652200", "code1": "    public AsciiParser(String systemID) throws GridBagException {\n        String id = systemID;\n        if (id.endsWith(\".xml\")) {\n            id = StringUtils.replace(id, \".xml\", \".gbc\");\n        }\n        ClassLoader loader = this.getClass().getClassLoader();\n        URL url = loader.getResource(id);\n        if (url == null) {\n            throw new GridBagException(\"Cannot located resource : \\\"\" + systemID + \"\\\".\");\n        }\n        try {\n            InputStream inStream = url.openStream();\n            constraints = getLines(inStream);\n            inStream.close();\n        } catch (IOException ie1) {\n            throw new GridBagException(\"Cannot read from resource \" + id);\n        }\n    }\n", "code2": "    @Before\n    public void init() throws IOException {\n        file = new File(LOCATION);\n        url = file.toURI().toURL();\n        stream = url.openStream();\n        byteArray = IOUtils.toByteArray(new FileInputStream(file));\n        content = FileUtils.readFileToString(file);\n    }\n", "label": 0, "substitutes": {"systemID": ["sysID", "systemId", "sysName", "sysId", "SystemIDS", " systemName", "sysIDs", "classId", " systemIDS", "SystemID", "sysURI", " systemIDs", "SystemName", "SystemIDs", " systemURI", "sysRI", "systemName", "classID", "sysURL", "SystemRI", "classURI", "SystemId", " systemURL", "SystemURL", "systemURI", " systemId", "systemIDS", "systemRI", " systemRI", "classIDS", "SystemURI", "systemURL", "systemIDs"], "id": ["source", "kid", "init", "create", "uid", "style", "Id", "rid", "uri", "path", "f", "info", "i", "ident", "one", "image", "xml", "data", "in", "resource", "ad", "ip", "and", "error", "base", "name", "ide", "it", "modified", "code", "is", "address", "mid", "string", "oid", "element", "ID", "sid", "did", "pid", "value", "file", "like", "part", "key", "entry", "end", "aid", "type", "layout", "start", "ids", "http"], "loader": ["init", "util", "buffer", "loading", "cache", "Loader", "path", "loaded", "load", "system", "driver", "rar", "l", "loc", "folder", "module", "resource", "builder", "up", "class", "log", "lc", "pool", "lang", "container", "lock", "handler", "layer", "cl", "impl", "acl", "parser", "file", "er", "reader", "user", "library"], "url": ["ls", "source", "buffer", "uri", "client", "path", "Url", "download", "f", "this", "event", "il", "link", "l", "src", "image", "loc", "service", "resource", "location", "io", "base", "job", "name", "b", "server", "URL", "rl", "sl", "address", "api", "rc", "string", "rule", "fr", "ur", "stream", "coll", "lr", "ll", "impl", "file", "lib", "pull", "r", "feed", "ssl", "xml", "http"], "inStream": ["innSteam", " instream", "conString", "outSocket", "conStreamer", "outstream", "inReader", "INStreamer", "innStream", " inString", "INStream", "conStream", "inString", "INSteam", " inReader", "inputReader", "inputstream", "inStreamer", "instream", "inSteam", "Instream", "InSteam", "outSteam", "inputSteam", "inputStream", " inSteam", "innstream", "outReader", " inStreamer", "outStream", "innSocket", "InSocket", "INString", "conSteam", "inSocket", "InStream"], "constraints": ["Constrains", "Constrions", "Constraint", "constaints", "Constaint", "Constains", "Constions", "constions", "Constaints", "containts", "contains", "constrains", "constaint", "concomplaint", "concomplains", "containt", "concomplaints", "constrions", "concomplions", "constains", "contions", "constraint", "Constraints"]}}
{"id1": "12349563", "id2": "1133123", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "label": 0, "substitutes": {"resourceExists": [" fileexes", " fileexists", " resourceExits", " resourceexists", " resourceexits", " resourceExes", " resourceexistence", " resourceCompists", " resourceAbsistence", " fileExits", " resourceCompistence", " resourceAbses", " resourceAbsists", " fileExes", " resourceCompes", " fileexits", " fileExistence", " fileExists", " resourceexes", " resourceAbsits", " resourceExistence", " fileexistence", " resourceCompits"], "location": ["source", "local", "message", "filename", "position", "shape", "remote", "uri", "Location", "length", "path", "language", "point", "home", "info", "pointer", "area", "image", "localhost", "loc", "data", "folder", "object", "resource", "LOC", "directory", "description", "base", "name", "server", "host", "operation", "address", "connection", "string", "region", "layer", "provided", "reference", "file", "collection", "route", "href", "response", "layout", "type", "node", "target", "content"], "url": ["source", "uri", "path", "Url", "c", "f", "config", "page", "i", "l", "image", "build", "loc", "blog", "web", "resource", "open", "www", "io", "base", "b", "server", "host", "URL", "obj", "fl", "sl", "api", "address", "zip", "string", "connection", "ll", "impl", "file", "lib", "r", "ssl", "user", "http"], "cxn": ["crexg", "cexne", "Cxne", "cxxn", "cuxp", "Cxns", " cxp", "crexcon", " crexp", "cuxne", "cxxne", "crexp", "cdscon", "cuxns", "cexcon", " crexn", "cxg", "Cxp", "cxp", "cxcon", "cxns", "Cuxns", " crexg", "cdsp", "cdsn", "cxxp", "cxxns", "cuxn", "cexn", "cexp", " crexcon", "cexg", "cexns", "Cuxne", " cxcon", " cxg", "cxne", "Cuxn", "cdsg", "crexn", "Cxn", "Cuxp"], "is": ["x", "as", "ris", "app", "init", "internet", "uri", "IS", "out", "im", "us", "was", "isa", "oss", "ai", "info", "s", "its", "ori", "ens", "iss", "i", "Is", "src", "or", "iso", "web", "in", "close", "lis", "does", "ir", "ip", "ar", "next", "ms", "os", "cos", "it", "isc", "fs", "ui", "isl", "bs", "api", "isi", "stream", "ais", "ios", "es", "abs", "iris", "nis", "ob", "id", "bis", "get", "has", "js", "cms", "ois", "http"], "byteBuffer": ["bitBuff", "ByteArray", "ByteBuff", " byteBB", "byteBB", "bitBuffer", "ByteLength", " byteArray", "ByteBuffer", "byteArray", "bitLength", "ByteBB", "byteBuff", "byteLength", " byteBuff", " byteLength", "bitBB", "bitArray"]}}
{"id1": "442381", "id2": "14324112", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doVersioncheck", "doReleaseWork", "doReleasecheck", "doVersionTest", " doReleaseTest", "doReleaseCheck", " doReleaseCheck", "doversionTest", "doVERSIONTest", " doBuildcheck", "doReleaseTest", "doVersioncheck", " doBuildTest", " doVersionWork", "doversioncheck", "doVERSIONCheck", "doBuildWork", " doReleasecheck", "doBuildCheck", "doVersionWork", "doVERSIONcheck", "doBuildTest", " doBuildWork", "doversionCheck", " doVersionTest", " doBuildCheck", "doVERSIONWork", "doBuildcheck"], "view": ["form", "edit", "style", "app", "buffer", "cache", "widget", "port", "out", "client", "session", "cell", "update", "config", "this", "model", "View", "page", "event", "show", "e", "use", "gui", "input", "l", "image", "screen", "box", "q", "VIEW", "object", "comment", "self", "accept", "window", "display", "server", "change", "sel", "ui", "body", "see", "vis", "div", "lock", "views", "gu", "el", "full", "block", "html", "request", "row", "layout", "reader", "v", "can", "http"], "url": ["source", "buffer", "uri", "browser", "client", "path", "Url", "f", "bb", "input", "l", "socket", "image", "build", "blog", "loader", "web", "service", "resource", "open", "hub", "base", "log", "bel", "server", "host", "URL", "zip", "sl", "address", "string", "connection", "channel", "stream", "ll", "file", "lib", "ssl", "ob", "user", "http"], "in": ["source", "as", "init", "buffer", "gin", "inn", "out", "inner", "ac", "s", "i", "input", "socket", "sin", "IN", "data", "ini", "win", "con", "resource", "binary", "n", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "rin", "file", "login", "reader", "bis", "din"], "bin": ["init", "ln", "buffer", "inn", "gin", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "inline", "IN", "abi", "data", "loader", "win", "record", "con", "binary", "bot", "bi", "log", "b", "bn", "fin", "nb", "body", "lock", "cin", "lin", "spin", "ruby", "file", "kin", "lib", "part", "oin", "reader", "din", "run"], "line": ["text", "source", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "cell", "day", "load", "lo", "home", "model", "page", "pass", "link", "e", "i", "word", "l", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "valid", "base", "name", "log", "b", "lc", "job", "pe", "band", "code", "ge", "split", "letter", "string", "rule", "LINE", "el", "lin", "cl", "layer", "ine", "block", "file", "part", "row", "key", "non", "entry", "end", "le", "unit", "site", "id", "no"], "develBuild": ["deployBuild", "develBuilder", "dewardbuild", "deployBuilt", "DEvelbuild", "dewardBuilder", "desvenRun", "DEvelBuilt", "desvenBuilder", "deviousBuild", "desvelbuild", "desvelBuilder", "deVELRun", "desvelRun", "deVELBuilder", "devenBuild", "develbuild", "desvelBuild", "deVELbuild", "develRun", "desvenRelease", "DEvelBuild", "deployBuilder", "devenBuilder", "develRelease", "desvelBuilt", "deelRelease", "DEVELBuilt", "deployRun", "dellBuild", "dewardBuild", "dewardBuilt", "devenbuild", "DEVELBuilder", "desvenbuild", "dellRun", "DEVELBuild", "DEvelBuilder", "deelBuilder", "dellBuilder", "desvenBuild", "DEVELbuild", "develBuilt", "desvenBuilt", "deviousbuild", "devenBuilt", "deelBuild", "deVELBuild", "devenRun", "deelRun", "dellRelease", "deviousBuilt", "deVELBuilt", "desvelRelease", "devenRelease", "deploybuild"], "stableBuild": ["basebuild", "latestBuilder", "stablebuild", "compatibleBuild", "latestbuild", "prettyBuilder", "stableVersion", "validBuilder", "securebuild", "prettybuild", "latestBuild", "compatibleBuilder", "baseBuild", "secureBuild", "compatiblebuild", "secureBuilder", "stableBuilder", "validBuild", " stablebuild", " stableVersion", "staticbuild", "validbuild", " stableBuilder", "baseVersion", "prettyVersion", "prettyBuild", "staticBuild", "baseBuilder", "staticBuilder"]}}
{"id1": "14877116", "id2": "21999120", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 0, "substitutes": {"cpFile": [" copyFile", "cpfile", " cpfile", "CopyFile", " cpFiles", " cpCode", " copyCode", "Copyfile", "CopyFiles", " copyfile", "cpCode", "cpFiles", "CopyCode", " copyFiles"], "source": ["remote", "current", "se", "client", "token", "table", "path", "config", "this", "use", "view", "seed", "archive", "component", "ources", "ource", "image", "SOURCE", "project", "Source", "service", "object", "from", "resource", "ce", "Target", "force", "self", "dest", "directory", "document", "url", "base", "name", "subject", "database", "null", "server", "host", "zip", "secure", "grade", "scene", "string", "connection", "scope", "channel", "stream", "element", "reference", "iter", "file", "route", "slice", "template", "site", "unit", "type", "parent", "start", "node", "context"], "target": ["top", "remote", "result", "copy", "tor", "table", "current", "port", "token", "client", "path", "sync", "output", "download", "config", "alias", "home", "archive", "component", "master", "tail", "nt", "root", "owner", "to", "arget", "project", "ource", "global", "service", "object", "Target", "resource", "other", "format", "transform", "force", "self", "dest", "proxy", "director", "next", "url", "base", "name", "database", "folder", "null", "it", "server", "host", "connection", "external", "origin", "range", "reference", "iter", "file", "route", "template", "site", "boot", "type", "parent", "content"], "replace": ["match", "reset", "copy", "re", "sync", "cover", "flash", "update", "store", "use", "place", "compatible", "root", "move", "complete", "inline", "follow", "other", "force", "placed", "rm", "share", "allow", "change", "add", "multiple", "array", "split", "append", "fill", "align", "repeat", "repl", "write", "only", "range", "insert", "include", "route", "protect", "remove", "stall", "apply", "same", "delete", "hide", "rel", "reply"], "bufferSize": ["byteLen", "serverLen", " bufferCount", "bytesize", "flushSize", "buffersize", " buffersize", "queueSize", "serversize", "byteSize", "flushsize", "queuesize", "serverSize", " bufferLen", "flushLen", "queueLen", "bufferCount", "bufferLen", " bufferSIZE", "flushSIZE", "bufferSIZE", "serverSIZE", "queueCount", "byteCount"], "src": ["result", "sb", "copy", "rec", "sync", "flash", "gz", "archive", "ources", "input", "ource", "socket", "inst", "loc", "RC", "req", "Source", "sys", "in", "resource", "proxy", "sr", "dest", "reflect", "url", "tmp", "bc", "proc", "server", "obj", "sel", "sc", "zip", "sl", "secure", "sub", "rc", "rb", "cur", "fn", "gb", "stream", "sh", "sq", "ruby", "rt", "ssl", "ser", "ctx", "start", "cb"], "tarn": ["taur", " treen", "taron", "yarn", "ttarp", "ttaro", "tron", "wtern", "Treen", "ttarm", "taran", "treen", "trn", "ttern", " taron", "ttrn", "wtaran", "ntaron", "etann", " tern", "yaran", "thern", "ttann", "ntann", "ttarn", "wtarn", " tarm", "Tann", " tron", "Tarm", "tann", "tharn", "yern", "ttaron", "Trn", "tern", "taro", "Taran", " taro", "wtarm", " tarp", "ttron", "ntarp", "yarm", "ttaur", "ntarn", "tharo", " taur", "Tron", "etarn", "Tarn", "tarm", " trn", "etaran", " taran", "etreen", "tarp", " tann", "thaur"], "tardir": ["tarddir", "tardedpath", "tartdir", "tartart", "tarpirt", "tartirs", "tartire", "tartirt", "tardsar", "tarir", "tarart", "Tartir", "tardire", "tildart", "sardar", "sardirt", "tardsire", "sardsar", "Tartart", "tartar", "tardiri", "Tartiri", "tardirs", "tarpar", "tildir", "tarpire", "tartpath", "tardsdir", "Tartdir", "tardsir", "tardeddir", "tartiri", "tariri", "Tardirs", "sardire", "Tardiri", "tarar", "sardsire", "tildiri", "Tartpath", "Tardir", "Tarddir", "tardsirs", "sardsir", "tartir", "Tardpath", "Tartar", "sardsirt", "tardedir", "tardedirs", "Tardart", "tardart", "Tartirs", "Tardar", "sardir", "tardirt", "tarpir", "tildar", "tardar", "tardpath", "tardspath", "tardsirt"], "n": ["p", "x", "ln", "z", "c", "ni", "nt", "i", "e", "l", "k", "conn", "norm", "N", "nor", "none", "m", "nl", "in", "ne", "g", "nn", "u", "num", "nb", "number", "na", "nu", "j", "min", "nc", "fn", "pn", "mn", "rn", "ng", "nw", "coll", "en", "un", "sn", "ns", "cn", "dn", "o", "v", "d", " i"], "tar": ["buffer", "shape", "copy", "cloud", "large", "ray", "flash", "csv", "cat", "tc", "archive", "gz", "rar", "trans", "war", "ca", "skip", "tan", "box", "sr", "dest", "ar", "tmp", "cos", "tif", "transfer", "cr", "zip", "cro", "Tar", "tg", "dr", "par", "shr", "tf", "di", "safe", "sum", "sh", "test", "ra", "tr", "file", "temp", "pack", "sv", "raf", "jar", "car"], "bytes": ["frames", "ls", "nets", "bles", "eps", "Bytes", "ps", "words", "lines", "out", "bits", "keys", "seconds", "vals", "les", "resources", "ones", "data", "ipes", "vs", "bps", "cells", "io", "values", "pieces", "b", "os", "objects", "files", "bs", "reads", "steps", "pages", "outs", "runs", "es", "tes", "items", "classes", "boot", "blocks", "rows", "ops"], "readn": ["runns", "findne", "findN", "findn", "Readn", "writelen", "ReadN", "writen", " readl", "readN", "writene", "passns", "readno", " readlen", "Readl", "writeno", "runl", "readns", "writeN", " readN", "runlen", "runn", "runN", "readne", "Readlen", "passN", "readl", "passn", "passno", " readne", "findlen", "writens", "runno", "readlen"]}}
{"id1": "6742637", "id2": "14450108", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findextensions", "findDistension", "getextends", "findextends", "getExtensions", "getExtends", "findExtension", "getExtension", "findDistends", "getextension", "findDistensions", "findAppends", "findAppension", "findextension", "getextensions", "findExtends", "findAppensions"], "url": ["ls", "source", "org", "remote", "result", "buffer", "re", "uri", "gl", "path", "Url", "load", "config", "f", "ver", "bb", "page", "il", "link", "l", "src", "image", "loc", "data", "web", "service", "resource", "location", "io", "base", "name", "bel", "log", "server", "URL", "rl", "zip", "address", "api", "ch", "sl", "rc", "connection", "fr", "ur", "cl", "lr", "ul", "element", "impl", "coll", "html", "file", "bug", "pull", "err", "r", "ssl", "feed", "id", "entry", "rel", "http"], "extensions": ["intps", "fensions", "exensions", "Extension", "fends", "intension", "appensions", "fps", "Extencies", "intends", "xtension", "xtends", "extension", "appencies", "exras", "extras", "appras", "fension", "extps", "extencies", "exension", "xtps", "exencies", "exends", "Extras", "intensions", "exps", "xtensions", "Extensions", "appension"], "res": ["rem", "ris", "ret", "result", "ps", "re", "out", "ver", "rr", "mr", "ex", "rest", "RE", "vals", "resp", "req", "resource", "RS", "rs", "ras", "ros", "RES", "os", "ries", "hr", "is", "gr", "ch", "rc", "Rs", "rss", "rus", "fr", "pres", "details", "vers", "raw", "rez", "resolution", "rex", "ress", "Res", "es", "request", "r", "results", "response", "err", "rev", "rh", "js", "rows", "http"], "prop": ["p", "attr", "ref", "app", "style", "result", "property", "ps", "fp", "mp", "feature", "feat", "f", "config", "info", "fb", "point", "Prop", "pb", "project", "pos", "val", "data", "resource", "class", "base", "tmp", "b", "proc", "ext", "obj", "pac", "priv", "api", "term", "j", "exp", "cp", "option", "comp", "pr", "lit", "def", "properties", "pro", "key", "part", "op", "opt"], "msg": ["text", "me", "og", "message", "eg", "ug", "str", "s", "info", "title", "cmd", "sg", "agg", "rag", "cfg", "ko", "mb", "mg", "loc", "req", "m", "format", "bf", "g", "log", "ms", "reason", "Msg", "ext", "kg", "printf", "mid", "bg", "gr", "gm", "db", "string", "tag", "mn", "mt", "gs", "urg", "err", "comm", "mag", "error", "status"]}}
{"id1": "9738825", "id2": "6558022", "code1": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 0, "substitutes": {"load": ["work", "create", "init", "loading", "pload", "parse", "loaded", "check", "download", "update", "config", "use", "construct", "view", "link", "show", "e", "content", "input", "read", "process", "loader", "build", "resources", "install", "in", "resource", "open", "from", "play", "Load", "add", "execute", "oad", "upload", "loads", "raw", "full", "en", "replace", "loop", "save", "include", "pack", "get", "start", "select", "run", "LOAD"], "url": ["source", "filename", "buffer", "gl", "uri", "path", "Url", "download", "f", "config", "info", "store", "use", "link", "e", "l", "ource", "image", "loader", "data", "service", "object", "resource", "location", "email", "base", "name", "log", "server", "host", "URL", "rl", "zip", "address", "sl", "connection", "string", "ur", "element", "el", "ll", "ul", "lr", "layer", "coll", "html", "file", "route", "ssl", "id", "user", "http"], "locator": ["locationoder", "locationater", "loccer", " locale", "Loculator", " locater", " locer", "Locators", "locationators", "locationatter", "localator", "locationcer", "Locater", "Locer", " loccer", "Locatter", "Locoder", "locationator", "locationulator", " loculator", "locale", "Locator", "loculator", "locater", "Locale", "locatter", " locatter", " locators", "locationer", "locationale", "localer", "Loccer", "locators", "locer", " locoder", "localater", "localulator", "locoder"], "stream": ["source", "form", "result", "sw", "video", "media", "output", "ream", "buffer", "client", "length", "path", "flash", "clean", "port", "f", "draw", "through", "http", "view", "plus", "content", "per", "input", "trans", "socket", "draft", "control", "image", "drop", "data", "loader", "resource", "transform", "progress", "valid", "speed", "log", "null", "cont", "iv", "host", "server", "pool", "zip", "sl", "child", "ack", "upload", "string", "Stream", "channel", "stack", "coll", "handler", "wrapper", "raw", "file", "temp", "track", "row", "response", "feed", "sign", "roll", "reader", "user", "get", "can", "context", "pair"]}}
{"id1": "5760649", "id2": "10690321", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "label": 0, "substitutes": {"createFile": ["createContent", "saveFolder", "saveResource", "saveContent", " createContent", "CreateFile", "CreateContent", "createFolder", " createFolder", "createResource", "saveFile", " createResource", "CreateResource", "CreateFolder"], "src": ["source", "sb", "fp", "uri", "path", "username", "load", "s", "buf", "txt", "input", "resources", "loc", "data", "Source", "resource", "img", "dest", "rob", "url", "name", "proc", "obj", "files", "sel", "sit", "sl", "sc", "secure", "SourceFile", "rc", "rss", "string", "fn", "rb", "upload", "gb", "stream", "ruby", "file", "r", "ssl", "slice", "href", "cb", "content"], "filename": ["source", "uri", "fp", "output", "length", "path", "username", "feat", "ame", "f", "s", "title", "txt", "fil", "l", "loader", "location", "metadata", "resource", "which", "dll", "directory", "FILE", "url", "name", "ames", "files", "rl", "SourceFile", "string", "fn", "ename", "prefix", "Filename", "acl", "file", "utf", "route", "nil", "wb", "sf"], "fis": ["fbs", "Fiss", "fiss", "cfIS", "cfris", "FIS", " fiss", "sfis", "Fbs", "sfos", "fris", "Fos", "Fis", " fais", "Fais", "fais", "cfis", "Fris", "cfbs", "fIS", "sfris", " fIS", "cfais", "sfiss", " fbs", "cfos", " fris"], "fos": ["affis", "affios", "Fas", "bos", "sfios", "foras", "sfis", "affbos", "affos", "Fbos", "sfos", "FOS", " fops", "sfops", " fOS", "bbos", "Fos", "fbos", "bios", "Fis", "Fops", "fas", "fios", " fas", "foris", "Fios", "fOS", "bis", "fops", " fios", "foros", "forOS"]}}
{"id1": "16760971", "id2": "13368520", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"generateHash": ["generatesHash", " GeneratedKey", "generoseMac", " GenerateSalt", " GeneratedMac", "generoseSalt", "generatedHash", "generatesMac", "generoseHash", " GeneratedSalt", "generateSalt", " GeneratedHash", "generoseKey", " GenerateHash", " GenerateKey", "generatedSalt", "generatesKey", " GenerateMac", "generateKey", "generatesSalt", "generateMac", "generatedMac", "generatedKey"], "key": ["work", "text", "secret", "message", "char", "cy", "token", "str", "ace", "fee", "path", "keys", "point", "date", "hash", "seed", "word", "k", "data", "cert", "ce", "mac", "self", "url", "base", "name", "pe", "code", "password", "msg", "address", "hex", "proof", "body", "string", "rule", "connection", "crypt", "prefix", "full", "block", "trust", "file", "sign", "KEY", "id", "type", "user", "Key", "pair"], "md": ["me", "mand", "message", "hm", "mm", "mp", "clean", "mod", "amd", "Cmd", "hash", "wd", "dig", "cmd", "dm", "po", "ds", "mb", "mg", "m", "nm", "mage", "metadata", "mad", "ad", "mac", "editor", "bm", "rm", "sm", "ms", "mail", "nd", "pd", "dr", " MD", "ld", "di", "dd", "od", "cm", "mo", "mt", " Md", "hd", "mem", "am", "cd", "MD", "dh", "mc", "ma", "df", "mag", "pm", "d", "rpm", "bd", "dc"], "bytes": ["ls", "parts", "bles", "Bytes", "words", "lines", "bits", "ips", "keys", "fb", "s", "seconds", " bits", "vals", "les", "ones", "data", "errors", "strings", "bps", "binary", "vs", "cells", "values", "pieces", "letters", "pins", "b", "objects", "os", "files", "zip", "bs", "gb", "pages", "codes", "outs", "es", "items", "boot", "bis", "blocks", "rows", "ops"], "buff": ["app", "flat", "buffer", "sb", "uf", "fx", "py", "bag", "obb", "f", "bb", "fb", "buf", "hack", "bo", "txt", "agg", "pb", "ff", "mb", "cast", "ph", "amp", "kb", "bf", "tt", "tmp", "b", "fw", "nb", "Buffer", "append", "eb", "gb", "uff", "bm", "cp", "tf", "cpp", "batch", "html", "bug", "pp", "ob", "diff", "Buff", "ctx", "bis", "cb", "abb", "bd"], "l": ["p", "x", "ls", "lp", "ln", "L", "al", "length", "z", "kl", "c", "jl", "f", "pl", "il", "e", "i", "bl", "nl", "ell", "ol", "dl", "lb", "n", "u", "b", "lc", "col", "ly", "rl", "fl", "sl", "li", "j", "h", " L", "cl", "el", "ll", "ul", "lu", "lv", "t", "o", "le", "v", "d", "la"], "hx": ["dhx", " hxc", "hrx", "hxa", "hsrx", "Hxc", "hc", "Hrx", " hrx", "Hex", " hwx", "hsx", " hxa", "Hx", "hswx", "hwx", "dhc", " hc", " hex", "dhex", "Hc", "hex", "hsxc", "hxs", " hxs", "hmxs", "hxc", " hy", "hmy", "Hxa", "Hy", "hmx", "dhxc", "hmxa", "hy", "Hxs", "Hwx"]}}
{"id1": "21995302", "id2": "21656668", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"open": ["Open", "create", "init", "opening", "oc", "re", "set", "parse", "load", " close", "update", " opened", "use", " Open", "to", "build", "process", "close", "resource", "fix", " opening", "add", " opener", "change", "it", "initial", " transfer", " OPEN", "res", "stream", "ize", " reopen", "write", " start", "en", "un", "end", "o", "get", "start", "xml", "handle"], "input": ["text", "source", "form", "buffer", "output", "out", "client", "current", "inner", "instance", "PUT", "config", "this", "state", "event", "Input", "command", "i", "socket", "keep", "image", "data", "argument", "object", "resource", "in", "io", "accept", "class", "document", "base", "inf", "ink", "exec", "upload", "container", "connection", "stream", "element", "file", "temp", "request", "pull", "ssl", "feed", "reader", "type", "inc", "error", "audio", "context", "http"], "uri": ["source", "uni", "uid", "bridge", "result", "str", "absolute", "path", "username", "instance", "info", "gi", "state", "via", "i", " URI", "manager", "image", "ci", "data", "abi", "definition", "service", "object", "resource", "directory", "io", "next", "base", "si", "database", "document", "picture", "ui", "address", "api", "pi", "li", "iri", "ki", "string", "verb", "connection", "origin", "mi", "prefix", "di", "direction", "qi", "element", "eni", "file", "route", "cli", "response", "URI", "id", "doi", "adi", "ri", "http"], "url": ["ls", "text", "source", "ref", "char", "buffer", "browser", "path", "Url", "plug", "f", "config", "ball", "state", "link", "i", "l", "socket", "data", "resource", "io", "base", "bel", "b", "server", "URL", "sl", "address", "api", "li", "string", "connection", "channel", "stream", "layer", "coll", "impl", "file", "ssl", "feed", "ob", "id", "http"]}}
{"id1": "18544890", "id2": "23677128", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"get": ["match", "call", "create", "remote", "cache", "json", "load", "update", "download", "info", "show", "send", "data", "gets", "resource", "find", "next", "query", "list", "GET", "Get", "pull", "end", "debug", "start", "select"], "url": ["ls", "source", "uri", "str", "path", "Url", "download", "f", "date", "page", "l", "image", "loc", "service", "location", "resource", "email", "www", "base", "name", "server", "host", "URL", "address", "sl", "string", "rule", "connection", "ur", "queue", "layer", "ll", "file", "route", "key", "ssl", "feed", "href", "id", "http"], "lat": ["local", "street", "out", "port", "length", "tile", "at", "home", "alt", "point", "gal", "league", "l", "pos", "loc", "Lat", "west", "data", "location", "bot", "play", "base", "width", "address", "live", "las", "height", "range", "grid", "distance", "late", "route", "id", "game", "la", "offset"], "lon": ["ln", "position", "land", "depth", "length", "len", "lan", "level", "l", "pos", "val", "loc", "left", "nl", "location", "lb", "on", "online", "base", "log", "width", "number", "live", "lang", "vel", "layer", "ng", "lin", "range", "lag", "off", "ino", "fat", "la", "offset"], "count": ["cache", "depth", "length", "c", "load", "amount", "f", "all", "len", "timeout", "level", "scroll", "val", "found", "follow", "total", "age", "force", "n", "limit", "base", "log", "name", "num", "code", "pool", "number", "time", "index", "list", "size", "Count", "sum", "batch", "file", "more", "part", "id", "type", "error", "offset"], "req": ["work", "ref", "cache", "rr", "build", "loc", "fit", "wx", "ext", "post", "conf", "cur", "require", "cp", "jp", "fail", "ok", "def", "temp", "ctx", "fin", "sem", "orb", "http", "form", "client", "check", "ver", "reg", "conn", "qt", "pub", "io", "rob", "grad", "proc", "hr", "res", "gr", "worker", "ctr", "sq", "test", "rt", "pull", "pkg", "dq", "cb", "org", "call", "rx", "cf", "plug", "https", "socket", "serv", "next", "wa", "cook", "requ", "rb", "exp", "respond", "fr", "pr", "tr", "bur", "Request", "p", "c", "download", "f", "fb", "cmd", "resp", "q", "ru", "server", "exec", "fe", "query", "ur", "rf", "request", "r", "err"], "gl": ["gn", "ogl", "berg", "fx", "ml", "browser", "gi", "hl", "pl", "gal", "cal", "il", "view", "groups", "lim", "Gl", "console", "l", "bl", "gre", "GL", "global", "loc", "ang", "gall", "gg", "nl", "ger", "img", "g", "ga", "bel", "lc", "sel", "rl", "fl", "fe", "bg", "sl", "gm", "bs", "gb", "list", "gold", "fr", "las", "cl", "el", "ll", "coll", "ul", "gel", "go", "cm", "lol", "rg"], "br": ["bridge", "result", "bro", "bh", "arr", "str", "browser", "bar", "buf", "mr", "ler", "BR", "bl", "Br", "sr", "img", "io", "ar", "bc", "ber", "b", "hr", "cr", "ch", "res", "sp", "rb", "brush", "body", "dr", "gr", "div", "fr", "yr", "stream", "lr", "pr", "ctr", "tr", "r", "err", "reader"], "line": ["text", "source", "lf", "style", "char", "look", "Line", "lines", "str", "sync", "cell", "lo", "page", "link", "e", "word", "l", "bl", "cle", "pos", "inline", "data", "nl", "comment", "ne", "base", "log", "name", "pe", "lc", "ge", "sel", "code", "sl", "letter", "live", "string", "rule", "fr", "cl", "el", "lin", "LINE", "ine", "block", "co", "file", "row", "key", "ino", "entry", "end", "le", "unit", "jo"]}}
{"id1": "23672408", "id2": "3801655", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyiconImages", "copyImageTypes", " copyIconImages", "copyFileFiles", " copyiconTypes", "copyIconTypes", "copyImageImages", " copyIconFile", "copyIconFile", " copyIconTypes", "copyiconTypes", "copyFileFile", "copyFileTypes", "copyiconImages", "copyImageFiles", "copyiconFile", "copyIconImages", "copyiconFiles", " copyiconFiles", "copyFileImages", "copyImageFile", " copyiconFile"], "clazz": ["ploser", "hellasso", "glance", "llaz", "classe", " closer", "CLod", "Clunk", " claz", "CLaz", "closer", "helllass", "hellasse", " cllass", "fluster", "closs", "cluster", "flazz", " clunk", "clclass", "sloss", "slazz", "llazz", "slaz", "clobe", "clod", "llasso", "claz", "cllass", "hellance", "plclass", " clab", "Clclass", "plazz", "llclass", "slosed", " cluster", "sluster", "glod", "llasse", " clobe", "llobe", "glaz", " clance", "glazz", "llab", " closed", "classo", "flaz", "Cluster", " closs", " classe", "Cllass", "pllass", "CLance", "slance", "CLazz", "hellobe", "sllass", "clab", "closed", "Claz", "Closs", "hellazz", "Closer", "clunk", "clance", "Clab", " classo", "Clazz", "flunk", " clclass", "slod", "hellosed"], "i16": ["i17", "si2016", "ini2016", "l16", "i15", "l64", "ii2016", "I14", "i24", "l24", "i64", "ini14", "ini16", "int16", "io24", "ai14", "int24", "si15", "io2016", "int2016", "io15", "ai2016", "si24", "pi64", "pi16", "pi15", "si64", "ii14", "ii15", "ii24", "ii16", "si16", "si14", "pi24", "i2016", "I15", "I16", "i14", "I17", "int15", "ai15", "l15", "ini15", "ii17", "ai16", "io16", "ini17"], "fileType": [" filePath", "FileInfo", "singleTime", "playSpread", " filetype", "fileSpread", " filePatch", "imageType", "filetype", "fileState", "fileFamily", "feedPatch", "FileLike", "iconLength", " fileTy", "singleStyle", "singleType", "feedType", " fileBlock", "lettertype", "documentType", " fileLength", "documenttype", "messagePatch", "letterState", " fileFile", "fileLocation", "imageFile", " fileLike", "feedPath", "feedLike", "wordType", "fileAuth", "letterType", "messagetype", "letterSpread", "fileStyle", " fileFamily", "transferSpread", "letterBlock", "feedLocation", "iconKey", "imageStyle", "playTy", " fileLocation", "fileUnit", "imageUnit", "imageKey", " fileStyle", "FileLocation", "messageType", "wordTy", "iconTy", "wordAuth", "fileFile", " fileState", "imagePath", "FileStyle", "FileFamily", "transferTy", "transferFamily", "feedtype", "transferType", "letterFamily", "messagePath", "FileType", "fileTy", "imageTime", " fileTime", "feedInfo", "filePath", "fileTime", "playType", "fileKey", "playFamily", "fileLike", "fileInfo", " fileUnit", "iconPath", "imageFamily", " fileKey", "filePatch", "documentBlock", "FileUnit", "fileLength", "fileBlock", "iconType", "wordLength", "iconAuth", "singleFile", " fileInfo", " fileAuth", "letterTy", "iconStyle", "documentState"], "desti16": ["combi32", "combini15", "destini16", "combi16", "destI016", "targeti2016", "combini64", "destI16", "destf2016", "destabi016", "desturi32", "targeti016", "targetI2016", "destabi16", "destsi16", "desturi15", "destf16", "combini16", "destsi15", "targetI016", "desti15", "destabi15", "targetI15", "combi64", "desturi64", "destf15", "destabi2016", "desturi16", "desti016", "destI2016", "destf016", "destini15", "desti2016", "combi15", "combini32", "targeti15", "targetI16", "destini64", "destsi64", "destini32", "targeti16", "destsi32", "destI15", "desti64"], "src": ["cv", "attr", "source", "crop", "gl", "video", "ug", "uc", "config", "s", "image", "default", "loc", "hub", "dest", "url", "null", "thumbnails", "rl", "sc", "scene", "cur", "upload", "stream", "desc", "ctx", "target", "http", "uv", "bh", "uri", "sync", "ctrl", "load", "front", "gz", "view", "scenes", "root", "req", "data", "img", "rob", "grad", "tmp", "iv", "proc", "dist", "rc", "coll", "sq", "lib", "pull", "pkg", "cb", "output", "st", "back", "https", "input", "ource", "socket", "cdn", "sys", "resource", "b", "sel", "bs", "sl", "rss", "rb", "gb", "ser", "support", "filename", "download", "buf", "console", "inst", "func", "in", "sr", "conv", "secure", "usr", "file", "ssl", "r", "cmp"], "dst": ["dedst", " drd", "sdsc", " dsts", "drput", "rdput", " dsc", "dest", "adst", "Dsts", "drest", "drsc", "dST", "nst", "iddest", "ldost", "Ddr", "sdst", "sdest", "Drest", " ddest", "drST", "ldct", "Dst", "deddr", "idsl", "dedost", "nste", " dste", "dsts", "adct", "idst", "Dste", "Dput", "ldst", " dbl", "sdrd", " dsl", "dsost", "idrd", " dST", "dsput", "dsdr", "dost", "dsc", "ddr", "dsst", "adbl", "ldbl", "drd", "ddest", "dput", "idsc", "Dbl", "dedput", "rdst", "Dct", "dct", " dput", "adost", "sdsl", "nrest", "dste", " drest", "drst", "sdbl", "Dost", "sddest", "idest", "dsl", "dbl", "rdsc", " dest", "idbl", "nsts", "rdST"], "i32": ["i31", "ini22", "ui31", "in32", "si35", "si33", "si32", "i15", "ini32", "qi32", " i22", "ri32", "I35", "qi33", "iu15", "iu33", "ui30", " i42", "ui32", "ri33", "i34", "in15", "ini33", "in33", "iu32", "I31", "in34", " i35", "i33", " i31", "I34", "i30", "I30", "ri42", "i35", "ui34", "ri35", "I33", " i33", "si22", "i42", "i22", "qi34", " i30", " i34", "I42", "iu34", "qi15", "I32", "ini35"], "desti32": ["destin28", "targetiu32", "destii32", "destic15", "destii34", "destiu28", "destic22", "destic16", "destic32", " destsi32", "destiu34", "destin33", "destabi16", "destsi16", "targeti34", "desti33", "targetiu28", "destsi15", "destii28", "destiu32", "desti34", "desti15", "destabi32", "destabi15", "destin34", " desti22", " destsi15", "destabi22", " destsi16", "targetiu34", "targeti28", "desti22", "targeti32", " destsi22", "destsi22", "targeti33", "destiu33", "destin32", "destsi32", "destii33", " desti15", "desti28", "targetiu33"]}}
{"id1": "8087001", "id2": "12242903", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generateStackHeaderKey", "generateStackHeaderkey", "generatestackhashkey", "generatestackhashString", "generatestackHashString", "generateStackHashkey", "generateStackhashkey", "generateStackHashKeys", "generateStackHeaderKeys", "generateStackHashString", "generateStackhashKey", "generatestackhashKey", "generateStackHeaderString", "generatestackHashkey", "generateStackhashKeys", "generatestackHashKey", "generatestackhashKeys", "generateStackhashString", "generatestackHashKeys"], "e": ["p", "x", "est", "me", "se", "ace", "c", "f", "this", "event", "ex", "ie", "enter", "exc", "ele", "et", "oe", "ed", "E", "m", "ze", "ec", "n", "a", "b", "pe", "esi", "exec", "fe", "body", "ef", "h", "he", "ception", "element", "ee", "el", "ae", "en", "es", "ev", "t", "r", "err", "er", "o", "Exception", "error", "d", "ea"], "digest": [" digator", " digenge", "decature", "mdate", "Digusher", "Signate", "Digester", "mder", "mdested", " digher", "Signature", "Signester", "Signest", "logest", "Digenge", " Digator", " digusher", "digested", "digusher", "digge", "mdester", "digenge", "digate", "Diger", " Digest", "logher", "decest", "logester", " Digested", " Digester", "digature", "Digator", " digge", "diger", "mdenge", " diger", "Digge", "Digest", "decester", "mdature", "digator", " digested", "Digested", "decate", "mdest", "logge", "digester", " digester", "digher", "mdusher", "Digher"], "hash": ["dot", "text", "message", "history", "bh", "hed", "result", "ashes", "ash", "f", "dig", "image", "build", "kh", "data", "ph", "total", "mac", "base", "v", "array", "b", "Hash", "code", "sha", "hex", "body", "h", "string", "header", "sum", "sh", "ha", "value", "key", "her", "rh"], "rtn": ["RTnin", "RTb", "vrns", "ntc", "ortne", "txc", "ntn", "rtne", "txn", "retns", "RTns", "ntnin", "latne", "RTpn", "RTn", "retn", "rdn", "gtN", "rdns", "rtN", "rtnn", "rdN", "retN", "ntpn", "RTN", "gtn", "txN", "txnin", "rtb", "ntN", "latn", "ortN", "rdb", "RTne", "ntb", "latN", "gtpn", "RTc", "rtc", "gtb", "rtpn", "vrne", "ortnn", "vrnn", "retb", "RTnn", "ortn", "vrN", "rtns", "rtnin", "latns", "vrn"]}}
{"id1": "2668853", "id2": "13886238", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2Stream", "decodeFile2file", "decodeFiletoFiles", "decodeStringToStream", "decodeFileAsfile", "decodeStringToFiles", "decodeFileAsStream", "decodeFiletofile", "decodeFile2File", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileTofile", "decodeFiletoStream", "decodeFile2Files", "decodeString2Stream", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeStringTofile", "decodeFiletoFile", "decodeString2file", "decodeString2File"], "infile": ["infp", "outFile", "inputFile", "infiles", "outfiles", "outfilename", "minfp", " inFile", "inputfile", " infilename", "inputfilename", "inFile", "minFile", "inputfiles", "minfilename", "outfp", "inputfp", "infilename", "minfile", " infiles"], "outfile": ["infp", "outFile", "infilename", "Outfile", " outfp", " outfilename", " outfolder", "outfull", "outputfp", "Outfolder", " outFile", "outputfolder", "infolder", "outfolder", "outfilename", "outputfile", "outputfilename", " outfull", "outputfull", "OutFile", "outputFile", "outfp", "Outfull"], "in": ["source", "as", "init", "re", "gin", "inn", "pin", "inner", "ac", "f", "s", "this", "ex", "e", "i", "input", "socket", "inside", "conn", "inas", "image", "IN", "data", "m", "con", "win", "ini", "up", "a", "din", "b", "is", "nin", "min", "ins", "cin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "reader", "bin", "ic"], "out": ["work", "as", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "s", "pass", "ex", "to", "socket", "OUT", "conn", "line", "image", "writer", "other", "on", "io", "up", "base", "name", "b", "outer", "ext", "exec", "post", "obj", "exp", "lock", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "op", "o", "bin", "error", "target", "co", "no"], "buffer": ["source", "shape", "result", "length", "memory", "bb", "buff", "pad", "buf", "bytes", "seed", "input", "uffer", "padding", "border", "data", "resource", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "size", "queue", "layer", "batch", "reference", "iter", "value", "pause", "row", "wave", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "x", "current", "Read", "parse", "k", " sleep", " check", "add", " connect", "reads", "size", "write", "iter", "feed", "start", "run", "copy", "sync", "check", "load", "use", "count", "play", " find", " copy", "allow", " reach", "id", " parse", "select", "tell", "reading", "lex", "READ", "send", "input", "skip", "line", "sleep", "ind", " r", "limit", "next", " write", " use", " reader", " receive", "wait", " get", "reader", "get", "inc", "fill", " Read", "ride", "seek", "se", "length", "pass", " request", "open", "ad", "find", " send", "connect", " ride", " load", "exec", "index", "r", "end"], "success": ["ceed", "better", "fast", "result", "first", "continue", "successful", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "found", "warning", "correct", "follow", "done", "good", "accept", "zero", "valid", "job", "danger", "null", "initial", " succ", "true", "yes", "rolling", "safe", "fail", "full", "winner", "ok", "failed", "again", "value", "response", "cess", "results", "roll", "ccess", "error", "selected", "status", "content"]}}
{"id1": "23161545", "id2": "19276022", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomUid", "getRandomUUID", "getRandomGCID", "getRandGUID", "getRandGuid", "getRandGID", "getRandomGCUID", "getRandomGuid", "getRandUUID", "getRandUid", "getRandomIGID", "getRandGid", "getRandomIGid", "getRandomUuid", "getRandomGID", "getRandUID", "getRandomGCuid", "getRandomIGUID", "getRandomGid", "getRandomUID", "getRandomIGuid", "getRandomGCid", "getRandUuid"], "secure": ["secret", "remote", " insecure", "depth", "session", "config", "https", "use", "timeout", "seed", "unsigned", "service", "proxy", "ce", "stable", "weak", "force", "sr", "smart", "sec", "deep", "security", "random", "server", "allow", "host", "zip", "sensitive", "Secure", "external", "require", "confirmed", "encrypted", "safe", "pure", "secondary", "exclusive", "ssl", "protect", "debug", "active"], "md5": [" md500", "MDql", "md2", " md11", "md500", " md3", " MD11", " MD3", "cmd3", "cmdql", "md512", " mdql", "md3", " md2", "MD2", "cmd512", "MD5", "MD11", "cmd5", "mdql", "MD512", " MD500", " MD5", "md11", " md512", " MD2", "MD3", "MD500"], "sbValueBeforeMD5": ["sbValueBeforeMD1", "sbValueBeforeMD65", "sbValueBeforemd25", "sbValueAfterMD65", "sbValueBeforeMAC3", "sbValueBeforeMD7", "sbValueBeforeMS375", "sbValueBeforeMC5", "sbValueAfterMD7", "sbValueAfterMD0", "sbValueBeforeMD0", "sbValueBeforeMI5", "sbValueAfterMD95", "sbValueBeforeDER5", "sbValueBeforemd512", "sbValueBeforeSHA1", "sbValueBeforeDER3", "sbValueBeforeMD25", "sbValueAfterMD25", "sbValueBeforeMD20", "sbValueGivenMD375", "sbValueAfterMS0", "sbValueBeforeMAC55", "sbValueBeforeMD005", "sbValueAfterMS20", "sbValueGivenMD5", "sbValueAfterMS65", "sbValuebeforeMD1", "sbValueBeforeDER20", "sbValueBeforeMS3", "sbValueBeforeMR5", "sbValueBeforeMD75", "sbValueBeforeMAC5", "sbValueBeforeMS95", "sbValueBeforeMP3", "sbValueGivenMD512", "sbValueBeforeMI20", "sbValueBeforeMR3", "sbValuebeforeMD20", "sbValueBeforeSHA20", "sbValuebeforeMD005", "sbValueBeforeMS512", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeAMD1", "sbValueBeforeD75", "sbValueBeforemd75", "sbValueBeforemd95", "sbValueGivenmd512", "sbValueBeforeMD3", "sbValueBeforeMS65", "sbValueBeforeSD20", "sbValueAfterMP1", "sbValueGivenmd3", "sbValueBeforeMI3", "sbValueAfterMS95", "sbValueBeforeMS20", "sbValueBeforeMC512", "sbValueBeforeMD55", "sbValueAfterMD5", "sbValueBeforeDER55", "sbValueBeforeMI7", "sbValuebeforeSD1", "sbValueBeforeDER0", "sbValueBeforemd65", "sbValueBeforeMS1", "sbValueBeforeSHA5", "sbValueBeforemd3", "sbValueBeforeMR25", "sbValueBeforeAMD3", "sbValueBeforeD3", "sbValueAfterMS3", "sbValueAfterMS25", "sbValueBeforeMS25", "sbValuebeforeSD20", "sbValueBeforeD65", "sbValueBeforemd5", "sbValueBeforeMS5", "sbValueBeforeMP5", "sbValueGivenmd5", "sbValueAfterMD75", "sbValueBeforeMD375", "sbValueBeforeSD5", "sbValueBeforeMS75", "sbValueBeforemd375", "sbValueBeforeMP7", "sbValueBeforeDER005", "sbValueAfterMS55", "sbValueAfterMS5", "sbValuebeforeSD5", "sbValueBeforeSD005", "sbValueAfterMP7", "sbValueAfterMS75", "sbValueAfterMD20", "sbValueAfterMP3", "sbValueBeforeMS7", "sbValueBeforeAMD20", "sbValueGivenmd375", "sbValueBeforeMS55", "sbValueBeforeMI1", "sbValueBeforeMC375", "sbValueBeforeMR95", "sbValueBeforeDER1", "sbValueBeforeMS0", "sbValuebeforeMD5", "sbValueBeforeSD1", "sbValueGivenMD3", "sbValueBeforeAMD5", "sbValueBeforeMC3", "sbValueAfterMD55", "sbValueBeforeMP1", "sbValueAfterMD3", "sbValueBeforeMD512", "sbValuebeforeSD005", "sbValueBeforeSHA005", "sbValueBeforeMAC0", "sbValueBeforeMD95", "sbValueBeforeD5", "sbValueAfterMP5"], "time": ["work", "mode", "depth", "timer", "length", "date", "etime", "event", "tz", "timeout", "seed", "Time", "tim", "count", "loc", "year", "duration", "hour", "money", "speed", "TIME", "name", "random", "host", "counter", "ime", "delay", "race", "times", "size", "clock", "value", "version", "cost", "slice", "id", "rate", "type", "user", "start", "error", "offset"], "rand": ["right", "ro", "depth", "clean", "risk", "reg", "rr", "seed", "root", "Rand", "max", "raid", "rank", "count", "year", "q", "pick", "win", "bot", "round", "bit", "random", "gen", "cr", "mid", "res", "chance", "index", "rc", "delay", "rule", "lang", "min", "alpha", "ng", "range", "rage", "serial", "winner", "version", "r", "id", "rate", "type", "rh", "error", "rol", "order"], "valueBeforeMD5": ["valueBeforeAMD53", "valueInsideMD5", "valueInsideMD85", "valueBeforeMP53", "valueBeforeAMD5", "valueBeforemd3", "valueBeforemd85", "valueBeforemd5", "valueBeforeMD85", "valueBeforeAMD2", "valueInsideMD3", "valueAfterMD53", "valueAfterAMD53", "valueBeforemd2", "valueBeforeMC85", "valueBeforeMC3", "valueBeforeAMD3", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueBeforeMC5", "valueBeforeMD53", "valueBeforeMC2", "valueAfterAMD3", "valueBeforeMP2", "valueBeforeMP5", "valueInsideMD2"], "array": ["vector", "message", "app", "result", "shape", "expression", "arr", "cache", "ray", "feature", "instance", "our", "archive", "view", "area", "angle", "image", "data", "record", "object", "binary", "storage", "air", "integer", "database", "allow", "function", "number", "address", "api", "string", "list", "arrow", "element", "range", "batch", "sample", "value", "collection", "Array", "row", "any", "section", "error", "audio", "pair"], "sb": ["lp", "sbm", "bh", "buffer", "ab", "xb", "SB", "obb", "bb", "fb", "s", "buf", "lab", "bj", "sg", "pb", "src", "bl", "mb", " SB", "bp", "kb", "ib", "zb", "binary", "bf", "lb", "sth", "sa", "nn", "si", "bc", "rob", "bt", "usb", "nb", "bs", "sl", "rb", "eb", "gb", "bm", "BB", "lr", "orb", "sq", "ruby", "bsp", "wb", "sf", "ob", "sv", "cb", "abb", "stab"], "j": ["p", "x", "out", "ij", "length", "z", "br", "c", "jl", "f", "bj", "ii", "e", "i", "ie", "l", "k", "aj", "q", "n", "g", "job", "v", "jj", "num", "ja", "code", "obj", "ji", "ch", "li", "index", "dy", "jp", "pr", "y", "part", "key", "adj", "uj", "o", "end", "J", "js", "d", "jo"], "b": ["p", "x", "ab", "bar", "br", "cb", "c", "f", "bb", "fb", "e", "i", "pb", "l", "k", "mb", "B", "ib", "binary", "bf", "lb", "n", "bi", "be", "a", "bit", "bc", "job", "nb", "bs", "eb", "rb", "BB", "orb", "y", "bug", "ob", "bin", "db", "d"], "valueAfterMD5": ["valueAfterMP2", "valueAfterMP3", "valueAfterVM2", "valueAfterVM3", "valueAfterVM5", "valueAfterMD7", "valueBeforeMD7", "valueAfterAMD7", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterMP7", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueAfterVM7", "valueAfterAMD3", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMP5", "valueBeforeMP7"]}}
{"id1": "20190303", "id2": "3430784", "code1": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 0, "substitutes": {"test01_ok_failed_500_no_logo": ["test01_ok_failed_500_no__log", "test01_ok_failed_500_no1blog", "test01_ok_failed_500_NO__log", "test01_ok_failed_500_no1log", "test01_ok_failed_500_NO__ban", "test01_ok_failed_500_no1Log", "test01_ok_failed_500_NO__Log", "test01_ok_failed_500_no__ban", "test01_ok_failed_500_no__blog", "test01_ok_failed_500_no_ban", "test01_ok_failed_500_no1ban", "test01_ok_failed_500_NO_log", "test01_ok_failed_500_no_Log", "test01_ok_failed_500_no_log", "test01_ok_failed_500_NO_blog", "test01_ok_failed_500_no__Log", "test01_ok_failed_500_no_blog", "test01_ok_failed_500_NO_ban", "test01_ok_failed_500_NO_Log", "test01_ok_failed_500_NO__blog"], "client": ["p", "method", "call", "app", "cache", "uri", "port", "Client", "session", "c", "instance", "config", "tc", "this", "https", "per", "console", "manager", "conn", "socket", "web", "service", "con", "proxy", "resource", "force", "self", "connect", "class", "url", "server", "host", "pool", "child", "api", "secure", "connection", "channel", "handler", "plugin", "php", "wait", "request", "cli", "ssl", "http"], "post": ["pre", "method", "call", "copy", "set", "port", "pod", "load", "f", "head", "pass", "success", "to", "project", "build", "process", "object", "proxy", "builder", "self", "next", "server", "code", "zip", "api", "upload", "patch", "submit", "Post", "test", "php", "request", "feed", "entry", "after", "apply", "end", "POST", "posts", "http"], "response": ["message", "method", "result", "output", "json", "successful", "status", "model", "page", "view", "success", "application", "resp", "data", "throw", "service", "object", "resource", "reply", "next", "document", "server", "Response", "pool", "api", "body", "index", "onse", "connection", "respond", "respons", "request", "feed", "site", "error", "report", "http"]}}
{"id1": "9996334", "id2": "4468255", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"generateToken": ["generationToken", "generATETokens", "generationSecret", "generATEKey", "generatedSecret", "generATESecret", "generationTokens", " GenerateTokens", "generateSecret", "generateTokens", "generatedToken", " GenerATETokens", "generATEToken", " GenerATESecret", " GenerateKey", " GenerateSecret", "generatedTokens", " GenerATEToken", " GenerateToken", "generationKey", "generateKey", " GenerATEKey", "generatedKey"], "code": ["text", "source", "message", "buffer", "ode", "token", "str", "output", "cache", "script", "c", "config", "info", "hash", "state", "input", "data", "mac", "next", "name", "password", "address", "hex", "Code", "body", "string", "header", "tag", "prefix", "codes", "cod", "value", "key", "id", "content", "coded"], "md": ["mand", "mm", "mp", "mod", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "po", "ds", "mb", "meta", "ind", "mg", "m", "metadata", "ad", "mac", "editor", "grad", "rm", "sm", "ms", "kg", "pd", "sha", "gd", " MD", "od", "dd", "mo", "cm", "mt", "hd", "cd", "MD", "mc", "ma", "df", "mu", "mag", "pm", "d", "bd"], "bytes": ["parts", "bles", "Bytes", "units", "words", "output", "lines", "bits", "ips", "s", "buf", "seconds", "groups", "les", "data", "strings", "binary", "bps", "vs", "values", "pieces", "b", "objects", "files", "zip", "bs", "address", "body", "string", "codes", "outs", "es", "tes", "classes", "boot", "blocks", "bin"]}}
{"id1": "20267500", "id2": "539195", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWavfromUR", "getWaveFromURL", "getWavFromUrl", "getWavfromurl", "getWavFromurl", "getWavForUrl", "getWavForURL", "getWavFromUR", "getWavfromUrl", "getWavefromUR", "getWaveFromurl", "getWavfromURL", "getWavForurl", "getWavefromURL", "getWavefromurl", "getWavefromUrl", "getWaveFromUrl", "getWaveFromUR", "getWavForUR"], "urlstr": ["filestr", "lStr", " urlpath", "httpStr", "lSTR", "httpstr", "urlStr", "lstring", "lstr", "httpstring", " urlSTR", " urlstring", "httppath", "llSTR", "filepath", "urlstring", "urlpath", "llstr", "fileStr", "filestring", "llstring", "urlSTR", "llStr", " urlStr"], "url": ["ls", "source", "org", "oc", "uri", "str", "path", "Url", "plug", "f", "page", "e", "l", "conn", "image", "build", "loc", "resource", "www", "log", "u", "lc", "server", "b", "host", "URL", "rl", "fl", "sl", "api", "ch", "li", "cur", "connection", "string", "ur", "cl", "lr", "ll", "coll", "ul", "file", "ssl", "feed", "ob", "http"], "ais": ["ls", "ahi", "as", "ait", "ays", " tapes", "ss", " ado", "waves", "asi", "ac", "avi", "ai", "bb", "aus", "audi", "mos", "ava", "ds", "acs", "ci", "gae", " ain", "ois", "aa", "cci", "ami", "rs", "ws", "ras", "Audio", "sa", "ay", " arra", "is", "ia", "aud", "oi", "rss", " audi", " audio", "ios", "aos", "ae", "oci", " sax", " ads", "plays", "au", " au", "aaa", "xml", "audio", "ians"], "c": ["p", "cs", "client", "cf", "ctrl", "ac", "f", "http", "e", "l", "conn", "ci", "m", "con", "ec", "a", "bc", "pc", "u", "b", "lc", "C", "cr", "ch", "api", "cc", "nc", "connection", "channel", "cp", "enc", "cm", "cl", "coll", "fc", "cd", "co", "cu", "cn", "mc", "ct", "cb", "cmp", "dc"], "stream": ["p", "source", "form", "video", "sw", "cache", "output", "uc", "path", "f", "s", "w", "e", "d", "input", "l", "src", "data", "m", "in", "object", "io", "u", "b", "server", "host", "zip", "sl", "string", "Stream", "h", "channel", "connection", "cm", "coll", "fc", "feed", "uu", "reader", "engine", "audio", "context"]}}
{"id1": "18989018", "id2": "22611968", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"doSetInput": [" doGetInput", " doSetContent", "dosetOutput", "dosetContent", "doGetContent", "doGetOutput", " doGetOutput", "doSetOutput", "doProcessInput", " doSetText", "dosetInput", " doGetText", "doGetInput", "doProcessOutput", "doProcessContent", "doProcessText", " doGetContent", " doSetOutput", "doSetContent", "doSetText", "doGetText", "dosetText"], "input": ["text", "form", "method", "util", "select", "remote", "expression", "output", "current", "client", "session", "inner", "field", "instance", "config", " inputs", "model", "head", "view", "Input", "command", "enter", "image", "present", "project", "install", "IN", "magic", "definition", "agent", "q", "argument", "act", "resource", "storage", "operator", "progress", "img", "error", "inf", "initial", "null", "exec", "child", "upload", "container", "list", "element", "submit", "raw", "impl", "parser", "insert", "request", "pull", "temp", "key", "entry", "reader", "type", "inc", "xml", "audio", "context", "active"], "monitor": ["p", "method", "meter", "summary", "out", "timer", "client", "pin", "mod", "config", "system", "state", "param", "timeout", "processor", "watch", "dm", "console", "manager", " monitors", "condition", "loader", "m", "module", "resource", "metadata", "progress", "mx", "directory", "callback", "subject", "counter", " Monitor", "mon", "channel", "mi", "Monitor", "bm", "handler", "cm", " monitoring", "wm", "mc", "reader", "unit", "pm", "report"], "root": ["work", "p", "remote", "result", "media", "output", "table", "out", "cover", "instance", "config", "home", "system", "this", "store", "archive", "slave", "owner", "manager", "src", "tx", "or", "process", "writer", "m", "folder", "resource", "Root", "location", "storage", "n", "directory", "base", "array", "null", "server", "host", "container", "target", "region", "plugin", "mount", "collection", "r", "parent", "node", "cms", "roots", "library", "http"], "format": ["form", "style", "filename", "util", "output", "FORM", "feature", "f", "config", "at", "model", "title", "event", "image", "et", "data", "magic", "writer", "service", "object", "location", "record", "transform", "act", "class", "base", "name", "spec", "Format", "function", "term", "api", "string", "fn", "handler", "element", "plugin", "filter", "parser", "attribute", "temp", "version", "template", "atter", "unit", "type", "ant", "pattern"], "source": ["text", "remote", "result", "output", "token", "client", "session", "inner", "instance", "config", "info", "component", "view", "use", "via", "driver", "src", "ource", "image", "SOURCE", "data", "Source", "service", "object", "resource", "proxy", "storage", "description", "spec", "secure", "container", "string", "connection", "scope", "channel", "size", "rule", "reference", "slice", "id", "reader", "unit", "rate", "parent", "node", "target", "content"], "in": ["text", "init", "buffer", "gin", "out", "session", "config", "image", "con", "isin", "name", "ins", "In", "slice", "inn", "token", "pin", "i", "conn", "or", "IN", "data", "ini", "win", "img", "n", "io", "nin", "include", "pull", "id", "parent", "bin", "str", "update", "socket", "ource", "resource", "from", "is", "container", "element", "value", "version", "login", "reader", "get", "din", "inc", "doc", "p", "inner", "c", "download", "f", "pass", "src", "inside", "read", "m", "on", "it", "min", "body", "index", "connection", "again", "r", "err"], "path": ["work", "text", "remote", "out", "session", "config", "alias", "PATH", "image", "loc", "location", "directory", "core", "base", "name", "log", "code", "true", "key", "template", "dir", "slice", "type", "pattern", "token", "sync", "this", "model", "component", "ath", "one", "data", "loader", "object", "binary", "password", "api", "thin", " Path", "mount", "id", "parent", "method", "str", "Path", "point", "link", "folder", "resource", " filename", "container", "string", "value", "step", "reader", "node", "content", "p", "filename", "port", " string", "pointer", "src", "host", "child", "index", "full", "route", "part", "walk"], "s": ["p", "ls", "sb", "ps", "ss", "sync", "session", "c", "f", "store", "sym", "e", "i", "l", "services", "src", "ds", "an", "m", "sys", "folder", "service", "ws", "storage", "n", "g", "sa", "si", "b", "share", "spec", "os", "fs", "sl", "secure", "stores", "h", "scope", " storage", "gs", "settings", "ns", "space", "abs", "sharing", "r", "ssl", "slice", "sf", "o", "sv", "S", "v", "js", "d", "http"], "file": ["p", "Image", "x", "filename", "remote", "copy", "File", "fp", "port", "output", "media", "f", "info", "store", "archive", "use", "il", "ile", "e", "l", "image", "xml", "data", "folder", "object", "resource", "binary", "open", "storage", "up", "directory", "FILE", "io", "base", "name", "b", "pe", "files", "string", "fn", "future", "full", " File", "value", "lib", "feed", "dir", "slice", "sf", "unit", "icon", "section", "node", "audio", "content"], "uri": ["text", "uni", "uid", "filename", "util", "username", "Url", "gi", "i", " URI", "image", "data", "abi", "service", "object", "location", "resource", "storage", "io", "base", "name", "database", "server", "URL", "ui", "query", "pi", "api", "address", "term", "iri", "connection", "rule", "prefix", "qi", "handler", "range", "attribute", "route", "cli", "dir", "URI", "id", "entry", "ri", "http"], "url": ["text", "ref", "str", "Url", "config", "store", "link", "l", "src", "ource", "image", "data", "object", "resource", "location", "sr", "io", "base", "name", "URL", "address", "sl", "string", "channel", "fr", "layer", "ul", "ssl", "key", "id", "user", "ri", "rel", "http"], "cd": ["CE", "cy", "cs", "CR", "md", "xc", "cf", "clean", "c", "lab", "de", "ca", "ds", "ci", "DC", "ce", "CD", "vd", "C", "CC", "cr", "nd", "pd", "gd", "dr", "rc", "cc", "arch", "cp", "dd", "cm", "co", "def", "xd", "CS", "ct", "cand", "ck", "cb", "d", "CF", "dc"], "valid": ["local", "Invalid", "normal", "style", "current", "Valid", "available", "empty", "successful", "all", "compatible", " invalid", "vals", "visible", "val", "present", "defined", "data", "required", "vari", " Valid", "allowed", "cert", "missing", "stable", "supported", "good", "multi", "VAL", "complete", "array", "standard", "multiple", "post", "secure", "list", "regular", "full", "legal", "iter", "bad", "value", "def", "sign", "id", "acceptable", "broken", "v", "correct", "pattern", "active"], "stream": ["flow", "message", "form", "video", "sw", "output", "client", "clean", "model", "content", "trans", "image", "read", "data", "writer", "object", "resource", "transform", "body", "container", "string", "Stream", "channel", "handler", "raw", "serial", "temp", "row", "feed", "response", "reader", "v", "draw", "context"], "document": ["text", "style", "filename", "video", "media", "output", "author", "system", "model", "this", "ocument", "image", "material", "data", "writer", "Source", "record", "object", "resource", "metadata", "description", "io", "Document", "Filename", "_", "Reader", "collection", "response", "template", "feed", "reader", "parent", "xml", "doc", "content"]}}
{"id1": "19868933", "id2": "5414088", "code1": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFromFileToFileUsingNIO": ["copyFromFileToFileUsingnFile", "copyFromFileToFileUsingnIO", "copyFromFileToFileWithFileChannel", "copyFromFileToFileWithNio", "copyFromFileToFileUsingNFile", "copyFromFileToFileUsingNio", "copyFromFileToFileUsingNetChannel", "copyFromFileToFileUsingNChannel", "copyFromFileToFileWithNIO", "copyFromFileToFileWithNFile", "copyFromFileToFileWithFileFile", "copyFromFileToFileWithFileio", "copyFromFileToFileWithNChannel", "copyFromFileToFileUsingFileio", "copyFromFileToFileUsingFileChannel", "copyFromFileToFileUsingnio", "copyFromFileToFileUsingNetIO", "copyFromFileToFileWithFileIO", "copyFromFileToFileUsingFileIO", "copyFromFileToFileUsingNetio", "copyFromFileToFileUsingNetFile", "copyFromFileToFileUsingFileFile", "copyFromFileToFileUsingnChannel"], "inputFile": [" inputfile", "InputFile", "sourceDir", "imagefile", "imageFile", "InputDirectory", " inputDir", "sourceDirectory", "inputDir", " inputDirectory", "inputDirectory", "InputStream", " inputStream", "outputStream", "inputfile", "outputfile", "inputStream", "sourceStream", "InputDir", "sourceFile", "imageStream", "imageChannel"], "outputFile": ["OutputStream", "outputPath", " outputfile", "targetfile", "outputDirectory", " outputStream", "targetDirectory", "inputDirectory", " outputFiles", "targetFiles", "inputPath", "targetFile", "Outputfile", "outputStream", "outputfile", " outputDirectory", "targetPath", "OutputFile", "inputStream", "OutputFiles", "targetStream", "outputFiles", " outputPath"], "inputChannel": ["InputFile", "httpChan", "httpChannel", "InputChannel", "Inputchannel", "httpCh", "inputChan", " inputchannel", "outputListener", " inputSocket", "outputchannel", "httpSocket", "inputSocket", "parentChannel", " inputChan", "InputSocket", "InputStream", "parentSocket", " inputStream", "outputCh", "outputStream", "InputListener", "parentFile", " inputListener", "inputStream", "InputChan", "parentChan", "outputChan", "InputCh", "inputCh", "outputSocket", "inputListener", "parentStream", "inputchannel"], "outputChannel": ["outSocket", "OutputStream", "outputConnection", "inputChan", "inputConnection", " outputStream", "OutputChan", "outputStream", "OutputConnection", " outputChan", "OutputSocket", "outChannel", "OutputFile", " outputConnection", "inputStream", "OutputChannel", " outputSocket", "outChan", "outputChan", "outStream", "outputSocket"]}}
{"id1": "494226", "id2": "4164833", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"linesep": [" linespace", "linyp", "linseps", "linesupp", " linespec", "nseps", "linerspec", "linsep", "linespace", "ineseper", "codesew", " lineseps", "timespe", "linerseps", "linep", "linersep", "lineseps", "gesep", "linerseter", "linespec", "timeseps", "linpace", "lineseng", "linerseng", "codesip", "linespe", "nseper", "linesew", "linedew", "gesyp", "linesip", "lineseper", "linspec", " linesaper", "ringspec", "linesaper", "gespe", "nsep", "inesaper", "lineps", "linseter", "linspace", "linesyp", "lineeps", "linsew", "ringspace", "timesep", "linesearch", "linersip", "lineep", "ineseps", "lineearch", "linedep", "linpe", "ringsep", "lineseter", "linersew", "linedip", "inesep", " lineseter", " linesew", "linepace", " linesearch", "linepec", "linseng", "codesep", "codeseps", "timesyp", " lineseper", "lineupp", "geseps", "linersearch", "linedeps", "ringsupp", "linpec", " lineseng", "nsaper", " linesupp"], "fos": ["foS", " foser", "Fats", "FOS", " fops", "pos", "Fes", "zol", " fats", "pols", "Fis", " foes", "zos", "gocks", "fios", "Foser", "zotes", " fios", "poos", "fes", "go", "forOS", "fingocks", "infos", "eol", " foses", "infios", "loados", "Fo", "info", "coos", "foos", "fol", "fingos", "infis", "cols", " fes", "infoos", "fo", "infotes", "cos", "fulloes", "Focks", "infols", "fulloser", " foS", "Fios", "loadops", "fols", "foros", " fOS", " fis", "foss", "foes", " fOs", "Foss", "infoes", "foser", "FOs", "forats", "Fos", "gos", "zo", "eos", "fis", "fullis", "fOS", "fats", "foses", "Foes", "coes", "FoS", "foroses", "infops", "Foses", "infoses", "Fops", "goss", "poes", "loadoS", "fotes", " fo", "eotes", "fingo", "fingoss", "fullos", "infes", "loadOs", "infol", "fops", "fOs", "eo", "focks"], "files": ["ls", "workers", "tests", "rules", "tools", "apps", "locks", "lines", "jobs", "bugs", "keys", "f", "groups", "scenes", "l", "services", "books", "projects", "resources", "balls", "data", "iles", "names", "strings", "lets", "archives", "objects", "boxes", "docs", "thumbnails", "fs", "facts", "members", "bs", "features", "Files", "ins", "models", "states", "pages", "plugins", "users", "file", "headers", "results", "obs", "items", "classes", "ports", "blocks", "events", "ids", "images", "rows", "http"], "i": ["p", "uri", "current", "z", "inner", "c", "f", "ai", "gi", "ii", "info", "ix", "e", "d", "ie", "I", "count", "ci", "yi", "m", "ini", "multi", "ip", "iu", "io", "si", "b", "u", "it", "col", "ui", "pi", "oi", "ji", "index", "li", "j", "hi", "di", "qi", "eni", "y", "xi", "fi", "t", "slice", "id", "type", "v", "start", "ri", "ti", "phi"], "metaprops": ["metapprop", "metaprop", "metoprops", "metapPropps", "metapprope", "metaprobpe", "metopropp", "metaprobps", "metoppropps", "metaprobpps", "metaprobpp", "meteprope", "metaprobpes", "metepprope", "metoprope", "metaprps", "metaprospps", "metepropps", "metaparpps", "metapprops", "metopropps", "metopproperties", "metoppropes", "metaporepe", "metappropps", "metapPropes", "metaprobp", "metapropp", "meteppropes", "metaprpes", "metoppropp", "metopprop", "metopropes", "metaprosps", "metaparpp", "meteppropps", "metapPrope", "metopprops", "metoproperties", "metappropp", "metapropps", "metaporeps", "metapproperties", "metaparp", "metepropes", "metaprobperties", "metaprosperties", "metaprope", "metaporepes", "metaprpe", "metaparps", "metappropes", "metapropes", "metapProps", "metaporepps", "metaproperties", "metoprop", "metepprops", "metaprospes", "meteprops", "metaprpps", "metopprope"], "itsect": ["litrupt", "itsection", "itssect", "itrupt", "itect", "Itna", " itrupt", "Itsection", "itssection", "iterconnect", "Itsect", "Itsector", "itersect", "iterect", "Itect", "litsect", "iterrupt", " itsection", " itect", " itconnect", "litna", " itna", "itsector", "itconnect", "itssector", "Itconnect", "litect", "itna", "Itrupt", " itsector"], "section": ["account", "text", "closure", "sector", "set", " sections", "script", "config", "environment", "page", "ection", "ie", "area", "line", "loc", "year", "service", "sect", "ect", "description", "division", "job", "sections", "name", "sec", "array", "search", "sub", "function", "child", " subsection", "rc", "j", "header", "string", "esc", " Section", "element", "mission", "second", "protection", "version", "edition", "part", "step", "key", "route", "entry", "ion", "vision", "Section"]}}
